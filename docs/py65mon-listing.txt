
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Tue Apr 11 11:18:51 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000					ram_start = $0000          ; start of installed 32 KiB of RAM
=32767					ram_end   = $8000-1        ; end of installed RAM
=$0000					zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f					zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100					stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744					hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000					user0     = zpage            ; user and system variables
=$ff					rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff					bsize     = $ff              ; size of input/output buffers
=512					buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768					cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744					cp_end    = hist_buff        ; Last RAM byte available for code
=$ff					padoffset = $ff              ; offset from CP to PAD (holds number strings)
=["ed","editor","ramdrive","block","environment?","assembler","wordlist"]
					TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]

;******  Processing file: platform/../taliforth.asm

.8000					code0:

;******  Processing file: platform/../definitions.asm

=0					cp        = user0+0   ; Compiler Pointer
=2					dp        = user0+2   ; Dictionary Pointer
=4					workword  = user0+4   ; nt (not xt!) of word being compiled, except in
=6					insrc     = user0+6   ; input Source for SOURCE-ID
=8					cib       = user0+8   ; address of current input buffer
=10					ciblen    = user0+10  ; length of current input buffer
=12					toin      = user0+12  ; pointer to CIB (>IN in Forth)
=14					ip        = user0+14  ; Instruction Pointer (current xt)
=16					output    = user0+16  ; vector for EMIT
=18					input     = user0+18  ; vector for KEY
=20					havekey   = user0+20  ; vector for KEY?
=22					state     = user0+22  ; STATE: -1 compile, 0 interpret
=24					base      = user0+24  ; number radix, default decimal
=26					nc_limit  = user0+26  ; limit for Native Compile size
=28					uf_strip  = user0+28  ; flag to strip underflow detection code
=30					up        = user0+30  ; User Pointer (Address of user variables)
=32					status    = user0+32  ; internal status information
=34					tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
=36					tmp1      = user0+36  ; temporary storage
=38					tmp2      = user0+38  ; temporary storage
=40					tmp3      = user0+40  ; temporary storage (especially for print)
=42					tmpdsp    = user0+42  ; temporary DSP (X) storage (two bytes)
=44					tmptos    = user0+44  ; temporary TOS storage
=46					editor1   = user0+46  ; temporary for editors
=48					editor2   = user0+48  ; temporary for editors
=50					editor3   = user0+50  ; temporary for editors
=52					tohold    = user0+52  ; pointer for formatted output
=54					scratch   = user0+54  ; 8 byte scratchpad (see UM/MOD)
=120					dsp0      = zpage_end-7    ; initial Data Stack Pointer
=0					blk_offset = 0        ; BLK : UP + 0
=2					scr_offset = 2        ; SCR : UP + 2
=4					current_offset = 4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
=5					num_wordlists_offset = 5
=6					wordlists_offset = 6  ; WORDLISTS (cells) : UP + 6 to UP + 29
=30					num_order_offset = 30 ; #ORDER (byte) : UP + 30
=31					search_order_offset = 31
=12					max_wordlists = 12    ; Maximum number of wordlists supported
=40					blkbuffer_offset    = 40   ; Address of buffer
=42					buffblocknum_offset = 42   ; Block number current in buffer
=44					buffstatus_offset   = 44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
=46					blockread_offset    = 46   ; Vector to block reading routine
=48					blockwrite_offset   = 48   ; Vector to block writing routine
=$03					AscCC   = $03  ; break (CTRL-c)
=$07					AscBELL = $07  ; bell sound
=$08					AscBS   = $08  ; backspace
=$0a					AscLF   = $0a  ; line feed
=$0d					AscCR   = $0d  ; carriage return
=$1b					AscESC  = $1b  ; escape
=$20					AscSP   = $20  ; space
=$7f					AscDEL  = $7f  ; delete (CTRL-h)
=$10					AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e					AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1					CO = 1  ; Compile Only
=2					AN = 2  ; Always Native Compile
=4					IM = 4  ; Immediate Word
=8					NN = 8  ; Never Native Compile
=16					UF = 16 ; Includes Underflow Check (RESERVED)
=32					HC = 32 ; Word has Code Field Area (CFA)
=79					MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm

.8000					forth:

;******  Processing file: platform/../native_words.asm

.8000					xt_cold:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 10		sta $10		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 11		sta $11		                sta output+1
.8009	a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b					_load_zp_loop:
.800b	bd c5 80	lda $80c5,x	                lda cold_zp_table,x
.800e	95 00		sta $00,x	                sta zpage,x
.8010	ca		dex		                dex
.8011	d0 f8		bne $800b	                bne _load_zp_loop
.8013	ad c5 80	lda $80c5	                lda cold_zp_table
.8016	85 00		sta $00		                sta zpage
.8018	a2 ff		ldx #$ff	                ldx #rsp0
.801a	9a		txs		                txs
.801b	a2 78		ldx #$78	                ldx #dsp0
.801d	a0 31		ldy #$31	                ldy #cold_user_table_end-cold_user_table-1
.801f	a9 00		lda #$00	                lda #0
.8021					_load_user_vars_loop:
.8021	b9 e7 80	lda $80e7,y	                lda cold_user_table,y
.8024	91 1e		sta ($1e),y	                sta (up),y
.8026	88		dey		                dey
.8027	d0 f8		bne $8021	                bne _load_user_vars_loop
.8029	ad e7 80	lda $80e7	                lda cold_user_table
.802c	92 1e		sta ($1e)	                sta (up)
.802e	20 5d 89	jsr $895d	                jsr xt_cr
.8031	ca		dex		                dex
.8032	ca		dex		                dex
.8033	ca		dex		                dex
.8034	ca		dex		                dex
.8035	a9 56		lda #$56	                lda #<forth_words_start
.8037	95 02		sta $02,x	                sta 2,x
.8039	a9 bb		lda #$bb	                lda #>forth_words_start
.803b	95 03		sta $03,x	                sta 3,x
.803d	a9 27		lda #$27	                lda #<forth_words_end
.803f	38		sec		                sec
.8040	e9 56		sbc #$56	                sbc #<forth_words_start
.8042	95 00		sta $00,x	                sta 0,x
.8044	a9 bc		lda #$bc	                lda #>forth_words_end
.8046	e9 bb		sbc #$bb	                sbc #>forth_words_start
.8048	95 01		sta $01,x	                sta 1,x
.804a	20 cf 90	jsr $90cf	                jsr xt_evaluate
.804d	ca		dex		                dex
.804e	ca		dex		                dex
.804f	ca		dex		                dex
.8050	ca		dex		                dex
.8051	a9 27		lda #$27	                lda #<user_words_start
.8053	95 02		sta $02,x	                sta 2,x
.8055	a9 bc		lda #$bc	                lda #>user_words_start
.8057	95 03		sta $03,x	                sta 3,x
.8059	a9 29		lda #$29	                lda #<user_words_end
.805b	38		sec		                sec
.805c	e9 27		sbc #$27	                sbc #<user_words_start
.805e	95 00		sta $00,x	                sta 0,x
.8060	a9 bc		lda #$bc	                lda #>user_words_end
.8062	e9 bc		sbc #$bc	                sbc #>user_words_start
.8064	95 01		sta $01,x	                sta 1,x
.8066	20 cf 90	jsr $90cf	                jsr xt_evaluate
.8069	9c 00 7c	stz $7c00	                stz hist_buff
.806c	9c 80 7c	stz $7c80	                stz hist_buff+$80
.806f	9c 00 7d	stz $7d00	                stz hist_buff+$100
.8072	9c 80 7d	stz $7d80	                stz hist_buff+$180
.8075	9c 00 7e	stz $7e00	                stz hist_buff+$200
.8078	9c 80 7e	stz $7e80	                stz hist_buff+$280
.807b	9c 00 7f	stz $7f00	                stz hist_buff+$300
.807e	9c 80 7f	stz $7f80	                stz hist_buff+$380
.8081					xt_abort:
.8081	a2 78		ldx #$78	                ldx #dsp0
.8083					xt_quit:
.8083	8a		txa		                txa             ; Save the DSP that we just defined
.8084	a2 ff		ldx #$ff	                ldx #rsp0
.8086	9a		txs		                txs
.8087	aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8088	64 0e		stz $0e		                stz ip
.808a	64 0f		stz $0f		                stz ip+1
.808c	64 06		stz $06		                stz insrc
.808e	64 07		stz $07		                stz insrc+1
.8090	64 16		stz $16		                stz state
.8092	64 17		stz $17		                stz state+1
.8094					_get_line:
.8094	a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8096	85 08		sta $08		                sta cib
.8098	a9 02		lda #$02	                lda #>buffer0
.809a	85 09		sta $09		                sta cib+1
.809c	64 0a		stz $0a		                stz ciblen
.809e	64 0b		stz $0b		                stz ciblen+1
.80a0	20 e3 9a	jsr $9ae3	                jsr xt_refill           ; ( -- f )
.80a3	b5 00		lda $00,x	                lda 0,x
.80a5	d0 05		bne $80ac	                bne _success
.80a7	a9 06		lda #$06	                lda #err_refill
.80a9	4c 2a d8	jmp $d82a	                jmp error
.80ac					_success:
.80ac	e8		inx		                inx                     ; drop
.80ad	e8		inx		                inx
.80ae	20 7c d7	jsr $d77c	                jsr interpret
.80b1	e0 78		cpx #$78	                cpx #dsp0
.80b3	f0 05		beq $80ba	                beq _stack_ok
.80b5	90 03		bcc $80ba	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80b7	4c 28 d8	jmp $d828	                jmp underflow_error
.80ba					_stack_ok:
.80ba	a5 16		lda $16		                lda state
.80bc	f0 02		beq $80c0	                beq _print
.80be	a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80c0					_print:
.80c0	20 5a d8	jsr $d85a	                jsr print_string
.80c3	80 cf		bra $8094	                bra _get_line
.80c5					z_cold:
.80c5					z_abort:
.80c5					z_quit:
.80c5					cold_zp_table:
>80c5	00 08				        .word cp0+256+1024      ; cp moved to make room for user vars and
>80c7	29 bc				        .word dictionary_start  ; dp
>80c9	00 00				        .word 0                 ; workword
>80cb	00 00				        .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
>80cd	00 02				        .word buffer0           ; cib
>80cf	00 00				        .word 0                 ; ciblen
>80d1	00 00				        .word 0                 ; toin
>80d3	00 00				        .word 0                 ; ip
>80d5	27 f0				        .word kernel_putc       ; output
>80d7	21 f0				        .word kernel_getc       ; input
>80d9	00 00				        .word 0                 ; havekey
>80db	00 00				        .word 0                 ; state (0 = interpret)
>80dd	0a 00				        .word 10                ; base
>80df	14 00				        .word 20                ; nc-limit
>80e1	00 00				        .word 0                 ; uf_strip (off by default)
>80e3	00 03				        .word cp0               ; up (user vars put right at beginning of
>80e5	00 00				        .word 0                 ; status
.80e7					cold_zp_table_end:
.80e7					cold_user_table:
>80e7	00 00				        .word 0                         ; BLK
>80e9	00 00				        .word 0                         ; SCR
>80eb	00				        .byte 0                         ; CURRENT = FORTH-WORDLIST
>80ec	04				        .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>80ed	29 bc				        .word dictionary_start          ; FORTH-WORDLIST
>80ef	71 ca				        .word editor_dictionary_start   ; EDITOR-WORDLIST
>80f1	c1 ca				        .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
>80f3	30 ca				        .word root_dictionary_start     ; ROOT-WORDLIST
>80f5	00 00 00 00 00 00 00 00		        .word 0,0,0,0,0,0,0,0           ; User wordlists
>80fd	00 00 00 00 00 00 00 00
>8105	01				        .byte 1                         ; #ORDER
>8106	00 00 00 00 00 00 00 00		        .byte 0,0,0,0,0,0,0,0,0         ; search-order
>810e	00
>810f	00 04				        .word cp0+256                   ; Address of buffer (right after USER vars)
>8111	00 00				        .word 0                         ; block in buffer
>8113	00 00				        .word 0                         ; buffer status (not in use)
>8115	55 85				        .word xt_block_word_error       ; block-read vector
>8117	55 85				        .word xt_block_word_error       ; block-write vector
.8119					cold_user_table_end:
.8119					xt_abort_quote:
.8119	20 3a 9d	jsr $9d3a	                jsr xt_s_quote          ; S"
.811c	a0 81		ldy #$81	                ldy #>abort_quote_runtime
.811e	a9 24		lda #$24	                lda #<abort_quote_runtime
.8120	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.8123	60		rts		z_abort_quote:  rts
.8124					abort_quote_runtime:
.8124	b5 04		lda $04,x	                lda 4,x
.8126	15 05		ora $05,x	                ora 5,x
.8128	f0 09		beq $8133	                beq _done       ; if FALSE, we're done
.812a	20 e8 a4	jsr $a4e8	                jsr xt_type
.812d	20 5d 89	jsr $895d	                jsr xt_cr
.8130	4c 81 80	jmp $8081	                jmp xt_abort    ; not JSR, so never come back
.8133					_done:
.8133	8a		txa		                txa
.8134	18		clc		                clc
.8135	69 06		adc #$06	                adc #6
.8137	aa		tax		                tax
.8138	60		rts		                rts
.8139					xt_abs:
.8139	20 14 d8	jsr $d814	                jsr underflow_1
.813c	b5 01		lda $01,x	                lda 1,x
.813e	10 0d		bpl $814d	                bpl _done       ; positive number, easy money!
.8140	38		sec		                sec
.8141	a9 00		lda #$00	                lda #0
.8143	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8145	95 00		sta $00,x	                sta 0,x
.8147	a9 00		lda #$00	                lda #0          ; MSB
.8149	f5 01		sbc $01,x	                sbc 1,x
.814b	95 01		sta $01,x	                sta 1,x
.814d					_done:
.814d	60		rts		z_abs:          rts
.814e					xt_accept:
.814e	20 19 d8	jsr $d819	                jsr underflow_2
.8151	b5 00		lda $00,x	                lda 0,x
.8153	15 01		ora $01,x	                ora 1,x
.8155	d0 09		bne $8160	                bne _not_zero
.8157	e8		inx		                inx
.8158	e8		inx		                inx
.8159	74 00		stz $00,x	                stz 0,x
.815b	74 01		stz $01,x	                stz 1,x
.815d	4c 2c 82	jmp $822c	                jmp accept_done
.8160					_not_zero:
.8160	b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.8162	85 26		sta $26		                sta tmp2
.8164	64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.8166	b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8168	85 24		sta $24		                sta tmp1
.816a	b5 03		lda $03,x	                lda 3,x
.816c	85 25		sta $25		                sta tmp1+1
.816e	e8		inx		                inx
.816f	e8		inx		                inx
.8170	a0 00		ldy #$00	                ldy #0
.8172	a5 20		lda $20		                lda status
.8174	29 f7		and #$f7	                and #$f7
.8176	1a		inc a		               ina
.8177	09 08		ora #$08	                ora #$08
.8179	85 20		sta $20		                sta status
.817b					accept_loop:
.817b	20 32 93	jsr $9332	                jsr key_a
.817e	c9 0a		cmp #$0a	                cmp #AscLF
.8180	f0 20		beq $81a2	                beq _eol
.8182	c9 0d		cmp #$0d	                cmp #AscCR
.8184	f0 1c		beq $81a2	                beq _eol
.8186	c9 08		cmp #$08	                cmp #AscBS
.8188	f0 22		beq $81ac	                beq _backspace
.818a	c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.818c	f0 1e		beq $81ac	                beq _backspace
.818e	c9 10		cmp #$10	                cmp #AscCP
.8190	f0 36		beq $81c8	                beq _ctrl_p
.8192	c9 0e		cmp #$0e	                cmp #AscCN
.8194	f0 44		beq $81da	                beq _ctrl_n
.8196	91 24		sta ($24),y	                sta (tmp1),y
.8198	c8		iny		                iny
.8199	20 f0 8d	jsr $8df0	                jsr emit_a
.819c	c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.819e	d0 db		bne $817b	                bne accept_loop       ; fall through if buffer limit reached
.81a0	80 03		bra $81a5	                bra _buffer_full
.81a2					_eol:
.81a2	20 09 a1	jsr $a109	                jsr xt_space    ; print final space
.81a5					_buffer_full:
.81a5	94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.81a7	74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.81a9	4c 2c 82	jmp $822c	                jmp accept_done
.81ac					_backspace:
.81ac	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.81ae	d0 06		bne $81b6	                bne +
.81b0	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.81b2	20 f0 8d	jsr $8df0	                jsr emit_a
.81b5	c8		iny		                iny
.81b6					+
.81b6	88		dey		                dey
.81b7	a9 08		lda #$08	                lda #AscBS      ; move back one
.81b9	20 f0 8d	jsr $8df0	                jsr emit_a
.81bc	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.81be	20 f0 8d	jsr $8df0	                jsr emit_a
.81c1	a9 08		lda #$08	                lda #AscBS      ; move back over space
.81c3	20 f0 8d	jsr $8df0	                jsr emit_a
.81c6	80 b3		bra $817b	                bra accept_loop
.81c8					_ctrl_p:
.81c8	a5 20		lda $20		                lda status
.81ca	29 07		and #$07	                and #7
.81cc	d0 08		bne $81d6	                bne _ctrl_p_dec
.81ce	a5 20		lda $20		                lda status
.81d0	09 07		ora #$07	                ora #7
.81d2	85 20		sta $20		                sta status
.81d4	80 11		bra $81e7	                bra _recall_history
.81d6					_ctrl_p_dec:
.81d6	c6 20		dec $20		                dec status
.81d8	80 0d		bra $81e7	                bra _recall_history
.81da					_ctrl_n:
.81da	a9 08		lda #$08	                lda #$8
.81dc	24 20		bit $20		                bit status
.81de	d0 07		bne $81e7	                bne _recall_history
.81e0	a5 20		lda $20		                lda status
.81e2	29 f7		and #$f7	                and #$f7
.81e4	1a		inc a		               ina
.81e5	85 20		sta $20		                sta status
.81e7					_recall_history:
.81e7	a9 08		lda #$08	                lda #%00001000
.81e9	14 20		trb $20		                trb status
.81eb	20 47 82	jsr $8247	                jsr accept_total_recall
.81ee	a9 0d		lda #$0d	                lda #AscCR
.81f0	20 f0 8d	jsr $8df0	                jsr emit_a
.81f3					input_clear:
.81f3	c0 00		cpy #$00	                cpy #0
.81f5	f0 08		beq $81ff	                beq input_cleared
.81f7	a9 20		lda #$20	                lda #AscSP
.81f9	20 f0 8d	jsr $8df0	                jsr emit_a
.81fc	88		dey		                dey
.81fd	80 f4		bra $81f3	                bra input_clear
.81ff					input_cleared:
.81ff	a9 0d		lda #$0d	                lda #AscCR
.8201	20 f0 8d	jsr $8df0	                jsr emit_a
.8204	b1 28		lda ($28),y	                lda (tmp3),y
.8206	85 21		sta $21		                sta status+1
.8208	e6 28		inc $28		                inc tmp3
.820a	d0 02		bne $820e	                bne +           ; Increment the upper byte on carry.
.820c	e6 29		inc $29		                inc tmp3+1
.820e					+
.820e	a9 0d		lda #$0d	                lda #AscCR
.8210	20 f0 8d	jsr $8df0	                jsr emit_a
.8213					_history_loop:
.8213	c4 21		cpy $21		                cpy status+1
.8215	d0 03		bne $821a	                bne +
.8217	4c 7b 81	jmp $817b	                jmp accept_loop       ; Needs a long jump
.821a					+
.821a	c4 26		cpy $26		                cpy tmp2
.821c	f0 0a		beq $8228	                beq _hist_filled_buffer
.821e	b1 28		lda ($28),y	                lda (tmp3),y
.8220	91 24		sta ($24),y	                sta (tmp1),y
.8222	20 f0 8d	jsr $8df0	                jsr emit_a
.8225	c8		iny		                iny
.8226	80 eb		bra $8213	                bra _history_loop
.8228					_hist_filled_buffer:
.8228	88		dey		                dey
.8229	4c 7b 81	jmp $817b	                jmp accept_loop
.822c					accept_done:
.822c	20 47 82	jsr $8247	                jsr accept_total_recall
.822f	85 21		sta $21		                sta status+1
.8231	a0 00		ldy #$00	                ldy #0
.8233	91 28		sta ($28),y	                sta (tmp3),y
.8235	e6 28		inc $28		                inc tmp3
.8237	d0 02		bne $823b	                bne +           ; Increment the upper byte on carry.
.8239	e6 29		inc $29		                inc tmp3+1
.823b					+
.823b					_save_history_loop:
.823b	c4 21		cpy $21		                cpy status+1
.823d	f0 07		beq $8246	                beq _save_history_done
.823f	b1 24		lda ($24),y	                lda (tmp1),y
.8241	91 28		sta ($28),y	                sta (tmp3),y
.8243	c8		iny		                iny
.8244	80 f5		bra $823b	                bra _save_history_loop
.8246					_save_history_done:
.8246					z_accept:
.8246	60		rts		                rts
.8247					accept_total_recall:
.8247	a9 00		lda #$00	                lda #<hist_buff
.8249	85 28		sta $28		                sta tmp3
.824b	a9 7c		lda #$7c	                lda #>hist_buff
.824d	85 29		sta $29		                sta tmp3+1
.824f	a5 20		lda $20		                lda status
.8251	6a		ror a		                ror
.8252	29 03		and #$03	                and #3
.8254	18		clc		                clc
.8255	65 29		adc $29		                adc tmp3+1
.8257	85 29		sta $29		                sta tmp3+1
.8259	a5 20		lda $20		                lda status
.825b	6a		ror a		                ror             ; Rotate through carry into msb.
.825c	6a		ror a		                ror
.825d	29 80		and #$80	                and #$80
.825f	18		clc		                clc
.8260	65 28		adc $28		                adc tmp3
.8262	85 28		sta $28		                sta tmp3
.8264	90 02		bcc $8268	                bcc +           ; Increment the upper byte on carry.
.8266	e6 29		inc $29		                inc tmp3+1
.8268					+
.8268	98		tya		                tya
.8269	c9 80		cmp #$80	                cmp #$80
.826b	90 02		bcc $826f	                bcc +
.826d	a9 7f		lda #$7f	                lda #$7F
.826f					+
.826f	60		rts		                rts
.8270					xt_action_of:
.8270	a5 16		lda $16		                lda state
.8272	05 17		ora $17		                ora state+1
.8274	f0 0c		beq $8282	                beq _interpreting
.8276					_compiling:
.8276	20 98 85	jsr $8598	                jsr xt_bracket_tick
.8279	a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.827b	a9 d9		lda #$d9	                lda #<xt_defer_fetch
.827d	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.8280	80 06		bra $8288	                bra _done
.8282					_interpreting:
.8282	20 f6 a1	jsr $a1f6	                jsr xt_tick
.8285	20 d9 8a	jsr $8ad9	                jsr xt_defer_fetch
.8288					_done:
.8288	60		rts		z_action_of:           rts
.8289					xt_again:
.8289	20 14 d8	jsr $d814	                jsr underflow_1
.828c	a0 00		ldy #$00	                ldy #0
.828e	a9 4c		lda #$4c	                lda #$4C        ; JMP
.8290	91 00		sta ($00),y	                sta (cp),y
.8292	c8		iny		                iny
.8293	b5 00		lda $00,x	                lda 0,x         ; LSB of address
.8295	91 00		sta ($00),y	                sta (cp),y
.8297	c8		iny		                iny
.8298	b5 01		lda $01,x	                lda 1,x         ; MSB of address
.829a	91 00		sta ($00),y	                sta (cp),y
.829c	c8		iny		                iny
.829d	98		tya		                tya
.829e	18		clc		                clc
.829f	65 00		adc $00		                adc cp
.82a1	85 00		sta $00		                sta cp
.82a3	90 02		bcc $82a7	                bcc _done
.82a5	e6 01		inc $01		                inc cp+1
.82a7					_done:
.82a7	e8		inx		                inx
.82a8	e8		inx		                inx
.82a9	60		rts		z_again:        rts
.82aa					xt_align:
.82aa					xt_aligned:
.82aa					z_align:
.82aa	60		rts		z_aligned:      rts             ; stripped out during native compile
.82ab					xt_allot:
.82ab	20 14 d8	jsr $d814	                jsr underflow_1
.82ae	b5 01		lda $01,x	                lda 1,x
.82b0	30 22		bmi $82d4	                bmi _release
.82b2	18		clc		                clc
.82b3	a5 00		lda $00		                lda cp
.82b5	75 00		adc $00,x	                adc 0,x
.82b7	85 00		sta $00		                sta cp
.82b9	a5 01		lda $01		                lda cp+1
.82bb	75 01		adc $01,x	                adc 1,x
.82bd	85 01		sta $01		                sta cp+1
.82bf	a0 00		ldy #$00	                ldy #<cp_end
.82c1	c4 00		cpy $00		                cpy cp
.82c3	a9 7c		lda #$7c	                lda #>cp_end
.82c5	e5 01		sbc $01		                sbc cp+1
.82c7	b0 48		bcs $8311	                bcs _done               ; we're fine.
.82c9	84 00		sty $00		                sty cp                  ; still #<cp_end
.82cb	a9 7c		lda #$7c	                lda #>cp_end
.82cd	85 01		sta $01		                sta cp+1
.82cf	a9 00		lda #$00	                lda #err_allot
.82d1	4c 2a d8	jmp $d82a	                jmp error
.82d4					_release:
.82d4	ca		dex		                dex
.82d5	ca		dex		                dex
.82d6	a5 00		lda $00		                lda cp
.82d8	95 00		sta $00,x	                sta 0,x
.82da	a5 01		lda $01		                lda cp+1
.82dc	95 01		sta $01,x	                sta 1,x
.82de	20 ce 99	jsr $99ce	                jsr xt_plus                     ; new CP is now TOS
.82e1	ca		dex		                dex
.82e2	ca		dex		                dex                             ; new CP now NOS
.82e3	a9 00		lda #$00	                lda #<cp0
.82e5	95 00		sta $00,x	                sta 0,x
.82e7	a9 03		lda #$03	                lda #>cp0
.82e9	95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.82eb	20 3b d7	jsr $d73b	                jsr compare_16bit               ; still ( CP CP0 )
.82ee	f0 17		beq $8307	                beq _nega_done
.82f0	30 15		bmi $8307	                bmi _nega_done
.82f2	a9 00		lda #$00	                lda #<cp0
.82f4	85 00		sta $00		                sta cp
.82f6	a9 03		lda #$03	                lda #>cp0
.82f8	85 01		sta $01		                sta cp+1
.82fa	a9 29		lda #$29	                lda #<dictionary_start
.82fc	85 02		sta $02		                sta dp
.82fe	a9 bc		lda #$bc	                lda #>dictionary_start
.8300	85 03		sta $03		                sta dp+1
.8302	a9 0a		lda #$0a	                lda #err_negallot
.8304	4c 2a d8	jmp $d82a	                jmp error
.8307					_nega_done:
.8307	b5 02		lda $02,x	                lda 2,x
.8309	85 00		sta $00		                sta cp
.830b	b5 03		lda $03,x	                lda 3,x
.830d	85 01		sta $01		                sta cp+1
.830f	e8		inx		                inx
.8310	e8		inx		                inx                     ; drop through to _done
.8311					_done:
.8311	e8		inx		                inx
.8312	e8		inx		                inx
.8313					z_allot:
.8313	60		rts		                rts
.8314					xt_allow_native:
.8314	20 56 d7	jsr $d756	                jsr current_to_dp
.8317	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8319	b1 02		lda ($02),y	                lda (dp),y
.831b	29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.831d	91 02		sta ($02),y	                sta (dp),y
.831f					z_allow_native:
.831f	60		rts		                rts
.8320					xt_also:
.8320	20 2e 91	jsr $912e	                jsr xt_get_order
.8323	20 7e 98	jsr $987e	                jsr xt_over
.8326	20 93 a1	jsr $a193	                jsr xt_swap
.8329	20 08 98	jsr $9808	                jsr xt_one_plus
.832c	20 06 9d	jsr $9d06	                jsr xt_set_order
.832f	60		rts		z_also:         rts
.8330					xt_always_native:
.8330	20 56 d7	jsr $d756	                jsr current_to_dp
.8333	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8335	b1 02		lda ($02),y	                lda (dp),y
.8337	09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.8339	29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.833b	91 02		sta ($02),y	                sta (dp),y
.833d					z_always_native:
.833d	60		rts		                rts
.833e					xt_and:
.833e	20 19 d8	jsr $d819	                jsr underflow_2
.8341	b5 00		lda $00,x	                lda 0,x
.8343	35 02		and $02,x	                and 2,x
.8345	95 02		sta $02,x	                sta 2,x
.8347	b5 01		lda $01,x	                lda 1,x
.8349	35 03		and $03,x	                and 3,x
.834b	95 03		sta $03,x	                sta 3,x
.834d	e8		inx		                inx
.834e	e8		inx		                inx
.834f	60		rts		z_and:          rts
.8350					xt_at_xy:
.8350	20 19 d8	jsr $d819	                jsr underflow_2
.8353	a5 18		lda $18		                lda base
.8355	48		pha		                pha
.8356	a9 0a		lda #$0a	                lda #10
.8358	85 18		sta $18		                sta base
.835a	a9 1b		lda #$1b	                lda #AscESC
.835c	20 f0 8d	jsr $8df0	                jsr emit_a
.835f	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.8361	20 f0 8d	jsr $8df0	                jsr emit_a
.8364	20 60 d8	jsr $d860	                jsr print_u
.8367	a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8369	20 f0 8d	jsr $8df0	                jsr emit_a
.836c	20 60 d8	jsr $d860	                jsr print_u
.836f	a9 48		lda #$48	                lda #'H'
.8371	20 f0 8d	jsr $8df0	                jsr emit_a
.8374	68		pla		                pla
.8375	85 18		sta $18		                sta base
.8377	60		rts		z_at_xy:        rts
.8378					xt_backslash:
.8378	a5 0a		lda $0a		                lda ciblen
.837a	85 0c		sta $0c		                sta toin
.837c	a5 0b		lda $0b		                lda ciblen+1
.837e	85 0d		sta $0d		                sta toin+1
.8380	60		rts		z_backslash:    rts
.8381					xt_base:
.8381	ca		dex		                dex
.8382	ca		dex		                dex
.8383	a9 18		lda #$18	                lda #<base
.8385	95 00		sta $00,x	                sta 0,x         ; LSB
.8387	74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8389	60		rts		z_base:         rts
.838a					xt_begin:
.838a	20 6c 91	jsr $916c	                jsr xt_here
.838d	60		rts		z_begin:        rts
.838e					xt_bell:
.838e	a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.8390	20 f0 8d	jsr $8df0	                jsr emit_a
.8393	60		rts		z_bell:         rts
.8394					xt_bl:
.8394	ca		dex		                dex
.8395	ca		dex		                dex
.8396	a9 20		lda #$20	                lda #AscSP
.8398	95 00		sta $00,x	                sta 0,x
.839a	74 01		stz $01,x	                stz 1,x
.839c	60		rts		z_bl:           rts
.839d					xt_blk:
.839d	ca		dex		                dex
.839e	ca		dex		                dex
.839f	18		clc		                clc
.83a0	a5 1e		lda $1e		                lda up
.83a2	69 00		adc #$00	                adc #blk_offset ; Add offset
.83a4	95 00		sta $00,x	                sta 0,x
.83a6	a5 1f		lda $1f		                lda up+1
.83a8	69 00		adc #$00	                adc #0          ; Adding carry
.83aa	95 01		sta $01,x	                sta 1,x
.83ac	60		rts		z_blk:          rts
.83ad					xt_blkbuffer:
.83ad	ca		dex		                dex
.83ae	ca		dex		                dex
.83af	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83b1	b1 1e		lda ($1e),y	                lda (up),y
.83b3	95 00		sta $00,x	                sta 0,x
.83b5	c8		iny		                iny             ; Move along to the next byte
.83b6	b1 1e		lda ($1e),y	                lda (up),y
.83b8	95 01		sta $01,x	                sta 1,x
.83ba	60		rts		z_blkbuffer:    rts
.83bb					xt_block:
.83bb	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83bd	b1 1e		lda ($1e),y	                lda (up),y
.83bf	d5 00		cmp $00,x	                cmp 0,x
.83c1	d0 0f		bne $83d2	                bne _not_in_buffer
.83c3	c8		iny		                iny
.83c4	b1 1e		lda ($1e),y	                lda (up),y
.83c6	d5 01		cmp $01,x	                cmp 1,x
.83c8	d0 08		bne $83d2	                bne _not_in_buffer
.83ca	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83cc	b1 1e		lda ($1e),y	                lda (up),y
.83ce	29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.83d0	d0 30		bne $8402	                bne _done       ; It's already in the buffer and in use.
.83d2					_not_in_buffer:
.83d2	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83d4	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.83d6	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.83d8	d0 0c		bne $83e6	                bne _buffer_available ; Unused or not dirty = available
.83da	20 ad 83	jsr $83ad	                jsr xt_blkbuffer
.83dd	20 9f 85	jsr $859f	                jsr xt_buffblocknum
.83e0	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.83e3	20 5a 85	jsr $855a	                jsr xt_block_write
.83e6					_buffer_available:
.83e6	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83e8	b5 00		lda $00,x	                lda 0,x
.83ea	91 1e		sta ($1e),y	                sta (up),y
.83ec	c8		iny		                iny
.83ed	b5 01		lda $01,x	                lda 1,x
.83ef	91 1e		sta ($1e),y	                sta (up),y
.83f1	20 ad 83	jsr $83ad	                jsr xt_blkbuffer
.83f4	20 93 a1	jsr $a193	                jsr xt_swap
.83f7	20 37 85	jsr $8537	                jsr xt_block_read
.83fa	a9 01		lda #$01	                lda #1
.83fc	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83fe	91 1e		sta ($1e),y	                sta (up),y
.8400	ca		dex		                dex
.8401	ca		dex		                dex
.8402					_done:
.8402	a0 28		ldy #$28	                ldy #blkbuffer_offset
.8404	b1 1e		lda ($1e),y	                lda (up),y
.8406	95 00		sta $00,x	                sta 0,x
.8408	c8		iny		                iny
.8409	b1 1e		lda ($1e),y	                lda (up),y
.840b	95 01		sta $01,x	                sta 1,x
.840d	60		rts		z_block:        rts
.840e					xt_block_ramdrive_init:
.840e	20 14 d8	jsr $d814	                jsr underflow_1
.8411	4c 2c 85	jmp $852c	                jmp _after_ramdrive_code
.8414					_ramdrive_code:
>8414	62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>841c	77 61 70 20 64 65 63 69 6d 61 6c
>8427	20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>842e	20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>8432	20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>843a	20 72 61 6d 64 72 69 76 65
>8443	20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>844b	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>8459	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8461	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8471	73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>8481	20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>8489	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>8498	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>84a0	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>84b0	31 30 32 34 20 6d 6f 76 65 20 3b
>84bb	20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>84c3	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>84d3	6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>84e3	20 21
>84e5	20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84ed	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>84fd	62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>850d	6f 72 20 21
>8511	20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>8519	65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>8529	65 20 21
.852c					_after_ramdrive_code:
.852c	20 94 a0	jsr $a094	                jsr sliteral_runtime
>852f	14 84 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.8533	20 cf 90	jsr $90cf	                jsr xt_evaluate
.8536					z_block_ramdrive_init:
.8536	60		rts		                rts
.8537					xt_block_read:
.8537	a0 2e		ldy #$2e	                ldy #blockread_offset
.8539	b1 1e		lda ($1e),y	                lda (up),y
.853b	85 24		sta $24		                sta tmp1
.853d	c8		iny		                iny
.853e	b1 1e		lda ($1e),y	                lda (up),y
.8540	85 25		sta $25		                sta tmp1+1
.8542	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8545					z_block_read:
.8545					xt_block_read_vector:
.8545	ca		dex		                dex
.8546	ca		dex		                dex
.8547	18		clc		                clc
.8548	a5 1e		lda $1e		                lda up
.854a	69 2e		adc #$2e	                adc #blockread_offset
.854c	95 00		sta $00,x	                sta 0,x
.854e	a5 1f		lda $1f		                lda up+1
.8550	69 00		adc #$00	                adc #0          ; Add carry
.8552	95 01		sta $01,x	                sta 1,x
.8554					z_block_read_vector:
.8554	60		rts		                rts
.8555					xt_block_word_error:
.8555	a9 0c		lda #$0c	                lda #err_blockwords
.8557	4c 2a d8	jmp $d82a	                jmp error       ; no RTS needed
.855a					z_block_word_error:
.855a					xt_block_write:
.855a	a0 30		ldy #$30	                ldy #blockwrite_offset
.855c	b1 1e		lda ($1e),y	                lda (up),y
.855e	85 24		sta $24		                sta tmp1
.8560	c8		iny		                iny
.8561	b1 1e		lda ($1e),y	                lda (up),y
.8563	85 25		sta $25		                sta tmp1+1
.8565	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8568					z_block_write:
.8568					xt_block_write_vector:
.8568	ca		dex		                dex
.8569	ca		dex		                dex
.856a	18		clc		                clc
.856b	a5 1e		lda $1e		                lda up
.856d	69 30		adc #$30	                adc #blockwrite_offset
.856f	95 00		sta $00,x	                sta 0,x
.8571	a5 1f		lda $1f		                lda up+1
.8573	69 00		adc #$00	                adc #0          ; Add carry
.8575	95 01		sta $01,x	                sta 1,x
.8577					z_block_write_vector:
.8577	60		rts		                rts
.8578					xt_bounds:
.8578	20 19 d8	jsr $d819	                jsr underflow_2
.857b	18		clc		                clc
.857c	b5 00		lda $00,x	                lda 0,x                 ; LSB u
.857e	b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.8580	75 02		adc $02,x	                adc 2,x
.8582	95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.8584	94 00		sty $00,x	                sty 0,x
.8586	b5 01		lda $01,x	                lda 1,x                 ; MSB u
.8588	b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.858a	75 03		adc $03,x	                adc 3,x
.858c	95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.858e	94 01		sty $01,x	                sty 1,x
.8590	60		rts		z_bounds:       rts
.8591					xt_bracket_char:
.8591	20 2b 86	jsr $862b	                jsr xt_char
.8594	20 84 93	jsr $9384	                jsr xt_literal
.8597	60		rts		z_bracket_char: rts
.8598					xt_bracket_tick:
.8598	20 f6 a1	jsr $a1f6	                jsr xt_tick
.859b	20 84 93	jsr $9384	                jsr xt_literal
.859e	60		rts		z_bracket_tick: rts
.859f					xt_buffblocknum:
.859f	ca		dex		                dex
.85a0	ca		dex		                dex
.85a1	18		clc		                clc
.85a2	a5 1e		lda $1e		                lda up
.85a4	69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.85a6	95 00		sta $00,x	                sta 0,x
.85a8	a5 1f		lda $1f		                lda up+1
.85aa	69 00		adc #$00	                adc #0                          ; Adding carry
.85ac	95 01		sta $01,x	                sta 1,x
.85ae	60		rts		z_buffblocknum: rts
.85af					xt_buffer:
.85af	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85b1	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.85b3	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.85b5	d0 0c		bne $85c3	                bne _buffer_available ; Unused or not dirty = available
.85b7	20 ad 83	jsr $83ad	                jsr xt_blkbuffer
.85ba	20 9f 85	jsr $859f	                jsr xt_buffblocknum
.85bd	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.85c0	20 5a 85	jsr $855a	                jsr xt_block_write
.85c3					_buffer_available:
.85c3	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.85c5	b5 00		lda $00,x	                lda 0,x
.85c7	91 1e		sta ($1e),y	                sta (up),y
.85c9	c8		iny		                iny
.85ca	b5 01		lda $01,x	                lda 1,x
.85cc	91 1e		sta ($1e),y	                sta (up),y
.85ce	a9 01		lda #$01	                lda #1
.85d0	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85d2	91 1e		sta ($1e),y	                sta (up),y
.85d4					_done:
.85d4	a0 28		ldy #$28	                ldy #blkbuffer_offset
.85d6	b1 1e		lda ($1e),y	                lda (up),y
.85d8	95 00		sta $00,x	                sta 0,x
.85da	c8		iny		                iny
.85db	b1 1e		lda ($1e),y	                lda (up),y
.85dd	95 01		sta $01,x	                sta 1,x
.85df	60		rts		z_buffer:       rts
.85e0					xt_buffer_colon:
.85e0	20 63 89	jsr $8963	                jsr xt_create
.85e3	20 ab 82	jsr $82ab	                jsr xt_allot
.85e6	60		rts		z_buffer_colon: rts
.85e7					xt_buffstatus:
.85e7	ca		dex		                dex
.85e8	ca		dex		                dex
.85e9	18		clc		                clc
.85ea	a5 1e		lda $1e		                lda up
.85ec	69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.85ee	95 00		sta $00,x	                sta 0,x
.85f0	a5 1f		lda $1f		                lda up+1
.85f2	69 00		adc #$00	                adc #0                  ; Adding carry
.85f4	95 01		sta $01,x	                sta 1,x
.85f6	60		rts		z_buffstatus:   rts
.85f7					xt_bye:
.85f7	4c 2b f0	jmp $f02b	                jmp platform_bye
.85fa					z_bye:
.85fa					xt_c_comma:
.85fa	20 14 d8	jsr $d814	                jsr underflow_1
.85fd	b5 00		lda $00,x	                lda 0,x
.85ff	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.8602	e8		inx		                inx
.8603	e8		inx		                inx
.8604	60		rts		z_c_comma:      rts
.8605					xt_c_fetch:
.8605	20 14 d8	jsr $d814	                jsr underflow_1
.8608	a1 00		lda ($00,x)	                lda (0,x)
.860a	95 00		sta $00,x	                sta 0,x
.860c	74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.860e	60		rts		z_c_fetch:      rts
.860f					xt_c_store:
.860f	20 19 d8	jsr $d819	                jsr underflow_2
.8612	b5 02		lda $02,x	                lda 2,x
.8614	81 00		sta ($00,x)	                sta (0,x)
.8616	e8		inx		                inx
.8617	e8		inx		                inx
.8618	e8		inx		                inx
.8619	e8		inx		                inx
.861a	60		rts		z_c_store:      rts
.861b					xt_cell_plus:
.861b	20 14 d8	jsr $d814	                jsr underflow_1
.861e	f6 00		inc $00,x	                inc 0,x
.8620	d0 02		bne $8624	                bne +
.8622	f6 01		inc $01,x	                inc 1,x
.8624					+
.8624	f6 00		inc $00,x	                inc 0,x
.8626	d0 02		bne $862a	                bne _done
.8628	f6 01		inc $01,x	                inc 1,x
.862a					_done:
.862a	60		rts		z_cell_plus:    rts
.862b					xt_char:
.862b	20 ca 98	jsr $98ca	                jsr xt_parse_name
.862e	b5 00		lda $00,x	                lda 0,x
.8630	15 01		ora $01,x	                ora 1,x
.8632	d0 05		bne $8639	                bne _not_empty
.8634	a9 05		lda #$05	                lda #err_noname
.8636	4c 2a d8	jmp $d82a	                jmp error
.8639					_not_empty:
.8639	e8		inx		                inx             ; drop number of characters, leave addr
.863a	e8		inx		                inx
.863b	a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.863d	95 00		sta $00,x	                sta 0,x
.863f	74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8641	60		rts		z_char:         rts
.8642					xt_chars:
.8642	20 14 d8	jsr $d814	                jsr underflow_1
.8645	60		rts		z_chars:        rts
.8646					xt_cleave:
.8646	20 19 d8	jsr $d819	                jsr underflow_2
.8649	20 5d 95	jsr $955d	                jsr xt_minus_leading    ; -LEADING ( addr u )
.864c	20 5c 92	jsr $925c	                jsr xt_input_to_r       ; save old imput state
.864f	b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.8651	85 0a		sta $0a		                sta ciblen
.8653	b5 01		lda $01,x	                lda 1,x
.8655	85 0b		sta $0b		                sta ciblen+1
.8657	b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.8659	85 08		sta $08		                sta cib
.865b	b5 03		lda $03,x	                lda 3,x
.865d	85 09		sta $09		                sta cib+1
.865f	64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.8661	64 0d		stz $0d		                stz toin+1
.8663	20 ca 98	jsr $98ca	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.8666	b5 00		lda $00,x	                lda 0,x
.8668	15 01		ora $01,x	                ora 1,x
.866a	f0 23		beq $868f	                beq _done
.866c	b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.866e	38		sec		                sec
.866f	f5 00		sbc $00,x	                sbc 0,x
.8671	95 04		sta $04,x	                sta 4,x
.8673	b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.8675	f5 01		sbc $01,x	                sbc 1,x
.8677	95 05		sta $05,x	                sta 5,x
.8679	b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.867b	18		clc		                clc
.867c	75 00		adc $00,x	                adc 0,x
.867e	95 06		sta $06,x	                sta 6,x
.8680	b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.8682	75 01		adc $01,x	                adc 1,x
.8684	95 07		sta $07,x	                sta 7,x
.8686	20 63 a4	jsr $a463	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.8689	20 5d 95	jsr $955d	                jsr xt_minus_leading
.868c	20 63 a4	jsr $a463	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.868f					_done:
.868f	20 8e 9a	jsr $9a8e	                jsr xt_r_to_input
.8692	60		rts		z_cleave:       rts
.8693					xt_cmove:
.8693	20 1e d8	jsr $d81e	                jsr underflow_3
.8696	b5 02		lda $02,x	                lda 2,x
.8698	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.869a	b5 03		lda $03,x	                lda 3,x
.869c	85 27		sta $27		                sta tmp2+1
.869e	b5 04		lda $04,x	                lda 4,x
.86a0	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86a2	b5 05		lda $05,x	                lda 5,x
.86a4	85 25		sta $25		                sta tmp1+1
.86a6	a0 00		ldy #$00	                ldy #0
.86a8	b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.86aa	f0 0f		beq $86bb	                beq _dopartial
.86ac					_page:
.86ac	b1 24		lda ($24),y	                lda (tmp1),y
.86ae	91 26		sta ($26),y	                sta (tmp2),y
.86b0	c8		iny		                iny
.86b1	d0 f9		bne $86ac	                bne _page
.86b3	e6 25		inc $25		                inc tmp1+1
.86b5	e6 27		inc $27		                inc tmp2+1
.86b7	d6 01		dec $01,x	                dec 1,x
.86b9	d0 f1		bne $86ac	                bne _page
.86bb					_dopartial:
.86bb	b5 00		lda $00,x	                lda 0,x         ; length of last page
.86bd	f0 09		beq $86c8	                beq _done
.86bf					_partial:
.86bf	b1 24		lda ($24),y	                lda (tmp1),y
.86c1	91 26		sta ($26),y	                sta (tmp2),y
.86c3	c8		iny		                iny
.86c4	d6 00		dec $00,x	                dec 0,x
.86c6	d0 f7		bne $86bf	                bne _partial
.86c8					_done:
.86c8	8a		txa		                txa
.86c9	18		clc		                clc
.86ca	69 06		adc #$06	                adc #6
.86cc	aa		tax		                tax
.86cd	60		rts		z_cmove:        rts
.86ce					xt_cmove_up:
.86ce	20 1e d8	jsr $d81e	                jsr underflow_3
.86d1	b5 02		lda $02,x	                lda 2,x
.86d3	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86d5	b5 03		lda $03,x	                lda 3,x
.86d7	18		clc		                clc
.86d8	75 01		adc $01,x	                adc 1,x
.86da	85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.86dc	b5 04		lda $04,x	                lda 4,x
.86de	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86e0	b5 05		lda $05,x	                lda 5,x
.86e2	18		clc		                clc
.86e3	75 01		adc $01,x	                adc 1,x
.86e5	85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86e7	f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86e9	b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86eb	f0 0e		beq $86fb	                beq _nopartial
.86ed					_outerloop:
.86ed	88		dey		                dey
.86ee	f0 07		beq $86f7	                beq _finishpage
.86f0					_innerloop:
.86f0	b1 24		lda ($24),y	                lda (tmp1),y
.86f2	91 26		sta ($26),y	                sta (tmp2),y
.86f4	88		dey		                dey
.86f5	d0 f9		bne $86f0	                bne _innerloop
.86f7					_finishpage:
.86f7	b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.86f9	92 26		sta ($26)	                sta (tmp2)
.86fb					_nopartial:
.86fb	c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.86fd	c6 27		dec $27		                dec tmp2+1
.86ff	d6 01		dec $01,x	                dec 1,x
.8701	d0 ea		bne $86ed	                bne _outerloop
.8703					_done:
.8703	8a		txa		                txa
.8704	18		clc		                clc
.8705	69 06		adc #$06	                adc #6
.8707	aa		tax		                tax
.8708	60		rts		z_cmove_up:     rts
.8709					xt_colon:
.8709	a5 16		lda $16		                lda state
.870b	05 17		ora $17		                ora state+1
.870d	f0 05		beq $8714	                beq +
.870f	a9 07		lda #$07	                lda #err_state
.8711	4c 2a d8	jmp $d82a	                jmp error
.8714					+
.8714	c6 16		dec $16		                dec state
.8716	c6 17		dec $17		                dec state+1
.8718	a9 40		lda #$40	                lda #%01000000
.871a	04 20		tsb $20		                tsb status
.871c	20 56 d7	jsr $d756	                jsr current_to_dp
.871f	a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8721	48		pha		                pha
.8722	a5 02		lda $02		                lda dp
.8724	48		pha		                pha
.8725	a9 80		lda #$80	                lda #%10000000
.8727	04 20		tsb $20		                tsb status
.8729	20 63 89	jsr $8963	                jsr xt_create
.872c	20 56 d7	jsr $d756	                jsr current_to_dp   ; This might be able to be omitted
.872f	a5 02		lda $02		                lda dp
.8731	85 04		sta $04		                sta workword
.8733	a5 03		lda $03		                lda dp+1
.8735	85 05		sta $05		                sta workword+1
.8737	68		pla		                pla
.8738	85 02		sta $02		                sta dp
.873a	68		pla		                pla
.873b	85 03		sta $03		                sta dp+1
.873d	20 69 d7	jsr $d769	                jsr dp_to_current
.8740	a5 00		lda $00		                lda cp
.8742	38		sec		                sec
.8743	e9 03		sbc #$03	                sbc #3
.8745	85 00		sta $00		                sta cp
.8747	b0 02		bcs $874b	                bcs _done
.8749	c6 01		dec $01		                dec cp+1
.874b					_done:
.874b	60		rts		z_colon:        rts
.874c					xt_colon_noname:
.874c	a5 16		lda $16		                lda state
.874e	05 17		ora $17		                ora state+1
.8750	f0 05		beq $8757	                beq +
.8752	a9 07		lda #$07	                lda #err_state
.8754	4c 2a d8	jmp $d82a	                jmp error
.8757					+
.8757	c6 16		dec $16		                dec state
.8759	c6 17		dec $17		                dec state+1
.875b	a9 40		lda #$40	                lda #%01000000
.875d	14 20		trb $20		                trb status
.875f	a5 00		lda $00		                lda cp
.8761	85 04		sta $04		                sta workword
.8763	a5 01		lda $01		                lda cp+1
.8765	85 05		sta $05		                sta workword+1
.8767					_done:
.8767	60		rts		z_colon_noname:        rts
.8768					xt_comma:
.8768	20 14 d8	jsr $d814	                jsr underflow_1
.876b	b5 00		lda $00,x	                lda 0,x
.876d	92 00		sta ($00)	                sta (cp)
.876f	e6 00		inc $00		                inc cp
.8771	d0 02		bne $8775	                bne +
.8773	e6 01		inc $01		                inc cp+1
.8775					+
.8775	b5 01		lda $01,x	                lda 1,x
.8777	92 00		sta ($00)	                sta (cp)
.8779	e6 00		inc $00		                inc cp
.877b	d0 02		bne $877f	                bne _done
.877d	e6 01		inc $01		                inc cp+1
.877f					_done:
.877f	e8		inx		                inx
.8780	e8		inx		                inx
.8781	60		rts		z_comma:        rts
.8782					xt_compare:
.8782	20 23 d8	jsr $d823	                jsr underflow_4
.8785	b5 02		lda $02,x	                lda 2,x
.8787	85 26		sta $26		                sta tmp2
.8789	b5 03		lda $03,x	                lda 3,x
.878b	85 27		sta $27		                sta tmp2+1
.878d	b5 06		lda $06,x	                lda 6,x
.878f	85 24		sta $24		                sta tmp1
.8791	b5 07		lda $07,x	                lda 7,x
.8793	85 25		sta $25		                sta tmp1+1
.8795					_compare_loop:
.8795	b5 04		lda $04,x	                lda 4,x
.8797	15 05		ora $05,x	                ora 5,x
.8799	f0 2c		beq $87c7	                beq _str1_done
.879b	b5 00		lda $00,x	                lda 0,x
.879d	15 01		ora $01,x	                ora 1,x
.879f	f0 3a		beq $87db	                beq _greater    ; Str2 empty first
.87a1					_check_letter:
.87a1	b2 24		lda ($24)	                lda (tmp1)
.87a3	d2 26		cmp ($26)	                cmp (tmp2)
.87a5	90 26		bcc $87cd	                bcc _less
.87a7	d0 32		bne $87db	                bne _greater
.87a9					_next_letter:
.87a9	e6 24		inc $24		                inc tmp1
.87ab	d0 02		bne $87af	                bne +
.87ad	e6 25		inc $25		                inc tmp1+1
.87af					+
.87af	e6 26		inc $26		                inc tmp2
.87b1	d0 02		bne $87b5	                bne +
.87b3	e6 27		inc $27		                inc tmp2+1
.87b5					+
.87b5	b5 04		lda $04,x	                lda 4,x
.87b7	d0 02		bne $87bb	                bne +
.87b9	d6 05		dec $05,x	                dec 5,x
.87bb					+
.87bb	d6 04		dec $04,x	                dec 4,x
.87bd	b5 00		lda $00,x	                lda 0,x
.87bf	d0 02		bne $87c3	                bne +
.87c1	d6 01		dec $01,x	                dec 1,x
.87c3					+
.87c3	d6 00		dec $00,x	                dec 0,x
.87c5	80 ce		bra $8795	                bra _compare_loop
.87c7					_str1_done:
.87c7	b5 00		lda $00,x	                lda 0,x
.87c9	15 01		ora $01,x	                ora 1,x
.87cb	f0 08		beq $87d5	                beq _equal      ; Both out of letters
.87cd					_less:
.87cd	a9 ff		lda #$ff	                lda #$FF
.87cf	95 06		sta $06,x	                sta 6,x
.87d1	95 07		sta $07,x	                sta 7,x
.87d3	80 0c		bra $87e1	                bra _done
.87d5					_equal:
.87d5	74 06		stz $06,x	                stz 6,x
.87d7	74 07		stz $07,x	                stz 7,x
.87d9	80 06		bra $87e1	                bra _done
.87db					_greater:
.87db	a9 01		lda #$01	                lda #1
.87dd	95 06		sta $06,x	                sta 6,x
.87df	74 07		stz $07,x	                stz 7,x
.87e1					_done:
.87e1	8a		txa		                txa
.87e2	18		clc		                clc
.87e3	69 06		adc #$06	                adc #6
.87e5	aa		tax		                tax
.87e6	60		rts		z_compare:      rts
.87e7					xt_compile_comma:
.87e7	20 14 d8	jsr $d814	                jsr underflow_1
.87ea	b5 01		lda $01,x	                lda 1,x                 ; MSB
.87ec	48		pha		                pha
.87ed	b5 00		lda $00,x	                lda 0,x
.87ef	48		pha		                pha                     ; LSB
.87f0	20 72 92	jsr $9272	                jsr xt_int_to_name      ; ( xt -- nt )
.87f3	b5 00		lda $00,x	                lda 0,x
.87f5	15 01		ora $01,x	                ora 1,x
.87f7	d0 03		bne $87fc	                bne _check_nt
.87f9	4c e4 88	jmp $88e4	                jmp _compile_as_jump
.87fc					_check_nt:
.87fc	b5 00		lda $00,x	                lda 0,x
.87fe	85 2c		sta $2c		                sta tmptos
.8800	b5 01		lda $01,x	                lda 1,x
.8802	85 2d		sta $2d		                sta tmptos+1
.8804	f6 00		inc $00,x	                inc 0,x
.8806	d0 02		bne $880a	                bne +
.8808	f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.880a					+
.880a	a1 00		lda ($00,x)	                lda (0,x)
.880c	85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.880e	29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8810	f0 0d		beq $881f	                beq _compile_check
.8812	a5 2c		lda $2c		                lda tmptos
.8814	95 00		sta $00,x	                sta 0,x
.8816	a5 2d		lda $2d		                lda tmptos+1
.8818	95 01		sta $01,x	                sta 1,x
.881a	20 5a a7	jsr $a75a	                jsr xt_wordsize         ; ( nt -- u )
.881d	80 27		bra $8846	                bra _compile_as_code
.881f					_compile_check:
.881f	a5 28		lda $28		                lda tmp3
.8821	29 08		and #$08	                and #NN
.8823	f0 03		beq $8828	                beq _check_size_limit
.8825	4c e4 88	jmp $88e4	                jmp _compile_as_jump    ; too far for BRA
.8828					_check_size_limit:
.8828	a5 2c		lda $2c		                lda tmptos
.882a	95 00		sta $00,x	                sta 0,x
.882c	a5 2d		lda $2d		                lda tmptos+1
.882e	95 01		sta $01,x	                sta 1,x
.8830	20 5a a7	jsr $a75a	                jsr xt_wordsize         ; ( nt -- u )
.8833	b5 01		lda $01,x	                lda 1,x
.8835	c5 1b		cmp $1b		                cmp nc_limit+1
.8837	90 0d		bcc $8846	                bcc _compile_as_code    ; user-defined limit MSB
.8839	d0 08		bne $8843	                bne _jumpto_compile_as_jump
.883b	b5 00		lda $00,x	                lda 0,x
.883d	c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.883f	90 05		bcc $8846	                bcc _compile_as_code    ; Allow native compiling for less
.8841	f0 03		beq $8846	                beq _compile_as_code    ; than or equal to the limit.
.8843					_jumpto_compile_as_jump:
.8843	4c e4 88	jmp $88e4	                jmp _compile_as_jump    ; too far for BRA
.8846					_compile_as_code:
.8846	ca		dex		                dex
.8847	ca		dex		                dex                     ; ( -- u ? )
.8848	ca		dex		                dex
.8849	ca		dex		                dex                     ; ( -- u ? ? )
.884a	b5 04		lda $04,x	                lda 4,x
.884c	95 00		sta $00,x	                sta 0,x                 ; LSB of u
.884e	b5 05		lda $05,x	                lda 5,x
.8850	95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.8852	68		pla		                pla
.8853	95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8855	68		pla		                pla
.8856	95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.8858	a5 00		lda $00		                lda cp                  ; LSB of cp
.885a	95 02		sta $02,x	                sta 2,x
.885c	a5 01		lda $01		                lda cp+1
.885e	95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.8860	a0 00		ldy #$00	                ldy #0
.8862					_strip_loop:
.8862	b9 d2 88	lda $88d2,y	                lda _strip_table,y      ; LSB of first word
.8865	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8867	d0 07		bne $8870	                bne _next_entry
.8869	b9 d3 88	lda $88d3,y	                lda _strip_table+1,y
.886c	d5 05		cmp $05,x	                cmp 5,x
.886e	f0 0c		beq $887c	                beq _found_entry
.8870					_next_entry:
.8870	b9 d2 88	lda $88d2,y	                lda _strip_table,y      ; pointing to LSB
.8873	19 d3 88	ora $88d3,y	                ora _strip_table+1,y    ; get MSB
.8876	f0 22		beq $889a	                beq _underflow_strip    ; table done, let's get out of here
.8878	c8		iny		                iny
.8879	c8		iny		                iny
.887a	80 e6		bra $8862	                bra _strip_loop
.887c					_found_entry:
.887c	98		tya		                tya
.887d	4a		lsr a		                lsr
.887e	a8		tay		                tay
.887f	b9 de 88	lda $88de,y	                lda _strip_size,y
.8882	85 2c		sta $2c		                sta tmptos              ; save a copy
.8884	18		clc		                clc
.8885	75 04		adc $04,x	                adc 4,x
.8887	95 04		sta $04,x	                sta 4,x
.8889	90 02		bcc $888d	                bcc+
.888b	f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.888d					+
.888d	06 2c		asl $2c		                asl tmptos
.888f	38		sec		                sec
.8890	b5 00		lda $00,x	                lda 0,x
.8892	e5 2c		sbc $2c		                sbc tmptos
.8894	95 00		sta $00,x	                sta 0,x
.8896	b0 02		bcs $889a	                bcs +
.8898	d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.889a					+
.889a					_underflow_strip:
.889a	a5 1c		lda $1c		                lda uf_strip
.889c	05 1d		ora $1d		                ora uf_strip+1
.889e	f0 1c		beq $88bc	                beq _specials_done
.88a0	a5 28		lda $28		                lda tmp3
.88a2	29 10		and #$10	                and #UF
.88a4	f0 16		beq $88bc	                beq _specials_done
.88a6	18		clc		                clc
.88a7	b5 04		lda $04,x	                lda 4,x
.88a9	69 03		adc #$03	                adc #3
.88ab	95 04		sta $04,x	                sta 4,x
.88ad	90 02		bcc $88b1	                bcc +
.88af	f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.88b1					+
.88b1	38		sec		                sec
.88b2	b5 00		lda $00,x	                lda 0,x
.88b4	e9 03		sbc #$03	                sbc #3
.88b6	95 00		sta $00,x	                sta 0,x
.88b8	b0 02		bcs $88bc	                bcs +
.88ba	d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.88bc					+
.88bc					_specials_done:
.88bc	b5 01		lda $01,x	                lda 1,x                 ; MSB
.88be	48		pha		                pha
.88bf	b5 00		lda $00,x	                lda 0,x                 ; LSB
.88c1	48		pha		                pha
.88c2	20 bc 95	jsr $95bc	                jsr xt_move
.88c5	18		clc		                clc
.88c6	68		pla		                pla                     ; LSB
.88c7	65 00		adc $00		                adc cp
.88c9	85 00		sta $00		                sta cp
.88cb	68		pla		                pla                     ; MSB
.88cc	65 01		adc $01		                adc cp+1
.88ce	85 01		sta $01		                sta cp+1
.88d0	80 2c		bra $88fe	                bra _done
.88d2					_strip_table:
>88d2	7d 9a 68 9a 55 a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88d8	87 a4 0d a4 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88de					_strip_size:
>88de	04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88e4					_compile_as_jump:
.88e4	a9 20		lda #$20	                lda #$20
.88e6	92 00		sta ($00)	                sta (cp)
.88e8	a0 01		ldy #$01	                ldy #1
.88ea	68		pla		                pla             ; LSB
.88eb	91 00		sta ($00),y	                sta (cp),y
.88ed	c8		iny		                iny
.88ee	68		pla		                pla             ; MSB
.88ef	91 00		sta ($00),y	                sta (cp),y
.88f1	a9 03		lda #$03	                lda #3
.88f3	18		clc		                clc
.88f4	65 00		adc $00		                adc cp
.88f6	85 00		sta $00		                sta cp
.88f8	90 02		bcc $88fc	                bcc +
.88fa	e6 01		inc $01		                inc cp+1
.88fc					+
.88fc	e8		inx		                inx             ; drop xt
.88fd	e8		inx		                inx
.88fe					_done:
.88fe					z_compile_comma:
.88fe	60		rts		                rts
.88ff					xt_compile_only:
.88ff	20 56 d7	jsr $d756	                jsr current_to_dp
.8902	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8904	b1 02		lda ($02),y	                lda (dp),y
.8906	09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.8908	91 02		sta ($02),y	                sta (dp),y
.890a	60		rts		z_compile_only: rts
.890b					xt_value:
.890b					xt_constant:
.890b	20 14 d8	jsr $d814	                jsr underflow_1
.890e	20 63 89	jsr $8963	                jsr xt_create
.8911	38		sec		                sec
.8912	a5 00		lda $00		                lda cp
.8914	e9 02		sbc #$02	                sbc #2
.8916	85 24		sta $24		                sta tmp1
.8918	a5 01		lda $01		                lda cp+1
.891a	e9 00		sbc #$00	                sbc #0
.891c	85 25		sta $25		                sta tmp1+1
.891e	a9 d0		lda #$d0	                lda #<doconst           ; LSB of DOCONST
.8920	92 24		sta ($24)	                sta (tmp1)
.8922	a0 01		ldy #$01	                ldy #1
.8924	a9 d6		lda #$d6	                lda #>doconst           ; MSB of DOCONST
.8926	91 24		sta ($24),y	                sta (tmp1),y
.8928	20 68 87	jsr $8768	                jsr xt_comma            ; drop through to adjust_z
.892b					adjust_z:
.892b	20 35 93	jsr $9335	                jsr xt_latestnt         ; gives us ( -- nt )
.892e	b5 00		lda $00,x	                lda 0,x
.8930	85 24		sta $24		                sta tmp1
.8932	b5 01		lda $01,x	                lda 1,x
.8934	85 25		sta $25		                sta tmp1+1
.8936	a0 06		ldy #$06	                ldy #6
.8938	b1 24		lda ($24),y	                lda (tmp1),y
.893a	18		clc		                clc
.893b	69 02		adc #$02	                adc #2
.893d	91 24		sta ($24),y	                sta (tmp1),y
.893f	c8		iny		                iny
.8940	b1 24		lda ($24),y	                lda (tmp1),y
.8942	69 00		adc #$00	                adc #0                  ; only need carry
.8944	91 24		sta ($24),y	                sta (tmp1),y
.8946	e8		inx		                inx
.8947	e8		inx		                inx
.8948					z_value:
.8948	60		rts		z_constant:     rts
.8949					xt_count:
.8949	20 14 d8	jsr $d814	                jsr underflow_1
.894c	a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.894e	a8		tay		                tay
.894f	f6 00		inc $00,x	                inc 0,x         ; LSB
.8951	d0 02		bne $8955	                bne +
.8953	f6 01		inc $01,x	                inc 1,x         ; MSB
.8955	98		tya		+               tya
.8956	ca		dex		                dex
.8957	ca		dex		                dex
.8958	95 00		sta $00,x	                sta 0,x         ; LSB
.895a	74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.895c	60		rts		z_count:        rts
.895d					xt_cr:
.895d	a9 0a		lda #$0a	                lda #AscLF
.895f	20 f0 8d	jsr $8df0	                jsr emit_a
.8962	60		rts		z_cr:           rts
.8963					xt_create:
.8963	20 ca 98	jsr $98ca	                jsr xt_parse_name       ; ( addr u )
.8966	b5 00		lda $00,x	                lda 0,x
.8968	15 01		ora $01,x	                ora 1,x
.896a	d0 05		bne $8971	                bne _got_name
.896c	a9 05		lda #$05	                lda #err_noname
.896e	4c 2a d8	jmp $d82a	                jmp error
.8971					_got_name:
.8971	74 01		stz $01,x	                stz 1,x
.8973	20 9d a3	jsr $a39d	                jsr xt_two_dup          ; ( addr u addr u )
.8976	20 d5 8f	jsr $8fd5	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8979	b5 00		lda $00,x	                lda 0,x
.897b	15 01		ora $01,x	                ora 1,x
.897d	f0 1e		beq $899d	                beq _new_name           ; We haven't seen this one before.
.897f	e8		inx		                inx                     ; Drop flag (nt) from find-name.
.8980	e8		inx		                inx
.8981	24 20		bit $20		                bit status
.8983	10 08		bpl $898d	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8985	a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8987	05 20		ora $20		                ora status
.8989	85 20		sta $20		                sta status
.898b	80 18		bra $89a5	                bra _process_name
.898d					_redefined_name:
.898d	a9 02		lda #$02	                lda #str_redefined
.898f	20 40 d8	jsr $d840	                jsr print_string_no_lf
.8992	20 9d a3	jsr $a39d	                jsr xt_two_dup           ; ( addr u addr u )
.8995	20 e8 a4	jsr $a4e8	                jsr xt_type
.8998	20 09 a1	jsr $a109	                jsr xt_space
.899b	80 08		bra $89a5	                bra _process_name
.899d					_new_name:
.899d	e8		inx		                inx                     ; Drop flag (0) from find-name.
.899e	e8		inx		                inx
.899f	a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.89a1	25 20		and $20		                and status
.89a3	85 20		sta $20		                sta status
.89a5					_process_name:
.89a5	b5 00		lda $00,x	                lda 0,x
.89a7	85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.89a9	a5 00		lda $00		                lda cp
.89ab	85 24		sta $24		                sta tmp1
.89ad	a5 01		lda $01		                lda cp+1
.89af	85 25		sta $25		                sta tmp1+1
.89b1	b5 00		lda $00,x	                lda 0,x
.89b3	18		clc		                clc
.89b4	69 08		adc #$08	                adc #8
.89b6	85 28		sta $28		                sta tmp3                ; total header length
.89b8	18		clc		                clc
.89b9	69 03		adc #$03	                adc #3
.89bb	95 00		sta $00,x	                sta 0,x
.89bd	74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.89bf	20 ab 82	jsr $82ab	                jsr xt_allot    ; ( addr )
.89c2	20 56 d7	jsr $d756	                jsr current_to_dp
.89c5	a0 00		ldy #$00	                ldy #0
.89c7	a5 26		lda $26		                lda tmp2
.89c9	91 24		sta ($24),y	                sta (tmp1),y
.89cb	a9 08		lda #$08	                lda #NN
.89cd	09 20		ora #$20	                ora #HC
.89cf	c8		iny		                iny
.89d0	91 24		sta ($24),y	                sta (tmp1),y
.89d2	c8		iny		                iny
.89d3	a5 02		lda $02		                lda dp
.89d5	91 24		sta ($24),y	                sta (tmp1),y
.89d7	c8		iny		                iny
.89d8	a5 03		lda $03		                lda dp+1
.89da	91 24		sta ($24),y	                sta (tmp1),y
.89dc	c8		iny		                iny
.89dd	a5 25		lda $25		                lda tmp1+1
.89df	85 03		sta $03		                sta dp+1
.89e1	a5 24		lda $24		                lda tmp1
.89e3	85 02		sta $02		                sta dp
.89e5	18		clc		                clc
.89e6	65 28		adc $28		                adc tmp3        ; add total header length
.89e8	91 24		sta ($24),y	                sta (tmp1),y
.89ea	48		pha		                pha             ; we need this in the next step
.89eb	c8		iny		                iny
.89ec	a5 25		lda $25		                lda tmp1+1
.89ee	69 00		adc #$00	                adc #0          ; only need the carry
.89f0	91 24		sta ($24),y	                sta (tmp1),y
.89f2	c8		iny		                iny
.89f3	68		pla		                pla             ; LSB of "z_" address
.89f4	18		clc		                clc
.89f5	69 03		adc #$03	                adc #3
.89f7	91 24		sta ($24),y	                sta (tmp1),y
.89f9	88		dey		                dey             ; get the MSB of xt back
.89fa	b1 24		lda ($24),y	                lda (tmp1),y
.89fc	69 00		adc #$00	                adc #0          ; only need the carry
.89fe	c8		iny		                iny
.89ff	c8		iny		                iny
.8a00	91 24		sta ($24),y	                sta (tmp1),y
.8a02	c8		iny		                iny
.8a03	b5 00		lda $00,x	                lda 0,x
.8a05	38		sec		                sec
.8a06	e9 08		sbc #$08	                sbc #8
.8a08	85 2c		sta $2c		                sta tmptos
.8a0a	b5 01		lda $01,x	                lda 1,x
.8a0c	e9 00		sbc #$00	                sbc #0          ; only need carry
.8a0e	85 2d		sta $2d		                sta tmptos+1
.8a10					_name_loop:
.8a10	b1 2c		lda ($2c),y	                lda (tmptos),y
.8a12	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8a14	b0 07		bcs $8a1d	                bcs _store_name
.8a16	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8a18	90 03		bcc $8a1d	                bcc _store_name
.8a1a	18		clc		                clc
.8a1b	69 20		adc #$20	                adc #$20
.8a1d					_store_name:
.8a1d	91 24		sta ($24),y	                sta (tmp1),y
.8a1f	c8		iny		                iny
.8a20	c6 26		dec $26		                dec tmp2
.8a22	d0 ec		bne $8a10	                bne _name_loop
.8a24	a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a26	91 24		sta ($24),y	                sta (tmp1),y
.8a28	c8		iny		                iny
.8a29	a9 16		lda #$16	                lda #<dovar
.8a2b	91 24		sta ($24),y	                sta (tmp1),y
.8a2d	c8		iny		                iny
.8a2e	a9 d7		lda #$d7	                lda #>dovar
.8a30	91 24		sta ($24),y	                sta (tmp1),y
.8a32	20 69 d7	jsr $d769	                jsr dp_to_current
.8a35	e8		inx		                inx
.8a36	e8		inx		                inx
.8a37	60		rts		z_create:       rts
.8a38					xt_d_minus:
.8a38	20 23 d8	jsr $d823	                jsr underflow_4 ; two double numbers
.8a3b	38		sec		                sec
.8a3c	b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a3e	f5 02		sbc $02,x	                sbc 2,x
.8a40	95 06		sta $06,x	                sta 6,x
.8a42	b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a44	f5 03		sbc $03,x	                sbc 3,x
.8a46	95 07		sta $07,x	                sta 7,x
.8a48	b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a4a	f5 00		sbc $00,x	                sbc 0,x
.8a4c	95 04		sta $04,x	                sta 4,x
.8a4e	b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a50	f5 01		sbc $01,x	                sbc 1,x
.8a52	95 05		sta $05,x	                sta 5,x
.8a54	e8		inx		                inx
.8a55	e8		inx		                inx
.8a56	e8		inx		                inx
.8a57	e8		inx		                inx
.8a58	60		rts		z_d_minus:      rts
.8a59					xt_d_plus:
.8a59	20 23 d8	jsr $d823	                jsr underflow_4 ; two double numbers
.8a5c	18		clc		                clc
.8a5d	b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a5f	75 06		adc $06,x	                adc 6,x
.8a61	95 06		sta $06,x	                sta 6,x
.8a63	b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a65	75 07		adc $07,x	                adc 7,x
.8a67	95 07		sta $07,x	                sta 7,x
.8a69	b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a6b	75 04		adc $04,x	                adc 4,x
.8a6d	95 04		sta $04,x	                sta 4,x
.8a6f	b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a71	75 05		adc $05,x	                adc 5,x
.8a73	95 05		sta $05,x	                sta 5,x
.8a75	e8		inx		                inx
.8a76	e8		inx		                inx
.8a77	e8		inx		                inx
.8a78	e8		inx		                inx
.8a79	60		rts		z_d_plus:       rts
.8a7a					xt_d_to_s:
.8a7a	20 19 d8	jsr $d819	                jsr underflow_2
.8a7d	e8		inx		                inx
.8a7e	e8		inx		                inx
.8a7f	60		rts		z_d_to_s:       rts
.8a80					xt_dabs:
.8a80	20 19 d8	jsr $d819	                jsr underflow_2 ; double number
.8a83	b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a85	10 17		bpl $8a9e	                bpl _done       ; positive, we get off light
.8a87	a0 00		ldy #$00	                ldy #0
.8a89	38		sec		                sec
.8a8a	98		tya		                tya
.8a8b	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a8d	95 02		sta $02,x	                sta 2,x
.8a8f	98		tya		                tya
.8a90	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a92	95 03		sta $03,x	                sta 3,x
.8a94	98		tya		                tya
.8a95	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a97	95 00		sta $00,x	                sta 0,x
.8a99	98		tya		                tya
.8a9a	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a9c	95 01		sta $01,x	                sta 1,x
.8a9e					_done:
.8a9e	60		rts		z_dabs:         rts
.8a9f					xt_decimal:
.8a9f	a9 0a		lda #$0a	                lda #10
.8aa1	85 18		sta $18		                sta base
.8aa3	64 19		stz $19		                stz base+1              ; paranoid
.8aa5	60		rts		z_decimal:      rts
.8aa6					xt_defer:
.8aa6	20 63 89	jsr $8963	                jsr xt_create
.8aa9	a5 00		lda $00		                lda cp          ; LSB
.8aab	38		sec		                sec
.8aac	e9 02		sbc #$02	                sbc #2
.8aae	85 24		sta $24		                sta tmp1
.8ab0	a5 01		lda $01		                lda cp+1        ; MSB
.8ab2	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8ab4	85 25		sta $25		                sta tmp1+1
.8ab6	a0 00		ldy #$00	                ldy #0
.8ab8	a9 e4		lda #$e4	                lda #<dodefer   ; LSB
.8aba	91 24		sta ($24),y	                sta (tmp1),y
.8abc	c8		iny		                iny
.8abd	a9 d6		lda #$d6	                lda #>dodefer   ; MSB
.8abf	91 24		sta ($24),y	                sta (tmp1),y
.8ac1	a9 f8		lda #$f8	                lda #<defer_error
.8ac3	92 00		sta ($00)	                sta (cp)
.8ac5	e6 00		inc $00		                inc cp
.8ac7	d0 02		bne $8acb	                bne +
.8ac9	e6 01		inc $01		                inc cp+1
.8acb					+
.8acb	a9 d6		lda #$d6	                lda #>defer_error
.8acd	92 00		sta ($00)	                sta (cp)
.8acf	e6 00		inc $00		                inc cp
.8ad1	d0 02		bne $8ad5	                bne +
.8ad3	e6 01		inc $01		                inc cp+1
.8ad5					+
.8ad5	20 2b 89	jsr $892b	                jsr adjust_z    ; adjust header to correct length
.8ad8	60		rts		z_defer:        rts
.8ad9					xt_defer_fetch:
.8ad9	20 72 a2	jsr $a272	                jsr xt_to_body
.8adc	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.8adf	60		rts		z_defer_fetch:  rts
.8ae0					xt_defer_store:
.8ae0	20 72 a2	jsr $a272	                jsr xt_to_body
.8ae3	20 72 a1	jsr $a172	                jsr xt_store
.8ae6	60		rts		z_defer_store:  rts
.8ae7					xt_definitions:
.8ae7	a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8ae9	b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8aeb	a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8aed	91 1e		sta ($1e),y	                sta (up),y
.8aef	60		rts		z_definitions:  rts
.8af0					xt_depth:
.8af0	a9 78		lda #$78	                lda #dsp0
.8af2	86 2a		stx $2a		                stx tmpdsp
.8af4	38		sec		                sec
.8af5	e5 2a		sbc $2a		                sbc tmpdsp
.8af7	4a		lsr a		                lsr
.8af8	ca		dex		                dex
.8af9	ca		dex		                dex
.8afa	95 00		sta $00,x	                sta 0,x
.8afc	74 01		stz $01,x	                stz 1,x
.8afe	60		rts		z_depth:        rts
.8aff					xt_digit_question:
.8aff	20 14 d8	jsr $d814	                jsr underflow_1
.8b02	ca		dex		                dex
.8b03	ca		dex		                dex
.8b04	74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8b06	74 01		stz $01,x	                stz 1,x
.8b08	74 03		stz $03,x	                stz 3,x                 ; paranoid
.8b0a	b5 02		lda $02,x	                lda 2,x
.8b0c	c9 30		cmp #$30	                cmp #'0'
.8b0e	90 23		bcc $8b33	                bcc _done               ; failure flag already set
.8b10	c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8b12	90 12		bcc $8b26	                bcc _checkbase
.8b14	c9 41		cmp #$41	                cmp #'A'
.8b16	90 1b		bcc $8b33	                bcc _done               ; failure flag is already set
.8b18	c9 61		cmp #$61	                cmp #'a'
.8b1a	90 07		bcc $8b23	                bcc _case_done          ; not lower case, too low
.8b1c	c9 7b		cmp #$7b	                cmp #'z'+1
.8b1e	b0 03		bcs $8b23	                bcs _case_done          ; not lower case, too high
.8b20	18		clc		                clc                     ; just right
.8b21	69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b23					_case_done:
.8b23	38		sec		                sec
.8b24	e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b26					_checkbase:
.8b26	38		sec		                sec
.8b27	e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b29	c5 18		cmp $18		                cmp base
.8b2b	b0 06		bcs $8b33	                bcs _done               ; already have false flag
.8b2d	95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b2f	d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b31	d6 01		dec $01,x	                dec 1,x
.8b33					_done:
.8b33					z_digit_question:
.8b33	60		rts		                rts
.8b34					xt_disasm:
.8b34	20 19 d8	jsr $d819	                jsr underflow_2
.8b37	20 bc ac	jsr $acbc	                jsr disassembler
.8b3a	60		rts		z_disasm:       rts
.8b3b					xt_dnegate:
.8b3b	20 19 d8	jsr $d819	                jsr underflow_2 ; double number
.8b3e	a0 00		ldy #$00	     		ldy #0
.8b40	38		sec		                sec
.8b41	98		tya		                tya
.8b42	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b44	95 02		sta $02,x	                sta 2,x
.8b46	98		tya		                tya
.8b47	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b49	95 03		sta $03,x	                sta 3,x
.8b4b	98		tya		                tya
.8b4c	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b4e	95 00		sta $00,x	                sta 0,x
.8b50	98		tya		                tya
.8b51	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b53	95 01		sta $01,x	                sta 1,x
.8b55	60		rts		z_dnegate:      rts
.8b56					xt_question_do:
.8b56	a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b58	85 24		sta $24		                sta tmp1
.8b5a	80 02		bra $8b5e	                bra do_common           ; skip flag for DO
.8b5c					xt_do:
.8b5c	64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b5e					do_common:
.8b5e	ca		dex		                dex
.8b5f	ca		dex		                dex
.8b60	a5 00		lda $00		                lda cp
.8b62	95 00		sta $00,x	                sta 0,x                 ; LSB
.8b64	a5 01		lda $01		                lda cp+1
.8b66	95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b68	a9 05		lda #$05	                lda #5                  ; we don't really care about the value,
.8b6a	a8		tay		                tay                     ; so we use 5 to be tricky
.8b6b					_loop:
.8b6b	91 00		sta ($00),y	                sta (CP),y
.8b6d	88		dey		                dey
.8b6e	10 fb		bpl $8b6b	                bpl _loop
.8b70	1a		inc a		                ina             ; we used 5 as a dummy value, this is why
.8b71	18		clc		                clc
.8b72	65 00		adc $00		                adc CP
.8b74	85 00		sta $00		                sta CP
.8b76	90 02		bcc $8b7a	                bcc +
.8b78	e6 01		inc $01		                inc CP+1
.8b7a					+
.8b7a	a5 24		lda $24		                lda tmp1
.8b7c	f0 17		beq $8b95	                beq _compile_do
.8b7e	a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b80	5a		phy		                phy             ; save counter to calculate new CP
.8b81					-
.8b81	b9 db 8b	lda $8bdb,y	                lda question_do_runtime,y
.8b84	91 00		sta ($00),y	                sta (cp),y
.8b86	88		dey		                dey
.8b87	10 f8		bpl $8b81	                bpl -
.8b89	68		pla		                pla             ; retrieve counter
.8b8a	18		clc		                clc
.8b8b	65 00		adc $00		                adc cp
.8b8d	85 00		sta $00		                sta cp
.8b8f	a5 01		lda $01		                lda cp+1
.8b91	69 00		adc #$00	                adc #0          ; only care about carry
.8b93	85 01		sta $01		                sta cp+1        ; fall through to _compile_do
.8b95					_compile_do:
.8b95	a0 24		ldy #$24	                ldy #do_runtime_end-do_runtime  ; counter
.8b97	5a		phy		                phy             ; save counter to calculate new CP
.8b98					-
.8b98	b9 b7 8b	lda $8bb7,y	                lda do_runtime,y
.8b9b	91 00		sta ($00),y	                sta (cp),y
.8b9d	88		dey		                dey
.8b9e	10 f8		bpl $8b98	                bpl -
.8ba0	68		pla		                pla             ; retrieve counter
.8ba1	18		clc		                clc
.8ba2	65 00		adc $00		                adc cp
.8ba4	85 00		sta $00		                sta cp
.8ba6	a5 01		lda $01		                lda cp+1
.8ba8	69 00		adc #$00	                adc #0          ; only care about carry
.8baa	85 01		sta $01		                sta cp+1
.8bac	ca		dex		                dex
.8bad	ca		dex		                dex
.8bae	a5 00		lda $00		                lda CP          ; LSB
.8bb0	95 00		sta $00,x	                sta 0,x
.8bb2	a5 01		lda $01		                lda CP+1        ; MSB
.8bb4	95 01		sta $01,x	                sta 1,x
.8bb6					z_question_do:
.8bb6	60		rts		z_do:           rts
.8bb7					do_runtime:
.8bb7	38		sec		                sec
.8bb8	a9 00		lda #$00	                lda #0
.8bba	f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8bbc	95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8bbe	a9 80		lda #$80	                lda #$80
.8bc0	f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8bc2	95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8bc4	48		pha		                pha             ; FUFA replaces limit on R stack
.8bc5	b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8bc7	48		pha		                pha
.8bc8	18		clc		                clc
.8bc9	b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8bcb	75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8bcd	95 00		sta $00,x	                sta 0,x
.8bcf	b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8bd1	75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8bd3	48		pha		                pha
.8bd4	b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8bd6	48		pha		                pha
.8bd7	e8		inx		                inx
.8bd8	e8		inx		                inx
.8bd9	e8		inx		                inx
.8bda	e8		inx		                inx             ; no RTS because this is copied into code
.8bdb					do_runtime_end:
.8bdb					question_do_runtime:
.8bdb	20 9d a3	jsr $a39d	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8bde	20 c8 8e	jsr $8ec8	                jsr xt_equal            ; ( -- n1 n2 f )
.8be1	b5 00		lda $00,x	                lda 0,x
.8be3	15 01		ora $01,x	                ora 1,x
.8be5	f0 06		beq $8bed	                beq _do_do
.8be7	8a		txa		                txa
.8be8	18		clc		                clc
.8be9	69 06		adc #$06	                adc #6
.8beb	aa		tax		                tax
.8bec	60		rts		                rts
.8bed					_do_do:
.8bed	e8		inx		                inx             ; clear flag from EQUAL off stack
.8bee	e8		inx		                inx             ; no RTS because this is copied into code
.8bef					question_do_runtime_end:
.8bef					xt_does:
.8bef	a0 8b		ldy #$8b	                ldy #>does_runtime
.8bf1	a9 fe		lda #$fe	                lda #<does_runtime
.8bf3	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.8bf6	a0 d6		ldy #$d6	                ldy #>dodoes
.8bf8	a9 fd		lda #$fd	                lda #<dodoes
.8bfa	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.8bfd	60		rts		z_does:         rts
.8bfe					does_runtime:
.8bfe	7a		ply		                ply             ; LSB
.8bff	68		pla		                pla             ; MSB
.8c00	c8		iny		                iny
.8c01	d0 01		bne $8c04	                bne +
.8c03	1a		inc a		                ina
.8c04					+
.8c04	84 24		sty $24		                sty tmp1
.8c06	85 25		sta $25		                sta tmp1+1
.8c08	20 56 d7	jsr $d756	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8c0b	a5 02		lda $02		                lda dp
.8c0d	18		clc		                clc
.8c0e	69 04		adc #$04	                adc #4
.8c10	85 26		sta $26		                sta tmp2
.8c12	a5 03		lda $03		                lda dp+1
.8c14	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c16	85 27		sta $27		                sta tmp2+1
.8c18	b2 26		lda ($26)	                lda (tmp2)
.8c1a	18		clc		                clc
.8c1b	69 01		adc #$01	                adc #1
.8c1d	85 28		sta $28		                sta tmp3
.8c1f	a0 01		ldy #$01	                ldy #1
.8c21	b1 26		lda ($26),y	                lda (tmp2),y
.8c23	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c25	85 29		sta $29		                sta tmp3+1
.8c27	a5 24		lda $24		                lda tmp1        ; LSB
.8c29	92 28		sta ($28)	                sta (tmp3)
.8c2b	a5 25		lda $25		                lda tmp1+1
.8c2d	91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8c2f	60		rts		                rts
.8c30					xt_dot:
.8c30	20 14 d8	jsr $d814	                jsr underflow_1
.8c33	20 a9 8d	jsr $8da9	                jsr xt_dup                      ; ( n n )
.8c36	20 39 81	jsr $8139	                jsr xt_abs                      ; ( n u )
.8c39	20 8d a7	jsr $a78d	                jsr xt_zero                     ; ( n u 0 )
.8c3c	20 54 93	jsr $9354	                jsr xt_less_number_sign         ; ( n u 0 )
.8c3f	20 c9 97	jsr $97c9	                jsr xt_number_sign_s            ; ( n ud )
.8c42	20 42 9b	jsr $9b42	                jsr xt_rot                      ; ( ud n )
.8c45	20 d2 9f	jsr $9fd2	                jsr xt_sign                     ; ( ud )
.8c48	20 a7 97	jsr $97a7	                jsr xt_number_sign_greater      ; ( addr u )
.8c4b	20 e8 a4	jsr $a4e8	                jsr xt_type
.8c4e	20 09 a1	jsr $a109	                jsr xt_space
.8c51	60		rts		z_dot:          rts
.8c52					xt_dot_paren:
.8c52	ca		dex		                dex
.8c53	ca		dex		                dex
.8c54	a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c56	95 00		sta $00,x	                sta 0,x
.8c58	74 01		stz $01,x	                stz 1,x
.8c5a	20 25 99	jsr $9925	                jsr xt_parse
.8c5d	20 e8 a4	jsr $a4e8	                jsr xt_type
.8c60	60		rts		z_dot_paren:    rts
.8c61					xt_dot_quote:
.8c61	20 3a 9d	jsr $9d3a	                jsr xt_s_quote
.8c64	a0 a4		ldy #$a4	                ldy #>xt_type
.8c66	a9 e8		lda #$e8	                lda #<xt_type
.8c68	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.8c6b	60		rts		z_dot_quote:    rts
.8c6c					xt_dot_r:
.8c6c	20 19 d8	jsr $d819	                jsr underflow_2
.8c6f	20 55 a3	jsr $a355	                jsr xt_to_r
.8c72	20 a9 8d	jsr $8da9	                jsr xt_dup
.8c75	20 39 81	jsr $8139	                jsr xt_abs
.8c78	20 8d a7	jsr $a78d	                jsr xt_zero
.8c7b	20 54 93	jsr $9354	                jsr xt_less_number_sign
.8c7e	20 c9 97	jsr $97c9	                jsr xt_number_sign_s
.8c81	20 42 9b	jsr $9b42	                jsr xt_rot
.8c84	20 d2 9f	jsr $9fd2	                jsr xt_sign
.8c87	20 a7 97	jsr $97a7	                jsr xt_number_sign_greater
.8c8a	20 7d 9a	jsr $9a7d	                jsr xt_r_from
.8c8d	20 7e 98	jsr $987e	                jsr xt_over
.8c90	20 4a 95	jsr $954a	                jsr xt_minus
.8c93	20 0f a1	jsr $a10f	                jsr xt_spaces
.8c96	20 e8 a4	jsr $a4e8	                jsr xt_type
.8c99	60		rts		z_dot_r:        rts
.8c9a					xt_dot_s:
.8c9a	20 f0 8a	jsr $8af0	                jsr xt_depth    ; ( -- u )
.8c9d	a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8c9f	20 f0 8d	jsr $8df0	                jsr emit_a
.8ca2	b5 00		lda $00,x	                lda 0,x
.8ca4	48		pha		                pha
.8ca5	ca		dex		                dex             ; DUP
.8ca6	ca		dex		                dex
.8ca7	95 00		sta $00,x	                sta 0,x
.8ca9	74 01		stz $01,x	                stz 1,x
.8cab	20 60 d8	jsr $d860	                jsr print_u
.8cae	a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8cb0	20 f0 8d	jsr $8df0	                jsr emit_a
.8cb3	a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8cb5	20 f0 8d	jsr $8df0	                jsr emit_a
.8cb8	e8		inx		                inx
.8cb9	e8		inx		                inx
.8cba	e0 78		cpx #$78	                cpx #dsp0
.8cbc	f0 1e		beq $8cdc	                beq _done
.8cbe					_have_stack:
.8cbe	7a		ply		                ply
.8cbf	a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8cc1	85 28		sta $28		                sta tmp3
.8cc3	64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8cc5					_loop:
.8cc5	ca		dex		                dex
.8cc6	ca		dex		                dex
.8cc7	b2 28		lda ($28)	                lda (tmp3)
.8cc9	95 01		sta $01,x	                sta 1,x
.8ccb	c6 28		dec $28		                dec tmp3
.8ccd	b2 28		lda ($28)	                lda (tmp3)
.8ccf	95 00		sta $00,x	                sta 0,x
.8cd1	c6 28		dec $28		                dec tmp3
.8cd3	5a		phy		                phy
.8cd4	20 30 8c	jsr $8c30	                jsr xt_dot
.8cd7	7a		ply		                ply
.8cd8	88		dey		                dey
.8cd9	d0 ea		bne $8cc5	                bne _loop
.8cdb	48		pha		                pha             ; dummy to balance stack
.8cdc					_done:
.8cdc	68		pla		                pla
.8cdd	60		rts		z_dot_s:        rts
.8cde					xt_d_dot:
.8cde	20 19 d8	jsr $d819	                jsr underflow_2
.8ce1	20 72 a3	jsr $a372	                jsr xt_tuck
.8ce4	20 80 8a	jsr $8a80	                jsr xt_dabs
.8ce7	20 54 93	jsr $9354	                jsr xt_less_number_sign
.8cea	20 c9 97	jsr $97c9	                jsr xt_number_sign_s
.8ced	20 42 9b	jsr $9b42	                jsr xt_rot
.8cf0	20 d2 9f	jsr $9fd2	                jsr xt_sign
.8cf3	20 a7 97	jsr $97a7	                jsr xt_number_sign_greater
.8cf6	20 e8 a4	jsr $a4e8	                jsr xt_type
.8cf9	20 09 a1	jsr $a109	                jsr xt_space
.8cfc	60		rts		z_d_dot:        rts
.8cfd					xt_d_dot_r:
.8cfd	20 1e d8	jsr $d81e	                jsr underflow_3
.8d00	20 55 a3	jsr $a355	                jsr xt_to_r
.8d03	20 72 a3	jsr $a372	                jsr xt_tuck
.8d06	20 80 8a	jsr $8a80	                jsr xt_dabs
.8d09	20 54 93	jsr $9354	                jsr xt_less_number_sign
.8d0c	20 c9 97	jsr $97c9	                jsr xt_number_sign_s
.8d0f	20 42 9b	jsr $9b42	                jsr xt_rot
.8d12	20 d2 9f	jsr $9fd2	                jsr xt_sign
.8d15	20 a7 97	jsr $97a7	                jsr xt_number_sign_greater
.8d18	20 7d 9a	jsr $9a7d	                jsr xt_r_from
.8d1b	20 7e 98	jsr $987e	                jsr xt_over
.8d1e	20 4a 95	jsr $954a	                jsr xt_minus
.8d21	20 0f a1	jsr $a10f	                jsr xt_spaces
.8d24	20 e8 a4	jsr $a4e8	                jsr xt_type
.8d27	60		rts		z_d_dot_r:      rts
.8d28					xt_drop:
.8d28	20 14 d8	jsr $d814	                jsr underflow_1
.8d2b	e8		inx		                inx
.8d2c	e8		inx		                inx
.8d2d	60		rts		z_drop:         rts
.8d2e					xt_dump:
.8d2e	20 19 d8	jsr $d819	                jsr underflow_2
.8d31					_row:
.8d31	a0 10		ldy #$10	                ldy #16
.8d33	64 26		stz $26		                stz tmp2
.8d35	20 5d 89	jsr $895d	                jsr xt_cr
.8d38	b5 03		lda $03,x	                lda 3,x
.8d3a	20 24 d7	jsr $d724	                jsr byte_to_ascii
.8d3d	b5 02		lda $02,x	                lda 2,x
.8d3f	20 24 d7	jsr $d724	                jsr byte_to_ascii
.8d42	20 09 a1	jsr $a109	                jsr xt_space
.8d45	20 09 a1	jsr $a109	                jsr xt_space
.8d48					_loop:
.8d48	b5 00		lda $00,x	                lda 0,x
.8d4a	15 01		ora $01,x	                ora 1,x
.8d4c	f0 39		beq $8d87	                beq _all_printed
.8d4e	a1 02		lda ($02,x)	                lda (2,x)
.8d50	48		pha		                pha                     ; byte_to_ascii destroys A
.8d51	20 24 d7	jsr $d724	                jsr byte_to_ascii
.8d54	20 09 a1	jsr $a109	                jsr xt_space
.8d57	68		pla		                pla
.8d58	20 fa d7	jsr $d7fa	                jsr is_printable
.8d5b	b0 02		bcs $8d5f	                bcs _printable
.8d5d	a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d5f					_printable:
.8d5f	5a		phy		                phy                     ; save counter
.8d60	a4 26		ldy $26		                ldy tmp2
.8d62	91 00		sta ($00),y	                sta (cp),y
.8d64	e6 26		inc $26		                inc tmp2
.8d66	7a		ply		                ply
.8d67	c0 09		cpy #$09	                cpy #9
.8d69	d0 03		bne $8d6e	                bne _next_char
.8d6b	20 09 a1	jsr $a109	                jsr xt_space
.8d6e					_next_char:
.8d6e	f6 02		inc $02,x	                inc 2,x
.8d70	d0 02		bne $8d74	                bne _counter
.8d72	f6 03		inc $03,x	                inc 3,x
.8d74					_counter:
.8d74	b5 00		lda $00,x	                lda 0,x
.8d76	d0 02		bne $8d7a	                bne +
.8d78	d6 01		dec $01,x	                dec 1,x
.8d7a					+
.8d7a	d6 00		dec $00,x	                dec 0,x
.8d7c	88		dey		                dey
.8d7d	d0 c9		bne $8d48	                bne _loop               ; next byte
.8d7f	20 09 a1	jsr $a109	                jsr xt_space
.8d82	20 95 8d	jsr $8d95	                jsr dump_print_ascii
.8d85	80 aa		bra $8d31	                bra _row                ; new row
.8d87					_all_printed:
.8d87	a5 26		lda $26		                lda tmp2
.8d89	f0 06		beq $8d91	                beq _done
.8d8b	20 09 a1	jsr $a109	                jsr xt_space
.8d8e	20 95 8d	jsr $8d95	                jsr dump_print_ascii
.8d91					_done:
.8d91	20 95 a3	jsr $a395	                jsr xt_two_drop         ; one byte less than 4x INX
.8d94	60		rts		z_dump:         rts
.8d95					dump_print_ascii:
.8d95	a0 00		ldy #$00	                ldy #0
.8d97					_ascii_loop:
.8d97	b1 00		lda ($00),y	                lda (cp),y
.8d99	20 f0 8d	jsr $8df0	                jsr emit_a
.8d9c	c8		iny		                iny
.8d9d	c0 08		cpy #$08	                cpy #8
.8d9f	d0 03		bne $8da4	                bne +
.8da1	20 09 a1	jsr $a109	                jsr xt_space
.8da4					+
.8da4	c6 26		dec $26		                dec tmp2
.8da6	d0 ef		bne $8d97	                bne _ascii_loop
.8da8	60		rts		                rts
.8da9					xt_dup:
.8da9	20 14 d8	jsr $d814	                jsr underflow_1
.8dac	ca		dex		                dex
.8dad	ca		dex		                dex
.8dae	b5 02		lda $02,x	                lda 2,x         ; LSB
.8db0	95 00		sta $00,x	                sta 0,x
.8db2	b5 03		lda $03,x	                lda 3,x         ; MSB
.8db4	95 01		sta $01,x	                sta 1,x
.8db6	60		rts		z_dup:          rts
.8db7					xt_ed:
.8db7	20 67 b5	jsr $b567	                jsr ed6502      ; kept in separate file
.8dba	60		rts		z_ed:           rts
.8dbb					xt_else:
.8dbb					xt_endof:
.8dbb	a0 8d		ldy #$8d	                ldy #>branch_runtime
.8dbd	a9 d5		lda #$d5	                lda #<branch_runtime
.8dbf	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.8dc2	20 6c 91	jsr $916c	                jsr xt_here
.8dc5	20 8d a7	jsr $a78d	                jsr xt_zero
.8dc8	20 68 87	jsr $8768	                jsr xt_comma
.8dcb	20 6c 91	jsr $916c	                jsr xt_here
.8dce	20 42 9b	jsr $9b42	                jsr xt_rot
.8dd1	20 72 a1	jsr $a172	                jsr xt_store
.8dd4					z_else:
.8dd4					z_endof:
.8dd4	60		rts		                rts
.8dd5					branch_runtime:
.8dd5	68		pla		                pla
.8dd6	85 22		sta $22		                sta tmpbranch
.8dd8	68		pla		                pla
.8dd9	85 23		sta $23		                sta tmpbranch+1
.8ddb	a0 01		ldy #$01	                ldy #1
.8ddd	b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8ddf	85 24		sta $24		                sta tmp1
.8de1	c8		iny		                iny
.8de2	b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8de4	85 25		sta $25		                sta tmp1+1
.8de6	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8de9					xt_emit:
.8de9	20 14 d8	jsr $d814	                jsr underflow_1
.8dec	b5 00		lda $00,x	                lda 0,x
.8dee	e8		inx		                inx
.8def	e8		inx		                inx
.8df0					emit_a:
.8df0	6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8df3					z_emit:
.8df3					xt_empty_buffers:
.8df3	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8df5	a9 00		lda #$00	                lda #0
.8df7	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8df9					z_empty_buffers:
.8df9	60		rts		                rts
.8dfa					xt_endcase:
.8dfa	a0 8d		ldy #$8d	                ldy #>xt_drop
.8dfc	a9 28		lda #$28	                lda #<xt_drop
.8dfe	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.8e01					_endcase_loop:
.8e01	b5 00		lda $00,x	                lda 0,x
.8e03	15 01		ora $01,x	                ora 1,x
.8e05	f0 05		beq $8e0c	                beq _done
.8e07	20 a7 a1	jsr $a1a7	                jsr xt_then
.8e0a	80 f5		bra $8e01	                bra _endcase_loop
.8e0c					_done:
.8e0c	e8		inx		                inx
.8e0d	e8		inx		                inx
.8e0e	60		rts		z_endcase:      rts
.8e0f					xt_environment_q:
.8e0f	20 14 d8	jsr $d814	                jsr underflow_1
.8e12	a0 00		ldy #$00	                ldy #00                 ; counter for table
.8e14	5a		phy		                phy
.8e15					_table_loop:
.8e15	20 9d a3	jsr $a39d	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e18	ca		dex		                dex
.8e19	ca		dex		                dex                     ; ( addr u addr u ? )
.8e1a	b9 8c 8e	lda $8e8c,y	                lda env_table_single,y
.8e1d	95 00		sta $00,x	                sta 0,x
.8e1f	c8		iny		                iny
.8e20	b9 8c 8e	lda $8e8c,y	                lda env_table_single,y
.8e23	95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e25	c8		iny		                iny
.8e26	15 00		ora $00,x	                ora 0,x
.8e28	f0 4d		beq $8e77	                beq _table_done
.8e2a	5a		phy		                phy                     ; save Y, which is used by COUNT
.8e2b	20 49 89	jsr $8949	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e2e	20 82 87	jsr $8782	                jsr xt_compare          ; ( addr u f )
.8e31	7a		ply		                ply
.8e32	b5 00		lda $00,x	                lda 0,x
.8e34	15 01		ora $01,x	                ora 1,x
.8e36	f0 04		beq $8e3c	                beq _got_result
.8e38	e8		inx		                inx                     ; DROP, now ( addr u )
.8e39	e8		inx		                inx
.8e3a	80 d9		bra $8e15	                bra _table_loop
.8e3c					_got_result:
.8e3c	e8		inx		                inx                     ; drop flag, now ( addr u )
.8e3d	e8		inx		                inx
.8e3e	88		dey		                dey                     ; go back to index we had
.8e3f	88		dey		                dey
.8e40	68		pla		                pla
.8e41	d0 0d		bne $8e50	                bne _double_result
.8e43	b9 aa 8e	lda $8eaa,y	                lda env_results_single,y
.8e46	95 02		sta $02,x	                sta 2,x
.8e48	c8		iny		                iny
.8e49	b9 aa 8e	lda $8eaa,y	                lda env_results_single,y
.8e4c	95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e4e	80 1f		bra $8e6f	                bra _set_flag
.8e50					_double_result:
.8e50	ca		dex		                dex                     ; ( addr u ? )
.8e51	ca		dex		                dex
.8e52	98		tya		                tya
.8e53	38		sec		                sec
.8e54	e9 18		sbc #$18	                sbc #24
.8e56	0a		asl a		                asl
.8e57	a8		tay		                tay
.8e58	b9 c0 8e	lda $8ec0,y	                lda env_results_double,y
.8e5b	95 02		sta $02,x	                sta 2,x
.8e5d	c8		iny		                iny
.8e5e	b9 c0 8e	lda $8ec0,y	                lda env_results_double,y
.8e61	95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e63	c8		iny		                iny
.8e64	b9 c0 8e	lda $8ec0,y	                lda env_results_double,y
.8e67	95 04		sta $04,x	                sta 4,x
.8e69	c8		iny		                iny
.8e6a	b9 c0 8e	lda $8ec0,y	                lda env_results_double,y
.8e6d	95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e6f					_set_flag:
.8e6f	a9 ff		lda #$ff	                lda #$ff
.8e71	95 00		sta $00,x	                sta 0,x
.8e73	95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e75	80 14		bra $8e8b	                bra _done
.8e77					_table_done:
.8e77	68		pla		                pla
.8e78	d0 09		bne $8e83	                bne _no_match
.8e7a	1a		inc a		                ina
.8e7b	48		pha		                pha
.8e7c	8a		txa		                txa
.8e7d	18		clc		                clc
.8e7e	69 06		adc #$06	                adc #6                  ; skip six bytes
.8e80	aa		tax		                tax                     ; ( addr u )
.8e81	80 92		bra $8e15	                bra _table_loop
.8e83					_no_match:
.8e83	8a		txa		                txa
.8e84	18		clc		                clc
.8e85	69 0a		adc #$0a	                adc #10
.8e87	aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e88	20 73 8f	jsr $8f73	                jsr xt_false
.8e8b					_done:
.8e8b					z_environment_q:
.8e8b	60		rts		                rts
.8e8c					env_table_single:
>8e8c	37 d6 47 d6 4d d6 52 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e94	64 d6
>8e96	6c d6 75 d6 7b d6 81 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e9e	94 d6 a0 d6 00 00		        .word envs_sc, envs_wl, 0000
.8ea4					env_table_double:
>8ea4	aa d6 b0 d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8eaa					env_results_single:
>8eaa	ff 7f				        .word $7FFF     ; /COUNTED-STRING
>8eac	ff 00				        .word $00FF     ; /HOLD
>8eae	54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8eb0	08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8eb2	00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8eb4	ff 00				        .word $00FF     ; MAX-CHAR
>8eb6	ff 7f				        .word $7FFF     ; MAX-N
>8eb8	ff ff				        .word $FFFF     ; MAX-U
>8eba	80 00				        .word $0080     ; RETURN-STACK-CELLS
>8ebc	20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8ebe	09 00				        .word $0009     ; WORDLISTS
.8ec0					env_results_double:
>8ec0	ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8ec4	ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8ec8					xt_equal:
.8ec8	20 19 d8	jsr $d819	                jsr underflow_2
.8ecb	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8ecd	d5 02		cmp $02,x	                cmp 2,x
.8ecf	d0 0a		bne $8edb	                bne _false
.8ed1	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8ed3	d5 03		cmp $03,x	                cmp 3,x
.8ed5	d0 04		bne $8edb	                bne _false
.8ed7	a9 ff		lda #$ff	                lda #$ff
.8ed9	80 02		bra $8edd	                bra _done
.8edb	a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8edd	95 02		sta $02,x	_done:          sta 2,x
.8edf	95 03		sta $03,x	                sta 3,x
.8ee1	e8		inx		                inx
.8ee2	e8		inx		                inx
.8ee3	60		rts		z_equal:        rts
.8ee4					xt_blank:
.8ee4	ca		dex		                dex
.8ee5	ca		dex		                dex
.8ee6	a9 20		lda #$20	                lda #AscSP
.8ee8	95 00		sta $00,x	                sta 0,x
.8eea	74 01		stz $01,x	                stz 1,x
.8eec	80 06		bra $8ef4	                bra xt_fill     ; skip over code for ERASE
.8eee					xt_erase:
.8eee	ca		dex		                dex
.8eef	ca		dex		                dex
.8ef0	74 00		stz $00,x	                stz 0,x
.8ef2	74 01		stz $01,x	                stz 1,x
.8ef4					xt_fill:
.8ef4	20 1e d8	jsr $d81e	                jsr underflow_3
.8ef7	b5 04		lda $04,x	                lda 4,x         ; LSB
.8ef9	85 24		sta $24		                sta tmp1
.8efb	b5 05		lda $05,x	                lda 5,x
.8efd	85 25		sta $25		                sta tmp1+1
.8eff	b5 02		lda $02,x	                lda 2,x
.8f01	85 26		sta $26		                sta tmp2
.8f03	b5 03		lda $03,x	                lda 3,x
.8f05	85 27		sta $27		                sta tmp2+1
.8f07	b5 00		lda $00,x	                lda 0,x
.8f09	a8		tay		                tay
.8f0a					_loop:
.8f0a	a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8f0c	c5 25		cmp $25		                cmp tmp1+1
.8f0e	90 21		bcc $8f31	                bcc _done               ; RAM_END < TMP1, so leave
.8f10	d0 06		bne $8f18	                bne _check_counter      ; RAM_END is not smaller and not equal
.8f12	a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8f14	c5 24		cmp $24		                cmp tmp1
.8f16	90 19		bcc $8f31	                bcc _done               ; RAM_END < TMP1, so leave
.8f18					_check_counter:
.8f18	a5 26		lda $26		                lda tmp2
.8f1a	05 27		ora $27		                ora tmp2+1
.8f1c	f0 13		beq $8f31	                beq _done
.8f1e	98		tya		                tya
.8f1f	92 24		sta ($24)	                sta (tmp1)
.8f21	a5 26		lda $26		                lda tmp2
.8f23	d0 02		bne $8f27	                bne +
.8f25	c6 27		dec $27		                dec tmp2+1
.8f27	c6 26		dec $26		+               dec tmp2
.8f29	e6 24		inc $24		                inc tmp1
.8f2b	d0 dd		bne $8f0a	                bne _loop
.8f2d	e6 25		inc $25		                inc tmp1+1
.8f2f	80 d9		bra $8f0a	                bra _loop
.8f31					_done:
.8f31	8a		txa		                txa
.8f32	18		clc		                clc
.8f33	69 06		adc #$06	                adc #6
.8f35	aa		tax		                tax
.8f36					z_blank:
.8f36					z_erase:
.8f36	60		rts		z_fill:         rts
.8f37					xt_execute:
.8f37	20 14 d8	jsr $d814	                jsr underflow_1
.8f3a	20 3e 8f	jsr $8f3e	                jsr doexecute   ; do not combine to JMP (native coding)
.8f3d	60		rts		z_execute:      rts
.8f3e					doexecute:
.8f3e	b5 00		lda $00,x	                lda 0,x
.8f40	85 0e		sta $0e		                sta ip
.8f42	b5 01		lda $01,x	                lda 1,x
.8f44	85 0f		sta $0f		                sta ip+1
.8f46	e8		inx		                inx
.8f47	e8		inx		                inx
.8f48	6c 0e 00	jmp ($000e)	                jmp (ip)
.8f4b					xt_execute_parsing:
.8f4b	20 1e d8	jsr $d81e	                jsr underflow_3
.8f4e	20 5c 92	jsr $925c	                jsr xt_input_to_r       ; save normal input for later
.8f51	20 68 96	jsr $9668	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f54	b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f56	85 0a		sta $0a		                sta ciblen
.8f58	b5 01		lda $01,x	                lda 1,x
.8f5a	85 0b		sta $0b		                sta ciblen+1
.8f5c	b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f5e	85 08		sta $08		                sta cib
.8f60	b5 03		lda $03,x	                lda 3,x
.8f62	85 09		sta $09		                sta cib+1
.8f64	64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f66	64 0d		stz $0d		                stz toin+1
.8f68	20 95 a3	jsr $a395	                jsr xt_two_drop         ; 2DROP ( xt )
.8f6b	20 37 8f	jsr $8f37	                jsr xt_execute
.8f6e	20 8e 9a	jsr $9a8e	                jsr xt_r_to_input
.8f71					z_execute_parsing:
.8f71	60		rts		                rts
.8f72					xt_exit:
.8f72	60		rts		                rts             ; keep before z_exit
.8f73					z_exit:
.8f73					xt_false:
.8f73	ca		dex		                dex
.8f74	ca		dex		                dex
.8f75	74 00		stz $00,x	                stz 0,x
.8f77	74 01		stz $01,x	                stz 1,x
.8f79	60		rts		z_false:        rts
.8f7a					xt_fetch:
.8f7a	20 14 d8	jsr $d814	                jsr underflow_1
.8f7d	a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f7f	a8		tay		                tay
.8f80	f6 00		inc $00,x	                inc 0,x
.8f82	d0 02		bne $8f86	                bne +
.8f84	f6 01		inc $01,x	                inc 1,x
.8f86					+
.8f86	a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f88	95 01		sta $01,x	                sta 1,x
.8f8a	94 00		sty $00,x	                sty 0,x
.8f8c	60		rts		z_fetch:        rts
.8f8d					xt_find:
.8f8d	20 14 d8	jsr $d814	                jsr underflow_1
.8f90	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f92	48		pha		                pha
.8f93	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f95	48		pha		                pha
.8f96	20 49 89	jsr $8949	                jsr xt_count            ; ( caddr -- addr u )
.8f99	20 d5 8f	jsr $8fd5	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f9c	b5 00		lda $00,x	                lda 0,x
.8f9e	15 01		ora $01,x	                ora 1,x
.8fa0	d0 0b		bne $8fad	                bne _found_word
.8fa2	20 73 8f	jsr $8f73	                jsr xt_false            ; ( 0 0 )
.8fa5	68		pla		                pla                     ; LSB of address
.8fa6	95 02		sta $02,x	                sta 2,x
.8fa8	68		pla		                pla
.8fa9	95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8fab	80 27		bra $8fd4	                bra _done               ; ( addr 0 )
.8fad					_found_word:
.8fad	68		pla		                pla
.8fae	68		pla		                pla
.8faf	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( nt nt )
.8fb2	20 db 95	jsr $95db	                jsr xt_name_to_int      ; ( nt xt )
.8fb5	20 93 a1	jsr $a193	                jsr xt_swap             ; ( xt nt )
.8fb8	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fba	f6 00		inc $00,x	                inc 0,x
.8fbc	d0 02		bne $8fc0	                bne +
.8fbe	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fc0					+
.8fc0	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fc2	29 04		and #$04	                and #IM
.8fc4	d0 08		bne $8fce	                bne _immediate          ; bit set, we're immediate
.8fc6	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8fc8	95 00		sta $00,x	                sta 0,x
.8fca	95 01		sta $01,x	                sta 1,x
.8fcc	80 06		bra $8fd4	                bra _done
.8fce					_immediate:
.8fce	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8fd0	95 00		sta $00,x	                sta 0,x
.8fd2	74 01		stz $01,x	                stz 1,x
.8fd4					_done:
.8fd4	60		rts		z_find:         rts
.8fd5					xt_find_name:
.8fd5	20 19 d8	jsr $d819	                jsr underflow_2
.8fd8	b5 00		lda $00,x	                lda 0,x
.8fda	15 01		ora $01,x	                ora 1,x
.8fdc	d0 03		bne $8fe1	                bne _nonempty
.8fde	4c 7a 90	jmp $907a	                jmp _fail_done
.8fe1					_nonempty:
.8fe1	64 28		stz $28		                stz tmp3                ; Start at the beginning
.8fe3					_wordlist_loop:
.8fe3	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8fe5	a5 28		lda $28		                lda tmp3
.8fe7	d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8fe9	d0 03		bne $8fee	                bne _have_string
.8feb	4c 7a 90	jmp $907a	                jmp _fail_done
.8fee					_have_string:
.8fee	18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8fef	69 1f		adc #$1f	                adc #search_order_offset
.8ff1	a8		tay		                tay
.8ff2	b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.8ff4	0a		asl a		                asl                     ; Turn offset into cells offset.
.8ff5	18		clc		                clc
.8ff6	69 06		adc #$06	                adc #wordlists_offset
.8ff8	a8		tay		                tay
.8ff9	b1 1e		lda ($1e),y	                lda (up),y
.8ffb	85 24		sta $24		                sta tmp1
.8ffd	c8		iny		                iny
.8ffe	b1 1e		lda ($1e),y	                lda (up),y
.9000	85 25		sta $25		                sta tmp1+1
.9002	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9004	85 26		sta $26		                sta tmp2
.9006	b5 03		lda $03,x	                lda 3,x
.9008	85 27		sta $27		                sta tmp2+1
.900a					_loop:
.900a	b2 24		lda ($24)	                lda (tmp1)
.900c	d5 00		cmp $00,x	                cmp 0,x
.900e	d0 54		bne $9064	                bne _next_entry
.9010					_compare_string:
.9010	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9012	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9014	b0 07		bcs $901d	                bcs _compare_first
.9016	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9018	90 03		bcc $901d	                bcc _compare_first
.901a	18		clc		                clc
.901b	69 20		adc #$20	                adc #$20
.901d					_compare_first:
.901d	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.901f	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9021	d0 41		bne $9064	                bne _next_entry
.9023	b5 00		lda $00,x	                lda 0,x
.9025	3a		dec a		                dea
.9026	f0 2c		beq $9054	                beq _success
.9028	a5 24		lda $24		                lda tmp1
.902a	48		pha		                pha             ; Preserve tmp1 on the return stack.
.902b	18		clc		                clc
.902c	69 08		adc #$08	                adc #8
.902e	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9030	a5 25		lda $25		                lda tmp1+1
.9032	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9033	69 00		adc #$00	                adc #0          ; we only need the carry
.9035	85 25		sta $25		                sta tmp1+1
.9037	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9039	88		dey		                dey
.903a					_string_loop:
.903a	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.903c	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.903e	b0 07		bcs $9047	                bcs _check_char
.9040	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9042	90 03		bcc $9047	                bcc _check_char
.9044	18		clc		                clc
.9045	69 20		adc #$20	                adc #$20
.9047					_check_char:
.9047	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9049	d0 13		bne $905e	                bne _next_entry_tmp1
.904b	88		dey		                dey
.904c	d0 ec		bne $903a	                bne _string_loop
.904e					_success_tmp1:
.904e	68		pla		                pla             ; Restore tmp1 from the return stack.
.904f	85 25		sta $25		                sta tmp1+1
.9051	68		pla		                pla
.9052	85 24		sta $24		                sta tmp1
.9054					_success:
.9054	a5 24		lda $24		                lda tmp1
.9056	95 02		sta $02,x	                sta 2,x
.9058	a5 25		lda $25		                lda tmp1+1
.905a	95 03		sta $03,x	                sta 3,x
.905c	80 20		bra $907e	                bra _done
.905e					_next_entry_tmp1:
.905e	68		pla		                pla             ; Restore tmp1 from the return stack.
.905f	85 25		sta $25		                sta tmp1+1
.9061	68		pla		                pla
.9062	85 24		sta $24		                sta tmp1
.9064					_next_entry:
.9064	a0 02		ldy #$02	                ldy #2
.9066	b1 24		lda ($24),y	                lda (tmp1),y
.9068	48		pha		                pha
.9069	c8		iny		                iny
.906a	b1 24		lda ($24),y	                lda (tmp1),y
.906c	85 25		sta $25		                sta tmp1+1
.906e	68		pla		                pla
.906f	85 24		sta $24		                sta tmp1
.9071	05 25		ora $25		                ora tmp1+1
.9073	d0 95		bne $900a	                bne _loop
.9075	e6 28		inc $28		                inc tmp3
.9077	4c e3 8f	jmp $8fe3	                jmp _wordlist_loop
.907a					_fail_done:
.907a	74 02		stz $02,x	                stz 2,x         ; failure flag
.907c	74 03		stz $03,x	                stz 3,x
.907e					_done:
.907e	e8		inx		                inx
.907f	e8		inx		                inx
.9080	60		rts		z_find_name:    rts
.9081					xt_flush:
.9081	20 a9 9e	jsr $9ea9	                jsr xt_save_buffers
.9084	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9086	a9 00		lda #$00	                lda #0
.9088	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.908a					z_flush:
.908a	60		rts		                rts
.908b					xt_fm_slash_mod:
.908b	20 1e d8	jsr $d81e	                jsr underflow_3
.908e	64 26		stz $26		                stz tmp2        ; default: n is positive
.9090	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9092	10 0e		bpl $90a2	                bpl _check_d
.9094	e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.9096	20 1d 96	jsr $961d	                jsr xt_negate   ; NEGATE
.9099	20 55 a3	jsr $a355	                jsr xt_to_r     ; >R
.909c	20 3b 8b	jsr $8b3b	                jsr xt_dnegate  ; DNEGATE
.909f	20 7d 9a	jsr $9a7d	                jsr xt_r_from   ; R>
.90a2					_check_d:
.90a2	b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.90a4	10 0d		bpl $90b3	                bpl _multiply
.90a6	18		clc		                clc
.90a7	b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.90a9	75 02		adc $02,x	                adc 2,x         ; LSB of dh
.90ab	95 02		sta $02,x	                sta 2,x
.90ad	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90af	75 03		adc $03,x	                adc 3,x         ; MSB of dh
.90b1	95 03		sta $03,x	                sta 3,x
.90b3					_multiply:
.90b3	20 9f a5	jsr $a59f	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90b6	a5 26		lda $26		                lda tmp2
.90b8	f0 07		beq $90c1	                beq _done
.90ba	e8		inx		                inx             ; pretend that we SWAP
.90bb	e8		inx		                inx
.90bc	20 1d 96	jsr $961d	                jsr xt_negate
.90bf	ca		dex		                dex
.90c0	ca		dex		                dex
.90c1					_done:
.90c1	60		rts		z_fm_slash_mod: rts
.90c2					xt_forth:
.90c2	a0 1f		ldy #$1f	                ldy #search_order_offset
.90c4	a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90c6	91 1e		sta ($1e),y	                sta (up),y
.90c8					z_forth:
.90c8	60		rts		                rts
.90c9					load_evaluate:
.90c9	a9 ff		lda #$ff	                lda #$FF
.90cb	85 24		sta $24		                sta tmp1
.90cd	80 11		bra $90e0	                bra load_evaluate_start
.90cf					xt_evaluate:
.90cf	20 19 d8	jsr $d819	                jsr underflow_2
.90d2	64 24		stz $24		                stz tmp1
.90d4	b5 00		lda $00,x	                lda 0,x
.90d6	15 01		ora $01,x	                ora 1,x
.90d8	d0 06		bne $90e0	                bne evaluate_got_work
.90da	e8		inx		                inx
.90db	e8		inx		                inx
.90dc	e8		inx		                inx
.90dd	e8		inx		                inx
.90de	80 42		bra $9122	                bra evaluate_done
.90e0					load_evaluate_start:
.90e0					evaluate_got_work:
.90e0	a0 01		ldy #$01	                ldy #blk_offset+1
.90e2	b1 1e		lda ($1e),y	                lda (up),y
.90e4	48		pha		                pha
.90e5	88		dey		                dey
.90e6	b1 1e		lda ($1e),y	                lda (up),y
.90e8	48		pha		                pha
.90e9	a5 24		lda $24		                lda tmp1
.90eb	d0 05		bne $90f2	                bne _nozero
.90ed	91 1e		sta ($1e),y	                sta (up),y
.90ef	c8		iny		                iny
.90f0	91 1e		sta ($1e),y	                sta (up),y
.90f2					_nozero:
.90f2	20 5c 92	jsr $925c	                jsr xt_input_to_r
.90f5	a9 ff		lda #$ff	                lda #$ff
.90f7	85 06		sta $06		                sta insrc
.90f9	85 07		sta $07		                sta insrc+1
.90fb	64 0c		stz $0c		                stz toin
.90fd	64 0d		stz $0d		                stz toin+1
.90ff	b5 00		lda $00,x	                lda 0,x
.9101	85 0a		sta $0a		                sta ciblen
.9103	b5 01		lda $01,x	                lda 1,x
.9105	85 0b		sta $0b		                sta ciblen+1
.9107	b5 02		lda $02,x	                lda 2,x
.9109	85 08		sta $08		                sta cib
.910b	b5 03		lda $03,x	                lda 3,x
.910d	85 09		sta $09		                sta cib+1
.910f	e8		inx		                inx             ; A clean stack is a clean mind
.9110	e8		inx		                inx
.9111	e8		inx		                inx
.9112	e8		inx		                inx
.9113	20 7c d7	jsr $d77c	                jsr interpret   ; ( -- )
.9116	20 8e 9a	jsr $9a8e	                jsr xt_r_to_input
.9119	a0 00		ldy #$00	                ldy #blk_offset
.911b	68		pla		                pla
.911c	91 1e		sta ($1e),y	                sta (up),y
.911e	c8		iny		                iny
.911f	68		pla		                pla
.9120	91 1e		sta ($1e),y	                sta (up),y
.9122					evaluate_done:
.9122	60		rts		z_evaluate:     rts
.9123					xt_get_current:
.9123	ca		dex		                dex
.9124	ca		dex		                dex
.9125	a0 04		ldy #$04	                ldy #current_offset
.9127	b1 1e		lda ($1e),y	                lda (up),y
.9129	95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.912b	74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.912d	60		rts		z_get_current:  rts
.912e					xt_get_order:
.912e	a0 1e		ldy #$1e	                ldy #num_order_offset
.9130	b1 1e		lda ($1e),y	                lda (up),y
.9132	85 24		sta $24		                sta tmp1
.9134	f0 16		beq $914c	                beq _done       ; If zero, there are no wordlists.
.9136					_loop:
.9136	c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.9138	a9 1f		lda #$1f	                lda #search_order_offset
.913a	18		clc		                clc
.913b	65 24		adc $24		                adc tmp1
.913d	a8		tay		                tay
.913e	ca		dex		                dex
.913f	ca		dex		                dex
.9140	b1 1e		lda ($1e),y	                lda (up),y
.9142	95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.9144	74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.9146	a9 00		lda #$00	                lda #0
.9148	c5 24		cmp $24		                cmp tmp1
.914a	d0 ea		bne $9136	                bne _loop
.914c					_done:
.914c	ca		dex		                dex
.914d	ca		dex		                dex
.914e	a0 1e		ldy #$1e	                ldy #num_order_offset
.9150	b1 1e		lda ($1e),y	                lda (up),y
.9152	95 00		sta $00,x	                sta 0,x
.9154	74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.9156	60		rts		z_get_order:    rts
.9157					xt_greater_than:
.9157	20 19 d8	jsr $d819	                jsr underflow_2
.915a	a0 00		ldy #$00	                ldy #0          ; default false
.915c	20 3b d7	jsr $d73b	                jsr compare_16bit
.915f	f0 03		beq $9164	                beq _false
.9161	10 01		bpl $9164	                bpl _false
.9163	88		dey		                dey
.9164					_false:
.9164	98		tya		                tya
.9165	e8		inx		                inx
.9166	e8		inx		                inx
.9167	95 00		sta $00,x	                sta 0,x
.9169	95 01		sta $01,x	                sta 1,x
.916b	60		rts		z_greater_than: rts
.916c					xt_here:
.916c					xt_asm_arrow:
.916c	ca		dex		                dex
.916d	ca		dex		                dex
.916e	a5 00		lda $00		                lda cp
.9170	95 00		sta $00,x	                sta 0,x
.9172	a5 01		lda $01		                lda cp+1
.9174	95 01		sta $01,x	                sta 1,x
.9176					z_asm_arrow:
.9176	60		rts		z_here:         rts
.9177					xt_hex:
.9177	a9 10		lda #$10	                lda #16
.9179	85 18		sta $18		                sta base
.917b	64 19		stz $19		                stz base+1              ; paranoid
.917d	60		rts		z_hex:          rts
.917e					xt_hexstore:
.917e	20 1e d8	jsr $d81e	                jsr underflow_3
.9181	20 a9 8d	jsr $8da9	                jsr xt_dup              ; Save copy of original address
.9184	20 87 a4	jsr $a487	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9187					_loop:
.9187	b5 00		lda $00,x	                lda 0,x
.9189	15 01		ora $01,x	                ora 1,x
.918b	f0 36		beq $91c3	                beq _done
.918d	20 46 86	jsr $8646	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9190	20 87 a4	jsr $a487	                jsr xt_two_to_r
.9193	20 8d a7	jsr $a78d	                jsr xt_zero
.9196	20 8d a7	jsr $a78d	                jsr xt_zero
.9199	20 0d a4	jsr $a40d	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.919c	20 a2 a2	jsr $a2a2	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.919f	b5 00		lda $00,x	                lda 0,x
.91a1	15 01		ora $01,x	                ora 1,x
.91a3	d0 17		bne $91bc	                bne _have_chars_left
.91a5	20 95 a3	jsr $a395	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.91a8	20 7a 8a	jsr $8a7a	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.91ab	20 68 9a	jsr $9a68	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.91ae	20 0f 86	jsr $860f	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.91b1	20 7d 9a	jsr $9a7d	                jsr xt_r_from           ; R>
.91b4	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+
.91b7	20 55 a3	jsr $a355	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91ba	80 cb		bra $9187	                bra _loop
.91bc					_have_chars_left:
.91bc	8a		txa		                txa
.91bd	18		clc		                clc
.91be	69 08		adc #$08	                adc #8
.91c0	aa		tax		                tax
.91c1	80 c4		bra $9187	                bra _loop
.91c3					_done:
.91c3	e8		inx		                inx
.91c4	e8		inx		                inx
.91c5	e8		inx		                inx
.91c6	e8		inx		                inx                     ; 2DROP
.91c7	20 0d a4	jsr $a40d	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91ca	20 93 a1	jsr $a193	                jsr xt_swap
.91cd	20 4a 95	jsr $954a	                jsr xt_minus            ; ( n )
.91d0	60		rts		z_hexstore:     rts
.91d1					xt_hold:
.91d1	20 14 d8	jsr $d814	                jsr underflow_1
.91d4	a5 34		lda $34		                lda tohold
.91d6	d0 02		bne $91da	                bne +
.91d8	c6 35		dec $35		                dec tohold+1
.91da					+
.91da	c6 34		dec $34		                dec tohold
.91dc	b5 00		lda $00,x	                lda 0,x
.91de	92 34		sta ($34)	                sta (tohold)
.91e0	e8		inx		                inx
.91e1	e8		inx		                inx
.91e2	60		rts		z_hold:         rts
.91e3					xt_i:
.91e3	ca		dex		                dex
.91e4	ca		dex		                dex
.91e5	86 2a		stx $2a		                stx tmpdsp
.91e7	ba		tsx		                tsx
.91e8	38		sec		                sec
.91e9	bd 01 01	lda $0101,x	                lda $0101,x     ; LSB
.91ec	fd 03 01	sbc $0103,x	                sbc $0103,x
.91ef	a8		tay		                tay
.91f0	bd 02 01	lda $0102,x	                lda $0102,x     ; MSB
.91f3	fd 04 01	sbc $0104,x	                sbc $0104,x
.91f6	a6 2a		ldx $2a		                ldx tmpdsp
.91f8	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.91fa	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.91fc	60		rts		z_i:            rts
.91fd					xt_if:
.91fd	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.91ff	a9 0e		lda #$0e	                lda #<zero_branch_runtime
.9201	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.9204	20 6c 91	jsr $916c	                jsr xt_here
.9207	20 8d a7	jsr $a78d	                jsr xt_zero
.920a	20 68 87	jsr $8768	                jsr xt_comma
.920d	60		rts		z_if:           rts
.920e					zero_branch_runtime:
.920e	68		pla		                pla
.920f	85 22		sta $22		                sta tmpbranch
.9211	68		pla		                pla
.9212	85 23		sta $23		                sta tmpbranch+1
.9214	b5 00		lda $00,x	                lda 0,x
.9216	15 01		ora $01,x	                ora 1,x
.9218	f0 0f		beq $9229	                beq _zero
.921a	a5 22		lda $22		                lda tmpbranch   ; LSB
.921c	18		clc		                clc
.921d	69 02		adc #$02	                adc #2
.921f	85 24		sta $24		                sta tmp1
.9221	a5 23		lda $23		                lda tmpbranch+1 ; MSB
.9223	69 00		adc #$00	                adc #0          ; For carry
.9225	85 25		sta $25		                sta tmp1+1
.9227	80 13		bra $923c	                bra _done
.9229					_zero:
.9229	a0 01		ldy #$01	                ldy #1
.922b	b1 22		lda ($22),y	                lda (tmpbranch),y
.922d	85 24		sta $24		                sta tmp1
.922f	c8		iny		                iny
.9230	b1 22		lda ($22),y	                lda (tmpbranch),y
.9232	85 25		sta $25		                sta tmp1+1
.9234	a5 24		lda $24		                lda tmp1
.9236	d0 02		bne $923a	                bne +
.9238	c6 25		dec $25		                dec tmp1+1
.923a					+
.923a	c6 24		dec $24		                dec tmp1
.923c					_done:
.923c	a5 25		lda $25		                lda tmp1+1
.923e	48		pha		                pha             ; MSB first
.923f	a5 24		lda $24		                lda tmp1
.9241	48		pha		                pha
.9242	e8		inx		                inx
.9243	e8		inx		                inx
.9244	60		rts		                rts
.9245					xt_immediate:
.9245	20 56 d7	jsr $d756	                jsr current_to_dp
.9248	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.924a	b1 02		lda ($02),y	                lda (dp),y
.924c	09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.924e	91 02		sta ($02),y	                sta (dp),y
.9250	60		rts		z_immediate:    rts
.9251					xt_input:
.9251	ca		dex		                dex
.9252	ca		dex		                dex
.9253	a9 12		lda #$12	                lda #<input
.9255	95 00		sta $00,x	                sta 0,x
.9257	a9 00		lda #$00	                lda #>input
.9259	95 01		sta $01,x	                sta 1,x
.925b	60		rts		z_input:        rts
.925c					xt_input_to_r:
.925c	68		pla		                pla
.925d	85 24		sta $24		                sta tmp1
.925f	68		pla		                pla
.9260	85 25		sta $25		                sta tmp1+1
.9262	a0 07		ldy #$07	                ldy #7
.9264					_loop:
.9264	b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.9267	48		pha		                pha
.9268	88		dey		                dey
.9269	10 f9		bpl $9264	                bpl _loop
.926b	a5 25		lda $25		                lda tmp1+1
.926d	48		pha		                pha
.926e	a5 24		lda $24		                lda tmp1
.9270	48		pha		                pha
.9271	60		rts		z_input_to_r: 	rts
.9272					xt_int_to_name:
.9272	20 14 d8	jsr $d814	                jsr underflow_1
.9275	ca		dex		                dex
.9276	ca		dex		                dex
.9277	74 00		stz $00,x	                stz 0,x
.9279	74 01		stz $01,x	                stz 1,x
.927b					_wordlist_loop:
.927b	b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.927d	0a		asl a		                asl                     ; Turn offset into cells offset.
.927e	18		clc		                clc
.927f	69 06		adc #$06	                adc #wordlists_offset
.9281	a8		tay		                tay
.9282	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.9284	85 26		sta $26		                sta tmp2                ; into tmp2
.9286	c8		iny		                iny
.9287	b1 1e		lda ($1e),y	                lda (up),y
.9289	85 27		sta $27		                sta tmp2+1
.928b	a5 26		lda $26		                lda tmp2
.928d	05 27		ora $27		                ora tmp2+1
.928f	f0 38		beq $92c9	                beq _next_wordlist
.9291	b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9293	85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.9295	b5 03		lda $03,x	                lda 3,x
.9297	85 29		sta $29		                sta tmp3+1
.9299					_loop:
.9299	a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.929b	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.929d	c5 28		cmp $28		                cmp tmp3
.929f	d0 07		bne $92a8	                bne _no_match
.92a1	c8		iny		                iny
.92a2	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.92a4	c5 29		cmp $29		                cmp tmp3+1
.92a6	f0 32		beq $92da	                beq _match
.92a8					_no_match:
.92a8	18		clc		                clc
.92a9	a5 26		lda $26		                lda tmp2
.92ab	69 02		adc #$02	                adc #2
.92ad	85 26		sta $26		                sta tmp2
.92af	a5 27		lda $27		                lda tmp2+1
.92b1	69 00		adc #$00	                adc #0          ; only care about carry
.92b3	85 27		sta $27		                sta tmp2+1
.92b5	a0 00		ldy #$00	                ldy #0
.92b7	b1 26		lda ($26),y	                lda (tmp2),y
.92b9	48		pha		                pha
.92ba	c8		iny		                iny
.92bb	11 26		ora ($26),y	                ora (tmp2),y
.92bd	f0 09		beq $92c8	                beq _zero
.92bf	b1 26		lda ($26),y	                lda (tmp2),y
.92c1	85 27		sta $27		                sta tmp2+1
.92c3	68		pla		                pla
.92c4	85 26		sta $26		                sta tmp2
.92c6	80 d1		bra $9299	                bra _loop
.92c8					_zero:
.92c8	68		pla		                pla             ; Leftover from above loop
.92c9					_next_wordlist:
.92c9	b5 00		lda $00,x	                lda 0,x
.92cb	1a		inc a		                ina
.92cc	95 00		sta $00,x	                sta 0,x
.92ce	c9 0c		cmp #$0c	                cmp #max_wordlists
.92d0	d0 a9		bne $927b	                bne _wordlist_loop
.92d2	e8		inx		                inx
.92d3	e8		inx		                inx
.92d4	74 00		stz $00,x	                stz 0,x
.92d6	74 01		stz $01,x	                stz 1,x
.92d8	80 0a		bra $92e4	                bra z_int_to_name
.92da					_match:
.92da	e8		inx		                inx
.92db	e8		inx		                inx
.92dc	a5 26		lda $26		                lda tmp2
.92de	95 00		sta $00,x	                sta 0,x
.92e0	a5 27		lda $27		                lda tmp2+1
.92e2	95 01		sta $01,x	                sta 1,x
.92e4	60		rts		z_int_to_name:  rts
.92e5					xt_invert:
.92e5	20 14 d8	jsr $d814	                jsr underflow_1
.92e8	a9 ff		lda #$ff	                lda #$FF
.92ea	55 00		eor $00,x	                eor 0,x         ; LSB
.92ec	95 00		sta $00,x	                sta 0,x
.92ee	a9 ff		lda #$ff	                lda #$FF
.92f0	55 01		eor $01,x	                eor 1,x         ; MSB
.92f2	95 01		sta $01,x	                sta 1,x
.92f4	60		rts		z_invert:       rts
.92f5					xt_is:
.92f5	a5 16		lda $16		                lda state
.92f7	05 17		ora $17		                ora state+1
.92f9	f0 0c		beq $9307	                beq _interpreting
.92fb					_compiling:
.92fb	20 98 85	jsr $8598	                jsr xt_bracket_tick
.92fe	a0 8a		ldy #$8a	                ldy #>xt_defer_store
.9300	a9 e0		lda #$e0	                lda #<xt_defer_store
.9302	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.9305	80 06		bra $930d	                bra _done
.9307					_interpreting:
.9307	20 f6 a1	jsr $a1f6	                jsr xt_tick
.930a	20 e0 8a	jsr $8ae0	                jsr xt_defer_store
.930d					_done:
.930d	60		rts		z_is:           rts
.930e					xt_j:
.930e	ca		dex		                dex
.930f	ca		dex		                dex
.9310	86 2a		stx $2a		                stx tmpdsp
.9312	ba		tsx		                tsx
.9313	38		sec		                sec
.9314	bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.9317	fd 09 01	sbc $0109,x	                sbc $0109,x
.931a	a8		tay		                tay
.931b	bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.931e	fd 0a 01	sbc $010a,x	                sbc $010A,x
.9321	a6 2a		ldx $2a		                ldx tmpdsp
.9323	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.9325	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.9327	60		rts		z_j:            rts
.9328					xt_key:
.9328	20 32 93	jsr $9332	                jsr key_a               ; returns char in A
.932b	ca		dex		                dex
.932c	ca		dex		                dex
.932d	95 00		sta $00,x	                sta 0,x
.932f	74 01		stz $01,x	                stz 1,x
.9331	60		rts		z_key:          rts
.9332					key_a:
.9332	6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.9335					xt_latestnt:
.9335	ca		dex		                dex
.9336	ca		dex		                dex
.9337	20 56 d7	jsr $d756	                jsr current_to_dp
.933a	a5 02		lda $02		                lda dp
.933c	95 00		sta $00,x	                sta 0,x
.933e	a5 03		lda $03		                lda dp+1
.9340	95 01		sta $01,x	                sta 1,x
.9342	60		rts		z_latestnt:     rts
.9343					xt_latestxt:
.9343	20 35 93	jsr $9335	                jsr xt_latestnt         ; ( nt )
.9346	20 db 95	jsr $95db	                jsr xt_name_to_int      ; ( xt )
.9349	60		rts		z_latestxt:     rts
.934a					xt_leave:
.934a	68		pla		                pla
.934b	68		pla		                pla
.934c	68		pla		                pla
.934d	68		pla		                pla
.934e	60		rts		                rts             ; this must be compiled, so keep before z_leave
.934f					z_leave:
.934f					xt_left_bracket:
.934f	64 16		stz $16		                stz state
.9351	64 17		stz $17		                stz state+1
.9353	60		rts		z_left_bracket: rts
.9354					xt_less_number_sign:
.9354	20 8c 98	jsr $988c	                jsr xt_pad      ; ( addr )
.9357	b5 00		lda $00,x	                lda 0,x
.9359	85 34		sta $34		                sta tohold
.935b	b5 01		lda $01,x	                lda 1,x
.935d	85 35		sta $35		                sta tohold+1
.935f	e8		inx		                inx
.9360	e8		inx		                inx
.9361					z_less_number_sign:
.9361	60		rts		                rts
.9362					xt_less_than:
.9362	20 19 d8	jsr $d819	                jsr underflow_2
.9365	a0 00		ldy #$00	                ldy #0          ; default false
.9367	20 3b d7	jsr $d73b	                jsr compare_16bit
.936a	f0 03		beq $936f	                beq _false
.936c	30 01		bmi $936f	                bmi _false
.936e	88		dey		                dey
.936f					_false:
.936f	98		tya		                tya
.9370	e8		inx		                inx
.9371	e8		inx		                inx
.9372	95 00		sta $00,x	                sta 0,x
.9374	95 01		sta $01,x	                sta 1,x
.9376	60		rts		z_less_than:    rts
.9377					xt_list:
.9377	20 14 d8	jsr $d814	                jsr underflow_1
.937a	20 c4 9e	jsr $9ec4	                jsr xt_scr
.937d	20 72 a1	jsr $a172	                jsr xt_store
.9380	20 2b a8	jsr $a82b	                jsr xt_editor_l
.9383	60		rts		z_list:         rts
.9384					xt_literal:
.9384	20 14 d8	jsr $d814	                jsr underflow_1
.9387	a0 93		ldy #$93	                ldy #>literal_runtime
.9389	a9 92		lda #$92	                lda #<literal_runtime
.938b	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.938e	20 68 87	jsr $8768	                jsr xt_comma
.9391	60		rts		z_literal:      rts
.9392					literal_runtime:
.9392	ca		dex		                dex
.9393	ca		dex		                dex
.9394	68		pla		                pla             ; LSB
.9395	85 24		sta $24		                sta tmp1
.9397	68		pla		                pla             ; MSB
.9398	85 25		sta $25		                sta tmp1+1
.939a	a0 01		ldy #$01	                ldy #1
.939c	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.939e	95 00		sta $00,x	                sta 0,x
.93a0	c8		iny		                iny
.93a1	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.93a3	95 01		sta $01,x	                sta 1,x
.93a5	98		tya		                tya
.93a6	18		clc		                clc
.93a7	65 24		adc $24		                adc tmp1
.93a9	a8		tay		                tay
.93aa	a5 25		lda $25		                lda tmp1+1
.93ac	69 00		adc #$00	                adc #0
.93ae	48		pha		                pha
.93af	5a		phy		                phy
.93b0	60		rts		                rts
.93b1					xt_load:
.93b1	20 14 d8	jsr $d814	                jsr underflow_1
.93b4	a0 01		ldy #$01	                ldy #blk_offset+1
.93b6	b1 1e		lda ($1e),y	                lda (up),y
.93b8	48		pha		                pha
.93b9	88		dey		                dey
.93ba	b1 1e		lda ($1e),y	                lda (up),y
.93bc	48		pha		                pha
.93bd	b5 00		lda $00,x	                lda 0,x
.93bf	91 1e		sta ($1e),y	                sta (up),y
.93c1	c8		iny		                iny
.93c2	b5 01		lda $01,x	                lda 1,x
.93c4	91 1e		sta ($1e),y	                sta (up),y
.93c6	20 bb 83	jsr $83bb	                jsr xt_block
.93c9	ca		dex		                dex
.93ca	ca		dex		                dex
.93cb	a9 04		lda #$04	                lda #4
.93cd	95 01		sta $01,x	                sta 1,x
.93cf	74 00		stz $00,x	                stz 0,x
.93d1	20 c9 90	jsr $90c9	                jsr load_evaluate
.93d4	a0 00		ldy #$00	                ldy #blk_offset
.93d6	68		pla		                pla
.93d7	91 1e		sta ($1e),y	                sta (up),y
.93d9	c8		iny		                iny
.93da	68		pla		                pla
.93db	91 1e		sta ($1e),y	                sta (up),y
.93dd	88		dey		                dey
.93de	11 1e		ora ($1e),y	                ora (up),y
.93e0	f0 12		beq $93f4	                beq _done
.93e2	ca		dex		                dex
.93e3	ca		dex		                dex
.93e4	a0 00		ldy #$00	                ldy #blk_offset
.93e6	b1 1e		lda ($1e),y	                lda (up),y
.93e8	95 00		sta $00,x	                sta 0,x
.93ea	c8		iny		                iny
.93eb	b1 1e		lda ($1e),y	                lda (up),y
.93ed	95 01		sta $01,x	                sta 1,x
.93ef	20 bb 83	jsr $83bb	                jsr xt_block
.93f2	e8		inx		                inx
.93f3	e8		inx		                inx
.93f4					_done:
.93f4	60		rts		z_load:         rts
.93f5					xt_loop:
.93f5	a0 97		ldy #$97	                ldy #>xt_one
.93f7	a9 f3		lda #$f3	                lda #<xt_one
.93f9	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine     ; drop through to +LOOP
.93fc					xt_plus_loop:
.93fc	a0 11		ldy #$11	                ldy #plus_loop_runtime_end-plus_loop_runtime
.93fe	5a		phy		                phy             ; save counter to adjust CP
.93ff					-
.93ff	b9 63 94	lda $9463,y	                lda plus_loop_runtime,y
.9402	91 00		sta ($00),y	                sta (cp),y
.9404	88		dey		                dey
.9405	10 f8		bpl $93ff	                bpl -
.9407	68		pla		                pla
.9408	18		clc		                clc
.9409	65 00		adc $00		                adc cp
.940b	85 00		sta $00		                sta cp
.940d	a5 01		lda $01		                lda cp+1
.940f	69 00		adc #$00	                adc #0          ; only need carry
.9411	85 01		sta $01		                sta cp+1
.9413	20 68 87	jsr $8768	                jsr xt_comma
.9416	a9 68		lda #$68	                lda #$68                ; opcode for PLA
.9418	a0 06		ldy #$06	                ldy #6
.941a					-
.941a	91 00		sta ($00),y	                sta (cp),y
.941c	88		dey		                dey
.941d	10 fb		bpl $941a	                bpl -
.941f	a9 06		lda #$06	                lda #6
.9421	18		clc		                clc
.9422	65 00		adc $00		                adc cp
.9424	85 00		sta $00		                sta cp
.9426	a5 01		lda $01		                lda cp+1
.9428	69 00		adc #$00	                adc #0                  ; only need carry
.942a	85 01		sta $01		                sta cp+1
.942c	b5 00		lda $00,x	                lda 0,x
.942e	85 24		sta $24		                sta tmp1
.9430	b5 01		lda $01,x	                lda 1,x
.9432	85 25		sta $25		                sta tmp1+1
.9434	e8		inx		                inx
.9435	e8		inx		                inx
.9436	a5 00		lda $00		                lda cp
.9438	38		sec		                sec
.9439	e9 01		sbc #$01	                sbc #1
.943b	85 26		sta $26		                sta tmp2
.943d	a5 01		lda $01		                lda cp+1
.943f	e9 00		sbc #$00	                sbc #0
.9441	85 27		sta $27		                sta tmp2+1
.9443	a0 00		ldy #$00	                ldy #0
.9445	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.9447	91 24		sta ($24),y	                sta (tmp1),y
.9449	c8		iny		                iny
.944a	a5 27		lda $27		                lda tmp2+1      ; MSB
.944c	91 24		sta ($24),y	                sta (tmp1),y
.944e	c8		iny		                iny
.944f	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9451	91 24		sta ($24),y	                sta (tmp1),y
.9453	c8		iny		                iny
.9454	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.9456	91 24		sta ($24),y	                sta (tmp1),y
.9458	c8		iny		                iny
.9459	a5 26		lda $26		                lda tmp2        ; LSB
.945b	91 24		sta ($24),y	                sta (tmp1),y
.945d	c8		iny		                iny
.945e	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9460	91 24		sta ($24),y	                sta (tmp1),y
.9462					z_loop:
.9462	60		rts		z_plus_loop:    rts
.9463					plus_loop_runtime:
.9463	18		clc		                clc
.9464	68		pla		                pla             ; LSB of index
.9465	75 00		adc $00,x	                adc 0,x         ; LSB of step
.9467	a8		tay		                tay             ; temporary storage of LSB
.9468	b8		clv		                clv
.9469	68		pla		                pla             ; MSB of index
.946a	75 01		adc $01,x	                adc 1,x         ; MSB of step
.946c	48		pha		                pha             ; put MSB of index back on stack
.946d	98		tya		                tya             ; put LSB of index back on stack
.946e	48		pha		                pha
.946f	e8		inx		                inx             ; dump step from TOS
.9470	e8		inx		                inx
.9471	70 03		bvs $9476	                bvs _hack+3     ; skip over JMP instruction
.9473					_hack:
>9473	4c				                .byte $4C
.9474					plus_loop_runtime_end:
.9474					xt_lshift:
.9474	20 19 d8	jsr $d819	                jsr underflow_2
.9477	b5 00		lda $00,x	                lda 0,x
.9479	29 0f		and #$0f	                and #%00001111
.947b	f0 08		beq $9485	                beq _done
.947d	a8		tay		                tay
.947e					_loop:
.947e	16 02		asl $02,x	                asl 2,x
.9480	36 03		rol $03,x	                rol 3,x
.9482	88		dey		                dey
.9483	d0 f9		bne $947e	                bne _loop
.9485					_done:
.9485	e8		inx		                inx
.9486	e8		inx		                inx
.9487	60		rts		z_lshift:       rts
.9488					xt_m_star:
.9488	20 19 d8	jsr $d819	                jsr underflow_2
.948b	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.948d	55 03		eor $03,x	                eor 3,x         ; MSB of n2
.948f	48		pha		                pha
.9490	20 39 81	jsr $8139	                jsr xt_abs
.9493	20 93 a1	jsr $a193	                jsr xt_swap
.9496	20 39 81	jsr $8139	                jsr xt_abs
.9499	20 e1 a5	jsr $a5e1	                jsr xt_um_star          ; ( d )
.949c	68		pla		                pla
.949d	10 03		bpl $94a2	                bpl _done
.949f	20 3b 8b	jsr $8b3b	                jsr xt_dnegate
.94a2					_done:
.94a2	60		rts		z_m_star:       rts
.94a3					xt_marker:
.94a3	20 56 d7	jsr $d756	                jsr current_to_dp
.94a6	a5 02		lda $02		                lda dp
.94a8	48		pha		                pha
.94a9	a5 03		lda $03		                lda dp+1
.94ab	48		pha		                pha
.94ac	a5 00		lda $00		                lda cp
.94ae	48		pha		                pha
.94af	a5 01		lda $01		                lda cp+1
.94b1	48		pha		                pha
.94b2	20 63 89	jsr $8963	                jsr xt_create
.94b5	a5 00		lda $00		                lda cp          ; LSB
.94b7	38		sec		                sec
.94b8	e9 02		sbc #$02	                sbc #2
.94ba	85 00		sta $00		                sta cp
.94bc	a5 01		lda $01		                lda cp+1        ; MSB
.94be	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94c0	85 01		sta $01		                sta cp+1
.94c2	a0 94		ldy #$94	                ldy #>marker_runtime
.94c4	a9 e1		lda #$e1	                lda #<marker_runtime
.94c6	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.94c9	7a		ply		                ply                     ; MSB
.94ca	68		pla		                pla                     ; LSB
.94cb	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.94ce	7a		ply		                ply                     ; MSB
.94cf	68		pla		                pla                     ; LSB
.94d0	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.94d3	a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94d5					_marker_loop:
.94d5	b1 1e		lda ($1e),y	                lda (up),y
.94d7	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.94da	c8		iny		                iny
.94db	98		tya		                tya
.94dc	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94de	d0 f5		bne $94d5	                bne _marker_loop
.94e0	60		rts		z_marker:       rts
.94e1					marker_runtime:
.94e1	68		pla		                pla
.94e2	85 24		sta $24		                sta tmp1        ; LSB of address
.94e4	68		pla		                pla
.94e5	85 25		sta $25		                sta tmp1+1      ; MSB of address
.94e7	e6 24		inc $24		                inc tmp1
.94e9	d0 02		bne $94ed	                bne +
.94eb	e6 25		inc $25		                inc tmp1+1
.94ed					+
.94ed	a0 00		ldy #$00	                ldy #0
.94ef	b1 24		lda ($24),y	                lda (tmp1),y
.94f1	85 00		sta $00		                sta cp
.94f3	c8		iny		                iny
.94f4	b1 24		lda ($24),y	                lda (tmp1),y
.94f6	85 01		sta $01		                sta cp+1
.94f8	c8		iny		                iny
.94f9	b1 24		lda ($24),y	                lda (tmp1),y
.94fb	85 02		sta $02		                sta dp
.94fd	c8		iny		                iny
.94fe	b1 24		lda ($24),y	                lda (tmp1),y
.9500	85 03		sta $03		                sta dp+1
.9502	a0 04		ldy #$04	                ldy #4
.9504					_marker_restore_loop:
.9504	b1 24		lda ($24),y	                lda (tmp1), y
.9506	91 1e		sta ($1e),y	                sta (up), y
.9508	c8		iny		                iny
.9509	98		tya		                tya
.950a	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.950c	d0 f6		bne $9504	                bne _marker_restore_loop
.950e	20 69 d7	jsr $d769	                jsr dp_to_current       ; Move the CURRENT DP back.
.9511	60		rts		                rts
.9512					xt_max:
.9512	20 19 d8	jsr $d819	                jsr underflow_2
.9515	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9517	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.9519	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.951b	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.951d	50 02		bvc $9521	                bvc _no_overflow
.951f	49 80		eor #$80	                eor #$80        ; complement negative flag
.9521					_no_overflow:
.9521	30 08		bmi $952b	                bmi _keep_nos
.9523	b5 00		lda $00,x	                lda 0,x
.9525	95 02		sta $02,x	                sta 2,x
.9527	b5 01		lda $01,x	                lda 1,x
.9529	95 03		sta $03,x	                sta 3,x
.952b					_keep_nos:
.952b	e8		inx		                inx
.952c	e8		inx		                inx
.952d	60		rts		z_max:          rts
.952e					xt_min:
.952e	20 19 d8	jsr $d819	                jsr underflow_2
.9531	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9533	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.9535	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9537	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9539	50 02		bvc $953d	                bvc _no_overflow
.953b	49 80		eor #$80	                eor #$80
.953d					_no_overflow:
.953d	10 08		bpl $9547	                bpl _keep_nos
.953f	b5 00		lda $00,x	                lda 0,x
.9541	95 02		sta $02,x	                sta 2,x
.9543	b5 01		lda $01,x	                lda 1,x
.9545	95 03		sta $03,x	                sta 3,x
.9547					_keep_nos:
.9547	e8		inx		                inx
.9548	e8		inx		                inx
.9549	60		rts		z_min:          rts
.954a					xt_minus:
.954a	20 19 d8	jsr $d819	                jsr underflow_2
.954d	38		sec		                sec
.954e	b5 02		lda $02,x	                lda 2,x         ; LSB
.9550	f5 00		sbc $00,x	                sbc 0,x
.9552	95 02		sta $02,x	                sta 2,x
.9554	b5 03		lda $03,x	                lda 3,x         ; MSB
.9556	f5 01		sbc $01,x	                sbc 1,x
.9558	95 03		sta $03,x	                sta 3,x
.955a	e8		inx		                inx
.955b	e8		inx		                inx
.955c	60		rts		z_minus:        rts
.955d					xt_minus_leading:
.955d	20 19 d8	jsr $d819	                jsr underflow_2
.9560					_loop:
.9560	b5 00		lda $00,x	                lda 0,x
.9562	15 01		ora $01,x	                ora 1,x
.9564	f0 0f		beq $9575	                beq _done
.9566	a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.9568	20 07 d8	jsr $d807	                jsr is_whitespace
.956b	90 08		bcc $9575	                bcc _done
.956d	20 f3 97	jsr $97f3	                jsr xt_one              ; ( addr u 1 )
.9570	20 04 a0	jsr $a004	                jsr xt_slash_string     ; ( addr+ u-1 )
.9573	80 eb		bra $9560	                bra _loop
.9575					_done:
.9575					z_minus_leading:
.9575	60		rts		                rts
.9576					xt_minus_trailing:
.9576	20 19 d8	jsr $d819	                jsr underflow_2
.9579	b5 00		lda $00,x	                lda 0,x         ; LSB of n
.957b	15 01		ora $01,x	                ora 1,x         ; MSB of n
.957d	f0 33		beq $95b2	                beq _done
.957f	18		clc		                clc
.9580	b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.9582	75 00		adc $00,x	                adc 0,x
.9584	85 24		sta $24		                sta tmp1
.9586	b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.9588	75 01		adc $01,x	                adc 1,x
.958a	85 25		sta $25		                sta tmp1+1
.958c	a5 24		lda $24		                lda tmp1
.958e	d0 02		bne $9592	                bne +
.9590	c6 25		dec $25		                dec tmp1+1
.9592					+
.9592	c6 24		dec $24		                dec tmp1
.9594					_loop:
.9594	b2 24		lda ($24)	                lda (tmp1)
.9596	c9 20		cmp #$20	                cmp #AscSP
.9598	d0 18		bne $95b2	                bne _done
.959a	a5 24		lda $24		                lda tmp1
.959c	d0 02		bne $95a0	                bne +
.959e	c6 25		dec $25		                dec tmp1+1
.95a0					+
.95a0	c6 24		dec $24		                dec tmp1
.95a2	b5 00		lda $00,x	                lda 0,x
.95a4	d0 02		bne $95a8	                bne +
.95a6	d6 01		dec $01,x	                dec 1,x
.95a8					+
.95a8	d6 00		dec $00,x	                dec 0,x
.95aa	b5 00		lda $00,x	                lda 0,x
.95ac	15 01		ora $01,x	                ora 1,x
.95ae	f0 02		beq $95b2	                beq _done       ; Count has reached zero - we're done!
.95b0	80 e2		bra $9594	                bra _loop
.95b2					_done:
.95b2					z_minus_trailing:
.95b2	60		rts		                rts
.95b3					xt_mod:
.95b3	20 19 d8	jsr $d819	                jsr underflow_2
.95b6	20 ec 9f	jsr $9fec	                jsr xt_slash_mod
.95b9	e8		inx		                inx             ; DROP
.95ba	e8		inx		                inx
.95bb					z_mod:
.95bb	60		rts		                rts
.95bc					xt_move:
.95bc	b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95be	d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95c0	f0 05		beq $95c7	                beq _lsb                ; wasn't helpful, move to LSB
.95c2	b0 0e		bcs $95d2	                bcs _to_move_up         ; we want CMOVE>
.95c4	4c 93 86	jmp $8693	                jmp xt_cmove            ; JSR/RTS
.95c7					_lsb:
.95c7	b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95c9	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95cb	f0 08		beq $95d5	                beq _equal              ; LSB is equal as well
.95cd	b0 03		bcs $95d2	                bcs _to_move_up         ; we want CMOVE>
.95cf	4c 93 86	jmp $8693	                jmp xt_cmove            ; JSR/RTS
.95d2					_to_move_up:
.95d2	4c ce 86	jmp $86ce	                jmp xt_cmove_up         ; JSR/RTS
.95d5					_equal:
.95d5	8a		txa		                txa
.95d6	18		clc		                clc
.95d7	69 06		adc #$06	                adc #6
.95d9	aa		tax		                tax
.95da	60		rts		z_move:         rts
.95db					xt_name_to_int:
.95db	20 14 d8	jsr $d814	                jsr underflow_1
.95de	b5 00		lda $00,x	                lda 0,x
.95e0	18		clc		                clc
.95e1	69 04		adc #$04	                adc #4
.95e3	85 28		sta $28		                sta tmp3
.95e5	b5 01		lda $01,x	                lda 1,x
.95e7	90 01		bcc $95ea	                bcc _done
.95e9	1a		inc a		                ina
.95ea					_done:
.95ea	85 29		sta $29		                sta tmp3+1
.95ec	a0 00		ldy #$00	                ldy #0
.95ee	b1 28		lda ($28),y	                lda (tmp3),y
.95f0	95 00		sta $00,x	                sta 0,x
.95f2	c8		iny		                iny
.95f3	b1 28		lda ($28),y	                lda (tmp3),y
.95f5	95 01		sta $01,x	                sta 1,x
.95f7	60		rts		z_name_to_int:  rts
.95f8					xt_name_to_string:
.95f8	20 14 d8	jsr $d814	                jsr underflow_1
.95fb	ca		dex		                dex
.95fc	ca		dex		                dex
.95fd	a1 02		lda ($02,x)	                lda (2,x)
.95ff	95 00		sta $00,x	                sta 0,x
.9601	74 01		stz $01,x	                stz 1,x
.9603	b5 02		lda $02,x	                lda 2,x         ; LSB
.9605	18		clc		                clc
.9606	69 08		adc #$08	                adc #8
.9608	a8		tay		                tay
.9609	b5 03		lda $03,x	                lda 3,x         ; MSB
.960b	69 00		adc #$00	                adc #0          ; just need carry
.960d	95 03		sta $03,x	                sta 3,x
.960f	94 02		sty $02,x	                sty 2,x
.9611					z_name_to_string:
.9611	60		rts		                rts
.9612					xt_nc_limit:
.9612	ca		dex		                dex
.9613	ca		dex		                dex
.9614	a9 1a		lda #$1a	                lda #<nc_limit
.9616	95 00		sta $00,x	                sta 0,x
.9618	a9 00		lda #$00	                lda #>nc_limit
.961a	95 01		sta $01,x	                sta 1,x
.961c	60		rts		z_nc_limit:     rts
.961d					xt_negate:
.961d	20 14 d8	jsr $d814	                jsr underflow_1
.9620	a9 00		lda #$00	        	lda #0
.9622	38		sec		                sec
.9623	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.9625	95 00		sta $00,x	                sta 0,x
.9627	a9 00		lda #$00	                lda #0
.9629	f5 01		sbc $01,x	                sbc 1,x         ; MSB
.962b	95 01		sta $01,x	                sta 1,x
.962d	60		rts		z_negate:       rts
.962e					xt_never_native:
.962e	20 56 d7	jsr $d756	                jsr current_to_dp
.9631	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9633	b1 02		lda ($02),y	                lda (dp),y
.9635	09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9637	29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.9639	91 02		sta ($02),y	                sta (dp),y
.963b					z_never_native:
.963b	60		rts		                rts
.963c					xt_nip:
.963c	20 19 d8	jsr $d819	                jsr underflow_2
.963f	b5 00		lda $00,x	                lda 0,x         ; LSB
.9641	95 02		sta $02,x	                sta 2,x
.9643	b5 01		lda $01,x	                lda 1,x         ; MSB
.9645	95 03		sta $03,x	                sta 3,x
.9647	e8		inx		                inx
.9648	e8		inx		                inx
.9649	60		rts		z_nip:          rts
.964a					xt_not_equals:
.964a	20 19 d8	jsr $d819	                jsr underflow_2
.964d	a0 00		ldy #$00	                ldy #0                  ; default is true
.964f	b5 00		lda $00,x	                lda 0,x                 ; LSB
.9651	d5 02		cmp $02,x	                cmp 2,x
.9653	d0 0a		bne $965f	                bne _not_equal
.9655	b5 01		lda $01,x	                lda 1,x                 ; MSB
.9657	d5 03		cmp $03,x	                cmp 3,x
.9659	d0 04		bne $965f	                bne _not_equal
.965b	a9 ff		lda #$ff	                lda #$FF
.965d	80 01		bra $9660	                bra _done
.965f					_not_equal:
.965f	88		dey		                dey                     ; drop thru to done
.9660					_done:
.9660	98		tya		                tya
.9661	e8		inx		                inx
.9662	e8		inx		                inx
.9663	95 00		sta $00,x	                sta 0,x
.9665	95 01		sta $01,x	                sta 1,x
.9667	60		rts		z_not_equals:   rts
.9668					xt_not_rote:
.9668	20 1e d8	jsr $d81e	                jsr underflow_3
.966b	b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.966d	b5 03		lda $03,x	                lda 3,x
.966f	95 01		sta $01,x	                sta 1,x
.9671	b5 05		lda $05,x	                lda 5,x
.9673	95 03		sta $03,x	                sta 3,x
.9675	94 05		sty $05,x	                sty 5,x
.9677	b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9679	b5 02		lda $02,x	                lda 2,x
.967b	95 00		sta $00,x	                sta 0,x
.967d	b5 04		lda $04,x	                lda 4,x
.967f	95 02		sta $02,x	                sta 2,x
.9681	94 04		sty $04,x	                sty 4,x
.9683	60		rts		z_not_rote:     rts
.9684					xt_number:
.9684	20 19 d8	jsr $d819	                jsr underflow_2
.9687	64 2a		stz $2a		                stz tmpdsp      ; flag for double
.9689	64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.968b	a5 18		lda $18		                lda base
.968d	48		pha		                pha
.968e	a1 02		lda ($02,x)	                lda (2,x)
.9690					_check_dec:
.9690	c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.9692	d0 04		bne $9698	                bne _check_hex
.9694	a9 0a		lda #$0a	                lda #$0A
.9696	80 42		bra $96da	                bra _base_changed
.9698					_check_hex:
.9698	c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.969a	d0 04		bne $96a0	                bne _check_binary
.969c	a9 10		lda #$10	                lda #$10
.969e	80 3a		bra $96da	                bra _base_changed
.96a0					_check_binary:
.96a0	c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.96a2	d0 04		bne $96a8	                bne _check_char
.96a4	a9 02		lda #$02	                lda #$02
.96a6	80 32		bra $96da	                bra _base_changed
.96a8					_check_char:
.96a8	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96aa	d0 3a		bne $96e6	                bne _check_minus
.96ac	b5 00		lda $00,x	                lda 0,x         ; Get the length
.96ae	c9 03		cmp #$03	                cmp #$03
.96b0	d0 26		bne $96d8	                bne _not_a_char
.96b2	b5 01		lda $01,x	                lda 1,x
.96b4	d0 22		bne $96d8	                bne _not_a_char ; No compare needed to check for non-zero.
.96b6	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96b8	18		clc		                clc
.96b9	69 02		adc #$02	                adc #2          ; length of string
.96bb	85 2c		sta $2c		                sta tmptos
.96bd	b5 03		lda $03,x	                lda 3,x
.96bf	69 00		adc #$00	                adc #0          ; only need carry
.96c1	85 2d		sta $2d		                sta tmptos+1
.96c3	b2 2c		lda ($2c)	                lda (tmptos)
.96c5	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96c7	d0 0f		bne $96d8	                bne _not_a_char
.96c9	f6 02		inc $02,x	                inc 2,x
.96cb	d0 02		bne $96cf	                bne +
.96cd	f6 03		inc $03,x	                inc 3,x
.96cf					+
.96cf	a1 02		lda ($02,x)	                lda (2,x)
.96d1	95 02		sta $02,x	                sta 2,x
.96d3	74 03		stz $03,x	                stz 3,x
.96d5	4c 61 97	jmp $9761	                jmp _single ; Single with drop the TOS for us.
.96d8					_not_a_char:
.96d8	80 5a		bra $9734	                bra _number_error
.96da					_base_changed:
.96da	85 18		sta $18		                sta base        ; Switch to the new base
.96dc	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96de	d0 02		bne $96e2	                bne +
.96e0	f6 03		inc $03,x	                inc 3,x
.96e2					+
.96e2	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96e4	a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96e6					_check_minus:
.96e6	c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96e8	d0 0a		bne $96f4	                bne _check_dot
.96ea	c6 2b		dec $2b		                dec tmpdsp+1
.96ec	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96ee	d0 02		bne $96f2	                bne +
.96f0	f6 03		inc $03,x	                inc 3,x
.96f2					+
.96f2	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96f4					_check_dot:
.96f4	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96f6	18		clc		                clc
.96f7	75 00		adc $00,x	                adc 0,x         ; length of string
.96f9	85 2c		sta $2c		                sta tmptos
.96fb	b5 03		lda $03,x	                lda 3,x
.96fd	69 00		adc #$00	                adc #0          ; only need carry
.96ff	85 2d		sta $2d		                sta tmptos+1
.9701	a5 2c		lda $2c		                lda tmptos
.9703	d0 02		bne $9707	                bne +
.9705	c6 2d		dec $2d		                dec tmptos+1
.9707					+
.9707	c6 2c		dec $2c		                dec tmptos
.9709	b2 2c		lda ($2c)	                lda (tmptos)
.970b	c9 2e		cmp #$2e	                cmp #'.'
.970d	d0 04		bne $9713	                bne _main
.970f	c6 2a		dec $2a		                dec tmpdsp
.9711	d6 00		dec $00,x	                dec 0,x
.9713					_main:
.9713	ca		dex		                dex
.9714	ca		dex		                dex
.9715	ca		dex		                dex
.9716	ca		dex		                dex
.9717	b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9719	95 00		sta $00,x	                sta 0,x
.971b	74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.971d	b5 06		lda $06,x	                lda 6,x         ; LSB of address
.971f	95 02		sta $02,x	                sta 2,x
.9721	b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9723	95 03		sta $03,x	                sta 3,x
.9725	74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9727	74 05		stz $05,x	                stz 5,x
.9729	74 06		stz $06,x	                stz 6,x
.972b	74 07		stz $07,x	                stz 7,x
.972d	20 a2 a2	jsr $a2a2	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9730	b5 00		lda $00,x	                lda 0,x
.9732	f0 18		beq $974c	                beq _all_converted
.9734					_number_error:
.9734	a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9736	20 f0 8d	jsr $8df0	                jsr emit_a
.9739	20 e8 a4	jsr $a4e8	                jsr xt_type
.973c	a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.973e	20 f0 8d	jsr $8df0	                jsr emit_a
.9741	20 09 a1	jsr $a109	                jsr xt_space
.9744	68		pla		                pla
.9745	85 18		sta $18		                sta base
.9747	a9 08		lda #$08	                lda #err_syntax
.9749	4c 2a d8	jmp $d82a	                jmp error
.974c					_all_converted:
.974c	e8		inx		                inx
.974d	e8		inx		                inx
.974e	e8		inx		                inx
.974f	e8		inx		                inx
.9750	a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9752	f0 0d		beq $9761	                beq _single
.9754	a9 20		lda #$20	                lda #%00100000
.9756	04 20		tsb $20		                tsb status
.9758	a5 2b		lda $2b		                lda tmpdsp+1
.975a	f0 12		beq $976e	                beq _done       ; no minus, all done
.975c	20 3b 8b	jsr $8b3b	                jsr xt_dnegate
.975f	80 0d		bra $976e	                bra _done
.9761					_single:
.9761	e8		inx		                inx
.9762	e8		inx		                inx
.9763	a9 20		lda #$20	                lda #%00100000
.9765	14 20		trb $20		                trb status
.9767	a5 2b		lda $2b		                lda tmpdsp+1
.9769	f0 03		beq $976e	                beq _done       ; no minus, all done
.976b	20 1d 96	jsr $961d	                jsr xt_negate
.976e					_done:
.976e	68		pla		                pla
.976f	85 18		sta $18		                sta base
.9771	60		rts		z_number:       rts
.9772					xt_number_sign:
.9772	20 19 d8	jsr $d819	                jsr underflow_2         ; double number
.9775	20 81 83	jsr $8381	                jsr xt_base
.9778	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; ( ud1 base )
.977b	20 55 a3	jsr $a355	                jsr xt_to_r             ; >r
.977e	20 8d a7	jsr $a78d	                jsr xt_zero             ; 0
.9781	20 68 9a	jsr $9a68	                jsr xt_r_fetch          ; r@
.9784	20 9f a5	jsr $a59f	                jsr xt_um_slash_mod     ; um/mod
.9787	20 42 9b	jsr $9b42	                jsr xt_rot              ; rot
.978a	20 42 9b	jsr $9b42	                jsr xt_rot              ; rot
.978d	20 7d 9a	jsr $9a7d	                jsr xt_r_from           ; r>
.9790	20 9f a5	jsr $a59f	                jsr xt_um_slash_mod     ; um/mod
.9793	20 42 9b	jsr $9b42	                jsr xt_rot              ; rot
.9796	20 42 9b	jsr $9b42	                jsr xt_rot              ; ( ud rem )
.9799	b5 00		lda $00,x	                lda 0,x
.979b	a8		tay		                tay
.979c	b9 08 d4	lda $d408,y	                lda s_abc_upper,y
.979f	95 00		sta $00,x	                sta 0,x
.97a1	74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.97a3	20 d1 91	jsr $91d1	                jsr xt_hold
.97a6					z_number_sign:
.97a6	60		rts		                rts
.97a7					xt_number_sign_greater:
.97a7	20 19 d8	jsr $d819	                jsr underflow_2         ; double number
.97aa	a5 34		lda $34		                lda tohold
.97ac	95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97ae	95 02		sta $02,x	                sta 2,x
.97b0	a5 35		lda $35		                lda tohold+1
.97b2	95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97b4	95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97b6	20 8c 98	jsr $988c	                jsr xt_pad      ; ( addr addr pad )
.97b9	38		sec		                sec
.97ba	b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97bc	f5 02		sbc $02,x	                sbc 2,x
.97be	95 02		sta $02,x	                sta 2,x
.97c0	b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97c2	f5 03		sbc $03,x	                sbc 3,x
.97c4	95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97c6	e8		inx		                inx
.97c7	e8		inx		                inx
.97c8					z_number_sign_greater:
.97c8	60		rts		                rts
.97c9					xt_number_sign_s:
.97c9	20 19 d8	jsr $d819	                jsr underflow_2
.97cc					_loop:
.97cc	20 72 97	jsr $9772	                jsr xt_number_sign
.97cf	b5 00		lda $00,x	                lda 0,x
.97d1	15 01		ora $01,x	                ora 1,x
.97d3	15 02		ora $02,x	                ora 2,x
.97d5	15 03		ora $03,x	                ora 3,x
.97d7	d0 f3		bne $97cc	                bne _loop
.97d9					z_number_sign_s:
.97d9	60		rts		                rts
.97da					xt_of:
.97da	a0 98		ldy #$98	                ldy #>xt_over
.97dc	a9 7e		lda #$7e	                lda #<xt_over
.97de	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.97e1	a0 8e		ldy #$8e	                ldy #>xt_equal
.97e3	a9 c8		lda #$c8	                lda #<xt_equal
.97e5	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.97e8	20 fd 91	jsr $91fd	                jsr xt_if
.97eb	a0 8d		ldy #$8d	                ldy #>xt_drop
.97ed	a9 28		lda #$28	                lda #<xt_drop
.97ef	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.97f2	60		rts		z_of:           rts
.97f3					xt_editor_wordlist:
.97f3					xt_one:
.97f3	ca		dex		                dex
.97f4	ca		dex		                dex
.97f5	a9 01		lda #$01	                lda #1
.97f7	95 00		sta $00,x	                sta 0,x
.97f9	74 01		stz $01,x	                stz 1,x
.97fb					z_editor_wordlist:
.97fb					z_one:
.97fb	60		rts		                rts
.97fc					xt_one_minus:
.97fc	20 14 d8	jsr $d814	                jsr underflow_1
.97ff	b5 00		lda $00,x	                lda 0,x
.9801	d0 02		bne $9805	                bne +
.9803	d6 01		dec $01,x	                dec 1,x
.9805					+
.9805	d6 00		dec $00,x	                dec 0,x
.9807	60		rts		z_one_minus:    rts
.9808					xt_char_plus:
.9808					xt_one_plus:
.9808	20 14 d8	jsr $d814	                jsr underflow_1
.980b	f6 00		inc $00,x	                inc 0,x
.980d	d0 02		bne $9811	                bne _done
.980f	f6 01		inc $01,x	                inc 1,x
.9811					_done:
.9811					z_char_plus:
.9811	60		rts		z_one_plus:     rts
.9812					xt_only:
.9812	ca		dex		                dex
.9813	ca		dex		                dex
.9814	a9 ff		lda #$ff	                lda #$FF
.9816	95 00		sta $00,x	                sta 0,x
.9818	95 01		sta $01,x	                sta 1,x
.981a	20 06 9d	jsr $9d06	                jsr xt_set_order
.981d	60		rts		z_only:         rts
.981e					xt_or:
.981e	20 19 d8	jsr $d819	                jsr underflow_2
.9821	b5 00		lda $00,x	                lda 0,x
.9823	15 02		ora $02,x	                ora 2,x
.9825	95 02		sta $02,x	                sta 2,x
.9827	b5 01		lda $01,x	                lda 1,x
.9829	15 03		ora $03,x	                ora 3,x
.982b	95 03		sta $03,x	                sta 3,x
.982d	e8		inx		                inx
.982e	e8		inx		                inx
.982f	60		rts		z_or:           rts
.9830					xt_order:
.9830	20 5d 89	jsr $895d	                jsr xt_cr
.9833	20 2e 91	jsr $912e	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.9836	b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9838	f0 1e		beq $9858	                beq _drop_done
.983a					_have_wordlists:
.983a	a8		tay		                tay
.983b					_loop:
.983b	e8		inx		                inx
.983c	e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.983d	b5 00		lda $00,x	                lda 0,x
.983f	5a		phy		                phy
.9840	20 5b 98	jsr $985b	                jsr order_print_wid_string   ; internal helper function
.9843	7a		ply		                ply
.9844	88		dey		                dey
.9845	d0 f4		bne $983b	                bne _loop
.9847	20 09 a1	jsr $a109	                jsr xt_space
.984a	20 09 a1	jsr $a109	                jsr xt_space
.984d	20 23 91	jsr $9123	                jsr xt_get_current      ; ( wid )
.9850	b5 00		lda $00,x	                lda 0,x
.9852	20 5b 98	jsr $985b	                jsr order_print_wid_string
.9855	20 5d 89	jsr $895d	                jsr xt_cr
.9858					_drop_done:
.9858	e8		inx		                inx
.9859	e8		inx		                inx
.985a					z_order:
.985a	60		rts		                rts
.985b					order_print_wid_string:
.985b	c9 04		cmp #$04	                cmp #4
.985d	90 09		bcc $9868	                bcc _output_string      ; less than 4, print a real string
.985f	ca		dex		                dex
.9860	ca		dex		                dex
.9861	95 00		sta $00,x	                sta 0,x
.9863	74 01		stz $01,x	                stz 1,x
.9865	4c 13 a5	jmp $a513	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.9868					_output_string:
.9868	a8		tay		                tay
.9869	b9 6f 98	lda $986f,y	                lda _wid_data,y
.986c	4c 40 d8	jmp $d840	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.986f					_wid_data:
>986f	03				        .byte str_wid_forth            ; WID 0: "Forth"
>9870	06				        .byte str_wid_editor           ; WID 1: "Editor"
>9871	07				        .byte str_wid_assembler        ; WID 2: "Assembler"
>9872	08				        .byte str_wid_root             ; WID 3: "Root"
.9873					xt_output:
.9873	ca		dex		                dex
.9874	ca		dex		                dex
.9875	a9 10		lda #$10	                lda #<output
.9877	95 00		sta $00,x	                sta 0,x
.9879	a9 00		lda #$00	                lda #>output
.987b	95 01		sta $01,x	                sta 1,x
.987d	60		rts		z_output:       rts
.987e					xt_over:
.987e	20 19 d8	jsr $d819	                jsr underflow_2
.9881	ca		dex		                dex
.9882	ca		dex		                dex
.9883	b5 04		lda $04,x	                lda 4,x         ; LSB
.9885	95 00		sta $00,x	                sta 0,x
.9887	b5 05		lda $05,x	                lda 5,x         ; MSB
.9889	95 01		sta $01,x	                sta 1,x
.988b	60		rts		z_over:         rts
.988c					xt_pad:
.988c	ca		dex		                dex
.988d	ca		dex		                dex
.988e	a5 00		lda $00		                lda cp
.9890	18		clc		                clc
.9891	69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.9893	95 00		sta $00,x	                sta 0,x
.9895	a5 01		lda $01		                lda cp+1
.9897	69 00		adc #$00	                adc #0          ; only need carry
.9899	95 01		sta $01,x	                sta 1,x
.989b	60		rts		z_pad:          rts
.989c					xt_page:
.989c	a9 1b		lda #$1b	                lda #AscESC
.989e	20 f0 8d	jsr $8df0	                jsr emit_a
.98a1	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.98a3	20 f0 8d	jsr $8df0	                jsr emit_a
.98a6	a9 32		lda #$32	                lda #'2'
.98a8	20 f0 8d	jsr $8df0	                jsr emit_a
.98ab	a9 4a		lda #$4a	                lda #'J'
.98ad	20 f0 8d	jsr $8df0	                jsr emit_a
.98b0	20 8d a7	jsr $a78d	                jsr xt_zero
.98b3	20 8d a7	jsr $a78d	                jsr xt_zero
.98b6	20 50 83	jsr $8350	                jsr xt_at_xy
.98b9	60		rts		z_page:         rts
.98ba					xt_paren:
.98ba	ca		dex		                dex
.98bb	ca		dex		                dex
.98bc	a9 29		lda #$29	                lda #41     ; Right parenthesis
.98be	95 00		sta $00,x	                sta 0,x
.98c0	74 01		stz $01,x	                stz 1,x
.98c2	20 25 99	jsr $9925	                jsr xt_parse
.98c5	e8		inx		                inx
.98c6	e8		inx		                inx
.98c7	e8		inx		                inx
.98c8	e8		inx		                inx
.98c9	60		rts		z_paren:        rts
.98ca					xt_parse_name:
.98ca	a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98cc	38		sec		                sec
.98cd	e5 0c		sbc $0c		                sbc toin
.98cf	85 24		sta $24		                sta tmp1
.98d1	a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98d3	e5 0d		sbc $0d		                sbc toin+1
.98d5	85 25		sta $25		                sta tmp1+1
.98d7	a5 24		lda $24		                lda tmp1
.98d9	05 25		ora $25		                ora tmp1+1
.98db	f0 28		beq $9905	                beq _empty_line
.98dd	a5 08		lda $08		                lda cib
.98df	18		clc		                clc
.98e0	65 0c		adc $0c		                adc toin
.98e2	85 26		sta $26		                sta tmp2                ; LSB of first character
.98e4	a5 09		lda $09		                lda cib+1
.98e6	65 0d		adc $0d		                adc toin+1
.98e8	85 27		sta $27		                sta tmp2+1              ; MSB
.98ea					_skip_loop:
.98ea	b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.98ec	20 07 d8	jsr $d807	                jsr is_whitespace
.98ef	90 1f		bcc $9910	                bcc _char_found
.98f1	e6 26		inc $26		                inc tmp2
.98f3	d0 02		bne $98f7	                bne +
.98f5	e6 27		inc $27		                inc tmp2+1
.98f7					+
.98f7	a5 24		lda $24		                lda tmp1
.98f9	d0 02		bne $98fd	                bne +
.98fb	c6 25		dec $25		                dec tmp1+1
.98fd	c6 24		dec $24		+               dec tmp1
.98ff	a5 24		lda $24		                lda tmp1
.9901	05 25		ora $25		                ora tmp1+1
.9903	d0 e5		bne $98ea	                bne _skip_loop          ; fall through if empty line
.9905					_empty_line:
.9905	ca		dex		                dex
.9906	ca		dex		                dex
.9907	ca		dex		                dex
.9908	ca		dex		                dex
.9909	74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.990b	74 01		stz $01,x	                stz 1,x
.990d	4c bc 99	jmp $99bc	                jmp z_parse_name        ; skip over PARSE
.9910					_char_found:
.9910	a5 26		lda $26		                lda tmp2
.9912	38		sec		                sec
.9913	e5 08		sbc $08		                sbc cib
.9915	85 0c		sta $0c		                sta toin
.9917	a5 27		lda $27		                lda tmp2+1
.9919	e5 09		sbc $09		                sbc cib+1
.991b	85 0d		sta $0d		                sta toin+1
.991d	ca		dex		                dex
.991e	ca		dex		                dex
.991f	a9 20		lda #$20	                lda #AscSP
.9921	95 00		sta $00,x	                sta 0,x
.9923	74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.9925					xt_parse:
.9925	20 14 d8	jsr $d814	                jsr underflow_1
.9928	a5 0a		lda $0a		                lda ciblen
.992a	05 0b		ora $0b		                ora ciblen+1
.992c	f0 0c		beq $993a	                beq _abort_parse
.992e	a5 0d		lda $0d		                lda toin+1              ; MSB
.9930	c5 0b		cmp $0b		                cmp ciblen+1
.9932	90 0e		bcc $9942	                bcc _go_parse           ; unsigned comparison
.9934	a5 0c		lda $0c		                lda toin                ; LSB
.9936	c5 0a		cmp $0a		                cmp ciblen
.9938	90 08		bcc $9942	                bcc _go_parse
.993a					_abort_parse:
.993a	ca		dex		                dex
.993b	ca		dex		                dex
.993c	74 00		stz $00,x	                stz 0,x
.993e	74 01		stz $01,x	                stz 1,x
.9940	80 7a		bra $99bc	                bra _done
.9942					_go_parse:
.9942	b5 00		lda $00,x	                lda 0,x
.9944	85 2c		sta $2c		                sta tmptos
.9946	ca		dex		                dex
.9947	ca		dex		                dex
.9948	a5 08		lda $08		                lda cib
.994a	18		clc		                clc
.994b	65 0c		adc $0c		                adc toin        ; LSB
.994d	85 24		sta $24		                sta tmp1
.994f	85 26		sta $26		                sta tmp2
.9951	95 02		sta $02,x	                sta 2,x
.9953	a5 09		lda $09		                lda cib+1
.9955	65 0d		adc $0d		                adc toin+1      ; MSB
.9957	85 25		sta $25		                sta tmp1+1
.9959	85 27		sta $27		                sta tmp2+1
.995b	95 03		sta $03,x	                sta 3,x
.995d	a5 08		lda $08		                lda cib
.995f	18		clc		                clc
.9960	65 0a		adc $0a		                adc ciblen
.9962	85 28		sta $28		                sta tmp3
.9964	a5 09		lda $09		                lda cib+1
.9966	65 0b		adc $0b		                adc ciblen+1
.9968	85 29		sta $29		                sta tmp3+1
.996a	64 2d		stz $2d		                stz tmptos+1
.996c					_loop:
.996c	a5 26		lda $26		                lda tmp2
.996e	c5 28		cmp $28		                cmp tmp3
.9970	d0 06		bne $9978	                bne _not_empty
.9972	a5 27		lda $27		                lda tmp2+1
.9974	c5 29		cmp $29		                cmp tmp3+1
.9976	f0 1d		beq $9995	                beq _eol
.9978					_not_empty:
.9978	b2 26		lda ($26)	                lda (tmp2)
.997a	a4 2c		ldy $2c		                ldy tmptos
.997c	c0 20		cpy #$20	                cpy #AscSP
.997e	d0 07		bne $9987	                bne _not_whitespace
.9980	20 07 d8	jsr $d807	                jsr is_whitespace
.9983	90 02		bcc $9987	                bcc _not_whitespace
.9985	80 0c		bra $9993	                bra _found_delimiter
.9987					_not_whitespace:
.9987	c5 2c		cmp $2c		                cmp tmptos
.9989	f0 08		beq $9993	                beq _found_delimiter
.998b	e6 26		inc $26		                inc tmp2
.998d	d0 dd		bne $996c	                bne _loop
.998f	e6 27		inc $27		                inc tmp2+1
.9991	80 d9		bra $996c	                bra _loop
.9993					_found_delimiter:
.9993	e6 2d		inc $2d		                inc tmptos+1
.9995					_eol:
.9995	a5 26		lda $26		                lda tmp2
.9997	38		sec		                sec
.9998	e5 24		sbc $24		                sbc tmp1
.999a	95 00		sta $00,x	                sta 0,x
.999c	a5 27		lda $27		                lda tmp2+1
.999e	e5 25		sbc $25		                sbc tmp1+1
.99a0	95 01		sta $01,x	                sta 1,x
.99a2	a5 26		lda $26		                lda tmp2
.99a4	38		sec		                sec
.99a5	e5 08		sbc $08		                sbc cib
.99a7	85 0c		sta $0c		                sta toin
.99a9	a5 27		lda $27		                lda tmp2+1
.99ab	e5 09		sbc $09		                sbc cib+1
.99ad	85 0d		sta $0d		                sta toin+1
.99af	a5 0c		lda $0c		                lda toin
.99b1	18		clc		                clc
.99b2	65 2d		adc $2d		                adc tmptos+1
.99b4	85 0c		sta $0c		                sta toin
.99b6	a5 0d		lda $0d		                lda toin+1
.99b8	69 00		adc #$00	                adc #0          ; we only need the carry
.99ba	85 0d		sta $0d		                sta toin+1
.99bc					_done:
.99bc					z_parse_name:
.99bc	60		rts		z_parse:        rts
.99bd					xt_pick:
.99bd	16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99bf	8a		txa		                txa
.99c0	75 00		adc $00,x	                adc 0,x
.99c2	a8		tay		                tay
.99c3	b9 02 00	lda $0002,y	                lda 0002,y
.99c6	95 00		sta $00,x	                sta 0,x
.99c8	b9 03 00	lda $0003,y	                lda 0003,y
.99cb	95 01		sta $01,x	                sta 1,x
.99cd	60		rts		z_pick:         rts
.99ce					xt_plus:
.99ce	20 19 d8	jsr $d819	                jsr underflow_2
.99d1	18		clc		                clc
.99d2	b5 00		lda $00,x	                lda 0,x         ; LSB
.99d4	75 02		adc $02,x	                adc 2,x
.99d6	95 02		sta $02,x	                sta 2,x
.99d8	b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99da	75 03		adc $03,x	                adc 3,x
.99dc	95 03		sta $03,x	                sta 3,x
.99de	e8		inx		                inx
.99df	e8		inx		                inx
.99e0	60		rts		z_plus:         rts
.99e1					xt_plus_store:
.99e1	20 19 d8	jsr $d819	                jsr underflow_2
.99e4	b5 00		lda $00,x	                lda 0,x
.99e6	85 24		sta $24		                sta tmp1
.99e8	b5 01		lda $01,x	                lda 1,x
.99ea	85 25		sta $25		                sta tmp1+1
.99ec	a0 00		ldy #$00	                ldy #0          ; LSB
.99ee	b1 24		lda ($24),y	                lda (tmp1),y
.99f0	18		clc		                clc
.99f1	75 02		adc $02,x	                adc 2,x
.99f3	91 24		sta ($24),y	                sta (tmp1),y
.99f5	c8		iny		                iny             ; MSB
.99f6	b1 24		lda ($24),y	                lda (tmp1),y
.99f8	75 03		adc $03,x	                adc 3,x
.99fa	91 24		sta ($24),y	                sta (tmp1),y
.99fc	e8		inx		                inx
.99fd	e8		inx		                inx
.99fe	e8		inx		                inx
.99ff	e8		inx		                inx
.9a00	60		rts		z_plus_store:   rts
.9a01					xt_postpone:
.9a01	20 ca 98	jsr $98ca	                jsr xt_parse_name               ; ( -- addr n )
.9a04	b5 00		lda $00,x	                lda 0,x
.9a06	15 01		ora $01,x	                ora 1,x
.9a08	d0 05		bne $9a0f	                bne +
.9a0a	a9 05		lda #$05	                lda #err_noname
.9a0c	4c 2a d8	jmp $d82a	                jmp error
.9a0f					+
.9a0f	20 d5 8f	jsr $8fd5	                jsr xt_find_name                ; ( -- nt | 0 )
.9a12	d0 05		bne $9a19	                bne +
.9a14	a9 05		lda #$05	                lda #err_noname
.9a16	4c 2a d8	jmp $d82a	                jmp error
.9a19					+
.9a19	b5 00		lda $00,x	                lda 0,x
.9a1b	85 24		sta $24		                sta tmp1
.9a1d	b5 01		lda $01,x	                lda 1,x
.9a1f	85 25		sta $25		                sta tmp1+1
.9a21	20 db 95	jsr $95db	                jsr xt_name_to_int              ; ( nt -- xt )
.9a24	e6 24		inc $24		                inc tmp1
.9a26	d0 02		bne $9a2a	                bne +
.9a28	e6 25		inc $25		                inc tmp1+1
.9a2a					+
.9a2a	b2 24		lda ($24)	                lda (tmp1)
.9a2c	29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a2e	f0 05		beq $9a35	                beq _not_immediate
.9a30	20 e7 87	jsr $87e7	                jsr xt_compile_comma
.9a33	80 0a		bra $9a3f	                bra _done
.9a35					_not_immediate:
.9a35	20 84 93	jsr $9384	                jsr xt_literal
.9a38	a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a3a	a9 e7		lda #$e7	                lda #<xt_compile_comma
.9a3c	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.9a3f					_done:
.9a3f	60		rts		z_postpone:     rts
.9a40					xt_previous:
.9a40	20 2e 91	jsr $912e	                jsr xt_get_order
.9a43	20 3c 96	jsr $963c	                jsr xt_nip
.9a46	20 fc 97	jsr $97fc	                jsr xt_one_minus
.9a49	20 06 9d	jsr $9d06	                jsr xt_set_order
.9a4c	60		rts		z_previous:     rts
.9a4d					xt_question:
.9a4d	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.9a50	20 30 8c	jsr $8c30	                jsr xt_dot
.9a53	60		rts		z_question:     rts
.9a54					xt_question_dup:
.9a54	20 14 d8	jsr $d814	                jsr underflow_1
.9a57	b5 00		lda $00,x	                lda 0,x
.9a59	15 01		ora $01,x	                ora 1,x
.9a5b	f0 0a		beq $9a67	                beq _done
.9a5d	ca		dex		                dex
.9a5e	ca		dex		                dex
.9a5f	b5 02		lda $02,x	                lda 2,x
.9a61	95 00		sta $00,x	                sta 0,x
.9a63	b5 03		lda $03,x	                lda 3,x
.9a65	95 01		sta $01,x	                sta 1,x
.9a67					_done:
.9a67	60		rts		z_question_dup: rts
.9a68					xt_r_fetch:
.9a68	7a		ply		                ply             ; LSB
.9a69	84 24		sty $24		                sty tmp1
.9a6b	7a		ply		                ply             ; MSB
.9a6c	ca		dex		                dex
.9a6d	ca		dex		                dex
.9a6e	68		pla		                pla             ; LSB
.9a6f	95 00		sta $00,x	                sta 0,x
.9a71	68		pla		                pla             ; MSB
.9a72	95 01		sta $01,x	                sta 1,x
.9a74	48		pha		                pha
.9a75	b5 00		lda $00,x	                lda 0,x
.9a77	48		pha		                pha
.9a78	5a		phy		                phy             ; MSB
.9a79	a4 24		ldy $24		                ldy tmp1
.9a7b	5a		phy		                phy             ; LSB
.9a7c	60		rts		z_r_fetch:      rts
.9a7d					xt_r_from:
.9a7d	68		pla		                pla             ; LSB
.9a7e	85 2c		sta $2c		                sta tmptos
.9a80	7a		ply		                ply             ; MSB
.9a81	ca		dex		                dex
.9a82	ca		dex		                dex
.9a83	68		pla		                pla             ; LSB
.9a84	95 00		sta $00,x	                sta 0,x
.9a86	68		pla		                pla             ; MSB
.9a87	95 01		sta $01,x	                sta 1,x
.9a89	5a		phy		                phy             ; MSB
.9a8a	a5 2c		lda $2c		                lda tmptos
.9a8c	48		pha		                pha             ; LSB
.9a8d	60		rts		z_r_from:       rts
.9a8e					xt_r_to_input:
.9a8e	68		pla		                pla
.9a8f	85 24		sta $24		                sta tmp1
.9a91	68		pla		                pla
.9a92	85 25		sta $25		                sta tmp1+1
.9a94	a0 00		ldy #$00	                ldy #0
.9a96					_loop:
.9a96	68		pla		                pla
.9a97	99 06 00	sta $0006,y	                sta insrc,y
.9a9a	c8		iny		                iny
.9a9b	c0 08		cpy #$08	                cpy #8
.9a9d	d0 f7		bne $9a96	                bne _loop
.9a9f	a5 25		lda $25		                lda tmp1+1
.9aa1	48		pha		                pha
.9aa2	a5 24		lda $24		                lda tmp1
.9aa4	48		pha		                pha
.9aa5	60		rts		z_r_to_input: 	rts
.9aa6					xt_recurse:
.9aa6	a0 00		ldy #$00	                ldy #0
.9aa8	a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9aaa	91 00		sta ($00),y	                sta (cp),y
.9aac	c8		iny		                iny
.9aad	24 20		bit $20		                bit status
.9aaf	70 0c		bvs $9abd	                bvs _nt_in_workword
.9ab1	a5 04		lda $04		                lda workword
.9ab3	91 00		sta ($00),y	                sta (cp),y
.9ab5	c8		iny		                iny
.9ab6	a5 05		lda $05		                lda workword+1
.9ab8	91 00		sta ($00),y	                sta (cp),y
.9aba	c8		iny		                iny
.9abb	80 1b		bra $9ad8	                bra _update_cp
.9abd					_nt_in_workword:
.9abd	a5 04		lda $04		                lda workword            ; LSB
.9abf	18		clc		                clc
.9ac0	69 04		adc #$04	                adc #4
.9ac2	85 24		sta $24		                sta tmp1
.9ac4	a5 05		lda $05		                lda workword+1          ; MSB
.9ac6	69 00		adc #$00	                adc #0
.9ac8	85 25		sta $25		                sta tmp1+1
.9aca	b2 24		lda ($24)	                lda (tmp1)
.9acc	91 00		sta ($00),y	                sta (cp),y
.9ace	5a		phy		                phy
.9acf	a0 01		ldy #$01	                ldy #1
.9ad1	b1 24		lda ($24),y	                lda (tmp1),y
.9ad3	7a		ply		                ply
.9ad4	c8		iny		                iny
.9ad5	91 00		sta ($00),y	                sta (cp),y
.9ad7	c8		iny		                iny
.9ad8					_update_cp:
.9ad8	98		tya		                tya
.9ad9	18		clc		                clc
.9ada	65 00		adc $00		                adc cp
.9adc	85 00		sta $00		                sta cp
.9ade	90 02		bcc $9ae2	                bcc _done
.9ae0	e6 01		inc $01		                inc cp+1
.9ae2					_done:
.9ae2	60		rts		z_recurse:      rts
.9ae3					xt_refill:
.9ae3	a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9ae5	d0 2d		bne $9b14	                bne _src_not_kbd
.9ae7	ca		dex		                dex
.9ae8	ca		dex		                dex
.9ae9	ca		dex		                dex
.9aea	ca		dex		                dex
.9aeb	a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9aed	95 02		sta $02,x	                sta 2,x
.9aef	a5 09		lda $09		                lda cib+1
.9af1	95 03		sta $03,x	                sta 3,x
.9af3	64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9af5	64 0b		stz $0b		                stz ciblen+1
.9af7	a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9af9	95 00		sta $00,x	                sta 0,x
.9afb	74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9afd	20 4e 81	jsr $814e	                jsr xt_accept           ; ( addr n1 -- n2)
.9b00	b5 00		lda $00,x	                lda 0,x
.9b02	85 0a		sta $0a		                sta ciblen
.9b04	b5 01		lda $01,x	                lda 1,x
.9b06	85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9b08	64 0c		stz $0c		                stz toin
.9b0a	64 0d		stz $0d		                stz toin+1
.9b0c	a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b0e	95 00		sta $00,x	                sta 0,x
.9b10	95 01		sta $01,x	                sta 1,x
.9b12	80 10		bra $9b24	                bra _done
.9b14					_src_not_kbd:
.9b14	1a		inc a		                ina
.9b15	d0 08		bne $9b1f	                bne _src_not_string
.9b17	ca		dex		                dex
.9b18	ca		dex		                dex
.9b19	74 00		stz $00,x	                stz 0,x
.9b1b	74 01		stz $01,x	                stz 1,x
.9b1d	80 05		bra $9b24	                bra z_refill
.9b1f					_src_not_string:
.9b1f	a9 01		lda #$01	                lda #err_badsource
.9b21	4c 2a d8	jmp $d82a	                jmp error
.9b24					_done:
.9b24	60		rts		z_refill:       rts
.9b25					xt_repeat:
.9b25	20 89 82	jsr $8289	                jsr xt_again
.9b28	20 6c 91	jsr $916c	                jsr xt_here
.9b2b	20 93 a1	jsr $a193	                jsr xt_swap
.9b2e	20 72 a1	jsr $a172	                jsr xt_store
.9b31	60		rts		z_repeat:       rts
.9b32					xt_right_bracket:
.9b32	a9 ff		lda #$ff	                lda #$FF
.9b34	85 16		sta $16		                sta state
.9b36	85 17		sta $17		                sta state+1
.9b38					z_right_bracket:
.9b38	60		rts		                rts
.9b39					xt_root_wordlist:
.9b39	ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b3a	ca		dex		                dex
.9b3b	a9 03		lda #$03	                lda #3
.9b3d	95 00		sta $00,x	                sta 0,x
.9b3f	74 01		stz $01,x	                stz 1,x
.9b41					z_root_wordlist:
.9b41	60		rts		                rts
.9b42					xt_rot:
.9b42	20 1e d8	jsr $d81e	                jsr underflow_3
.9b45	b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b47	b5 03		lda $03,x	                lda 3,x
.9b49	95 05		sta $05,x	                sta 5,x
.9b4b	b5 01		lda $01,x	                lda 1,x
.9b4d	95 03		sta $03,x	                sta 3,x
.9b4f	94 01		sty $01,x	                sty 1,x
.9b51	b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b53	b5 02		lda $02,x	                lda 2,x
.9b55	95 04		sta $04,x	                sta 4,x
.9b57	b5 00		lda $00,x	                lda 0,x
.9b59	95 02		sta $02,x	                sta 2,x
.9b5b	94 00		sty $00,x	                sty 0,x
.9b5d	60		rts		z_rot:          rts
.9b5e					xt_rshift:
.9b5e	20 19 d8	jsr $d819	                jsr underflow_2
.9b61	b5 00		lda $00,x	                lda 0,x
.9b63	29 0f		and #$0f	                and #%00001111
.9b65	f0 08		beq $9b6f	                beq _done               ; if 0 shifts, quit
.9b67	a8		tay		                tay
.9b68					_loop:
.9b68	56 03		lsr $03,x	                lsr 3,x
.9b6a	76 02		ror $02,x	                ror 2,x
.9b6c	88		dey		                dey
.9b6d	d0 f9		bne $9b68	                bne _loop
.9b6f					_done:
.9b6f	e8		inx		                inx
.9b70	e8		inx		                inx
.9b71	60		rts		z_rshift:       rts
.9b72					xt_s_backslash_quote:
.9b72	a9 ff		lda #$ff	                lda #$FF
.9b74	85 26		sta $26		                sta tmp2
.9b76	64 27		stz $27		                stz tmp2+1
.9b78	20 3e 9d	jsr $9d3e	                jsr s_quote_start
.9b7b					_done:
.9b7b					z_s_backslash_quote:
.9b7b	60		rts		                rts
.9b7c					convert_hex_value:
.9b7c	c9 41		cmp #$41	        cmp #'A'
.9b7e	90 07		bcc $9b87	        bcc _digit
.9b80	29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b82	38		sec		        sec
.9b83	e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b85	80 03		bra $9b8a	        bra _done
.9b87					_digit:
.9b87	38		sec		        sec
.9b88	e9 30		sbc #$30	        sbc #'0'
.9b8a					_done:
.9b8a	60		rts		        rts
.9b8b					xt_search_wordlist:
.9b8b	20 1e d8	jsr $d81e	                jsr underflow_3
.9b8e	a5 1e		lda $1e		                lda up
.9b90	18		clc		                clc
.9b91	69 06		adc #$06	                adc #wordlists_offset
.9b93	85 26		sta $26		                sta tmp2
.9b95	a5 1f		lda $1f		                lda up+1
.9b97	69 00		adc #$00	                adc #0          ; Adding carry
.9b99	85 27		sta $27		                sta tmp2+1
.9b9b	b5 00		lda $00,x	                lda 0,x
.9b9d	0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9b9e	65 26		adc $26		                adc tmp2
.9ba0	85 26		sta $26		                sta tmp2
.9ba2	90 02		bcc $9ba6	                bcc +
.9ba4	e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9ba6					+
.9ba6	e8		inx		                inx
.9ba7	e8		inx		                inx
.9ba8	b5 00		lda $00,x	                lda 0,x
.9baa	15 01		ora $01,x	                ora 1,x
.9bac	d0 03		bne $9bb1	                bne _check_wordlist
.9bae	4c 69 9c	jmp $9c69	                jmp _done
.9bb1					_check_wordlist:
.9bb1	a5 26		lda $26		                lda tmp2
.9bb3	05 27		ora $27		                ora tmp2+1
.9bb5	d0 03		bne $9bba	                bne _have_string
.9bb7	4c 69 9c	jmp $9c69	                jmp _done
.9bba					_have_string:
.9bba	b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9bbc	85 24		sta $24		                sta tmp1
.9bbe	e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9bc0	d0 02		bne $9bc4	                bne +
.9bc2	e6 27		inc $27		                inc tmp2+1
.9bc4					+
.9bc4	b2 26		lda ($26)	                lda (tmp2)
.9bc6	85 25		sta $25		                sta tmp1+1
.9bc8	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9bca	85 26		sta $26		                sta tmp2
.9bcc	b5 03		lda $03,x	                lda 3,x
.9bce	85 27		sta $27		                sta tmp2+1
.9bd0					_loop:
.9bd0	b2 24		lda ($24)	                lda (tmp1)
.9bd2	d5 00		cmp $00,x	                cmp 0,x
.9bd4	d0 7b		bne $9c51	                bne _next_entry
.9bd6					_compare_string:
.9bd6	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9bd8	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bda	b0 07		bcs $9be3	                bcs _compare_first
.9bdc	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bde	90 03		bcc $9be3	                bcc _compare_first
.9be0	18		clc		                clc
.9be1	69 20		adc #$20	                adc #$20
.9be3					_compare_first:
.9be3	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9be5	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9be7	d0 68		bne $9c51	                bne _next_entry
.9be9	b5 00		lda $00,x	                lda 0,x
.9beb	3a		dec a		                dea
.9bec	f0 2c		beq $9c1a	                beq _success
.9bee	a5 24		lda $24		                lda tmp1
.9bf0	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9bf1	18		clc		                clc
.9bf2	69 08		adc #$08	                adc #8
.9bf4	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9bf6	a5 25		lda $25		                lda tmp1+1
.9bf8	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9bf9	69 00		adc #$00	                adc #0          ; we only need the carry
.9bfb	85 25		sta $25		                sta tmp1+1
.9bfd	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9bff	88		dey		                dey
.9c00					_string_loop:
.9c00	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9c02	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9c04	b0 07		bcs $9c0d	                bcs _check_char
.9c06	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9c08	90 03		bcc $9c0d	                bcc _check_char
.9c0a	18		clc		                clc
.9c0b	69 20		adc #$20	                adc #$20
.9c0d					_check_char:
.9c0d	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c0f	d0 3a		bne $9c4b	                bne _next_entry_tmp1
.9c11	88		dey		                dey
.9c12	d0 ec		bne $9c00	                bne _string_loop
.9c14					_success_tmp1:
.9c14	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c15	85 25		sta $25		                sta tmp1+1
.9c17	68		pla		                pla
.9c18	85 24		sta $24		                sta tmp1
.9c1a					_success:
.9c1a	e8		inx		                inx
.9c1b	e8		inx		                inx
.9c1c	a5 24		lda $24		                lda tmp1
.9c1e	95 00		sta $00,x	                sta 0,x
.9c20	a5 25		lda $25		                lda tmp1+1
.9c22	95 01		sta $01,x	                sta 1,x
.9c24	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( nt nt )
.9c27	20 db 95	jsr $95db	                jsr xt_name_to_int      ; ( nt xt )
.9c2a	20 93 a1	jsr $a193	                jsr xt_swap             ; ( xt nt )
.9c2d	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c2f	f6 00		inc $00,x	                inc 0,x
.9c31	d0 02		bne $9c35	                bne +
.9c33	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c35					+
.9c35	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c37	29 04		and #$04	                and #IM
.9c39	d0 08		bne $9c43	                bne _immediate          ; bit set, we're immediate
.9c3b	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c3d	95 00		sta $00,x	                sta 0,x
.9c3f	95 01		sta $01,x	                sta 1,x
.9c41	80 28		bra $9c6b	                bra _done_nodrop
.9c43					_immediate:
.9c43	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c45	95 00		sta $00,x	                sta 0,x
.9c47	74 01		stz $01,x	                stz 1,x
.9c49	80 20		bra $9c6b	                bra _done_nodrop
.9c4b					_next_entry_tmp1:
.9c4b	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c4c	85 25		sta $25		                sta tmp1+1
.9c4e	68		pla		                pla
.9c4f	85 24		sta $24		                sta tmp1
.9c51					_next_entry:
.9c51	a0 02		ldy #$02	                ldy #2
.9c53	b1 24		lda ($24),y	                lda (tmp1),y
.9c55	48		pha		                pha
.9c56	c8		iny		                iny
.9c57	b1 24		lda ($24),y	                lda (tmp1),y
.9c59	85 25		sta $25		                sta tmp1+1
.9c5b	68		pla		                pla
.9c5c	85 24		sta $24		                sta tmp1
.9c5e	05 25		ora $25		                ora tmp1+1
.9c60	f0 03		beq $9c65	                beq _fail_done
.9c62	4c d0 9b	jmp $9bd0	                jmp _loop
.9c65					_fail_done:
.9c65	74 02		stz $02,x	                stz 2,x         ; failure flag
.9c67	74 03		stz $03,x	                stz 3,x
.9c69					_done:
.9c69	e8		inx		                inx
.9c6a	e8		inx		                inx
.9c6b					_done_nodrop:
.9c6b					z_search_wordlist:
.9c6b	60		rts		                rts
.9c6c					xt_see:
.9c6c	20 ca 98	jsr $98ca	                jsr xt_parse_name       ; ( addr u )
.9c6f	20 d5 8f	jsr $8fd5	                jsr xt_find_name        ; ( nt | 0 )
.9c72	b5 00		lda $00,x	                lda 0,x
.9c74	15 01		ora $01,x	                ora 1,x
.9c76	d0 05		bne $9c7d	                bne +
.9c78	a9 05		lda #$05	                lda #err_noname
.9c7a	4c 2a d8	jmp $d82a	                jmp error
.9c7d					+
.9c7d	20 5d 89	jsr $895d	                jsr xt_cr
.9c80	a5 18		lda $18		                lda base
.9c82	48		pha		                pha
.9c83	20 77 91	jsr $9177	                jsr xt_hex
.9c86	a9 0a		lda #$0a	                lda #str_see_nt
.9c88	20 40 d8	jsr $d840	                jsr print_string_no_lf
.9c8b	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( nt nt )
.9c8e	20 13 a5	jsr $a513	                jsr xt_u_dot
.9c91	20 09 a1	jsr $a109	                jsr xt_space            ; ( nt )
.9c94	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( nt nt )
.9c97	20 db 95	jsr $95db	                jsr xt_name_to_int      ; ( nt xt )
.9c9a	a9 0b		lda #$0b	                lda #str_see_xt
.9c9c	20 40 d8	jsr $d840	                jsr print_string_no_lf
.9c9f	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( nt xt xt )
.9ca2	20 13 a5	jsr $a513	                jsr xt_u_dot
.9ca5	20 5d 89	jsr $895d	                jsr xt_cr               ; ( nt xt )
.9ca8	a9 09		lda #$09	                lda #str_see_flags
.9caa	20 40 d8	jsr $d840	                jsr print_string_no_lf
.9cad	20 7e 98	jsr $987e	                jsr xt_over             ; ( nt xt nt )
.9cb0	20 08 98	jsr $9808	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9cb3	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; ( nt xt flags )
.9cb6	b5 00		lda $00,x	                lda 0,x
.9cb8	a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9cba					_flag_loop:
.9cba	48		pha		                pha
.9cbb	29 01		and #$01	                and #%00000001
.9cbd	18		clc		                clc
.9cbe	69 30		adc #$30	                adc #$30                ; ASCII "0"
.9cc0	20 f0 8d	jsr $8df0	                jsr emit_a
.9cc3	20 09 a1	jsr $a109	                jsr xt_space
.9cc6	68		pla		                pla
.9cc7	6a		ror a		                ror                     ; Next flag
.9cc8	88		dey		                dey
.9cc9	d0 ef		bne $9cba	                bne _flag_loop
.9ccb	20 5d 89	jsr $895d	                jsr xt_cr
.9cce	e8		inx		                inx
.9ccf	e8		inx		                inx                     ; ( nt xt )
.9cd0	a9 0c		lda #$0c	                lda #str_see_size
.9cd2	20 40 d8	jsr $d840	                jsr print_string_no_lf
.9cd5	20 93 a1	jsr $a193	                jsr xt_swap             ; ( xt nt )
.9cd8	20 5a a7	jsr $a75a	                jsr xt_wordsize         ; ( xt u )
.9cdb	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9cde	20 9f 8a	jsr $8a9f	                jsr xt_decimal
.9ce1	20 13 a5	jsr $a513	                jsr xt_u_dot            ; ( xt u )
.9ce4	20 77 91	jsr $9177	                jsr xt_hex
.9ce7	20 5d 89	jsr $895d	                jsr xt_cr
.9cea	20 9d a3	jsr $a39d	                jsr xt_two_dup          ; ( xt u xt u )
.9ced	20 2e 8d	jsr $8d2e	                jsr xt_dump
.9cf0	20 5d 89	jsr $895d	                jsr xt_cr
.9cf3	20 34 8b	jsr $8b34	                jsr xt_disasm
.9cf6	68		pla		                pla
.9cf7	85 18		sta $18		                sta base
.9cf9	60		rts		z_see:          rts
.9cfa					xt_set_current:
.9cfa	20 14 d8	jsr $d814	                jsr underflow_1
.9cfd	a0 04		ldy #$04	                ldy #current_offset
.9cff	b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9d01	91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9d03	e8		inx		                inx
.9d04	e8		inx		                inx
.9d05	60		rts		z_set_current:  rts
.9d06					xt_set_order:
.9d06	a9 ff		lda #$ff	                lda #$FF
.9d08	d5 01		cmp $01,x	                cmp 1,x
.9d0a	d0 12		bne $9d1e	                bne _start
.9d0c	d5 00		cmp $00,x	                cmp 0,x
.9d0e	d0 0e		bne $9d1e	                bne _start
.9d10	ca		dex		                dex             ; Make room for the count.
.9d11	ca		dex		                dex
.9d12	74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d14	a9 03		lda #$03	                lda #3
.9d16	95 02		sta $02,x	                sta 2,x
.9d18	74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d1a	a9 01		lda #$01	                lda #1
.9d1c	95 00		sta $00,x	                sta 0,x
.9d1e					_start:
.9d1e	a0 1e		ldy #$1e	                ldy #num_order_offset
.9d20	b5 00		lda $00,x	                lda 0,x
.9d22	91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d24	85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d26	e8		inx		                inx             ; Drop the count off the data stack.
.9d27	e8		inx		                inx
.9d28	a5 24		lda $24		                lda tmp1
.9d2a	f0 0d		beq $9d39	                beq _done       ; If zero, there are no wordlists.
.9d2c	a0 1f		ldy #$1f	                ldy #search_order_offset
.9d2e					_loop:
.9d2e	b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d30	91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d32	c8		iny		                iny
.9d33	e8		inx		                inx
.9d34	e8		inx		                inx
.9d35	c6 24		dec $24		                dec tmp1
.9d37	d0 f5		bne $9d2e	                bne _loop
.9d39					_done:
.9d39	60		rts		z_set_order:    rts
.9d3a					xt_s_quote:
.9d3a	64 26		stz $26		                stz tmp2
.9d3c	64 27		stz $27		                stz tmp2+1
.9d3e					s_quote_start:
.9d3e	ca		dex		                dex
.9d3f	ca		dex		                dex
.9d40	ca		dex		                dex
.9d41	ca		dex		                dex
.9d42	a9 4c		lda #$4c	                lda #$4C
.9d44	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.9d47	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.9d4a	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.9d4d	a5 00		lda $00		                lda cp
.9d4f	95 02		sta $02,x	                sta 2,x
.9d51	a5 01		lda $01		                lda cp+1
.9d53	95 03		sta $03,x	                sta 3,x
.9d55					_savechars_loop:
.9d55	a5 0d		lda $0d		                lda toin+1              ; MSB
.9d57	c5 0b		cmp $0b		                cmp ciblen+1
.9d59	90 2a		bcc $9d85	                bcc _input_fine         ; unsigned comparison
.9d5b	a5 0c		lda $0c		                lda toin                ; LSB
.9d5d	c5 0a		cmp $0a		                cmp ciblen
.9d5f	90 24		bcc $9d85	                bcc _input_fine
.9d61	a5 26		lda $26		                lda tmp2
.9d63	48		pha		                pha
.9d64	a5 27		lda $27		                lda tmp2+1
.9d66	48		pha		                pha
.9d67	a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d69	48		pha		                pha
.9d6a	20 e3 9a	jsr $9ae3	                jsr xt_refill           ; ( -- f )
.9d6d	68		pla		                pla
.9d6e	85 28		sta $28		                sta tmp3
.9d70	68		pla		                pla
.9d71	85 27		sta $27		                sta tmp2+1
.9d73	68		pla		                pla
.9d74	85 26		sta $26		                sta tmp2
.9d76	b5 00		lda $00,x	                lda 0,x
.9d78	15 01		ora $01,x	                ora 1,x
.9d7a	d0 05		bne $9d81	                bne _refill_ok
.9d7c	a9 06		lda #$06	                lda #err_refill
.9d7e	4c 2a d8	jmp $d82a	                jmp error
.9d81					_refill_ok:
.9d81	e8		inx		                inx
.9d82	e8		inx		                inx
.9d83	80 d0		bra $9d55	                bra _savechars_loop
.9d85					_input_fine:
.9d85	a5 08		lda $08		                lda cib
.9d87	18		clc		                clc
.9d88	65 0c		adc $0c		                adc toin        ; LSB
.9d8a	85 24		sta $24		                sta tmp1
.9d8c	a5 09		lda $09		                lda cib+1
.9d8e	65 0d		adc $0d		                adc toin+1      ; MSB
.9d90	85 25		sta $25		                sta tmp1+1
.9d92	b2 24		lda ($24)	                lda (tmp1)
.9d94	24 26		bit $26		                bit tmp2
.9d96	30 03		bmi $9d9b	                bmi _handle_escapes    ; Only checking bit 7
.9d98	4c 53 9e	jmp $9e53	                jmp _regular_char
.9d9b					_handle_escapes:
.9d9b	24 27		bit $27		                bit tmp2+1
.9d9d	30 03		bmi $9da2	                bmi _escaped
.9d9f	4c 49 9e	jmp $9e49	                jmp _not_escaped
.9da2					_escaped:
.9da2	70 22		bvs $9dc6	                bvs _check_esc_chars
.9da4	a9 01		lda #$01	                lda #1
.9da6	24 27		bit $27		                bit tmp2+1
.9da8	d0 10		bne $9dba	                bne _esc_x_second_digit
.9daa	e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9dac	b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9dae	20 7c 9b	jsr $9b7c	                jsr convert_hex_value
.9db1	0a		asl a		                asl
.9db2	0a		asl a		                asl
.9db3	0a		asl a		                asl
.9db4	0a		asl a		                asl
.9db5	85 28		sta $28		                sta tmp3    ; Save it for later.
.9db7	4c 5a 9e	jmp $9e5a	                jmp _next_character
.9dba					_esc_x_second_digit:
.9dba	64 27		stz $27		                stz tmp2+1
.9dbc	b2 24		lda ($24)	                lda (tmp1)
.9dbe	20 7c 9b	jsr $9b7c	                jsr convert_hex_value
.9dc1	05 28		ora $28		                ora tmp3
.9dc3	4c 57 9e	jmp $9e57	                jmp _save_character
.9dc6					_check_esc_chars:
.9dc6	64 27		stz $27		                stz tmp2+1
.9dc8					_check_esc_a:
.9dc8	c9 61		cmp #$61	                cmp #'a'
.9dca	d0 05		bne $9dd1	                bne _check_esc_b
.9dcc	a9 07		lda #$07	                lda #7
.9dce	4c 57 9e	jmp $9e57	                jmp _save_character
.9dd1					_check_esc_b:
.9dd1	c9 62		cmp #$62	                cmp #'b'
.9dd3	d0 05		bne $9dda	                bne _check_esc_e
.9dd5	a9 08		lda #$08	                lda #8
.9dd7	4c 57 9e	jmp $9e57	                jmp _save_character
.9dda					_check_esc_e:
.9dda	c9 65		cmp #$65	                cmp #'e'
.9ddc	d0 04		bne $9de2	                bne _check_esc_f
.9dde	a9 1b		lda #$1b	                lda #27
.9de0	80 75		bra $9e57	                bra _save_character
.9de2					_check_esc_f:
.9de2	c9 66		cmp #$66	                cmp #'f'
.9de4	d0 04		bne $9dea	                bne _check_esc_l
.9de6	a9 0c		lda #$0c	                lda #12
.9de8	80 6d		bra $9e57	                bra _save_character
.9dea					_check_esc_l:
.9dea	c9 6c		cmp #$6c	                cmp #'l'
.9dec	d0 04		bne $9df2	                bne _check_esc_m
.9dee	a9 0a		lda #$0a	                lda #10
.9df0	80 65		bra $9e57	                bra _save_character
.9df2					_check_esc_m:
.9df2	c9 6d		cmp #$6d	                cmp #'m'
.9df4	d0 09		bne $9dff	                bne _check_esc_n
.9df6	a9 0d		lda #$0d	                lda #13
.9df8	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.9dfb	a9 0a		lda #$0a	                lda #10
.9dfd	80 58		bra $9e57	                bra _save_character
.9dff					_check_esc_n:
.9dff	c9 6e		cmp #$6e	                cmp #'n'
.9e01	d0 04		bne $9e07	                bne _check_esc_q
.9e03	a9 0a		lda #$0a	                lda #10
.9e05	80 50		bra $9e57	                bra _save_character
.9e07					_check_esc_q:
.9e07	c9 71		cmp #$71	                cmp #'q'
.9e09	d0 04		bne $9e0f	                bne _check_esc_r
.9e0b	a9 22		lda #$22	                lda #34
.9e0d	80 48		bra $9e57	                bra _save_character
.9e0f					_check_esc_r:
.9e0f	c9 72		cmp #$72	                cmp #'r'
.9e11	d0 04		bne $9e17	                bne _check_esc_t
.9e13	a9 0d		lda #$0d	                lda #13
.9e15	80 40		bra $9e57	                bra _save_character
.9e17					_check_esc_t:
.9e17	c9 74		cmp #$74	                cmp #'t'
.9e19	d0 04		bne $9e1f	                bne _check_esc_v
.9e1b	a9 09		lda #$09	                lda #9
.9e1d	80 38		bra $9e57	                bra _save_character
.9e1f					_check_esc_v:
.9e1f	c9 76		cmp #$76	                cmp #'v'
.9e21	d0 04		bne $9e27	                bne _check_esc_z
.9e23	a9 0b		lda #$0b	                lda #11
.9e25	80 30		bra $9e57	                bra _save_character
.9e27					_check_esc_z:
.9e27	c9 7a		cmp #$7a	                cmp #'z'
.9e29	d0 04		bne $9e2f	                bne _check_esc_quote
.9e2b	a9 00		lda #$00	                lda #0
.9e2d	80 28		bra $9e57	                bra _save_character
.9e2f					_check_esc_quote:
.9e2f	c9 22		cmp #$22	                cmp #$22
.9e31	d0 04		bne $9e37	                bne _check_esc_x
.9e33	a9 22		lda #$22	                lda #34
.9e35	80 20		bra $9e57	                bra _save_character
.9e37					_check_esc_x:
.9e37	c9 78		cmp #$78	                cmp #'x'
.9e39	d0 06		bne $9e41	                bne _check_esc_backslash
.9e3b	a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e3d	85 27		sta $27		                sta tmp2+1
.9e3f	80 19		bra $9e5a	                bra _next_character
.9e41					_check_esc_backslash:
.9e41	c9 5c		cmp #$5c	                cmp #$5C
.9e43	d0 04		bne $9e49	                bne _not_escaped
.9e45	a9 5c		lda #$5c	                lda #92
.9e47	80 0e		bra $9e57	                bra _save_character
.9e49					_not_escaped:
.9e49	c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e4b	d0 06		bne $9e53	                bne _regular_char
.9e4d	a9 ff		lda #$ff	                lda #$FF
.9e4f	85 27		sta $27		                sta tmp2+1
.9e51	80 07		bra $9e5a	                bra _next_character
.9e53					_regular_char:
.9e53	c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e55	f0 0c		beq $9e63	                beq _found_string_end
.9e57					_save_character:
.9e57	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.9e5a					_next_character:
.9e5a	e6 0c		inc $0c		                inc toin
.9e5c	d0 02		bne $9e60	                bne _savechars_loop_longjump
.9e5e	e6 0d		inc $0d		                inc toin+1
.9e60					_savechars_loop_longjump:
.9e60	4c 55 9d	jmp $9d55	                jmp _savechars_loop
.9e63					_found_string_end:
.9e63	e6 0c		inc $0c		                inc toin
.9e65	d0 02		bne $9e69	                bne +
.9e67	e6 0d		inc $0d		                inc toin+1
.9e69					+
.9e69	a5 00		lda $00		                lda cp
.9e6b	38		sec		                sec
.9e6c	f5 02		sbc $02,x	                sbc 2,x
.9e6e	95 00		sta $00,x	                sta 0,x         ; LSB
.9e70	a5 01		lda $01		                lda cp+1
.9e72	f5 03		sbc $03,x	                sbc 3,x
.9e74	95 01		sta $01,x	                sta 1,x         ; MSB
.9e76	b5 02		lda $02,x	                lda 2,x
.9e78	38		sec		                sec
.9e79	e9 02		sbc #$02	                sbc #2
.9e7b	85 24		sta $24		                sta tmp1
.9e7d	b5 03		lda $03,x	                lda 3,x
.9e7f	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e81	85 25		sta $25		                sta tmp1+1
.9e83	a5 00		lda $00		                lda cp
.9e85	92 24		sta ($24)	                sta (tmp1)
.9e87	a0 01		ldy #$01	                ldy #1
.9e89	a5 01		lda $01		                lda cp+1
.9e8b	91 24		sta ($24),y	                sta (tmp1),y
.9e8d	a5 16		lda $16		                lda state
.9e8f	05 17		ora $17		                ora state+1             ; paranoid
.9e91	f0 03		beq $9e96	                beq _done
.9e93	20 7a a0	jsr $a07a	                jsr sliteral_const_str         ; ( addr u -- )
.9e96					_done:
.9e96	60		rts		z_s_quote:      rts
.9e97					xt_s_to_d:
.9e97	20 14 d8	jsr $d814	                jsr underflow_1
.9e9a	ca		dex		                dex
.9e9b	ca		dex		                dex
.9e9c	74 00		stz $00,x	                stz 0,x
.9e9e	74 01		stz $01,x	                stz 1,x
.9ea0	b5 03		lda $03,x	                lda 3,x
.9ea2	10 04		bpl $9ea8	                bpl _done
.9ea4	d6 00		dec $00,x	                dec 0,x
.9ea6	d6 01		dec $01,x	                dec 1,x
.9ea8					_done:
.9ea8	60		rts		z_s_to_d:       rts
.9ea9					xt_save_buffers:
.9ea9	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9eab	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9ead	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9eaf	d0 12		bne $9ec3	                bne _done       ; Either not used or not dirty = done!
.9eb1	20 ad 83	jsr $83ad	                jsr xt_blkbuffer
.9eb4	20 9f 85	jsr $859f	                jsr xt_buffblocknum
.9eb7	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.9eba	20 5a 85	jsr $855a	                jsr xt_block_write
.9ebd	a9 01		lda #$01	                lda #1
.9ebf	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9ec1	91 1e		sta ($1e),y	                sta (up),y
.9ec3					_done:
.9ec3	60		rts		z_save_buffers: rts
.9ec4					xt_scr:
.9ec4	ca		dex		                dex
.9ec5	ca		dex		                dex
.9ec6	18		clc		                clc
.9ec7	a5 1e		lda $1e		                lda up
.9ec9	69 02		adc #$02	                adc #scr_offset ; Add offset
.9ecb	95 00		sta $00,x	                sta 0,x
.9ecd	a5 1f		lda $1f		                lda up+1
.9ecf	69 00		adc #$00	                adc #0          ; Adding carry
.9ed1	95 01		sta $01,x	                sta 1,x
.9ed3	60		rts		z_scr:          rts
.9ed4					xt_search:
.9ed4	20 23 d8	jsr $d823	                jsr underflow_4
.9ed7	b5 00		lda $00,x	                lda 0,x
.9ed9	15 01		ora $01,x	                ora 1,x
.9edb	d0 0b		bne $9ee8	                bne _start_search
.9edd	e8		inx		                inx             ; Remove u2
.9ede	e8		inx		                inx
.9edf	a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ee1	95 00		sta $00,x	                sta 0,x
.9ee3	95 01		sta $01,x	                sta 1,x
.9ee5	4c 72 9f	jmp $9f72	                jmp z_search
.9ee8					_start_search:
.9ee8	20 8d a7	jsr $a78d	                jsr xt_zero
.9eeb					_search_loop:
.9eeb	18		clc		                clc
.9eec	b5 00		lda $00,x	                lda 0,x
.9eee	75 02		adc $02,x	                adc 2,x
.9ef0	85 24		sta $24		                sta tmp1
.9ef2	b5 01		lda $01,x	                lda 1,x
.9ef4	75 03		adc $03,x	                adc 3,x
.9ef6	d5 07		cmp $07,x	                cmp 7,x
.9ef8	90 12		bcc $9f0c	                bcc _init_comparison ; Obviously less
.9efa	d0 06		bne $9f02	                bne _not_found
.9efc	b5 06		lda $06,x	                lda 6,x
.9efe	c5 24		cmp $24		                cmp tmp1
.9f00	b0 0a		bcs $9f0c	                bcs _init_comparison
.9f02					_not_found:
.9f02	e8		inx		                inx             ; Remove offset
.9f03	e8		inx		                inx
.9f04	e8		inx		                inx             ; Remove u2
.9f05	e8		inx		                inx
.9f06	74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9f08	74 01		stz $01,x	                stz 1,x
.9f0a	80 66		bra $9f72	                bra z_search
.9f0c					_init_comparison:
.9f0c	18		clc		                clc
.9f0d	b5 08		lda $08,x	                lda 8,x
.9f0f	75 00		adc $00,x	                adc 0,x
.9f11	85 24		sta $24		                sta tmp1
.9f13	b5 09		lda $09,x	                lda 9,x
.9f15	75 01		adc $01,x	                adc 1,x
.9f17	85 25		sta $25		                sta tmp1+1
.9f19	b5 04		lda $04,x	                lda 4,x
.9f1b	85 26		sta $26		                sta tmp2
.9f1d	b5 05		lda $05,x	                lda 5,x
.9f1f	85 27		sta $27		                sta tmp2+1
.9f21	b5 02		lda $02,x	                lda 2,x
.9f23	85 28		sta $28		                sta tmp3
.9f25	b5 03		lda $03,x	                lda 3,x
.9f27	85 29		sta $29		                sta tmp3+1
.9f29					_comparison_loop:
.9f29	b2 24		lda ($24)	                lda (tmp1)
.9f2b	d2 26		cmp ($26)	                cmp (tmp2)
.9f2d	f0 05		beq $9f34	                beq _letters_match
.9f2f	20 08 98	jsr $9808	                jsr xt_one_plus
.9f32	80 b7		bra $9eeb	                bra _search_loop
.9f34					_letters_match:
.9f34	e6 24		inc $24		                inc tmp1
.9f36	d0 02		bne $9f3a	                bne +
.9f38	e6 25		inc $25		                inc tmp1+1
.9f3a					+
.9f3a	e6 26		inc $26		                inc tmp2
.9f3c	d0 02		bne $9f40	                bne +
.9f3e	e6 27		inc $27		                inc tmp2+1
.9f40					+
.9f40	a5 28		lda $28		                lda tmp3
.9f42	d0 02		bne $9f46	                bne +
.9f44	c6 29		dec $29		                dec tmp3+1
.9f46					+
.9f46	c6 28		dec $28		                dec tmp3
.9f48	a5 28		lda $28		                lda tmp3
.9f4a	05 29		ora $29		                ora tmp3+1
.9f4c	d0 db		bne $9f29	                bne _comparison_loop ; Check the next letter
.9f4e	18		clc		                clc
.9f4f	b5 00		lda $00,x	                lda 0,x
.9f51	75 08		adc $08,x	                adc 8,x
.9f53	95 08		sta $08,x	                sta 8,x
.9f55	b5 01		lda $01,x	                lda 1,x
.9f57	75 09		adc $09,x	                adc 9,x
.9f59	95 09		sta $09,x	                sta 9,x
.9f5b	38		sec		                sec
.9f5c	b5 06		lda $06,x	                lda 6,x
.9f5e	f5 00		sbc $00,x	                sbc 0,x
.9f60	95 06		sta $06,x	                sta 6,x
.9f62	b5 07		lda $07,x	                lda 7,x
.9f64	f5 01		sbc $01,x	                sbc 1,x
.9f66	95 07		sta $07,x	                sta 7,x
.9f68	e8		inx		                inx             ; drop offset
.9f69	e8		inx		                inx
.9f6a	e8		inx		                inx             ; drop u2
.9f6b	e8		inx		                inx
.9f6c	a9 ff		lda #$ff	                lda #$FF
.9f6e	95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f70	95 01		sta $01,x	                sta 1,x
.9f72	60		rts		z_search:       rts
.9f73					xt_semicolon:
.9f73	24 20		bit $20		                bit status
.9f75	70 11		bvs $9f88	                bvs _colonword
.9f77	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f79	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.9f7c	ca		dex		                dex
.9f7d	ca		dex		                dex
.9f7e	a5 04		lda $04		                lda workword
.9f80	95 00		sta $00,x	                sta 0,x
.9f82	a5 05		lda $05		                lda workword+1
.9f84	95 01		sta $01,x	                sta 1,x
.9f86	80 45		bra $9fcd	                bra _semicolon_done
.9f88					_colonword:
.9f88	a0 06		ldy #$06	                ldy #6
.9f8a	a5 00		lda $00		                lda cp
.9f8c	91 04		sta ($04),y	                sta (workword),y
.9f8e	c8		iny		                iny
.9f8f	a5 01		lda $01		                lda cp+1
.9f91	91 04		sta ($04),y	                sta (workword),y
.9f93	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f95	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.9f98	24 20		bit $20		                bit status
.9f9a	10 26		bpl $9fc2	                bpl _new_word   ; Bit 7 is clear = new word
.9f9c	ca		dex		                dex
.9f9d	ca		dex		                dex
.9f9e	ca		dex		                dex
.9f9f	ca		dex		                dex
.9fa0	b2 04		lda ($04)	                lda (workword)
.9fa2	95 00		sta $00,x	                sta 0,x
.9fa4	74 01		stz $01,x	                stz 1,x
.9fa6	a5 04		lda $04		                lda workword
.9fa8	18		clc		                clc
.9fa9	69 08		adc #$08	                adc #8
.9fab	95 02		sta $02,x	                sta 2,x
.9fad	a5 05		lda $05		                lda workword+1
.9faf	69 00		adc #$00	                adc #0                  ; only want carry
.9fb1	95 03		sta $03,x	                sta 3,x
.9fb3	a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9fb5	20 40 d8	jsr $d840	                jsr print_string_no_lf
.9fb8	20 e8 a4	jsr $a4e8	                jsr xt_type
.9fbb	20 09 a1	jsr $a109	                jsr xt_space
.9fbe	a9 80		lda #$80	                lda #%10000000
.9fc0	14 20		trb $20		                trb status
.9fc2					_new_word:
.9fc2	a5 04		lda $04		                lda workword
.9fc4	85 02		sta $02		                sta dp
.9fc6	a5 05		lda $05		                lda workword+1
.9fc8	85 03		sta $03		                sta dp+1
.9fca	20 69 d7	jsr $d769	                jsr dp_to_current       ; Save the updated DP to the
.9fcd					_semicolon_done:
.9fcd	64 16		stz $16		                stz state
.9fcf	64 17		stz $17		                stz state+1
.9fd1	60		rts		z_semicolon:    rts
.9fd2					xt_sign:
.9fd2	20 14 d8	jsr $d814	                jsr underflow_1
.9fd5	b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9fd7	30 04		bmi $9fdd	                bmi _minus
.9fd9	e8		inx		                inx
.9fda	e8		inx		                inx
.9fdb	80 09		bra $9fe6	                bra _done
.9fdd					_minus:
.9fdd	a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9fdf	95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9fe1	74 01		stz $01,x	                stz 1,x         ; paranoid
.9fe3	20 d1 91	jsr $91d1	                jsr xt_hold
.9fe6					_done:
.9fe6	60		rts		z_sign:         rts
.9fe7					xt_slash:
.9fe7	a9 00		lda #$00	                lda #0
.9fe9	48		pha		                pha
.9fea	80 03		bra $9fef	                bra slashmod_common
.9fec					xt_slash_mod:
.9fec	a9 ff		lda #$ff	                lda #$FF
.9fee	48		pha		                pha             ; falls through to _common
.9fef					slashmod_common:
.9fef	20 55 a3	jsr $a355	                jsr xt_to_r             ; >R
.9ff2	20 97 9e	jsr $9e97	                jsr xt_s_to_d           ; S>D
.9ff5	20 7d 9a	jsr $9a7d	                jsr xt_r_from           ; R>
.9ff8	20 c0 a0	jsr $a0c0	                jsr xt_sm_slash_rem     ; SM/REM
.9ffb	68		pla		                pla
.9ffc	d0 05		bne $a003	                bne _done
.9ffe	20 93 a1	jsr $a193	                jsr xt_swap
.a001	e8		inx		                inx             ; DROP
.a002	e8		inx		                inx
.a003					_done:
.a003					z_slash_mod:
.a003	60		rts		z_slash:        rts
.a004					xt_slash_string:
.a004	20 1e d8	jsr $d81e	                jsr underflow_3
.a007	18		clc		                clc             ; 3OS+TOS
.a008	b5 00		lda $00,x	                lda 0,x
.a00a	75 04		adc $04,x	                adc 4,x
.a00c	95 04		sta $04,x	                sta 4,x
.a00e	b5 01		lda $01,x	                lda 1,x
.a010	75 05		adc $05,x	                adc 5,x
.a012	95 05		sta $05,x	                sta 5,x
.a014	38		sec		                sec             ; NOS-TOS
.a015	b5 02		lda $02,x	                lda 2,x
.a017	f5 00		sbc $00,x	                sbc 0,x
.a019	95 02		sta $02,x	                sta 2,x
.a01b	b5 03		lda $03,x	                lda 3,x
.a01d	f5 01		sbc $01,x	                sbc 1,x
.a01f	95 03		sta $03,x	                sta 3,x
.a021	e8		inx		                inx
.a022	e8		inx		                inx
.a023	60		rts		z_slash_string: rts
.a024					xt_sliteral:
.a024	20 19 d8	jsr $d819	                jsr underflow_2
.a027	a9 4c		lda #$4c	                lda #$4C
.a029	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.a02c	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.a02f	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.a032	8a		txa		                txa
.a033	38		sec		                sec
.a034	e9 06		sbc #$06	                sbc #6
.a036	aa		tax		                tax
.a037	b5 08		lda $08,x	                lda 8,x
.a039	95 04		sta $04,x	                sta 4,x
.a03b	b5 09		lda $09,x	                lda 9,x
.a03d	95 05		sta $05,x	                sta 5,x
.a03f	b5 06		lda $06,x	                lda 6,x
.a041	95 00		sta $00,x	                sta 0,x
.a043	b5 07		lda $07,x	                lda 7,x
.a045	95 01		sta $01,x	                sta 1,x
.a047	a5 00		lda $00		                lda cp
.a049	95 08		sta $08,x	                sta 8,x
.a04b	95 02		sta $02,x	                sta 2,x
.a04d	a5 01		lda $01		                lda cp+1
.a04f	95 09		sta $09,x	                sta 9,x
.a051	95 03		sta $03,x	                sta 3,x
.a053	20 bc 95	jsr $95bc	                jsr xt_move
.a056	18		clc		                clc
.a057	a5 00		lda $00		                lda cp
.a059	75 00		adc $00,x	                adc 0,x
.a05b	85 00		sta $00		                sta cp
.a05d	a5 01		lda $01		                lda cp+1
.a05f	75 01		adc $01,x	                adc 1,x
.a061	85 01		sta $01		                sta cp+1
.a063	b5 02		lda $02,x	                lda 2,x
.a065	38		sec		                sec
.a066	e9 02		sbc #$02	                sbc #2
.a068	85 24		sta $24		                sta tmp1
.a06a	b5 03		lda $03,x	                lda 3,x
.a06c	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a06e	85 25		sta $25		                sta tmp1+1
.a070	a5 00		lda $00		                lda cp
.a072	92 24		sta ($24)	                sta (tmp1)
.a074	a0 01		ldy #$01	                ldy #1
.a076	a5 01		lda $01		                lda cp+1
.a078	91 24		sta ($24),y	                sta (tmp1),y
.a07a					sliteral_const_str:
.a07a	a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a07c	a9 94		lda #$94	                lda #<sliteral_runtime
.a07e	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.a081	b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a083	b5 02		lda $02,x	                lda 2,x                ; address LSB
.a085	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.a088	b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a08a	b5 00		lda $00,x	                lda 0,x                ; length LSB
.a08c	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.a08f	e8		inx		                inx
.a090	e8		inx		                inx
.a091	e8		inx		                inx
.a092	e8		inx		                inx
.a093	60		rts		z_sliteral:     rts
.a094					sliteral_runtime:
.a094	ca		dex		                dex
.a095	ca		dex		                dex
.a096	ca		dex		                dex
.a097	ca		dex		                dex
.a098	68		pla		                pla
.a099	85 24		sta $24		                sta tmp1        ; LSB of address
.a09b	68		pla		                pla
.a09c	85 25		sta $25		                sta tmp1+1      ; MSB of address
.a09e	a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a0a0	b1 24		lda ($24),y	                lda (tmp1),y
.a0a2	95 02		sta $02,x	                sta 2,x         ; LSB of address
.a0a4	c8		iny		                iny
.a0a5	b1 24		lda ($24),y	                lda (tmp1),y
.a0a7	95 03		sta $03,x	                sta 3,x         ; MSB of address
.a0a9	c8		iny		                iny
.a0aa	b1 24		lda ($24),y	                lda (tmp1),y
.a0ac	95 00		sta $00,x	                sta 0,x         ; LSB of length
.a0ae	c8		iny		                iny
.a0af	b1 24		lda ($24),y	                lda (tmp1),y
.a0b1	95 01		sta $01,x	                sta 1,x         ; MSB of length
.a0b3	18		clc		                clc
.a0b4	a5 24		lda $24		                lda tmp1
.a0b6	69 04		adc #$04	                adc #4
.a0b8	a8		tay		                tay             ; LSB
.a0b9	a5 25		lda $25		                lda tmp1+1
.a0bb	69 00		adc #$00	                adc #0          ; we only need carry
.a0bd	48		pha		                pha             ; MSB
.a0be	5a		phy		                phy
.a0bf	60		rts		                rts
.a0c0					xt_sm_slash_rem:
.a0c0	20 1e d8	jsr $d81e	                jsr underflow_3 ; contains double number
.a0c3	b5 03		lda $03,x	                lda 3,x
.a0c5	48		pha		                pha
.a0c6	b5 01		lda $01,x	                lda 1,x
.a0c8	55 03		eor $03,x	                eor 3,x
.a0ca	48		pha		                pha
.a0cb	20 39 81	jsr $8139	                jsr xt_abs
.a0ce	e8		inx		                inx             ; pretend we pushed n1 to R
.a0cf	e8		inx		                inx
.a0d0	20 80 8a	jsr $8a80	                jsr xt_dabs
.a0d3	ca		dex		                dex
.a0d4	ca		dex		                dex
.a0d5	20 9f a5	jsr $a59f	                jsr xt_um_slash_mod     ; UM/MOD
.a0d8	68		pla		                pla
.a0d9	10 03		bpl $a0de	                bpl +
.a0db	20 1d 96	jsr $961d	                jsr xt_negate
.a0de					+
.a0de	68		pla		                pla
.a0df	10 07		bpl $a0e8	                bpl _done
.a0e1	e8		inx		                inx             ; pretend we pushed quotient to R
.a0e2	e8		inx		                inx
.a0e3	20 1d 96	jsr $961d	                jsr xt_negate
.a0e6	ca		dex		                dex
.a0e7	ca		dex		                dex
.a0e8					_done:
.a0e8	60		rts		z_sm_slash_rem: rts
.a0e9					xt_source:
.a0e9	ca		dex		                dex
.a0ea	ca		dex		                dex
.a0eb	a5 08		lda $08		                lda cib
.a0ed	95 00		sta $00,x	                sta 0,x
.a0ef	a5 09		lda $09		                lda cib+1
.a0f1	95 01		sta $01,x	                sta 1,x
.a0f3	ca		dex		                dex
.a0f4	ca		dex		                dex
.a0f5	a5 0a		lda $0a		                lda ciblen
.a0f7	95 00		sta $00,x	                sta 0,x
.a0f9	a5 0b		lda $0b		                lda ciblen+1
.a0fb	95 01		sta $01,x	                sta 1,x
.a0fd	60		rts		z_source:       rts
.a0fe					xt_source_id:
.a0fe	ca		dex		                dex
.a0ff	ca		dex		                dex
.a100	a5 06		lda $06		                lda insrc
.a102	95 00		sta $00,x	                sta 0,x
.a104	a5 07		lda $07		                lda insrc+1
.a106	95 01		sta $01,x	                sta 1,x
.a108	60		rts		z_source_id:    rts
.a109					xt_space:
.a109	a9 20		lda #$20	                lda #AscSP
.a10b	20 f0 8d	jsr $8df0	                jsr emit_a
.a10e	60		rts		z_space:        rts
.a10f					xt_spaces:
.a10f	20 14 d8	jsr $d814	                jsr underflow_1
.a112	b5 00		lda $00,x	                lda 0,x
.a114	15 01		ora $01,x	                ora 1,x
.a116	f0 2a		beq $a142	                beq _done
.a118	b4 01		ldy $01,x	                ldy 1,x
.a11a	d0 0c		bne $a128	                bne _lots_of_spaces
.a11c	b4 00		ldy $00,x	                ldy 0,x
.a11e					_quick_loop:
.a11e	a9 20		lda #$20	                lda #AscSP
.a120	20 f0 8d	jsr $8df0	                jsr emit_a
.a123	88		dey		                dey
.a124	f0 1c		beq $a142	                beq _done
.a126	80 f6		bra $a11e	                bra _quick_loop
.a128					_lots_of_spaces:
.a128	b4 00		ldy $00,x	                ldy 0,x
.a12a					_first_slow_loop:
.a12a	f0 08		beq $a134	                beq _slow_outer_loop
.a12c	a9 20		lda #$20	                lda #AscSP
.a12e	20 f0 8d	jsr $8df0	                jsr emit_a
.a131	88		dey		                dey
.a132	80 f6		bra $a12a	                bra _first_slow_loop
.a134					_slow_outer_loop:
.a134	a0 00		ldy #$00	                ldy #00
.a136					_slow_inner_loop:
.a136	a9 20		lda #$20	                lda #AscSP
.a138	20 f0 8d	jsr $8df0	                jsr emit_a
.a13b	88		dey		                dey
.a13c	d0 f8		bne $a136	                bne _slow_inner_loop
.a13e	d6 01		dec $01,x	                dec 1,x
.a140	d0 f2		bne $a134	                bne _slow_outer_loop
.a142					_done:
.a142	e8		inx		                inx             ; drop
.a143	e8		inx		                inx
.a144	60		rts		z_spaces:       rts
.a145					xt_star:
.a145	20 19 d8	jsr $d819	                jsr underflow_2
.a148	20 e1 a5	jsr $a5e1	                jsr xt_um_star
.a14b	e8		inx		                inx
.a14c	e8		inx		                inx
.a14d	60		rts		z_star:         rts
.a14e					xt_star_slash:
.a14e	20 57 a1	jsr $a157	                jsr xt_star_slash_mod
.a151	20 93 a1	jsr $a193	                jsr xt_swap
.a154	e8		inx		                inx
.a155	e8		inx		                inx
.a156					z_star_slash:
.a156	60		rts		                rts
.a157					xt_star_slash_mod:
.a157	20 1e d8	jsr $d81e	                jsr underflow_3
.a15a	20 55 a3	jsr $a355	                jsr xt_to_r
.a15d	20 88 94	jsr $9488	                jsr xt_m_star
.a160	20 7d 9a	jsr $9a7d	                jsr xt_r_from
.a163	20 c0 a0	jsr $a0c0	                jsr xt_sm_slash_rem
.a166					z_star_slash_mod:
.a166	60		rts		                rts
.a167					xt_state:
.a167	ca		dex		                dex
.a168	ca		dex		                dex
.a169	a9 16		lda #$16	                lda #<state
.a16b	95 00		sta $00,x	                sta 0,x
.a16d	a9 00		lda #$00	                lda #>state
.a16f	95 01		sta $01,x	                sta 1,x
.a171	60		rts		z_state:        rts
.a172					xt_store:
.a172	20 19 d8	jsr $d819	                jsr underflow_2
.a175	b5 02		lda $02,x	                lda 2,x         ; LSB
.a177	81 00		sta ($00,x)	                sta (0,x)
.a179	f6 00		inc $00,x	                inc 0,x
.a17b	d0 02		bne $a17f	                bne +
.a17d	f6 01		inc $01,x	                inc 1,x
.a17f					+
.a17f	b5 03		lda $03,x	                lda 3,x         ; MSB
.a181	81 00		sta ($00,x)	                sta (0,x)
.a183	e8		inx		                inx             ; 2DROP
.a184	e8		inx		                inx
.a185	e8		inx		                inx
.a186	e8		inx		                inx
.a187	60		rts		z_store:        rts
.a188					xt_strip_underflow:
.a188	ca		dex		                dex
.a189	ca		dex		                dex
.a18a	a9 1c		lda #$1c	                lda #<uf_strip
.a18c	95 00		sta $00,x	                sta 0,x
.a18e	a9 00		lda #$00	                lda #>uf_strip
.a190	95 01		sta $01,x	                sta 1,x
.a192					z_strip_underflow:
.a192	60		rts		                rts
.a193					xt_swap:
.a193	20 19 d8	jsr $d819	                jsr underflow_2
.a196	b5 00		lda $00,x	                lda 0,x         ; LSB
.a198	b4 02		ldy $02,x	                ldy 2,x
.a19a	95 02		sta $02,x	                sta 2,x
.a19c	94 00		sty $00,x	                sty 0,x
.a19e	b5 01		lda $01,x	                lda 1,x         ; MSB
.a1a0	b4 03		ldy $03,x	                ldy 3,x
.a1a2	95 03		sta $03,x	                sta 3,x
.a1a4	94 01		sty $01,x	                sty 1,x
.a1a6	60		rts		z_swap:         rts
.a1a7					xt_then:
.a1a7	20 6c 91	jsr $916c	                jsr xt_here
.a1aa	20 93 a1	jsr $a193	                jsr xt_swap
.a1ad	20 72 a1	jsr $a172	                jsr xt_store
.a1b0	60		rts		z_then:         rts
.a1b1					xt_thru:
.a1b1	20 19 d8	jsr $d819	                jsr underflow_2
.a1b4	b5 01		lda $01,x	                lda 1,x
.a1b6	48		pha		                pha
.a1b7	b5 00		lda $00,x	                lda 0,x
.a1b9	48		pha		                pha
.a1ba	e8		inx		                inx
.a1bb	e8		inx		                inx
.a1bc					_thru_loop:
.a1bc	b5 01		lda $01,x	                lda 1,x
.a1be	48		pha		                pha
.a1bf	b5 00		lda $00,x	                lda 0,x
.a1c1	48		pha		                pha
.a1c2	20 b1 93	jsr $93b1	                jsr xt_load
.a1c5	68		pla		                pla
.a1c6	85 24		sta $24		                sta tmp1
.a1c8	68		pla		                pla
.a1c9	85 25		sta $25		                sta tmp1+1
.a1cb	68		pla		                pla
.a1cc	85 26		sta $26		                sta tmp2
.a1ce	68		pla		                pla
.a1cf	85 27		sta $27		                sta tmp2+1
.a1d1	c5 25		cmp $25		                cmp tmp1+1
.a1d3	d0 08		bne $a1dd	                bne _next_screen
.a1d5	a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a1d7	c5 24		cmp $24		                cmp tmp1
.a1d9	d0 02		bne $a1dd	                bne _next_screen
.a1db	80 18		bra $a1f5	                bra _done       ; We just did the last screen.
.a1dd					_next_screen:
.a1dd	a5 27		lda $27		                lda tmp2+1
.a1df	48		pha		                pha
.a1e0	a5 26		lda $26		                lda tmp2
.a1e2	48		pha		                pha
.a1e3	e6 24		inc $24		                inc tmp1
.a1e5	d0 02		bne $a1e9	                bne +
.a1e7	e6 25		inc $25		                inc tmp1+1
.a1e9					+
.a1e9	ca		dex		                dex
.a1ea	ca		dex		                dex
.a1eb	a5 24		lda $24		                lda tmp1
.a1ed	95 00		sta $00,x	                sta 0,x
.a1ef	a5 25		lda $25		                lda tmp1+1
.a1f1	95 01		sta $01,x	                sta 1,x
.a1f3	80 c7		bra $a1bc	                bra _thru_loop
.a1f5					_done:
.a1f5	60		rts		z_thru:         rts
.a1f6					xt_tick:
.a1f6	20 ca 98	jsr $98ca	                jsr xt_parse_name       ; ( -- addr u )
.a1f9	b5 00		lda $00,x	                lda 0,x
.a1fb	15 01		ora $01,x	                ora 1,x
.a1fd	d0 05		bne $a204	                bne +
.a1ff	a9 05		lda #$05	                lda #err_noname
.a201	4c 2a d8	jmp $d82a	                jmp error
.a204					+
.a204	20 d5 8f	jsr $8fd5	                jsr xt_find_name        ; ( addr u -- nt )
.a207	b5 00		lda $00,x	                lda 0,x
.a209	15 01		ora $01,x	                ora 1,x
.a20b	d0 05		bne $a212	                bne +
.a20d	a9 08		lda #$08	                lda #err_syntax
.a20f	4c 2a d8	jmp $d82a	                jmp error
.a212					+
.a212	20 db 95	jsr $95db	                jsr xt_name_to_int      ; ( nt -- xt )
.a215	60		rts		z_tick:         rts
.a216					xt_to:
.a216	20 f6 a1	jsr $a1f6	                jsr xt_tick             ; ( [n] xt )
.a219	b5 00		lda $00,x	                lda 0,x                 ; LSB
.a21b	18		clc		                clc
.a21c	69 03		adc #$03	                adc #3
.a21e	85 24		sta $24		                sta tmp1
.a220	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a222	69 00		adc #$00	                adc #0                  ; we just want the carry
.a224	85 25		sta $25		                sta tmp1+1
.a226	e8		inx		                inx
.a227	e8		inx		                inx                     ; ( [n] )
.a228	a5 16		lda $16		                lda state
.a22a	05 17		ora $17		                ora state+1
.a22c	f0 34		beq $a262	                beq _interpret
.a22e	a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a230	a9 b5		lda #$b5	                lda #$B5
.a232	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.a235	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a237	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.a23a	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a23c	a5 24		lda $24		                lda tmp1
.a23e	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.a241	a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a243	a9 b5		lda #$b5	                lda #$B5
.a245	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.a248	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a24a	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.a24d	e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a24f	d0 02		bne $a253	                bne +
.a251	e6 25		inc $25		                inc tmp1+1
.a253					+
.a253	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a255	a5 24		lda $24		                lda tmp1
.a257	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.a25a	a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a25c	98		tya		                tya
.a25d	20 c3 d6	jsr $d6c3	                jsr cmpl_word
.a260	80 0f		bra $a271	                bra _done
.a262					_interpret:
.a262	20 14 d8	jsr $d814	                jsr underflow_1
.a265	b5 00		lda $00,x	                lda 0,x
.a267	92 24		sta ($24)	                sta (tmp1)              ; LSB
.a269	a0 01		ldy #$01	                ldy #1
.a26b	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a26d	91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a26f	e8		inx		                inx                     ; DROP
.a270	e8		inx		                inx
.a271					_done:
.a271	60		rts		z_to:           rts
.a272					xt_to_body:
.a272	20 14 d8	jsr $d814	                jsr underflow_1
.a275	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( xt xt )
.a278	20 72 92	jsr $9272	                jsr xt_int_to_name      ; ( xt nt )
.a27b	f6 00		inc $00,x	                inc 0,x
.a27d	d0 02		bne $a281	                bne +
.a27f	f6 01		inc $01,x	                inc 1,x
.a281					+
.a281	a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a283	29 20		and #$20	                and #HC
.a285	f0 0d		beq $a294	                beq _no_cfa
.a287	18		clc		                clc
.a288	b5 02		lda $02,x	                lda 2,x         ; LSB
.a28a	69 03		adc #$03	                adc #3
.a28c	95 02		sta $02,x	                sta 2,x
.a28e	b5 03		lda $03,x	                lda 3,x         ; MSB
.a290	69 00		adc #$00	                adc #0          ; we conly care about the carry
.a292	95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a294					_no_cfa:
.a294	e8		inx		                inx             ; get rid of the nt
.a295	e8		inx		                inx
.a296					_done:
.a296	60		rts		z_to_body:      rts
.a297					xt_to_in:
.a297	ca		dex		                dex
.a298	ca		dex		                dex
.a299	a9 0c		lda #$0c	                lda #<toin
.a29b	95 00		sta $00,x	                sta 0,x
.a29d	a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a29f	95 01		sta $01,x	                sta 1,x
.a2a1	60		rts		z_to_in:        rts
.a2a2					xt_to_number:
.a2a2	20 23 d8	jsr $d823	                jsr underflow_4
.a2a5	b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a2a7	85 36		sta $36		                sta scratch
.a2a9	b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a2ab	85 37		sta $37		                sta scratch+1
.a2ad	b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a2af	85 38		sta $38		                sta scratch+2
.a2b1	b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a2b3	85 39		sta $39		                sta scratch+3
.a2b5	ca		dex		                dex
.a2b6	ca		dex		                dex
.a2b7					_loop:
.a2b7	a1 04		lda ($04,x)	                lda (4,x)
.a2b9	95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a2bb	74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2bd	20 ff 8a	jsr $8aff	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a2c0	b5 00		lda $00,x	                lda 0,x
.a2c2	d0 04		bne $a2c8	                bne _digit_ok
.a2c4	e8		inx		                inx
.a2c5	e8		inx		                inx
.a2c6	80 67		bra $a32f	                bra _done       ; ( ud-lo ud-hi addr u char )
.a2c8					_digit_ok:
.a2c8	b5 02		lda $02,x	                lda 2,x
.a2ca	85 3a		sta $3a		                sta scratch+4
.a2cc	b5 03		lda $03,x	                lda 3,x
.a2ce	85 3b		sta $3b		                sta scratch+5
.a2d0	a5 38		lda $38		                lda scratch+2
.a2d2	95 02		sta $02,x	                sta 2,x         ; NOS
.a2d4	a5 39		lda $39		                lda scratch+3
.a2d6	95 03		sta $03,x	                sta 3,x
.a2d8	a5 18		lda $18		                lda base
.a2da	95 00		sta $00,x	                sta 0,x         ; TOS
.a2dc	74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a2de	20 e1 a5	jsr $a5e1	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2e1	b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a2e3	85 3c		sta $3c		                sta scratch+6
.a2e5	b5 03		lda $03,x	                lda 3,x
.a2e7	85 3d		sta $3d		                sta scratch+7
.a2e9	a5 36		lda $36		                lda scratch
.a2eb	95 02		sta $02,x	                sta 2,x
.a2ed	a5 37		lda $37		                lda scratch+1
.a2ef	95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a2f1	a5 18		lda $18		                lda base
.a2f3	95 00		sta $00,x	                sta 0,x
.a2f5	74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a2f7	20 e1 a5	jsr $a5e1	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a2fa	b5 00		lda $00,x	                lda 0,x
.a2fc	85 38		sta $38		                sta scratch+2
.a2fe	b5 01		lda $01,x	                lda 1,x
.a300	85 39		sta $39		                sta scratch+3
.a302	b5 02		lda $02,x	                lda 2,x
.a304	85 36		sta $36		                sta scratch
.a306	b5 03		lda $03,x	                lda 3,x
.a308	85 37		sta $37		                sta scratch+1
.a30a	18		clc		                clc
.a30b	a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a30d	65 3a		adc $3a		                adc scratch+4   ; n LSB
.a30f	85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a311	a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a313	65 3b		adc $3b		                adc scratch+5   ; n MSB
.a315	85 37		sta $37		                sta scratch+1
.a317	a5 38		lda $38		                lda scratch+2   ; LSB
.a319	65 3c		adc $3c		                adc scratch+6
.a31b	85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a31d	a5 39		lda $39		                lda scratch+3   ; MSB
.a31f	65 3d		adc $3d		                adc scratch+7
.a321	85 39		sta $39		                sta scratch+3
.a323	e8		inx		                inx
.a324	e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a325	f6 04		inc $04,x	                inc 4,x
.a327	d0 02		bne $a32b	                bne +
.a329	f6 05		inc $05,x	                inc 5,x
.a32b					+
.a32b	d6 02		dec $02,x	                dec 2,x
.a32d	d0 88		bne $a2b7	                bne _loop
.a32f					_done:
.a32f	e8		inx		                inx
.a330	e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a331	a5 36		lda $36		                lda scratch     ; new ud-lo
.a333	95 06		sta $06,x	                sta 6,x
.a335	a5 37		lda $37		                lda scratch+1
.a337	95 07		sta $07,x	                sta 7,x
.a339	a5 38		lda $38		                lda scratch+2
.a33b	95 04		sta $04,x	                sta 4,x
.a33d	a5 39		lda $39		                lda scratch+3
.a33f	95 05		sta $05,x	                sta 5,x
.a341	60		rts		z_to_number:    rts
.a342					xt_to_order:
.a342	20 55 a3	jsr $a355	                jsr xt_to_r
.a345	20 2e 91	jsr $912e	                jsr xt_get_order
.a348	20 7d 9a	jsr $9a7d	                jsr xt_r_from
.a34b	20 93 a1	jsr $a193	                jsr xt_swap
.a34e	20 08 98	jsr $9808	                jsr xt_one_plus
.a351	20 06 9d	jsr $9d06	                jsr xt_set_order
.a354	60		rts		z_to_order:     rts
.a355					xt_to_r:
.a355	68		pla		                pla             ; LSB
.a356	85 2c		sta $2c		                sta tmptos
.a358	7a		ply		                ply             ; MSB
.a359	20 14 d8	jsr $d814	                jsr underflow_1
.a35c	b5 01		lda $01,x	                lda 1,x         ; MSB
.a35e	48		pha		                pha
.a35f	b5 00		lda $00,x	                lda 0,x         ; LSB
.a361	48		pha		                pha
.a362	e8		inx		                inx
.a363	e8		inx		                inx
.a364	5a		phy		                phy             ; MSB
.a365	a5 2c		lda $2c		                lda tmptos
.a367	48		pha		                pha             ; LSB
.a368	60		rts		z_to_r:         rts
.a369					xt_true:
.a369	ca		dex		                dex
.a36a	ca		dex		                dex
.a36b	a9 ff		lda #$ff	                lda #$FF
.a36d	95 00		sta $00,x	                sta 0,x
.a36f	95 01		sta $01,x	                sta 1,x
.a371	60		rts		z_true:         rts
.a372					xt_tuck:
.a372	20 19 d8	jsr $d819	                jsr underflow_2
.a375	ca		dex		                dex
.a376	ca		dex		                dex
.a377	b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a379	b5 02		lda $02,x	                lda 2,x
.a37b	95 04		sta $04,x	                sta 4,x
.a37d	94 02		sty $02,x	                sty 2,x
.a37f	95 00		sta $00,x	                sta 0,x
.a381	b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a383	b5 03		lda $03,x	                lda 3,x
.a385	95 05		sta $05,x	                sta 5,x
.a387	94 03		sty $03,x	                sty 3,x         ; bba
.a389	95 01		sta $01,x	                sta 1,x         ; baa
.a38b	60		rts		z_tuck:         rts
.a38c					xt_assembler_wordlist:
.a38c					xt_two:
.a38c	ca		dex		                dex
.a38d	ca		dex		                dex
.a38e	a9 02		lda #$02	                lda #2
.a390	95 00		sta $00,x	                sta 0,x
.a392	74 01		stz $01,x	                stz 1,x
.a394					z_assembler_wordlist:
.a394	60		rts		z_two:          rts
.a395					xt_two_drop:
.a395	20 19 d8	jsr $d819	                jsr underflow_2
.a398	e8		inx		                inx
.a399	e8		inx		                inx
.a39a	e8		inx		                inx
.a39b	e8		inx		                inx
.a39c	60		rts		z_two_drop:     rts
.a39d					xt_two_dup:
.a39d	20 19 d8	jsr $d819	                jsr underflow_2
.a3a0	ca		dex		                dex
.a3a1	ca		dex		                dex
.a3a2	ca		dex		                dex
.a3a3	ca		dex		                dex
.a3a4	b5 04		lda $04,x	                lda 4,x         ; TOS
.a3a6	95 00		sta $00,x	                sta 0,x
.a3a8	b5 05		lda $05,x	                lda 5,x
.a3aa	95 01		sta $01,x	                sta 1,x
.a3ac	b5 06		lda $06,x	                lda 6,x         ; NOS
.a3ae	95 02		sta $02,x	                sta 2,x
.a3b0	b5 07		lda $07,x	                lda 7,x
.a3b2	95 03		sta $03,x	                sta 3,x
.a3b4	60		rts		z_two_dup:      rts
.a3b5					xt_two_fetch:
.a3b5	20 14 d8	jsr $d814	                jsr underflow_1
.a3b8	b5 00		lda $00,x	                lda 0,x
.a3ba	85 24		sta $24		                sta tmp1
.a3bc	b4 01		ldy $01,x	                ldy 1,x
.a3be	84 25		sty $25		                sty tmp1+1
.a3c0	ca		dex		                dex             ; reuse one stack element
.a3c1	ca		dex		                dex
.a3c2	b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a3c4	95 00		sta $00,x	                sta 0,x
.a3c6	a0 01		ldy #$01	                ldy #1          ; copy next
.a3c8	b1 24		lda ($24),y	                lda (tmp1),y
.a3ca	95 01		sta $01,x	                sta 1,x
.a3cc	c8		iny		                iny             ; copy next
.a3cd	b1 24		lda ($24),y	                lda (tmp1),y
.a3cf	95 02		sta $02,x	                sta 2,x
.a3d1	c8		iny		                iny             ; copy next
.a3d2	b1 24		lda ($24),y	                lda (tmp1),y
.a3d4	95 03		sta $03,x	                sta 3,x
.a3d6	60		rts		z_two_fetch:    rts
.a3d7					xt_two_over:
.a3d7	20 23 d8	jsr $d823	                jsr underflow_4
.a3da	ca		dex		                dex
.a3db	ca		dex		                dex
.a3dc	ca		dex		                dex
.a3dd	ca		dex		                dex
.a3de	b5 08		lda $08,x	                lda 8,x
.a3e0	95 00		sta $00,x	                sta 0,x
.a3e2	b5 09		lda $09,x	                lda 9,x
.a3e4	95 01		sta $01,x	                sta 1,x
.a3e6	b5 0a		lda $0a,x	                lda 10,x
.a3e8	95 02		sta $02,x	                sta 2,x
.a3ea	b5 0b		lda $0b,x	                lda 11,x
.a3ec	95 03		sta $03,x	                sta 3,x
.a3ee	60		rts		z_two_over:     rts
.a3ef					xt_two_r_fetch:
.a3ef	ca		dex		                dex
.a3f0	ca		dex		                dex
.a3f1	ca		dex		                dex
.a3f2	ca		dex		                dex
.a3f3	8a		txa		                txa
.a3f4	ba		tsx		                tsx
.a3f5	da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a3f6	7a		ply		                ply
.a3f7	aa		tax		                tax
.a3f8	b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a3fb	95 00		sta $00,x	                sta 0,x
.a3fd	b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a400	95 01		sta $01,x	                sta 1,x
.a402	b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a405	95 02		sta $02,x	                sta 2,x
.a407	b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a40a	95 03		sta $03,x	                sta 3,x
.a40c	60		rts		z_two_r_fetch:  rts
.a40d					xt_two_r_from:
.a40d	68		pla		                pla                     ; LSB
.a40e	85 24		sta $24		                sta tmp1
.a410	68		pla		                pla                     ; MSB
.a411	85 25		sta $25		                sta tmp1+1
.a413	ca		dex		                dex
.a414	ca		dex		                dex
.a415	ca		dex		                dex
.a416	ca		dex		                dex
.a417	68		pla		                pla                     ; LSB
.a418	95 00		sta $00,x	                sta 0,x
.a41a	68		pla		                pla                     ; MSB
.a41b	95 01		sta $01,x	                sta 1,x
.a41d	68		pla		                pla                     ; LSB
.a41e	95 02		sta $02,x	                sta 2,x
.a420	68		pla		                pla                     ; MSB
.a421	95 03		sta $03,x	                sta 3,x
.a423	a5 25		lda $25		                lda tmp1+1              ; MSB
.a425	48		pha		                pha
.a426	a5 24		lda $24		                lda tmp1                ; LSB
.a428	48		pha		                pha
.a429	60		rts		z_two_r_from:   rts
.a42a					xt_two_slash:
.a42a	20 14 d8	jsr $d814	                jsr underflow_1
.a42d	b5 01		lda $01,x	                lda 1,x
.a42f	0a		asl a		                asl                     ; save the sign
.a430	76 01		ror $01,x	                ror 1,x
.a432	76 00		ror $00,x	                ror 0,x
.a434	60		rts		z_two_slash:    rts
.a435					xt_two_star:
.a435					xt_cells:
.a435	20 14 d8	jsr $d814	                jsr underflow_1
.a438	16 00		asl $00,x	                asl 0,x
.a43a	36 01		rol $01,x	                rol 1,x
.a43c					z_cells:
.a43c	60		rts		z_two_star:     rts
.a43d					xt_two_store:
.a43d	20 1e d8	jsr $d81e	                jsr underflow_3
.a440	b5 00		lda $00,x	                lda 0,x
.a442	85 24		sta $24		                sta tmp1
.a444	b4 01		ldy $01,x	                ldy 1,x
.a446	84 25		sty $25		                sty tmp1+1
.a448	e8		inx		                inx
.a449	e8		inx		                inx
.a44a	b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a44c	92 24		sta ($24)	                sta (tmp1)
.a44e	b5 01		lda $01,x	                lda 1,x         ; copy next
.a450	a0 01		ldy #$01	                ldy #1
.a452	91 24		sta ($24),y	                sta (tmp1),y
.a454	b5 02		lda $02,x	                lda 2,x         ; copy next
.a456	c8		iny		                iny
.a457	91 24		sta ($24),y	                sta (tmp1),y
.a459	b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a45b	c8		iny		                iny
.a45c	91 24		sta ($24),y	                sta (tmp1),y
.a45e	e8		inx		                inx             ; 2DROP
.a45f	e8		inx		                inx
.a460	e8		inx		                inx
.a461	e8		inx		                inx
.a462	60		rts		z_two_store:    rts
.a463					xt_two_swap:
.a463	20 23 d8	jsr $d823	                jsr underflow_4
.a466	b5 00		lda $00,x	                lda 0,x
.a468	b4 04		ldy $04,x	                ldy 4,x
.a46a	95 04		sta $04,x	                sta 4,x
.a46c	94 00		sty $00,x	                sty 0,x
.a46e	b5 01		lda $01,x	                lda 1,x
.a470	b4 05		ldy $05,x	                ldy 5,x
.a472	95 05		sta $05,x	                sta 5,x
.a474	94 01		sty $01,x	                sty 1,x
.a476	b5 02		lda $02,x	                lda 2,x
.a478	b4 06		ldy $06,x	                ldy 6,x
.a47a	95 06		sta $06,x	                sta 6,x
.a47c	94 02		sty $02,x	                sty 2,x
.a47e	b5 03		lda $03,x	                lda 3,x
.a480	b4 07		ldy $07,x	                ldy 7,x
.a482	95 07		sta $07,x	                sta 7,x
.a484	94 03		sty $03,x	                sty 3,x
.a486	60		rts		z_two_swap:     rts
.a487					xt_two_to_r:
.a487	68		pla		                pla             ; LSB
.a488	85 24		sta $24		                sta tmp1
.a48a	68		pla		                pla             ; MSB
.a48b	85 25		sta $25		                sta tmp1+1
.a48d	20 19 d8	jsr $d819	                jsr underflow_2
.a490	b5 03		lda $03,x	                lda 3,x         ; MSB
.a492	48		pha		                pha
.a493	b5 02		lda $02,x	                lda 2,x         ; LSB
.a495	48		pha		                pha
.a496	b5 01		lda $01,x	                lda 1,x         ; MSB
.a498	48		pha		                pha
.a499	b5 00		lda $00,x	                lda 0,x         ; LSB
.a49b	48		pha		                pha
.a49c	e8		inx		                inx
.a49d	e8		inx		                inx
.a49e	e8		inx		                inx
.a49f	e8		inx		                inx
.a4a0	a5 25		lda $25		                lda tmp1+1      ; MSB
.a4a2	48		pha		                pha
.a4a3	a5 24		lda $24		                lda tmp1        ; LSB
.a4a5	48		pha		                pha
.a4a6	60		rts		z_two_to_r:     rts
.a4a7					xt_two_constant:
.a4a7	20 19 d8	jsr $d819	                jsr underflow_2
.a4aa	20 63 89	jsr $8963	                jsr xt_create
.a4ad	20 93 a1	jsr $a193	                jsr xt_swap
.a4b0	20 68 87	jsr $8768	                jsr xt_comma
.a4b3	20 68 87	jsr $8768	                jsr xt_comma
.a4b6	20 fe 8b	jsr $8bfe	                jsr does_runtime    ; does> turns into these two routines.
.a4b9	20 fd d6	jsr $d6fd	                jsr dodoes
.a4bc	20 a9 8d	jsr $8da9	                jsr xt_dup
.a4bf	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.a4c2	20 93 a1	jsr $a193	                jsr xt_swap
.a4c5	20 1b 86	jsr $861b	                jsr xt_cell_plus
.a4c8	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.a4cb	60		rts		z_two_constant: rts
.a4cc					xt_two_literal:
.a4cc	20 19 d8	jsr $d819	                jsr underflow_2 ; double number
.a4cf	20 93 a1	jsr $a193	                jsr xt_swap
.a4d2	20 84 93	jsr $9384	                jsr xt_literal
.a4d5	20 84 93	jsr $9384	                jsr xt_literal
.a4d8	60		rts		z_two_literal:  rts
.a4d9					xt_two_variable:
.a4d9	20 63 89	jsr $8963	                jsr xt_create
.a4dc	ca		dex		                dex
.a4dd	ca		dex		                dex
.a4de	a9 04		lda #$04	                lda #4
.a4e0	95 00		sta $00,x	                sta 0,x
.a4e2	74 01		stz $01,x	                stz 1,x
.a4e4	20 ab 82	jsr $82ab	                jsr xt_allot
.a4e7	60		rts		z_two_variable: rts
.a4e8					xt_type:
.a4e8	20 19 d8	jsr $d819	                jsr underflow_2
.a4eb	b5 02		lda $02,x	                lda 2,x
.a4ed	85 24		sta $24		                sta tmp1
.a4ef	b5 03		lda $03,x	                lda 3,x
.a4f1	85 25		sta $25		                sta tmp1+1
.a4f3					_loop:
.a4f3	b5 00		lda $00,x	                lda 0,x
.a4f5	15 01		ora $01,x	                ora 1,x
.a4f7	f0 15		beq $a50e	                beq _done
.a4f9	b2 24		lda ($24)	                lda (tmp1)
.a4fb	20 f0 8d	jsr $8df0	                jsr emit_a      ; avoids stack foolery
.a4fe	e6 24		inc $24		                inc tmp1
.a500	d0 02		bne $a504	                bne +
.a502	e6 25		inc $25		                inc tmp1+1
.a504					+
.a504	b5 00		lda $00,x	                lda 0,x
.a506	d0 02		bne $a50a	                bne +
.a508	d6 01		dec $01,x	                dec 1,x
.a50a					+
.a50a	d6 00		dec $00,x	                dec 0,x
.a50c	80 e5		bra $a4f3	                bra _loop
.a50e					_done:
.a50e	e8		inx		                inx
.a50f	e8		inx		                inx
.a510	e8		inx		                inx
.a511	e8		inx		                inx
.a512	60		rts		z_type:         rts
.a513					xt_u_dot:
.a513	20 14 d8	jsr $d814	                jsr underflow_1
.a516	20 60 d8	jsr $d860	                jsr print_u
.a519	a9 20		lda #$20	                lda #AscSP
.a51b	20 f0 8d	jsr $8df0	                jsr emit_a
.a51e	60		rts		z_u_dot:        rts
.a51f					xt_u_dot_r:
.a51f	20 19 d8	jsr $d819	                jsr underflow_2
.a522	20 55 a3	jsr $a355	                jsr xt_to_r
.a525	20 8d a7	jsr $a78d	                jsr xt_zero
.a528	20 54 93	jsr $9354	                jsr xt_less_number_sign
.a52b	20 c9 97	jsr $97c9	                jsr xt_number_sign_s
.a52e	20 a7 97	jsr $97a7	                jsr xt_number_sign_greater
.a531	20 7d 9a	jsr $9a7d	                jsr xt_r_from
.a534	20 7e 98	jsr $987e	                jsr xt_over
.a537	20 4a 95	jsr $954a	                jsr xt_minus
.a53a	20 0f a1	jsr $a10f	                jsr xt_spaces
.a53d	20 e8 a4	jsr $a4e8	                jsr xt_type
.a540	60		rts		z_u_dot_r:      rts
.a541					xt_u_greater_than:
.a541	20 19 d8	jsr $d819	                jsr underflow_2
.a544	b5 00		lda $00,x	                lda 0,x
.a546	d5 02		cmp $02,x	                cmp 2,x
.a548	b5 01		lda $01,x	                lda 1,x
.a54a	f5 03		sbc $03,x	                sbc 3,x
.a54c	e8		inx		                inx
.a54d	e8		inx		                inx
.a54e	a9 00		lda #$00	                lda #0
.a550	69 ff		adc #$ff	                adc #$ff
.a552	95 00		sta $00,x	                sta 0,x         ; store flag
.a554	95 01		sta $01,x	                sta 1,x
.a556	60		rts		z_u_greater_than:    rts
.a557					xt_u_less_than:
.a557	20 19 d8	jsr $d819	                jsr underflow_2
.a55a	b5 02		lda $02,x	                lda 2,x
.a55c	d5 00		cmp $00,x	                cmp 0,x
.a55e	b5 03		lda $03,x	                lda 3,x
.a560	f5 01		sbc $01,x	                sbc 1,x
.a562	e8		inx		                inx
.a563	e8		inx		                inx
.a564	a9 00		lda #$00	                lda #0
.a566	69 ff		adc #$ff	                adc #$ff
.a568	95 00		sta $00,x	                sta 0,x         ; store flag
.a56a	95 01		sta $01,x	                sta 1,x
.a56c	60		rts		z_u_less_than:    rts
.a56d					xt_ud_dot:
.a56d	20 19 d8	jsr $d819	                jsr underflow_2 ; double number
.a570	20 54 93	jsr $9354	                jsr xt_less_number_sign
.a573	20 c9 97	jsr $97c9	                jsr xt_number_sign_s
.a576	20 a7 97	jsr $97a7	                jsr xt_number_sign_greater
.a579	20 e8 a4	jsr $a4e8	                jsr xt_type
.a57c	20 09 a1	jsr $a109	                jsr xt_space
.a57f	60		rts		z_ud_dot:        rts
.a580					xt_ud_dot_r:
.a580	20 1e d8	jsr $d81e	                jsr underflow_3
.a583	20 55 a3	jsr $a355	                jsr xt_to_r
.a586	20 54 93	jsr $9354	                jsr xt_less_number_sign
.a589	20 c9 97	jsr $97c9	                jsr xt_number_sign_s
.a58c	20 a7 97	jsr $97a7	                jsr xt_number_sign_greater
.a58f	20 7d 9a	jsr $9a7d	                jsr xt_r_from
.a592	20 7e 98	jsr $987e	                jsr xt_over
.a595	20 4a 95	jsr $954a	                jsr xt_minus
.a598	20 0f a1	jsr $a10f	                jsr xt_spaces
.a59b	20 e8 a4	jsr $a4e8	                jsr xt_type
.a59e	60		rts		z_ud_dot_r:      rts
.a59f					xt_um_slash_mod:
.a59f	20 1e d8	jsr $d81e	                jsr underflow_3
.a5a2	b5 00		lda $00,x	                lda 0,x
.a5a4	15 01		ora $01,x	                ora 1,x
.a5a6	d0 05		bne $a5ad	                bne _not_zero
.a5a8	a9 04		lda #$04	                lda #err_divzero
.a5aa	4c 2a d8	jmp $d82a	                jmp error
.a5ad					_not_zero:
.a5ad	a9 11		lda #$11	                lda #17
.a5af	85 2c		sta $2c		                sta tmptos
.a5b1					_loop:
.a5b1	36 04		rol $04,x	                rol 4,x
.a5b3	36 05		rol $05,x	                rol 5,x
.a5b5	c6 2c		dec $2c		                dec tmptos
.a5b7	f0 22		beq $a5db	                beq _done
.a5b9	36 02		rol $02,x	                rol 2,x
.a5bb	36 03		rol $03,x	                rol 3,x
.a5bd	64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a5bf	26 24		rol $24		                rol tmp1
.a5c1	38		sec		                sec
.a5c2	b5 02		lda $02,x	                lda 2,x
.a5c4	f5 00		sbc $00,x	                sbc 0,x
.a5c6	85 25		sta $25		                sta tmp1+1
.a5c8	b5 03		lda $03,x	                lda 3,x
.a5ca	f5 01		sbc $01,x	                sbc 1,x
.a5cc	a8		tay		                tay
.a5cd	a5 24		lda $24		                lda tmp1
.a5cf	e9 00		sbc #$00	                sbc #0
.a5d1	90 de		bcc $a5b1	                bcc _loop
.a5d3	a5 25		lda $25		                lda tmp1+1
.a5d5	95 02		sta $02,x	                sta 2,x
.a5d7	94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a5d9	80 d6		bra $a5b1	                bra _loop
.a5db					_done:
.a5db	e8		inx		                inx
.a5dc	e8		inx		                inx
.a5dd	20 93 a1	jsr $a193	                jsr xt_swap
.a5e0	60		rts		z_um_slash_mod: rts
.a5e1					xt_um_star:
.a5e1	20 19 d8	jsr $d819	                jsr underflow_2
.a5e4	18		clc		                clc
.a5e5	b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a5e7	e9 00		sbc #$00	                sbc #0
.a5e9	85 26		sta $26		                sta tmp2
.a5eb	b5 01		lda $01,x	                lda 1,x
.a5ed	e9 00		sbc #$00	                sbc #0
.a5ef	90 31		bcc $a622	                bcc _zero       ; is TOS zero?
.a5f1	85 27		sta $27		                sta tmp2+1
.a5f3	a9 00		lda #$00	                lda #0
.a5f5	85 24		sta $24		                sta tmp1
.a5f7	86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a5f9	ca		dex		                dex
.a5fa	ca		dex		                dex
.a5fb					_outer_loop:
.a5fb	a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a5fd	56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a5ff					_inner_loop:
.a5ff	90 0c		bcc $a60d	                bcc _no_add
.a601	85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a603	a5 24		lda $24		                lda tmp1
.a605	65 26		adc $26		                adc tmp2
.a607	85 24		sta $24		                sta tmp1
.a609	a5 25		lda $25		                lda tmp1+1
.a60b	65 27		adc $27		                adc tmp2+1
.a60d					_no_add:
.a60d	6a		ror a		                ror
.a60e	66 24		ror $24		                ror tmp1
.a610	76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a612	88		dey		                dey
.a613	d0 ea		bne $a5ff	                bne _inner_loop ; go back for one more shift?
.a615	e8		inx		                inx
.a616	e4 28		cpx $28		                cpx tmp3
.a618	d0 e1		bne $a5fb	                bne _outer_loop ; go back for eight more shifts?
.a61a	95 01		sta $01,x	                sta 1,x
.a61c	a5 24		lda $24		                lda tmp1
.a61e	95 00		sta $00,x	                sta 0,x
.a620	80 04		bra $a626	                bra _done
.a622					_zero:
.a622	74 02		stz $02,x	                stz 2,x
.a624	74 03		stz $03,x	                stz 3,x
.a626					_done:
.a626	60		rts		z_um_star:      rts
.a627					xt_unloop:
.a627	68		pla		                pla
.a628	68		pla		                pla
.a629	68		pla		                pla
.a62a	68		pla		                pla
.a62b	68		pla		                pla
.a62c	68		pla		                pla
.a62d	60		rts		z_unloop:       rts
.a62e					xt_until:
.a62e	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a630	a9 0e		lda #$0e	                lda #<zero_branch_runtime
.a632	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.a635	20 68 87	jsr $8768	                jsr xt_comma
.a638	60		rts		z_until:        rts
.a639					xt_unused:
.a639	ca		dex		                dex
.a63a	ca		dex		                dex
.a63b	a9 00		lda #$00	                lda #<cp_end
.a63d	38		sec		                sec
.a63e	e5 00		sbc $00		                sbc cp
.a640	95 00		sta $00,x	                sta 0,x
.a642	a9 7c		lda #$7c	                lda #>cp_end
.a644	e5 01		sbc $01		                sbc cp+1
.a646	95 01		sta $01,x	                sta 1,x
.a648	60		rts		z_unused:       rts
.a649					xt_update:
.a649	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a64b	b1 1e		lda ($1e),y	                lda (up),y
.a64d	09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a64f	91 1e		sta ($1e),y	                sta (up),y
.a651	60		rts		z_update:       rts
.a652					xt_useraddr:
.a652	ca		dex		                dex
.a653	ca		dex		                dex
.a654	a9 1e		lda #$1e	                lda #<up
.a656	95 00		sta $00,x	                sta 0,x
.a658	a9 00		lda #$00	                lda #>up
.a65a	95 01		sta $01,x	                sta 1,x
.a65c	60		rts		z_useraddr:     rts
.a65d					xt_variable:
.a65d	20 63 89	jsr $8963	                jsr xt_create
.a660	a9 00		lda #$00	                lda #0
.a662	92 00		sta ($00)	                sta (cp)
.a664	e6 00		inc $00		                inc cp
.a666	d0 02		bne $a66a	                bne +
.a668	e6 01		inc $01		                inc cp+1
.a66a					+
.a66a	92 00		sta ($00)	                sta (cp)
.a66c	e6 00		inc $00		                inc cp
.a66e	d0 02		bne $a672	                bne +
.a670	e6 01		inc $01		                inc cp+1
.a672					+
.a672	20 2b 89	jsr $892b	                jsr adjust_z
.a675	60		rts		z_variable:     rts
.a676					xt_while:
.a676	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a678	a9 0e		lda #$0e	                lda #<zero_branch_runtime
.a67a	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.a67d	20 6c 91	jsr $916c	                jsr xt_here
.a680	20 8d a7	jsr $a78d	                jsr xt_zero
.a683	20 68 87	jsr $8768	                jsr xt_comma
.a686	20 93 a1	jsr $a193	                jsr xt_swap
.a689	60		rts		z_while:        rts
.a68a					xt_within:
.a68a	20 1e d8	jsr $d81e	                jsr underflow_3
.a68d	20 7e 98	jsr $987e	                jsr xt_over
.a690	20 4a 95	jsr $954a	                jsr xt_minus
.a693	20 55 a3	jsr $a355	                jsr xt_to_r
.a696	20 4a 95	jsr $954a	                jsr xt_minus
.a699	20 7d 9a	jsr $9a7d	                jsr xt_r_from
.a69c	20 57 a5	jsr $a557	                jsr xt_u_less_than
.a69f	60		rts		z_within:       rts
.a6a0					xt_word:
.a6a0	20 14 d8	jsr $d814	                jsr underflow_1
.a6a3	a4 0c		ldy $0c		                ldy toin                ; >IN
.a6a5					_loop:
.a6a5	c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a6a7	f0 09		beq $a6b2	                beq _found_char
.a6a9	b1 08		lda ($08),y	                lda (cib),y
.a6ab	d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a6ad	d0 03		bne $a6b2	                bne _found_char
.a6af	c8		iny		                iny
.a6b0	80 f3		bra $a6a5	                bra _loop
.a6b2					_found_char:
.a6b2	84 0c		sty $0c		                sty toin
.a6b4	20 25 99	jsr $9925	                jsr xt_parse            ; Returns ( addr u )
.a6b7	b5 00		lda $00,x	                lda 0,x
.a6b9	92 00		sta ($00)	                sta (cp)                ; Save length of string
.a6bb	48		pha		                pha                     ; Keep copy of length for later
.a6bc	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( addr u u )
.a6bf	a5 00		lda $00		                lda cp
.a6c1	18		clc		                clc
.a6c2	69 01		adc #$01	                adc #1
.a6c4	95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a6c6	a5 01		lda $01		                lda cp+1
.a6c8	69 00		adc #$00	                adc #0
.a6ca	95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a6cc	20 bc 95	jsr $95bc	                jsr xt_move
.a6cf	ca		dex		                dex
.a6d0	ca		dex		                dex
.a6d1	a5 00		lda $00		                lda cp
.a6d3	95 00		sta $00,x	                sta 0,x
.a6d5	a5 01		lda $01		                lda cp+1
.a6d7	95 01		sta $01,x	                sta 1,x
.a6d9	68		pla		                pla                     ; length of string
.a6da	18		clc		                clc
.a6db	65 00		adc $00		                adc cp
.a6dd	85 00		sta $00		                sta cp
.a6df	a5 01		lda $01		                lda cp+1
.a6e1	69 00		adc #$00	                adc #0                  ; we only need the carry
.a6e3	85 01		sta $01		                sta cp+1
.a6e5	60		rts		z_word:         rts
.a6e6					xt_wordlist:
.a6e6	a0 05		ldy #$05	                ldy #num_wordlists_offset
.a6e8	b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a6ea	c9 0c		cmp #$0c	                cmp #max_wordlists
.a6ec	d0 05		bne $a6f3	                bne _ok
.a6ee	a9 0b		lda #$0b	                lda #err_wordlist
.a6f0	4c 2a d8	jmp $d82a	                jmp error
.a6f3					_ok:
.a6f3	1a		inc a		                ina             ; Increment the wordlist#
.a6f4	91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a6f6	ca		dex		                dex             ; and put it on the stack.
.a6f7	ca		dex		                dex
.a6f8	95 00		sta $00,x	                sta 0,x
.a6fa	74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a6fc	60		rts		z_wordlist:     rts
.a6fd					xt_words:
.a6fd	20 5d 89	jsr $895d	                jsr xt_cr
.a700	a9 00		lda #$00	                lda #0
.a702	48		pha		                pha
.a703	ca		dex		                dex                     ; Make room on the stack for
.a704	ca		dex		                dex                     ; a dictionary pointer.
.a705	64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a707					_wordlist_loop:
.a707	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a709	a5 28		lda $28		                lda tmp3
.a70b	d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a70d	d0 02		bne $a711	                bne _have_wordlist
.a70f	80 45		bra $a756	                bra _words_done
.a711					_have_wordlist:
.a711	18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a712	69 1f		adc #$1f	                adc #search_order_offset
.a714	a8		tay		                tay
.a715	b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a717	0a		asl a		                asl                     ; Turn offset into cells offset.
.a718	18		clc		                clc
.a719	69 06		adc #$06	                adc #wordlists_offset
.a71b	a8		tay		                tay
.a71c	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a71e	95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a720	c8		iny		                iny
.a721	b1 1e		lda ($1e),y	                lda (up),y
.a723	95 01		sta $01,x	                sta 1,x
.a725					_loop:
.a725	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( nt nt )
.a728	20 f8 95	jsr $95f8	                jsr xt_name_to_string   ; ( nt addr u )
.a72b	68		pla		                pla
.a72c	18		clc		                clc
.a72d	75 00		adc $00,x	                adc 0,x
.a72f	1a		inc a		                ina                     ; don't forget the space between words
.a730	c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a732	90 06		bcc $a73a	                bcc +
.a734	20 5d 89	jsr $895d	                jsr xt_cr
.a737	b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a739	1a		inc a		                ina                     ; with length of this word.
.a73a					+
.a73a	48		pha		                pha
.a73b	20 e8 a4	jsr $a4e8	                jsr xt_type             ; ( nt )
.a73e	a9 20		lda #$20	                lda #AscSP
.a740	20 f0 8d	jsr $8df0	                jsr emit_a
.a743	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+
.a746	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+
.a749	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; @ ( nt+1 )
.a74c	b5 00		lda $00,x	                lda 0,x
.a74e	15 01		ora $01,x	                ora 1,x
.a750	d0 d3		bne $a725	                bne _loop
.a752	e6 28		inc $28		                inc tmp3
.a754	80 b1		bra $a707	                bra _wordlist_loop
.a756					_words_done:
.a756	68		pla		                pla                     ; dump counter
.a757	e8		inx		                inx
.a758	e8		inx		                inx
.a759	60		rts		z_words:        rts
.a75a					xt_wordsize:
.a75a	20 14 d8	jsr $d814	                jsr underflow_1
.a75d	b5 00		lda $00,x	                lda 0,x
.a75f	85 24		sta $24		                sta tmp1
.a761	b5 01		lda $01,x	                lda 1,x
.a763	85 25		sta $25		                sta tmp1+1
.a765	a0 06		ldy #$06	                ldy #6
.a767	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a769	88		dey		                dey
.a76a	88		dey		                dey
.a76b	38		sec		                sec
.a76c	f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a76e	95 00		sta $00,x	                sta 0,x
.a770	a0 07		ldy #$07	                ldy #7
.a772	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a774	88		dey		                dey
.a775	88		dey		                dey
.a776	f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a778	95 01		sta $01,x	                sta 1,x
.a77a	60		rts		z_wordsize:     rts
.a77b					xt_xor:
.a77b	20 19 d8	jsr $d819	                jsr underflow_2
.a77e	b5 00		lda $00,x	                lda 0,x
.a780	55 02		eor $02,x	                eor 2,x
.a782	95 02		sta $02,x	                sta 2,x
.a784	b5 01		lda $01,x	                lda 1,x
.a786	55 03		eor $03,x	                eor 3,x
.a788	95 03		sta $03,x	                sta 3,x
.a78a	e8		inx		                inx
.a78b	e8		inx		                inx
.a78c	60		rts		z_xor:          rts
.a78d					xt_case:
.a78d					xt_forth_wordlist:
.a78d					xt_zero:
.a78d	ca		dex		                dex             ; push
.a78e	ca		dex		                dex
.a78f	74 00		stz $00,x	                stz 0,x
.a791	74 01		stz $01,x	                stz 1,x
.a793					z_case:
.a793					z_forth_wordlist:
.a793					z_zero:
.a793	60		rts		                rts
.a794					xt_zero_equal:
.a794	20 14 d8	jsr $d814	                jsr underflow_1
.a797	b5 00		lda $00,x	                lda 0,x
.a799	15 01		ora $01,x	                ora 1,x
.a79b	f0 04		beq $a7a1	                beq _zero
.a79d	a9 00		lda #$00	                lda #0
.a79f	80 02		bra $a7a3	                bra _store
.a7a1					_zero:
.a7a1	a9 ff		lda #$ff	                lda #$ff
.a7a3					_store:
.a7a3	95 00		sta $00,x	                sta 0,x
.a7a5	95 01		sta $01,x	                sta 1,x
.a7a7	60		rts		z_zero_equal:   rts
.a7a8					xt_zero_greater:
.a7a8	20 14 d8	jsr $d814	                jsr underflow_1
.a7ab	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a7ad	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7af	30 05		bmi $a7b6	                bmi _done       ; TOS is negative, keep FLASE
.a7b1	15 00		ora $00,x	                ora 0,x
.a7b3	f0 01		beq $a7b6	                beq _done       ; TOS is zero, keep FALSE
.a7b5	88		dey		                dey             ; TOS is postive, make true
.a7b6					_done:
.a7b6	98		tya		                tya
.a7b7	95 00		sta $00,x	                sta 0,x
.a7b9	95 01		sta $01,x	                sta 1,x
.a7bb	60		rts		z_zero_greater: rts
.a7bc					xt_zero_less:
.a7bc	20 14 d8	jsr $d814	                jsr underflow_1
.a7bf	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a7c1	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7c3	10 01		bpl $a7c6	                bpl _done       ; TOS is positive, so keep FALSE
.a7c5	88		dey		                dey             ; TOS is negative, make TRUE
.a7c6					_done:
.a7c6	98		tya		                tya
.a7c7	95 00		sta $00,x	                sta 0,x
.a7c9	95 01		sta $01,x	                sta 1,x
.a7cb	60		rts		z_zero_less:    rts
.a7cc					xt_zero_unequal:
.a7cc	20 14 d8	jsr $d814	                jsr underflow_1
.a7cf	a0 00		ldy #$00	                ldy #0          ; default false
.a7d1	b5 00		lda $00,x	                lda 0,x
.a7d3	15 01		ora $01,x	                ora 1,x
.a7d5	f0 01		beq $a7d8	                beq _got_zero
.a7d7	88		dey		                dey
.a7d8					_got_zero:
.a7d8	98		tya		                tya
.a7d9	95 00		sta $00,x	                sta 0,x
.a7db	95 01		sta $01,x	                sta 1,x
.a7dd	60		rts		z_zero_unequal: rts
.a7de					xt_editor_screen_helper:
.a7de	20 a9 8d	jsr $8da9	                jsr xt_dup
.a7e1	20 c4 9e	jsr $9ec4	                jsr xt_scr
.a7e4	20 72 a1	jsr $a172	                jsr xt_store
.a7e7	20 af 85	jsr $85af	                jsr xt_buffer
.a7ea					z_editor_screen_helper:
.a7ea	60		rts		                rts
.a7eb					xt_editor_enter_screen:
.a7eb	20 de a7	jsr $a7de	                jsr xt_editor_screen_helper
.a7ee	20 28 8d	jsr $8d28	                jsr xt_drop
.a7f1	64 2e		stz $2e		                stz editor1
.a7f3					_prompt_loop:
.a7f3	ca		dex		                dex
.a7f4	ca		dex		                dex
.a7f5	a5 2e		lda $2e		                lda editor1
.a7f7	95 00		sta $00,x	                sta 0,x
.a7f9	74 01		stz $01,x	                stz 1,x
.a7fb	20 c0 a8	jsr $a8c0	                jsr xt_editor_o
.a7fe	e6 2e		inc $2e		                inc editor1
.a800	a9 10		lda #$10	                lda #16
.a802	c5 2e		cmp $2e		                cmp editor1
.a804	d0 ed		bne $a7f3	                bne _prompt_loop
.a806					z_editor_enter_screen:
.a806	60		rts		                rts
.a807					xt_editor_erase_screen:
.a807	20 de a7	jsr $a7de	                jsr xt_editor_screen_helper
.a80a	ca		dex		                dex
.a80b	ca		dex		                dex
.a80c	74 00		stz $00,x	                stz 0,x
.a80e	a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a810	95 01		sta $01,x	                sta 1,x
.a812	20 e4 8e	jsr $8ee4	                jsr xt_blank
.a815	20 49 a6	jsr $a649	                jsr xt_update
.a818					z_editor_erase_screen:
.a818	60		rts		                rts
.a819					xt_editor_el:
.a819	20 a7 a8	jsr $a8a7	                jsr xt_editor_line
.a81c	ca		dex		                dex
.a81d	ca		dex		                dex
.a81e	a9 40		lda #$40	                lda #64
.a820	95 00		sta $00,x	                sta 0,x
.a822	74 01		stz $01,x	                stz 1,x
.a824	20 e4 8e	jsr $8ee4	                jsr xt_blank
.a827	20 49 a6	jsr $a649	                jsr xt_update
.a82a	60		rts		z_editor_el:    rts
.a82b					xt_editor_l:
.a82b	ca		dex		                dex             ; Put SCR on the stack.
.a82c	ca		dex		                dex
.a82d	a0 02		ldy #$02	                ldy #scr_offset
.a82f	b1 1e		lda ($1e),y	                lda (up),y
.a831	95 00		sta $00,x	                sta 0,x
.a833	c8		iny		                iny
.a834	b1 1e		lda ($1e),y	                lda (up),y
.a836	95 01		sta $01,x	                sta 1,x
.a838	20 bb 83	jsr $83bb	                jsr xt_block    ; Get the current screen.
.a83b	20 5d 89	jsr $895d	                jsr xt_cr
.a83e	80 08		bra $a848	                bra _after_screen_msg
.a840					_screen_msg:
>a840	53 63 72 65 65 6e 20 23		                .text "Screen #"
.a848					_after_screen_msg:
.a848	20 94 a0	jsr $a094	                jsr sliteral_runtime
>a84b	40 a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a84f	20 e8 a4	jsr $a4e8	                jsr xt_type
.a852	20 c4 9e	jsr $9ec4	                jsr xt_scr
.a855	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.a858	ca		dex		                dex
.a859	ca		dex		                dex
.a85a	a9 04		lda #$04	                lda #4          ; four spaces
.a85c	95 00		sta $00,x	                sta 0,x
.a85e	74 01		stz $01,x	                stz 1,x
.a860	20 1f a5	jsr $a51f	                jsr xt_u_dot_r
.a863	64 28		stz $28		                stz tmp3
.a865					_line_loop:
.a865	20 5d 89	jsr $895d	                jsr xt_cr
.a868	ca		dex		                dex
.a869	ca		dex		                dex
.a86a	ca		dex		                dex
.a86b	ca		dex		                dex
.a86c	74 03		stz $03,x	                stz 3,x
.a86e	a5 28		lda $28		                lda tmp3
.a870	95 02		sta $02,x	                sta 2,x
.a872	74 01		stz $01,x	                stz 1,x
.a874	a9 02		lda #$02	                lda #2
.a876	95 00		sta $00,x	                sta 0,x
.a878	20 1f a5	jsr $a51f	                jsr xt_u_dot_r
.a87b	20 09 a1	jsr $a109	                jsr xt_space
.a87e	20 a9 8d	jsr $8da9	                jsr xt_dup
.a881	ca		dex		                dex
.a882	ca		dex		                dex
.a883	a9 40		lda #$40	                lda #64
.a885	95 00		sta $00,x	                sta 0,x
.a887	74 01		stz $01,x	                stz 1,x
.a889	20 e8 a4	jsr $a4e8	                jsr xt_type
.a88c	18		clc		                clc
.a88d	a9 40		lda #$40	                lda #64
.a88f	75 00		adc $00,x	                adc 0,x
.a891	95 00		sta $00,x	                sta 0,x
.a893	b5 01		lda $01,x	                lda 1,x
.a895	69 00		adc #$00	                adc #0      ; Add carry
.a897	95 01		sta $01,x	                sta 1,x
.a899	e6 28		inc $28		                inc tmp3
.a89b	a5 28		lda $28		                lda tmp3
.a89d	c9 10		cmp #$10	                cmp #16
.a89f	d0 c4		bne $a865	                bne _line_loop
.a8a1	20 5d 89	jsr $895d	                jsr xt_cr
.a8a4	e8		inx		                inx
.a8a5	e8		inx		                inx
.a8a6	60		rts		z_editor_l:            rts
.a8a7					xt_editor_line:
.a8a7	20 14 d8	jsr $d814	                jsr underflow_1
.a8aa	a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a8ac					_shift_tos_left:
.a8ac	16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a8ae	36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a8b0	88		dey		                dey
.a8b1	d0 f9		bne $a8ac	                bne _shift_tos_left
.a8b3	20 c4 9e	jsr $9ec4	                jsr xt_scr
.a8b6	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.a8b9	20 bb 83	jsr $83bb	                jsr xt_block
.a8bc	20 ce 99	jsr $99ce	                jsr xt_plus
.a8bf	60		rts		z_editor_line:  rts
.a8c0					xt_editor_o:
.a8c0	20 5d 89	jsr $895d	                jsr xt_cr
.a8c3	20 a9 8d	jsr $8da9	                jsr xt_dup
.a8c6	20 8c a3	jsr $a38c	                jsr xt_two
.a8c9	20 1f a5	jsr $a51f	                jsr xt_u_dot_r
.a8cc	20 09 a1	jsr $a109	                jsr xt_space
.a8cf	a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a8d1	20 f0 8d	jsr $8df0	                jsr emit_a
.a8d4	20 09 a1	jsr $a109	                jsr xt_space
.a8d7	20 a7 a8	jsr $a8a7	                jsr xt_editor_line
.a8da	20 a9 8d	jsr $8da9	                jsr xt_dup      ; Save a copy of the line address for later.
.a8dd	ca		dex		                dex
.a8de	ca		dex		                dex
.a8df	a9 40		lda #$40	                lda #64         ; chars/line
.a8e1	95 00		sta $00,x	                sta 0,x
.a8e3	74 01		stz $01,x	                stz 1,x
.a8e5	20 4e 81	jsr $814e	                jsr xt_accept
.a8e8	20 a9 8d	jsr $8da9	                jsr xt_dup
.a8eb	20 68 96	jsr $9668	                jsr xt_not_rote ; -rot
.a8ee	20 ce 99	jsr $99ce	                jsr xt_plus
.a8f1	ca		dex		                dex
.a8f2	ca		dex		                dex
.a8f3	a9 40		lda #$40	                lda #64         ; chars/line
.a8f5	95 00		sta $00,x	                sta 0,x
.a8f7	74 01		stz $01,x	                stz 1,x
.a8f9	20 42 9b	jsr $9b42	                jsr xt_rot
.a8fc	20 4a 95	jsr $954a	                jsr xt_minus
.a8ff	20 e4 8e	jsr $8ee4	                jsr xt_blank
.a902	20 49 a6	jsr $a649	                jsr xt_update
.a905	60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a906					assembler:
.a906					xt_asm_adc_h:
.a906	a9 69		lda #$69	                lda #$69
.a908	4c 61 ac	jmp $ac61	                jmp asm_common
.a90b					z_asm_adc_h:
.a90b					xt_asm_adc_x:
.a90b	a9 7d		lda #$7d	                lda #$7D
.a90d	4c 61 ac	jmp $ac61	                jmp asm_common
.a910					z_asm_adc_x:
.a910					xt_asm_adc_y:
.a910	a9 79		lda #$79	                lda #$79
.a912	4c 61 ac	jmp $ac61	                jmp asm_common
.a915					z_asm_adc_y:
.a915					xt_asm_adc_z:
.a915	a9 65		lda #$65	                lda #$65
.a917	4c 61 ac	jmp $ac61	                jmp asm_common
.a91a					z_asm_adc_z:
.a91a					xt_asm_adc_zi:
.a91a	a9 72		lda #$72	                lda #$72
.a91c	4c 61 ac	jmp $ac61	                jmp asm_common
.a91f					z_asm_adc_zi:
.a91f					xt_asm_adc_ziy:
.a91f	a9 71		lda #$71	                lda #$71
.a921	4c 61 ac	jmp $ac61	                jmp asm_common
.a924					z_asm_adc_ziy:
.a924					xt_asm_adc_zx:
.a924	a9 75		lda #$75	                lda #$75
.a926	4c 61 ac	jmp $ac61	                jmp asm_common
.a929					z_asm_adc_zx:
.a929					xt_asm_adc_zxi:
.a929	a9 61		lda #$61	                lda #$61
.a92b	4c 61 ac	jmp $ac61	                jmp asm_common
.a92e					z_asm_adc_zxi:
.a92e					xt_asm_and:
.a92e	a9 2d		lda #$2d	                lda #$2D
.a930	4c 61 ac	jmp $ac61	                jmp asm_common
.a933					z_asm_and:
.a933					xt_asm_and_h:
.a933	a9 29		lda #$29	                lda #$29
.a935	4c 61 ac	jmp $ac61	                jmp asm_common
.a938					z_asm_and_h:
.a938					xt_asm_and_x:
.a938	a9 3d		lda #$3d	                lda #$3D
.a93a	4c 61 ac	jmp $ac61	                jmp asm_common
.a93d					z_asm_and_x:
.a93d					xt_asm_and_y:
.a93d	a9 39		lda #$39	                lda #$39
.a93f	4c 61 ac	jmp $ac61	                jmp asm_common
.a942					z_asm_and_y:
.a942					xt_asm_and_z:
.a942	a9 25		lda #$25	                lda #$25
.a944	4c 61 ac	jmp $ac61	                jmp asm_common
.a947					z_asm_and_z:
.a947					xt_asm_and_zi:
.a947	a9 32		lda #$32	                lda #$32
.a949	4c 61 ac	jmp $ac61	                jmp asm_common
.a94c					z_asm_and_zi:
.a94c					xt_asm_and_ziy:
.a94c	a9 31		lda #$31	                lda #$31
.a94e	4c 61 ac	jmp $ac61	                jmp asm_common
.a951					z_asm_and_ziy:
.a951					xt_asm_and_zx:
.a951	a9 35		lda #$35	                lda #$35
.a953	4c 61 ac	jmp $ac61	                jmp asm_common
.a956					z_asm_and_zx:
.a956					xt_asm_and_zxi:
.a956	a9 21		lda #$21	                lda #$21
.a958	4c 61 ac	jmp $ac61	                jmp asm_common
.a95b					z_asm_and_zxi:
.a95b					xt_asm_asl:
.a95b	a9 0e		lda #$0e	                lda #$0E
.a95d	4c 61 ac	jmp $ac61	                jmp asm_common
.a960					z_asm_asl:
.a960					xt_asm_asl_a:
.a960	a9 0a		lda #$0a	                lda #$0A
.a962	4c 61 ac	jmp $ac61	                jmp asm_common
.a965					z_asm_asl_a:
.a965					xt_asm_asl_x:
.a965	a9 1e		lda #$1e	                lda #$1E
.a967	4c 61 ac	jmp $ac61	                jmp asm_common
.a96a					z_asm_asl_x:
.a96a					xt_asm_asl_z:
.a96a	a9 06		lda #$06	                lda #$06
.a96c	4c 61 ac	jmp $ac61	                jmp asm_common
.a96f					z_asm_asl_z:
.a96f					xt_asm_asl_zx:
.a96f	a9 16		lda #$16	                lda #$16
.a971	4c 61 ac	jmp $ac61	                jmp asm_common
.a974					z_asm_asl_zx:
.a974					xt_asm_bcc:
.a974	a9 90		lda #$90	                lda #$90
.a976	4c 61 ac	jmp $ac61	                jmp asm_common
.a979					z_asm_bcc:
.a979					xt_asm_bcs:
.a979	a9 b0		lda #$b0	                lda #$B0
.a97b	a0 02		ldy #$02	                ldy #2
.a97d	4c 61 ac	jmp $ac61	                jmp asm_common
.a980					z_asm_bcs:
.a980					xt_asm_beq:
.a980	a9 f0		lda #$f0	                lda #$F0
.a982	4c 61 ac	jmp $ac61	                jmp asm_common
.a985					z_asm_beq:
.a985					xt_asm_bit:
.a985	a9 2c		lda #$2c	                lda #$2C
.a987	4c 61 ac	jmp $ac61	                jmp asm_common
.a98a					z_asm_bit:
.a98a					xt_asm_bit_h:
.a98a	a9 89		lda #$89	                lda #$89
.a98c	4c 61 ac	jmp $ac61	                jmp asm_common
.a98f					z_asm_bit_h:
.a98f					xt_asm_bit_x:
.a98f	a9 3c		lda #$3c	                lda #$3C
.a991	4c 61 ac	jmp $ac61	                jmp asm_common
.a994					z_asm_bit_x:
.a994					xt_asm_bit_z:
.a994	a9 24		lda #$24	                lda #$24
.a996	4c 61 ac	jmp $ac61	                jmp asm_common
.a999					z_asm_bit_z:
.a999					xt_asm_bit_zx:
.a999	a9 34		lda #$34	                lda #$34
.a99b	4c 61 ac	jmp $ac61	                jmp asm_common
.a99e					z_asm_bit_zx:
.a99e					xt_asm_bmi:
.a99e	a9 30		lda #$30	                lda #$30
.a9a0	4c 61 ac	jmp $ac61	                jmp asm_common
.a9a3					z_asm_bmi:
.a9a3					xt_asm_bne:
.a9a3	a9 d0		lda #$d0	                lda #$D0
.a9a5	4c 61 ac	jmp $ac61	                jmp asm_common
.a9a8					z_asm_bne:
.a9a8					xt_asm_bpl:
.a9a8	a9 10		lda #$10	                lda #$10
.a9aa	4c 61 ac	jmp $ac61	                jmp asm_common
.a9ad					z_asm_bpl:
.a9ad					xt_asm_bra:
.a9ad	a9 80		lda #$80	                lda #$80
.a9af	4c 61 ac	jmp $ac61	                jmp asm_common
.a9b2					z_asm_bra:
.a9b2					xt_asm_brk:
.a9b2	a9 00		lda #$00	                lda #$00
.a9b4	4c 61 ac	jmp $ac61	                jmp asm_common
.a9b7					z_asm_brk:
.a9b7					xt_asm_bvc:
.a9b7	a9 50		lda #$50	                lda #$50
.a9b9	4c 61 ac	jmp $ac61	                jmp asm_common
.a9bc					z_asm_bvc:
.a9bc					xt_asm_bvs:
.a9bc	a9 70		lda #$70	                lda #$70
.a9be	4c 61 ac	jmp $ac61	                jmp asm_common
.a9c1					z_asm_bvs:
.a9c1					xt_asm_clc:
.a9c1	a9 18		lda #$18	                lda #$18
.a9c3	4c 61 ac	jmp $ac61	                jmp asm_common
.a9c6					z_asm_clc:
.a9c6					xt_asm_cld:
.a9c6	a9 d8		lda #$d8	                lda #$D8
.a9c8	4c 61 ac	jmp $ac61	                jmp asm_common
.a9cb					z_asm_cld:
.a9cb					xt_asm_cli:
.a9cb	a9 58		lda #$58	                lda #$58
.a9cd	4c 61 ac	jmp $ac61	                jmp asm_common
.a9d0					z_asm_cli:
.a9d0					xt_asm_clv:
.a9d0	a9 b8		lda #$b8	                lda #$B8
.a9d2	4c 61 ac	jmp $ac61	                jmp asm_common
.a9d5					z_asm_clv:
.a9d5					xt_asm_cmp:
.a9d5	a9 cd		lda #$cd	                lda #$CD
.a9d7	4c 61 ac	jmp $ac61	                jmp asm_common
.a9da					z_asm_cmp:
.a9da					xt_asm_cmp_h:
.a9da	a9 c9		lda #$c9	                lda #$C9
.a9dc	4c 61 ac	jmp $ac61	                jmp asm_common
.a9df					z_asm_cmp_h:
.a9df					xt_asm_cmp_x:
.a9df	a9 dd		lda #$dd	                lda #$DD
.a9e1	4c 61 ac	jmp $ac61	                jmp asm_common
.a9e4					z_asm_cmp_x:
.a9e4					xt_asm_cmp_y:
.a9e4	a9 d9		lda #$d9	                lda #$D9
.a9e6	4c 61 ac	jmp $ac61	                jmp asm_common
.a9e9					z_asm_cmp_y:
.a9e9					xt_asm_cmp_z:
.a9e9	a9 c5		lda #$c5	                lda #$C5
.a9eb	4c 61 ac	jmp $ac61	                jmp asm_common
.a9ee					z_asm_cmp_z:
.a9ee					xt_asm_cmp_zi:
.a9ee	a9 d2		lda #$d2	                lda #$D2
.a9f0	4c 61 ac	jmp $ac61	                jmp asm_common
.a9f3					z_asm_cmp_zi:
.a9f3					xt_asm_cmp_ziy:
.a9f3	a9 d1		lda #$d1	                lda #$D1
.a9f5	4c 61 ac	jmp $ac61	                jmp asm_common
.a9f8					z_asm_cmp_ziy:
.a9f8					xt_asm_cmp_zx:
.a9f8	a9 d5		lda #$d5	                lda #$D5
.a9fa	4c 61 ac	jmp $ac61	                jmp asm_common
.a9fd					z_asm_cmp_zx:
.a9fd					xt_asm_cmp_zxi:
.a9fd	a9 c1		lda #$c1	                lda #$C1
.a9ff	4c 61 ac	jmp $ac61	                jmp asm_common
.aa02					z_asm_cmp_zxi:
.aa02					xt_asm_cpx:
.aa02	a9 ec		lda #$ec	                lda #$EC
.aa04	4c 61 ac	jmp $ac61	                jmp asm_common
.aa07					z_asm_cpx:
.aa07					xt_asm_cpx_h:
.aa07	a9 e0		lda #$e0	                lda #$E0
.aa09	4c 61 ac	jmp $ac61	                jmp asm_common
.aa0c					z_asm_cpx_h:
.aa0c					xt_asm_cpx_z:
.aa0c	a9 e4		lda #$e4	                lda #$E4
.aa0e	4c 61 ac	jmp $ac61	                jmp asm_common
.aa11					z_asm_cpx_z:
.aa11					xt_asm_cpy:
.aa11	a9 cc		lda #$cc	                lda #$CC
.aa13	a0 03		ldy #$03	                ldy #3
.aa15	4c 61 ac	jmp $ac61	                jmp asm_common
.aa18					z_asm_cpy:
.aa18					xt_asm_cpy_h:
.aa18	a9 c0		lda #$c0	                lda #$C0
.aa1a	4c 61 ac	jmp $ac61	                jmp asm_common
.aa1d					z_asm_cpy_h:
.aa1d					xt_asm_cpy_z:
.aa1d	a9 c4		lda #$c4	                lda #$C4
.aa1f	4c 61 ac	jmp $ac61	                jmp asm_common
.aa22					z_asm_cpy_z:
.aa22					xt_asm_dec:
.aa22	a9 ce		lda #$ce	                lda #$CE
.aa24	4c 61 ac	jmp $ac61	                jmp asm_common
.aa27					z_asm_dec:
.aa27					xt_asm_dec_a:
.aa27	a9 3a		lda #$3a	                lda #$3A
.aa29	4c 61 ac	jmp $ac61	                jmp asm_common
.aa2c					z_asm_dec_a:
.aa2c					xt_asm_dec_x:
.aa2c	a9 de		lda #$de	                lda #$DE
.aa2e	4c 61 ac	jmp $ac61	                jmp asm_common
.aa31					z_asm_dec_x:
.aa31					xt_asm_dec_z:
.aa31	a9 c6		lda #$c6	                lda #$C6
.aa33	4c 61 ac	jmp $ac61	                jmp asm_common
.aa36					z_asm_dec_z:
.aa36					xt_asm_dec_zx:
.aa36	a9 d6		lda #$d6	                lda #$D6
.aa38	4c 61 ac	jmp $ac61	                jmp asm_common
.aa3b					z_asm_dec_zx:
.aa3b					xt_asm_dex:
.aa3b	a9 ca		lda #$ca	                lda #$CA
.aa3d	4c 61 ac	jmp $ac61	                jmp asm_common
.aa40					z_asm_dex:
.aa40					xt_asm_dey:
.aa40	a9 88		lda #$88	                lda #$88
.aa42	4c 61 ac	jmp $ac61	                jmp asm_common
.aa45					z_asm_dey:
.aa45					xt_asm_eor:
.aa45	a9 4d		lda #$4d	                lda #$4D
.aa47	4c 61 ac	jmp $ac61	                jmp asm_common
.aa4a					z_asm_eor:
.aa4a					xt_asm_eor_h:
.aa4a	a9 49		lda #$49	                lda #$49
.aa4c	4c 61 ac	jmp $ac61	                jmp asm_common
.aa4f					z_asm_eor_h:
.aa4f					xt_asm_eor_x:
.aa4f	a9 5d		lda #$5d	                lda #$5D
.aa51	4c 61 ac	jmp $ac61	                jmp asm_common
.aa54					z_asm_eor_x:
.aa54					xt_asm_eor_y:
.aa54	a9 59		lda #$59	                lda #$59
.aa56	4c 61 ac	jmp $ac61	                jmp asm_common
.aa59					z_asm_eor_y:
.aa59					xt_asm_eor_z:
.aa59	a9 45		lda #$45	                lda #$45
.aa5b	4c 61 ac	jmp $ac61	                jmp asm_common
.aa5e					z_asm_eor_z:
.aa5e					xt_asm_eor_zi:
.aa5e	a9 52		lda #$52	                lda #$52
.aa60	4c 61 ac	jmp $ac61	                jmp asm_common
.aa63					z_asm_eor_zi:
.aa63					xt_asm_eor_ziy:
.aa63	a9 51		lda #$51	                lda #$51
.aa65	4c 61 ac	jmp $ac61	                jmp asm_common
.aa68					z_asm_eor_ziy:
.aa68					xt_asm_eor_zx:
.aa68	a9 55		lda #$55	                lda #$55
.aa6a	4c 61 ac	jmp $ac61	                jmp asm_common
.aa6d					z_asm_eor_zx:
.aa6d					xt_asm_eor_zxi:
.aa6d	a9 41		lda #$41	                lda #$41
.aa6f	4c 61 ac	jmp $ac61	                jmp asm_common
.aa72					z_asm_eor_zxi:
.aa72					xt_asm_inc:
.aa72	a9 ee		lda #$ee	                lda #$EE
.aa74	4c 61 ac	jmp $ac61	                jmp asm_common
.aa77					z_asm_inc:
.aa77					xt_asm_inc_a:
.aa77	a9 1a		lda #$1a	                lda #$1A
.aa79	4c 61 ac	jmp $ac61	                jmp asm_common
.aa7c					z_asm_inc_a:
.aa7c					xt_asm_inc_x:
.aa7c	a9 fe		lda #$fe	                lda #$FE
.aa7e	4c 61 ac	jmp $ac61	                jmp asm_common
.aa81					z_asm_inc_x:
.aa81					xt_asm_inc_z:
.aa81	a9 e6		lda #$e6	                lda #$E6
.aa83	4c 61 ac	jmp $ac61	                jmp asm_common
.aa86					z_asm_inc_z:
.aa86					xt_asm_inc_zx:
.aa86	a9 f6		lda #$f6	                lda #$F6
.aa88	4c 61 ac	jmp $ac61	                jmp asm_common
.aa8b					z_asm_inc_zx:
.aa8b					xt_asm_inx:
.aa8b	a9 e8		lda #$e8	                lda #$E8
.aa8d	4c 61 ac	jmp $ac61	                jmp asm_common
.aa90					z_asm_inx:
.aa90					xt_asm_iny:
.aa90	a9 c8		lda #$c8	                lda #$C8
.aa92	4c 61 ac	jmp $ac61	                jmp asm_common
.aa95					z_asm_iny:
.aa95					xt_asm_jmp:
.aa95	a9 4c		lda #$4c	                lda #$4C
.aa97	4c 61 ac	jmp $ac61	                jmp asm_common
.aa9a					z_asm_jmp:
.aa9a					xt_asm_jmp_i:
.aa9a	a9 6c		lda #$6c	                lda #$6C
.aa9c	4c 61 ac	jmp $ac61	                jmp asm_common
.aa9f					z_asm_jmp_i:
.aa9f					xt_asm_jmp_xi:
.aa9f	a9 7c		lda #$7c	                lda #$7C
.aaa1	4c 61 ac	jmp $ac61	                jmp asm_common
.aaa4					z_asm_jmp_xi:
.aaa4					xt_asm_jsr:
.aaa4	a9 20		lda #$20	                lda #$20
.aaa6	4c 61 ac	jmp $ac61	                jmp asm_common
.aaa9					z_asm_jsr:
.aaa9					xt_asm_lda:
.aaa9	a9 ad		lda #$ad	                lda #$AD
.aaab	4c 61 ac	jmp $ac61	                jmp asm_common
.aaae					z_asm_lda:
.aaae					xt_asm_lda_h:
.aaae	a9 a9		lda #$a9	                lda #$A9
.aab0	4c 61 ac	jmp $ac61	                jmp asm_common
.aab3					z_asm_lda_h:
.aab3					xt_asm_lda_x:
.aab3	a9 bd		lda #$bd	                lda #$BD
.aab5	4c 61 ac	jmp $ac61	                jmp asm_common
.aab8					z_asm_lda_x:
.aab8					xt_asm_lda_y:
.aab8	a9 b9		lda #$b9	                lda #$B9
.aaba	4c 61 ac	jmp $ac61	                jmp asm_common
.aabd					z_asm_lda_y:
.aabd					xt_asm_lda_z:
.aabd	a9 a5		lda #$a5	                lda #$A5
.aabf	4c 61 ac	jmp $ac61	                jmp asm_common
.aac2					z_asm_lda_z:
.aac2					xt_asm_lda_zi:
.aac2	a9 b2		lda #$b2	                lda #$B2
.aac4	4c 61 ac	jmp $ac61	                jmp asm_common
.aac7					z_asm_lda_zi:
.aac7					xt_asm_lda_ziy:
.aac7	a9 b1		lda #$b1	                lda #$B1
.aac9	4c 61 ac	jmp $ac61	                jmp asm_common
.aacc					z_asm_lda_ziy:
.aacc					xt_asm_lda_zx:
.aacc	a9 b5		lda #$b5	                lda #$B5
.aace	4c 61 ac	jmp $ac61	                jmp asm_common
.aad1					z_asm_lda_zx:
.aad1					xt_asm_lda_zxi:
.aad1	a9 a1		lda #$a1	                lda #$A1
.aad3	4c 61 ac	jmp $ac61	                jmp asm_common
.aad6					z_asm_lda_zxi:
.aad6					xt_asm_ldx:
.aad6	a9 ae		lda #$ae	                lda #$AE
.aad8	4c 61 ac	jmp $ac61	                jmp asm_common
.aadb					z_asm_ldx:
.aadb					xt_asm_ldx_h:
.aadb	a9 a2		lda #$a2	                lda #$A2
.aadd	4c 61 ac	jmp $ac61	                jmp asm_common
.aae0					z_asm_ldx_h:
.aae0					xt_asm_ldx_y:
.aae0	a9 be		lda #$be	                lda #$BE
.aae2	4c 61 ac	jmp $ac61	                jmp asm_common
.aae5					z_asm_ldx_y:
.aae5					xt_asm_ldx_z:
.aae5	a9 a6		lda #$a6	                lda #$A6
.aae7	4c 61 ac	jmp $ac61	                jmp asm_common
.aaea					z_asm_ldx_z:
.aaea					xt_asm_ldx_zy:
.aaea	a9 b6		lda #$b6	                lda #$B6
.aaec	4c 61 ac	jmp $ac61	                jmp asm_common
.aaef					z_asm_ldx_zy:
.aaef					xt_asm_ldy:
.aaef	a9 ac		lda #$ac	                lda #$AC
.aaf1	4c 61 ac	jmp $ac61	                jmp asm_common
.aaf4					z_asm_ldy:
.aaf4					xt_asm_ldy_h:
.aaf4	a9 a0		lda #$a0	                lda #$A0
.aaf6	4c 61 ac	jmp $ac61	                jmp asm_common
.aaf9					z_asm_ldy_h:
.aaf9					xt_asm_ldy_x:
.aaf9	a9 bc		lda #$bc	                lda #$BC
.aafb	4c 61 ac	jmp $ac61	                jmp asm_common
.aafe					z_asm_ldy_x:
.aafe					xt_asm_ldy_z:
.aafe	a9 a4		lda #$a4	                lda #$A4
.ab00	4c 61 ac	jmp $ac61	                jmp asm_common
.ab03					z_asm_ldy_z:
.ab03					xt_asm_ldy_zx:
.ab03	a9 b4		lda #$b4	                lda #$B4
.ab05	4c 61 ac	jmp $ac61	                jmp asm_common
.ab08					z_asm_ldy_zx:
.ab08					xt_asm_lsr:
.ab08	a9 4e		lda #$4e	                lda #$4E
.ab0a	4c 61 ac	jmp $ac61	                jmp asm_common
.ab0d					z_asm_lsr:
.ab0d					xt_asm_lsr_a:
.ab0d	a9 4a		lda #$4a	                lda #$4A
.ab0f	4c 61 ac	jmp $ac61	                jmp asm_common
.ab12					z_asm_lsr_a:
.ab12					xt_asm_lsr_x:
.ab12	a9 5e		lda #$5e	                lda #$5E
.ab14	4c 61 ac	jmp $ac61	                jmp asm_common
.ab17					z_asm_lsr_x:
.ab17					xt_asm_lsr_z:
.ab17	a9 46		lda #$46	                lda #$46
.ab19	4c 61 ac	jmp $ac61	                jmp asm_common
.ab1c					z_asm_lsr_z:
.ab1c					xt_asm_lsr_zx:
.ab1c	a9 56		lda #$56	                lda #$56
.ab1e	4c 61 ac	jmp $ac61	                jmp asm_common
.ab21					z_asm_lsr_zx:
.ab21					xt_asm_nop:
.ab21	a9 ea		lda #$ea	                lda #$EA
.ab23	4c 61 ac	jmp $ac61	                jmp asm_common
.ab26					z_asm_nop:
.ab26					xt_asm_ora:
.ab26	a9 0d		lda #$0d	                lda #$0D
.ab28	4c 61 ac	jmp $ac61	                jmp asm_common
.ab2b					z_asm_ora:
.ab2b					xt_asm_ora_h:
.ab2b	a9 09		lda #$09	                lda #$09
.ab2d	4c 61 ac	jmp $ac61	                jmp asm_common
.ab30					z_asm_ora_h:
.ab30					xt_asm_ora_x:
.ab30	a9 1d		lda #$1d	                lda #$1D
.ab32	4c 61 ac	jmp $ac61	                jmp asm_common
.ab35					z_asm_ora_x:
.ab35					xt_asm_ora_y:
.ab35	a9 19		lda #$19	                lda #$19
.ab37	4c 61 ac	jmp $ac61	                jmp asm_common
.ab3a					z_asm_ora_y:
.ab3a					xt_asm_ora_z:
.ab3a	a9 05		lda #$05	                lda #$05
.ab3c	4c 61 ac	jmp $ac61	                jmp asm_common
.ab3f					z_asm_ora_z:
.ab3f					xt_asm_ora_zi:
.ab3f	a9 12		lda #$12	                lda #$12
.ab41	a0 02		ldy #$02	                ldy #2
.ab43	4c 61 ac	jmp $ac61	                jmp asm_common
.ab46					z_asm_ora_zi:
.ab46					xt_asm_ora_ziy:
.ab46	a9 11		lda #$11	                lda #$11
.ab48	4c 61 ac	jmp $ac61	                jmp asm_common
.ab4b					z_asm_ora_ziy:
.ab4b					xt_asm_ora_zx:
.ab4b	a9 15		lda #$15	                lda #$15
.ab4d	4c 61 ac	jmp $ac61	                jmp asm_common
.ab50					z_asm_ora_zx:
.ab50					xt_asm_ora_zxi:
.ab50	a9 01		lda #$01	                lda #$01
.ab52	4c 61 ac	jmp $ac61	                jmp asm_common
.ab55					z_asm_ora_zxi:
.ab55					xt_asm_pha:
.ab55	a9 48		lda #$48	                lda #$48
.ab57	4c 61 ac	jmp $ac61	                jmp asm_common
.ab5a					z_asm_pha:
.ab5a					xt_asm_php:
.ab5a	a9 08		lda #$08	                lda #$08
.ab5c	4c 61 ac	jmp $ac61	                jmp asm_common
.ab5f					z_asm_php:
.ab5f					xt_asm_phx:
.ab5f	a9 da		lda #$da	                lda #$DA
.ab61	4c 61 ac	jmp $ac61	                jmp asm_common
.ab64					z_asm_phx:
.ab64					xt_asm_phy:
.ab64	a9 5a		lda #$5a	                lda #$5A
.ab66	4c 61 ac	jmp $ac61	                jmp asm_common
.ab69					z_asm_phy:
.ab69					xt_asm_pla:
.ab69	a9 68		lda #$68	                lda #$68
.ab6b	4c 61 ac	jmp $ac61	                jmp asm_common
.ab6e					z_asm_pla:
.ab6e					xt_asm_plp:
.ab6e	a9 28		lda #$28	                lda #$28
.ab70	4c 61 ac	jmp $ac61	                jmp asm_common
.ab73					z_asm_plp:
.ab73					xt_asm_plx:
.ab73	a9 fa		lda #$fa	                lda #$FA
.ab75	4c 61 ac	jmp $ac61	                jmp asm_common
.ab78					z_asm_plx:
.ab78					xt_asm_ply:
.ab78	a9 7a		lda #$7a	                lda #$7A
.ab7a	4c 61 ac	jmp $ac61	                jmp asm_common
.ab7d					z_asm_ply:
.ab7d					xt_asm_rol:
.ab7d	a9 2e		lda #$2e	                lda #$2E
.ab7f	4c 61 ac	jmp $ac61	                jmp asm_common
.ab82					z_asm_rol:
.ab82					xt_asm_rol_a:
.ab82	a9 2a		lda #$2a	                lda #$2A
.ab84	4c 61 ac	jmp $ac61	                jmp asm_common
.ab87					z_asm_rol_a:
.ab87					xt_asm_rol_x:
.ab87	a9 3e		lda #$3e	                lda #$3E
.ab89	4c 61 ac	jmp $ac61	                jmp asm_common
.ab8c					z_asm_rol_x:
.ab8c					xt_asm_rol_z:
.ab8c	a9 26		lda #$26	                lda #$26
.ab8e	4c 61 ac	jmp $ac61	                jmp asm_common
.ab91					z_asm_rol_z:
.ab91					xt_asm_rol_zx:
.ab91	a9 36		lda #$36	                lda #$36
.ab93	4c 61 ac	jmp $ac61	                jmp asm_common
.ab96					z_asm_rol_zx:
.ab96					xt_asm_ror:
.ab96	a9 6e		lda #$6e	                lda #$6E
.ab98	4c 61 ac	jmp $ac61	                jmp asm_common
.ab9b					z_asm_ror:
.ab9b					xt_asm_ror_a:
.ab9b	a9 6a		lda #$6a	                lda #$6A
.ab9d	4c 61 ac	jmp $ac61	                jmp asm_common
.aba0					z_asm_ror_a:
.aba0					xt_asm_ror_x:
.aba0	a9 7e		lda #$7e	                lda #$7E
.aba2	4c 61 ac	jmp $ac61	                jmp asm_common
.aba5					z_asm_ror_x:
.aba5					xt_asm_ror_z:
.aba5	a9 66		lda #$66	                lda #$66
.aba7	4c 61 ac	jmp $ac61	                jmp asm_common
.abaa					z_asm_ror_z:
.abaa					xt_asm_ror_zx:
.abaa	a9 76		lda #$76	                lda #$76
.abac	4c 61 ac	jmp $ac61	                jmp asm_common
.abaf					z_asm_ror_zx:
.abaf					xt_asm_rti:
.abaf	a9 40		lda #$40	                lda #$40
.abb1	4c 61 ac	jmp $ac61	                jmp asm_common
.abb4					z_asm_rti:
.abb4					xt_asm_rts:
.abb4	a9 60		lda #$60	                lda #$60
.abb6	4c 61 ac	jmp $ac61	                jmp asm_common
.abb9					z_asm_rts:
.abb9					xt_asm_sbc:
.abb9	a9 ed		lda #$ed	                lda #$ED
.abbb	4c 61 ac	jmp $ac61	                jmp asm_common
.abbe					z_asm_sbc:
.abbe					xt_asm_sbc_h:
.abbe	a9 e9		lda #$e9	                lda #$E9
.abc0	4c 61 ac	jmp $ac61	                jmp asm_common
.abc3					z_asm_sbc_h:
.abc3					xt_asm_sbc_x:
.abc3	a9 fd		lda #$fd	                lda #$FD
.abc5	4c 61 ac	jmp $ac61	                jmp asm_common
.abc8					z_asm_sbc_x:
.abc8					xt_asm_sbc_y:
.abc8	a9 f9		lda #$f9	                lda #$F9
.abca	4c 61 ac	jmp $ac61	                jmp asm_common
.abcd					z_asm_sbc_y:
.abcd					xt_asm_sbc_z:
.abcd	a9 e5		lda #$e5	                lda #$E5
.abcf	4c 61 ac	jmp $ac61	                jmp asm_common
.abd2					z_asm_sbc_z:
.abd2					xt_asm_sbc_zi:
.abd2	a9 f2		lda #$f2	                lda #$F2
.abd4	4c 61 ac	jmp $ac61	                jmp asm_common
.abd7					z_asm_sbc_zi:
.abd7					xt_asm_sbc_ziy:
.abd7	a9 f1		lda #$f1	                lda #$F1
.abd9	4c 61 ac	jmp $ac61	                jmp asm_common
.abdc					z_asm_sbc_ziy:
.abdc					xt_asm_sbc_zx:
.abdc	a9 f5		lda #$f5	                lda #$F5
.abde	4c 61 ac	jmp $ac61	                jmp asm_common
.abe1					z_asm_sbc_zx:
.abe1					xt_asm_sbc_zxi:
.abe1	a9 e1		lda #$e1	                lda #$E1
.abe3	80 7c		bra $ac61	                bra asm_common  ; <-- limit for BRA instead of JMP
.abe5					z_asm_sbc_zxi:
.abe5					xt_asm_sec:
.abe5	a9 38		lda #$38	                lda #$38
.abe7	80 78		bra $ac61	                bra asm_common
.abe9					z_asm_sec:
.abe9					xt_asm_sed:
.abe9	a9 f8		lda #$f8	                lda #$F8
.abeb	80 74		bra $ac61	                bra asm_common
.abed					z_asm_sed:
.abed					xt_asm_sei:
.abed	a9 78		lda #$78	                lda #$78
.abef	80 70		bra $ac61	                bra asm_common
.abf1					z_asm_sei:
.abf1					xt_asm_sta:
.abf1	a9 8d		lda #$8d	                lda #$8D
.abf3	80 6c		bra $ac61	                bra asm_common
.abf5					z_asm_sta:
.abf5					xt_asm_sta_x:
.abf5	a9 9d		lda #$9d	                lda #$9D
.abf7	80 68		bra $ac61	                bra asm_common
.abf9					z_asm_sta_x:
.abf9					xt_asm_sta_y:
.abf9	a9 99		lda #$99	                lda #$99
.abfb	80 64		bra $ac61	                bra asm_common
.abfd					z_asm_sta_y:
.abfd					xt_asm_sta_z:
.abfd	a9 85		lda #$85	                lda #$85
.abff	80 60		bra $ac61	                bra asm_common
.ac01					z_asm_sta_z:
.ac01					xt_asm_sta_zi:
.ac01	a9 92		lda #$92	                lda #$92
.ac03	80 5c		bra $ac61	                bra asm_common
.ac05					z_asm_sta_zi:
.ac05					xt_asm_sta_ziy:
.ac05	a9 91		lda #$91	                lda #$91
.ac07	80 58		bra $ac61	                bra asm_common
.ac09					z_asm_sta_ziy:
.ac09					xt_asm_sta_zx:
.ac09	a9 95		lda #$95	                lda #$95
.ac0b	80 54		bra $ac61	                bra asm_common
.ac0d					z_asm_sta_zx:
.ac0d					xt_asm_sta_zxi:
.ac0d	a9 81		lda #$81	                lda #$81
.ac0f	80 50		bra $ac61	                bra asm_common
.ac11					z_asm_sta_zxi:
.ac11					xt_asm_stx:
.ac11	a9 8e		lda #$8e	                lda #$8E
.ac13	80 4c		bra $ac61	                bra asm_common
.ac15					z_asm_stx:
.ac15					xt_asm_stx_z:
.ac15	a9 86		lda #$86	                lda #$86
.ac17	80 48		bra $ac61	                bra asm_common
.ac19					z_asm_stx_z:
.ac19					xt_asm_stx_zy:
.ac19	a9 96		lda #$96	                lda #$96
.ac1b	80 44		bra $ac61	                bra asm_common
.ac1d					z_asm_stx_zy:
.ac1d					xt_asm_sty:
.ac1d	a9 8c		lda #$8c	                lda #$8C
.ac1f	80 40		bra $ac61	                bra asm_common
.ac21					z_asm_sty:
.ac21					xt_asm_sty_z:
.ac21	a9 84		lda #$84	                lda #$84
.ac23	80 3c		bra $ac61	                bra asm_common
.ac25					z_asm_sty_z:
.ac25					xt_asm_sty_zx:
.ac25	a9 94		lda #$94	                lda #$94
.ac27	80 38		bra $ac61	                bra asm_common
.ac29					z_asm_sty_zx:
.ac29					xt_asm_stz:
.ac29	a9 9c		lda #$9c	                lda #$9C
.ac2b	80 34		bra $ac61	                bra asm_common
.ac2d					z_asm_stz:
.ac2d					xt_asm_stz_x:
.ac2d	a9 9e		lda #$9e	                lda #$9E
.ac2f	80 30		bra $ac61	                bra asm_common
.ac31					z_asm_stz_x:
.ac31					xt_asm_stz_z:
.ac31	a9 64		lda #$64	                lda #$64
.ac33	80 2c		bra $ac61	                bra asm_common
.ac35					z_asm_stz_z:
.ac35					xt_asm_stz_zx:
.ac35	a9 74		lda #$74	                lda #$74
.ac37	80 28		bra $ac61	                bra asm_common
.ac39					z_asm_stz_zx:
.ac39					xt_asm_tax:
.ac39	a9 aa		lda #$aa	                lda #$AA
.ac3b	80 24		bra $ac61	                bra asm_common
.ac3d					z_asm_tax:
.ac3d					xt_asm_tay:
.ac3d	a9 a8		lda #$a8	                lda #$A8
.ac3f	80 20		bra $ac61	                bra asm_common
.ac41					z_asm_tay:
.ac41					xt_asm_trb:
.ac41	a9 1c		lda #$1c	                lda #$1C
.ac43	80 1c		bra $ac61	                bra asm_common
.ac45					z_asm_trb:
.ac45					xt_asm_trb_z:
.ac45	a9 14		lda #$14	                lda #$14
.ac47	80 18		bra $ac61	                bra asm_common
.ac49					z_asm_trb_z:
.ac49					xt_asm_tsb:
.ac49	a9 0c		lda #$0c	                lda #$0C
.ac4b	80 14		bra $ac61	                bra asm_common
.ac4d					z_asm_tsb:
.ac4d					xt_asm_tsb_z:
.ac4d	a9 04		lda #$04	                lda #$04
.ac4f	80 10		bra $ac61	                bra asm_common
.ac51					z_asm_tsb_z:
.ac51					xt_asm_tsx:
.ac51	a9 ba		lda #$ba	                lda #$BA
.ac53	80 0c		bra $ac61	                bra asm_common
.ac55					z_asm_tsx:
.ac55					xt_asm_txa:
.ac55	a9 8a		lda #$8a	                lda #$8A
.ac57	80 08		bra $ac61	                bra asm_common
.ac59					z_asm_txa:
.ac59					xt_asm_txs:
.ac59	a9 9a		lda #$9a	                lda #$9A
.ac5b	80 04		bra $ac61	                bra asm_common
.ac5d					z_asm_txs:
.ac5d					xt_asm_tya:
.ac5d	a9 98		lda #$98	                lda #$98
.ac5f	80 00		bra $ac61	                bra asm_common
.ac61					z_asm_tya:
.ac61					asm_common:
.ac61	a8		tay		                tay
.ac62	20 c7 d6	jsr $d6c7	                jsr cmpl_a
.ac65	a9 cd		lda #$cd	                lda #<oc_index_table
.ac67	85 26		sta $26		                sta tmp2
.ac69	a9 ae		lda #$ae	                lda #>oc_index_table
.ac6b	85 27		sta $27		                sta tmp2+1
.ac6d	98		tya		                tya             ; retrieve opcode
.ac6e	0a		asl a		                asl             ; times two for offset
.ac6f	90 02		bcc $ac73	                bcc +
.ac71	e6 27		inc $27		                inc tmp2+1
.ac73					+
.ac73	a8		tay		                tay             ; use Y as the index
.ac74	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac76	85 28		sta $28		                sta tmp3
.ac78	c8		iny		                iny
.ac79	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac7b	85 29		sta $29		                sta tmp3+1
.ac7d	b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac7f	2a		rol a		                rol
.ac80	2a		rol a		                rol
.ac81	2a		rol a		                rol             ; Three times because we go through Carry
.ac82	29 03		and #$03	                and #%00000011
.ac84	a8		tay		                tay
.ac85	88		dey		                dey
.ac86	f0 12		beq $ac9a	                beq _done
.ac88	20 14 d8	jsr $d814	                jsr underflow_1
.ac8b	b5 00		lda $00,x	                lda 0,x
.ac8d	20 c7 d6	jsr $d6c7	                jsr cmpl_a      ; does not use Y
.ac90	88		dey		                dey
.ac91	f0 05		beq $ac98	                beq _done_drop
.ac93	b5 01		lda $01,x	                lda 1,x
.ac95	20 c7 d6	jsr $d6c7	                jsr cmpl_a      ; Fall through to _done_drop
.ac98					_done_drop:
.ac98	e8		inx		                inx
.ac99	e8		inx		                inx             ; Fall through to _done
.ac9a					_done:
.ac9a	60		rts		                rts             ; Returns to original caller
.ac9b					xt_asm_push_a:
.ac9b	a0 00		ldy #$00	                ldy #0
.ac9d					_loop:
.ac9d	b9 ab ac	lda $acab,y	                lda asm_push_a_data,y
.aca0	c9 ff		cmp #$ff	                cmp #$FF
.aca2	f0 06		beq $acaa	                beq _done
.aca4	20 c7 d6	jsr $d6c7	                jsr cmpl_a      ; does not change Y
.aca7	c8		iny		                iny
.aca8	80 f3		bra $ac9d	                bra _loop
.acaa					_done:
.acaa					z_asm_push_a:
.acaa	60		rts		                rts
.acab					asm_push_a_data:
>acab	ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>acb1	ff				        .byte $FF               ; terminator
.acb2					xt_asm_back_jump:
.acb2					z_asm_back_jump:
.acb2	60		rts		                rts
.acb3					xt_asm_back_branch:
.acb3	20 6c 91	jsr $916c	                jsr xt_here             ; ( addr-l addr-h )
.acb6	20 4a 95	jsr $954a	                jsr xt_minus            ; ( offset )
.acb9	3a		dec a		                dea
.acba	3a		dec a		                dea
.acbb					z_asm_back_branch:
.acbb	60		rts		                rts
.acbc					assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acbc					disassembler:
.acbc	20 5d 89	jsr $895d	                jsr xt_cr       ; ( addr u )
.acbf					_byte_loop:
.acbf	20 7e 98	jsr $987e	                jsr xt_over     ; ( addr u addr )
.acc2	20 13 a5	jsr $a513	                jsr xt_u_dot    ; ( addr u )
.acc5	20 09 a1	jsr $a109	                jsr xt_space
.acc8	a9 cd		lda #$cd	                lda #<oc_index_table
.acca	85 26		sta $26		                sta tmp2
.accc	a9 ae		lda #$ae	                lda #>oc_index_table
.acce	85 27		sta $27		                sta tmp2+1
.acd0	a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.acd2	85 36		sta $36		                sta scratch     ; Save opcode
.acd4	0a		asl a		                asl             ; multiply by two for offset
.acd5	90 02		bcc $acd9	                bcc +
.acd7	e6 27		inc $27		                inc tmp2+1      ; we're on second page
.acd9					+
.acd9	a8		tay		                tay             ; use Y as the index
.acda	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.acdc	85 28		sta $28		                sta tmp3
.acde	48		pha		                pha
.acdf	c8		iny		                iny
.ace0	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ace2	85 29		sta $29		                sta tmp3+1
.ace4	48		pha		                pha
.ace5	b2 28		lda ($28)	                lda (tmp3)
.ace7	a8		tay		                tay                     ; save copy of lengths byte
.ace8	10 3c		bpl $ad26	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.acea	20 8d a7	jsr $a78d	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.aced	f6 04		inc $04,x	                inc 4,x
.acef	d0 02		bne $acf3	                bne +
.acf1	f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.acf3					+
.acf3	b5 02		lda $02,x	                lda 2,x
.acf5	d0 02		bne $acf9	                bne +
.acf7	d6 03		dec $03,x	                dec 3,x
.acf9					+
.acf9	d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.acfb	a1 04		lda ($04,x)	                lda (4,x)
.acfd	95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.acff	85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.ad01	98		tya		                tya                     ; retrieve copy of lengths byte
.ad02	2a		rol a		                rol                     ; shift bit 6 to bit 7
.ad03	10 14		bpl $ad19	                bpl _print_operand
.ad05	f6 04		inc $04,x	                inc 4,x
.ad07	d0 02		bne $ad0b	                bne +
.ad09	f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad0b					+
.ad0b	b5 02		lda $02,x	                lda 2,x
.ad0d	d0 02		bne $ad11	                bne +
.ad0f	d6 03		dec $03,x	                dec 3,x
.ad11					+
.ad11	d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad13	a1 04		lda ($04,x)	                lda (4,x)
.ad15	95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad17	85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad19					_print_operand:
.ad19	ca		dex		                dex
.ad1a	ca		dex		                dex
.ad1b	a9 05		lda #$05	                lda #5
.ad1d	95 00		sta $00,x	                sta 0,x
.ad1f	74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad21	20 1f a5	jsr $a51f	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad24	80 0b		bra $ad31	                bra _print_mnemonic
.ad26					_no_operand:
.ad26	ca		dex		                dex
.ad27	ca		dex		                dex
.ad28	a9 05		lda #$05	                lda #5
.ad2a	95 00		sta $00,x	                sta 0,x
.ad2c	74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad2e	20 0f a1	jsr $a10f	                jsr xt_spaces           ; ( addr u )
.ad31					_print_mnemonic:
.ad31	20 09 a1	jsr $a109	                jsr xt_space
.ad34	ca		dex		                dex
.ad35	ca		dex		                dex                     ; ( addr u ? )
.ad36	68		pla		                pla                     ; MSB
.ad37	95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad39	68		pla		                pla                     ; LSB
.ad3a	95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad3c	20 49 89	jsr $8949	                jsr xt_count            ; ( addr u addr-o u-o )
.ad3f	74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad41	b5 00		lda $00,x	                lda 0,x
.ad43	29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad45	95 00		sta $00,x	                sta 0,x
.ad47	20 e8 a4	jsr $a4e8	                jsr xt_type             ; ( addr u )
.ad4a	a5 36		lda $36		                lda scratch
.ad4c	c9 20		cmp #$20	                cmp #$20
.ad4e	d0 59		bne $ada9	                bne _not_jsr
.ad50	ca		dex		                dex
.ad51	ca		dex		                dex
.ad52	a9 05		lda #$05	                lda #5
.ad54	95 00		sta $00,x	                sta 0,x
.ad56	74 01		stz $01,x	                stz 1,x
.ad58	20 0f a1	jsr $a10f	                jsr xt_spaces
.ad5b	a9 92		lda #$92	                lda #<literal_runtime
.ad5d	c5 37		cmp $37		                cmp scratch+1
.ad5f	d0 0c		bne $ad6d	                bne _not_literal
.ad61	a9 93		lda #$93	                lda #>literal_runtime
.ad63	c5 38		cmp $38		                cmp scratch+2
.ad65	d0 06		bne $ad6d	                bne _not_literal
.ad67	20 5f ae	jsr $ae5f	                jsr disasm_literal
.ad6a	4c d6 ad	jmp $add6	                jmp _printing_done
.ad6d					_not_literal:
.ad6d	a9 94		lda #$94	                lda #<sliteral_runtime
.ad6f	c5 37		cmp $37		                cmp scratch+1
.ad71	d0 0c		bne $ad7f	                bne _not_sliteral
.ad73	a9 a0		lda #$a0	                lda #>sliteral_runtime
.ad75	c5 38		cmp $38		                cmp scratch+2
.ad77	d0 06		bne $ad7f	                bne _not_sliteral
.ad79	20 1c ae	jsr $ae1c	                jsr disasm_sliteral
.ad7c	4c d6 ad	jmp $add6	                jmp _printing_done
.ad7f					_not_sliteral:
.ad7f	a9 0e		lda #$0e	                lda #<zero_branch_runtime
.ad81	c5 37		cmp $37		                cmp scratch+1
.ad83	d0 0c		bne $ad91	                bne _not_0branch
.ad85	a9 92		lda #$92	                lda #>zero_branch_runtime
.ad87	c5 38		cmp $38		                cmp scratch+2
.ad89	d0 06		bne $ad91	                bne _not_0branch
.ad8b	20 53 ae	jsr $ae53	                jsr disasm_0branch
.ad8e	4c d6 ad	jmp $add6	                jmp _printing_done
.ad91					_not_0branch
.ad91	a9 d5		lda #$d5	                lda #<branch_runtime
.ad93	c5 37		cmp $37		                cmp scratch+1
.ad95	d0 0c		bne $ada3	                bne _not_branch
.ad97	a9 8d		lda #$8d	                lda #>branch_runtime
.ad99	c5 38		cmp $38		                cmp scratch+2
.ad9b	d0 06		bne $ada3	                bne _not_branch
.ad9d	20 58 ae	jsr $ae58	                jsr disasm_branch
.ada0	4c d6 ad	jmp $add6	                jmp _printing_done
.ada3					_not_branch
.ada3	20 7d ae	jsr $ae7d	                jsr disasm_jsr
.ada6	4c d6 ad	jmp $add6	                jmp _printing_done
.ada9					_not_jsr:
.ada9	c9 4c		cmp #$4c	                cmp #$4C
.adab	d0 29		bne $add6	                bne _printing_done
.adad	a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.adaf	85 39		sta $39		                sta scratch+3
.adb1	a5 38		lda $38		                lda scratch+2
.adb3	85 3a		sta $3a		                sta scratch+4
.adb5	b2 39		lda ($39)	                lda (scratch+3)
.adb7	c9 20		cmp #$20	                cmp #$20 ; check for JSR
.adb9	d0 1b		bne $add6	                bne _printing_done
.adbb	e6 39		inc $39		                inc scratch+3
.adbd	d0 02		bne $adc1	                bne +
.adbf	e6 3a		inc $3a		                inc scratch+4
.adc1					+
.adc1	b2 39		lda ($39)	                lda (scratch+3)
.adc3	c9 94		cmp #$94	                cmp #<sliteral_runtime
.adc5	d0 0f		bne $add6	                bne _printing_done
.adc7	e6 39		inc $39		                inc scratch+3
.adc9	d0 02		bne $adcd	                bne +
.adcb	e6 3a		inc $3a		                inc scratch+4
.adcd					+
.adcd	b2 39		lda ($39)	                lda (scratch+3)
.adcf	c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.add1	d0 03		bne $add6	                bne _printing_done
.add3	20 f2 ad	jsr $adf2	                jsr disasm_sliteral_jump
.add6					_printing_done:
.add6	20 5d 89	jsr $895d	                jsr xt_cr
.add9	f6 02		inc $02,x	                inc 2,x
.addb	d0 02		bne $addf	                bne +
.addd	f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.addf					+
.addf	20 fc 97	jsr $97fc	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ade2	b5 00		lda $00,x	                lda 0,x                 ; All done?
.ade4	15 01		ora $01,x	                ora 1,x
.ade6	f0 07		beq $adef	                beq _done
.ade8	b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.adea	30 03		bmi $adef	                bmi _done
.adec	4c bf ac	jmp $acbf	                jmp _byte_loop          ; out of range for BRA
.adef					_done:
.adef	4c 95 a3	jmp $a395	                jmp xt_two_drop         ; JSR/RTS
.adf2					disasm_sliteral_jump:
.adf2	20 93 a1	jsr $a193	                jsr xt_swap
.adf5	ca		dex		                dex
.adf6	ca		dex		                dex
.adf7	a5 37		lda $37		                lda scratch+1
.adf9	95 00		sta $00,x	                sta 0,x
.adfb	a5 38		lda $38		                lda scratch+2
.adfd	95 01		sta $01,x	                sta 1,x
.adff	20 93 a1	jsr $a193	                jsr xt_swap
.ae02	20 4a 95	jsr $954a	                jsr xt_minus
.ae05	20 fc 97	jsr $97fc	                jsr xt_one_minus
.ae08	20 4a 95	jsr $954a	                jsr xt_minus
.ae0b	ca		dex		                dex
.ae0c	ca		dex		                dex
.ae0d	a5 37		lda $37		                lda scratch+1
.ae0f	95 00		sta $00,x	                sta 0,x
.ae11	a5 38		lda $38		                lda scratch+2
.ae13	95 01		sta $01,x	                sta 1,x
.ae15	20 fc 97	jsr $97fc	                jsr xt_one_minus
.ae18	20 93 a1	jsr $a193	                jsr xt_swap ; ( new_addr new_n )
.ae1b	60		rts		                rts
.ae1c					disasm_sliteral:
.ae1c	a9 53		lda #$53	                lda #'S'
.ae1e	20 f0 8d	jsr $8df0	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae21	a9 0d		lda #$0d	                lda #str_disasm_lit     ; "LITERAL "
.ae23	20 40 d8	jsr $d840	                jsr print_string_no_lf
.ae26	20 93 a1	jsr $a193	                jsr xt_swap             ; switch to (u addr)
.ae29	20 08 98	jsr $9808	                jsr xt_one_plus
.ae2c	20 a9 8d	jsr $8da9	                jsr xt_dup
.ae2f	20 7a 8f	jsr $8f7a	                jsr xt_fetch
.ae32	20 13 a5	jsr $a513	                jsr xt_u_dot            ; Print the address of the string
.ae35	20 8c a3	jsr $a38c	                jsr xt_two
.ae38	20 ce 99	jsr $99ce	                jsr xt_plus
.ae3b	20 a9 8d	jsr $8da9	                jsr xt_dup
.ae3e	20 4d 9a	jsr $9a4d	                jsr xt_question         ; Print the length of the string
.ae41	20 08 98	jsr $9808	                jsr xt_one_plus
.ae44	20 93 a1	jsr $a193	                jsr xt_swap            ; ( addr+4 u )
.ae47	ca		dex		                dex
.ae48	ca		dex		                dex
.ae49	a9 04		lda #$04	                lda #4
.ae4b	95 00		sta $00,x	                sta 0,x
.ae4d	74 01		stz $01,x	                stz 1,x
.ae4f	20 4a 95	jsr $954a	                jsr xt_minus            ; ( addr+4 u-4 )
.ae52	60		rts		                rts
.ae53					disasm_0branch:
.ae53	a9 30		lda #$30	                lda #'0'
.ae55	20 f0 8d	jsr $8df0	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ae58					disasm_branch:
.ae58	a9 0f		lda #$0f	                lda #str_disasm_bra
.ae5a	20 40 d8	jsr $d840	                jsr print_string_no_lf ; "BRANCH "
.ae5d	80 05		bra $ae64	                bra disasm_print_literal
.ae5f					disasm_literal:
.ae5f	a9 0d		lda #$0d	                lda #str_disasm_lit
.ae61	20 40 d8	jsr $d840	                jsr print_string_no_lf ; "LITERAL "
.ae64					disasm_print_literal:
.ae64	20 93 a1	jsr $a193	                jsr xt_swap ; switch to (u addr)
.ae67	20 08 98	jsr $9808	                jsr xt_one_plus
.ae6a	20 a9 8d	jsr $8da9	                jsr xt_dup
.ae6d	20 4d 9a	jsr $9a4d	                jsr xt_question ; Print the value at the adress
.ae70	20 08 98	jsr $9808	                jsr xt_one_plus
.ae73	20 93 a1	jsr $a193	                jsr xt_swap ; (addr+2 u)
.ae76	20 fc 97	jsr $97fc	                jsr xt_one_minus
.ae79	20 fc 97	jsr $97fc	                jsr xt_one_minus ; (addr+2 u-2)
.ae7c	60		rts		                rts
.ae7d					disasm_jsr:
.ae7d	ca		dex		                dex
.ae7e	ca		dex		                dex
.ae7f	a5 37		lda $37		                lda scratch+1
.ae81	95 00		sta $00,x	                sta 0,x
.ae83	a5 38		lda $38		                lda scratch+2
.ae85	95 01		sta $01,x	                sta 1,x
.ae87	20 72 92	jsr $9272	                jsr xt_int_to_name
.ae8a	b5 00		lda $00,x	                lda 0,x
.ae8c	15 01		ora $01,x	                ora 1,x
.ae8e	f0 07		beq $ae97	                beq _disasm_no_nt
.ae90	20 f8 95	jsr $95f8	                jsr xt_name_to_string
.ae93	20 e8 a4	jsr $a4e8	                jsr xt_type
.ae96	60		rts		                rts
.ae97					_disasm_no_nt:
.ae97	20 28 8d	jsr $8d28	                jsr xt_drop ; the 0 indicating no name token
.ae9a	ca		dex		                dex
.ae9b	ca		dex		                dex
.ae9c	a5 37		lda $37		                lda scratch+1
.ae9e	95 00		sta $00,x	                sta 0,x
.aea0	a5 38		lda $38		                lda scratch+2
.aea2	95 01		sta $01,x	                sta 1,x
.aea4	ca		dex		                dex
.aea5	ca		dex		                dex
.aea6	a9 14		lda #$14	                lda #<underflow_1
.aea8	95 00		sta $00,x	                sta 0,x
.aeaa	a9 d8		lda #$d8	                lda #>underflow_1
.aeac	95 01		sta $01,x	                sta 1,x
.aeae	20 3b d7	jsr $d73b	                jsr compare_16bit
.aeb1	f0 02		beq $aeb5	                beq _disasm_jsr_uflow_check_upper
.aeb3	b0 14		bcs $aec9	                bcs _disasm_jsr_unknown
.aeb5					_disasm_jsr_uflow_check_upper:
.aeb5	a9 23		lda #$23	                lda #<underflow_4
.aeb7	95 00		sta $00,x	                sta 0,x
.aeb9	a9 d8		lda #$d8	                lda #>underflow_4
.aebb	95 01		sta $01,x	                sta 1,x
.aebd	20 3b d7	jsr $d73b	                jsr compare_16bit
.aec0	f0 02		beq $aec4	                beq _disasm_jsr_soc
.aec2	90 05		bcc $aec9	                bcc _disasm_jsr_unknown
.aec4					_disasm_jsr_soc:
.aec4	a9 0e		lda #$0e	                lda #str_disasm_sdc
.aec6	20 40 d8	jsr $d840	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.aec9					_disasm_jsr_unknown:
.aec9	20 95 a3	jsr $a395	                jsr xt_two_drop
.aecc	60		rts		                rts
.aecd					oc_index_table:
>aecd	cd b0 d1 b0 65 b5 65 b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>aed5	d9 b0 df b0 e5 b0 65 b5
>aedd	eb b0 ef b0 f5 b0 65 b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>aee5	fb b0 ff b0 03 b1 07 b1
>aeed	0c b1 10 b1 18 b1 65 b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>aef5	1f b1 25 b1 2c b1 33 b1
>aefd	3a b1 3e b1 44 b1 65 b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af05	4a b1 4e b1 65 b5 54 b1
>af0d	5a b1 5e b1 65 b5 65 b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af15	66 b1 6c b1 72 b1 78 b1
>af1d	7f b1 83 b1 89 b1 65 b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af25	8f b1 93 b1 98 b1 9c b1
>af2d	a1 b1 a5 b1 ad b1 65 b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af35	b4 b1 bc b1 c3 b1 ca b1
>af3d	d1 b1 d5 b1 db b1 65 b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af45	e1 b1 e7 b1 ed b1 07 b1
>af4d	f8 b1 fc b1 65 b5 65 b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>af55	65 b5 04 b2 0a b2 10 b2
>af5d	17 b2 1b b2 21 b2 65 b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>af65	27 b2 2b b2 2f b2 33 b2
>af6d	38 b2 3c b2 44 b2 65 b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>af75	65 b5 4b b2 52 b2 59 b2
>af7d	60 b2 64 b2 6a b2 65 b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>af85	65 b5 65 b5 74 b2 7a b2
>af8d	7f b2 83 b2 65 b5 65 b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>af95	8b b2 91 b2 97 b2 9d b2
>af9d	a4 b2 a8 b2 ae b2 65 b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>afa5	b4 b2 ba b2 be b2 c2 b2
>afad	c7 b2 cb b2 d3 b2 65 b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>afb5	da b2 e1 b2 e8 b2 ef b2
>afbd	f6 b2 fa b2 00 b3 65 b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>afc5	04 b3 0b b3 11 b3 17 b3
>afcd	1c b3 20 b3 65 b5 65 b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>afd5	28 b3 2e b3 34 b3 65 b5
>afdd	3a b3 3e b3 44 b3 65 b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>afe5	48 b3 4c b3 50 b3 54 b3
>afed	59 b3 5d b3 65 b3 65 b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>aff5	6c b3 73 b3 7a b3 81 b3
>affd	88 b3 8c b3 92 b3 65 b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b005	96 b3 9a b3 a0 b3 a6 b3
>b00d	ab b3 b1 b3 b9 b3 65 b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b015	bf b3 c5 b3 cb b3 d1 b3
>b01d	d8 b3 dc b3 e2 b3 65 b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b025	e6 b3 ea b3 ee b3 f2 b3
>b02d	f7 b3 fb b3 03 b4 65 b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b035	0a b4 11 b4 18 b4 1f b4
>b03d	26 b4 2a b4 30 b4 65 b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b045	34 b4 3a b4 40 b4 46 b4
>b04d	4b b4 51 b4 65 b5 65 b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b055	59 b4 5f b4 65 b4 6b b4
>b05d	72 b4 76 b4 7c b4 65 b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b065	80 b4 84 b4 88 b4 8c b4
>b06d	91 b4 95 b4 9d b4 65 b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b075	65 b5 a4 b4 ab b4 b2 b4
>b07d	b9 b4 bd b4 c3 b4 65 b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b085	65 b5 c7 b4 cd b4 d3 b4
>b08d	d8 b4 de b4 65 b5 65 b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b095	e6 b4 ec b4 f2 b4 f8 b4
>b09d	ff b4 03 b5 09 b5 65 b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b0a5	0d b5 11 b5 15 b5 19 b5
>b0ad	1e b5 22 b5 2a b5 65 b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b0b5	65 b5 31 b5 38 b5 3f b5
>b0bd	46 b5 4a b5 50 b5 65 b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b0c5	65 b5 54 b5 5a b5 60 b5
.b0cd					oc_table:
>b0cd	83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b0d1	87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b0d9	85 74 73 62 2e 7a		        oc04:   .text 2*64+5, "tsb.z"
>b0df	85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b0e5	85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b0eb	43 70 68 70				oc08:	.text 1*64+3, "php"
>b0ef	85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b0f5	45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b0fb	c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b0ff	c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b103	c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b107	c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b10c	83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b110	87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b118	86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b11f	85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b125	86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b12c	86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b133	86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b13a	43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b13e	c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b144	45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b14a	c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b14e	c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b154	c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b15a	c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b15e	87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b166	85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b16c	85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b172	85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b178	86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b17f	43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b183	85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b189	45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b18f	c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b193	c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b198	c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b19c	c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1a1	83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b1a5	87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b1ad	86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b1b4	87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b1bc	86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b1c3	86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b1ca	86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b1d1	43 73 65 63				oc38:	.text 1*64+3, "sec"
>b1d5	c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b1db	45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b1e1	c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b1e7	c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b1ed	c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b1f3	c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b1f8	43 72 74 69				oc40:	.text 1*64+3, "rti"
>b1fc	87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b204	85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b20a	85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b210	86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b217	43 70 68 61				oc48:	.text 1*64+3, "pha"
>b21b	85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b221	45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b227	c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b22b	c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b22f	c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b233	c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b238	83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b23c	87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b244	86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b24b	86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b252	86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b259	86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b260	43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b264	c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b26a	43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b26e	c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b274	c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b27a	c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b27f	43 72 74 73				oc60:	.text 1*64+3, "rts"
>b283	87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b28b	85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b291	85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b297	85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b29d	86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b2a4	43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b2a8	85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b2ae	45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b2b4	c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b2ba	c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b2be	c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b2c2	c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b2c7	83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b2cb	87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b2d3	86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b2da	86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b2e1	86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b2e8	86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b2ef	86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b2f6	43 73 65 69				oc78:	.text 1*64+3, "sei"
>b2fa	c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b300	43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b304	c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b30b	c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b311	c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b317	c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b31c	83 62 72 61				oc80:	.text 2*64+3, "bra"
>b320	87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b328	85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b32e	85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b334	85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b33a	43 64 65 79				oc88:	.text 1*64+3, "dey"
>b33e	85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b344	43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b348	c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b34c	c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b350	c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b354	c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b359	83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b35d	87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b365	86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b36c	86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b373	86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b37a	86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b381	86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b388	43 74 79 61				oc98:	.text 1*64+3, "tya"
>b38c	c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b392	43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b396	c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b39a	c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3a0	c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b3a6	c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b3ab	85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b3b1	87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b3b9	85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b3bf	85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b3c5	85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b3cb	85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b3d1	86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b3d8	43 74 61 79				oca8:	.text 1*64+3, "tay"
>b3dc	85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b3e2	43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b3e6	c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b3ea	c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b3ee	c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b3f2	c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b3f7	83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b3fb	87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b403	86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b40a	86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b411	86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b418	86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b41f	86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b426	43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b42a	c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b430	43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b434	c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b43a	c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b440	c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b446	c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b44b	85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b451	87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b459	85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b45f	85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b465	85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b46b	86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b472	43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b476	85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b47c	43 64 65 78				occa:	.text 1*64+3, "dex"
>b480	c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b484	c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b488	c3 64 65 63				occe:	.text 3*64+3, "dec"
>b48c	c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b491	83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b495	87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b49d	86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b4a4	86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b4ab	86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b4b2	86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b4b9	43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b4bd	c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b4c3	43 70 68 78				ocda:	.text 1*64+3, "phx"
>b4c7	c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b4cd	c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b4d3	c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b4d8	85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b4de	87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b4e6	85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b4ec	85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b4f2	85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b4f8	86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b4ff	43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b503	85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b509	43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b50d	c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b511	c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b515	c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b519	c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b51e	83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b522	87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b52a	86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b531	86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b538	86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b53f	86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b546	43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b54a	c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b550	43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b554	c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b55a	c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b560	c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b565	01 3f					oc__:	.text 1, "?"
.b567					disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=46					ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=48					ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=50					ed_flags = editor3  ; Flags used by ed, where
.b567					ed6502:
.b567	a5 18		lda $18		                lda base
.b569	85 33		sta $33		                sta editor3+1
.b56b	a9 0a		lda #$0a	                lda #10
.b56d	85 18		sta $18		                sta base
.b56f	64 2e		stz $2e		                stz ed_head
.b571	64 2f		stz $2f		                stz ed_head+1
.b573	64 30		stz $30		                stz ed_cur
.b575	64 31		stz $31		                stz ed_cur+1
.b577	64 32		stz $32		                stz ed_flags
.b579	20 8d a7	jsr $a78d	                jsr xt_zero
.b57c	20 8d a7	jsr $a78d	                jsr xt_zero             ; ( addr-t u-t )
.b57f	20 5d 89	jsr $895d	                jsr xt_cr
.b582					ed_input_loop:
.b582	a9 81		lda #$81	                lda #%10000001
.b584	14 32		trb $32		                trb ed_flags
.b586	20 61 ba	jsr $ba61	                jsr ed_get_input
.b589	a5 0a		lda $0a		                lda ciblen
.b58b	d0 1f		bne $b5ac	                bne _command_mode
.b58d	ca		dex		                dex
.b58e	ca		dex		                dex                     ; ( addr-t u-t ? )
.b58f	a5 30		lda $30		                lda ed_cur
.b591	95 00		sta $00,x	                sta 0,x
.b593	a5 31		lda $31		                lda ed_cur+1
.b595	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b597	a9 80		lda #$80	                lda #%10000000
.b599	04 32		tsb $32		                tsb ed_flags
.b59b	20 08 98	jsr $9808	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b59e	20 7d ba	jsr $ba7d	                jsr ed_is_valid_line
.b5a1	b0 03		bcs $b5a6	                bcs +
.b5a3	4c 51 ba	jmp $ba51	                jmp ed_error_1drop
.b5a6					+
.b5a6	20 8d a7	jsr $a78d	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b5a9	4c 77 b6	jmp $b677	                jmp _line_number_only_from_external
.b5ac					_command_mode:
.b5ac	20 8d a7	jsr $a78d	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b5af	20 8d a7	jsr $a78d	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b5b2					_prefix_dot:
.b5b2	b2 08		lda ($08)	                lda (cib)
.b5b4	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b5b6	d0 3a		bne $b5f2	                bne _prefix_dollar
.b5b8	20 72 ba	jsr $ba72	                jsr ed_have_text
.b5bb	a5 30		lda $30		                lda ed_cur
.b5bd	95 02		sta $02,x	                sta 2,x
.b5bf	a5 31		lda $31		                lda ed_cur+1
.b5c1	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b5c3	a9 80		lda #$80	                lda #%10000000
.b5c5	04 32		tsb $32		                tsb ed_flags
.b5c7	a5 0a		lda $0a		                lda ciblen
.b5c9	3a		dec a		                dea                     ; sets Z if A was 1
.b5ca	d0 03		bne $b5cf	                bne +
.b5cc	4c 77 b6	jmp $b677	                jmp _line_number_only_from_external
.b5cf					+
.b5cf	ca		dex		                dex
.b5d0	ca		dex		                dex
.b5d1	ca		dex		                dex
.b5d2	ca		dex		                dex
.b5d3	a5 08		lda $08		                lda cib
.b5d5	95 02		sta $02,x	                sta 2,x
.b5d7	a5 09		lda $09		                lda cib+1
.b5d9	95 03		sta $03,x	                sta 3,x
.b5db	a5 0a		lda $0a		                lda ciblen
.b5dd	95 00		sta $00,x	                sta 0,x
.b5df	a5 0b		lda $0b		                lda ciblen+1
.b5e1	95 01		sta $01,x	                sta 1,x
.b5e3	20 fc 97	jsr $97fc	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b5e6	20 93 a1	jsr $a193	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b5e9	20 08 98	jsr $9808	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b5ec	20 93 a1	jsr $a193	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b5ef	4c cf b6	jmp $b6cf	                jmp _check_for_para2
.b5f2					_prefix_dollar:
.b5f2	b2 08		lda ($08)	                lda (cib)
.b5f4	c9 24		cmp #$24	                cmp #'$'
.b5f6	d0 1c		bne $b614	                bne _prefix_percent
.b5f8	20 72 ba	jsr $ba72	                jsr ed_have_text
.b5fb	e8		inx		                inx
.b5fc	e8		inx		                inx                     ; ( addr-t u-t 0 )
.b5fd	20 9f ba	jsr $ba9f	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b600	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b603	a9 80		lda #$80	                lda #%10000000
.b605	04 32		tsb $32		                tsb ed_flags
.b607	a5 0a		lda $0a		                lda ciblen
.b609	3a		dec a		                dea                     ; sets Z if A was 1
.b60a	d0 03		bne $b60f	                bne +
.b60c	4c 77 b6	jmp $b677	                jmp _line_number_only_from_external
.b60f					+
.b60f	a0 01		ldy #$01	                ldy #01
.b611	4c 4b b7	jmp $b74b	                jmp _check_command
.b614					_prefix_percent:
.b614	b2 08		lda ($08)	                lda (cib)
.b616	c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b618	f0 04		beq $b61e	                beq _whole_text
.b61a	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b61c	d0 17		bne $b635	                bne _prefix_semicolon
.b61e					_whole_text:
.b61e	20 72 ba	jsr $ba72	                jsr ed_have_text
.b621	a9 01		lda #$01	                lda #01
.b623	95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b625	74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b627					_semicolon_entry:
.b627	e8		inx		                inx
.b628	e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b629	20 9f ba	jsr $ba9f	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b62c	a9 80		lda #$80	                lda #%10000000
.b62e	04 32		tsb $32		                tsb ed_flags
.b630	a0 01		ldy #$01	                ldy #01
.b632	4c 4b b7	jmp $b74b	                jmp _check_command
.b635					_prefix_semicolon:
.b635	b2 08		lda ($08)	                lda (cib)
.b637	c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b639	d0 0d		bne $b648	                bne _prefix_number
.b63b	20 72 ba	jsr $ba72	                jsr ed_have_text
.b63e	a5 30		lda $30		                lda ed_cur
.b640	95 02		sta $02,x	                sta 2,x
.b642	a5 31		lda $31		                lda ed_cur+1
.b644	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b646	80 df		bra $b627	                bra _semicolon_entry
.b648					_prefix_number:
.b648	20 8d a7	jsr $a78d	                jsr xt_zero
.b64b	20 8d a7	jsr $a78d	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b64e	ca		dex		                dex
.b64f	ca		dex		                dex
.b650	ca		dex		                dex
.b651	ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b652	a5 08		lda $08		                lda cib
.b654	95 02		sta $02,x	                sta 2,x
.b656	a5 09		lda $09		                lda cib+1
.b658	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b65a	a5 0a		lda $0a		                lda ciblen
.b65c	95 00		sta $00,x	                sta 0,x
.b65e	a5 0b		lda $0b		                lda ciblen+1
.b660	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b662	20 a2 a2	jsr $a2a2	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b665	b5 00		lda $00,x	                lda 0,x
.b667	15 01		ora $01,x	                ora 1,x
.b669	d0 24		bne $b68f	                bne _have_unconverted_chars
.b66b	e8		inx		                inx
.b66c	e8		inx		                inx
.b66d	e8		inx		                inx
.b66e	e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b66f	20 7a 8a	jsr $8a7a	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b672	20 68 96	jsr $9668	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b675	e8		inx		                inx
.b676	e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b677					_line_number_only_from_external:
.b677	20 93 a1	jsr $a193	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b67a	20 7d ba	jsr $ba7d	                jsr ed_is_valid_line
.b67d	b0 03		bcs $b682	                bcs +
.b67f	4c 4f ba	jmp $ba4f	                jmp ed_error_2drop
.b682					+
.b682	20 93 a1	jsr $a193	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b685	20 0c bb	jsr $bb0c	                jsr ed_para1_to_cur
.b688	a9 80		lda #$80	                lda #%10000000
.b68a	04 32		tsb $32		                tsb ed_flags
.b68c	4c 2a b9	jmp $b92a	                jmp ed_cmd_p_from_external
.b68f					_have_unconverted_chars:
.b68f	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b692	ca		dex		                dex
.b693	ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b694	a5 0a		lda $0a		                lda ciblen
.b696	95 00		sta $00,x	                sta 0,x
.b698	a5 0b		lda $0b		                lda ciblen+1
.b69a	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b69c	20 c8 8e	jsr $8ec8	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b69f	b5 00		lda $00,x	                lda 0,x
.b6a1	15 01		ora $01,x	                ora 1,x
.b6a3	f0 0e		beq $b6b3	                beq _no_command_yet
.b6a5	8a		txa		                txa
.b6a6	18		clc		                clc
.b6a7	69 0a		adc #$0a	                adc #10
.b6a9	aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b6aa	a9 80		lda #$80	                lda #%10000000
.b6ac	14 32		trb $32		                trb ed_flags
.b6ae	a0 00		ldy #$00	                ldy #00
.b6b0	4c 4b b7	jmp $b74b	                jmp _check_command
.b6b3					_no_command_yet:
.b6b3	e8		inx		                inx
.b6b4	e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b6b5	20 55 a3	jsr $a355	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b6b8	20 68 96	jsr $9668	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b6bb	20 7a 8a	jsr $8a7a	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b6be	b5 00		lda $00,x	                lda 0,x                 ; LSB
.b6c0	95 06		sta $06,x	                sta 6,x
.b6c2	b5 01		lda $01,x	                lda 1,x                 ; MSB
.b6c4	95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b6c6	e8		inx		                inx
.b6c7	e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b6c8	20 7d 9a	jsr $9a7d	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b6cb	a9 80		lda #$80	                lda #%10000000
.b6cd	04 32		tsb $32		                tsb ed_flags
.b6cf					_check_for_para2:
.b6cf	a1 02		lda ($02,x)	                lda (2,x)
.b6d1	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b6d3	f0 0d		beq $b6e2	                beq _got_comma
.b6d5	38		sec		                sec
.b6d6	a5 0a		lda $0a		                lda ciblen
.b6d8	f5 00		sbc $00,x	                sbc 0,x
.b6da	a8		tay		                tay
.b6db	e8		inx		                inx
.b6dc	e8		inx		                inx
.b6dd	e8		inx		                inx
.b6de	e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b6df	4c 4b b7	jmp $b74b	                jmp _check_command
.b6e2					_got_comma:
.b6e2	f6 02		inc $02,x	                inc 2,x
.b6e4	d0 02		bne $b6e8	                bne +
.b6e6	f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b6e8					+
.b6e8	b5 01		lda $01,x	                lda 1,x
.b6ea	f0 02		beq $b6ee	                beq +
.b6ec	d6 01		dec $01,x	                dec 1,x
.b6ee					+
.b6ee	d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b6f0	a1 02		lda ($02,x)	                lda (2,x)
.b6f2	c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b6f4	d0 14		bne $b70a	                bne _para2_not_dollar
.b6f6	38		sec		                sec
.b6f7	a5 0a		lda $0a		                lda ciblen
.b6f9	f5 02		sbc $02,x	                sbc 2,x
.b6fb	a8		tay		                tay
.b6fc	c8		iny		                iny
.b6fd	5a		phy		                phy
.b6fe	8a		txa		                txa
.b6ff	18		clc		                clc
.b700	69 06		adc #$06	                adc #06
.b702	aa		tax		                tax                     ; ( addr-t u-t para1 )
.b703	20 9f ba	jsr $ba9f	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b706	7a		ply		                ply
.b707	4c 4b b7	jmp $b74b	                jmp _check_command
.b70a					_para2_not_dollar:
.b70a	20 55 a3	jsr $a355	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b70d	20 8d a7	jsr $a78d	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b710	20 8d a7	jsr $a78d	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b713	20 42 9b	jsr $9b42	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b716	20 7d 9a	jsr $9a7d	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b719	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b71c	20 55 a3	jsr $a355	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b71f	20 a2 a2	jsr $a2a2	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b722	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b725	20 7d 9a	jsr $9a7d	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b728	20 c8 8e	jsr $8ec8	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b72b	b5 00		lda $00,x	                lda 0,x
.b72d	15 01		ora $01,x	                ora 1,x
.b72f	f0 08		beq $b739	                beq _second_number
.b731	8a		txa		                txa
.b732	18		clc		                clc
.b733	69 0c		adc #$0c	                adc #12
.b735	aa		tax		                tax                     ; back to ( addr-t u-t )
.b736	4c 53 ba	jmp $ba53	                jmp ed_error
.b739					_second_number:
.b739	e8		inx		                inx
.b73a	e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b73b	38		sec		                sec
.b73c	a5 0a		lda $0a		                lda ciblen
.b73e	f5 00		sbc $00,x	                sbc 0,x
.b740	48		pha		                pha
.b741	20 95 a3	jsr $a395	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b744	20 7a 8a	jsr $8a7a	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b747	20 3c 96	jsr $963c	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b74a	7a		ply		                ply
.b74b					_check_command:
.b74b	24 32		bit $32		                bit ed_flags
.b74d	30 08		bmi $b757	                bmi _check_command_have_arg
.b74f	a5 30		lda $30		                lda ed_cur
.b751	95 02		sta $02,x	                sta 2,x
.b753	a5 31		lda $31		                lda ed_cur+1
.b755	95 03		sta $03,x	                sta 3,x
.b757					_check_command_have_arg:
.b757	b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b759	85 24		sta $24		                sta tmp1
.b75b	da		phx		                phx
.b75c	a2 00		ldx #$00	                ldx #00
.b75e					_cmd_loop:
.b75e	bd 37 bb	lda $bb37,x	                lda ed_cmd_list,x
.b761	f0 07		beq $b76a	                beq _illegal_command    ; zero marks end of list
.b763	c5 24		cmp $24		                cmp tmp1
.b765	f0 07		beq $b76e	                beq _found_cmd
.b767	e8		inx		                inx
.b768	80 f4		bra $b75e	                bra _cmd_loop
.b76a					_illegal_command:
.b76a	fa		plx		                plx
.b76b	4c 4f ba	jmp $ba4f	                jmp ed_error_2drop
.b76e					_found_cmd:
.b76e	8a		txa		                txa
.b76f	0a		asl a		                asl
.b770	aa		tax		                tax                     ; X * 2 for table
.b771	7c 42 bb	jmp ($bb42,x)	                jmp (ed_cmd_table,x)
.b774					ed_next_command:
.b774	e8		inx		                inx
.b775	e8		inx		                inx
.b776	e8		inx		                inx
.b777	e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b778					_next_command_empty:
.b778	4c 82 b5	jmp $b582	                jmp ed_input_loop
.b77b					ed_all_done:
.b77b	64 0a		stz $0a		                stz ciblen
.b77d	64 0b		stz $0b		                stz ciblen+1
.b77f	20 95 a3	jsr $a395	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b782	a5 33		lda $33		                lda editor3+1
.b784	85 18		sta $18		                sta base
.b786	60		rts		                rts
.b787					ed_cmd_a:
.b787	fa		plx		                plx
.b788	e8		inx		                inx
.b789	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b78a					ed_entry_cmd_i:
.b78a					ed_cmd_a_have_para:
.b78a	20 d5 ba	jsr $bad5	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b78d	20 5d 89	jsr $895d	                jsr xt_cr
.b790					_next_string_loop:
.b790	20 61 ba	jsr $ba61	                jsr ed_get_input
.b793	b2 08		lda ($08)	                lda (cib)
.b795	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b797	d0 16		bne $b7af	                bne _add_line
.b799	a4 0a		ldy $0a		                ldy ciblen
.b79b	c0 01		cpy #$01	                cpy #01
.b79d	d0 10		bne $b7af	                bne _add_line
.b79f	a4 0b		ldy $0b		                ldy ciblen+1
.b7a1	d0 0c		bne $b7af	                bne _add_line
.b7a3	e8		inx		                inx
.b7a4	e8		inx		                inx
.b7a5	a9 40		lda #$40	                lda #%01000000
.b7a7	04 32		tsb $32		                tsb ed_flags
.b7a9	20 5d 89	jsr $895d	                jsr xt_cr
.b7ac	4c 82 b5	jmp $b582	                jmp ed_input_loop
.b7af					_add_line:
.b7af	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b7b2	20 6c 91	jsr $916c	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b7b5	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b7b8	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b7bb	20 68 87	jsr $8768	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b7be	20 72 a3	jsr $a372	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b7c1	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b7c4	20 72 a1	jsr $a172	                jsr xt_store            ; ! ( addr-t u-t here )
.b7c7	20 6c 91	jsr $916c	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b7ca	a5 00		lda $00		                lda cp
.b7cc	18		clc		                clc
.b7cd	69 04		adc #$04	                adc #04
.b7cf	85 00		sta $00		                sta cp
.b7d1	90 02		bcc $b7d5	                bcc +
.b7d3	e6 01		inc $01		                inc cp+1
.b7d5					+
.b7d5	e6 30		inc $30		                inc ed_cur
.b7d7	d0 02		bne $b7db	                bne +
.b7d9	e6 31		inc $31		                inc ed_cur+1
.b7db					+
.b7db	20 6c 91	jsr $916c	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b7de	20 a9 8d	jsr $8da9	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b7e1	ca		dex		                dex
.b7e2	ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b7e3	a5 08		lda $08		                lda cib
.b7e5	95 00		sta $00,x	                sta 0,x
.b7e7	a5 09		lda $09		                lda cib+1
.b7e9	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b7eb	20 93 a1	jsr $a193	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b7ee	ca		dex		                dex
.b7ef	ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b7f0	a5 0a		lda $0a		                lda ciblen
.b7f2	95 00		sta $00,x	                sta 0,x
.b7f4	a5 0b		lda $0b		                lda ciblen+1
.b7f6	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b7f8	20 bc 95	jsr $95bc	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b7fb	18		clc		                clc
.b7fc	a5 00		lda $00		                lda cp
.b7fe	65 0a		adc $0a		                adc ciblen
.b800	85 00		sta $00		                sta cp
.b802	90 06		bcc $b80a	                bcc +
.b804	a5 01		lda $01		                lda cp+1
.b806	65 0b		adc $0b		                adc ciblen+1
.b808	85 01		sta $01		                sta cp+1
.b80a					+
.b80a	20 7e 98	jsr $987e	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b80d	20 72 a1	jsr $a172	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b810	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+
.b813	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b816	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b819	a5 0a		lda $0a		                lda ciblen
.b81b	95 02		sta $02,x	                sta 2,x
.b81d	a5 0b		lda $0b		                lda ciblen+1
.b81f	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b821	20 72 a1	jsr $a172	                jsr xt_store            ; ! ( addr-t u-t here )
.b824	20 5d 89	jsr $895d	                jsr xt_cr
.b827	4c 90 b7	jmp $b790	                jmp _next_string_loop
.b82a					ed_cmd_d:
.b82a	fa		plx		                plx
.b82b	20 72 ba	jsr $ba72	                jsr ed_have_text
.b82e	20 c7 ba	jsr $bac7	                jsr ed_no_line_zero
.b831	b5 00		lda $00,x	                lda 0,x
.b833	15 01		ora $01,x	                ora 1,x
.b835	d0 08		bne $b83f	                bne +
.b837	20 7e 98	jsr $987e	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b83a	20 7c b8	jsr $b87c	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b83d	80 33		bra $b872	                bra _cmd_d_done
.b83f					+
.b83f	20 7d ba	jsr $ba7d	                jsr ed_is_valid_line      ; result is in C flag
.b842	b0 03		bcs $b847	                bcs _cmd_d_loop
.b844	4c 4f ba	jmp $ba4f	                jmp ed_error_2drop
.b847					_cmd_d_loop:
.b847	20 9d a3	jsr $a39d	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b84a	20 57 91	jsr $9157	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b84d	b5 00		lda $00,x	                lda 0,x
.b84f	15 01		ora $01,x	                ora 1,x
.b851	d0 0d		bne $b860	                bne _cmd_d_done_with_flag
.b853	e8		inx		                inx
.b854	e8		inx		                inx                     ; Get rid of the flag from >
.b855	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b858	20 7c b8	jsr $b87c	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b85b	20 fc 97	jsr $97fc	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b85e	80 e7		bra $b847	                bra _cmd_d_loop
.b860					_cmd_d_done_with_flag:
.b860	e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b861	e8		inx		                inx
.b862	b5 02		lda $02,x	                lda 2,x
.b864	d0 02		bne $b868	                bne +
.b866	d6 03		dec $03,x	                dec 3,x
.b868					+
.b868	d6 02		dec $02,x	                dec 2,x
.b86a	b5 02		lda $02,x	                lda 2,x
.b86c	85 30		sta $30		                sta ed_cur
.b86e	b5 03		lda $03,x	                lda 3,x
.b870	85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b872					_cmd_d_done:
.b872	a9 40		lda #$40	                lda #%01000000
.b874	04 32		tsb $32		                tsb ed_flags
.b876	20 5d 89	jsr $895d	                jsr xt_cr
.b879	4c 74 b7	jmp $b774	                jmp ed_next_command
.b87c					_cmd_d_common:
.b87c	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b87f	20 d5 ba	jsr $bad5	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b882	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b885	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b888	20 fc 97	jsr $97fc	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b88b	20 d5 ba	jsr $bad5	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b88e	20 72 a1	jsr $a172	                jsr xt_store            ; ! ( addr-t u-t )
.b891	60		rts		                rts
.b892					ed_cmd_equ:
.b892	fa		plx		                plx
.b893	a5 2e		lda $2e		                lda ed_head
.b895	05 2f		ora $2f		                ora ed_head+1
.b897	d0 08		bne $b8a1	                bne _cmd_equ_have_text
.b899	ca		dex		                dex
.b89a	ca		dex		                dex
.b89b	74 00		stz $00,x	                stz 0,x
.b89d	74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b89f	80 21		bra $b8c2	                bra _cmd_equ_done
.b8a1					_cmd_equ_have_text:
.b8a1	20 c7 ba	jsr $bac7	                jsr ed_no_line_zero
.b8a4	24 32		bit $32		                bit ed_flags
.b8a6	30 0c		bmi $b8b4	                bmi _cmd_equ_have_para
.b8a8	ca		dex		                dex
.b8a9	ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b8aa	a5 30		lda $30		                lda ed_cur
.b8ac	95 00		sta $00,x	                sta 0,x
.b8ae	a5 31		lda $31		                lda ed_cur+1
.b8b0	95 01		sta $01,x	                sta 1,x
.b8b2	80 0e		bra $b8c2	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b8b4					_cmd_equ_have_para:
.b8b4	b5 00		lda $00,x	                lda 0,x
.b8b6	15 01		ora $01,x	                ora 1,x
.b8b8	d0 05		bne $b8bf	                bne _cmd_equ_two_paras
.b8ba	20 7e 98	jsr $987e	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b8bd	80 03		bra $b8c2	                bra _cmd_equ_done
.b8bf					_cmd_equ_two_paras:
.b8bf	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b8c2					_cmd_equ_done:
.b8c2	20 5d 89	jsr $895d	                jsr xt_cr               ; number goes on new line
.b8c5	20 13 a5	jsr $a513	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b8c8	20 5d 89	jsr $895d	                jsr xt_cr
.b8cb	4c 74 b7	jmp $b774	                jmp ed_next_command
.b8ce					ed_cmd_f:
.b8ce	fa		plx		                plx
.b8cf	24 32		bit $32		                bit ed_flags
.b8d1	30 17		bmi $b8ea	                bmi _cmd_f_have_para
.b8d3	20 5d 89	jsr $895d	                jsr xt_cr
.b8d6	20 55 a3	jsr $a355	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b8d9	20 42 9b	jsr $9b42	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b8dc	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b8df	20 13 a5	jsr $a513	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b8e2	20 68 96	jsr $9668	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b8e5	20 7d 9a	jsr $9a7d	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b8e8	80 11		bra $b8fb	                bra _cmd_f_done
.b8ea					_cmd_f_have_para:
.b8ea	20 7e 98	jsr $987e	                jsr xt_over
.b8ed	20 5d 89	jsr $895d	                jsr xt_cr
.b8f0	20 13 a5	jsr $a513	                jsr xt_u_dot
.b8f3	b5 02		lda $02,x	                lda 2,x
.b8f5	95 06		sta $06,x	                sta 6,x
.b8f7	b5 03		lda $03,x	                lda 3,x
.b8f9	95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b8fb					_cmd_f_done:
.b8fb	20 5d 89	jsr $895d	                jsr xt_cr
.b8fe	4c 74 b7	jmp $b774	                jmp ed_next_command
.b901					ed_cmd_i:
.b901	fa		plx		                plx
.b902	e8		inx		                inx
.b903	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b904	24 32		bit $32		                bit ed_flags
.b906	30 08		bmi $b910	                bmi _cmd_i_have_para
.b908	a5 30		lda $30		                lda ed_cur
.b90a	95 00		sta $00,x	                sta 0,x
.b90c	a5 31		lda $31		                lda ed_cur+1
.b90e	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b910					_cmd_i_have_para:
.b910	b5 00		lda $00,x	                lda 0,x
.b912	15 01		ora $01,x	                ora 1,x
.b914	f0 09		beq $b91f	                beq _cmd_i_done
.b916	20 fc 97	jsr $97fc	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b919	20 8d a7	jsr $a78d	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b91c	20 12 95	jsr $9512	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b91f					_cmd_i_done:
.b91f	4c 8a b7	jmp $b78a	                jmp ed_entry_cmd_i
.b922					ed_cmd_n:
.b922	fa		plx		                plx
.b923	a9 01		lda #$01	                lda #%00000001
.b925	04 32		tsb $32		                tsb ed_flags
.b927	80 05		bra $b92e	                bra ed_cmd_p_entry_for_cmd_n
.b929					ed_cmd_p:
.b929	fa		plx		                plx
.b92a					ed_cmd_p_from_external:
.b92a	a9 01		lda #$01	                lda #%00000001
.b92c	14 32		trb $32		                trb ed_flags
.b92e					ed_cmd_p_entry_for_cmd_n:
.b92e	20 72 ba	jsr $ba72	                jsr ed_have_text
.b931	20 c7 ba	jsr $bac7	                jsr ed_no_line_zero
.b934	20 5d 89	jsr $895d	                jsr xt_cr
.b937	b5 00		lda $00,x	                lda 0,x
.b939	15 01		ora $01,x	                ora 1,x
.b93b	d0 10		bne $b94d	                bne _cmd_p_loop
.b93d	b5 02		lda $02,x	                lda 2,x
.b93f	85 30		sta $30		                sta ed_cur
.b941	b5 03		lda $03,x	                lda 3,x
.b943	85 31		sta $31		                sta ed_cur+1
.b945	20 7e 98	jsr $987e	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b948	20 76 b9	jsr $b976	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b94b	80 26		bra $b973	                bra _cmd_p_all_done
.b94d					_cmd_p_loop:
.b94d	20 9d a3	jsr $a39d	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b950	20 57 91	jsr $9157	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b953	b5 00		lda $00,x	                lda 0,x
.b955	15 01		ora $01,x	                ora 1,x
.b957	d0 10		bne $b969	                bne _cmd_p_done
.b959	e8		inx		                inx
.b95a	e8		inx		                inx                     ; Get rid of the flag from >
.b95b	20 7e 98	jsr $987e	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b95e	20 76 b9	jsr $b976	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b961	f6 02		inc $02,x	                inc 2,x
.b963	d0 02		bne $b967	                bne +
.b965	f6 03		inc $03,x	                inc 3,x
.b967					+
.b967	80 e4		bra $b94d	                bra _cmd_p_loop
.b969					_cmd_p_done:
.b969	e8		inx		                inx
.b96a	e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b96b	b5 00		lda $00,x	                lda 0,x
.b96d	85 30		sta $30		                sta ed_cur
.b96f	b5 01		lda $01,x	                lda 1,x
.b971	85 31		sta $31		                sta ed_cur+1
.b973					_cmd_p_all_done:
.b973	4c 74 b7	jmp $b774	                jmp ed_next_command
.b976					_cmd_p_common:
.b976	a5 32		lda $32		                lda ed_flags
.b978	4a		lsr a		                lsr                     ; bit 0 now in carry
.b979	90 0b		bcc $b986	                bcc _cmd_p_common_no_num
.b97b	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b97e	20 13 a5	jsr $a513	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b981	a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b983	20 f0 8d	jsr $8df0	                jsr emit_a
.b986					_cmd_p_common_no_num:
.b986	20 d5 ba	jsr $bad5	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b989	20 15 bb	jsr $bb15	                jsr ed_print_addr
.b98c	60		rts		                rts
.b98d					ed_cmd_q:
.b98d	fa		plx		                plx
.b98e	24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b990	50 03		bvc $b995	                bvc +
.b992	4c 4f ba	jmp $ba4f	                jmp ed_error_2drop
.b995					+
.b995	4c 7b b7	jmp $b77b	                jmp ed_all_done            ; can't fall thru because of PLX
.b998					ed_cmd_qq:
.b998	fa		plx		                plx
.b999	4c 7b b7	jmp $b77b	                jmp ed_all_done
.b99c					ed_cmd_w:
.b99c	fa		plx		                plx
.b99d	20 72 ba	jsr $ba72	                jsr ed_have_text
.b9a0	24 32		bit $32		                bit ed_flags
.b9a2	30 13		bmi $b9b7	                bmi _cmd_w_have_para
.b9a4	b5 06		lda $06,x	                lda 6,x
.b9a6	15 07		ora $07,x	                ora 7,x
.b9a8	d0 03		bne $b9ad	                bne +
.b9aa	4c 4f ba	jmp $ba4f	                jmp ed_error_2drop
.b9ad					+
.b9ad	b5 06		lda $06,x	                lda 6,x
.b9af	95 02		sta $02,x	                sta 2,x
.b9b1	b5 07		lda $07,x	                lda 7,x
.b9b3	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b9b5	80 08		bra $b9bf	                bra _cmd_w_para_ready
.b9b7					_cmd_w_have_para:
.b9b7	b5 02		lda $02,x	                lda 2,x
.b9b9	95 06		sta $06,x	                sta 6,x
.b9bb	b5 03		lda $03,x	                lda 3,x
.b9bd	95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b9bf					_cmd_w_para_ready:
.b9bf	a9 2e		lda #$2e	                lda #<ed_head
.b9c1	95 00		sta $00,x	                sta 0,x
.b9c3	a9 00		lda #$00	                lda #>ed_head
.b9c5	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.b9c7	20 7e 98	jsr $987e	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.b9ca	20 55 a3	jsr $a355	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.b9cd					_cmd_w_loop:
.b9cd	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.b9d0	b5 00		lda $00,x	                lda 0,x
.b9d2	15 01		ora $01,x	                ora 1,x
.b9d4	f0 55		beq $ba2b	                beq _cmd_w_eol
.b9d6	20 9d a3	jsr $a39d	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.b9d9	20 87 a4	jsr $a487	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.b9dc	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.b9df	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.b9e2	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.b9e5	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.b9e8	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.b9eb	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.b9ee	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.b9f1	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.b9f4	20 68 96	jsr $9668	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.b9f7	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.b9fa	20 42 9b	jsr $9b42	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.b9fd	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba00	20 55 a3	jsr $a355	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba03	20 bc 95	jsr $95bc	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba06	20 7d 9a	jsr $9a7d	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba09	20 0d a4	jsr $a40d	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba0c	20 68 96	jsr $9668	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba0f	20 ce 99	jsr $99ce	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba12	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba15	ca		dex		                dex
.ba16	ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba17	a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba19	95 00		sta $00,x	                sta 0,x
.ba1b	74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba1d	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba20	20 72 a1	jsr $a172	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba23	20 08 98	jsr $9808	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba26	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba29	80 a2		bra $b9cd	                bra _cmd_w_loop
.ba2b					_cmd_w_eol:
.ba2b	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba2e	20 7d 9a	jsr $9a7d	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba31	20 4a 95	jsr $954a	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba34	b5 00		lda $00,x	                lda 0,x
.ba36	95 04		sta $04,x	                sta 4,x
.ba38	b5 01		lda $01,x	                lda 1,x
.ba3a	95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba3c	20 5d 89	jsr $895d	                jsr xt_cr
.ba3f	20 a9 8d	jsr $8da9	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba42	20 13 a5	jsr $a513	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba45	20 5d 89	jsr $895d	                jsr xt_cr
.ba48	a9 40		lda #$40	                lda #%01000000
.ba4a	14 32		trb $32		                trb ed_flags
.ba4c	4c 74 b7	jmp $b774	                jmp ed_next_command
.ba4f					ed_error_2drop:
.ba4f	e8		inx		                inx
.ba50	e8		inx		                inx                     ; drop through to _error_1drop
.ba51					ed_error_1drop:
.ba51	e8		inx		                inx
.ba52	e8		inx		                inx                     ; drop through to _error
.ba53					ed_error:
.ba53	20 5d 89	jsr $895d	                jsr xt_cr
.ba56	a9 3f		lda #$3f	                lda #'?'
.ba58	20 f0 8d	jsr $8df0	                jsr emit_a
.ba5b	20 5d 89	jsr $895d	                jsr xt_cr
.ba5e	4c 82 b5	jmp $b582	                jmp ed_input_loop
.ba61					ed_get_input:
.ba61	20 e3 9a	jsr $9ae3	                jsr xt_refill           ;  ( addr-t u-t f )
.ba64	b5 00		lda $00,x	                lda 0,x
.ba66	15 01		ora $01,x	                ora 1,x
.ba68	d0 05		bne $ba6f	                bne +
.ba6a	7a		ply		                ply
.ba6b	7a		ply		                ply
.ba6c	4c 51 ba	jmp $ba51	                jmp ed_error_1drop
.ba6f					+
.ba6f	e8		inx		                inx
.ba70	e8		inx		                inx
.ba71	60		rts		                rts
.ba72					ed_have_text:
.ba72	a5 2e		lda $2e		                lda ed_head
.ba74	05 2f		ora $2f		                ora ed_head+1
.ba76	d0 04		bne $ba7c	                bne +
.ba78	7a		ply		                ply
.ba79	7a		ply		                ply
.ba7a	80 d7		bra $ba53	                bra ed_error
.ba7c					+
.ba7c	60		rts		                rts
.ba7d					ed_is_valid_line:
.ba7d	38		sec		                sec                             ; default is legal line number
.ba7e	b5 00		lda $00,x	                lda 0,x
.ba80	15 01		ora $01,x	                ora 1,x
.ba82	f0 19		beq $ba9d	                beq _is_valid_line_nope_zero    ; ( n )
.ba84	20 a9 8d	jsr $8da9	                jsr xt_dup                      ; DUP ( n n )
.ba87	20 9f ba	jsr $ba9f	                jsr ed_last_line                  ; ( n n last )
.ba8a	20 93 a1	jsr $a193	                jsr xt_swap                     ; SWAP ( n last n )
.ba8d	20 62 93	jsr $9362	                jsr xt_less_than                ; < ( n f )
.ba90	b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ba92	15 01		ora $01,x	                ora 1,x
.ba94	d0 05		bne $ba9b	                bne _is_valid_line_too_small
.ba96	e8		inx		                inx
.ba97	e8		inx		                inx                     ; DROP flag ( n )
.ba98	38		sec		                sec                     ; Who knows what's happened to C by now
.ba99	80 03		bra $ba9e	                bra _is_valid_line_done ; only one exit from this routine
.ba9b					_is_valid_line_too_small:
.ba9b	e8		inx		                inx
.ba9c	e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ba9d					_is_valid_line_nope_zero:
.ba9d	18		clc		                clc                     ; drop through to _is_valid_line_done
.ba9e					_is_valid_line_done:
.ba9e	60		rts		                rts
.ba9f					ed_last_line:
.ba9f	64 24		stz $24		                stz tmp1
.baa1	64 25		stz $25		                stz tmp1+1
.baa3	ca		dex		                dex
.baa4	ca		dex		                dex                     ; ( ? )
.baa5	a9 2e		lda #$2e	                lda #<ed_head
.baa7	95 00		sta $00,x	                sta 0,x
.baa9	a9 00		lda #$00	                lda #>ed_head
.baab	95 01		sta $01,x	                sta 1,x                 ; ( addr )
.baad					_last_line_loop:
.baad	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; ( addr | 0 )
.bab0	b5 00		lda $00,x	                lda 0,x
.bab2	15 01		ora $01,x	                ora 1,x
.bab4	f0 08		beq $babe	                beq _last_line_done
.bab6	e6 24		inc $24		                inc tmp1
.bab8	d0 02		bne $babc	                bne +
.baba	e6 25		inc $25		                inc tmp1+1
.babc					+
.babc	80 ef		bra $baad	                bra _last_line_loop
.babe					_last_line_done:
.babe	a5 24		lda $24		                lda tmp1
.bac0	95 00		sta $00,x	                sta 0,x
.bac2	a5 25		lda $25		                lda tmp1+1
.bac4	95 01		sta $01,x	                sta 1,x                 ; ( u )
.bac6	60		rts		                rts
.bac7					ed_no_line_zero:
.bac7	b5 02		lda $02,x	                lda 2,x
.bac9	15 03		ora $03,x	                ora 3,x
.bacb	d0 07		bne $bad4	                bne _no_line_zero_done
.bacd	24 32		bit $32		                bit ed_flags
.bacf	10 03		bpl $bad4	                bpl _no_line_zero_done
.bad1	4c 4f ba	jmp $ba4f	                jmp ed_error_2drop
.bad4					_no_line_zero_done:
.bad4	60		rts		                rts
.bad5					ed_num_to_addr:
.bad5	ca		dex		                dex
.bad6	ca		dex		                dex                     ; ( u ? )
.bad7	a9 2e		lda #$2e	                lda #<ed_head
.bad9	95 00		sta $00,x	                sta 0,x
.badb	a9 00		lda #$00	                lda #>ed_head
.badd	95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.badf	b5 02		lda $02,x	                lda 2,x
.bae1	15 03		ora $03,x	                ora 3,x
.bae3	d0 05		bne $baea	                bne _num_to_addr_loop
.bae5	20 3c 96	jsr $963c	                jsr xt_nip              ; ( addr-h )
.bae8	80 21		bra $bb0b	                bra _num_to_addr_done
.baea					_num_to_addr_loop:
.baea	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; @ ( u addr1 )
.baed	b5 00		lda $00,x	                lda 0,x
.baef	15 01		ora $01,x	                ora 1,x
.baf1	d0 05		bne $baf8	                bne +
.baf3	20 3c 96	jsr $963c	                jsr xt_nip              ; NIP ( addr1 )
.baf6	80 13		bra $bb0b	                bra _num_to_addr_done
.baf8					+
.baf8	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( addr1 u )
.bafb	20 fc 97	jsr $97fc	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bafe	b5 00		lda $00,x	                lda 0,x
.bb00	15 01		ora $01,x	                ora 1,x
.bb02	f0 05		beq $bb09	                beq _num_to_addr_finished
.bb04	20 93 a1	jsr $a193	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb07	80 e1		bra $baea	                bra _num_to_addr_loop
.bb09					_num_to_addr_finished:
.bb09	e8		inx		                inx
.bb0a	e8		inx		                inx                     ; ( addr )
.bb0b					_num_to_addr_done:
.bb0b	60		rts		                rts
.bb0c					ed_para1_to_cur:
.bb0c	b5 02		lda $02,x	                lda 2,x
.bb0e	85 30		sta $30		                sta ed_cur
.bb10	b5 03		lda $03,x	                lda 3,x
.bb12	85 31		sta $31		                sta ed_cur+1
.bb14	60		rts		                rts
.bb15					ed_print_addr:
.bb15	20 08 98	jsr $9808	                jsr xt_one_plus
.bb18	20 08 98	jsr $9808	                jsr xt_one_plus         ; ( addr+2 )
.bb1b	20 a9 8d	jsr $8da9	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb1e	20 08 98	jsr $9808	                jsr xt_one_plus
.bb21	20 08 98	jsr $9808	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb24	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; ( addr+2 u-s )
.bb27	20 93 a1	jsr $a193	                jsr xt_swap             ; ( u-s addr+2 )
.bb2a	20 7a 8f	jsr $8f7a	                jsr xt_fetch            ; ( u-s addr-s )
.bb2d	20 93 a1	jsr $a193	                jsr xt_swap             ; ( addr-s u-s )
.bb30	20 e8 a4	jsr $a4e8	                jsr xt_type
.bb33	20 5d 89	jsr $895d	                jsr xt_cr
.bb36	60		rts		                rts
>bb37	61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb3f	71 51 00
.bb42					ed_cmd_table:
>bb42	87 b7 ce b8 01 b9 2a b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bb4a	29 b9 22 b9
>bb4e	92 b8 9c b9 8d b9 98 b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bb56					ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bb56					forth_words_start:
>bb56	20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb5e	61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb6e	74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bb7e	20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bb8e	20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bb9e	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bbae	2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bbbe	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bbce	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bbde	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bbee	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bbfe	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc0e	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc1e	65 78 69 74 29 20 63 72 20
.bc27					forth_words_end:
.bc27					user_words_start:
>bc27	20 20				.binary "user_words.asc"
.bc29					user_words_end:

;******  Processing file: platform/../headers.asm

.bc29					dictionary_start:
.bc29					nt_drop:
>bc29	04 10				        .byte 4, UF
>bc2b	35 bc 28 8d 2d 8d		        .word nt_dup, xt_drop, z_drop
>bc31	64 72 6f 70			        .text "drop"
.bc35					nt_dup:
>bc35	03 10				        .byte 3, UF
>bc37	40 bc a9 8d b6 8d		        .word nt_swap, xt_dup, z_dup
>bc3d	64 75 70			        .text "dup"
.bc40					nt_swap:
>bc40	04 10				        .byte 4, UF
>bc42	4c bc 93 a1 a6 a1		        .word nt_store, xt_swap, z_swap
>bc48	73 77 61 70			        .text "swap"
.bc4c					nt_store:
>bc4c	01 10				        .byte 1, UF
>bc4e	55 bc 72 a1 87 a1		        .word nt_fetch, xt_store, z_store
>bc54	21				        .text "!"
.bc55					nt_fetch:
>bc55	01 10				        .byte 1, UF
>bc57	5e bc 7a 8f 8c 8f		        .word nt_over, xt_fetch, z_fetch
>bc5d	40				        .text "@"
.bc5e					nt_over:
>bc5e	04 10				        .byte 4, UF
>bc60	6a bc 7e 98 8b 98		        .word nt_to_r, xt_over, z_over
>bc66	6f 76 65 72			        .text "over"
.bc6a					nt_to_r:
>bc6a	02 11				        .byte 2, CO+UF ; native is special case
>bc6c	74 bc 55 a3 68 a3		        .word nt_r_from, xt_to_r, z_to_r
>bc72	3e 72				        .text ">r"
.bc74					nt_r_from:
>bc74	02 01				        .byte 2, CO    ; native is special case
>bc76	7e bc 7d 9a 8d 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bc7c	72 3e				        .text "r>"
.bc7e					nt_r_fetch:
>bc7e	02 01				        .byte 2, CO    ; native is special case
>bc80	88 bc 68 9a 7c 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bc86	72 40				        .text "r@"
.bc88					nt_nip:
>bc88	03 10				        .byte 3, UF
>bc8a	93 bc 3c 96 49 96		        .word nt_rot, xt_nip, z_nip
>bc90	6e 69 70			        .text "nip"
.bc93					nt_rot:
>bc93	03 10				        .byte 3, UF
>bc95	9e bc 42 9b 5d 9b		        .word nt_not_rote, xt_rot, z_rot
>bc9b	72 6f 74			        .text "rot"
.bc9e					nt_not_rote:
>bc9e	04 10				        .byte 4, UF
>bca0	aa bc 68 96 83 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bca6	2d 72 6f 74			        .text "-rot"
.bcaa					nt_tuck:
>bcaa	04 10				        .byte 4, UF
>bcac	b6 bc 72 a3 8b a3		        .word nt_comma, xt_tuck, z_tuck
>bcb2	74 75 63 6b			        .text "tuck"
.bcb6					nt_comma:
>bcb6	01 10				        .byte 1, UF
>bcb8	bf bc 68 87 81 87		        .word nt_c_fetch, xt_comma, z_comma
>bcbe	2c				        .text ","
.bcbf					nt_c_fetch:
>bcbf	02 10				        .byte 2, UF
>bcc1	c9 bc 05 86 0e 86		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bcc7	63 40				        .text "c@"
.bcc9					nt_c_store:
>bcc9	02 10				        .byte 2, UF
>bccb	d3 bc 0f 86 1a 86		        .word nt_plus_store, xt_c_store, z_c_store
>bcd1	63 21				        .text "c!"
.bcd3					nt_plus_store:
>bcd3	02 10				        .byte 2, UF
>bcd5	dd bc e1 99 00 9a		        .word nt_execute, xt_plus_store, z_plus_store
>bcdb	2b 21				        .text "+!"
.bcdd					nt_execute:
>bcdd	07 10				        .byte 7, UF
>bcdf	ec bc 37 8f 3d 8f		        .word nt_emit, xt_execute, z_execute
>bce5	65 78 65 63 75 74 65		        .text "execute"
.bcec					nt_emit:
>bcec	04 18				        .byte 4, NN+UF
>bcee	f8 bc e9 8d f3 8d		        .word nt_type, xt_emit, z_emit
>bcf4	65 6d 69 74			        .text "emit"
.bcf8					nt_type:
>bcf8	04 10				        .byte 4, UF
>bcfa	04 bd e8 a4 12 a5		        .word nt_dot, xt_type, z_type
>bd00	74 79 70 65			        .text "type"
.bd04					nt_dot:
>bd04	01 10				        .byte 1, UF
>bd06	0d bd 30 8c 51 8c		        .word nt_u_dot, xt_dot, z_dot
>bd0c	2e				        .text "."
.bd0d					nt_u_dot:
>bd0d	02 10				        .byte 2, UF
>bd0f	17 bd 13 a5 1e a5		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd15	75 2e				        .text "u."
.bd17					nt_u_dot_r:
>bd17	03 10				        .byte 3, UF
>bd19	22 bd 1f a5 40 a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd1f	75 2e 72			        .text "u.r"
.bd22					nt_dot_r:
>bd22	02 10				        .byte 2, UF
>bd24	2c bd 6c 8c 99 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd2a	2e 72				        .text ".r"
.bd2c					nt_d_dot:
>bd2c	02 10				        .byte 2, UF
>bd2e	36 bd de 8c fc 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd34	64 2e				        .text "d."
.bd36					nt_d_dot_r:
>bd36	03 10				        .byte 3, UF
>bd38	41 bd fd 8c 27 8d		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd3e	64 2e 72			        .text "d.r"
.bd41					nt_ud_dot:
>bd41	03 10				        .byte 3, UF
>bd43	4c bd 6d a5 7f a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd49	75 64 2e			        .text "ud."
.bd4c					nt_ud_dot_r:
>bd4c	04 10				        .byte 4, UF
>bd4e	58 bd 80 a5 9e a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd54	75 64 2e 72			        .text "ud.r"
.bd58					nt_question:
>bd58	01 00				        .byte 1, 0
>bd5a	61 bd 4d 9a 53 9a		        .word nt_false, xt_question, z_question
>bd60	3f				        .text "?"
.bd61					nt_false:
>bd61	05 00				        .byte 5, 0
>bd63	6e bd 73 8f 79 8f		        .word nt_true, xt_false, z_false
>bd69	66 61 6c 73 65			        .text "false"
.bd6e					nt_true:
>bd6e	04 00				        .byte 4, 0
>bd70	7a bd 69 a3 71 a3		        .word nt_space, xt_true, z_true
>bd76	74 72 75 65			        .text "true"
.bd7a					nt_space:
>bd7a	05 00				        .byte 5, 0
>bd7c	87 bd 09 a1 0e a1		        .word nt_zero, xt_space, z_space
>bd82	73 70 61 63 65			        .text "space"
.bd87					nt_zero:
>bd87	01 00				        .byte 1, 0
>bd89	90 bd 8d a7 93 a7		        .word nt_one, xt_zero, z_zero
>bd8f	30				        .text "0"
.bd90					nt_one:
>bd90	01 00				        .byte 1, 0
>bd92	99 bd f3 97 fb 97		        .word nt_two, xt_one, z_one
>bd98	31				        .text "1"
.bd99					nt_two:
>bd99	01 00				        .byte 1, 0
>bd9b	a2 bd 8c a3 94 a3		        .word nt_two_dup, xt_two, z_two
>bda1	32				        .text "2"
.bda2					nt_two_dup:
>bda2	04 10				        .byte 4, UF
>bda4	ae bd 9d a3 b4 a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bdaa	32 64 75 70			        .text "2dup"
.bdae					nt_question_dup:
>bdae	04 10				        .byte 4, UF
>bdb0	ba bd 54 9a 67 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bdb6	3f 64 75 70			        .text "?dup"
.bdba					nt_plus:
>bdba	01 10				        .byte 1, UF
>bdbc	c3 bd ce 99 e0 99		        .word nt_minus, xt_plus, z_plus
>bdc2	2b				        .text "+"
.bdc3					nt_minus:
>bdc3	01 10				        .byte 1, UF
>bdc5	cc bd 4a 95 5c 95		        .word nt_one_minus, xt_minus, z_minus
>bdcb	2d				        .text "-"
.bdcc					nt_one_minus:
>bdcc	02 10				        .byte 2, UF
>bdce	d6 bd fc 97 07 98		        .word nt_one_plus, xt_one_minus, z_one_minus
>bdd4	31 2d				        .text "1-"
.bdd6					nt_one_plus:
>bdd6	02 10				        .byte 2, UF
>bdd8	e0 bd 08 98 11 98		        .word nt_two_star, xt_one_plus, z_one_plus
>bdde	31 2b				        .text "1+"
.bde0					nt_two_star:
>bde0	02 10				        .byte 2, UF
>bde2	ea bd 35 a4 3c a4		        .word nt_two_slash, xt_two_star, z_two_star
>bde8	32 2a				        .text "2*"
.bdea					nt_two_slash:
>bdea	02 10				        .byte 2, UF
>bdec	f4 bd 2a a4 34 a4		        .word nt_abs, xt_two_slash, z_two_slash
>bdf2	32 2f				        .text "2/"
.bdf4					nt_abs:
>bdf4	03 10				        .byte 3, UF
>bdf6	ff bd 39 81 4d 81		        .word nt_dabs, xt_abs, z_abs
>bdfc	61 62 73			        .text "abs"
.bdff					nt_dabs:
>bdff	04 10				        .byte 4, UF
>be01	0b be 80 8a 9e 8a		        .word nt_and, xt_dabs, z_dabs
>be07	64 61 62 73			        .text "dabs"
.be0b					nt_and:
>be0b	03 10				        .byte 3, UF
>be0d	16 be 3e 83 4f 83		        .word nt_or, xt_and, z_and
>be13	61 6e 64			        .text "and"
.be16					nt_or:
>be16	02 10				        .byte 2, UF
>be18	20 be 1e 98 2f 98		        .word nt_xor, xt_or, z_or
>be1e	6f 72				        .text "or"
.be20					nt_xor:
>be20	03 10				        .byte 3, UF
>be22	2b be 7b a7 8c a7		        .word nt_rshift, xt_xor, z_xor
>be28	78 6f 72			        .text "xor"
.be2b					nt_rshift:
>be2b	06 10				        .byte 6, UF
>be2d	39 be 5e 9b 71 9b		        .word nt_lshift, xt_rshift, z_rshift
>be33	72 73 68 69 66 74		        .text "rshift"
.be39					nt_lshift:
>be39	06 10				        .byte 6, UF
>be3b	47 be 74 94 87 94		        .word nt_pick, xt_lshift, z_lshift
>be41	6c 73 68 69 66 74		        .text "lshift"
.be47					nt_pick:
>be47	04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be49	53 be bd 99 cd 99		        .word nt_char, xt_pick, z_pick
>be4f	70 69 63 6b			        .text "pick"
.be53					nt_char:
>be53	04 00				        .byte 4, 0
>be55	5f be 2b 86 41 86		        .word nt_bracket_char, xt_char, z_char
>be5b	63 68 61 72			        .text "char"
.be5f					nt_bracket_char:
>be5f	06 05				        .byte 6, CO+IM
>be61	6d be 91 85 97 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>be67	5b 63 68 61 72 5d		        .text "[char]"
.be6d					nt_char_plus:
>be6d	05 00				        .byte 5, 0
>be6f	7a be 08 98 11 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>be75	63 68 61 72 2b			        .text "char+"
.be7a					nt_chars:
>be7a	05 12				        .byte 5, AN+UF   ; deleted during compile
>be7c	87 be 42 86 45 86		        .word nt_cells, xt_chars, z_chars
>be82	63 68 61 72 73			        .text "chars"
.be87					nt_cells:
>be87	05 00				        .byte 5, 0
>be89	94 be 35 a4 3c a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>be8f	63 65 6c 6c 73			        .text "cells"
.be94					nt_cell_plus:
>be94	05 10				        .byte 5, UF
>be96	a1 be 1b 86 2a 86		        .word nt_here, xt_cell_plus, z_cell_plus
>be9c	63 65 6c 6c 2b			        .text "cell+"
.bea1					nt_here:
>bea1	04 00				        .byte 4, 0
>bea3	ad be 6c 91 76 91		        .word nt_equal, xt_here, z_here
>bea9	68 65 72 65			        .text "here"
.bead					nt_equal:
>bead	01 10				        .byte 1, UF
>beaf	b6 be c8 8e e3 8e		        .word nt_not_equals, xt_equal, z_equal
>beb5	3d				        .text "="
.beb6					nt_not_equals:
>beb6	02 10				        .byte 2, UF
>beb8	c0 be 4a 96 67 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bebe	3c 3e				        .text "<>"
.bec0					nt_less_than:
>bec0	01 10				        .byte 1, UF
>bec2	c9 be 62 93 76 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bec8	3c				        .text "<"
.bec9					nt_u_less_than:
>bec9	02 10				        .byte 2, UF
>becb	d3 be 57 a5 6c a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bed1	75 3c				        .text "u<"
.bed3					nt_u_greater_than:
>bed3	02 10				        .byte 2, UF
>bed5	dd be 41 a5 56 a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bedb	75 3e				        .text "u>"
.bedd					nt_greater_than:
>bedd	01 10				        .byte 1, UF
>bedf	e6 be 57 91 6b 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bee5	3e				        .text ">"
.bee6					nt_zero_equal:
>bee6	02 10				        .byte 2, UF
>bee8	f0 be 94 a7 a7 a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>beee	30 3d				        .text "0="
.bef0					nt_zero_unequal:
>bef0	03 10				        .byte 3, UF
>bef2	fb be cc a7 dd a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bef8	30 3c 3e			        .text "0<>"
.befb					nt_zero_greater:
>befb	02 10				        .byte 2, UF
>befd	05 bf a8 a7 bb a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bf03	30 3e				        .text "0>"
.bf05					nt_zero_less:
>bf05	02 10				        .byte 2, UF
>bf07	0f bf bc a7 cb a7		        .word nt_min, xt_zero_less, z_zero_less
>bf0d	30 3c				        .text "0<"
.bf0f					nt_min:
>bf0f	03 10				        .byte 3, UF
>bf11	1a bf 2e 95 49 95		        .word nt_max, xt_min, z_min
>bf17	6d 69 6e			        .text "min"
.bf1a					nt_max:
>bf1a	03 10				        .byte 3, UF
>bf1c	25 bf 12 95 2d 95		        .word nt_two_drop, xt_max, z_max
>bf22	6d 61 78			        .text "max"
.bf25					nt_two_drop:
>bf25	05 10				        .byte 5, UF
>bf27	32 bf 95 a3 9c a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf2d	32 64 72 6f 70			        .text "2drop"
.bf32					nt_two_swap:
>bf32	05 10				        .byte 5, UF
>bf34	3f bf 63 a4 86 a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf3a	32 73 77 61 70			        .text "2swap"
.bf3f					nt_two_over:
>bf3f	05 10				        .byte 5, UF
>bf41	4c bf d7 a3 ee a3		        .word nt_two_store, xt_two_over, z_two_over
>bf47	32 6f 76 65 72			        .text "2over"
.bf4c					nt_two_store:
>bf4c	02 10				        .byte 2, UF
>bf4e	56 bf 3d a4 62 a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bf54	32 21				        .text "2!"
.bf56					nt_two_fetch:
>bf56	02 10				        .byte 2, UF
>bf58	60 bf b5 a3 d6 a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bf5e	32 40				        .text "2@"
.bf60					nt_two_variable:
>bf60	09 00				        .byte 9, 0
>bf62	71 bf d9 a4 e7 a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>bf68	32 76 61 72 69 61 62 6c		        .text "2variable"
>bf70	65
.bf71					nt_two_constant:
>bf71	09 10				        .byte 9, UF
>bf73	82 bf a7 a4 cb a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bf79	32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bf81	74
.bf82					nt_two_literal:
>bf82	08 14				        .byte 8, UF+IM
>bf84	92 bf cc a4 d8 a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bf8a	32 6c 69 74 65 72 61 6c		        .text "2literal"
.bf92					nt_two_r_fetch:
>bf92	03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bf94	9d bf ef a3 0c a4		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bf9a	32 72 40			        .text "2r@"
.bf9d					nt_two_r_from:
>bf9d	03 01				        .byte 3, CO             ; native is special case
>bf9f	a8 bf 0d a4 29 a4		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bfa5	32 72 3e			        .text "2r>"
.bfa8					nt_two_to_r:
>bfa8	03 11				        .byte 3, CO+UF          ; native is special case
>bfaa	b3 bf 87 a4 a6 a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>bfb0	32 3e 72			        .text "2>r"
.bfb3					nt_invert:
>bfb3	06 10				        .byte 6, UF
>bfb5	c1 bf e5 92 f4 92		        .word nt_negate, xt_invert, z_invert
>bfbb	69 6e 76 65 72 74		        .text "invert"
.bfc1					nt_negate:
>bfc1	06 10				        .byte 6, UF
>bfc3	cf bf 1d 96 2d 96		        .word nt_dnegate, xt_negate, z_negate
>bfc9	6e 65 67 61 74 65		        .text "negate"
.bfcf					nt_dnegate:
>bfcf	07 10				        .byte 7, UF
>bfd1	de bf 3b 8b 55 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>bfd7	64 6e 65 67 61 74 65		        .text "dnegate"
.bfde					nt_c_comma:
>bfde	02 10				        .byte 2, UF
>bfe0	e8 bf fa 85 04 86		        .word nt_bounds, xt_c_comma, z_c_comma
>bfe6	63 2c				        .text "c,"
.bfe8					nt_bounds:
>bfe8	06 10				        .byte 6, UF
>bfea	f6 bf 78 85 90 85		        .word nt_spaces, xt_bounds, z_bounds
>bff0	62 6f 75 6e 64 73		        .text "bounds"
.bff6					nt_spaces:
>bff6	06 10				        .byte 6, UF
>bff8	04 c0 0f a1 44 a1		        .word nt_bl, xt_spaces, z_spaces
>bffe	73 70 61 63 65 73		        .text "spaces"
.c004					nt_bl:
>c004	02 00				        .byte 2, 0
>c006	0e c0 94 83 9c 83		        .word nt_minus_trailing, xt_bl, z_bl
>c00c	62 6c				        .text "bl"
.c00e					nt_minus_trailing:
>c00e	09 10				        .byte 9, UF
>c010	1f c0 76 95 b2 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c016	2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c01e	67
.c01f					nt_minus_leading:
>c01f	08 10				        .byte 8, UF
>c021	2f c0 5d 95 75 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c027	2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c02f					nt_slash_string:
>c02f	07 10				        .byte 7, UF
>c031	3e c0 04 a0 23 a0		        .word nt_refill, xt_slash_string, z_slash_string
>c037	2f 73 74 72 69 6e 67		        .text "/string"
.c03e					nt_refill:
>c03e	06 00				        .byte 6, 0
>c040	4c c0 e3 9a 24 9b		        .word nt_accept, xt_refill, z_refill
>c046	72 65 66 69 6c 6c		        .text "refill"
.c04c					nt_accept:
>c04c	06 18				        .byte 6, UF+NN
>c04e	5a c0 4e 81 46 82		        .word nt_input_to_r, xt_accept, z_accept
>c054	61 63 63 65 70 74		        .text "accept"
.c05a					nt_input_to_r:
>c05a	07 08				        .byte 7, NN
>c05c	69 c0 5c 92 71 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c062	69 6e 70 75 74 3e 72		        .text "input>r"
.c069					nt_r_to_input:
>c069	07 08				        .byte 7, NN
>c06b	78 c0 8e 9a a5 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c071	72 3e 69 6e 70 75 74		        .text "r>input"
.c078					nt_unused:
>c078	06 00				        .byte 6, 0
>c07a	86 c0 39 a6 48 a6		        .word nt_depth, xt_unused, z_unused
>c080	75 6e 75 73 65 64		        .text "unused"
.c086					nt_depth:
>c086	05 00				        .byte 5, 0
>c088	93 c0 f0 8a fe 8a		        .word nt_key, xt_depth, z_depth
>c08e	64 65 70 74 68			        .text "depth"
.c093					nt_key:
>c093	03 00				        .byte 3, 0
>c095	9e c0 28 93 31 93		        .word nt_allot, xt_key, z_key
>c09b	6b 65 79			        .text "key"
.c09e					nt_allot:
>c09e	05 10				        .byte 5, UF
>c0a0	ab c0 ab 82 13 83		        .word nt_create, xt_allot, z_allot
>c0a6	61 6c 6c 6f 74			        .text "allot"
.c0ab					nt_create:
>c0ab	06 00				        .byte 6, 0
>c0ad	b9 c0 63 89 37 8a		        .word nt_does, xt_create, z_create
>c0b3	63 72 65 61 74 65		        .text "create"
.c0b9					nt_does:
>c0b9	05 05				        .byte 5, CO+IM
>c0bb	c6 c0 ef 8b fd 8b		        .word nt_variable, xt_does, z_does
>c0c1	64 6f 65 73 3e			        .text "does>"
.c0c6					nt_variable:
>c0c6	08 00				        .byte 8, 0
>c0c8	d6 c0 5d a6 75 a6		        .word nt_constant, xt_variable, z_variable
>c0ce	76 61 72 69 61 62 6c 65		        .text "variable"
.c0d6					nt_constant:
>c0d6	08 10				        .byte 8, UF
>c0d8	e6 c0 0b 89 48 89		        .word nt_value, xt_constant, z_constant
>c0de	63 6f 6e 73 74 61 6e 74		        .text "constant"
.c0e6					nt_value:
>c0e6	05 10				        .byte 5, UF
>c0e8	f3 c0 0b 89 48 89		        .word nt_to, xt_constant, z_constant
>c0ee	76 61 6c 75 65			        .text "value"
.c0f3					nt_to:
>c0f3	02 0c				        .byte 2, NN+IM
>c0f5	fd c0 16 a2 71 a2		        .word nt_s_to_d, xt_to, z_to
>c0fb	74 6f				        .text "to"
.c0fd					nt_s_to_d:
>c0fd	03 10				        .byte 3, UF
>c0ff	08 c1 97 9e a8 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c105	73 3e 64			        .text "s>d"
.c108					nt_d_to_s:
>c108	03 10				        .byte 3, UF
>c10a	13 c1 7a 8a 7f 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c110	64 3e 73			        .text "d>s"
.c113					nt_d_minus:
>c113	02 10				        .byte 2, UF
>c115	1d c1 38 8a 58 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c11b	64 2d				        .text "d-"
.c11d					nt_d_plus:
>c11d	02 10				        .byte 2, UF
>c11f	27 c1 59 8a 79 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c125	64 2b				        .text "d+"
.c127					nt_erase:
>c127	05 00				        .byte 5, 0      ; underflow checked by FILL
>c129	34 c1 ee 8e 36 8f		        .word nt_blank, xt_erase, z_erase
>c12f	65 72 61 73 65			        .text "erase"
.c134					nt_blank:
>c134	05 00				        .byte 5, 0     ; underflow checked by FILL
>c136	41 c1 e4 8e 36 8f		        .word nt_fill, xt_blank, z_blank
>c13c	62 6c 61 6e 6b			        .text "blank"
.c141					nt_fill:
>c141	04 10				        .byte 4, UF
>c143	4d c1 f4 8e 36 8f		        .word nt_find_name, xt_fill, z_fill
>c149	66 69 6c 6c			        .text "fill"
.c14d					nt_find_name:
>c14d	09 10				        .byte 9, UF
>c14f	5e c1 d5 8f 80 90		        .word nt_tick, xt_find_name, z_find_name
>c155	66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c15d	65
.c15e					nt_tick:
>c15e	01 00				        .byte 1, 0
>c160	67 c1 f6 a1 15 a2		        .word nt_bracket_tick, xt_tick, z_tick
>c166	27				        .text "'"
.c167					nt_bracket_tick:
>c167	03 05				        .byte 3, CO+IM
>c169	72 c1 98 85 9e 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c16f	5b 27 5d			        .text "[']"
.c172					nt_name_to_int:
>c172	08 10				        .byte 8, UF
>c174	82 c1 db 95 f7 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c17a	6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c182					nt_int_to_name:
>c182	08 10				        .byte 8, UF
>c184	92 c1 72 92 e4 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c18a	69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c192					nt_name_to_string:
>c192	0b 10				        .byte 11, UF
>c194	a5 c1 f8 95 11 96		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c19a	6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1a2	69 6e 67
.c1a5					nt_to_body:
>c1a5	05 10				        .byte 5, UF
>c1a7	b2 c1 72 a2 96 a2		        .word nt_defer, xt_to_body, z_to_body
>c1ad	3e 62 6f 64 79			        .text ">body"
.c1b2					nt_defer:
>c1b2	05 00				        .byte 5, 0
>c1b4	bf c1 a6 8a d8 8a		        .word nt_latestxt, xt_defer, z_defer
>c1ba	64 65 66 65 72			        .text "defer"
.c1bf					nt_latestxt:
>c1bf	08 00				        .byte 8, 0
>c1c1	cf c1 43 93 49 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c1c7	6c 61 74 65 73 74 78 74		        .text "latestxt"
.c1cf					nt_latestnt:
>c1cf	08 00				        .byte 8, 0
>c1d1	df c1 35 93 42 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c1d7	6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c1df					nt_parse_name:
>c1df	0a 08				        .byte 10, NN
>c1e1	f1 c1 ca 98 bc 99		        .word nt_parse, xt_parse_name, z_parse_name
>c1e7	70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c1ef	6d 65
.c1f1					nt_parse:
>c1f1	05 10				        .byte 5, UF
>c1f3	fe c1 25 99 bc 99		        .word nt_execute_parsing, xt_parse, z_parse
>c1f9	70 61 72 73 65			        .text "parse"
.c1fe					nt_execute_parsing:
>c1fe	0f 10				        .byte 15, UF
>c200	15 c2 4b 8f 71 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c206	65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c20e	70 61 72 73 69 6e 67
.c215					nt_source:
>c215	06 00				        .byte 6, 0
>c217	23 c2 e9 a0 fd a0		        .word nt_source_id, xt_source, z_source
>c21d	73 6f 75 72 63 65		        .text "source"
.c223					nt_source_id:
>c223	09 00				        .byte 9, 0
>c225	34 c2 fe a0 08 a1		        .word nt_colon, xt_source_id, z_source_id
>c22b	73 6f 75 72 63 65 2d 69		        .text "source-id"
>c233	64
.c234					nt_colon:
>c234	01 00				        .byte 1, 0
>c236	3d c2 09 87 4b 87		        .word nt_semicolon, xt_colon, z_colon
>c23c	3a				        .text ":"
.c23d					nt_semicolon:
>c23d	01 05				        .byte 1, CO+IM
>c23f	46 c2 73 9f d1 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c245	3b				        .text ";"
.c246					nt_colon_noname:
>c246	07 00				        .byte 7, 0
>c248	55 c2 4c 87 67 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c24e	3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c255					nt_compile_comma:
>c255	08 18				        .byte 8, UF+NN
>c257	65 c2 e7 87 fe 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c25d	63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c265					nt_left_bracket:
>c265	01 05				        .byte 1, IM+CO
>c267	6e c2 4f 93 53 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c26d	5b				        .text "["
.c26e					nt_right_bracket:
>c26e	01 04				        .byte 1, IM
>c270	77 c2 32 9b 38 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c276	5d				        .text "]"
.c277					nt_literal:
>c277	07 15				        .byte 7, IM+CO+UF
>c279	86 c2 84 93 91 93		        .word nt_sliteral, xt_literal, z_literal
>c27f	6c 69 74 65 72 61 6c		        .text "literal"
.c286					nt_sliteral:
>c286	08 15				        .byte 8, CO+IM+UF
>c288	96 c2 24 a0 93 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c28e	73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c296					nt_dot_quote:
>c296	02 05				        .byte 2, CO+IM
>c298	a0 c2 61 8c 6b 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c29e	2e 22				        .text ".", $22
.c2a0					nt_s_quote:
>c2a0	02 0c				        .byte 2, IM+NN
>c2a2	aa c2 3a 9d 96 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c2a8	73 22				        .text "s", $22
.c2aa					nt_s_backslash_quote:
>c2aa	03 04				        .byte 3, IM
>c2ac	b5 c2 72 9b 7b 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c2b2	73 5c 22			        .text "s", $5C, $22
.c2b5					nt_postpone:
>c2b5	08 05				        .byte 8, IM+CO
>c2b7	c5 c2 01 9a 3f 9a		        .word nt_immediate, xt_postpone, z_postpone
>c2bd	70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c2c5					nt_immediate:
>c2c5	09 00				        .byte 9, 0
>c2c7	d6 c2 45 92 50 92		        .word nt_compile_only, xt_immediate, z_immediate
>c2cd	69 6d 6d 65 64 69 61 74		        .text "immediate"
>c2d5	65
.c2d6					nt_compile_only:
>c2d6	0c 00				        .byte 12, 0
>c2d8	ea c2 ff 88 0a 89		        .word nt_never_native, xt_compile_only, z_compile_only
>c2de	63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c2e6	6f 6e 6c 79
.c2ea					nt_never_native:
>c2ea	0c 00				        .byte 12, 0
>c2ec	fe c2 2e 96 3b 96		        .word nt_always_native, xt_never_native, z_never_native
>c2f2	6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c2fa	74 69 76 65
.c2fe					nt_always_native:
>c2fe	0d 00				        .byte 13, 0
>c300	13 c3 30 83 3d 83		        .word nt_allow_native, xt_always_native, z_always_native
>c306	61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c30e	61 74 69 76 65
.c313					nt_allow_native:
>c313	0c 00				        .byte 12, 0
>c315	27 c3 14 83 1f 83		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c31b	61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c323	74 69 76 65
.c327					nt_nc_limit:
>c327	08 00				        .byte 8, 0
>c329	37 c3 12 96 1c 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c32f	6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c337					nt_strip_underflow:
>c337	0f 00				        .byte 15, 0
>c339	4e c3 88 a1 92 a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c33f	73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c347	64 65 72 66 6c 6f 77
.c34e					nt_abort:
>c34e	05 00				        .byte 5, 0
>c350	5b c3 81 80 c5 80		        .word nt_abort_quote, xt_abort, z_abort
>c356	61 62 6f 72 74			        .text "abort"
.c35b					nt_abort_quote:
>c35b	06 0d				        .byte 6, CO+IM+NN
>c35d	69 c3 19 81 23 81		        .word nt_do, xt_abort_quote, z_abort_quote
>c363	61 62 6f 72 74 22		        .text "abort", $22
.c369					nt_do:
>c369	02 0d				        .byte 2, CO+IM+NN
>c36b	73 c3 5c 8b b6 8b		        .word nt_question_do, xt_do, z_do
>c371	64 6f				        .text "do"
.c373					nt_question_do:
>c373	03 0d				        .byte 3, CO+IM+NN
>c375	7e c3 56 8b b6 8b		        .word nt_i, xt_question_do, z_question_do
>c37b	3f 64 6f			        .text "?do"
.c37e					nt_i:
>c37e	01 03				        .byte 1, AN+CO
>c380	87 c3 e3 91 fc 91		        .word nt_j, xt_i, z_i
>c386	69				        .text "i"
.c387					nt_j:
>c387	01 03				        .byte 1, AN+CO
>c389	90 c3 0e 93 27 93		        .word nt_loop, xt_j, z_j
>c38f	6a				        .text "j"
.c390					nt_loop:
>c390	04 05				        .byte 4, CO+IM
>c392	9c c3 f5 93 62 94		        .word nt_plus_loop, xt_loop, z_loop
>c398	6c 6f 6f 70			        .text "loop"
.c39c					nt_plus_loop:
>c39c	05 05				        .byte 5, CO+IM
>c39e	a9 c3 fc 93 62 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3a4	2b 6c 6f 6f 70			        .text "+loop"
.c3a9					nt_exit:
>c3a9	04 03				        .byte 4, AN+CO
>c3ab	b5 c3 72 8f 73 8f		        .word nt_unloop, xt_exit, z_exit
>c3b1	65 78 69 74			        .text "exit"
.c3b5					nt_unloop:
>c3b5	06 03				        .byte 6, AN+CO
>c3b7	c3 c3 27 a6 2d a6		        .word nt_leave, xt_unloop, z_unloop
>c3bd	75 6e 6c 6f 6f 70		        .text "unloop"
.c3c3					nt_leave:
>c3c3	05 03				        .byte 5, AN+CO
>c3c5	d0 c3 4a 93 4f 93		        .word nt_recurse, xt_leave, z_leave
>c3cb	6c 65 61 76 65			        .text "leave"
.c3d0					nt_recurse:
>c3d0	07 0d				        .byte 7, CO+IM+NN
>c3d2	df c3 a6 9a e2 9a		        .word nt_quit, xt_recurse, z_recurse
>c3d8	72 65 63 75 72 73 65		        .text "recurse"
.c3df					nt_quit:
>c3df	04 00				        .byte 4, 0
>c3e1	eb c3 83 80 c5 80		        .word nt_begin, xt_quit, z_quit
>c3e7	71 75 69 74			        .text "quit"
.c3eb					nt_begin:
>c3eb	05 07				        .byte 5, AN+CO+IM
>c3ed	f8 c3 8a 83 8d 83		        .word nt_again, xt_begin, z_begin
>c3f3	62 65 67 69 6e			        .text "begin"
.c3f8					nt_again:
>c3f8	05 17				        .byte 5, AN+CO+IM+UF
>c3fa	05 c4 89 82 a9 82		        .word nt_state, xt_again, z_again
>c400	61 67 61 69 6e			        .text "again"
.c405					nt_state:
>c405	05 00				        .byte 5, 0
>c407	12 c4 67 a1 71 a1		        .word nt_evaluate, xt_state, z_state
>c40d	73 74 61 74 65			        .text "state"
.c412					nt_evaluate:
>c412	08 10				        .byte 8, UF
>c414	22 c4 cf 90 22 91		        .word nt_base, xt_evaluate, z_evaluate
>c41a	65 76 61 6c 75 61 74 65		        .text "evaluate"
.c422					nt_base:
>c422	04 00				        .byte 4, 0
>c424	2e c4 81 83 89 83		        .word nt_digit_question, xt_base, z_base
>c42a	62 61 73 65			        .text "base"
.c42e					nt_digit_question:
>c42e	06 10				        .byte 6, UF
>c430	3c c4 ff 8a 33 8b		        .word nt_number, xt_digit_question, z_digit_question
>c436	64 69 67 69 74 3f		        .text "digit?"
.c43c					nt_number:
>c43c	06 10				        .byte 6, UF
>c43e	4a c4 84 96 71 97		        .word nt_to_number, xt_number, z_number
>c444	6e 75 6d 62 65 72		        .text "number"
.c44a					nt_to_number:
>c44a	07 10				        .byte 7, UF
>c44c	59 c4 a2 a2 41 a3		        .word nt_hex, xt_to_number, z_to_number
>c452	3e 6e 75 6d 62 65 72		        .text ">number"
.c459					nt_hex:
>c459	03 00				        .byte 3, 0
>c45b	64 c4 77 91 7d 91		        .word nt_decimal, xt_hex, z_hex
>c461	68 65 78			        .text "hex"
.c464					nt_decimal:
>c464	07 00				        .byte 7, 0
>c466	73 c4 9f 8a a5 8a		        .word nt_count, xt_decimal, z_decimal
>c46c	64 65 63 69 6d 61 6c		        .text "decimal"
.c473					nt_count:
>c473	05 10				        .byte 5, UF
>c475	80 c4 49 89 5c 89		        .word nt_m_star, xt_count, z_count
>c47b	63 6f 75 6e 74			        .text "count"
.c480					nt_m_star:
>c480	02 10				        .byte 2, UF
>c482	8a c4 88 94 a2 94		        .word nt_um_star, xt_m_star, z_m_star
>c488	6d 2a				        .text "m*"
.c48a					nt_um_star:
>c48a	03 10				        .byte 3, UF
>c48c	95 c4 e1 a5 26 a6		        .word nt_star, xt_um_star, z_um_star
>c492	75 6d 2a			        .text "um*"
.c495					nt_star:
>c495	01 10				        .byte 1, UF
>c497	9e c4 45 a1 4d a1		        .word nt_um_slash_mod, xt_star, z_star
>c49d	2a				        .text "*"
.c49e					nt_um_slash_mod:
>c49e	06 10				        .byte 6, UF
>c4a0	ac c4 9f a5 e0 a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c4a6	75 6d 2f 6d 6f 64		        .text "um/mod"
.c4ac					nt_sm_slash_rem:
>c4ac	06 10				        .byte 6, UF
>c4ae	ba c4 c0 a0 e8 a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c4b4	73 6d 2f 72 65 6d		        .text "sm/rem"
.c4ba					nt_fm_slash_mod:
>c4ba	06 10				        .byte 6, UF
>c4bc	c8 c4 8b 90 c1 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c4c2	66 6d 2f 6d 6f 64		        .text "fm/mod"
.c4c8					nt_slash:
>c4c8	01 10				        .byte 1, UF
>c4ca	d1 c4 e7 9f 03 a0		        .word nt_slash_mod, xt_slash, z_slash
>c4d0	2f				        .text "/"
.c4d1					nt_slash_mod:
>c4d1	04 10				        .byte 4, UF
>c4d3	dd c4 ec 9f 03 a0		        .word nt_mod, xt_slash_mod, z_slash_mod
>c4d9	2f 6d 6f 64			        .text "/mod"
.c4dd					nt_mod:
>c4dd	03 10				        .byte 3, UF
>c4df	e8 c4 b3 95 bb 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c4e5	6d 6f 64			        .text "mod"
.c4e8					nt_star_slash_mod:
>c4e8	05 10				        .byte 5, UF
>c4ea	f5 c4 57 a1 66 a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c4f0	2a 2f 6d 6f 64			        .text "*/mod"
.c4f5					nt_star_slash:
>c4f5	02 10				        .byte 2, UF
>c4f7	ff c4 4e a1 56 a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c4fd	2a 2f				        .text "*/"
.c4ff					nt_backslash:
>c4ff	01 04				        .byte 1, IM
>c501	08 c5 78 83 80 83		        .word nt_move, xt_backslash, z_backslash
>c507	5c				        .byte $5c
.c508					nt_move:
>c508	04 18				        .byte 4, NN+UF
>c50a	14 c5 bc 95 da 95		        .word nt_cmove_up, xt_move, z_move
>c510	6d 6f 76 65			        .text "move"
.c514					nt_cmove_up:
>c514	06 10				        .byte 6, UF
>c516	22 c5 ce 86 08 87		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c51c	63 6d 6f 76 65 3e		        .text "cmove>"
.c522					nt_cmove:
>c522	05 10				        .byte 5, UF
>c524	2f c5 93 86 cd 86		        .word nt_pad, xt_cmove, z_cmove
>c52a	63 6d 6f 76 65			        .text "cmove"
.c52f					nt_pad:
>c52f	03 00				        .byte 3, 0
>c531	3a c5 8c 98 9b 98		        .word nt_cleave, xt_pad, z_pad
>c537	70 61 64			        .text "pad"
.c53a					nt_cleave:
>c53a	06 10				        .byte 6, UF
>c53c	48 c5 46 86 92 86		        .word nt_hexstore, xt_cleave, z_cleave
>c542	63 6c 65 61 76 65		        .text "cleave"
.c548					nt_hexstore:
>c548	08 10				        .byte 8, UF
>c54a	58 c5 7e 91 d0 91		        .word nt_within, xt_hexstore, z_hexstore
>c550	68 65 78 73 74 6f 72 65		        .text "hexstore"
.c558					nt_within:
>c558	06 10				        .byte 6, UF
>c55a	66 c5 8a a6 9f a6		        .word nt_to_in, xt_within, z_within
>c560	77 69 74 68 69 6e		        .text "within"
.c566					nt_to_in:
>c566	03 00				        .byte 3, 0
>c568	71 c5 97 a2 a1 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c56e	3e 69 6e			        .text ">in"
.c571					nt_less_number_sign:
>c571	02 00				        .byte 2, 0
>c573	7b c5 54 93 61 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c579	3c 23				        .text "<#"
.c57b					nt_number_sign:
>c57b	01 10				        .byte 1, UF
>c57d	84 c5 72 97 a6 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c583	23				        .text "#"
.c584					nt_number_sign_s:
>c584	02 10				        .byte 2, UF
>c586	8e c5 c9 97 d9 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c58c	23 73				        .text "#s"
.c58e					nt_number_sign_greater:
>c58e	02 10				        .byte 2, UF
>c590	98 c5 a7 97 c8 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c596	23 3e				        .text "#>"
.c598					nt_hold:
>c598	04 10				        .byte 4, UF
>c59a	a4 c5 d1 91 e2 91		        .word nt_sign, xt_hold, z_hold
>c5a0	68 6f 6c 64			        .text "hold"
.c5a4					nt_sign:
>c5a4	04 10				        .byte 4, UF
>c5a6	b0 c5 d2 9f e6 9f		        .word nt_output, xt_sign, z_sign
>c5ac	73 69 67 6e			        .text "sign"
.c5b0					nt_output:
>c5b0	06 00				        .byte 6, 0
>c5b2	be c5 73 98 7d 98		        .word nt_input, xt_output, z_output
>c5b8	6f 75 74 70 75 74		        .text "output"
.c5be					nt_input:
>c5be	05 00				        .byte 5, 0
>c5c0	cb c5 51 92 5b 92		        .word nt_cr, xt_input, z_input
>c5c6	69 6e 70 75 74			        .text "input"
.c5cb					nt_cr:
>c5cb	02 00				        .byte 2, 0
>c5cd	d5 c5 5d 89 62 89		        .word nt_page, xt_cr, z_cr
>c5d3	63 72				        .text "cr"
.c5d5					nt_page:
>c5d5	04 00				        .byte 4, 0
>c5d7	e1 c5 9c 98 b9 98		        .word nt_at_xy, xt_page, z_page
>c5dd	70 61 67 65			        .text "page"
.c5e1					nt_at_xy:
>c5e1	05 10				        .byte 5, UF
>c5e3	ee c5 50 83 77 83		        .word nt_marker, xt_at_xy, z_at_xy
>c5e9	61 74 2d 78 79			        .text "at-xy"
.c5ee					nt_marker:
>c5ee	06 04				        .byte 6, IM
>c5f0	fc c5 a3 94 e0 94		        .word nt_words, xt_marker, z_marker
>c5f6	6d 61 72 6b 65 72		        .text "marker"
.c5fc					nt_words:
>c5fc	05 00				        .byte 5, 0
>c5fe	09 c6 fd a6 59 a7		        .word nt_wordsize, xt_words, z_words
>c604	77 6f 72 64 73			        .text "words"
.c609					nt_wordsize:
>c609	08 10				        .byte 8, UF
>c60b	19 c6 5a a7 7a a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c611	77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c619					nt_aligned:
>c619	07 00				        .byte 7, 0
>c61b	28 c6 aa 82 aa 82		        .word nt_align, xt_align, z_align
>c621	61 6c 69 67 6e 65 64		        .text "aligned"
.c628					nt_align:
>c628	05 00				        .byte 5, 0
>c62a	35 c6 aa 82 aa 82		        .word nt_bell, xt_align, z_align
>c630	61 6c 69 67 6e			        .text "align"
.c635					nt_bell:
>c635	04 00				        .byte 4, 0
>c637	41 c6 8e 83 93 83		        .word nt_dump, xt_bell, z_bell
>c63d	62 65 6c 6c			        .text "bell"
.c641					nt_dump:
>c641	04 10				        .byte 4, UF
>c643	4d c6 2e 8d 94 8d		        .word nt_dot_s, xt_dump, z_dump
>c649	64 75 6d 70			        .text "dump"
.c64d					nt_dot_s:
>c64d	02 00				        .byte 2, 0
>c64f	57 c6 9a 8c dd 8c		        .word nt_disasm, xt_dot_s, z_dot_s
>c655	2e 73				        .text ".s"
.c657					nt_disasm:
>c657	06 10				        .byte 6, UF
>c659	65 c6 34 8b 3a 8b		        .word nt_compare, xt_disasm, z_disasm
>c65f	64 69 73 61 73 6d		        .text "disasm"
.c665					nt_compare:
>c665	07 10				        .byte 7, UF
>c667	74 c6 82 87 e6 87		        .word nt_search, xt_compare, z_compare
>c66d	63 6f 6d 70 61 72 65		        .text "compare"
.c674					nt_search:
>c674	06 18				        .byte 6, UF+NN
>c676	82 c6 d4 9e 72 9f		        .word +, xt_search, z_search
>c67c	73 65 61 72 63 68		        .text "search"
.c682					+
.c682					nt_environment_q:
>c682	0c 10				        .byte 12, UF
>c684	96 c6 0f 8e 8b 8e		        .word +, xt_environment_q, z_environment_q
>c68a	65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c692	65 6e 74 3f
.c696					+
.c696					nt_find:
>c696	04 10				        .byte 4, UF
>c698	a2 c6 8d 8f d4 8f		        .word nt_word, xt_find, z_find
>c69e	66 69 6e 64			        .text "find"
.c6a2					nt_word:
>c6a2	04 10				        .byte 4, UF
>c6a4	ae c6 a0 a6 e5 a6		        .word nt_paren, xt_word, z_word
>c6aa	77 6f 72 64			        .text "word"
.c6ae					nt_paren:
>c6ae	01 04				        .byte 1, IM
>c6b0	b7 c6 ba 98 c9 98		        .word nt_dot_paren, xt_paren, z_paren
>c6b6	28				        .text "("
.c6b7					nt_dot_paren:
>c6b7	02 04				        .byte 2, IM
>c6b9	c1 c6 52 8c 60 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c6bf	2e 28				        .text ".("
.c6c1					nt_if:
>c6c1	02 0d				        .byte 2, IM+CO+NN
>c6c3	cb c6 fd 91 0d 92		        .word nt_then, xt_if, z_if
>c6c9	69 66				        .text "if"
.c6cb					nt_then:
>c6cb	04 0d				        .byte 4, IM+CO+NN
>c6cd	d7 c6 a7 a1 b0 a1		        .word nt_else, xt_then, z_then
>c6d3	74 68 65 6e			        .text "then"
.c6d7					nt_else:
>c6d7	04 0d				        .byte 4, IM+CO+NN
>c6d9	e3 c6 bb 8d d4 8d		        .word nt_repeat, xt_else, z_else
>c6df	65 6c 73 65			        .text "else"
.c6e3					nt_repeat:
>c6e3	06 0d				        .byte 6, IM+CO+NN
>c6e5	f1 c6 25 9b 31 9b		        .word nt_until, xt_repeat, z_repeat
>c6eb	72 65 70 65 61 74		        .text "repeat"
.c6f1					nt_until:
>c6f1	05 0d				        .byte 5, IM+CO+NN
>c6f3	fe c6 2e a6 38 a6		        .word nt_while, xt_until, z_until
>c6f9	75 6e 74 69 6c			        .text "until"
.c6fe					nt_while:
>c6fe	05 0d				        .byte 5, IM+CO+NN
>c700	0b c7 76 a6 89 a6		        .word nt_case, xt_while, z_while
>c706	77 68 69 6c 65			        .text "while"
.c70b					nt_case:
>c70b	04 0d				        .byte 4, IM+CO+NN
>c70d	17 c7 8d a7 93 a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c713	63 61 73 65			        .text "case"
.c717					nt_of:
>c717	02 0d				        .byte 2, IM+CO+NN
>c719	21 c7 da 97 f2 97		        .word nt_endof, xt_of, z_of
>c71f	6f 66				        .text "of"
.c721					nt_endof:
>c721	05 0d				        .byte 5, IM+CO+NN
>c723	2e c7 bb 8d d4 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c729	65 6e 64 6f 66			        .text "endof"
.c72e					nt_endcase:
>c72e	07 0d				        .byte 7, IM+CO+NN
>c730	3d c7 fa 8d 0e 8e		        .word nt_defer_fetch, xt_endcase, z_endcase
>c736	65 6e 64 63 61 73 65		        .text "endcase"
.c73d					nt_defer_fetch:
>c73d	06 00				        .byte 6, 0
>c73f	4b c7 d9 8a df 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c745	64 65 66 65 72 40		        .text "defer@"
.c74b					nt_defer_store:
>c74b	06 00				        .byte 6, 0
>c74d	59 c7 e0 8a e6 8a		        .word nt_is, xt_defer_store, z_defer_store
>c753	64 65 66 65 72 21		        .text "defer!"
.c759					nt_is:
>c759	02 04				        .byte 2, IM
>c75b	63 c7 f5 92 0d 93		        .word nt_action_of, xt_is, z_is
>c761	69 73				        .text "is"
.c763					nt_action_of:
>c763	09 04				        .byte 9, IM
>c765	74 c7 70 82 88 82		        .word nt_useraddr, xt_action_of, z_action_of
>c76b	61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c773	66
.c774					nt_useraddr:
>c774	08 00				        .byte 8, 0
>c776	84 c7 52 a6 5c a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c77c	75 73 65 72 61 64 64 72		        .text "useraddr"
.c784					nt_buffer_colon:
>c784	07 00				        .byte 7, 0
>c786	93 c7 e0 85 e6 85		        .word +, xt_buffer_colon, z_buffer_colon
>c78c	62 75 66 66 65 72 3a		        .text "buffer:"
.c793					+
.c793					nt_buffstatus:
>c793	0a 00				        .byte 10, 0
>c795	a5 c7 e7 85 f6 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c79b	62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7a3	75 73
.c7a5					nt_buffblocknum:
>c7a5	0c 00				        .byte 12, 0
>c7a7	b9 c7 9f 85 ae 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c7ad	62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c7b5	6b 6e 75 6d
.c7b9					nt_blkbuffer:
>c7b9	09 00				        .byte 9, 0
>c7bb	ca c7 ad 83 ba 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c7c1	62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c7c9	72
.c7ca					nt_scr:
>c7ca	03 00				        .byte 3, 0
>c7cc	d5 c7 c4 9e d3 9e		        .word nt_blk, xt_scr, z_scr
>c7d2	73 63 72			        .text "scr"
.c7d5					nt_blk:
>c7d5	03 00				        .byte 3, 0
>c7d7	e0 c7 9d 83 ac 83		        .word nt_block_write, xt_blk, z_blk
>c7dd	62 6c 6b			        .text "blk"
.c7e0					nt_block_write:
>c7e0	0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c7e2	f3 c7 5a 85 68 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c7e8	62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c7f0	69 74 65
.c7f3					nt_block_write_vector:
>c7f3	12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c7f5	0d c8 68 85 77 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c7fb	62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c803	69 74 65 2d 76 65 63 74 6f 72
.c80d					nt_block_read:
>c80d	0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c80f	1f c8 37 85 45 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c815	62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c81d	61 64
.c81f					nt_block_read_vector:
>c81f	11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c821	38 c8 45 85 54 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c827	62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c82f	61 64 2d 76 65 63 74 6f 72
.c838					nt_save_buffers:
>c838	0c 00				        .byte 12, 0
>c83a	4c c8 a9 9e c3 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c840	73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c848	66 65 72 73
.c84c					nt_block:
>c84c	05 00				        .byte 5, 0
>c84e	59 c8 bb 83 0d 84		        .word nt_update, xt_block, z_block
>c854	62 6c 6f 63 6b			        .text "block"
.c859					nt_update:
>c859	06 00				        .byte 6, 0
>c85b	67 c8 49 a6 51 a6		        .word nt_buffer, xt_update, z_update
>c861	75 70 64 61 74 65		        .text "update"
.c867					nt_buffer:
>c867	06 00				        .byte 6, 0
>c869	75 c8 af 85 df 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c86f	62 75 66 66 65 72		        .text "buffer"
.c875					nt_empty_buffers:
>c875	0d 00				        .byte 13, 0
>c877	8a c8 f3 8d f9 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c87d	65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c885	66 66 65 72 73
.c88a					nt_flush:
>c88a	05 00				        .byte 5, 0
>c88c	97 c8 81 90 8a 90		        .word nt_load, xt_flush, z_flush
>c892	66 6c 75 73 68			        .text "flush"
.c897					nt_load:
>c897	04 10				        .byte 4, UF
>c899	a3 c8 b1 93 f4 93		        .word nt_thru, xt_load, z_load
>c89f	6c 6f 61 64			        .text "load"
.c8a3					nt_thru:
>c8a3	04 10				        .byte 4, UF
>c8a5	af c8 b1 a1 f5 a1		        .word nt_list, xt_thru, z_thru
>c8ab	74 68 72 75			        .text "thru"
.c8af					nt_list:
>c8af	04 10				        .byte 4, UF
>c8b1	bb c8 77 93 83 93		        .word +, xt_list, z_list
>c8b7	6c 69 73 74			        .text "list"
.c8bb					+
.c8bb					nt_block_ramdrive_init:
>c8bb	13 10				        .byte 19, UF
>c8bd	d6 c8 0e 84 36 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c8c3	62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c8cb	6d 64 72 69 76 65 2d 69 6e 69 74
.c8d6					+
.c8d6					nt_definitions:
>c8d6	0b 00				        .byte 11, 0
>c8d8	e9 c8 e7 8a ef 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c8de	64 65 66 69 6e 69 74 69		        .text "definitions"
>c8e6	6f 6e 73
.c8e9					nt_wordlist:
>c8e9	08 00				        .byte 8, 0
>c8eb	f9 c8 e6 a6 fc a6		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c8f1	77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c8f9					nt_search_wordlist:
>c8f9	0f 10				        .byte 15, UF
>c8fb	10 c9 8b 9b 6b 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c901	73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c909	6f 72 64 6c 69 73 74
.c910					nt_set_current:
>c910	0b 10				        .byte 11, UF
>c912	23 c9 fa 9c 05 9d		        .word nt_get_current, xt_set_current, z_set_current
>c918	73 65 74 2d 63 75 72 72		        .text "set-current"
>c920	65 6e 74
.c923					nt_get_current:
>c923	0b 00				        .byte 11, 0
>c925	36 c9 23 91 2d 91		        .word nt_set_order, xt_get_current, z_get_current
>c92b	67 65 74 2d 63 75 72 72		        .text "get-current"
>c933	65 6e 74
.c936					nt_set_order:
>c936	09 00				        .byte 9, 0
>c938	47 c9 06 9d 39 9d		        .word nt_get_order, xt_set_order, z_set_order
>c93e	73 65 74 2d 6f 72 64 65		        .text "set-order"
>c946	72
.c947					nt_get_order:
>c947	09 00				        .byte 9, 0
>c949	58 c9 2e 91 56 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c94f	67 65 74 2d 6f 72 64 65		        .text "get-order"
>c957	72
.c958					nt_root_wordlist:
>c958	0d 00				        .byte 13, 0
>c95a	6d c9 39 9b 41 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c960	72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c968	64 6c 69 73 74
.c96d					+
.c96d					nt_assembler_wordlist:
>c96d	12 00				        .byte 18, 0
>c96f	87 c9 8c a3 94 a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c975	61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c97d	72 2d 77 6f 72 64 6c 69 73 74
.c987					+
.c987					nt_editor_wordlist:
>c987	0f 00				        .byte 15, 0
>c989	9e c9 f3 97 fb 97		        .word +, xt_editor_wordlist, z_editor_wordlist
>c98f	65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c997	6f 72 64 6c 69 73 74
.c99e					+
.c99e					nt_forth_wordlist:
>c99e	0e 00				        .byte 14, 0
>c9a0	b4 c9 8d a7 93 a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c9a6	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9ae	72 64 6c 69 73 74
.c9b4					nt_only:
>c9b4	04 00				        .byte 4, 0
>c9b6	c0 c9 12 98 1d 98		        .word nt_also, xt_only, z_only
>c9bc	6f 6e 6c 79			        .text "only"
.c9c0					nt_also:
>c9c0	04 00				        .byte 4, 0
>c9c2	cc c9 20 83 2f 83		        .word nt_previous, xt_also, z_also
>c9c8	61 6c 73 6f			        .text "also"
.c9cc					nt_previous:
>c9cc	08 00				        .byte 8, 0
>c9ce	dc c9 40 9a 4c 9a		        .word nt_to_order, xt_previous, z_previous
>c9d4	70 72 65 76 69 6f 75 73		        .text "previous"
.c9dc					nt_to_order:
>c9dc	06 00				        .byte 6, 0
>c9de	ea c9 42 a3 54 a3		        .word nt_order, xt_to_order, z_to_order
>c9e4	3e 6f 72 64 65 72		        .text ">order"
.c9ea					nt_order:
>c9ea	05 00				        .byte 5, 0
>c9ec	f7 c9 30 98 5a 98		        .word nt_forth, xt_order, z_order
>c9f2	6f 72 64 65 72			        .text "order"
.c9f7					nt_forth:
>c9f7	05 00				        .byte 5, 0
>c9f9	04 ca c2 90 c8 90		        .word +, xt_forth, z_forth
>c9ff	66 6f 72 74 68			        .text "forth"
.ca04					+
>ca04	03 08				nt_see: .byte 3, NN
>ca06	0f ca 6c 9c f9 9c		        .word +, xt_see, z_see
>ca0c	73 65 65			        .text "see"
.ca0f					+
.ca0f					nt_ed:
>ca0f	02 08				        .byte 2, NN
>ca11	19 ca b7 8d ba 8d		        .word +, xt_ed, z_ed
>ca17	65 64				        .text "ed"
.ca19					+
.ca19					nt_cold:
>ca19	04 00				        .byte 4, 0
>ca1b	25 ca 00 80 c5 80		        .word nt_bye, xt_cold, z_cold
>ca21	63 6f 6c 64			        .text "cold"
.ca25					nt_bye:
>ca25	03				        .byte 3         ; length of word strings
>ca26	00				        .byte 0         ; status byte
>ca27	00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca29	f7 85				        .word xt_bye    ; start of code block (xt of this word)
>ca2b	fa 85				        .word z_bye     ; end of code (RTS)
>ca2d	62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca30					root_dictionary_start:
.ca30					nt_root_set_order:
>ca30	09 00				        .byte 9, 0
>ca32	41 ca 06 9d 39 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca38	73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca40	72
.ca41					nt_root_forth:
>ca41	05 00				        .byte 5, 0
>ca43	4e ca c2 90 c8 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca49	66 6f 72 74 68			        .text "forth"
.ca4e					nt_root_forth_wordlist:
>ca4e	0e 00				        .byte 14, 0
>ca50	64 ca 8d a7 93 a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca56	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca5e	72 64 6c 69 73 74
.ca64					nt_root_words:
>ca64	05 00				        .byte 5, 0
>ca66	00 00 fd a6 59 a7		        .word 0000, xt_words, z_words
>ca6c	77 6f 72 64 73			        .text "words"
.ca71					editor_dictionary_start:
.ca71					nt_editor_o:
>ca71	01 00				        .byte 1, 0
>ca73	7a ca c0 a8 05 a9		        .word nt_editor_line, xt_editor_o, z_editor_o
>ca79	6f				        .text "o"
.ca7a					nt_editor_line:
>ca7a	04 10				        .byte 4, UF
>ca7c	86 ca a7 a8 bf a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>ca82	6c 69 6e 65			        .text "line"
.ca86					nt_editor_l:
>ca86	01 00				        .byte 1, 0
>ca88	8f ca 2b a8 a6 a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>ca8e	6c				        .text "l"
.ca8f					nt_editor_el:
>ca8f	02 00				        .byte 2, 0
>ca91	99 ca 19 a8 2a a8		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>ca97	65 6c				        .text "el"
.ca99					nt_editor_erase_screen:
>ca99	0c 00				        .byte 12, 0
>ca9b	ad ca 07 a8 18 a8		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>caa1	65 72 61 73 65 2d 73 63		        .text "erase-screen"
>caa9	72 65 65 6e
.caad					nt_editor_enter_screen:
>caad	0c 00				        .byte 12, 0
>caaf	00 00 eb a7 06 a8		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cab5	65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cabd	72 65 65 6e
.cac1					assembler_dictionary_start:
.cac1					nt_asm_adc_h:
>cac1	05 0c						.byte 5, IM+NN
>cac3	ce ca				                .word nt_asm_adc_x
>cac5	06 a9 0b a9					.word xt_asm_adc_h, z_asm_adc_h
>cac9	61 64 63 2e 23					.text "adc.#"
.cace					nt_asm_adc_x:
>cace	05 0c						.byte 5, IM+NN
>cad0	db ca				                .word nt_asm_adc_y
>cad2	0b a9 10 a9					.word xt_asm_adc_x, z_asm_adc_x
>cad6	61 64 63 2e 78					.text "adc.x"
.cadb					nt_asm_adc_y:
>cadb	05 0c						.byte 5, IM+NN
>cadd	e8 ca				                .word nt_asm_adc_z
>cadf	10 a9 15 a9					.word xt_asm_adc_y, z_asm_adc_y
>cae3	61 64 63 2e 79					.text "adc.y"
.cae8					nt_asm_adc_z:
>cae8	05 0c						.byte 5, IM+NN
>caea	f5 ca				                .word nt_asm_adc_zi
>caec	15 a9 1a a9					.word xt_asm_adc_z, z_asm_adc_z
>caf0	61 64 63 2e 7a					.text "adc.z"
.caf5					nt_asm_adc_zi:
>caf5	06 0c						.byte 6, IM+NN
>caf7	03 cb				                .word nt_asm_adc_ziy
>caf9	1a a9 1f a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cafd	61 64 63 2e 7a 69				.text "adc.zi"
.cb03					nt_asm_adc_ziy:
>cb03	07 0c						.byte 7, IM+NN
>cb05	12 cb				                .word nt_asm_adc_zx
>cb07	1f a9 24 a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb0b	61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb12					nt_asm_adc_zx:
>cb12	06 0c						.byte 6, IM+NN
>cb14	20 cb				                .word nt_asm_adc_zxi
>cb16	24 a9 29 a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cb1a	61 64 63 2e 7a 78				.text "adc.zx"
.cb20					nt_asm_adc_zxi:
>cb20	07 0c						.byte 7, IM+NN
>cb22	2f cb				                .word nt_asm_and
>cb24	29 a9 2e a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb28	61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb2f					nt_asm_and:
>cb2f	04 0c						.byte 4, IM+NN
>cb31	3b cb				                .word nt_asm_and_h
>cb33	2e a9 33 a9					.word xt_asm_and, z_asm_and
>cb37	61 6e 64 2e					.text "and."
.cb3b					nt_asm_and_h:
>cb3b	05 0c						.byte 5, IM+NN
>cb3d	48 cb				                .word nt_asm_and_x
>cb3f	33 a9 38 a9					.word xt_asm_and_h, z_asm_and_h
>cb43	61 6e 64 2e 23					.text "and.#"
.cb48					nt_asm_and_x:
>cb48	05 0c						.byte 5, IM+NN
>cb4a	55 cb				                .word nt_asm_and_y
>cb4c	38 a9 3d a9					.word xt_asm_and_x, z_asm_and_x
>cb50	61 6e 64 2e 78					.text "and.x"
.cb55					nt_asm_and_y:
>cb55	05 0c						.byte 5, IM+NN
>cb57	62 cb				                .word nt_asm_and_z
>cb59	3d a9 42 a9					.word xt_asm_and_y, z_asm_and_y
>cb5d	61 6e 64 2e 79					.text "and.y"
.cb62					nt_asm_and_z:
>cb62	05 0c						.byte 5, IM+NN
>cb64	6f cb				                .word nt_asm_and_zi
>cb66	42 a9 47 a9					.word xt_asm_and_z, z_asm_and_z
>cb6a	61 6e 64 2e 7a					.text "and.z"
.cb6f					nt_asm_and_zi:
>cb6f	06 0c						.byte 6, IM+NN
>cb71	7d cb				                .word nt_asm_and_ziy
>cb73	47 a9 4c a9					.word xt_asm_and_zi, z_asm_and_zi
>cb77	61 6e 64 2e 7a 69				.text "and.zi"
.cb7d					nt_asm_and_ziy:
>cb7d	07 0c						.byte 7, IM+NN
>cb7f	8c cb				                .word nt_asm_and_zx
>cb81	4c a9 51 a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cb85	61 6e 64 2e 7a 69 79				.text "and.ziy"
.cb8c					nt_asm_and_zx:
>cb8c	06 0c						.byte 6, IM+NN
>cb8e	9a cb				                .word nt_asm_and_zxi
>cb90	51 a9 56 a9					.word xt_asm_and_zx, z_asm_and_zx
>cb94	61 6e 64 2e 7a 78				.text "and.zx"
.cb9a					nt_asm_and_zxi:
>cb9a	07 0c						.byte 7, IM+NN
>cb9c	a9 cb				                .word nt_asm_asl
>cb9e	56 a9 5b a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cba2	61 6e 64 2e 7a 78 69				.text "and.zxi"
.cba9					nt_asm_asl:
>cba9	03 0c						.byte 3, IM+NN
>cbab	b4 cb				                .word nt_asm_asl_a
>cbad	5b a9 60 a9					.word xt_asm_asl, z_asm_asl
>cbb1	61 73 6c					.text "asl"
.cbb4					nt_asm_asl_a:
>cbb4	05 0c						.byte 5, IM+NN
>cbb6	c1 cb				                .word nt_asm_asl_x
>cbb8	60 a9 65 a9					.word xt_asm_asl_a, z_asm_asl_a
>cbbc	61 73 6c 2e 61					.text "asl.a"
.cbc1					nt_asm_asl_x:
>cbc1	05 0c						.byte 5, IM+NN
>cbc3	ce cb				                .word nt_asm_asl_z
>cbc5	65 a9 6a a9					.word xt_asm_asl_x, z_asm_asl_x
>cbc9	61 73 6c 2e 78					.text "asl.x"
.cbce					nt_asm_asl_z:
>cbce	05 0c						.byte 5, IM+NN
>cbd0	db cb				                .word nt_asm_asl_zx
>cbd2	6a a9 6f a9					.word xt_asm_asl_z, z_asm_asl_z
>cbd6	61 73 6c 2e 7a					.text "asl.z"
.cbdb					nt_asm_asl_zx:
>cbdb	06 0c						.byte 6, IM+NN
>cbdd	e9 cb				                .word nt_asm_bcc
>cbdf	6f a9 74 a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cbe3	61 73 6c 2e 7a 78				.text "asl.zx"
.cbe9					nt_asm_bcc:
>cbe9	03 0c						.byte 3, IM+NN
>cbeb	f4 cb				                .word nt_asm_bcs
>cbed	74 a9 79 a9					.word xt_asm_bcc, z_asm_bcc
>cbf1	62 63 63					.text "bcc"
.cbf4					nt_asm_bcs:
>cbf4	03 0c						.byte 3, IM+NN
>cbf6	ff cb				                .word nt_asm_beq
>cbf8	79 a9 80 a9					.word xt_asm_bcs, z_asm_bcs
>cbfc	62 63 73					.text "bcs"
.cbff					nt_asm_beq:
>cbff	03 0c						.byte 3, IM+NN
>cc01	0a cc				                .word nt_asm_bit
>cc03	80 a9 85 a9					.word xt_asm_beq, z_asm_beq
>cc07	62 65 71					.text "beq"
.cc0a					nt_asm_bit:
>cc0a	03 0c						.byte 3, IM+NN
>cc0c	15 cc				                .word nt_asm_bit_h
>cc0e	85 a9 8a a9					.word xt_asm_bit, z_asm_bit
>cc12	62 69 74					.text "bit"
.cc15					nt_asm_bit_h:
>cc15	05 0c						.byte 5, IM+NN
>cc17	22 cc				                .word nt_asm_bit_x
>cc19	8a a9 8f a9					.word xt_asm_bit_h, z_asm_bit_h
>cc1d	62 69 74 2e 23					.text "bit.#"
.cc22					nt_asm_bit_x:
>cc22	05 0c						.byte 5, IM+NN
>cc24	2f cc				                .word nt_asm_bit_z
>cc26	8f a9 94 a9					.word xt_asm_bit_x, z_asm_bit_x
>cc2a	62 69 74 2e 78					.text "bit.x"
.cc2f					nt_asm_bit_z:
>cc2f	05 0c						.byte 5, IM+NN
>cc31	3c cc				                .word nt_asm_bit_zx
>cc33	94 a9 99 a9					.word xt_asm_bit_z, z_asm_bit_z
>cc37	62 69 74 2e 7a					.text "bit.z"
.cc3c					nt_asm_bit_zx:
>cc3c	06 0c						.byte 6, IM+NN
>cc3e	4a cc				                .word nt_asm_bmi
>cc40	99 a9 9e a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cc44	62 69 74 2e 7a 78				.text "bit.zx"
.cc4a					nt_asm_bmi:
>cc4a	03 0c						.byte 3, IM+NN
>cc4c	55 cc				                .word nt_asm_bne
>cc4e	9e a9 a3 a9					.word xt_asm_bmi, z_asm_bmi
>cc52	62 6d 69					.text "bmi"
.cc55					nt_asm_bne:
>cc55	03 0c						.byte 3, IM+NN
>cc57	60 cc				                .word nt_asm_bpl
>cc59	a3 a9 a8 a9					.word xt_asm_bne, z_asm_bne
>cc5d	62 6e 65					.text "bne"
.cc60					nt_asm_bpl:
>cc60	03 0c						.byte 3, IM+NN
>cc62	6b cc				                .word nt_asm_bra
>cc64	a8 a9 ad a9					.word xt_asm_bpl, z_asm_bpl
>cc68	62 70 6c					.text "bpl"
.cc6b					nt_asm_bra:
>cc6b	03 0c						.byte 3, IM+NN
>cc6d	76 cc				                .word nt_asm_brk
>cc6f	ad a9 b2 a9					.word xt_asm_bra, z_asm_bra
>cc73	62 72 61					.text "bra"
.cc76					nt_asm_brk:
>cc76	03 0c						.byte 3, IM+NN
>cc78	81 cc				                .word nt_asm_bvc
>cc7a	b2 a9 b7 a9					.word xt_asm_brk, z_asm_brk
>cc7e	62 72 6b					.text "brk"
.cc81					nt_asm_bvc:
>cc81	03 0c						.byte 3, IM+NN
>cc83	8c cc				                .word nt_asm_bvs
>cc85	b7 a9 bc a9					.word xt_asm_bvc, z_asm_bvc
>cc89	62 76 63					.text "bvc"
.cc8c					nt_asm_bvs:
>cc8c	03 0c						.byte 3, IM+NN
>cc8e	97 cc				                .word nt_asm_clc
>cc90	bc a9 c1 a9					.word xt_asm_bvs, z_asm_bvs
>cc94	62 76 73					.text "bvs"
.cc97					nt_asm_clc:
>cc97	03 0c						.byte 3, IM+NN
>cc99	a2 cc				                .word nt_asm_cld
>cc9b	c1 a9 c6 a9					.word xt_asm_clc, z_asm_clc
>cc9f	63 6c 63					.text "clc"
.cca2					nt_asm_cld:
>cca2	03 0c						.byte 3, IM+NN
>cca4	ad cc				                .word nt_asm_cli
>cca6	c6 a9 cb a9					.word xt_asm_cld, z_asm_cld
>ccaa	63 6c 64					.text "cld"
.ccad					nt_asm_cli:
>ccad	03 0c						.byte 3, IM+NN
>ccaf	b8 cc				                .word nt_asm_clv
>ccb1	cb a9 d0 a9					.word xt_asm_cli, z_asm_cli
>ccb5	63 6c 69					.text "cli"
.ccb8					nt_asm_clv:
>ccb8	03 0c						.byte 3, IM+NN
>ccba	c3 cc				                .word nt_asm_cmp
>ccbc	d0 a9 d5 a9					.word xt_asm_clv, z_asm_clv
>ccc0	63 6c 76					.text "clv"
.ccc3					nt_asm_cmp:
>ccc3	03 0c						.byte 3, IM+NN
>ccc5	ce cc				                .word nt_asm_cmp_h
>ccc7	d5 a9 da a9					.word xt_asm_cmp, z_asm_cmp
>cccb	63 6d 70					.text "cmp"
.ccce					nt_asm_cmp_h:
>ccce	05 0c						.byte 5, IM+NN
>ccd0	db cc				                .word nt_asm_cmp_x
>ccd2	da a9 df a9					.word xt_asm_cmp_h, z_asm_cmp_h
>ccd6	63 6d 70 2e 23					.text "cmp.#"
.ccdb					nt_asm_cmp_x:
>ccdb	05 0c						.byte 5, IM+NN
>ccdd	e8 cc				                .word nt_asm_cmp_y
>ccdf	df a9 e4 a9					.word xt_asm_cmp_x, z_asm_cmp_x
>cce3	63 6d 70 2e 78					.text "cmp.x"
.cce8					nt_asm_cmp_y:
>cce8	05 0c						.byte 5, IM+NN
>ccea	f5 cc				                .word nt_asm_cmp_z
>ccec	e4 a9 e9 a9					.word xt_asm_cmp_y, z_asm_cmp_y
>ccf0	63 6d 70 2e 79					.text "cmp.y"
.ccf5					nt_asm_cmp_z:
>ccf5	05 0c						.byte 5, IM+NN
>ccf7	02 cd				                .word nt_asm_cmp_zi
>ccf9	e9 a9 ee a9					.word xt_asm_cmp_z, z_asm_cmp_z
>ccfd	63 6d 70 2e 7a					.text "cmp.z"
.cd02					nt_asm_cmp_zi:
>cd02	06 0c						.byte 6, IM+NN
>cd04	10 cd				                .word nt_asm_cmp_ziy
>cd06	ee a9 f3 a9					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd0a	63 6d 70 2e 7a 69				.text "cmp.zi"
.cd10					nt_asm_cmp_ziy:
>cd10	07 0c						.byte 7, IM+NN
>cd12	1f cd				                .word nt_asm_cmp_zx
>cd14	f3 a9 f8 a9					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd18	63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd1f					nt_asm_cmp_zx:
>cd1f	06 0c						.byte 6, IM+NN
>cd21	2d cd				                .word nt_asm_cmp_zxi
>cd23	f8 a9 fd a9					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd27	63 6d 70 2e 7a 78				.text "cmp.zx"
.cd2d					nt_asm_cmp_zxi:
>cd2d	07 0c						.byte 7, IM+NN
>cd2f	3c cd				                .word nt_asm_cpx
>cd31	fd a9 02 aa					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd35	63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd3c					nt_asm_cpx:
>cd3c	03 0c						.byte 3, IM+NN
>cd3e	47 cd				                .word nt_asm_cpx_h
>cd40	02 aa 07 aa					.word xt_asm_cpx, z_asm_cpx
>cd44	63 70 78					.text "cpx"
.cd47					nt_asm_cpx_h:
>cd47	05 0c						.byte 5, IM+NN
>cd49	54 cd				                .word nt_asm_cpx_z
>cd4b	07 aa 0c aa					.word xt_asm_cpx_h, z_asm_cpx_h
>cd4f	63 70 78 2e 23					.text "cpx.#"
.cd54					nt_asm_cpx_z:
>cd54	05 0c						.byte 5, IM+NN
>cd56	61 cd				                .word nt_asm_cpy
>cd58	0c aa 11 aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cd5c	63 70 78 2e 7a					.text "cpx.z"
.cd61					nt_asm_cpy:
>cd61	03 0c						.byte 3, IM+NN
>cd63	6c cd				                .word nt_asm_cpy_h
>cd65	11 aa 18 aa					.word xt_asm_cpy, z_asm_cpy
>cd69	63 70 79					.text "cpy"
.cd6c					nt_asm_cpy_h:
>cd6c	05 0c						.byte 5, IM+NN
>cd6e	79 cd				                .word nt_asm_cpy_z
>cd70	18 aa 1d aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cd74	63 70 79 2e 23					.text "cpy.#"
.cd79					nt_asm_cpy_z:
>cd79	05 0c						.byte 5, IM+NN
>cd7b	86 cd				                .word nt_asm_dec
>cd7d	1d aa 22 aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cd81	63 70 79 2e 7a					.text "cpy.z"
.cd86					nt_asm_dec:
>cd86	03 0c						.byte 3, IM+NN
>cd88	91 cd				                .word nt_asm_dec_a
>cd8a	22 aa 27 aa					.word xt_asm_dec, z_asm_dec
>cd8e	64 65 63					.text "dec"
.cd91					nt_asm_dec_a:
>cd91	05 0c						.byte 5, IM+NN
>cd93	9e cd				                .word nt_asm_dec_x
>cd95	27 aa 2c aa					.word xt_asm_dec_a, z_asm_dec_a
>cd99	64 65 63 2e 61					.text "dec.a"
.cd9e					nt_asm_dec_x:
>cd9e	05 0c						.byte 5, IM+NN
>cda0	ab cd				                .word nt_asm_dec_z
>cda2	2c aa 31 aa					.word xt_asm_dec_x, z_asm_dec_x
>cda6	64 65 63 2e 78					.text "dec.x"
.cdab					nt_asm_dec_z:
>cdab	05 0c						.byte 5, IM+NN
>cdad	b8 cd				                .word nt_asm_dec_zx
>cdaf	31 aa 36 aa					.word xt_asm_dec_z, z_asm_dec_z
>cdb3	64 65 63 2e 7a					.text "dec.z"
.cdb8					nt_asm_dec_zx:
>cdb8	06 0c						.byte 6, IM+NN
>cdba	c6 cd				                .word nt_asm_dex
>cdbc	36 aa 3b aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cdc0	64 65 63 2e 7a 78				.text "dec.zx"
.cdc6					nt_asm_dex:
>cdc6	03 0c						.byte 3, IM+NN
>cdc8	d1 cd				                .word nt_asm_dey
>cdca	3b aa 40 aa					.word xt_asm_dex, z_asm_dex
>cdce	64 65 78					.text "dex"
.cdd1					nt_asm_dey:
>cdd1	03 0c						.byte 3, IM+NN
>cdd3	dc cd				                .word nt_asm_eor
>cdd5	40 aa 45 aa					.word xt_asm_dey, z_asm_dey
>cdd9	64 65 79					.text "dey"
.cddc					nt_asm_eor:
>cddc	03 0c						.byte 3, IM+NN
>cdde	e7 cd				                .word nt_asm_eor_h
>cde0	45 aa 4a aa					.word xt_asm_eor, z_asm_eor
>cde4	65 6f 72					.text "eor"
.cde7					nt_asm_eor_h:
>cde7	05 0c						.byte 5, IM+NN
>cde9	f4 cd				                .word nt_asm_eor_x
>cdeb	4a aa 4f aa					.word xt_asm_eor_h, z_asm_eor_h
>cdef	65 6f 72 2e 23					.text "eor.#"
.cdf4					nt_asm_eor_x:
>cdf4	05 0c						.byte 5, IM+NN
>cdf6	01 ce				                .word nt_asm_eor_y
>cdf8	4f aa 54 aa					.word xt_asm_eor_x, z_asm_eor_x
>cdfc	65 6f 72 2e 78					.text "eor.x"
.ce01					nt_asm_eor_y:
>ce01	05 0c						.byte 5, IM+NN
>ce03	0e ce				                .word nt_asm_eor_z
>ce05	54 aa 59 aa					.word xt_asm_eor_y, z_asm_eor_y
>ce09	65 6f 72 2e 79					.text "eor.y"
.ce0e					nt_asm_eor_z:
>ce0e	05 0c						.byte 5, IM+NN
>ce10	1b ce				                .word nt_asm_eor_zi
>ce12	59 aa 5e aa					.word xt_asm_eor_z, z_asm_eor_z
>ce16	65 6f 72 2e 7a					.text "eor.z"
.ce1b					nt_asm_eor_zi:
>ce1b	06 0c						.byte 6, IM+NN
>ce1d	29 ce				                .word nt_asm_eor_ziy
>ce1f	5e aa 63 aa					.word xt_asm_eor_zi, z_asm_eor_zi
>ce23	65 6f 72 2e 7a 69				.text "eor.zi"
.ce29					nt_asm_eor_ziy:
>ce29	07 0c						.byte 7, IM+NN
>ce2b	38 ce				                .word nt_asm_eor_zx
>ce2d	63 aa 68 aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce31	65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce38					nt_asm_eor_zx:
>ce38	06 0c						.byte 6, IM+NN
>ce3a	46 ce				                .word nt_asm_eor_zxi
>ce3c	68 aa 6d aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce40	65 6f 72 2e 7a 78				.text "eor.zx"
.ce46					nt_asm_eor_zxi:
>ce46	07 0c						.byte 7, IM+NN
>ce48	55 ce				                .word nt_asm_inc
>ce4a	6d aa 72 aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce4e	65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce55					nt_asm_inc:
>ce55	03 0c						.byte 3, IM+NN
>ce57	60 ce				                .word nt_asm_inc_a
>ce59	72 aa 77 aa					.word xt_asm_inc, z_asm_inc
>ce5d	69 6e 63					.text "inc"
.ce60					nt_asm_inc_a:
>ce60	05 0c						.byte 5, IM+NN
>ce62	6d ce				                .word nt_asm_inc_x
>ce64	77 aa 7c aa					.word xt_asm_inc_a, z_asm_inc_a
>ce68	69 6e 63 2e 61					.text "inc.a"
.ce6d					nt_asm_inc_x:
>ce6d	05 0c						.byte 5, IM+NN
>ce6f	7a ce				                .word nt_asm_inc_z
>ce71	7c aa 81 aa					.word xt_asm_inc_x, z_asm_inc_x
>ce75	69 6e 63 2e 78					.text "inc.x"
.ce7a					nt_asm_inc_z:
>ce7a	05 0c						.byte 5, IM+NN
>ce7c	87 ce				                .word nt_asm_inc_zx
>ce7e	81 aa 86 aa					.word xt_asm_inc_z, z_asm_inc_z
>ce82	69 6e 63 2e 7a					.text "inc.z"
.ce87					nt_asm_inc_zx:
>ce87	06 0c						.byte 6, IM+NN
>ce89	95 ce				                .word nt_asm_inx
>ce8b	86 aa 8b aa					.word xt_asm_inc_zx, z_asm_inc_zx
>ce8f	69 6e 63 2e 7a 78				.text "inc.zx"
.ce95					nt_asm_inx:
>ce95	03 0c						.byte 3, IM+NN
>ce97	a0 ce				                .word nt_asm_iny
>ce99	8b aa 90 aa					.word xt_asm_inx, z_asm_inx
>ce9d	69 6e 78					.text "inx"
.cea0					nt_asm_iny:
>cea0	03 0c						.byte 3, IM+NN
>cea2	ab ce				                .word nt_asm_jmp
>cea4	90 aa 95 aa					.word xt_asm_iny, z_asm_iny
>cea8	69 6e 79					.text "iny"
.ceab					nt_asm_jmp:
>ceab	03 0c						.byte 3, IM+NN
>cead	b6 ce				                .word nt_asm_jmp_i
>ceaf	95 aa 9a aa					.word xt_asm_jmp, z_asm_jmp
>ceb3	6a 6d 70					.text "jmp"
.ceb6					nt_asm_jmp_i:
>ceb6	05 0c						.byte 5, IM+NN
>ceb8	c3 ce				                .word nt_asm_jmp_xi
>ceba	9a aa 9f aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cebe	6a 6d 70 2e 69					.text "jmp.i"
.cec3					nt_asm_jmp_xi:
>cec3	06 0c						.byte 6, IM+NN
>cec5	d1 ce				                .word nt_asm_jsr
>cec7	9f aa a4 aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cecb	6a 6d 70 2e 78 69				.text "jmp.xi"
.ced1					nt_asm_jsr:
>ced1	03 0c						.byte 3, IM+NN
>ced3	dc ce				                .word nt_asm_lda
>ced5	a4 aa a9 aa					.word xt_asm_jsr, z_asm_jsr
>ced9	6a 73 72					.text "jsr"
.cedc					nt_asm_lda:
>cedc	03 0c						.byte 3, IM+NN
>cede	e7 ce				                .word nt_asm_lda_h
>cee0	a9 aa ae aa					.word xt_asm_lda, z_asm_lda
>cee4	6c 64 61					.text "lda"
.cee7					nt_asm_lda_h:
>cee7	05 0c						.byte 5, IM+NN
>cee9	f4 ce				                .word nt_asm_lda_x
>ceeb	ae aa b3 aa					.word xt_asm_lda_h, z_asm_lda_h
>ceef	6c 64 61 2e 23					.text "lda.#"
.cef4					nt_asm_lda_x:
>cef4	05 0c						.byte 5, IM+NN
>cef6	01 cf				                .word nt_asm_lda_y
>cef8	b3 aa b8 aa					.word xt_asm_lda_x, z_asm_lda_x
>cefc	6c 64 61 2e 78					.text "lda.x"
.cf01					nt_asm_lda_y:
>cf01	05 0c						.byte 5, IM+NN
>cf03	0e cf				                .word nt_asm_lda_z
>cf05	b8 aa bd aa					.word xt_asm_lda_y, z_asm_lda_y
>cf09	6c 64 61 2e 79					.text "lda.y"
.cf0e					nt_asm_lda_z:
>cf0e	05 0c						.byte 5, IM+NN
>cf10	1b cf				                .word nt_asm_lda_zi
>cf12	bd aa c2 aa					.word xt_asm_lda_z, z_asm_lda_z
>cf16	6c 64 61 2e 7a					.text "lda.z"
.cf1b					nt_asm_lda_zi:
>cf1b	06 0c						.byte 6, IM+NN
>cf1d	29 cf				                .word nt_asm_lda_ziy
>cf1f	c2 aa c7 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cf23	6c 64 61 2e 7a 69				.text "lda.zi"
.cf29					nt_asm_lda_ziy:
>cf29	07 0c						.byte 7, IM+NN
>cf2b	38 cf				                .word nt_asm_lda_zx
>cf2d	c7 aa cc aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf31	6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf38					nt_asm_lda_zx:
>cf38	06 0c						.byte 6, IM+NN
>cf3a	46 cf				                .word nt_asm_lda_zxi
>cf3c	cc aa d1 aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cf40	6c 64 61 2e 7a 78				.text "lda.zx"
.cf46					nt_asm_lda_zxi:
>cf46	07 0c						.byte 7, IM+NN
>cf48	55 cf				                .word nt_asm_ldx
>cf4a	d1 aa d6 aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf4e	6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf55					nt_asm_ldx:
>cf55	03 0c						.byte 3, IM+NN
>cf57	60 cf				                .word nt_asm_ldx_h
>cf59	d6 aa db aa					.word xt_asm_ldx, z_asm_ldx
>cf5d	6c 64 78					.text "ldx"
.cf60					nt_asm_ldx_h:
>cf60	05 0c						.byte 5, IM+NN
>cf62	6d cf				                .word nt_asm_ldx_y
>cf64	db aa e0 aa					.word xt_asm_ldx_h, z_asm_ldx_h
>cf68	6c 64 78 2e 23					.text "ldx.#"
.cf6d					nt_asm_ldx_y:
>cf6d	05 0c						.byte 5, IM+NN
>cf6f	7a cf				                .word nt_asm_ldx_z
>cf71	e0 aa e5 aa					.word xt_asm_ldx_y, z_asm_ldx_y
>cf75	6c 64 78 2e 79					.text "ldx.y"
.cf7a					nt_asm_ldx_z:
>cf7a	05 0c						.byte 5, IM+NN
>cf7c	87 cf				                .word nt_asm_ldx_zy
>cf7e	e5 aa ea aa					.word xt_asm_ldx_z, z_asm_ldx_z
>cf82	6c 64 78 2e 7a					.text "ldx.z"
.cf87					nt_asm_ldx_zy:
>cf87	06 0c						.byte 6, IM+NN
>cf89	95 cf				                .word nt_asm_ldy
>cf8b	ea aa ef aa					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cf8f	6c 64 78 2e 7a 79				.text "ldx.zy"
.cf95					nt_asm_ldy:
>cf95	03 0c						.byte 3, IM+NN
>cf97	a0 cf				                .word nt_asm_ldy_h
>cf99	ef aa f4 aa					.word xt_asm_ldy, z_asm_ldy
>cf9d	6c 64 79					.text "ldy"
.cfa0					nt_asm_ldy_h:
>cfa0	05 0c						.byte 5, IM+NN
>cfa2	ad cf				                .word nt_asm_ldy_x
>cfa4	f4 aa f9 aa					.word xt_asm_ldy_h, z_asm_ldy_h
>cfa8	6c 64 79 2e 23					.text "ldy.#"
.cfad					nt_asm_ldy_x:
>cfad	05 0c						.byte 5, IM+NN
>cfaf	ba cf				                .word nt_asm_ldy_z
>cfb1	f9 aa fe aa					.word xt_asm_ldy_x, z_asm_ldy_x
>cfb5	6c 64 79 2e 78					.text "ldy.x"
.cfba					nt_asm_ldy_z:
>cfba	05 0c						.byte 5, IM+NN
>cfbc	c7 cf				                .word nt_asm_ldy_zx
>cfbe	fe aa 03 ab					.word xt_asm_ldy_z, z_asm_ldy_z
>cfc2	6c 64 79 2e 7a					.text "ldy.z"
.cfc7					nt_asm_ldy_zx:
>cfc7	06 0c						.byte 6, IM+NN
>cfc9	d5 cf				                .word nt_asm_lsr
>cfcb	03 ab 08 ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cfcf	6c 64 79 2e 7a 78				.text "ldy.zx"
.cfd5					nt_asm_lsr:
>cfd5	03 0c						.byte 3, IM+NN
>cfd7	e0 cf				                .word nt_asm_lsr_a
>cfd9	08 ab 0d ab					.word xt_asm_lsr, z_asm_lsr
>cfdd	6c 73 72					.text "lsr"
.cfe0					nt_asm_lsr_a:
>cfe0	05 0c						.byte 5, IM+NN
>cfe2	ed cf				                .word nt_asm_lsr_x
>cfe4	0d ab 12 ab					.word xt_asm_lsr_a, z_asm_lsr_a
>cfe8	6c 73 72 2e 61					.text "lsr.a"
.cfed					nt_asm_lsr_x:
>cfed	05 0c						.byte 5, IM+NN
>cfef	fa cf				                .word nt_asm_lsr_z
>cff1	12 ab 17 ab					.word xt_asm_lsr_x, z_asm_lsr_x
>cff5	6c 73 72 2e 78					.text "lsr.x"
.cffa					nt_asm_lsr_z:
>cffa	05 0c						.byte 5, IM+NN
>cffc	07 d0				                .word nt_asm_lsr_zx
>cffe	17 ab 1c ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d002	6c 73 72 2e 7a					.text "lsr.z"
.d007					nt_asm_lsr_zx:
>d007	06 0c						.byte 6, IM+NN
>d009	15 d0				                .word nt_asm_nop
>d00b	1c ab 21 ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d00f	6c 73 72 2e 7a 78				.text "lsr.zx"
.d015					nt_asm_nop:
>d015	03 0c						.byte 3, IM+NN
>d017	20 d0				                .word nt_asm_ora
>d019	21 ab 26 ab					.word xt_asm_nop, z_asm_nop
>d01d	6e 6f 70					.text "nop"
.d020					nt_asm_ora:
>d020	03 0c						.byte 3, IM+NN
>d022	2b d0				                .word nt_asm_ora_h
>d024	26 ab 2b ab					.word xt_asm_ora, z_asm_ora
>d028	6f 72 61					.text "ora"
.d02b					nt_asm_ora_h:
>d02b	05 0c						.byte 5, IM+NN
>d02d	38 d0				                .word nt_asm_ora_x
>d02f	2b ab 30 ab					.word xt_asm_ora_h, z_asm_ora_h
>d033	6f 72 61 2e 23					.text "ora.#"
.d038					nt_asm_ora_x:
>d038	05 0c						.byte 5, IM+NN
>d03a	45 d0				                .word nt_asm_ora_y
>d03c	30 ab 35 ab					.word xt_asm_ora_x, z_asm_ora_x
>d040	6f 72 61 2e 78					.text "ora.x"
.d045					nt_asm_ora_y:
>d045	05 0c						.byte 5, IM+NN
>d047	52 d0				                .word nt_asm_ora_z
>d049	35 ab 3a ab					.word xt_asm_ora_y, z_asm_ora_y
>d04d	6f 72 61 2e 79					.text "ora.y"
.d052					nt_asm_ora_z:
>d052	05 0c						.byte 5, IM+NN
>d054	5f d0				                .word nt_asm_ora_zi
>d056	3a ab 3f ab					.word xt_asm_ora_z, z_asm_ora_z
>d05a	6f 72 61 2e 7a					.text "ora.z"
.d05f					nt_asm_ora_zi:
>d05f	06 0c						.byte 6, IM+NN
>d061	6d d0				                .word nt_asm_ora_ziy
>d063	3f ab 46 ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d067	6f 72 61 2e 7a 69				.text "ora.zi"
.d06d					nt_asm_ora_ziy:
>d06d	07 0c						.byte 7, IM+NN
>d06f	7c d0				                .word nt_asm_ora_zx
>d071	46 ab 4b ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d075	6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d07c					nt_asm_ora_zx:
>d07c	06 0c						.byte 6, IM+NN
>d07e	8a d0				                .word nt_asm_ora_zxi
>d080	4b ab 50 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d084	6f 72 61 2e 7a 78				.text "ora.zx"
.d08a					nt_asm_ora_zxi:
>d08a	07 0c						.byte 7, IM+NN
>d08c	99 d0				                .word nt_asm_pha
>d08e	50 ab 55 ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d092	6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d099					nt_asm_pha:
>d099	03 0c						.byte 3, IM+NN
>d09b	a4 d0				                .word nt_asm_php
>d09d	55 ab 5a ab					.word xt_asm_pha, z_asm_pha
>d0a1	70 68 61					.text "pha"
.d0a4					nt_asm_php:
>d0a4	03 0c						.byte 3, IM+NN
>d0a6	af d0				                .word nt_asm_phx
>d0a8	5a ab 5f ab					.word xt_asm_php, z_asm_php
>d0ac	70 68 70					.text "php"
.d0af					nt_asm_phx:
>d0af	03 0c						.byte 3, IM+NN
>d0b1	ba d0				                .word nt_asm_phy
>d0b3	5f ab 64 ab					.word xt_asm_phx, z_asm_phx
>d0b7	70 68 78					.text "phx"
.d0ba					nt_asm_phy:
>d0ba	03 0c						.byte 3, IM+NN
>d0bc	c5 d0				                .word nt_asm_pla
>d0be	64 ab 69 ab					.word xt_asm_phy, z_asm_phy
>d0c2	70 68 79					.text "phy"
.d0c5					nt_asm_pla:
>d0c5	03 0c						.byte 3, IM+NN
>d0c7	d0 d0				                .word nt_asm_plp
>d0c9	69 ab 6e ab					.word xt_asm_pla, z_asm_pla
>d0cd	70 6c 61					.text "pla"
.d0d0					nt_asm_plp:
>d0d0	03 0c						.byte 3, IM+NN
>d0d2	db d0				                .word nt_asm_plx
>d0d4	6e ab 73 ab					.word xt_asm_plp, z_asm_plp
>d0d8	70 6c 70					.text "plp"
.d0db					nt_asm_plx:
>d0db	03 0c						.byte 3, IM+NN
>d0dd	e6 d0				                .word nt_asm_ply
>d0df	73 ab 78 ab					.word xt_asm_plx, z_asm_plx
>d0e3	70 6c 78					.text "plx"
.d0e6					nt_asm_ply:
>d0e6	03 0c						.byte 3, IM+NN
>d0e8	f1 d0				                .word nt_asm_rol
>d0ea	78 ab 7d ab					.word xt_asm_ply, z_asm_ply
>d0ee	70 6c 79					.text "ply"
.d0f1					nt_asm_rol:
>d0f1	03 0c						.byte 3, IM+NN
>d0f3	fc d0				                .word nt_asm_rol_a
>d0f5	7d ab 82 ab					.word xt_asm_rol, z_asm_rol
>d0f9	72 6f 6c					.text "rol"
.d0fc					nt_asm_rol_a:
>d0fc	05 0c						.byte 5, IM+NN
>d0fe	09 d1				                .word nt_asm_rol_x
>d100	82 ab 87 ab					.word xt_asm_rol_a, z_asm_rol_a
>d104	72 6f 6c 2e 61					.text "rol.a"
.d109					nt_asm_rol_x:
>d109	05 0c						.byte 5, IM+NN
>d10b	16 d1				                .word nt_asm_rol_z
>d10d	87 ab 8c ab					.word xt_asm_rol_x, z_asm_rol_x
>d111	72 6f 6c 2e 78					.text "rol.x"
.d116					nt_asm_rol_z:
>d116	05 0c						.byte 5, IM+NN
>d118	23 d1				                .word nt_asm_rol_zx
>d11a	8c ab 91 ab					.word xt_asm_rol_z, z_asm_rol_z
>d11e	72 6f 6c 2e 7a					.text "rol.z"
.d123					nt_asm_rol_zx:
>d123	06 0c						.byte 6, IM+NN
>d125	31 d1				                .word nt_asm_ror
>d127	91 ab 96 ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d12b	72 6f 6c 2e 7a 78				.text "rol.zx"
.d131					nt_asm_ror:
>d131	03 0c						.byte 3, IM+NN
>d133	3c d1				                .word nt_asm_ror_a
>d135	96 ab 9b ab					.word xt_asm_ror, z_asm_ror
>d139	72 6f 72					.text "ror"
.d13c					nt_asm_ror_a:
>d13c	05 0c						.byte 5, IM+NN
>d13e	49 d1				                .word nt_asm_ror_x
>d140	9b ab a0 ab					.word xt_asm_ror_a, z_asm_ror_a
>d144	72 6f 72 2e 61					.text "ror.a"
.d149					nt_asm_ror_x:
>d149	05 0c						.byte 5, IM+NN
>d14b	56 d1				                .word nt_asm_ror_z
>d14d	a0 ab a5 ab					.word xt_asm_ror_x, z_asm_ror_x
>d151	72 6f 72 2e 78					.text "ror.x"
.d156					nt_asm_ror_z:
>d156	05 0c						.byte 5, IM+NN
>d158	63 d1				                .word nt_asm_ror_zx
>d15a	a5 ab aa ab					.word xt_asm_ror_z, z_asm_ror_z
>d15e	72 6f 72 2e 7a					.text "ror.z"
.d163					nt_asm_ror_zx:
>d163	06 0c						.byte 6, IM+NN
>d165	71 d1				                .word nt_asm_rti
>d167	aa ab af ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d16b	72 6f 72 2e 7a 78				.text "ror.zx"
.d171					nt_asm_rti:
>d171	03 0c						.byte 3, IM+NN
>d173	7c d1				                .word nt_asm_rts
>d175	af ab b4 ab					.word xt_asm_rti, z_asm_rti
>d179	72 74 69					.text "rti"
.d17c					nt_asm_rts:
>d17c	03 0c						.byte 3, IM+NN
>d17e	87 d1				                .word nt_asm_sbc
>d180	b4 ab b9 ab					.word xt_asm_rts, z_asm_rts
>d184	72 74 73					.text "rts"
.d187					nt_asm_sbc:
>d187	03 0c						.byte 3, IM+NN
>d189	92 d1				                .word nt_asm_sbc_h
>d18b	b9 ab be ab					.word xt_asm_sbc, z_asm_sbc
>d18f	73 62 63					.text "sbc"
.d192					nt_asm_sbc_h:
>d192	05 0c						.byte 5, IM+NN
>d194	9f d1				                .word nt_asm_sbc_x
>d196	be ab c3 ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d19a	73 62 63 2e 23					.text "sbc.#"
.d19f					nt_asm_sbc_x:
>d19f	05 0c						.byte 5, IM+NN
>d1a1	ac d1				                .word nt_asm_sbc_y
>d1a3	c3 ab c8 ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d1a7	73 62 63 2e 78					.text "sbc.x"
.d1ac					nt_asm_sbc_y:
>d1ac	05 0c						.byte 5, IM+NN
>d1ae	b9 d1				                .word nt_asm_sbc_z
>d1b0	c8 ab cd ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d1b4	73 62 63 2e 79					.text "sbc.y"
.d1b9					nt_asm_sbc_z:
>d1b9	05 0c						.byte 5, IM+NN
>d1bb	c6 d1				                .word nt_asm_sbc_zi
>d1bd	cd ab d2 ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d1c1	73 62 63 2e 7a					.text "sbc.z"
.d1c6					nt_asm_sbc_zi:
>d1c6	06 0c						.byte 6, IM+NN
>d1c8	d4 d1				                .word nt_asm_sbc_ziy
>d1ca	d2 ab d7 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d1ce	73 62 63 2e 7a 69				.text "sbc.zi"
.d1d4					nt_asm_sbc_ziy:
>d1d4	07 0c						.byte 7, IM+NN
>d1d6	e3 d1				                .word nt_asm_sbc_zx
>d1d8	d7 ab dc ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d1dc	73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d1e3					nt_asm_sbc_zx:
>d1e3	06 0c						.byte 6, IM+NN
>d1e5	f1 d1				                .word nt_asm_sbc_zxi
>d1e7	dc ab e1 ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d1eb	73 62 63 2e 7a 78				.text "sbc.zx"
.d1f1					nt_asm_sbc_zxi:
>d1f1	07 0c						.byte 7, IM+NN
>d1f3	00 d2				                .word nt_asm_sec
>d1f5	e1 ab e5 ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d1f9	73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d200					nt_asm_sec:
>d200	03 0c						.byte 3, IM+NN
>d202	0b d2				                .word nt_asm_sed
>d204	e5 ab e9 ab					.word xt_asm_sec, z_asm_sec
>d208	73 65 63					.text "sec"
.d20b					nt_asm_sed:
>d20b	03 0c						.byte 3, IM+NN
>d20d	16 d2				                .word nt_asm_sei
>d20f	e9 ab ed ab					.word xt_asm_sed, z_asm_sed
>d213	73 65 64					.text "sed"
.d216					nt_asm_sei:
>d216	03 0c						.byte 3, IM+NN
>d218	21 d2				                .word nt_asm_sta
>d21a	ed ab f1 ab					.word xt_asm_sei, z_asm_sei
>d21e	73 65 69					.text "sei"
.d221					nt_asm_sta:
>d221	03 0c						.byte 3, IM+NN
>d223	2c d2				                .word nt_asm_sta_x
>d225	f1 ab f5 ab					.word xt_asm_sta, z_asm_sta
>d229	73 74 61					.text "sta"
.d22c					nt_asm_sta_x:
>d22c	05 0c						.byte 5, IM+NN
>d22e	39 d2				                .word nt_asm_sta_y
>d230	f5 ab f9 ab					.word xt_asm_sta_x, z_asm_sta_x
>d234	73 74 61 2e 78					.text "sta.x"
.d239					nt_asm_sta_y:
>d239	05 0c						.byte 5, IM+NN
>d23b	46 d2				                .word nt_asm_sta_z
>d23d	f9 ab fd ab					.word xt_asm_sta_y, z_asm_sta_y
>d241	73 74 61 2e 79					.text "sta.y"
.d246					nt_asm_sta_z:
>d246	05 0c						.byte 5, IM+NN
>d248	53 d2				                .word nt_asm_sta_zi
>d24a	fd ab 01 ac					.word xt_asm_sta_z, z_asm_sta_z
>d24e	73 74 61 2e 7a					.text "sta.z"
.d253					nt_asm_sta_zi:
>d253	06 0c						.byte 6, IM+NN
>d255	61 d2				                .word nt_asm_sta_ziy
>d257	01 ac 05 ac					.word xt_asm_sta_zi, z_asm_sta_zi
>d25b	73 74 61 2e 7a 69				.text "sta.zi"
.d261					nt_asm_sta_ziy:
>d261	07 0c						.byte 7, IM+NN
>d263	70 d2				                .word nt_asm_sta_zx
>d265	05 ac 09 ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d269	73 74 61 2e 7a 69 79				.text "sta.ziy"
.d270					nt_asm_sta_zx:
>d270	06 0c						.byte 6, IM+NN
>d272	7e d2				                .word nt_asm_sta_zxi
>d274	09 ac 0d ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d278	73 74 61 2e 7a 78				.text "sta.zx"
.d27e					nt_asm_sta_zxi:
>d27e	07 0c						.byte 7, IM+NN
>d280	8d d2				                .word nt_asm_stx
>d282	0d ac 11 ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d286	73 74 61 2e 7a 78 69				.text "sta.zxi"
.d28d					nt_asm_stx:
>d28d	03 0c						.byte 3, IM+NN
>d28f	98 d2				                .word nt_asm_stx_z
>d291	11 ac 15 ac					.word xt_asm_stx, z_asm_stx
>d295	73 74 78					.text "stx"
.d298					nt_asm_stx_z:
>d298	05 0c						.byte 5, IM+NN
>d29a	a5 d2				                .word nt_asm_stx_zy
>d29c	15 ac 19 ac					.word xt_asm_stx_z, z_asm_stx_z
>d2a0	73 74 78 2e 7a					.text "stx.z"
.d2a5					nt_asm_stx_zy:
>d2a5	06 0c						.byte 6, IM+NN
>d2a7	b3 d2				                .word nt_asm_sty
>d2a9	19 ac 1d ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d2ad	73 74 78 2e 7a 79				.text "stx.zy"
.d2b3					nt_asm_sty:
>d2b3	03 0c						.byte 3, IM+NN
>d2b5	be d2				                .word nt_asm_sty_z
>d2b7	1d ac 21 ac					.word xt_asm_sty, z_asm_sty
>d2bb	73 74 79					.text "sty"
.d2be					nt_asm_sty_z:
>d2be	05 0c						.byte 5, IM+NN
>d2c0	cb d2				                .word nt_asm_sty_zx
>d2c2	21 ac 25 ac					.word xt_asm_sty_z, z_asm_sty_z
>d2c6	73 74 79 2e 7a					.text "sty.z"
.d2cb					nt_asm_sty_zx:
>d2cb	06 0c						.byte 6, IM+NN
>d2cd	d9 d2				                .word nt_asm_stz
>d2cf	25 ac 29 ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d2d3	73 74 79 2e 7a 78				.text "sty.zx"
.d2d9					nt_asm_stz:
>d2d9	03 0c						.byte 3, IM+NN
>d2db	e4 d2				                .word nt_asm_stz_x
>d2dd	29 ac 2d ac					.word xt_asm_stz, z_asm_stz
>d2e1	73 74 7a					.text "stz"
.d2e4					nt_asm_stz_x:
>d2e4	05 0c						.byte 5, IM+NN
>d2e6	f1 d2				                .word nt_asm_stz_z
>d2e8	2d ac 31 ac					.word xt_asm_stz_x, z_asm_stz_x
>d2ec	73 74 7a 2e 78					.text "stz.x"
.d2f1					nt_asm_stz_z:
>d2f1	05 0c						.byte 5, IM+NN
>d2f3	fe d2				                .word nt_asm_stz_zx
>d2f5	31 ac 35 ac					.word xt_asm_stz_z, z_asm_stz_z
>d2f9	73 74 7a 2e 7a					.text "stz.z"
.d2fe					nt_asm_stz_zx:
>d2fe	06 0c						.byte 6, IM+NN
>d300	0c d3				                .word nt_asm_tax
>d302	35 ac 39 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d306	73 74 7a 2e 7a 78				.text "stz.zx"
.d30c					nt_asm_tax:
>d30c	03 0c						.byte 3, IM+NN
>d30e	17 d3				                .word nt_asm_tay
>d310	39 ac 3d ac					.word xt_asm_tax, z_asm_tax
>d314	74 61 78					.text "tax"
.d317					nt_asm_tay:
>d317	03 0c						.byte 3, IM+NN
>d319	22 d3				                .word nt_asm_trb
>d31b	3d ac 41 ac					.word xt_asm_tay, z_asm_tay
>d31f	74 61 79					.text "tay"
.d322					nt_asm_trb:
>d322	03 0c						.byte 3, IM+NN
>d324	2d d3				                .word nt_asm_trb_z
>d326	41 ac 45 ac					.word xt_asm_trb, z_asm_trb
>d32a	74 72 62					.text "trb"
.d32d					nt_asm_trb_z:
>d32d	05 0c						.byte 5, IM+NN
>d32f	3a d3				                .word nt_asm_tsb
>d331	45 ac 49 ac					.word xt_asm_trb_z, z_asm_trb_z
>d335	74 72 62 2e 7a					.text "trb.z"
.d33a					nt_asm_tsb:
>d33a	03 0c						.byte 3, IM+NN
>d33c	45 d3				                .word nt_asm_tsb_z
>d33e	49 ac 4d ac					.word xt_asm_tsb, z_asm_tsb
>d342	74 73 62					.text "tsb"
.d345					nt_asm_tsb_z:
>d345	05 0c						.byte 5, IM+NN
>d347	52 d3				                .word nt_asm_tsx
>d349	4d ac 51 ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d34d	74 73 62 2e 7a					.text "tsb.z"
.d352					nt_asm_tsx:
>d352	03 0c						.byte 3, IM+NN
>d354	5d d3				                .word nt_asm_txa
>d356	51 ac 55 ac					.word xt_asm_tsx, z_asm_tsx
>d35a	74 73 78					.text "tsx"
.d35d					nt_asm_txa:
>d35d	03 0c						.byte 3, IM+NN
>d35f	68 d3				                .word nt_asm_txs
>d361	55 ac 59 ac					.word xt_asm_txa, z_asm_txa
>d365	74 78 61					.text "txa"
.d368					nt_asm_txs:
>d368	03 0c						.byte 3, IM+NN
>d36a	73 d3				                .word nt_asm_tya
>d36c	59 ac 5d ac					.word xt_asm_txs, z_asm_txs
>d370	74 78 73					.text "txs"
.d373					nt_asm_tya:
>d373	03 0c						.byte 3, IM+NN
>d375	7e d3				                .word nt_asm_arrow
>d377	5d ac 61 ac					.word xt_asm_tya, z_asm_tya
>d37b	74 79 61					.text "tya"
.d37e					nt_asm_arrow:
>d37e	03 04				                .byte 3, IM
>d380	89 d3				                .word nt_asm_back_jump
>d382	6c 91 76 91			                .word xt_asm_arrow, z_asm_arrow
>d386	2d 2d 3e			                .text "-->"
.d389					nt_asm_back_jump:
>d389	02 04				                .byte 2, IM
>d38b	93 d3				                .word nt_asm_back_branch
>d38d	b2 ac b2 ac			                .word xt_asm_back_jump, z_asm_back_jump
>d391	3c 6a				                .text "<j"
.d393					nt_asm_back_branch:
>d393	02 04				                .byte 2, IM
>d395	9d d3				                .word nt_asm_push_a
>d397	b3 ac bb ac			                .word xt_asm_back_branch, z_asm_back_branch
>d39b	3c 62				                .text "<b"
.d39d					nt_asm_push_a:
>d39d	06 0c				                .byte 6, IM+NN
>d39f	00 00				                .word 0000
>d3a1	9b ac aa ac			                .word xt_asm_push_a, z_asm_push_a
>d3a5	70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0					str_ok             =  0
=1					str_compile        =  1
=2					str_redefined      =  2
=3					str_wid_forth      =  3
=4					str_abc_lower      =  4
=5					str_abc_upper      =  5
=6					str_wid_editor     =  6
=7					str_wid_assembler  =  7
=8					str_wid_root       =  8
=9					str_see_flags      =  9
=10					str_see_nt         = 10
=11					str_see_xt         = 11
=12					str_see_size       = 12
=13					str_disasm_lit     = 13
=14					str_disasm_sdc     = 14
=15					str_disasm_bra     = 15
.d3ab					string_table:
>d3ab	cb d3 cf d3 d9 d3 3f d4		        .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
>d3b3	e4 d3
>d3b5	08 d4 37 d4 2c d4 46 d4		        .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
>d3bd	4c d4 68 d4 6d d4 72 d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
>d3c5	83 d4 8c d4 9e d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 13-15
>d3cb	20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d3cf	20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d3d7	64 00
>d3d9	72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d3e1	64 20 00
>d3e4	30 31 32 33 34 35 36 37		s_abc_lower:  .text "0123456789abcdefghijklmnopqrstuvwxyz"
>d3ec	38 39 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e
>d3fc	6f 70 71 72 73 74 75 76 77 78 79 7a
>d408	30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d410	38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d420	4f 50 51 52 53 54 55 56 57 58 59 5a
>d42c	41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d434	72 20 00
>d437	45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d43f	46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d446	52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d44c	66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d454	4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d464	29 3a 20 00
>d468	6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d46d	78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d472	73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d47a	63 69 6d 61 6c 29 3a 20 00
>d483	4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d48b	00
>d48c	53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d494	50 54 48 20 43 48 45 43 4b 00
>d49e	42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0					err_allot        = 0
=1					err_badsource    = 1
=2					err_compileonly  = 2
=3					err_defer        = 3
=4					err_divzero      = 4
=5					err_noname       = 5
=6					err_refill       = 6
=7					err_state        = 7
=8					err_syntax       = 8
=9					err_underflow    = 9
=10					err_negallot     = 10
=11					err_wordlist     = 11
=12					err_blockwords   = 12
.d4a6					error_table:
>d4a6	c0 d4 e1 d4 01 d5 22 d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4ae	3f d5 50 d5 60 d5 8e d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4b6	a6 d5 b5 d5 c5 d5 e1 d5		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4be	f8 d5				        .word es_blockwords                                    ; 12
>d4c0	41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d4c8	69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d4d8	65 20 6d 65 6d 6f 72 79 00
>d4e1	49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d4e9	53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d4f9	20 52 45 46 49 4c 4c 00
>d501	49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d509	74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d519	6e 6c 79 20 77 6f 72 64 00
>d522	44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d52a	77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d53a	20 79 65 74 00
>d53f	44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d547	20 62 79 20 7a 65 72 6f 00
>d550	50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d558	66 61 69 6c 75 72 65 00
>d560	51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d568	6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d578	20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d588	64 20 2d 31 29 00
>d58e	41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d596	69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5a6	55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word", 0
>d5ae	64 20 77 6f 72 64 00
>d5b5	53 74 61 63 6b 20 75 6e		es_underflow:   .text "Stack underflow", 0
>d5bd	64 65 72 66 6c 6f 77 00
>d5c5	4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d5cd	72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d5dd	4c 4f 54 00
>d5e1	4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d5e9	69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d5f8	50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d600	73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d610	4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d620	61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d630	56 45 43 54 4f 52 00
>d637	0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d63f	44 2d 53 54 52 49 4e 47
>d647	05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d64d	04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d652	11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d65a	2d 55 4e 49 54 2d 42 49 54 53
>d664	07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d66c	08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d674	52
>d675	05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d67b	05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d681	12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d689	53 54 41 43 4b 2d 43 45 4c 4c 53
>d694	0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d69c	45 4c 4c 53
>d6a0	09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d6a8	54 53
>d6aa	05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d6b0	06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d6b7					cmpl_subroutine:
.d6b7	48		pha		                pha             ; save LSB of address
.d6b8	a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d6ba	80 03		bra $d6bf	                bra cmpl_common
.d6bc					cmpl_jump:
.d6bc	48		pha		                pha             ; save LSB of address
.d6bd	a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d6bf					cmpl_common:
.d6bf	20 c7 d6	jsr $d6c7	                jsr cmpl_a      ; compile opcode
.d6c2	68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d6c3					cmpl_word:
.d6c3	20 c7 d6	jsr $d6c7	                jsr cmpl_a      ; compile LSB of address
.d6c6	98		tya		                tya             ; fall thru for MSB
.d6c7					cmpl_a:
.d6c7	92 00		sta ($00)	                sta (cp)
.d6c9	e6 00		inc $00		                inc cp
.d6cb	d0 02		bne $d6cf	                bne _done
.d6cd	e6 01		inc $01		                inc cp+1
.d6cf					_done:
.d6cf	60		rts		                rts
.d6d0					doconst:
.d6d0	ca		dex		                dex             ; make room for constant
.d6d1	ca		dex		                dex
.d6d2	68		pla		                pla             ; LSB of return address
.d6d3	85 24		sta $24		                sta tmp1
.d6d5	68		pla		                pla             ; MSB of return address
.d6d6	85 25		sta $25		                sta tmp1+1
.d6d8	a0 01		ldy #$01	                ldy #1
.d6da	b1 24		lda ($24),y	                lda (tmp1),y
.d6dc	95 00		sta $00,x	                sta 0,x
.d6de	c8		iny		                iny
.d6df	b1 24		lda ($24),y	                lda (tmp1),y
.d6e1	95 01		sta $01,x	                sta 1,x
.d6e3	60		rts		                rts
.d6e4					dodefer:
.d6e4	68		pla		                pla             ; LSB
.d6e5	85 24		sta $24		                sta tmp1
.d6e7	68		pla		                pla             ; MSB
.d6e8	85 25		sta $25		                sta tmp1+1
.d6ea	a0 01		ldy #$01	                ldy #1
.d6ec	b1 24		lda ($24),y	                lda (tmp1),y
.d6ee	85 26		sta $26		                sta tmp2
.d6f0	c8		iny		                iny
.d6f1	b1 24		lda ($24),y	                lda (tmp1),y
.d6f3	85 27		sta $27		                sta tmp2+1
.d6f5	6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d6f8					defer_error:
.d6f8	a9 03		lda #$03	                lda #err_defer
.d6fa	4c 2a d8	jmp $d82a	                jmp error
.d6fd					dodoes:
.d6fd	7a		ply		                ply             ; LSB
.d6fe	68		pla		                pla             ; MSB
.d6ff	c8		iny		                iny
.d700	d0 01		bne $d703	                bne +
.d702	1a		inc a		                ina
.d703					+
.d703	84 26		sty $26		                sty tmp2
.d705	85 27		sta $27		                sta tmp2+1
.d707	ca		dex		                dex
.d708	ca		dex		                dex
.d709	7a		ply		                ply
.d70a	68		pla		                pla
.d70b	c8		iny		                iny
.d70c	d0 01		bne $d70f	                bne +
.d70e	1a		inc a		                ina
.d70f					+
.d70f	94 00		sty $00,x	                sty 0,x         ; LSB
.d711	95 01		sta $01,x	                sta 1,x         ; MSB
.d713	6c 26 00	jmp ($0026)	                jmp (tmp2)
.d716					dovar:
.d716	7a		ply		                ply             ; LSB
.d717	68		pla		                pla             ; MSB
.d718	c8		iny		                iny
.d719	d0 01		bne $d71c	                bne +
.d71b	1a		inc a		                ina
.d71c					+
.d71c	ca		dex		                dex
.d71d	ca		dex		                dex
.d71e	95 01		sta $01,x	                sta 1,x
.d720	98		tya		                tya
.d721	95 00		sta $00,x	                sta 0,x
.d723	60		rts		                rts
.d724					byte_to_ascii:
.d724	48		pha		                pha
.d725	4a		lsr a		                lsr             ; convert high nibble first
.d726	4a		lsr a		                lsr
.d727	4a		lsr a		                lsr
.d728	4a		lsr a		                lsr
.d729	20 2d d7	jsr $d72d	                jsr _nibble_to_ascii
.d72c	68		pla		                pla
.d72d					_nibble_to_ascii:
.d72d	29 0f		and #$0f	                and #$0F
.d72f	09 30		ora #$30	                ora #'0'
.d731	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d733	90 02		bcc $d737	                bcc +
.d735	69 06		adc #$06	                adc #$06
.d737	4c f0 8d	jmp $8df0	+               jmp emit_a
.d73a	60		rts		                rts
.d73b					compare_16bit:
.d73b	b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d73d	d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d73f	f0 0a		beq $d74b	                beq _equal
.d741	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d743	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d745	09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d747	70 08		bvs $d751	                bvs _overflow
.d749	80 08		bra $d753	                bra _not_equal
.d74b					_equal:
.d74b	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d74d	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d74f	50 04		bvc $d755	                bvc _done
.d751					_overflow:
.d751	49 80		eor #$80	                eor #$80                ; complement negative flag
.d753					_not_equal:
.d753	09 01		ora #$01	                ora #1                  ; if overflow, we can't be eqal
.d755					_done:
.d755	60		rts		                rts
.d756					current_to_dp:
.d756	a0 04		ldy #$04	                ldy #current_offset
.d758	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d75a	0a		asl a		                asl             ; turn it into an offset (in cells)
.d75b	18		clc		                clc
.d75c	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d75e	a8		tay		                tay
.d75f	b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d761	85 02		sta $02		                sta dp
.d763	c8		iny		                iny
.d764	b1 1e		lda ($1e),y	                lda (up),y
.d766	85 03		sta $03		                sta dp+1
.d768	60		rts		                rts
.d769					dp_to_current:
.d769	a0 04		ldy #$04	                ldy #current_offset
.d76b	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d76d	0a		asl a		                asl             ; turn it into an offset (in cells)
.d76e	18		clc		                clc
.d76f	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d771	a8		tay		                tay
.d772	a5 02		lda $02		                lda dp
.d774	91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d776	c8		iny		                iny
.d777	a5 03		lda $03		                lda dp+1
.d779	91 1e		sta ($1e),y	                sta (up),y
.d77b	60		rts		                rts
.d77c					interpret:
.d77c					_loop:
.d77c	20 ca 98	jsr $98ca	                jsr xt_parse_name       ; ( "string" -- addr u )
.d77f	b5 00		lda $00,x	                lda 0,x
.d781	15 01		ora $01,x	                ora 1,x
.d783	f0 70		beq $d7f5	                beq _line_done
.d785	20 9d a3	jsr $a39d	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d788	20 d5 8f	jsr $8fd5	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d78b	b5 00		lda $00,x	                lda 0,x
.d78d	15 01		ora $01,x	                ora 1,x
.d78f	d0 28		bne $d7b9	                bne _got_name_token
.d791	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d792	e8		inx		                inx
.d793	20 84 96	jsr $9684	                jsr xt_number           ; ( addr u -- u|d )
.d796	a5 16		lda $16		                lda state
.d798	f0 e2		beq $d77c	                beq _loop
.d79a	a9 20		lda #$20	                lda #$20
.d79c	24 20		bit $20		                bit status
.d79e	f0 0d		beq $d7ad	                beq _single_number
.d7a0	20 93 a1	jsr $a193	                jsr xt_swap
.d7a3	a0 93		ldy #$93	                ldy #>literal_runtime
.d7a5	a9 92		lda #$92	                lda #<literal_runtime
.d7a7	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.d7aa	20 68 87	jsr $8768	                jsr xt_comma
.d7ad					_single_number:
.d7ad	a0 93		ldy #$93	                ldy #>literal_runtime
.d7af	a9 92		lda #$92	                lda #<literal_runtime
.d7b1	20 b7 d6	jsr $d6b7	                jsr cmpl_subroutine
.d7b4	20 68 87	jsr $8768	                jsr xt_comma
.d7b7	80 c3		bra $d77c	                bra _loop
.d7b9					_got_name_token:
.d7b9	b5 00		lda $00,x	                lda 0,x
.d7bb	95 04		sta $04,x	                sta 4,x
.d7bd	b5 01		lda $01,x	                lda 1,x
.d7bf	95 05		sta $05,x	                sta 5,x
.d7c1	e8		inx		                inx
.d7c2	e8		inx		                inx
.d7c3	e8		inx		                inx
.d7c4	e8		inx		                inx                     ; ( nt )
.d7c5	b5 00		lda $00,x	                lda 0,x
.d7c7	85 22		sta $22		                sta tmpbranch
.d7c9	b5 01		lda $01,x	                lda 1,x
.d7cb	85 23		sta $23		                sta tmpbranch+1
.d7cd	20 db 95	jsr $95db	                jsr xt_name_to_int      ; ( nt - xt )
.d7d0	a5 16		lda $16		                lda state
.d7d2	d0 13		bne $d7e7	                bne _compile
.d7d4	a0 01		ldy #$01	                ldy #1
.d7d6	b1 22		lda ($22),y	                lda (tmpbranch),y
.d7d8	29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d7da	f0 05		beq $d7e1	                beq _interpret
.d7dc	a9 02		lda #$02	                lda #err_compileonly
.d7de	4c 2a d8	jmp $d82a	                jmp error
.d7e1					_interpret:
.d7e1	20 37 8f	jsr $8f37	                jsr xt_execute
.d7e4	4c 7c d7	jmp $d77c	                jmp _loop
.d7e7					_compile:
.d7e7	a0 01		ldy #$01	                ldy #1
.d7e9	b1 22		lda ($22),y	                lda (tmpbranch),y
.d7eb	29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d7ed	d0 f2		bne $d7e1	                bne _interpret          ; IMMEDIATE word, execute right now
.d7ef	20 e7 87	jsr $87e7	                jsr xt_compile_comma
.d7f2	4c 7c d7	jmp $d77c	                jmp _loop
.d7f5					_line_done:
.d7f5	e8		inx		                inx
.d7f6	e8		inx		                inx
.d7f7	e8		inx		                inx
.d7f8	e8		inx		                inx
.d7f9	60		rts		                rts
.d7fa					is_printable:
.d7fa	c9 20		cmp #$20	                cmp #AscSP              ; $20
.d7fc	90 08		bcc $d806	                bcc _done
.d7fe	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d800	b0 03		bcs $d805	                bcs _failed
.d802	38		sec		                sec
.d803	80 01		bra $d806	                bra _done
.d805					_failed:
.d805	18		clc		                clc
.d806					_done:
.d806	60		rts		                rts
.d807					is_whitespace:
.d807	c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d809	90 08		bcc $d813	                bcc _done
.d80b	c9 21		cmp #$21	                cmp #AscSP+1
.d80d	b0 03		bcs $d812	                bcs _failed
.d80f	38		sec		                sec
.d810	80 01		bra $d813	                bra _done
.d812					_failed:
.d812	18		clc		                clc
.d813					_done:
.d813	60		rts		                rts
.d814					underflow_1:
.d814	e0 77		cpx #$77	                cpx #dsp0-1
.d816	10 10		bpl $d828	                bpl underflow_error
.d818	60		rts		                rts
.d819					underflow_2:
.d819	e0 75		cpx #$75	                cpx #dsp0-3
.d81b	10 0b		bpl $d828	                bpl underflow_error
.d81d	60		rts		                rts
.d81e					underflow_3:
.d81e	e0 73		cpx #$73	                cpx #dsp0-5
.d820	10 06		bpl $d828	                bpl underflow_error
.d822	60		rts		                rts
.d823					underflow_4:
.d823	e0 71		cpx #$71	                cpx #dsp0-7
.d825	10 01		bpl $d828	                bpl underflow_error
.d827	60		rts		                rts
.d828					underflow_error:
.d828	a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d82a					error:
.d82a	0a		asl a		                asl
.d82b	a8		tay		                tay
.d82c	b9 a6 d4	lda $d4a6,y	                lda error_table,y
.d82f	85 28		sta $28		                sta tmp3                ; LSB
.d831	c8		iny		                iny
.d832	b9 a6 d4	lda $d4a6,y	                lda error_table,y
.d835	85 29		sta $29		                sta tmp3+1              ; MSB
.d837	20 4d d8	jsr $d84d	                jsr print_common
.d83a	20 5d 89	jsr $895d	                jsr xt_cr
.d83d	4c 81 80	jmp $8081	                jmp xt_abort            ; no jsr, as we clobber return stack
.d840					print_string_no_lf:
.d840	0a		asl a		                asl
.d841	a8		tay		                tay
.d842	b9 ab d3	lda $d3ab,y	                lda string_table,y
.d845	85 28		sta $28		                sta tmp3                ; LSB
.d847	c8		iny		                iny
.d848	b9 ab d3	lda $d3ab,y	                lda string_table,y
.d84b	85 29		sta $29		                sta tmp3+1              ; MSB
.d84d					print_common:
.d84d	a0 00		ldy #$00	                ldy #0
.d84f					_loop:
.d84f	b1 28		lda ($28),y	                lda (tmp3),y
.d851	f0 06		beq $d859	                beq _done               ; strings are zero-terminated
.d853	20 f0 8d	jsr $8df0	                jsr emit_a              ; allows vectoring via output
.d856	c8		iny		                iny
.d857	80 f6		bra $d84f	                bra _loop
.d859					_done:
.d859	60		rts		                rts
.d85a					print_string:
.d85a	20 40 d8	jsr $d840	                jsr print_string_no_lf
.d85d	4c 5d 89	jmp $895d	                jmp xt_cr               ; JSR/RTS because never compiled
.d860					print_u:
.d860	20 8d a7	jsr $a78d	                jsr xt_zero                     ; 0
.d863	20 54 93	jsr $9354	                jsr xt_less_number_sign         ; <#
.d866	20 c9 97	jsr $97c9	                jsr xt_number_sign_s            ; #S
.d869	20 a7 97	jsr $97a7	                jsr xt_number_sign_greater      ; #>
.d86c	4c e8 a4	jmp $a4e8	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp forth
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034	74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044	6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054	28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
