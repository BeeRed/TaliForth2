
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Tue Mar 26 20:26:07 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../native_words.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 27		lda #$27	                lda #<kernel_putc
.8003		85 10		sta $10		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 11		sta $11		                sta output+1
.8009		a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd a2 a8	lda $a8a2,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad a2 a8	lda $a8a2	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 31		ldy #$31	                ldy #cold_user_table_end-cold_user_table-1
.801f		a9 00		lda #$00	                lda #0
.8021						_load_user_vars_loop:
.8021		b9 c4 a8	lda $a8c4,y	                lda cold_user_table,y
.8024		91 1e		sta ($1e),y	                sta (up),y
.8026		88		dey		                dey
.8027		d0 f8		bne $8021	                bne _load_user_vars_loop
.8029		ad c4 a8	lda $a8c4	                lda cold_user_table
.802c		92 1e		sta ($1e)	                sta (up)
.802e		20 2a 89	jsr $892a	                jsr xt_cr
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		ca		dex		                dex
.8034		ca		dex		                dex
.8035		a9 83		lda #$83	                lda #<forth_words_start
.8037		95 02		sta $02,x	                sta 2,x
.8039		a9 bb		lda #$bb	                lda #>forth_words_start
.803b		95 03		sta $03,x	                sta 3,x
.803d		a9 d3		lda #$d3	                lda #<(user_words_end-forth_words_start)
.803f		95 00		sta $00,x	                sta 0,x
.8041		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043		95 01		sta $01,x	                sta 1,x
.8045		20 88 90	jsr $9088	                jsr xt_evaluate
.8048		9c 00 7c	stz $7c00	                stz hist_buff
.804b		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e		9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057		9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d		9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060						xt_abort:
.8060		a2 78		ldx #$78	                ldx #dsp0
.8062						xt_quit:
.8062		8a		txa		                txa             ; Save the DSP that we just defined
.8063		a2 ff		ldx #$ff	                ldx #rsp0
.8065		9a		txs		                txs
.8066		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067		64 0e		stz $0e		                stz ip
.8069		64 0f		stz $0f		                stz ip+1
.806b		64 06		stz $06		                stz insrc
.806d		64 07		stz $07		                stz insrc+1
.806f		a9 00		lda #$00	                lda #0
.8071		a0 00		ldy #$00	                ldy #blk_offset
.8073		91 1e		sta ($1e),y	                sta (up),y
.8075		c8		iny		                iny
.8076		91 1e		sta ($1e),y	                sta (up),y
.8078		64 16		stz $16		                stz state
.807a		64 17		stz $17		                stz state+1
.807c						_get_line:
.807c		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.807e		85 08		sta $08		                sta cib
.8080		a9 02		lda #$02	                lda #>buffer0
.8082		85 09		sta $09		                sta cib+1
.8084		64 0a		stz $0a		                stz ciblen
.8086		64 0b		stz $0b		                stz ciblen+1
.8088		20 ac 9a	jsr $9aac	                jsr xt_refill           ; ( -- f )
.808b		b5 00		lda $00,x	                lda 0,x
.808d		d0 05		bne $8094	                bne _success
.808f		a9 06		lda #$06	                lda #err_refill
.8091		4c 58 d8	jmp $d858	                jmp error
.8094						_success:
.8094		e8		inx		                inx                     ; drop
.8095		e8		inx		                inx
.8096		20 aa d7	jsr $d7aa	                jsr interpret
.8099		e0 78		cpx #$78	                cpx #dsp0
.809b		f0 05		beq $80a2	                beq _stack_ok
.809d		90 03		bcc $80a2	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.809f		4c 56 d8	jmp $d856	                jmp underflow_error
.80a2						_stack_ok:
.80a2		a5 16		lda $16		                lda state
.80a4		f0 02		beq $80a8	                beq _print
.80a6		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80a8						_print:
.80a8		20 a9 d8	jsr $d8a9	                jsr print_string
.80ab		80 cf		bra $807c	                bra _get_line
.80ad						z_cold:
.80ad						z_abort:
.80ad						z_quit:
.80ad						xt_abort_quote:
.80ad		20 03 9d	jsr $9d03	                jsr xt_s_quote          ; S"
.80b0		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b2		a9 b8		lda #$b8	                lda #<abort_quote_runtime
.80b4		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b7		60		rts		z_abort_quote:  rts
.80b8						abort_quote_runtime:
.80b8		b5 04		lda $04,x	                lda 4,x
.80ba		15 05		ora $05,x	                ora 5,x
.80bc		f0 09		beq $80c7	                beq _done       ; if FALSE, we're done
.80be		20 88 a4	jsr $a488	                jsr xt_type
.80c1		20 2a 89	jsr $892a	                jsr xt_cr
.80c4		4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.80c7						_done:
.80c7		8a		txa		                txa
.80c8		18		clc		                clc
.80c9		69 06		adc #$06	                adc #6
.80cb		aa		tax		                tax
.80cc		60		rts		                rts
.80cd						xt_abs:
.80cd		20 42 d8	jsr $d842	                jsr underflow_1
.80d0		b5 01		lda $01,x	                lda 1,x
.80d2		10 0d		bpl $80e1	                bpl _done       ; positive number, easy money!
.80d4		38		sec		                sec
.80d5		a9 00		lda #$00	                lda #0
.80d7		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80d9		95 00		sta $00,x	                sta 0,x
.80db		a9 00		lda #$00	                lda #0          ; MSB
.80dd		f5 01		sbc $01,x	                sbc 1,x
.80df		95 01		sta $01,x	                sta 1,x
.80e1						_done:
.80e1		60		rts		z_abs:          rts
.80e2						xt_accept:
.80e2		20 47 d8	jsr $d847	                jsr underflow_2
.80e5		b5 00		lda $00,x	                lda 0,x
.80e7		15 01		ora $01,x	                ora 1,x
.80e9		d0 09		bne $80f4	                bne _not_zero
.80eb		e8		inx		                inx
.80ec		e8		inx		                inx
.80ed		74 00		stz $00,x	                stz 0,x
.80ef		74 01		stz $01,x	                stz 1,x
.80f1		4c c0 81	jmp $81c0	                jmp accept_done
.80f4						_not_zero:
.80f4		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f6		85 26		sta $26		                sta tmp2
.80f8		64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fa		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fc		85 24		sta $24		                sta tmp1
.80fe		b5 03		lda $03,x	                lda 3,x
.8100		85 25		sta $25		                sta tmp1+1
.8102		e8		inx		                inx
.8103		e8		inx		                inx
.8104		a0 00		ldy #$00	                ldy #0
.8106		a5 20		lda $20		                lda status
.8108		29 f7		and #$f7	                and #$f7
.810a		1a		inc a		               ina
.810b		09 08		ora #$08	                ora #$08
.810d		85 20		sta $20		                sta status
.810f						accept_loop:
.810f		20 e9 92	jsr $92e9	                jsr key_a
.8112		c9 0a		cmp #$0a	                cmp #AscLF
.8114		f0 20		beq $8136	                beq _eol
.8116		c9 0d		cmp #$0d	                cmp #AscCR
.8118		f0 1c		beq $8136	                beq _eol
.811a		c9 08		cmp #$08	                cmp #AscBS
.811c		f0 22		beq $8140	                beq _backspace
.811e		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8120		f0 1e		beq $8140	                beq _backspace
.8122		c9 10		cmp #$10	                cmp #AscCP
.8124		f0 36		beq $815c	                beq _ctrl_p
.8126		c9 0e		cmp #$0e	                cmp #AscCN
.8128		f0 44		beq $816e	                beq _ctrl_n
.812a		91 24		sta ($24),y	                sta (tmp1),y
.812c		c8		iny		                iny
.812d		20 a9 8d	jsr $8da9	                jsr emit_a
.8130		c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.8132		d0 db		bne $810f	                bne accept_loop       ; fall through if buffer limit reached
.8134		80 03		bra $8139	                bra _buffer_full
.8136						_eol:
.8136		20 a3 a0	jsr $a0a3	                jsr xt_space    ; print final space
.8139						_buffer_full:
.8139		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813b		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813d		4c c0 81	jmp $81c0	                jmp accept_done
.8140						_backspace:
.8140		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8142		d0 06		bne $814a	                bne +
.8144		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8146		20 a9 8d	jsr $8da9	                jsr emit_a
.8149		c8		iny		                iny
.814a						+
.814a		88		dey		                dey
.814b		a9 08		lda #$08	                lda #AscBS      ; move back one
.814d		20 a9 8d	jsr $8da9	                jsr emit_a
.8150		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8152		20 a9 8d	jsr $8da9	                jsr emit_a
.8155		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8157		20 a9 8d	jsr $8da9	                jsr emit_a
.815a		80 b3		bra $810f	                bra accept_loop
.815c						_ctrl_p:
.815c		a5 20		lda $20		                lda status
.815e		29 07		and #$07	                and #7
.8160		d0 08		bne $816a	                bne _ctrl_p_dec
.8162		a5 20		lda $20		                lda status
.8164		09 07		ora #$07	                ora #7
.8166		85 20		sta $20		                sta status
.8168		80 11		bra $817b	                bra _recall_history
.816a						_ctrl_p_dec:
.816a		c6 20		dec $20		                dec status
.816c		80 0d		bra $817b	                bra _recall_history
.816e						_ctrl_n:
.816e		a9 08		lda #$08	                lda #$8
.8170		24 20		bit $20		                bit status
.8172		d0 07		bne $817b	                bne _recall_history
.8174		a5 20		lda $20		                lda status
.8176		29 f7		and #$f7	                and #$f7
.8178		1a		inc a		               ina
.8179		85 20		sta $20		                sta status
.817b						_recall_history:
.817b		a9 08		lda #$08	                lda #%00001000
.817d		14 20		trb $20		                trb status
.817f		20 db 81	jsr $81db	                jsr accept_total_recall
.8182		a9 0d		lda #$0d	                lda #AscCR
.8184		20 a9 8d	jsr $8da9	                jsr emit_a
.8187						input_clear:
.8187		c0 00		cpy #$00	                cpy #0
.8189		f0 08		beq $8193	                beq input_cleared
.818b		a9 20		lda #$20	                lda #AscSP
.818d		20 a9 8d	jsr $8da9	                jsr emit_a
.8190		88		dey		                dey
.8191		80 f4		bra $8187	                bra input_clear
.8193						input_cleared:
.8193		a9 0d		lda #$0d	                lda #AscCR
.8195		20 a9 8d	jsr $8da9	                jsr emit_a
.8198		b1 28		lda ($28),y	                lda (tmp3),y
.819a		85 21		sta $21		                sta status+1
.819c		e6 28		inc $28		                inc tmp3
.819e		d0 02		bne $81a2	                bne +           ; Increment the upper byte on carry.
.81a0		e6 29		inc $29		                inc tmp3+1
.81a2						+
.81a2		a9 0d		lda #$0d	                lda #AscCR
.81a4		20 a9 8d	jsr $8da9	                jsr emit_a
.81a7						_history_loop:
.81a7		c4 21		cpy $21		                cpy status+1
.81a9		d0 03		bne $81ae	                bne +
.81ab		4c 0f 81	jmp $810f	                jmp accept_loop       ; Needs a long jump
.81ae						+
.81ae		c4 26		cpy $26		                cpy tmp2
.81b0		f0 0a		beq $81bc	                beq _hist_filled_buffer
.81b2		b1 28		lda ($28),y	                lda (tmp3),y
.81b4		91 24		sta ($24),y	                sta (tmp1),y
.81b6		20 a9 8d	jsr $8da9	                jsr emit_a
.81b9		c8		iny		                iny
.81ba		80 eb		bra $81a7	                bra _history_loop
.81bc						_hist_filled_buffer:
.81bc		88		dey		                dey
.81bd		4c 0f 81	jmp $810f	                jmp accept_loop
.81c0						accept_done:
.81c0		20 db 81	jsr $81db	                jsr accept_total_recall
.81c3		85 21		sta $21		                sta status+1
.81c5		a0 00		ldy #$00	                ldy #0
.81c7		91 28		sta ($28),y	                sta (tmp3),y
.81c9		e6 28		inc $28		                inc tmp3
.81cb		d0 02		bne $81cf	                bne +           ; Increment the upper byte on carry.
.81cd		e6 29		inc $29		                inc tmp3+1
.81cf						+
.81cf						_save_history_loop:
.81cf		c4 21		cpy $21		                cpy status+1
.81d1		f0 07		beq $81da	                beq _save_history_done
.81d3		b1 24		lda ($24),y	                lda (tmp1),y
.81d5		91 28		sta ($28),y	                sta (tmp3),y
.81d7		c8		iny		                iny
.81d8		80 f5		bra $81cf	                bra _save_history_loop
.81da						_save_history_done:
.81da						z_accept:
.81da		60		rts		                rts
.81db						accept_total_recall:
.81db		a9 00		lda #$00	                lda #<hist_buff
.81dd		85 28		sta $28		                sta tmp3
.81df		a9 7c		lda #$7c	                lda #>hist_buff
.81e1		85 29		sta $29		                sta tmp3+1
.81e3		a5 20		lda $20		                lda status
.81e5		6a		ror a		                ror
.81e6		29 03		and #$03	                and #3
.81e8		18		clc		                clc
.81e9		65 29		adc $29		                adc tmp3+1
.81eb		85 29		sta $29		                sta tmp3+1
.81ed		a5 20		lda $20		                lda status
.81ef		6a		ror a		                ror             ; Rotate through carry into msb.
.81f0		6a		ror a		                ror
.81f1		29 80		and #$80	                and #$80
.81f3		18		clc		                clc
.81f4		65 28		adc $28		                adc tmp3
.81f6		85 28		sta $28		                sta tmp3
.81f8		90 02		bcc $81fc	                bcc +           ; Increment the upper byte on carry.
.81fa		e6 29		inc $29		                inc tmp3+1
.81fc						+
.81fc		98		tya		                tya
.81fd		c9 80		cmp #$80	                cmp #$80
.81ff		90 02		bcc $8203	                bcc +
.8201		a9 7f		lda #$7f	                lda #$7F
.8203						+
.8203		60		rts		                rts
.8204						xt_action_of:
.8204		a5 16		lda $16		                lda state
.8206		05 17		ora $17		                ora state+1
.8208		f0 0c		beq $8216	                beq _interpreting
.820a						_compiling:
.820a		20 54 85	jsr $8554	                jsr xt_bracket_tick
.820d		a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.820f		a9 a6		lda #$a6	                lda #<xt_defer_fetch
.8211		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.8214		80 06		bra $821c	                bra _done
.8216						_interpreting:
.8216		20 96 a1	jsr $a196	                jsr xt_tick
.8219		20 a6 8a	jsr $8aa6	                jsr xt_defer_fetch
.821c						_done:
.821c		60		rts		z_action_of:           rts
.821d						xt_again:
.821d		20 42 d8	jsr $d842	                jsr underflow_1
.8220		a0 00		ldy #$00	                ldy #0
.8222		a9 4c		lda #$4c	                lda #$4C        ; JMP
.8224		91 00		sta ($00),y	                sta (cp),y
.8226		c8		iny		                iny
.8227		b5 00		lda $00,x	                lda 0,x         ; LSB of address
.8229		91 00		sta ($00),y	                sta (cp),y
.822b		c8		iny		                iny
.822c		b5 01		lda $01,x	                lda 1,x         ; MSB of address
.822e		91 00		sta ($00),y	                sta (cp),y
.8230		c8		iny		                iny
.8231		98		tya		                tya
.8232		18		clc		                clc
.8233		65 00		adc $00		                adc cp
.8235		85 00		sta $00		                sta cp
.8237		90 02		bcc $823b	                bcc _done
.8239		e6 01		inc $01		                inc cp+1
.823b						_done:
.823b		e8		inx		                inx
.823c		e8		inx		                inx
.823d		60		rts		z_again:        rts
.823e						xt_align:
.823e						xt_aligned:
.823e						z_align:
.823e		60		rts		z_aligned:      rts             ; stripped out during native compile
.823f						xt_allot:
.823f		20 42 d8	jsr $d842	                jsr underflow_1
.8242		b5 01		lda $01,x	                lda 1,x
.8244		30 22		bmi $8268	                bmi _release
.8246		18		clc		                clc
.8247		a5 00		lda $00		                lda cp
.8249		75 00		adc $00,x	                adc 0,x
.824b		85 00		sta $00		                sta cp
.824d		a5 01		lda $01		                lda cp+1
.824f		75 01		adc $01,x	                adc 1,x
.8251		85 01		sta $01		                sta cp+1
.8253		a0 00		ldy #$00	                ldy #<cp_end
.8255		c4 00		cpy $00		                cpy cp
.8257		a9 7c		lda #$7c	                lda #>cp_end
.8259		e5 01		sbc $01		                sbc cp+1
.825b		b0 48		bcs $82a5	                bcs _done               ; we're fine.
.825d		84 00		sty $00		                sty cp                  ; still #<cp_end
.825f		a9 7c		lda #$7c	                lda #>cp_end
.8261		85 01		sta $01		                sta cp+1
.8263		a9 00		lda #$00	                lda #err_allot
.8265		4c 58 d8	jmp $d858	                jmp error
.8268						_release:
.8268		ca		dex		                dex
.8269		ca		dex		                dex
.826a		a5 00		lda $00		                lda cp
.826c		95 00		sta $00,x	                sta 0,x
.826e		a5 01		lda $01		                lda cp+1
.8270		95 01		sta $01,x	                sta 1,x
.8272		20 97 99	jsr $9997	                jsr xt_plus                     ; new CP is now TOS
.8275		ca		dex		                dex
.8276		ca		dex		                dex                             ; new CP now NOS
.8277		a9 00		lda #$00	                lda #<cp0
.8279		95 00		sta $00,x	                sta 0,x
.827b		a9 03		lda #$03	                lda #>cp0
.827d		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.827f		20 69 d7	jsr $d769	                jsr compare_16bit               ; still ( CP CP0 )
.8282		f0 17		beq $829b	                beq _nega_done
.8284		30 15		bmi $829b	                bmi _nega_done
.8286		a9 00		lda #$00	                lda #<cp0
.8288		85 00		sta $00		                sta cp
.828a		a9 03		lda #$03	                lda #>cp0
.828c		85 01		sta $01		                sta cp+1
.828e		a9 56		lda #$56	                lda #<dictionary_start
.8290		85 02		sta $02		                sta dp
.8292		a9 bc		lda #$bc	                lda #>dictionary_start
.8294		85 03		sta $03		                sta dp+1
.8296		a9 0a		lda #$0a	                lda #err_negallot
.8298		4c 58 d8	jmp $d858	                jmp error
.829b						_nega_done:
.829b		b5 02		lda $02,x	                lda 2,x
.829d		85 00		sta $00		                sta cp
.829f		b5 03		lda $03,x	                lda 3,x
.82a1		85 01		sta $01		                sta cp+1
.82a3		e8		inx		                inx
.82a4		e8		inx		                inx                     ; drop through to _done
.82a5						_done:
.82a5		e8		inx		                inx
.82a6		e8		inx		                inx
.82a7						z_allot:
.82a7		60		rts		                rts
.82a8						xt_allow_native:
.82a8		20 84 d7	jsr $d784	                jsr current_to_dp
.82ab		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82ad		b1 02		lda ($02),y	                lda (dp),y
.82af		29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.82b1		91 02		sta ($02),y	                sta (dp),y
.82b3						z_allow_native:
.82b3		60		rts		                rts
.82b4						xt_also:
.82b4		20 e7 90	jsr $90e7	                jsr xt_get_order
.82b7		20 47 98	jsr $9847	                jsr xt_over
.82ba		20 33 a1	jsr $a133	                jsr xt_swap
.82bd		20 d1 97	jsr $97d1	                jsr xt_one_plus
.82c0		20 cf 9c	jsr $9ccf	                jsr xt_set_order
.82c3		60		rts		z_also:         rts
.82c4						xt_always_native:
.82c4		20 84 d7	jsr $d784	                jsr current_to_dp
.82c7		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82c9		b1 02		lda ($02),y	                lda (dp),y
.82cb		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.82cd		29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.82cf		91 02		sta ($02),y	                sta (dp),y
.82d1						z_always_native:
.82d1		60		rts		                rts
.82d2						xt_and:
.82d2		20 47 d8	jsr $d847	                jsr underflow_2
.82d5		b5 00		lda $00,x	                lda 0,x
.82d7		35 02		and $02,x	                and 2,x
.82d9		95 02		sta $02,x	                sta 2,x
.82db		b5 01		lda $01,x	                lda 1,x
.82dd		35 03		and $03,x	                and 3,x
.82df		95 03		sta $03,x	                sta 3,x
.82e1		e8		inx		                inx
.82e2		e8		inx		                inx
.82e3		60		rts		z_and:          rts
.82e4						xt_at_xy:
.82e4		20 47 d8	jsr $d847	                jsr underflow_2
.82e7		a5 18		lda $18		                lda base
.82e9		48		pha		                pha
.82ea		a9 0a		lda #$0a	                lda #10
.82ec		85 18		sta $18		                sta base
.82ee		a9 1b		lda #$1b	                lda #AscESC
.82f0		20 a9 8d	jsr $8da9	                jsr emit_a
.82f3		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.82f5		20 a9 8d	jsr $8da9	                jsr emit_a
.82f8		20 d1 97	jsr $97d1	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82fb		20 af d8	jsr $d8af	                jsr print_u
.82fe		a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8300		20 a9 8d	jsr $8da9	                jsr emit_a
.8303		20 d1 97	jsr $97d1	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8306		20 af d8	jsr $d8af	                jsr print_u
.8309		a9 48		lda #$48	                lda #'H'
.830b		20 a9 8d	jsr $8da9	                jsr emit_a
.830e		68		pla		                pla
.830f		85 18		sta $18		                sta base
.8311		60		rts		z_at_xy:        rts
.8312						xt_backslash:
.8312		a0 00		ldy #$00	                ldy #blk_offset
.8314		b1 1e		lda ($1e),y	                lda (up),y
.8316		c8		iny		                iny
.8317		11 1e		ora ($1e),y	                ora (up),y
.8319		f0 19		beq $8334	                beq backslash_not_block
.831b		a5 0c		lda $0c		                lda toin
.831d		29 3f		and #$3f	                and #$3F
.831f		f0 1b		beq $833c	                beq z_backslash
.8321		c9 01		cmp #$01	                cmp #$01
.8323		f0 17		beq $833c	                beq z_backslash
.8325		a5 0c		lda $0c		                lda toin
.8327		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.8329		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.832a		69 40		adc #$40	                adc #$40
.832c		85 0c		sta $0c		                sta toin
.832e		90 0c		bcc $833c	                bcc z_backslash
.8330		e6 0d		inc $0d		                inc toin+1
.8332		80 08		bra $833c	                bra z_backslash
.8334						backslash_not_block:
.8334		a5 0a		lda $0a		                lda ciblen
.8336		85 0c		sta $0c		                sta toin
.8338		a5 0b		lda $0b		                lda ciblen+1
.833a		85 0d		sta $0d		                sta toin+1
.833c		60		rts		z_backslash:    rts
.833d						xt_base:
.833d		ca		dex		                dex
.833e		ca		dex		                dex
.833f		a9 18		lda #$18	                lda #<base
.8341		95 00		sta $00,x	                sta 0,x         ; LSB
.8343		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8345		60		rts		z_base:         rts
.8346						xt_begin:
.8346		20 25 91	jsr $9125	                jsr xt_here
.8349		60		rts		z_begin:        rts
.834a						xt_bell:
.834a		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.834c		20 a9 8d	jsr $8da9	                jsr emit_a
.834f		60		rts		z_bell:         rts
.8350						xt_bl:
.8350		ca		dex		                dex
.8351		ca		dex		                dex
.8352		a9 20		lda #$20	                lda #AscSP
.8354		95 00		sta $00,x	                sta 0,x
.8356		74 01		stz $01,x	                stz 1,x
.8358		60		rts		z_bl:           rts
.8359						xt_blk:
.8359		ca		dex		                dex
.835a		ca		dex		                dex
.835b		18		clc		                clc
.835c		a5 1e		lda $1e		                lda up
.835e		69 00		adc #$00	                adc #blk_offset ; Add offset
.8360		95 00		sta $00,x	                sta 0,x
.8362		a5 1f		lda $1f		                lda up+1
.8364		69 00		adc #$00	                adc #0          ; Adding carry
.8366		95 01		sta $01,x	                sta 1,x
.8368		60		rts		z_blk:          rts
.8369						xt_blkbuffer:
.8369		ca		dex		                dex
.836a		ca		dex		                dex
.836b		a0 28		ldy #$28	                ldy #blkbuffer_offset
.836d		b1 1e		lda ($1e),y	                lda (up),y
.836f		95 00		sta $00,x	                sta 0,x
.8371		c8		iny		                iny             ; Move along to the next byte
.8372		b1 1e		lda ($1e),y	                lda (up),y
.8374		95 01		sta $01,x	                sta 1,x
.8376		60		rts		z_blkbuffer:    rts
.8377						xt_block:
.8377		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.8379		b1 1e		lda ($1e),y	                lda (up),y
.837b		d5 00		cmp $00,x	                cmp 0,x
.837d		d0 0f		bne $838e	                bne _not_in_buffer
.837f		c8		iny		                iny
.8380		b1 1e		lda ($1e),y	                lda (up),y
.8382		d5 01		cmp $01,x	                cmp 1,x
.8384		d0 08		bne $838e	                bne _not_in_buffer
.8386		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8388		b1 1e		lda ($1e),y	                lda (up),y
.838a		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.838c		d0 30		bne $83be	                bne _done       ; It's already in the buffer and in use.
.838e						_not_in_buffer:
.838e		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8390		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.8392		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8394		d0 0c		bne $83a2	                bne _buffer_available ; Unused or not dirty = available
.8396		20 69 83	jsr $8369	                jsr xt_blkbuffer
.8399		20 5b 85	jsr $855b	                jsr xt_buffblocknum
.839c		20 33 8f	jsr $8f33	                jsr xt_fetch
.839f		20 16 85	jsr $8516	                jsr xt_block_write
.83a2						_buffer_available:
.83a2		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83a4		b5 00		lda $00,x	                lda 0,x
.83a6		91 1e		sta ($1e),y	                sta (up),y
.83a8		c8		iny		                iny
.83a9		b5 01		lda $01,x	                lda 1,x
.83ab		91 1e		sta ($1e),y	                sta (up),y
.83ad		20 69 83	jsr $8369	                jsr xt_blkbuffer
.83b0		20 33 a1	jsr $a133	                jsr xt_swap
.83b3		20 f3 84	jsr $84f3	                jsr xt_block_read
.83b6		a9 01		lda #$01	                lda #1
.83b8		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83ba		91 1e		sta ($1e),y	                sta (up),y
.83bc		ca		dex		                dex
.83bd		ca		dex		                dex
.83be						_done:
.83be		a0 28		ldy #$28	                ldy #blkbuffer_offset
.83c0		b1 1e		lda ($1e),y	                lda (up),y
.83c2		95 00		sta $00,x	                sta 0,x
.83c4		c8		iny		                iny
.83c5		b1 1e		lda ($1e),y	                lda (up),y
.83c7		95 01		sta $01,x	                sta 1,x
.83c9		60		rts		z_block:        rts
.83ca						xt_block_ramdrive_init:
.83ca		20 42 d8	jsr $d842	                jsr underflow_1
.83cd		4c e8 84	jmp $84e8	                jmp _after_ramdrive_code
.83d0						_ramdrive_code:
>83d0		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>83d8		77 61 70 20 64 65 63 69 6d 61 6c
>83e3		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>83ea		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>83ee		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>83f6		20 72 61 6d 64 72 69 76 65
>83ff		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>8407		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>8415		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>841d		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>842d		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>843d		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>8445		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>8454		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>845c		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>846c		31 30 32 34 20 6d 6f 76 65 20 3b
>8477		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>847f		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>848f		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>849f		20 21
>84a1		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84a9		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>84b9		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>84c9		6f 72 20 21
>84cd		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>84d5		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>84e5		65 20 21
.84e8						_after_ramdrive_code:
.84e8		20 2e a0	jsr $a02e	                jsr sliteral_runtime
>84eb		d0 83 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.84ef		20 88 90	jsr $9088	                jsr xt_evaluate
.84f2						z_block_ramdrive_init:
.84f2		60		rts		                rts
.84f3						xt_block_read:
.84f3		a0 2e		ldy #$2e	                ldy #blockread_offset
.84f5		b1 1e		lda ($1e),y	                lda (up),y
.84f7		85 24		sta $24		                sta tmp1
.84f9		c8		iny		                iny
.84fa		b1 1e		lda ($1e),y	                lda (up),y
.84fc		85 25		sta $25		                sta tmp1+1
.84fe		6c 24 00	jmp ($0024)	                jmp (tmp1)
.8501						z_block_read:
.8501						xt_block_read_vector:
.8501		ca		dex		                dex
.8502		ca		dex		                dex
.8503		18		clc		                clc
.8504		a5 1e		lda $1e		                lda up
.8506		69 2e		adc #$2e	                adc #blockread_offset
.8508		95 00		sta $00,x	                sta 0,x
.850a		a5 1f		lda $1f		                lda up+1
.850c		69 00		adc #$00	                adc #0          ; Add carry
.850e		95 01		sta $01,x	                sta 1,x
.8510						z_block_read_vector:
.8510		60		rts		                rts
.8511						xt_block_word_error:
.8511		a9 0c		lda #$0c	                lda #err_blockwords
.8513		4c 58 d8	jmp $d858	                jmp error       ; no RTS needed
.8516						z_block_word_error:
.8516						xt_block_write:
.8516		a0 30		ldy #$30	                ldy #blockwrite_offset
.8518		b1 1e		lda ($1e),y	                lda (up),y
.851a		85 24		sta $24		                sta tmp1
.851c		c8		iny		                iny
.851d		b1 1e		lda ($1e),y	                lda (up),y
.851f		85 25		sta $25		                sta tmp1+1
.8521		6c 24 00	jmp ($0024)	                jmp (tmp1)
.8524						z_block_write:
.8524						xt_block_write_vector:
.8524		ca		dex		                dex
.8525		ca		dex		                dex
.8526		18		clc		                clc
.8527		a5 1e		lda $1e		                lda up
.8529		69 30		adc #$30	                adc #blockwrite_offset
.852b		95 00		sta $00,x	                sta 0,x
.852d		a5 1f		lda $1f		                lda up+1
.852f		69 00		adc #$00	                adc #0          ; Add carry
.8531		95 01		sta $01,x	                sta 1,x
.8533						z_block_write_vector:
.8533		60		rts		                rts
.8534						xt_bounds:
.8534		20 47 d8	jsr $d847	                jsr underflow_2
.8537		18		clc		                clc
.8538		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.853a		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.853c		75 02		adc $02,x	                adc 2,x
.853e		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.8540		94 00		sty $00,x	                sty 0,x
.8542		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.8544		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8546		75 03		adc $03,x	                adc 3,x
.8548		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.854a		94 01		sty $01,x	                sty 1,x
.854c		60		rts		z_bounds:       rts
.854d						xt_bracket_char:
.854d		20 e7 85	jsr $85e7	                jsr xt_char
.8550		20 3b 93	jsr $933b	                jsr xt_literal
.8553		60		rts		z_bracket_char: rts
.8554						xt_bracket_tick:
.8554		20 96 a1	jsr $a196	                jsr xt_tick
.8557		20 3b 93	jsr $933b	                jsr xt_literal
.855a		60		rts		z_bracket_tick: rts
.855b						xt_buffblocknum:
.855b		ca		dex		                dex
.855c		ca		dex		                dex
.855d		18		clc		                clc
.855e		a5 1e		lda $1e		                lda up
.8560		69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.8562		95 00		sta $00,x	                sta 0,x
.8564		a5 1f		lda $1f		                lda up+1
.8566		69 00		adc #$00	                adc #0                          ; Adding carry
.8568		95 01		sta $01,x	                sta 1,x
.856a		60		rts		z_buffblocknum: rts
.856b						xt_buffer:
.856b		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.856d		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.856f		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8571		d0 0c		bne $857f	                bne _buffer_available ; Unused or not dirty = available
.8573		20 69 83	jsr $8369	                jsr xt_blkbuffer
.8576		20 5b 85	jsr $855b	                jsr xt_buffblocknum
.8579		20 33 8f	jsr $8f33	                jsr xt_fetch
.857c		20 16 85	jsr $8516	                jsr xt_block_write
.857f						_buffer_available:
.857f		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.8581		b5 00		lda $00,x	                lda 0,x
.8583		91 1e		sta ($1e),y	                sta (up),y
.8585		c8		iny		                iny
.8586		b5 01		lda $01,x	                lda 1,x
.8588		91 1e		sta ($1e),y	                sta (up),y
.858a		a9 01		lda #$01	                lda #1
.858c		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.858e		91 1e		sta ($1e),y	                sta (up),y
.8590						_done:
.8590		a0 28		ldy #$28	                ldy #blkbuffer_offset
.8592		b1 1e		lda ($1e),y	                lda (up),y
.8594		95 00		sta $00,x	                sta 0,x
.8596		c8		iny		                iny
.8597		b1 1e		lda ($1e),y	                lda (up),y
.8599		95 01		sta $01,x	                sta 1,x
.859b		60		rts		z_buffer:       rts
.859c						xt_buffer_colon:
.859c		20 30 89	jsr $8930	                jsr xt_create
.859f		20 3f 82	jsr $823f	                jsr xt_allot
.85a2		60		rts		z_buffer_colon: rts
.85a3						xt_buffstatus:
.85a3		ca		dex		                dex
.85a4		ca		dex		                dex
.85a5		18		clc		                clc
.85a6		a5 1e		lda $1e		                lda up
.85a8		69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.85aa		95 00		sta $00,x	                sta 0,x
.85ac		a5 1f		lda $1f		                lda up+1
.85ae		69 00		adc #$00	                adc #0                  ; Adding carry
.85b0		95 01		sta $01,x	                sta 1,x
.85b2		60		rts		z_buffstatus:   rts
.85b3						xt_bye:
.85b3		4c 2b f0	jmp $f02b	                jmp platform_bye
.85b6						z_bye:
.85b6						xt_c_comma:
.85b6		20 42 d8	jsr $d842	                jsr underflow_1
.85b9		b5 00		lda $00,x	                lda 0,x
.85bb		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.85be		e8		inx		                inx
.85bf		e8		inx		                inx
.85c0		60		rts		z_c_comma:      rts
.85c1						xt_c_fetch:
.85c1		20 42 d8	jsr $d842	                jsr underflow_1
.85c4		a1 00		lda ($00,x)	                lda (0,x)
.85c6		95 00		sta $00,x	                sta 0,x
.85c8		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.85ca		60		rts		z_c_fetch:      rts
.85cb						xt_c_store:
.85cb		20 47 d8	jsr $d847	                jsr underflow_2
.85ce		b5 02		lda $02,x	                lda 2,x
.85d0		81 00		sta ($00,x)	                sta (0,x)
.85d2		e8		inx		                inx
.85d3		e8		inx		                inx
.85d4		e8		inx		                inx
.85d5		e8		inx		                inx
.85d6		60		rts		z_c_store:      rts
.85d7						xt_cell_plus:
.85d7		20 42 d8	jsr $d842	                jsr underflow_1
.85da		f6 00		inc $00,x	                inc 0,x
.85dc		d0 02		bne $85e0	                bne +
.85de		f6 01		inc $01,x	                inc 1,x
.85e0						+
.85e0		f6 00		inc $00,x	                inc 0,x
.85e2		d0 02		bne $85e6	                bne _done
.85e4		f6 01		inc $01,x	                inc 1,x
.85e6						_done:
.85e6		60		rts		z_cell_plus:    rts
.85e7						xt_char:
.85e7		20 93 98	jsr $9893	                jsr xt_parse_name
.85ea		b5 00		lda $00,x	                lda 0,x
.85ec		15 01		ora $01,x	                ora 1,x
.85ee		d0 05		bne $85f5	                bne _not_empty
.85f0		a9 05		lda #$05	                lda #err_noname
.85f2		4c 58 d8	jmp $d858	                jmp error
.85f5						_not_empty:
.85f5		e8		inx		                inx             ; drop number of characters, leave addr
.85f6		e8		inx		                inx
.85f7		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.85f9		95 00		sta $00,x	                sta 0,x
.85fb		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.85fd		60		rts		z_char:         rts
.85fe						xt_chars:
.85fe		20 42 d8	jsr $d842	                jsr underflow_1
.8601		60		rts		z_chars:        rts
.8602						xt_cleave:
.8602		20 47 d8	jsr $d847	                jsr underflow_2
.8605		20 17 95	jsr $9517	                jsr xt_minus_leading    ; -LEADING ( addr u )
.8608		20 13 92	jsr $9213	                jsr xt_input_to_r       ; save old imput state
.860b		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.860d		85 0a		sta $0a		                sta ciblen
.860f		b5 01		lda $01,x	                lda 1,x
.8611		85 0b		sta $0b		                sta ciblen+1
.8613		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.8615		85 08		sta $08		                sta cib
.8617		b5 03		lda $03,x	                lda 3,x
.8619		85 09		sta $09		                sta cib+1
.861b		64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.861d		64 0d		stz $0d		                stz toin+1
.861f		20 93 98	jsr $9893	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.8622		b5 00		lda $00,x	                lda 0,x
.8624		15 01		ora $01,x	                ora 1,x
.8626		f0 23		beq $864b	                beq _done
.8628		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.862a		38		sec		                sec
.862b		f5 00		sbc $00,x	                sbc 0,x
.862d		95 04		sta $04,x	                sta 4,x
.862f		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.8631		f5 01		sbc $01,x	                sbc 1,x
.8633		95 05		sta $05,x	                sta 5,x
.8635		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.8637		18		clc		                clc
.8638		75 00		adc $00,x	                adc 0,x
.863a		95 06		sta $06,x	                sta 6,x
.863c		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.863e		75 01		adc $01,x	                adc 1,x
.8640		95 07		sta $07,x	                sta 7,x
.8642		20 03 a4	jsr $a403	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.8645		20 17 95	jsr $9517	                jsr xt_minus_leading
.8648		20 03 a4	jsr $a403	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.864b						_done:
.864b		20 57 9a	jsr $9a57	                jsr xt_r_to_input
.864e		60		rts		z_cleave:       rts
.864f						xt_cmove:
.864f		20 4c d8	jsr $d84c	                jsr underflow_3
.8652		b5 02		lda $02,x	                lda 2,x
.8654		85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.8656		b5 03		lda $03,x	                lda 3,x
.8658		85 27		sta $27		                sta tmp2+1
.865a		b5 04		lda $04,x	                lda 4,x
.865c		85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.865e		b5 05		lda $05,x	                lda 5,x
.8660		85 25		sta $25		                sta tmp1+1
.8662		a0 00		ldy #$00	                ldy #0
.8664		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.8666		f0 0f		beq $8677	                beq _dopartial
.8668						_page:
.8668		b1 24		lda ($24),y	                lda (tmp1),y
.866a		91 26		sta ($26),y	                sta (tmp2),y
.866c		c8		iny		                iny
.866d		d0 f9		bne $8668	                bne _page
.866f		e6 25		inc $25		                inc tmp1+1
.8671		e6 27		inc $27		                inc tmp2+1
.8673		d6 01		dec $01,x	                dec 1,x
.8675		d0 f1		bne $8668	                bne _page
.8677						_dopartial:
.8677		b5 00		lda $00,x	                lda 0,x         ; length of last page
.8679		f0 09		beq $8684	                beq _done
.867b						_partial:
.867b		b1 24		lda ($24),y	                lda (tmp1),y
.867d		91 26		sta ($26),y	                sta (tmp2),y
.867f		c8		iny		                iny
.8680		d6 00		dec $00,x	                dec 0,x
.8682		d0 f7		bne $867b	                bne _partial
.8684						_done:
.8684		8a		txa		                txa
.8685		18		clc		                clc
.8686		69 06		adc #$06	                adc #6
.8688		aa		tax		                tax
.8689		60		rts		z_cmove:        rts
.868a						xt_cmove_up:
.868a		20 4c d8	jsr $d84c	                jsr underflow_3
.868d		b5 02		lda $02,x	                lda 2,x
.868f		85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.8691		b5 03		lda $03,x	                lda 3,x
.8693		18		clc		                clc
.8694		75 01		adc $01,x	                adc 1,x
.8696		85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.8698		b5 04		lda $04,x	                lda 4,x
.869a		85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.869c		b5 05		lda $05,x	                lda 5,x
.869e		18		clc		                clc
.869f		75 01		adc $01,x	                adc 1,x
.86a1		85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86a3		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86a5		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86a7		f0 0e		beq $86b7	                beq _nopartial
.86a9						_outerloop:
.86a9		88		dey		                dey
.86aa		f0 07		beq $86b3	                beq _finishpage
.86ac						_innerloop:
.86ac		b1 24		lda ($24),y	                lda (tmp1),y
.86ae		91 26		sta ($26),y	                sta (tmp2),y
.86b0		88		dey		                dey
.86b1		d0 f9		bne $86ac	                bne _innerloop
.86b3						_finishpage:
.86b3		b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.86b5		92 26		sta ($26)	                sta (tmp2)
.86b7						_nopartial:
.86b7		c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.86b9		c6 27		dec $27		                dec tmp2+1
.86bb		d6 01		dec $01,x	                dec 1,x
.86bd		d0 ea		bne $86a9	                bne _outerloop
.86bf						_done:
.86bf		8a		txa		                txa
.86c0		18		clc		                clc
.86c1		69 06		adc #$06	                adc #6
.86c3		aa		tax		                tax
.86c4		60		rts		z_cmove_up:     rts
.86c5						xt_colon:
.86c5		a5 16		lda $16		                lda state
.86c7		05 17		ora $17		                ora state+1
.86c9		f0 05		beq $86d0	                beq +
.86cb		a9 07		lda #$07	                lda #err_state
.86cd		4c 58 d8	jmp $d858	                jmp error
.86d0						+
.86d0		c6 16		dec $16		                dec state
.86d2		c6 17		dec $17		                dec state+1
.86d4		a9 40		lda #$40	                lda #%01000000
.86d6		04 20		tsb $20		                tsb status
.86d8		20 84 d7	jsr $d784	                jsr current_to_dp
.86db		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.86dd		48		pha		                pha
.86de		a5 02		lda $02		                lda dp
.86e0		48		pha		                pha
.86e1		a9 80		lda #$80	                lda #%10000000
.86e3		04 20		tsb $20		                tsb status
.86e5		20 30 89	jsr $8930	                jsr xt_create
.86e8		20 84 d7	jsr $d784	                jsr current_to_dp   ; This might be able to be omitted
.86eb		a5 02		lda $02		                lda dp
.86ed		85 04		sta $04		                sta workword
.86ef		a5 03		lda $03		                lda dp+1
.86f1		85 05		sta $05		                sta workword+1
.86f3		68		pla		                pla
.86f4		85 02		sta $02		                sta dp
.86f6		68		pla		                pla
.86f7		85 03		sta $03		                sta dp+1
.86f9		20 97 d7	jsr $d797	                jsr dp_to_current
.86fc		a5 00		lda $00		                lda cp
.86fe		38		sec		                sec
.86ff		e9 03		sbc #$03	                sbc #3
.8701		85 00		sta $00		                sta cp
.8703		b0 02		bcs $8707	                bcs _done
.8705		c6 01		dec $01		                dec cp+1
.8707						_done:
.8707		60		rts		z_colon:        rts
.8708						xt_colon_noname:
.8708		a5 16		lda $16		                lda state
.870a		05 17		ora $17		                ora state+1
.870c		f0 05		beq $8713	                beq +
.870e		a9 07		lda #$07	                lda #err_state
.8710		4c 58 d8	jmp $d858	                jmp error
.8713						+
.8713		c6 16		dec $16		                dec state
.8715		c6 17		dec $17		                dec state+1
.8717		a9 40		lda #$40	                lda #%01000000
.8719		14 20		trb $20		                trb status
.871b		a5 00		lda $00		                lda cp
.871d		85 04		sta $04		                sta workword
.871f		a5 01		lda $01		                lda cp+1
.8721		85 05		sta $05		                sta workword+1
.8723						_done:
.8723		60		rts		z_colon_noname:        rts
.8724						xt_comma:
.8724		20 42 d8	jsr $d842	                jsr underflow_1
.8727		b5 00		lda $00,x	                lda 0,x
.8729		92 00		sta ($00)	                sta (cp)
.872b		e6 00		inc $00		                inc cp
.872d		d0 02		bne $8731	                bne +
.872f		e6 01		inc $01		                inc cp+1
.8731						+
.8731		b5 01		lda $01,x	                lda 1,x
.8733		92 00		sta ($00)	                sta (cp)
.8735		e6 00		inc $00		                inc cp
.8737		d0 02		bne $873b	                bne _done
.8739		e6 01		inc $01		                inc cp+1
.873b						_done:
.873b		e8		inx		                inx
.873c		e8		inx		                inx
.873d		60		rts		z_comma:        rts
.873e						xt_compare:
.873e		20 51 d8	jsr $d851	                jsr underflow_4
.8741		b5 02		lda $02,x	                lda 2,x
.8743		85 26		sta $26		                sta tmp2
.8745		b5 03		lda $03,x	                lda 3,x
.8747		85 27		sta $27		                sta tmp2+1
.8749		b5 06		lda $06,x	                lda 6,x
.874b		85 24		sta $24		                sta tmp1
.874d		b5 07		lda $07,x	                lda 7,x
.874f		85 25		sta $25		                sta tmp1+1
.8751						_compare_loop:
.8751		b5 04		lda $04,x	                lda 4,x
.8753		15 05		ora $05,x	                ora 5,x
.8755		f0 2c		beq $8783	                beq _str1_done
.8757		b5 00		lda $00,x	                lda 0,x
.8759		15 01		ora $01,x	                ora 1,x
.875b		f0 3a		beq $8797	                beq _greater    ; Str2 empty first
.875d						_check_letter:
.875d		b2 24		lda ($24)	                lda (tmp1)
.875f		d2 26		cmp ($26)	                cmp (tmp2)
.8761		90 26		bcc $8789	                bcc _less
.8763		d0 32		bne $8797	                bne _greater
.8765						_next_letter:
.8765		e6 24		inc $24		                inc tmp1
.8767		d0 02		bne $876b	                bne +
.8769		e6 25		inc $25		                inc tmp1+1
.876b						+
.876b		e6 26		inc $26		                inc tmp2
.876d		d0 02		bne $8771	                bne +
.876f		e6 27		inc $27		                inc tmp2+1
.8771						+
.8771		b5 04		lda $04,x	                lda 4,x
.8773		d0 02		bne $8777	                bne +
.8775		d6 05		dec $05,x	                dec 5,x
.8777						+
.8777		d6 04		dec $04,x	                dec 4,x
.8779		b5 00		lda $00,x	                lda 0,x
.877b		d0 02		bne $877f	                bne +
.877d		d6 01		dec $01,x	                dec 1,x
.877f						+
.877f		d6 00		dec $00,x	                dec 0,x
.8781		80 ce		bra $8751	                bra _compare_loop
.8783						_str1_done:
.8783		b5 00		lda $00,x	                lda 0,x
.8785		15 01		ora $01,x	                ora 1,x
.8787		f0 08		beq $8791	                beq _equal      ; Both out of letters
.8789						_less:
.8789		a9 ff		lda #$ff	                lda #$FF
.878b		95 06		sta $06,x	                sta 6,x
.878d		95 07		sta $07,x	                sta 7,x
.878f		80 0c		bra $879d	                bra _done
.8791						_equal:
.8791		74 06		stz $06,x	                stz 6,x
.8793		74 07		stz $07,x	                stz 7,x
.8795		80 06		bra $879d	                bra _done
.8797						_greater:
.8797		a9 01		lda #$01	                lda #1
.8799		95 06		sta $06,x	                sta 6,x
.879b		74 07		stz $07,x	                stz 7,x
.879d						_done:
.879d		8a		txa		                txa
.879e		18		clc		                clc
.879f		69 06		adc #$06	                adc #6
.87a1		aa		tax		                tax
.87a2		60		rts		z_compare:      rts
.87a3						xt_compile_comma:
.87a3		20 42 d8	jsr $d842	                jsr underflow_1
.87a6		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87a8		48		pha		                pha
.87a9		b5 00		lda $00,x	                lda 0,x
.87ab		48		pha		                pha                     ; LSB
.87ac		20 29 92	jsr $9229	                jsr xt_int_to_name      ; ( xt -- nt )
.87af		b5 00		lda $00,x	                lda 0,x
.87b1		15 01		ora $01,x	                ora 1,x
.87b3		d0 03		bne $87b8	                bne _check_nt
.87b5		4c b1 88	jmp $88b1	                jmp compile_as_jump
.87b8						_check_nt:
.87b8		b5 00		lda $00,x	                lda 0,x
.87ba		85 2c		sta $2c		                sta tmptos
.87bc		b5 01		lda $01,x	                lda 1,x
.87be		85 2d		sta $2d		                sta tmptos+1
.87c0		f6 00		inc $00,x	                inc 0,x
.87c2		d0 02		bne $87c6	                bne +
.87c4		f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.87c6						+
.87c6		a1 00		lda ($00,x)	                lda (0,x)
.87c8		85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.87ca		29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.87cc		f0 0d		beq $87db	                beq _compile_check
.87ce		a5 2c		lda $2c		                lda tmptos
.87d0		95 00		sta $00,x	                sta 0,x
.87d2		a5 2d		lda $2d		                lda tmptos+1
.87d4		95 01		sta $01,x	                sta 1,x
.87d6		20 fa a6	jsr $a6fa	                jsr xt_wordsize         ; ( nt -- u )
.87d9		80 27		bra $8802	                bra _compile_as_code
.87db						_compile_check:
.87db		a5 28		lda $28		                lda tmp3
.87dd		29 08		and #$08	                and #NN
.87df		f0 03		beq $87e4	                beq _check_size_limit
.87e1		4c b1 88	jmp $88b1	                jmp compile_as_jump    ; too far for BRA
.87e4						_check_size_limit:
.87e4		a5 2c		lda $2c		                lda tmptos
.87e6		95 00		sta $00,x	                sta 0,x
.87e8		a5 2d		lda $2d		                lda tmptos+1
.87ea		95 01		sta $01,x	                sta 1,x
.87ec		20 fa a6	jsr $a6fa	                jsr xt_wordsize         ; ( nt -- u )
.87ef		b5 01		lda $01,x	                lda 1,x
.87f1		c5 1b		cmp $1b		                cmp nc_limit+1
.87f3		90 0d		bcc $8802	                bcc _compile_as_code    ; user-defined limit MSB
.87f5		d0 08		bne $87ff	                bne _jumpto_compile_as_jump
.87f7		b5 00		lda $00,x	                lda 0,x
.87f9		c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.87fb		90 05		bcc $8802	                bcc _compile_as_code    ; Allow native compiling for less
.87fd		f0 03		beq $8802	                beq _compile_as_code    ; than or equal to the limit.
.87ff						_jumpto_compile_as_jump:
.87ff		4c b1 88	jmp $88b1	                jmp compile_as_jump    ; too far for BRA
.8802						_compile_as_code:
.8802		ca		dex		                dex
.8803		ca		dex		                dex                     ; ( -- u ? )
.8804		ca		dex		                dex
.8805		ca		dex		                dex                     ; ( -- u ? ? )
.8806		b5 04		lda $04,x	                lda 4,x
.8808		95 00		sta $00,x	                sta 0,x                 ; LSB of u
.880a		b5 05		lda $05,x	                lda 5,x
.880c		95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.880e		68		pla		                pla
.880f		95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8811		68		pla		                pla
.8812		95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.8814		a5 00		lda $00		                lda cp                  ; LSB of cp
.8816		95 02		sta $02,x	                sta 2,x
.8818		a5 01		lda $01		                lda cp+1
.881a		95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.881c		a0 00		ldy #$00	                ldy #0
.881e						_strip_loop:
.881e		b9 9f 88	lda $889f,y	                lda strip_table,y      ; LSB of first word
.8821		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8823		d0 07		bne $882c	                bne _next_entry
.8825		b9 a0 88	lda $88a0,y	                lda strip_table+1,y
.8828		d5 05		cmp $05,x	                cmp 5,x
.882a		f0 0c		beq $8838	                beq _found_entry
.882c						_next_entry:
.882c		b9 9f 88	lda $889f,y	                lda strip_table,y      ; pointing to LSB
.882f		19 a0 88	ora $88a0,y	                ora strip_table+1,y    ; get MSB
.8832		f0 22		beq $8856	                beq _underflow_strip    ; table done, let's get out of here
.8834		c8		iny		                iny
.8835		c8		iny		                iny
.8836		80 e6		bra $881e	                bra _strip_loop
.8838						_found_entry:
.8838		98		tya		                tya
.8839		4a		lsr a		                lsr
.883a		a8		tay		                tay
.883b		b9 ab 88	lda $88ab,y	                lda strip_size,y
.883e		85 2c		sta $2c		                sta tmptos              ; save a copy
.8840		18		clc		                clc
.8841		75 04		adc $04,x	                adc 4,x
.8843		95 04		sta $04,x	                sta 4,x
.8845		90 02		bcc $8849	                bcc+
.8847		f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8849						+
.8849		06 2c		asl $2c		                asl tmptos
.884b		38		sec		                sec
.884c		b5 00		lda $00,x	                lda 0,x
.884e		e5 2c		sbc $2c		                sbc tmptos
.8850		95 00		sta $00,x	                sta 0,x
.8852		b0 02		bcs $8856	                bcs +
.8854		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8856						+
.8856						_underflow_strip:
.8856		a5 1c		lda $1c		                lda uf_strip
.8858		05 1d		ora $1d		                ora uf_strip+1
.885a		f0 1c		beq $8878	                beq cmpl_inline
.885c		a5 28		lda $28		                lda tmp3
.885e		29 10		and #$10	                and #UF
.8860		f0 16		beq $8878	                beq cmpl_inline
.8862		18		clc		                clc
.8863		b5 04		lda $04,x	                lda 4,x
.8865		69 03		adc #$03	                adc #3
.8867		95 04		sta $04,x	                sta 4,x
.8869		90 02		bcc $886d	                bcc +
.886b		f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.886d						+
.886d		38		sec		                sec
.886e		b5 00		lda $00,x	                lda 0,x
.8870		e9 03		sbc #$03	                sbc #3
.8872		95 00		sta $00,x	                sta 0,x
.8874		b0 02		bcs $8878	                bcs +
.8876		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.8878						+
.8878						cmpl_inline:
.8878		b5 01		lda $01,x	                lda 1,x                 ; MSB
.887a		48		pha		                pha
.887b		b5 00		lda $00,x	                lda 0,x                 ; LSB
.887d		48		pha		                pha
.887e		20 76 95	jsr $9576	                jsr xt_move
.8881		18		clc		                clc
.8882		68		pla		                pla                     ; LSB
.8883		65 00		adc $00		                adc cp
.8885		85 00		sta $00		                sta cp
.8887		68		pla		                pla                     ; MSB
.8888		65 01		adc $01		                adc cp+1
.888a		85 01		sta $01		                sta cp+1
.888c		60		rts		                rts
.888d						cmpl_inline_y:
.888d		ca		dex		                dex             ; set up stack as ( src dst n -- )
.888e		ca		dex		                dex
.888f		ca		dex		                dex
.8890		ca		dex		                dex
.8891		94 00		sty $00,x	                sty 0,x
.8893		74 01		stz $01,x	                stz 1,x             ; assume < 256 bytes
.8895		a5 00		lda $00		                lda cp
.8897		95 02		sta $02,x	                sta 2,x
.8899		a5 01		lda $01		                lda cp+1
.889b		95 03		sta $03,x	                sta 3,x
.889d		80 d9		bra $8878	                bra cmpl_inline
.889f						strip_table:
>889f		46 9a 31 9a f5 a2		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88a5		27 a4 ad a3 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88ab						strip_size:
>88ab		04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88b1						compile_as_jump:
.88b1		a9 20		lda #$20	                lda #$20
.88b3		92 00		sta ($00)	                sta (cp)
.88b5		a0 01		ldy #$01	                ldy #1
.88b7		68		pla		                pla             ; LSB
.88b8		91 00		sta ($00),y	                sta (cp),y
.88ba		c8		iny		                iny
.88bb		68		pla		                pla             ; MSB
.88bc		91 00		sta ($00),y	                sta (cp),y
.88be		a9 03		lda #$03	                lda #3
.88c0		18		clc		                clc
.88c1		65 00		adc $00		                adc cp
.88c3		85 00		sta $00		                sta cp
.88c5		90 02		bcc $88c9	                bcc +
.88c7		e6 01		inc $01		                inc cp+1
.88c9						+
.88c9		e8		inx		                inx             ; drop xt
.88ca		e8		inx		                inx
.88cb						z_compile_comma:
.88cb		60		rts		                rts
.88cc						xt_compile_only:
.88cc		20 84 d7	jsr $d784	                jsr current_to_dp
.88cf		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.88d1		b1 02		lda ($02),y	                lda (dp),y
.88d3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.88d5		91 02		sta ($02),y	                sta (dp),y
.88d7		60		rts		z_compile_only: rts
.88d8						xt_value:
.88d8						xt_constant:
.88d8		20 42 d8	jsr $d842	                jsr underflow_1
.88db		20 30 89	jsr $8930	                jsr xt_create
.88de		38		sec		                sec
.88df		a5 00		lda $00		                lda cp
.88e1		e9 02		sbc #$02	                sbc #2
.88e3		85 24		sta $24		                sta tmp1
.88e5		a5 01		lda $01		                lda cp+1
.88e7		e9 00		sbc #$00	                sbc #0
.88e9		85 25		sta $25		                sta tmp1+1
.88eb		a9 fe		lda #$fe	                lda #<doconst           ; LSB of DOCONST
.88ed		92 24		sta ($24)	                sta (tmp1)
.88ef		a0 01		ldy #$01	                ldy #1
.88f1		a9 d6		lda #$d6	                lda #>doconst           ; MSB of DOCONST
.88f3		91 24		sta ($24),y	                sta (tmp1),y
.88f5		20 24 87	jsr $8724	                jsr xt_comma            ; drop through to adjust_z
.88f8						adjust_z:
.88f8		20 ec 92	jsr $92ec	                jsr xt_latestnt         ; gives us ( -- nt )
.88fb		b5 00		lda $00,x	                lda 0,x
.88fd		85 24		sta $24		                sta tmp1
.88ff		b5 01		lda $01,x	                lda 1,x
.8901		85 25		sta $25		                sta tmp1+1
.8903		a0 06		ldy #$06	                ldy #6
.8905		b1 24		lda ($24),y	                lda (tmp1),y
.8907		18		clc		                clc
.8908		69 02		adc #$02	                adc #2
.890a		91 24		sta ($24),y	                sta (tmp1),y
.890c		c8		iny		                iny
.890d		b1 24		lda ($24),y	                lda (tmp1),y
.890f		69 00		adc #$00	                adc #0                  ; only need carry
.8911		91 24		sta ($24),y	                sta (tmp1),y
.8913		e8		inx		                inx
.8914		e8		inx		                inx
.8915						z_value:
.8915		60		rts		z_constant:     rts
.8916						xt_count:
.8916		20 42 d8	jsr $d842	                jsr underflow_1
.8919		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.891b		a8		tay		                tay
.891c		f6 00		inc $00,x	                inc 0,x         ; LSB
.891e		d0 02		bne $8922	                bne +
.8920		f6 01		inc $01,x	                inc 1,x         ; MSB
.8922		98		tya		+               tya
.8923		ca		dex		                dex
.8924		ca		dex		                dex
.8925		95 00		sta $00,x	                sta 0,x         ; LSB
.8927		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8929		60		rts		z_count:        rts
.892a						xt_cr:
.892a		a9 0a		lda #$0a	                lda #AscLF
.892c		20 a9 8d	jsr $8da9	                jsr emit_a
.892f		60		rts		z_cr:           rts
.8930						xt_create:
.8930		20 93 98	jsr $9893	                jsr xt_parse_name       ; ( addr u )
.8933		b5 00		lda $00,x	                lda 0,x
.8935		15 01		ora $01,x	                ora 1,x
.8937		d0 05		bne $893e	                bne _got_name
.8939		a9 05		lda #$05	                lda #err_noname
.893b		4c 58 d8	jmp $d858	                jmp error
.893e						_got_name:
.893e		74 01		stz $01,x	                stz 1,x
.8940		20 3d a3	jsr $a33d	                jsr xt_two_dup          ; ( addr u addr u )
.8943		20 8e 8f	jsr $8f8e	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8946		b5 00		lda $00,x	                lda 0,x
.8948		15 01		ora $01,x	                ora 1,x
.894a		f0 1e		beq $896a	                beq _new_name           ; We haven't seen this one before.
.894c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.894d		e8		inx		                inx
.894e		24 20		bit $20		                bit status
.8950		10 08		bpl $895a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8952		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8954		05 20		ora $20		                ora status
.8956		85 20		sta $20		                sta status
.8958		80 18		bra $8972	                bra _process_name
.895a						_redefined_name:
.895a		a9 02		lda #$02	                lda #str_redefined
.895c		20 7e d8	jsr $d87e	                jsr print_string_no_lf
.895f		20 3d a3	jsr $a33d	                jsr xt_two_dup           ; ( addr u addr u )
.8962		20 88 a4	jsr $a488	                jsr xt_type
.8965		20 a3 a0	jsr $a0a3	                jsr xt_space
.8968		80 08		bra $8972	                bra _process_name
.896a						_new_name:
.896a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.896b		e8		inx		                inx
.896c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.896e		25 20		and $20		                and status
.8970		85 20		sta $20		                sta status
.8972						_process_name:
.8972		b5 00		lda $00,x	                lda 0,x
.8974		85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.8976		a5 00		lda $00		                lda cp
.8978		85 24		sta $24		                sta tmp1
.897a		a5 01		lda $01		                lda cp+1
.897c		85 25		sta $25		                sta tmp1+1
.897e		b5 00		lda $00,x	                lda 0,x
.8980		18		clc		                clc
.8981		69 08		adc #$08	                adc #8
.8983		85 28		sta $28		                sta tmp3                ; total header length
.8985		18		clc		                clc
.8986		69 03		adc #$03	                adc #3
.8988		95 00		sta $00,x	                sta 0,x
.898a		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.898c		20 3f 82	jsr $823f	                jsr xt_allot    ; ( addr )
.898f		20 84 d7	jsr $d784	                jsr current_to_dp
.8992		a0 00		ldy #$00	                ldy #0
.8994		a5 26		lda $26		                lda tmp2
.8996		91 24		sta ($24),y	                sta (tmp1),y
.8998		a9 08		lda #$08	                lda #NN
.899a		09 20		ora #$20	                ora #HC
.899c		c8		iny		                iny
.899d		91 24		sta ($24),y	                sta (tmp1),y
.899f		c8		iny		                iny
.89a0		a5 02		lda $02		                lda dp
.89a2		91 24		sta ($24),y	                sta (tmp1),y
.89a4		c8		iny		                iny
.89a5		a5 03		lda $03		                lda dp+1
.89a7		91 24		sta ($24),y	                sta (tmp1),y
.89a9		c8		iny		                iny
.89aa		a5 25		lda $25		                lda tmp1+1
.89ac		85 03		sta $03		                sta dp+1
.89ae		a5 24		lda $24		                lda tmp1
.89b0		85 02		sta $02		                sta dp
.89b2		18		clc		                clc
.89b3		65 28		adc $28		                adc tmp3        ; add total header length
.89b5		91 24		sta ($24),y	                sta (tmp1),y
.89b7		48		pha		                pha             ; we need this in the next step
.89b8		c8		iny		                iny
.89b9		a5 25		lda $25		                lda tmp1+1
.89bb		69 00		adc #$00	                adc #0          ; only need the carry
.89bd		91 24		sta ($24),y	                sta (tmp1),y
.89bf		c8		iny		                iny
.89c0		68		pla		                pla             ; LSB of "z_" address
.89c1		18		clc		                clc
.89c2		69 03		adc #$03	                adc #3
.89c4		91 24		sta ($24),y	                sta (tmp1),y
.89c6		88		dey		                dey             ; get the MSB of xt back
.89c7		b1 24		lda ($24),y	                lda (tmp1),y
.89c9		69 00		adc #$00	                adc #0          ; only need the carry
.89cb		c8		iny		                iny
.89cc		c8		iny		                iny
.89cd		91 24		sta ($24),y	                sta (tmp1),y
.89cf		c8		iny		                iny
.89d0		b5 00		lda $00,x	                lda 0,x
.89d2		38		sec		                sec
.89d3		e9 08		sbc #$08	                sbc #8
.89d5		85 2c		sta $2c		                sta tmptos
.89d7		b5 01		lda $01,x	                lda 1,x
.89d9		e9 00		sbc #$00	                sbc #0          ; only need carry
.89db		85 2d		sta $2d		                sta tmptos+1
.89dd						_name_loop:
.89dd		b1 2c		lda ($2c),y	                lda (tmptos),y
.89df		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.89e1		b0 07		bcs $89ea	                bcs _store_name
.89e3		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.89e5		90 03		bcc $89ea	                bcc _store_name
.89e7		18		clc		                clc
.89e8		69 20		adc #$20	                adc #$20
.89ea						_store_name:
.89ea		91 24		sta ($24),y	                sta (tmp1),y
.89ec		c8		iny		                iny
.89ed		c6 26		dec $26		                dec tmp2
.89ef		d0 ec		bne $89dd	                bne _name_loop
.89f1		a9 20		lda #$20	                lda #$20        ; opcode of JSR
.89f3		91 24		sta ($24),y	                sta (tmp1),y
.89f5		c8		iny		                iny
.89f6		a9 44		lda #$44	                lda #<dovar
.89f8		91 24		sta ($24),y	                sta (tmp1),y
.89fa		c8		iny		                iny
.89fb		a9 d7		lda #$d7	                lda #>dovar
.89fd		91 24		sta ($24),y	                sta (tmp1),y
.89ff		20 97 d7	jsr $d797	                jsr dp_to_current
.8a02		e8		inx		                inx
.8a03		e8		inx		                inx
.8a04		60		rts		z_create:       rts
.8a05						xt_d_minus:
.8a05		20 51 d8	jsr $d851	                jsr underflow_4 ; two double numbers
.8a08		38		sec		                sec
.8a09		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a0b		f5 02		sbc $02,x	                sbc 2,x
.8a0d		95 06		sta $06,x	                sta 6,x
.8a0f		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a11		f5 03		sbc $03,x	                sbc 3,x
.8a13		95 07		sta $07,x	                sta 7,x
.8a15		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a17		f5 00		sbc $00,x	                sbc 0,x
.8a19		95 04		sta $04,x	                sta 4,x
.8a1b		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a1d		f5 01		sbc $01,x	                sbc 1,x
.8a1f		95 05		sta $05,x	                sta 5,x
.8a21		e8		inx		                inx
.8a22		e8		inx		                inx
.8a23		e8		inx		                inx
.8a24		e8		inx		                inx
.8a25		60		rts		z_d_minus:      rts
.8a26						xt_d_plus:
.8a26		20 51 d8	jsr $d851	                jsr underflow_4 ; two double numbers
.8a29		18		clc		                clc
.8a2a		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a2c		75 06		adc $06,x	                adc 6,x
.8a2e		95 06		sta $06,x	                sta 6,x
.8a30		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a32		75 07		adc $07,x	                adc 7,x
.8a34		95 07		sta $07,x	                sta 7,x
.8a36		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a38		75 04		adc $04,x	                adc 4,x
.8a3a		95 04		sta $04,x	                sta 4,x
.8a3c		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a3e		75 05		adc $05,x	                adc 5,x
.8a40		95 05		sta $05,x	                sta 5,x
.8a42		e8		inx		                inx
.8a43		e8		inx		                inx
.8a44		e8		inx		                inx
.8a45		e8		inx		                inx
.8a46		60		rts		z_d_plus:       rts
.8a47						xt_d_to_s:
.8a47		20 47 d8	jsr $d847	                jsr underflow_2
.8a4a		e8		inx		                inx
.8a4b		e8		inx		                inx
.8a4c		60		rts		z_d_to_s:       rts
.8a4d						xt_dabs:
.8a4d		20 47 d8	jsr $d847	                jsr underflow_2 ; double number
.8a50		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a52		10 17		bpl $8a6b	                bpl _done       ; positive, we get off light
.8a54		a0 00		ldy #$00	                ldy #0
.8a56		38		sec		                sec
.8a57		98		tya		                tya
.8a58		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a5a		95 02		sta $02,x	                sta 2,x
.8a5c		98		tya		                tya
.8a5d		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a5f		95 03		sta $03,x	                sta 3,x
.8a61		98		tya		                tya
.8a62		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a64		95 00		sta $00,x	                sta 0,x
.8a66		98		tya		                tya
.8a67		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a69		95 01		sta $01,x	                sta 1,x
.8a6b						_done:
.8a6b		60		rts		z_dabs:         rts
.8a6c						xt_decimal:
.8a6c		a9 0a		lda #$0a	                lda #10
.8a6e		85 18		sta $18		                sta base
.8a70		64 19		stz $19		                stz base+1              ; paranoid
.8a72		60		rts		z_decimal:      rts
.8a73						xt_defer:
.8a73		20 30 89	jsr $8930	                jsr xt_create
.8a76		a5 00		lda $00		                lda cp          ; LSB
.8a78		38		sec		                sec
.8a79		e9 02		sbc #$02	                sbc #2
.8a7b		85 24		sta $24		                sta tmp1
.8a7d		a5 01		lda $01		                lda cp+1        ; MSB
.8a7f		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8a81		85 25		sta $25		                sta tmp1+1
.8a83		a0 00		ldy #$00	                ldy #0
.8a85		a9 12		lda #$12	                lda #<dodefer   ; LSB
.8a87		91 24		sta ($24),y	                sta (tmp1),y
.8a89		c8		iny		                iny
.8a8a		a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8a8c		91 24		sta ($24),y	                sta (tmp1),y
.8a8e		a9 26		lda #$26	                lda #<defer_error
.8a90		92 00		sta ($00)	                sta (cp)
.8a92		e6 00		inc $00		                inc cp
.8a94		d0 02		bne $8a98	                bne +
.8a96		e6 01		inc $01		                inc cp+1
.8a98						+
.8a98		a9 d7		lda #$d7	                lda #>defer_error
.8a9a		92 00		sta ($00)	                sta (cp)
.8a9c		e6 00		inc $00		                inc cp
.8a9e		d0 02		bne $8aa2	                bne +
.8aa0		e6 01		inc $01		                inc cp+1
.8aa2						+
.8aa2		20 f8 88	jsr $88f8	                jsr adjust_z    ; adjust header to correct length
.8aa5		60		rts		z_defer:        rts
.8aa6						xt_defer_fetch:
.8aa6		20 12 a2	jsr $a212	                jsr xt_to_body
.8aa9		20 33 8f	jsr $8f33	                jsr xt_fetch
.8aac		60		rts		z_defer_fetch:  rts
.8aad						xt_defer_store:
.8aad		20 12 a2	jsr $a212	                jsr xt_to_body
.8ab0		20 12 a1	jsr $a112	                jsr xt_store
.8ab3		60		rts		z_defer_store:  rts
.8ab4						xt_definitions:
.8ab4		a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8ab6		b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8ab8		a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8aba		91 1e		sta ($1e),y	                sta (up),y
.8abc		60		rts		z_definitions:  rts
.8abd						xt_depth:
.8abd		a9 78		lda #$78	                lda #dsp0
.8abf		86 2a		stx $2a		                stx tmpdsp
.8ac1		38		sec		                sec
.8ac2		e5 2a		sbc $2a		                sbc tmpdsp
.8ac4		4a		lsr a		                lsr
.8ac5		ca		dex		                dex
.8ac6		ca		dex		                dex
.8ac7		95 00		sta $00,x	                sta 0,x
.8ac9		74 01		stz $01,x	                stz 1,x
.8acb		60		rts		z_depth:        rts
.8acc						xt_digit_question:
.8acc		20 42 d8	jsr $d842	                jsr underflow_1
.8acf		ca		dex		                dex
.8ad0		ca		dex		                dex
.8ad1		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8ad3		74 01		stz $01,x	                stz 1,x
.8ad5		74 03		stz $03,x	                stz 3,x                 ; paranoid
.8ad7		b5 02		lda $02,x	                lda 2,x
.8ad9		c9 30		cmp #$30	                cmp #'0'
.8adb		90 23		bcc $8b00	                bcc _done               ; failure flag already set
.8add		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8adf		90 12		bcc $8af3	                bcc _checkbase
.8ae1		c9 41		cmp #$41	                cmp #'A'
.8ae3		90 1b		bcc $8b00	                bcc _done               ; failure flag is already set
.8ae5		c9 61		cmp #$61	                cmp #'a'
.8ae7		90 07		bcc $8af0	                bcc _case_done          ; not lower case, too low
.8ae9		c9 7b		cmp #$7b	                cmp #'z'+1
.8aeb		b0 03		bcs $8af0	                bcs _case_done          ; not lower case, too high
.8aed		18		clc		                clc                     ; just right
.8aee		69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8af0						_case_done:
.8af0		38		sec		                sec
.8af1		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8af3						_checkbase:
.8af3		38		sec		                sec
.8af4		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8af6		c5 18		cmp $18		                cmp base
.8af8		b0 06		bcs $8b00	                bcs _done               ; already have false flag
.8afa		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8afc		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8afe		d6 01		dec $01,x	                dec 1,x
.8b00						_done:
.8b00						z_digit_question:
.8b00		60		rts		                rts
.8b01						xt_disasm:
.8b01		20 47 d8	jsr $d847	                jsr underflow_2
.8b04		20 ac ac	jsr $acac	                jsr disassembler
.8b07		60		rts		z_disasm:       rts
.8b08						xt_dnegate:
.8b08		20 47 d8	jsr $d847	                jsr underflow_2 ; double number
.8b0b		a0 00		ldy #$00	     		ldy #0
.8b0d		38		sec		                sec
.8b0e		98		tya		                tya
.8b0f		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b11		95 02		sta $02,x	                sta 2,x
.8b13		98		tya		                tya
.8b14		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b16		95 03		sta $03,x	                sta 3,x
.8b18		98		tya		                tya
.8b19		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b1b		95 00		sta $00,x	                sta 0,x
.8b1d		98		tya		                tya
.8b1e		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b20		95 01		sta $01,x	                sta 1,x
.8b22		60		rts		z_dnegate:      rts
.8b23						xt_question_do:
.8b23		a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b25		85 24		sta $24		                sta tmp1
.8b27		80 02		bra $8b2b	                bra do_common           ; skip flag for DO
.8b29						xt_do:
.8b29		64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b2b						do_common:
.8b2b		ca		dex		                dex
.8b2c		ca		dex		                dex
.8b2d		a5 01		lda $01		                lda cp+1
.8b2f		95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b31		a5 00		lda $00		                lda cp
.8b33		95 00		sta $00,x	                sta 0,x                 ; LSB
.8b35		18		clc		                clc
.8b36		69 06		adc #$06	                adc #6
.8b38		85 00		sta $00		                sta cp
.8b3a		90 02		bcc $8b3e	                bcc +
.8b3c		e6 01		inc $01		                inc cp+1
.8b3e						+
.8b3e		a5 24		lda $24		                lda tmp1
.8b40		f0 0f		beq $8b51	                beq _compile_do
.8b42		ca		dex		                dex
.8b43		ca		dex		                dex
.8b44		a9 94		lda #$94	                lda #<question_do_runtime
.8b46		95 00		sta $00,x	                sta 0,x
.8b48		a9 8b		lda #$8b	                lda #>question_do_runtime
.8b4a		95 01		sta $01,x	                sta 1,x
.8b4c		a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b4e		20 8d 88	jsr $888d	                jsr cmpl_inline_y
.8b51						_compile_do:
.8b51		a0 8b		ldy #$8b	                ldy #>do_runtime
.8b53		a9 63		lda #$63	                lda #<do_runtime
.8b55		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.8b58		ca		dex		                dex
.8b59		ca		dex		                dex
.8b5a		a5 00		lda $00		                lda CP          ; LSB
.8b5c		95 00		sta $00,x	                sta 0,x
.8b5e		a5 01		lda $01		                lda CP+1        ; MSB
.8b60		95 01		sta $01,x	                sta 1,x
.8b62						z_question_do:
.8b62		60		rts		z_do:           rts
.8b63						do_runtime:
.8b63		68		pla		                pla
.8b64		85 24		sta $24		                sta tmp1
.8b66		68		pla		                pla
.8b67		85 25		sta $25		                sta tmp1+1
.8b69		38		sec		                sec
.8b6a		a9 00		lda #$00	                lda #0
.8b6c		f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8b6e		95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8b70		a9 80		lda #$80	                lda #$80
.8b72		f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8b74		95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8b76		48		pha		                pha             ; FUFA replaces limit on R stack
.8b77		b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8b79		48		pha		                pha
.8b7a		18		clc		                clc
.8b7b		b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8b7d		75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8b7f		95 00		sta $00,x	                sta 0,x
.8b81		b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8b83		75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8b85		48		pha		                pha
.8b86		b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8b88		48		pha		                pha
.8b89		e8		inx		                inx
.8b8a		e8		inx		                inx
.8b8b		e8		inx		                inx
.8b8c		e8		inx		                inx
.8b8d		a5 25		lda $25		                lda tmp1+1
.8b8f		48		pha		                pha
.8b90		a5 24		lda $24		                lda tmp1
.8b92		48		pha		                pha
.8b93		60		rts		                rts
.8b94						question_do_runtime:
.8b94		20 3d a3	jsr $a33d	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8b97		20 81 8e	jsr $8e81	                jsr xt_equal            ; ( -- n1 n2 f )
.8b9a		b5 00		lda $00,x	                lda 0,x
.8b9c		15 01		ora $01,x	                ora 1,x
.8b9e		f0 06		beq $8ba6	                beq _do_do
.8ba0		8a		txa		                txa
.8ba1		18		clc		                clc
.8ba2		69 06		adc #$06	                adc #6
.8ba4		aa		tax		                tax
.8ba5		60		rts		                rts
.8ba6						_do_do:
.8ba6		e8		inx		                inx             ; clear flag from EQUAL off stack
.8ba7		e8		inx		                inx             ; no RTS because this is copied into code
.8ba8						question_do_runtime_end:
.8ba8						xt_does:
.8ba8		a0 8b		ldy #$8b	                ldy #>does_runtime
.8baa		a9 b7		lda #$b7	                lda #<does_runtime
.8bac		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.8baf		a0 d7		ldy #$d7	                ldy #>dodoes
.8bb1		a9 2b		lda #$2b	                lda #<dodoes
.8bb3		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.8bb6		60		rts		z_does:         rts
.8bb7						does_runtime:
.8bb7		7a		ply		                ply             ; LSB
.8bb8		68		pla		                pla             ; MSB
.8bb9		c8		iny		                iny
.8bba		d0 01		bne $8bbd	                bne +
.8bbc		1a		inc a		                ina
.8bbd						+
.8bbd		84 24		sty $24		                sty tmp1
.8bbf		85 25		sta $25		                sta tmp1+1
.8bc1		20 84 d7	jsr $d784	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8bc4		a5 02		lda $02		                lda dp
.8bc6		18		clc		                clc
.8bc7		69 04		adc #$04	                adc #4
.8bc9		85 26		sta $26		                sta tmp2
.8bcb		a5 03		lda $03		                lda dp+1
.8bcd		69 00		adc #$00	                adc #0          ; we only care about the carry
.8bcf		85 27		sta $27		                sta tmp2+1
.8bd1		b2 26		lda ($26)	                lda (tmp2)
.8bd3		18		clc		                clc
.8bd4		69 01		adc #$01	                adc #1
.8bd6		85 28		sta $28		                sta tmp3
.8bd8		a0 01		ldy #$01	                ldy #1
.8bda		b1 26		lda ($26),y	                lda (tmp2),y
.8bdc		69 00		adc #$00	                adc #0          ; we only care about the carry
.8bde		85 29		sta $29		                sta tmp3+1
.8be0		a5 24		lda $24		                lda tmp1        ; LSB
.8be2		92 28		sta ($28)	                sta (tmp3)
.8be4		a5 25		lda $25		                lda tmp1+1
.8be6		91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8be8		60		rts		                rts
.8be9						xt_dot:
.8be9		20 42 d8	jsr $d842	                jsr underflow_1
.8bec		20 62 8d	jsr $8d62	                jsr xt_dup                      ; ( n n )
.8bef		20 cd 80	jsr $80cd	                jsr xt_abs                      ; ( n u )
.8bf2		20 2d a7	jsr $a72d	                jsr xt_zero                     ; ( n u 0 )
.8bf5		20 0b 93	jsr $930b	                jsr xt_less_number_sign         ; ( n u 0 )
.8bf8		20 92 97	jsr $9792	                jsr xt_number_sign_s            ; ( n ud )
.8bfb		20 0b 9b	jsr $9b0b	                jsr xt_rot                      ; ( ud n )
.8bfe		20 6c 9f	jsr $9f6c	                jsr xt_sign                     ; ( ud )
.8c01		20 70 97	jsr $9770	                jsr xt_number_sign_greater      ; ( addr u )
.8c04		20 88 a4	jsr $a488	                jsr xt_type
.8c07		20 a3 a0	jsr $a0a3	                jsr xt_space
.8c0a		60		rts		z_dot:          rts
.8c0b						xt_dot_paren:
.8c0b		ca		dex		                dex
.8c0c		ca		dex		                dex
.8c0d		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c0f		95 00		sta $00,x	                sta 0,x
.8c11		74 01		stz $01,x	                stz 1,x
.8c13		20 ee 98	jsr $98ee	                jsr xt_parse
.8c16		20 88 a4	jsr $a488	                jsr xt_type
.8c19		60		rts		z_dot_paren:    rts
.8c1a						xt_dot_quote:
.8c1a		20 03 9d	jsr $9d03	                jsr xt_s_quote
.8c1d		a0 a4		ldy #$a4	                ldy #>xt_type
.8c1f		a9 88		lda #$88	                lda #<xt_type
.8c21		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.8c24		60		rts		z_dot_quote:    rts
.8c25						xt_dot_r:
.8c25		20 47 d8	jsr $d847	                jsr underflow_2
.8c28		20 f5 a2	jsr $a2f5	                jsr xt_to_r
.8c2b		20 62 8d	jsr $8d62	                jsr xt_dup
.8c2e		20 cd 80	jsr $80cd	                jsr xt_abs
.8c31		20 2d a7	jsr $a72d	                jsr xt_zero
.8c34		20 0b 93	jsr $930b	                jsr xt_less_number_sign
.8c37		20 92 97	jsr $9792	                jsr xt_number_sign_s
.8c3a		20 0b 9b	jsr $9b0b	                jsr xt_rot
.8c3d		20 6c 9f	jsr $9f6c	                jsr xt_sign
.8c40		20 70 97	jsr $9770	                jsr xt_number_sign_greater
.8c43		20 46 9a	jsr $9a46	                jsr xt_r_from
.8c46		20 47 98	jsr $9847	                jsr xt_over
.8c49		20 04 95	jsr $9504	                jsr xt_minus
.8c4c		20 a9 a0	jsr $a0a9	                jsr xt_spaces
.8c4f		20 88 a4	jsr $a488	                jsr xt_type
.8c52		60		rts		z_dot_r:        rts
.8c53						xt_dot_s:
.8c53		20 bd 8a	jsr $8abd	                jsr xt_depth    ; ( -- u )
.8c56		a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8c58		20 a9 8d	jsr $8da9	                jsr emit_a
.8c5b		b5 00		lda $00,x	                lda 0,x
.8c5d		48		pha		                pha
.8c5e		ca		dex		                dex             ; DUP
.8c5f		ca		dex		                dex
.8c60		95 00		sta $00,x	                sta 0,x
.8c62		74 01		stz $01,x	                stz 1,x
.8c64		20 af d8	jsr $d8af	                jsr print_u
.8c67		a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8c69		20 a9 8d	jsr $8da9	                jsr emit_a
.8c6c		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8c6e		20 a9 8d	jsr $8da9	                jsr emit_a
.8c71		e8		inx		                inx
.8c72		e8		inx		                inx
.8c73		e0 78		cpx #$78	                cpx #dsp0
.8c75		f0 1e		beq $8c95	                beq _done
.8c77						_have_stack:
.8c77		7a		ply		                ply
.8c78		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8c7a		85 28		sta $28		                sta tmp3
.8c7c		64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8c7e						_loop:
.8c7e		ca		dex		                dex
.8c7f		ca		dex		                dex
.8c80		b2 28		lda ($28)	                lda (tmp3)
.8c82		95 01		sta $01,x	                sta 1,x
.8c84		c6 28		dec $28		                dec tmp3
.8c86		b2 28		lda ($28)	                lda (tmp3)
.8c88		95 00		sta $00,x	                sta 0,x
.8c8a		c6 28		dec $28		                dec tmp3
.8c8c		5a		phy		                phy
.8c8d		20 e9 8b	jsr $8be9	                jsr xt_dot
.8c90		7a		ply		                ply
.8c91		88		dey		                dey
.8c92		d0 ea		bne $8c7e	                bne _loop
.8c94		48		pha		                pha             ; dummy to balance stack
.8c95						_done:
.8c95		68		pla		                pla
.8c96		60		rts		z_dot_s:        rts
.8c97						xt_d_dot:
.8c97		20 47 d8	jsr $d847	                jsr underflow_2
.8c9a		20 12 a3	jsr $a312	                jsr xt_tuck
.8c9d		20 4d 8a	jsr $8a4d	                jsr xt_dabs
.8ca0		20 0b 93	jsr $930b	                jsr xt_less_number_sign
.8ca3		20 92 97	jsr $9792	                jsr xt_number_sign_s
.8ca6		20 0b 9b	jsr $9b0b	                jsr xt_rot
.8ca9		20 6c 9f	jsr $9f6c	                jsr xt_sign
.8cac		20 70 97	jsr $9770	                jsr xt_number_sign_greater
.8caf		20 88 a4	jsr $a488	                jsr xt_type
.8cb2		20 a3 a0	jsr $a0a3	                jsr xt_space
.8cb5		60		rts		z_d_dot:        rts
.8cb6						xt_d_dot_r:
.8cb6		20 4c d8	jsr $d84c	                jsr underflow_3
.8cb9		20 f5 a2	jsr $a2f5	                jsr xt_to_r
.8cbc		20 12 a3	jsr $a312	                jsr xt_tuck
.8cbf		20 4d 8a	jsr $8a4d	                jsr xt_dabs
.8cc2		20 0b 93	jsr $930b	                jsr xt_less_number_sign
.8cc5		20 92 97	jsr $9792	                jsr xt_number_sign_s
.8cc8		20 0b 9b	jsr $9b0b	                jsr xt_rot
.8ccb		20 6c 9f	jsr $9f6c	                jsr xt_sign
.8cce		20 70 97	jsr $9770	                jsr xt_number_sign_greater
.8cd1		20 46 9a	jsr $9a46	                jsr xt_r_from
.8cd4		20 47 98	jsr $9847	                jsr xt_over
.8cd7		20 04 95	jsr $9504	                jsr xt_minus
.8cda		20 a9 a0	jsr $a0a9	                jsr xt_spaces
.8cdd		20 88 a4	jsr $a488	                jsr xt_type
.8ce0		60		rts		z_d_dot_r:      rts
.8ce1						xt_drop:
.8ce1		20 42 d8	jsr $d842	                jsr underflow_1
.8ce4		e8		inx		                inx
.8ce5		e8		inx		                inx
.8ce6		60		rts		z_drop:         rts
.8ce7						xt_dump:
.8ce7		20 47 d8	jsr $d847	                jsr underflow_2
.8cea						_row:
.8cea		a0 10		ldy #$10	                ldy #16
.8cec		64 26		stz $26		                stz tmp2
.8cee		20 2a 89	jsr $892a	                jsr xt_cr
.8cf1		b5 03		lda $03,x	                lda 3,x
.8cf3		20 52 d7	jsr $d752	                jsr byte_to_ascii
.8cf6		b5 02		lda $02,x	                lda 2,x
.8cf8		20 52 d7	jsr $d752	                jsr byte_to_ascii
.8cfb		20 a3 a0	jsr $a0a3	                jsr xt_space
.8cfe		20 a3 a0	jsr $a0a3	                jsr xt_space
.8d01						_loop:
.8d01		b5 00		lda $00,x	                lda 0,x
.8d03		15 01		ora $01,x	                ora 1,x
.8d05		f0 39		beq $8d40	                beq _all_printed
.8d07		a1 02		lda ($02,x)	                lda (2,x)
.8d09		48		pha		                pha                     ; byte_to_ascii destroys A
.8d0a		20 52 d7	jsr $d752	                jsr byte_to_ascii
.8d0d		20 a3 a0	jsr $a0a3	                jsr xt_space
.8d10		68		pla		                pla
.8d11		20 28 d8	jsr $d828	                jsr is_printable
.8d14		b0 02		bcs $8d18	                bcs _printable
.8d16		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d18						_printable:
.8d18		5a		phy		                phy                     ; save counter
.8d19		a4 26		ldy $26		                ldy tmp2
.8d1b		91 00		sta ($00),y	                sta (cp),y
.8d1d		e6 26		inc $26		                inc tmp2
.8d1f		7a		ply		                ply
.8d20		c0 09		cpy #$09	                cpy #9
.8d22		d0 03		bne $8d27	                bne _next_char
.8d24		20 a3 a0	jsr $a0a3	                jsr xt_space
.8d27						_next_char:
.8d27		f6 02		inc $02,x	                inc 2,x
.8d29		d0 02		bne $8d2d	                bne _counter
.8d2b		f6 03		inc $03,x	                inc 3,x
.8d2d						_counter:
.8d2d		b5 00		lda $00,x	                lda 0,x
.8d2f		d0 02		bne $8d33	                bne +
.8d31		d6 01		dec $01,x	                dec 1,x
.8d33						+
.8d33		d6 00		dec $00,x	                dec 0,x
.8d35		88		dey		                dey
.8d36		d0 c9		bne $8d01	                bne _loop               ; next byte
.8d38		20 a3 a0	jsr $a0a3	                jsr xt_space
.8d3b		20 4e 8d	jsr $8d4e	                jsr dump_print_ascii
.8d3e		80 aa		bra $8cea	                bra _row                ; new row
.8d40						_all_printed:
.8d40		a5 26		lda $26		                lda tmp2
.8d42		f0 06		beq $8d4a	                beq _done
.8d44		20 a3 a0	jsr $a0a3	                jsr xt_space
.8d47		20 4e 8d	jsr $8d4e	                jsr dump_print_ascii
.8d4a						_done:
.8d4a		20 35 a3	jsr $a335	                jsr xt_two_drop         ; one byte less than 4x INX
.8d4d		60		rts		z_dump:         rts
.8d4e						dump_print_ascii:
.8d4e		a0 00		ldy #$00	                ldy #0
.8d50						_ascii_loop:
.8d50		b1 00		lda ($00),y	                lda (cp),y
.8d52		20 a9 8d	jsr $8da9	                jsr emit_a
.8d55		c8		iny		                iny
.8d56		c0 08		cpy #$08	                cpy #8
.8d58		d0 03		bne $8d5d	                bne +
.8d5a		20 a3 a0	jsr $a0a3	                jsr xt_space
.8d5d						+
.8d5d		c6 26		dec $26		                dec tmp2
.8d5f		d0 ef		bne $8d50	                bne _ascii_loop
.8d61		60		rts		                rts
.8d62						xt_dup:
.8d62		20 42 d8	jsr $d842	                jsr underflow_1
.8d65		ca		dex		                dex
.8d66		ca		dex		                dex
.8d67		b5 02		lda $02,x	                lda 2,x         ; LSB
.8d69		95 00		sta $00,x	                sta 0,x
.8d6b		b5 03		lda $03,x	                lda 3,x         ; MSB
.8d6d		95 01		sta $01,x	                sta 1,x
.8d6f		60		rts		z_dup:          rts
.8d70						xt_ed:
.8d70		20 94 b5	jsr $b594	                jsr ed6502      ; kept in separate file
.8d73		60		rts		z_ed:           rts
.8d74						xt_else:
.8d74						xt_endof:
.8d74		a0 8d		ldy #$8d	                ldy #>branch_runtime
.8d76		a9 8e		lda #$8e	                lda #<branch_runtime
.8d78		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.8d7b		20 25 91	jsr $9125	                jsr xt_here
.8d7e		20 2d a7	jsr $a72d	                jsr xt_zero
.8d81		20 24 87	jsr $8724	                jsr xt_comma
.8d84		20 25 91	jsr $9125	                jsr xt_here
.8d87		20 0b 9b	jsr $9b0b	                jsr xt_rot
.8d8a		20 12 a1	jsr $a112	                jsr xt_store
.8d8d						z_else:
.8d8d						z_endof:
.8d8d		60		rts		                rts
.8d8e						branch_runtime:
.8d8e		68		pla		                pla
.8d8f		85 22		sta $22		                sta tmpbranch
.8d91		68		pla		                pla
.8d92		85 23		sta $23		                sta tmpbranch+1
.8d94		a0 01		ldy #$01	                ldy #1
.8d96		b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8d98		85 24		sta $24		                sta tmp1
.8d9a		c8		iny		                iny
.8d9b		b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8d9d		85 25		sta $25		                sta tmp1+1
.8d9f		6c 24 00	jmp ($0024)	                jmp (tmp1)
.8da2						xt_emit:
.8da2		20 42 d8	jsr $d842	                jsr underflow_1
.8da5		b5 00		lda $00,x	                lda 0,x
.8da7		e8		inx		                inx
.8da8		e8		inx		                inx
.8da9						emit_a:
.8da9		6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8dac						z_emit:
.8dac						xt_empty_buffers:
.8dac		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8dae		a9 00		lda #$00	                lda #0
.8db0		91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8db2						z_empty_buffers:
.8db2		60		rts		                rts
.8db3						xt_endcase:
.8db3		a0 8c		ldy #$8c	                ldy #>xt_drop
.8db5		a9 e1		lda #$e1	                lda #<xt_drop
.8db7		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.8dba						_endcase_loop:
.8dba		b5 00		lda $00,x	                lda 0,x
.8dbc		15 01		ora $01,x	                ora 1,x
.8dbe		f0 05		beq $8dc5	                beq _done
.8dc0		20 47 a1	jsr $a147	                jsr xt_then
.8dc3		80 f5		bra $8dba	                bra _endcase_loop
.8dc5						_done:
.8dc5		e8		inx		                inx
.8dc6		e8		inx		                inx
.8dc7		60		rts		z_endcase:      rts
.8dc8						xt_environment_q:
.8dc8		20 42 d8	jsr $d842	                jsr underflow_1
.8dcb		a0 00		ldy #$00	                ldy #00                 ; counter for table
.8dcd		5a		phy		                phy
.8dce						_table_loop:
.8dce		20 3d a3	jsr $a33d	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8dd1		ca		dex		                dex
.8dd2		ca		dex		                dex                     ; ( addr u addr u ? )
.8dd3		b9 45 8e	lda $8e45,y	                lda env_table_single,y
.8dd6		95 00		sta $00,x	                sta 0,x
.8dd8		c8		iny		                iny
.8dd9		b9 45 8e	lda $8e45,y	                lda env_table_single,y
.8ddc		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8dde		c8		iny		                iny
.8ddf		15 00		ora $00,x	                ora 0,x
.8de1		f0 4d		beq $8e30	                beq _table_done
.8de3		5a		phy		                phy                     ; save Y, which is used by COUNT
.8de4		20 16 89	jsr $8916	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8de7		20 3e 87	jsr $873e	                jsr xt_compare          ; ( addr u f )
.8dea		7a		ply		                ply
.8deb		b5 00		lda $00,x	                lda 0,x
.8ded		15 01		ora $01,x	                ora 1,x
.8def		f0 04		beq $8df5	                beq _got_result
.8df1		e8		inx		                inx                     ; DROP, now ( addr u )
.8df2		e8		inx		                inx
.8df3		80 d9		bra $8dce	                bra _table_loop
.8df5						_got_result:
.8df5		e8		inx		                inx                     ; drop flag, now ( addr u )
.8df6		e8		inx		                inx
.8df7		88		dey		                dey                     ; go back to index we had
.8df8		88		dey		                dey
.8df9		68		pla		                pla
.8dfa		d0 0d		bne $8e09	                bne _double_result
.8dfc		b9 63 8e	lda $8e63,y	                lda env_results_single,y
.8dff		95 02		sta $02,x	                sta 2,x
.8e01		c8		iny		                iny
.8e02		b9 63 8e	lda $8e63,y	                lda env_results_single,y
.8e05		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e07		80 1f		bra $8e28	                bra _set_flag
.8e09						_double_result:
.8e09		ca		dex		                dex                     ; ( addr u ? )
.8e0a		ca		dex		                dex
.8e0b		98		tya		                tya
.8e0c		38		sec		                sec
.8e0d		e9 18		sbc #$18	                sbc #24
.8e0f		0a		asl a		                asl
.8e10		a8		tay		                tay
.8e11		b9 79 8e	lda $8e79,y	                lda env_results_double,y
.8e14		95 02		sta $02,x	                sta 2,x
.8e16		c8		iny		                iny
.8e17		b9 79 8e	lda $8e79,y	                lda env_results_double,y
.8e1a		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e1c		c8		iny		                iny
.8e1d		b9 79 8e	lda $8e79,y	                lda env_results_double,y
.8e20		95 04		sta $04,x	                sta 4,x
.8e22		c8		iny		                iny
.8e23		b9 79 8e	lda $8e79,y	                lda env_results_double,y
.8e26		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e28						_set_flag:
.8e28		a9 ff		lda #$ff	                lda #$ff
.8e2a		95 00		sta $00,x	                sta 0,x
.8e2c		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e2e		80 14		bra $8e44	                bra _done
.8e30						_table_done:
.8e30		68		pla		                pla
.8e31		d0 09		bne $8e3c	                bne _no_match
.8e33		1a		inc a		                ina
.8e34		48		pha		                pha
.8e35		8a		txa		                txa
.8e36		18		clc		                clc
.8e37		69 06		adc #$06	                adc #6                  ; skip six bytes
.8e39		aa		tax		                tax                     ; ( addr u )
.8e3a		80 92		bra $8dce	                bra _table_loop
.8e3c						_no_match:
.8e3c		8a		txa		                txa
.8e3d		18		clc		                clc
.8e3e		69 0a		adc #$0a	                adc #10
.8e40		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e41		20 2c 8f	jsr $8f2c	                jsr xt_false
.8e44						_done:
.8e44						z_environment_q:
.8e44		60		rts		                rts
.8e45						env_table_single:
>8e45		65 d6 75 d6 7b d6 80 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e4d		92 d6
>8e4f		9a d6 a3 d6 a9 d6 af d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e57		c2 d6 ce d6 00 00		        .word envs_sc, envs_wl, 0000
.8e5d						env_table_double:
>8e5d		d8 d6 de d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8e63						env_results_single:
>8e63		ff 00				        .word $00FF     ; /COUNTED-STRING
>8e65		ff 00				        .word $00FF     ; /HOLD
>8e67		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8e69		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8e6b		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8e6d		ff 00				        .word $00FF     ; MAX-CHAR
>8e6f		ff 7f				        .word $7FFF     ; MAX-N
>8e71		ff ff				        .word $FFFF     ; MAX-U
>8e73		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8e75		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8e77		09 00				        .word $0009     ; WORDLISTS
.8e79						env_results_double:
>8e79		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8e7d		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8e81						xt_equal:
.8e81		20 47 d8	jsr $d847	                jsr underflow_2
.8e84		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8e86		d5 02		cmp $02,x	                cmp 2,x
.8e88		d0 0a		bne $8e94	                bne _false
.8e8a		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8e8c		d5 03		cmp $03,x	                cmp 3,x
.8e8e		d0 04		bne $8e94	                bne _false
.8e90		a9 ff		lda #$ff	                lda #$ff
.8e92		80 02		bra $8e96	                bra _done
.8e94		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8e96		95 02		sta $02,x	_done:          sta 2,x
.8e98		95 03		sta $03,x	                sta 3,x
.8e9a		e8		inx		                inx
.8e9b		e8		inx		                inx
.8e9c		60		rts		z_equal:        rts
.8e9d						xt_blank:
.8e9d		ca		dex		                dex
.8e9e		ca		dex		                dex
.8e9f		a9 20		lda #$20	                lda #AscSP
.8ea1		95 00		sta $00,x	                sta 0,x
.8ea3		74 01		stz $01,x	                stz 1,x
.8ea5		80 06		bra $8ead	                bra xt_fill     ; skip over code for ERASE
.8ea7						xt_erase:
.8ea7		ca		dex		                dex
.8ea8		ca		dex		                dex
.8ea9		74 00		stz $00,x	                stz 0,x
.8eab		74 01		stz $01,x	                stz 1,x
.8ead						xt_fill:
.8ead		20 4c d8	jsr $d84c	                jsr underflow_3
.8eb0		b5 04		lda $04,x	                lda 4,x         ; LSB
.8eb2		85 24		sta $24		                sta tmp1
.8eb4		b5 05		lda $05,x	                lda 5,x
.8eb6		85 25		sta $25		                sta tmp1+1
.8eb8		b5 02		lda $02,x	                lda 2,x
.8eba		85 26		sta $26		                sta tmp2
.8ebc		b5 03		lda $03,x	                lda 3,x
.8ebe		85 27		sta $27		                sta tmp2+1
.8ec0		b5 00		lda $00,x	                lda 0,x
.8ec2		a8		tay		                tay
.8ec3						_loop:
.8ec3		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8ec5		c5 25		cmp $25		                cmp tmp1+1
.8ec7		90 21		bcc $8eea	                bcc _done               ; RAM_END < TMP1, so leave
.8ec9		d0 06		bne $8ed1	                bne _check_counter      ; RAM_END is not smaller and not equal
.8ecb		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8ecd		c5 24		cmp $24		                cmp tmp1
.8ecf		90 19		bcc $8eea	                bcc _done               ; RAM_END < TMP1, so leave
.8ed1						_check_counter:
.8ed1		a5 26		lda $26		                lda tmp2
.8ed3		05 27		ora $27		                ora tmp2+1
.8ed5		f0 13		beq $8eea	                beq _done
.8ed7		98		tya		                tya
.8ed8		92 24		sta ($24)	                sta (tmp1)
.8eda		a5 26		lda $26		                lda tmp2
.8edc		d0 02		bne $8ee0	                bne +
.8ede		c6 27		dec $27		                dec tmp2+1
.8ee0		c6 26		dec $26		+               dec tmp2
.8ee2		e6 24		inc $24		                inc tmp1
.8ee4		d0 dd		bne $8ec3	                bne _loop
.8ee6		e6 25		inc $25		                inc tmp1+1
.8ee8		80 d9		bra $8ec3	                bra _loop
.8eea						_done:
.8eea		8a		txa		                txa
.8eeb		18		clc		                clc
.8eec		69 06		adc #$06	                adc #6
.8eee		aa		tax		                tax
.8eef						z_blank:
.8eef						z_erase:
.8eef		60		rts		z_fill:         rts
.8ef0						xt_execute:
.8ef0		20 42 d8	jsr $d842	                jsr underflow_1
.8ef3		20 f7 8e	jsr $8ef7	                jsr doexecute   ; do not combine to JMP (native coding)
.8ef6		60		rts		z_execute:      rts
.8ef7						doexecute:
.8ef7		b5 00		lda $00,x	                lda 0,x
.8ef9		85 0e		sta $0e		                sta ip
.8efb		b5 01		lda $01,x	                lda 1,x
.8efd		85 0f		sta $0f		                sta ip+1
.8eff		e8		inx		                inx
.8f00		e8		inx		                inx
.8f01		6c 0e 00	jmp ($000e)	                jmp (ip)
.8f04						xt_execute_parsing:
.8f04		20 4c d8	jsr $d84c	                jsr underflow_3
.8f07		20 13 92	jsr $9213	                jsr xt_input_to_r       ; save normal input for later
.8f0a		20 22 96	jsr $9622	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f0d		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f0f		85 0a		sta $0a		                sta ciblen
.8f11		b5 01		lda $01,x	                lda 1,x
.8f13		85 0b		sta $0b		                sta ciblen+1
.8f15		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f17		85 08		sta $08		                sta cib
.8f19		b5 03		lda $03,x	                lda 3,x
.8f1b		85 09		sta $09		                sta cib+1
.8f1d		64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f1f		64 0d		stz $0d		                stz toin+1
.8f21		20 35 a3	jsr $a335	                jsr xt_two_drop         ; 2DROP ( xt )
.8f24		20 f0 8e	jsr $8ef0	                jsr xt_execute
.8f27		20 57 9a	jsr $9a57	                jsr xt_r_to_input
.8f2a						z_execute_parsing:
.8f2a		60		rts		                rts
.8f2b						xt_exit:
.8f2b		60		rts		                rts             ; keep before z_exit
.8f2c						z_exit:
.8f2c						xt_false:
.8f2c		ca		dex		                dex
.8f2d		ca		dex		                dex
.8f2e		74 00		stz $00,x	                stz 0,x
.8f30		74 01		stz $01,x	                stz 1,x
.8f32		60		rts		z_false:        rts
.8f33						xt_fetch:
.8f33		20 42 d8	jsr $d842	                jsr underflow_1
.8f36		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f38		a8		tay		                tay
.8f39		f6 00		inc $00,x	                inc 0,x
.8f3b		d0 02		bne $8f3f	                bne +
.8f3d		f6 01		inc $01,x	                inc 1,x
.8f3f						+
.8f3f		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f41		95 01		sta $01,x	                sta 1,x
.8f43		94 00		sty $00,x	                sty 0,x
.8f45		60		rts		z_fetch:        rts
.8f46						xt_find:
.8f46		20 42 d8	jsr $d842	                jsr underflow_1
.8f49		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f4b		48		pha		                pha
.8f4c		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f4e		48		pha		                pha
.8f4f		20 16 89	jsr $8916	                jsr xt_count            ; ( caddr -- addr u )
.8f52		20 8e 8f	jsr $8f8e	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f55		b5 00		lda $00,x	                lda 0,x
.8f57		15 01		ora $01,x	                ora 1,x
.8f59		d0 0b		bne $8f66	                bne _found_word
.8f5b		20 2c 8f	jsr $8f2c	                jsr xt_false            ; ( 0 0 )
.8f5e		68		pla		                pla                     ; LSB of address
.8f5f		95 02		sta $02,x	                sta 2,x
.8f61		68		pla		                pla
.8f62		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8f64		80 27		bra $8f8d	                bra _done               ; ( addr 0 )
.8f66						_found_word:
.8f66		68		pla		                pla
.8f67		68		pla		                pla
.8f68		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.8f6b		20 95 95	jsr $9595	                jsr xt_name_to_int      ; ( nt xt )
.8f6e		20 33 a1	jsr $a133	                jsr xt_swap             ; ( xt nt )
.8f71		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8f73		f6 00		inc $00,x	                inc 0,x
.8f75		d0 02		bne $8f79	                bne +
.8f77		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8f79						+
.8f79		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8f7b		29 04		and #$04	                and #IM
.8f7d		d0 08		bne $8f87	                bne _immediate          ; bit set, we're immediate
.8f7f		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8f81		95 00		sta $00,x	                sta 0,x
.8f83		95 01		sta $01,x	                sta 1,x
.8f85		80 06		bra $8f8d	                bra _done
.8f87						_immediate:
.8f87		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8f89		95 00		sta $00,x	                sta 0,x
.8f8b		74 01		stz $01,x	                stz 1,x
.8f8d						_done:
.8f8d		60		rts		z_find:         rts
.8f8e						xt_find_name:
.8f8e		20 47 d8	jsr $d847	                jsr underflow_2
.8f91		b5 00		lda $00,x	                lda 0,x
.8f93		15 01		ora $01,x	                ora 1,x
.8f95		d0 03		bne $8f9a	                bne _nonempty
.8f97		4c 33 90	jmp $9033	                jmp _fail_done
.8f9a						_nonempty:
.8f9a		64 28		stz $28		                stz tmp3                ; Start at the beginning
.8f9c						_wordlist_loop:
.8f9c		a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8f9e		a5 28		lda $28		                lda tmp3
.8fa0		d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8fa2		d0 03		bne $8fa7	                bne _have_string
.8fa4		4c 33 90	jmp $9033	                jmp _fail_done
.8fa7						_have_string:
.8fa7		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8fa8		69 1f		adc #$1f	                adc #search_order_offset
.8faa		a8		tay		                tay
.8fab		b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.8fad		0a		asl a		                asl                     ; Turn offset into cells offset.
.8fae		18		clc		                clc
.8faf		69 06		adc #$06	                adc #wordlists_offset
.8fb1		a8		tay		                tay
.8fb2		b1 1e		lda ($1e),y	                lda (up),y
.8fb4		85 24		sta $24		                sta tmp1
.8fb6		c8		iny		                iny
.8fb7		b1 1e		lda ($1e),y	                lda (up),y
.8fb9		85 25		sta $25		                sta tmp1+1
.8fbb		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.8fbd		85 26		sta $26		                sta tmp2
.8fbf		b5 03		lda $03,x	                lda 3,x
.8fc1		85 27		sta $27		                sta tmp2+1
.8fc3						_loop:
.8fc3		b2 24		lda ($24)	                lda (tmp1)
.8fc5		d5 00		cmp $00,x	                cmp 0,x
.8fc7		d0 54		bne $901d	                bne _next_entry
.8fc9						_compare_string:
.8fc9		b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.8fcb		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.8fcd		b0 07		bcs $8fd6	                bcs _compare_first
.8fcf		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8fd1		90 03		bcc $8fd6	                bcc _compare_first
.8fd3		18		clc		                clc
.8fd4		69 20		adc #$20	                adc #$20
.8fd6						_compare_first:
.8fd6		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.8fd8		d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.8fda		d0 41		bne $901d	                bne _next_entry
.8fdc		b5 00		lda $00,x	                lda 0,x
.8fde		3a		dec a		                dea
.8fdf		f0 2c		beq $900d	                beq _success
.8fe1		a5 24		lda $24		                lda tmp1
.8fe3		48		pha		                pha             ; Preserve tmp1 on the return stack.
.8fe4		18		clc		                clc
.8fe5		69 08		adc #$08	                adc #8
.8fe7		85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.8fe9		a5 25		lda $25		                lda tmp1+1
.8feb		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.8fec		69 00		adc #$00	                adc #0          ; we only need the carry
.8fee		85 25		sta $25		                sta tmp1+1
.8ff0		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.8ff2		88		dey		                dey
.8ff3						_string_loop:
.8ff3		b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.8ff5		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8ff7		b0 07		bcs $9000	                bcs _check_char
.8ff9		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8ffb		90 03		bcc $9000	                bcc _check_char
.8ffd		18		clc		                clc
.8ffe		69 20		adc #$20	                adc #$20
.9000						_check_char:
.9000		d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9002		d0 13		bne $9017	                bne _next_entry_tmp1
.9004		88		dey		                dey
.9005		d0 ec		bne $8ff3	                bne _string_loop
.9007						_success_tmp1:
.9007		68		pla		                pla             ; Restore tmp1 from the return stack.
.9008		85 25		sta $25		                sta tmp1+1
.900a		68		pla		                pla
.900b		85 24		sta $24		                sta tmp1
.900d						_success:
.900d		a5 24		lda $24		                lda tmp1
.900f		95 02		sta $02,x	                sta 2,x
.9011		a5 25		lda $25		                lda tmp1+1
.9013		95 03		sta $03,x	                sta 3,x
.9015		80 20		bra $9037	                bra _done
.9017						_next_entry_tmp1:
.9017		68		pla		                pla             ; Restore tmp1 from the return stack.
.9018		85 25		sta $25		                sta tmp1+1
.901a		68		pla		                pla
.901b		85 24		sta $24		                sta tmp1
.901d						_next_entry:
.901d		a0 02		ldy #$02	                ldy #2
.901f		b1 24		lda ($24),y	                lda (tmp1),y
.9021		48		pha		                pha
.9022		c8		iny		                iny
.9023		b1 24		lda ($24),y	                lda (tmp1),y
.9025		85 25		sta $25		                sta tmp1+1
.9027		68		pla		                pla
.9028		85 24		sta $24		                sta tmp1
.902a		05 25		ora $25		                ora tmp1+1
.902c		d0 95		bne $8fc3	                bne _loop
.902e		e6 28		inc $28		                inc tmp3
.9030		4c 9c 8f	jmp $8f9c	                jmp _wordlist_loop
.9033						_fail_done:
.9033		74 02		stz $02,x	                stz 2,x         ; failure flag
.9035		74 03		stz $03,x	                stz 3,x
.9037						_done:
.9037		e8		inx		                inx
.9038		e8		inx		                inx
.9039		60		rts		z_find_name:    rts
.903a						xt_flush:
.903a		20 43 9e	jsr $9e43	                jsr xt_save_buffers
.903d		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.903f		a9 00		lda #$00	                lda #0
.9041		91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.9043						z_flush:
.9043		60		rts		                rts
.9044						xt_fm_slash_mod:
.9044		20 4c d8	jsr $d84c	                jsr underflow_3
.9047		64 26		stz $26		                stz tmp2        ; default: n is positive
.9049		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.904b		10 0e		bpl $905b	                bpl _check_d
.904d		e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.904f		20 d7 95	jsr $95d7	                jsr xt_negate   ; NEGATE
.9052		20 f5 a2	jsr $a2f5	                jsr xt_to_r     ; >R
.9055		20 08 8b	jsr $8b08	                jsr xt_dnegate  ; DNEGATE
.9058		20 46 9a	jsr $9a46	                jsr xt_r_from   ; R>
.905b						_check_d:
.905b		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.905d		10 0d		bpl $906c	                bpl _multiply
.905f		18		clc		                clc
.9060		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.9062		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.9064		95 02		sta $02,x	                sta 2,x
.9066		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9068		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.906a		95 03		sta $03,x	                sta 3,x
.906c						_multiply:
.906c		20 3f a5	jsr $a53f	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.906f		a5 26		lda $26		                lda tmp2
.9071		f0 07		beq $907a	                beq _done
.9073		e8		inx		                inx             ; pretend that we SWAP
.9074		e8		inx		                inx
.9075		20 d7 95	jsr $95d7	                jsr xt_negate
.9078		ca		dex		                dex
.9079		ca		dex		                dex
.907a						_done:
.907a		60		rts		z_fm_slash_mod: rts
.907b						xt_forth:
.907b		a0 1f		ldy #$1f	                ldy #search_order_offset
.907d		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.907f		91 1e		sta ($1e),y	                sta (up),y
.9081						z_forth:
.9081		60		rts		                rts
.9082						load_evaluate:
.9082		a9 ff		lda #$ff	                lda #$FF
.9084		85 24		sta $24		                sta tmp1
.9086		80 11		bra $9099	                bra load_evaluate_start
.9088						xt_evaluate:
.9088		20 47 d8	jsr $d847	                jsr underflow_2
.908b		64 24		stz $24		                stz tmp1
.908d		b5 00		lda $00,x	                lda 0,x
.908f		15 01		ora $01,x	                ora 1,x
.9091		d0 06		bne $9099	                bne evaluate_got_work
.9093		e8		inx		                inx
.9094		e8		inx		                inx
.9095		e8		inx		                inx
.9096		e8		inx		                inx
.9097		80 42		bra $90db	                bra evaluate_done
.9099						load_evaluate_start:
.9099						evaluate_got_work:
.9099		a0 01		ldy #$01	                ldy #blk_offset+1
.909b		b1 1e		lda ($1e),y	                lda (up),y
.909d		48		pha		                pha
.909e		88		dey		                dey
.909f		b1 1e		lda ($1e),y	                lda (up),y
.90a1		48		pha		                pha
.90a2		a5 24		lda $24		                lda tmp1
.90a4		d0 05		bne $90ab	                bne _nozero
.90a6		91 1e		sta ($1e),y	                sta (up),y
.90a8		c8		iny		                iny
.90a9		91 1e		sta ($1e),y	                sta (up),y
.90ab						_nozero:
.90ab		20 13 92	jsr $9213	                jsr xt_input_to_r
.90ae		a9 ff		lda #$ff	                lda #$ff
.90b0		85 06		sta $06		                sta insrc
.90b2		85 07		sta $07		                sta insrc+1
.90b4		64 0c		stz $0c		                stz toin
.90b6		64 0d		stz $0d		                stz toin+1
.90b8		b5 00		lda $00,x	                lda 0,x
.90ba		85 0a		sta $0a		                sta ciblen
.90bc		b5 01		lda $01,x	                lda 1,x
.90be		85 0b		sta $0b		                sta ciblen+1
.90c0		b5 02		lda $02,x	                lda 2,x
.90c2		85 08		sta $08		                sta cib
.90c4		b5 03		lda $03,x	                lda 3,x
.90c6		85 09		sta $09		                sta cib+1
.90c8		e8		inx		                inx             ; A clean stack is a clean mind
.90c9		e8		inx		                inx
.90ca		e8		inx		                inx
.90cb		e8		inx		                inx
.90cc		20 aa d7	jsr $d7aa	                jsr interpret   ; ( -- )
.90cf		20 57 9a	jsr $9a57	                jsr xt_r_to_input
.90d2		a0 00		ldy #$00	                ldy #blk_offset
.90d4		68		pla		                pla
.90d5		91 1e		sta ($1e),y	                sta (up),y
.90d7		c8		iny		                iny
.90d8		68		pla		                pla
.90d9		91 1e		sta ($1e),y	                sta (up),y
.90db						evaluate_done:
.90db		60		rts		z_evaluate:     rts
.90dc						xt_get_current:
.90dc		ca		dex		                dex
.90dd		ca		dex		                dex
.90de		a0 04		ldy #$04	                ldy #current_offset
.90e0		b1 1e		lda ($1e),y	                lda (up),y
.90e2		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.90e4		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.90e6		60		rts		z_get_current:  rts
.90e7						xt_get_order:
.90e7		a0 1e		ldy #$1e	                ldy #num_order_offset
.90e9		b1 1e		lda ($1e),y	                lda (up),y
.90eb		85 24		sta $24		                sta tmp1
.90ed		f0 16		beq $9105	                beq _done       ; If zero, there are no wordlists.
.90ef						_loop:
.90ef		c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.90f1		a9 1f		lda #$1f	                lda #search_order_offset
.90f3		18		clc		                clc
.90f4		65 24		adc $24		                adc tmp1
.90f6		a8		tay		                tay
.90f7		ca		dex		                dex
.90f8		ca		dex		                dex
.90f9		b1 1e		lda ($1e),y	                lda (up),y
.90fb		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.90fd		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.90ff		a9 00		lda #$00	                lda #0
.9101		c5 24		cmp $24		                cmp tmp1
.9103		d0 ea		bne $90ef	                bne _loop
.9105						_done:
.9105		ca		dex		                dex
.9106		ca		dex		                dex
.9107		a0 1e		ldy #$1e	                ldy #num_order_offset
.9109		b1 1e		lda ($1e),y	                lda (up),y
.910b		95 00		sta $00,x	                sta 0,x
.910d		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.910f		60		rts		z_get_order:    rts
.9110						xt_greater_than:
.9110		20 47 d8	jsr $d847	                jsr underflow_2
.9113		a0 00		ldy #$00	                ldy #0          ; default false
.9115		20 69 d7	jsr $d769	                jsr compare_16bit
.9118		f0 03		beq $911d	                beq _false
.911a		10 01		bpl $911d	                bpl _false
.911c		88		dey		                dey
.911d						_false:
.911d		98		tya		                tya
.911e		e8		inx		                inx
.911f		e8		inx		                inx
.9120		95 00		sta $00,x	                sta 0,x
.9122		95 01		sta $01,x	                sta 1,x
.9124		60		rts		z_greater_than: rts
.9125						xt_here:
.9125						xt_asm_arrow:
.9125		ca		dex		                dex
.9126		ca		dex		                dex
.9127		a5 00		lda $00		                lda cp
.9129		95 00		sta $00,x	                sta 0,x
.912b		a5 01		lda $01		                lda cp+1
.912d		95 01		sta $01,x	                sta 1,x
.912f						z_asm_arrow:
.912f		60		rts		z_here:         rts
.9130						xt_hex:
.9130		a9 10		lda #$10	                lda #16
.9132		85 18		sta $18		                sta base
.9134		64 19		stz $19		                stz base+1              ; paranoid
.9136		60		rts		z_hex:          rts
.9137						xt_hexstore:
.9137		20 4c d8	jsr $d84c	                jsr underflow_3
.913a		20 62 8d	jsr $8d62	                jsr xt_dup              ; Save copy of original address
.913d		20 27 a4	jsr $a427	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9140						_loop:
.9140		b5 00		lda $00,x	                lda 0,x
.9142		15 01		ora $01,x	                ora 1,x
.9144		f0 36		beq $917c	                beq _done
.9146		20 02 86	jsr $8602	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9149		20 27 a4	jsr $a427	                jsr xt_two_to_r
.914c		20 2d a7	jsr $a72d	                jsr xt_zero
.914f		20 2d a7	jsr $a72d	                jsr xt_zero
.9152		20 ad a3	jsr $a3ad	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9155		20 42 a2	jsr $a242	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9158		b5 00		lda $00,x	                lda 0,x
.915a		15 01		ora $01,x	                ora 1,x
.915c		d0 17		bne $9175	                bne _have_chars_left
.915e		20 35 a3	jsr $a335	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9161		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9164		20 31 9a	jsr $9a31	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9167		20 cb 85	jsr $85cb	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.916a		20 46 9a	jsr $9a46	                jsr xt_r_from           ; R>
.916d		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+
.9170		20 f5 a2	jsr $a2f5	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9173		80 cb		bra $9140	                bra _loop
.9175						_have_chars_left:
.9175		8a		txa		                txa
.9176		18		clc		                clc
.9177		69 08		adc #$08	                adc #8
.9179		aa		tax		                tax
.917a		80 c4		bra $9140	                bra _loop
.917c						_done:
.917c		e8		inx		                inx
.917d		e8		inx		                inx
.917e		e8		inx		                inx
.917f		e8		inx		                inx                     ; 2DROP
.9180		20 ad a3	jsr $a3ad	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9183		20 33 a1	jsr $a133	                jsr xt_swap
.9186		20 04 95	jsr $9504	                jsr xt_minus            ; ( n )
.9189		60		rts		z_hexstore:     rts
.918a						xt_hold:
.918a		20 42 d8	jsr $d842	                jsr underflow_1
.918d		a5 34		lda $34		                lda tohold
.918f		d0 02		bne $9193	                bne +
.9191		c6 35		dec $35		                dec tohold+1
.9193						+
.9193		c6 34		dec $34		                dec tohold
.9195		b5 00		lda $00,x	                lda 0,x
.9197		92 34		sta ($34)	                sta (tohold)
.9199		e8		inx		                inx
.919a		e8		inx		                inx
.919b		60		rts		z_hold:         rts
.919c						xt_i:
.919c		ca		dex		                dex
.919d		ca		dex		                dex
.919e		da		phx		                phx
.919f		ba		tsx		                tsx
.91a0		38		sec		                sec
.91a1		bd 02 01	lda $0102,x	                lda $0102,x     ; LSB
.91a4		fd 04 01	sbc $0104,x	                sbc $0104,x
.91a7		a8		tay		                tay
.91a8		bd 03 01	lda $0103,x	                lda $0103,x     ; MSB
.91ab		fd 05 01	sbc $0105,x	                sbc $0105,x
.91ae		fa		plx		                plx
.91af		95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.91b1		94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.91b3		60		rts		z_i:            rts
.91b4						xt_if:
.91b4		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.91b6		a9 c5		lda #$c5	                lda #<zero_branch_runtime
.91b8		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.91bb		20 25 91	jsr $9125	                jsr xt_here
.91be		20 2d a7	jsr $a72d	                jsr xt_zero
.91c1		20 24 87	jsr $8724	                jsr xt_comma
.91c4		60		rts		z_if:           rts
.91c5						zero_branch_runtime:
.91c5		68		pla		                pla
.91c6		85 22		sta $22		                sta tmpbranch
.91c8		68		pla		                pla
.91c9		85 23		sta $23		                sta tmpbranch+1
.91cb		b5 00		lda $00,x	                lda 0,x
.91cd		15 01		ora $01,x	                ora 1,x
.91cf		f0 0f		beq $91e0	                beq _zero
.91d1		a5 22		lda $22		                lda tmpbranch   ; LSB
.91d3		18		clc		                clc
.91d4		69 02		adc #$02	                adc #2
.91d6		85 24		sta $24		                sta tmp1
.91d8		a5 23		lda $23		                lda tmpbranch+1 ; MSB
.91da		69 00		adc #$00	                adc #0          ; For carry
.91dc		85 25		sta $25		                sta tmp1+1
.91de		80 13		bra $91f3	                bra _done
.91e0						_zero:
.91e0		a0 01		ldy #$01	                ldy #1
.91e2		b1 22		lda ($22),y	                lda (tmpbranch),y
.91e4		85 24		sta $24		                sta tmp1
.91e6		c8		iny		                iny
.91e7		b1 22		lda ($22),y	                lda (tmpbranch),y
.91e9		85 25		sta $25		                sta tmp1+1
.91eb		a5 24		lda $24		                lda tmp1
.91ed		d0 02		bne $91f1	                bne +
.91ef		c6 25		dec $25		                dec tmp1+1
.91f1						+
.91f1		c6 24		dec $24		                dec tmp1
.91f3						_done:
.91f3		a5 25		lda $25		                lda tmp1+1
.91f5		48		pha		                pha             ; MSB first
.91f6		a5 24		lda $24		                lda tmp1
.91f8		48		pha		                pha
.91f9		e8		inx		                inx
.91fa		e8		inx		                inx
.91fb		60		rts		                rts
.91fc						xt_immediate:
.91fc		20 84 d7	jsr $d784	                jsr current_to_dp
.91ff		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9201		b1 02		lda ($02),y	                lda (dp),y
.9203		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9205		91 02		sta ($02),y	                sta (dp),y
.9207		60		rts		z_immediate:    rts
.9208						xt_input:
.9208		ca		dex		                dex
.9209		ca		dex		                dex
.920a		a9 12		lda #$12	                lda #<input
.920c		95 00		sta $00,x	                sta 0,x
.920e		a9 00		lda #$00	                lda #>input
.9210		95 01		sta $01,x	                sta 1,x
.9212		60		rts		z_input:        rts
.9213						xt_input_to_r:
.9213		68		pla		                pla
.9214		85 24		sta $24		                sta tmp1
.9216		68		pla		                pla
.9217		85 25		sta $25		                sta tmp1+1
.9219		a0 07		ldy #$07	                ldy #7
.921b						_loop:
.921b		b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.921e		48		pha		                pha
.921f		88		dey		                dey
.9220		10 f9		bpl $921b	                bpl _loop
.9222		a5 25		lda $25		                lda tmp1+1
.9224		48		pha		                pha
.9225		a5 24		lda $24		                lda tmp1
.9227		48		pha		                pha
.9228		60		rts		z_input_to_r: 	rts
.9229						xt_int_to_name:
.9229		20 42 d8	jsr $d842	                jsr underflow_1
.922c		ca		dex		                dex
.922d		ca		dex		                dex
.922e		74 00		stz $00,x	                stz 0,x
.9230		74 01		stz $01,x	                stz 1,x
.9232						_wordlist_loop:
.9232		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9234		0a		asl a		                asl                     ; Turn offset into cells offset.
.9235		18		clc		                clc
.9236		69 06		adc #$06	                adc #wordlists_offset
.9238		a8		tay		                tay
.9239		b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.923b		85 26		sta $26		                sta tmp2                ; into tmp2
.923d		c8		iny		                iny
.923e		b1 1e		lda ($1e),y	                lda (up),y
.9240		85 27		sta $27		                sta tmp2+1
.9242		a5 26		lda $26		                lda tmp2
.9244		05 27		ora $27		                ora tmp2+1
.9246		f0 38		beq $9280	                beq _next_wordlist
.9248		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.924a		85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.924c		b5 03		lda $03,x	                lda 3,x
.924e		85 29		sta $29		                sta tmp3+1
.9250						_loop:
.9250		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9252		b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.9254		c5 28		cmp $28		                cmp tmp3
.9256		d0 07		bne $925f	                bne _no_match
.9258		c8		iny		                iny
.9259		b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.925b		c5 29		cmp $29		                cmp tmp3+1
.925d		f0 32		beq $9291	                beq _match
.925f						_no_match:
.925f		18		clc		                clc
.9260		a5 26		lda $26		                lda tmp2
.9262		69 02		adc #$02	                adc #2
.9264		85 26		sta $26		                sta tmp2
.9266		a5 27		lda $27		                lda tmp2+1
.9268		69 00		adc #$00	                adc #0          ; only care about carry
.926a		85 27		sta $27		                sta tmp2+1
.926c		a0 00		ldy #$00	                ldy #0
.926e		b1 26		lda ($26),y	                lda (tmp2),y
.9270		48		pha		                pha
.9271		c8		iny		                iny
.9272		11 26		ora ($26),y	                ora (tmp2),y
.9274		f0 09		beq $927f	                beq _zero
.9276		b1 26		lda ($26),y	                lda (tmp2),y
.9278		85 27		sta $27		                sta tmp2+1
.927a		68		pla		                pla
.927b		85 26		sta $26		                sta tmp2
.927d		80 d1		bra $9250	                bra _loop
.927f						_zero:
.927f		68		pla		                pla             ; Leftover from above loop
.9280						_next_wordlist:
.9280		b5 00		lda $00,x	                lda 0,x
.9282		1a		inc a		                ina
.9283		95 00		sta $00,x	                sta 0,x
.9285		c9 0c		cmp #$0c	                cmp #max_wordlists
.9287		d0 a9		bne $9232	                bne _wordlist_loop
.9289		e8		inx		                inx
.928a		e8		inx		                inx
.928b		74 00		stz $00,x	                stz 0,x
.928d		74 01		stz $01,x	                stz 1,x
.928f		80 0a		bra $929b	                bra z_int_to_name
.9291						_match:
.9291		e8		inx		                inx
.9292		e8		inx		                inx
.9293		a5 26		lda $26		                lda tmp2
.9295		95 00		sta $00,x	                sta 0,x
.9297		a5 27		lda $27		                lda tmp2+1
.9299		95 01		sta $01,x	                sta 1,x
.929b		60		rts		z_int_to_name:  rts
.929c						xt_invert:
.929c		20 42 d8	jsr $d842	                jsr underflow_1
.929f		a9 ff		lda #$ff	                lda #$FF
.92a1		55 00		eor $00,x	                eor 0,x         ; LSB
.92a3		95 00		sta $00,x	                sta 0,x
.92a5		a9 ff		lda #$ff	                lda #$FF
.92a7		55 01		eor $01,x	                eor 1,x         ; MSB
.92a9		95 01		sta $01,x	                sta 1,x
.92ab		60		rts		z_invert:       rts
.92ac						xt_is:
.92ac		a5 16		lda $16		                lda state
.92ae		05 17		ora $17		                ora state+1
.92b0		f0 0c		beq $92be	                beq _interpreting
.92b2						_compiling:
.92b2		20 54 85	jsr $8554	                jsr xt_bracket_tick
.92b5		a0 8a		ldy #$8a	                ldy #>xt_defer_store
.92b7		a9 ad		lda #$ad	                lda #<xt_defer_store
.92b9		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.92bc		80 06		bra $92c4	                bra _done
.92be						_interpreting:
.92be		20 96 a1	jsr $a196	                jsr xt_tick
.92c1		20 ad 8a	jsr $8aad	                jsr xt_defer_store
.92c4						_done:
.92c4		60		rts		z_is:           rts
.92c5						xt_j:
.92c5		ca		dex		                dex
.92c6		ca		dex		                dex
.92c7		86 2a		stx $2a		                stx tmpdsp
.92c9		ba		tsx		                tsx
.92ca		38		sec		                sec
.92cb		bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.92ce		fd 09 01	sbc $0109,x	                sbc $0109,x
.92d1		a8		tay		                tay
.92d2		bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.92d5		fd 0a 01	sbc $010a,x	                sbc $010A,x
.92d8		a6 2a		ldx $2a		                ldx tmpdsp
.92da		95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.92dc		94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.92de		60		rts		z_j:            rts
.92df						xt_key:
.92df		20 e9 92	jsr $92e9	                jsr key_a               ; returns char in A
.92e2		ca		dex		                dex
.92e3		ca		dex		                dex
.92e4		95 00		sta $00,x	                sta 0,x
.92e6		74 01		stz $01,x	                stz 1,x
.92e8		60		rts		z_key:          rts
.92e9						key_a:
.92e9		6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.92ec						xt_latestnt:
.92ec		ca		dex		                dex
.92ed		ca		dex		                dex
.92ee		20 84 d7	jsr $d784	                jsr current_to_dp
.92f1		a5 02		lda $02		                lda dp
.92f3		95 00		sta $00,x	                sta 0,x
.92f5		a5 03		lda $03		                lda dp+1
.92f7		95 01		sta $01,x	                sta 1,x
.92f9		60		rts		z_latestnt:     rts
.92fa						xt_latestxt:
.92fa		20 ec 92	jsr $92ec	                jsr xt_latestnt         ; ( nt )
.92fd		20 95 95	jsr $9595	                jsr xt_name_to_int      ; ( xt )
.9300		60		rts		z_latestxt:     rts
.9301						xt_leave:
.9301		68		pla		                pla
.9302		68		pla		                pla
.9303		68		pla		                pla
.9304		68		pla		                pla
.9305		60		rts		                rts             ; this must be compiled, so keep before z_leave
.9306						z_leave:
.9306						xt_left_bracket:
.9306		64 16		stz $16		                stz state
.9308		64 17		stz $17		                stz state+1
.930a		60		rts		z_left_bracket: rts
.930b						xt_less_number_sign:
.930b		20 55 98	jsr $9855	                jsr xt_pad      ; ( addr )
.930e		b5 00		lda $00,x	                lda 0,x
.9310		85 34		sta $34		                sta tohold
.9312		b5 01		lda $01,x	                lda 1,x
.9314		85 35		sta $35		                sta tohold+1
.9316		e8		inx		                inx
.9317		e8		inx		                inx
.9318						z_less_number_sign:
.9318		60		rts		                rts
.9319						xt_less_than:
.9319		20 47 d8	jsr $d847	                jsr underflow_2
.931c		a0 00		ldy #$00	                ldy #0          ; default false
.931e		20 69 d7	jsr $d769	                jsr compare_16bit
.9321		f0 03		beq $9326	                beq _false
.9323		30 01		bmi $9326	                bmi _false
.9325		88		dey		                dey
.9326						_false:
.9326		98		tya		                tya
.9327		e8		inx		                inx
.9328		e8		inx		                inx
.9329		95 00		sta $00,x	                sta 0,x
.932b		95 01		sta $01,x	                sta 1,x
.932d		60		rts		z_less_than:    rts
.932e						xt_list:
.932e		20 42 d8	jsr $d842	                jsr underflow_1
.9331		20 5e 9e	jsr $9e5e	                jsr xt_scr
.9334		20 12 a1	jsr $a112	                jsr xt_store
.9337		20 c7 a7	jsr $a7c7	                jsr xt_editor_l
.933a		60		rts		z_list:         rts
.933b						xt_literal:
.933b		20 42 d8	jsr $d842	                jsr underflow_1
.933e		a0 93		ldy #$93	                ldy #>literal_runtime
.9340		a9 49		lda #$49	                lda #<literal_runtime
.9342		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.9345		20 24 87	jsr $8724	                jsr xt_comma
.9348		60		rts		z_literal:      rts
.9349						literal_runtime:
.9349		ca		dex		                dex
.934a		ca		dex		                dex
.934b		68		pla		                pla             ; LSB
.934c		85 24		sta $24		                sta tmp1
.934e		68		pla		                pla             ; MSB
.934f		85 25		sta $25		                sta tmp1+1
.9351		a0 01		ldy #$01	                ldy #1
.9353		b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.9355		95 00		sta $00,x	                sta 0,x
.9357		c8		iny		                iny
.9358		b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.935a		95 01		sta $01,x	                sta 1,x
.935c		98		tya		                tya
.935d		18		clc		                clc
.935e		65 24		adc $24		                adc tmp1
.9360		a8		tay		                tay
.9361		a5 25		lda $25		                lda tmp1+1
.9363		69 00		adc #$00	                adc #0
.9365		48		pha		                pha
.9366		5a		phy		                phy
.9367		60		rts		                rts
.9368						xt_load:
.9368		20 42 d8	jsr $d842	                jsr underflow_1
.936b		a0 01		ldy #$01	                ldy #blk_offset+1
.936d		b1 1e		lda ($1e),y	                lda (up),y
.936f		48		pha		                pha
.9370		88		dey		                dey
.9371		b1 1e		lda ($1e),y	                lda (up),y
.9373		48		pha		                pha
.9374		b5 00		lda $00,x	                lda 0,x
.9376		91 1e		sta ($1e),y	                sta (up),y
.9378		c8		iny		                iny
.9379		b5 01		lda $01,x	                lda 1,x
.937b		91 1e		sta ($1e),y	                sta (up),y
.937d		20 77 83	jsr $8377	                jsr xt_block
.9380		ca		dex		                dex
.9381		ca		dex		                dex
.9382		a9 04		lda #$04	                lda #4
.9384		95 01		sta $01,x	                sta 1,x
.9386		74 00		stz $00,x	                stz 0,x
.9388		20 82 90	jsr $9082	                jsr load_evaluate
.938b		a0 00		ldy #$00	                ldy #blk_offset
.938d		68		pla		                pla
.938e		91 1e		sta ($1e),y	                sta (up),y
.9390		c8		iny		                iny
.9391		68		pla		                pla
.9392		91 1e		sta ($1e),y	                sta (up),y
.9394		88		dey		                dey
.9395		11 1e		ora ($1e),y	                ora (up),y
.9397		f0 12		beq $93ab	                beq _done
.9399		ca		dex		                dex
.939a		ca		dex		                dex
.939b		a0 00		ldy #$00	                ldy #blk_offset
.939d		b1 1e		lda ($1e),y	                lda (up),y
.939f		95 00		sta $00,x	                sta 0,x
.93a1		c8		iny		                iny
.93a2		b1 1e		lda ($1e),y	                lda (up),y
.93a4		95 01		sta $01,x	                sta 1,x
.93a6		20 77 83	jsr $8377	                jsr xt_block
.93a9		e8		inx		                inx
.93aa		e8		inx		                inx
.93ab						_done:
.93ab		60		rts		z_load:         rts
.93ac						xt_loop:
.93ac		ca		dex		                dex
.93ad		ca		dex		                dex
.93ae		a0 0e		ldy #$0e	                ldy #loop_runtime_end-loop_runtime
.93b0		a9 20		lda #$20	                lda #<loop_runtime
.93b2		95 00		sta $00,x	                sta 0,x
.93b4		a9 94		lda #$94	                lda #>loop_runtime
.93b6		95 01		sta $01,x	                sta 1,x
.93b8		20 8d 88	jsr $888d	                jsr cmpl_inline_y
.93bb		80 0f		bra $93cc	                bra xt_loop_common
.93bd						xt_plus_loop:
.93bd		ca		dex		                dex
.93be		ca		dex		                dex
.93bf		a0 10		ldy #$10	                ldy #plus_loop_runtime_end-plus_loop_runtime
.93c1		a9 10		lda #$10	                lda #<plus_loop_runtime
.93c3		95 00		sta $00,x	                sta 0,x
.93c5		a9 94		lda #$94	                lda #>plus_loop_runtime
.93c7		95 01		sta $01,x	                sta 1,x
.93c9		20 8d 88	jsr $888d	                jsr cmpl_inline_y
.93cc						xt_loop_common:
.93cc		20 24 87	jsr $8724	                jsr xt_comma
.93cf		a9 68		lda #$68	                lda #$68                ; opcode for PLA
.93d1		a0 06		ldy #$06	                ldy #6
.93d3						-
.93d3		91 00		sta ($00),y	                sta (cp),y
.93d5		88		dey		                dey
.93d6		10 fb		bpl $93d3	                bpl -
.93d8		a9 06		lda #$06	                lda #6
.93da		18		clc		                clc
.93db		65 00		adc $00		                adc cp
.93dd		85 00		sta $00		                sta cp
.93df		a5 01		lda $01		                lda cp+1
.93e1		69 00		adc #$00	                adc #0                  ; only need carry
.93e3		85 01		sta $01		                sta cp+1
.93e5		b5 00		lda $00,x	                lda 0,x
.93e7		85 24		sta $24		                sta tmp1
.93e9		b5 01		lda $01,x	                lda 1,x
.93eb		85 25		sta $25		                sta tmp1+1
.93ed		e8		inx		                inx
.93ee		e8		inx		                inx
.93ef		a5 00		lda $00		                lda cp
.93f1		38		sec		                sec
.93f2		e9 01		sbc #$01	                sbc #1
.93f4		48		pha		                pha             ; lsb
.93f5		a5 01		lda $01		                lda cp+1
.93f7		e9 00		sbc #$00	                sbc #0
.93f9		48		pha		                pha             ; msb
.93fa		a0 00		ldy #$00	                ldy #0
.93fc						-
.93fc		b9 0a 94	lda $940a,y	                lda loop_epilogue,y
.93ff		d0 01		bne $9402	                bne +
.9401		68		pla		                pla
.9402						+
.9402		91 24		sta ($24),y	                sta (tmp1),y
.9404		c8		iny		                iny
.9405		c0 06		cpy #$06	                cpy #(loop_epilogue_end-loop_epilogue)
.9407		d0 f3		bne $93fc	                bne -
.9409						z_loop:
.9409		60		rts		z_plus_loop:    rts
.940a						loop_epilogue:
.940a		a9 00		lda #$00	                lda #0
.940c		48		pha		                pha
.940d		a9 00		lda #$00	                lda #0
.940f		48		pha		                pha
.9410						loop_epilogue_end:
.9410						plus_loop_runtime:
.9410		18		clc		                clc
.9411		68		pla		                pla             ; LSB of index
.9412		75 00		adc $00,x	                adc 0,x         ; LSB of step
.9414		a8		tay		                tay             ; temporary storage of LSB
.9415		b8		clv		                clv
.9416		68		pla		                pla             ; MSB of index
.9417		75 01		adc $01,x	                adc 1,x         ; MSB of step
.9419		48		pha		                pha             ; put MSB of index back on stack
.941a		5a		phy		                phy             ; put LSB of index back on stack
.941b		e8		inx		                inx             ; dump step from TOS
.941c		e8		inx		                inx
.941d		70 03		bvs $9422	                bvs _hack+3     ; skip over JMP instruction
.941f						_hack:
>941f		4c				                .byte $4C
.9420						plus_loop_runtime_end:
.9420						loop_runtime:
.9420		b8		clv		                clv             ; note inc doesn't affect V
.9421		7a		ply		                ply             ; LSB of index
.9422		c8		iny		                iny             ; add one
.9423		d0 05		bne $942a	                bne _skip_msb   ; definitely not done
.9425		68		pla		                pla             ; MSB of index
.9426		18		clc		                clc
.9427		69 01		adc #$01	                adc #1          ; use adc to get V flag
.9429		48		pha		                pha             ; put MSB of index back on stack
.942a		5a		phy		_skip_msb:      phy             ; put LSB of index back on stack
.942b		70 03		bvs $9430	                bvs _hack+3     ; skip over JMP instruction
.942d						_hack:
>942d		4c				                .byte $4C
.942e						loop_runtime_end:
.942e						xt_lshift:
.942e		20 47 d8	jsr $d847	                jsr underflow_2
.9431		b5 00		lda $00,x	                lda 0,x
.9433		29 0f		and #$0f	                and #%00001111
.9435		f0 08		beq $943f	                beq _done
.9437		a8		tay		                tay
.9438						_loop:
.9438		16 02		asl $02,x	                asl 2,x
.943a		36 03		rol $03,x	                rol 3,x
.943c		88		dey		                dey
.943d		d0 f9		bne $9438	                bne _loop
.943f						_done:
.943f		e8		inx		                inx
.9440		e8		inx		                inx
.9441		60		rts		z_lshift:       rts
.9442						xt_m_star:
.9442		20 47 d8	jsr $d847	                jsr underflow_2
.9445		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9447		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.9449		48		pha		                pha
.944a		20 cd 80	jsr $80cd	                jsr xt_abs
.944d		20 33 a1	jsr $a133	                jsr xt_swap
.9450		20 cd 80	jsr $80cd	                jsr xt_abs
.9453		20 81 a5	jsr $a581	                jsr xt_um_star          ; ( d )
.9456		68		pla		                pla
.9457		10 03		bpl $945c	                bpl _done
.9459		20 08 8b	jsr $8b08	                jsr xt_dnegate
.945c						_done:
.945c		60		rts		z_m_star:       rts
.945d						xt_marker:
.945d		20 84 d7	jsr $d784	                jsr current_to_dp
.9460		a5 02		lda $02		                lda dp
.9462		48		pha		                pha
.9463		a5 03		lda $03		                lda dp+1
.9465		48		pha		                pha
.9466		a5 00		lda $00		                lda cp
.9468		48		pha		                pha
.9469		a5 01		lda $01		                lda cp+1
.946b		48		pha		                pha
.946c		20 30 89	jsr $8930	                jsr xt_create
.946f		a5 00		lda $00		                lda cp          ; LSB
.9471		38		sec		                sec
.9472		e9 02		sbc #$02	                sbc #2
.9474		85 00		sta $00		                sta cp
.9476		a5 01		lda $01		                lda cp+1        ; MSB
.9478		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.947a		85 01		sta $01		                sta cp+1
.947c		a0 94		ldy #$94	                ldy #>marker_runtime
.947e		a9 9b		lda #$9b	                lda #<marker_runtime
.9480		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.9483		7a		ply		                ply                     ; MSB
.9484		68		pla		                pla                     ; LSB
.9485		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.9488		7a		ply		                ply                     ; MSB
.9489		68		pla		                pla                     ; LSB
.948a		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.948d		a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.948f						_marker_loop:
.948f		b1 1e		lda ($1e),y	                lda (up),y
.9491		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9494		c8		iny		                iny
.9495		98		tya		                tya
.9496		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.9498		d0 f5		bne $948f	                bne _marker_loop
.949a		60		rts		z_marker:       rts
.949b						marker_runtime:
.949b		68		pla		                pla
.949c		85 24		sta $24		                sta tmp1        ; LSB of address
.949e		68		pla		                pla
.949f		85 25		sta $25		                sta tmp1+1      ; MSB of address
.94a1		e6 24		inc $24		                inc tmp1
.94a3		d0 02		bne $94a7	                bne +
.94a5		e6 25		inc $25		                inc tmp1+1
.94a7						+
.94a7		a0 00		ldy #$00	                ldy #0
.94a9		b1 24		lda ($24),y	                lda (tmp1),y
.94ab		85 00		sta $00		                sta cp
.94ad		c8		iny		                iny
.94ae		b1 24		lda ($24),y	                lda (tmp1),y
.94b0		85 01		sta $01		                sta cp+1
.94b2		c8		iny		                iny
.94b3		b1 24		lda ($24),y	                lda (tmp1),y
.94b5		85 02		sta $02		                sta dp
.94b7		c8		iny		                iny
.94b8		b1 24		lda ($24),y	                lda (tmp1),y
.94ba		85 03		sta $03		                sta dp+1
.94bc		a0 04		ldy #$04	                ldy #4
.94be						_marker_restore_loop:
.94be		b1 24		lda ($24),y	                lda (tmp1), y
.94c0		91 1e		sta ($1e),y	                sta (up), y
.94c2		c8		iny		                iny
.94c3		98		tya		                tya
.94c4		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94c6		d0 f6		bne $94be	                bne _marker_restore_loop
.94c8		20 97 d7	jsr $d797	                jsr dp_to_current       ; Move the CURRENT DP back.
.94cb		60		rts		                rts
.94cc						xt_max:
.94cc		20 47 d8	jsr $d847	                jsr underflow_2
.94cf		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.94d1		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.94d3		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.94d5		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.94d7		50 02		bvc $94db	                bvc _no_overflow
.94d9		49 80		eor #$80	                eor #$80        ; complement negative flag
.94db						_no_overflow:
.94db		30 08		bmi $94e5	                bmi _keep_nos
.94dd		b5 00		lda $00,x	                lda 0,x
.94df		95 02		sta $02,x	                sta 2,x
.94e1		b5 01		lda $01,x	                lda 1,x
.94e3		95 03		sta $03,x	                sta 3,x
.94e5						_keep_nos:
.94e5		e8		inx		                inx
.94e6		e8		inx		                inx
.94e7		60		rts		z_max:          rts
.94e8						xt_min:
.94e8		20 47 d8	jsr $d847	                jsr underflow_2
.94eb		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.94ed		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.94ef		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.94f1		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.94f3		50 02		bvc $94f7	                bvc _no_overflow
.94f5		49 80		eor #$80	                eor #$80
.94f7						_no_overflow:
.94f7		10 08		bpl $9501	                bpl _keep_nos
.94f9		b5 00		lda $00,x	                lda 0,x
.94fb		95 02		sta $02,x	                sta 2,x
.94fd		b5 01		lda $01,x	                lda 1,x
.94ff		95 03		sta $03,x	                sta 3,x
.9501						_keep_nos:
.9501		e8		inx		                inx
.9502		e8		inx		                inx
.9503		60		rts		z_min:          rts
.9504						xt_minus:
.9504		20 47 d8	jsr $d847	                jsr underflow_2
.9507		38		sec		                sec
.9508		b5 02		lda $02,x	                lda 2,x         ; LSB
.950a		f5 00		sbc $00,x	                sbc 0,x
.950c		95 02		sta $02,x	                sta 2,x
.950e		b5 03		lda $03,x	                lda 3,x         ; MSB
.9510		f5 01		sbc $01,x	                sbc 1,x
.9512		95 03		sta $03,x	                sta 3,x
.9514		e8		inx		                inx
.9515		e8		inx		                inx
.9516		60		rts		z_minus:        rts
.9517						xt_minus_leading:
.9517		20 47 d8	jsr $d847	                jsr underflow_2
.951a						_loop:
.951a		b5 00		lda $00,x	                lda 0,x
.951c		15 01		ora $01,x	                ora 1,x
.951e		f0 0f		beq $952f	                beq _done
.9520		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.9522		20 35 d8	jsr $d835	                jsr is_whitespace
.9525		90 08		bcc $952f	                bcc _done
.9527		20 bc 97	jsr $97bc	                jsr xt_one              ; ( addr u 1 )
.952a		20 9e 9f	jsr $9f9e	                jsr xt_slash_string     ; ( addr+ u-1 )
.952d		80 eb		bra $951a	                bra _loop
.952f						_done:
.952f						z_minus_leading:
.952f		60		rts		                rts
.9530						xt_minus_trailing:
.9530		20 47 d8	jsr $d847	                jsr underflow_2
.9533		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.9535		15 01		ora $01,x	                ora 1,x         ; MSB of n
.9537		f0 33		beq $956c	                beq _done
.9539		18		clc		                clc
.953a		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.953c		75 00		adc $00,x	                adc 0,x
.953e		85 24		sta $24		                sta tmp1
.9540		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.9542		75 01		adc $01,x	                adc 1,x
.9544		85 25		sta $25		                sta tmp1+1
.9546		a5 24		lda $24		                lda tmp1
.9548		d0 02		bne $954c	                bne +
.954a		c6 25		dec $25		                dec tmp1+1
.954c						+
.954c		c6 24		dec $24		                dec tmp1
.954e						_loop:
.954e		b2 24		lda ($24)	                lda (tmp1)
.9550		c9 20		cmp #$20	                cmp #AscSP
.9552		d0 18		bne $956c	                bne _done
.9554		a5 24		lda $24		                lda tmp1
.9556		d0 02		bne $955a	                bne +
.9558		c6 25		dec $25		                dec tmp1+1
.955a						+
.955a		c6 24		dec $24		                dec tmp1
.955c		b5 00		lda $00,x	                lda 0,x
.955e		d0 02		bne $9562	                bne +
.9560		d6 01		dec $01,x	                dec 1,x
.9562						+
.9562		d6 00		dec $00,x	                dec 0,x
.9564		b5 00		lda $00,x	                lda 0,x
.9566		15 01		ora $01,x	                ora 1,x
.9568		f0 02		beq $956c	                beq _done       ; Count has reached zero - we're done!
.956a		80 e2		bra $954e	                bra _loop
.956c						_done:
.956c						z_minus_trailing:
.956c		60		rts		                rts
.956d						xt_mod:
.956d		20 47 d8	jsr $d847	                jsr underflow_2
.9570		20 86 9f	jsr $9f86	                jsr xt_slash_mod
.9573		e8		inx		                inx             ; DROP
.9574		e8		inx		                inx
.9575						z_mod:
.9575		60		rts		                rts
.9576						xt_move:
.9576		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.9578		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.957a		f0 05		beq $9581	                beq _lsb                ; wasn't helpful, move to LSB
.957c		b0 0e		bcs $958c	                bcs _to_move_up         ; we want CMOVE>
.957e		4c 4f 86	jmp $864f	                jmp xt_cmove            ; JSR/RTS
.9581						_lsb:
.9581		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.9583		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.9585		f0 08		beq $958f	                beq _equal              ; LSB is equal as well
.9587		b0 03		bcs $958c	                bcs _to_move_up         ; we want CMOVE>
.9589		4c 4f 86	jmp $864f	                jmp xt_cmove            ; JSR/RTS
.958c						_to_move_up:
.958c		4c 8a 86	jmp $868a	                jmp xt_cmove_up         ; JSR/RTS
.958f						_equal:
.958f		8a		txa		                txa
.9590		18		clc		                clc
.9591		69 06		adc #$06	                adc #6
.9593		aa		tax		                tax
.9594		60		rts		z_move:         rts
.9595						xt_name_to_int:
.9595		20 42 d8	jsr $d842	                jsr underflow_1
.9598		b5 00		lda $00,x	                lda 0,x
.959a		18		clc		                clc
.959b		69 04		adc #$04	                adc #4
.959d		85 28		sta $28		                sta tmp3
.959f		b5 01		lda $01,x	                lda 1,x
.95a1		90 01		bcc $95a4	                bcc _done
.95a3		1a		inc a		                ina
.95a4						_done:
.95a4		85 29		sta $29		                sta tmp3+1
.95a6		a0 00		ldy #$00	                ldy #0
.95a8		b1 28		lda ($28),y	                lda (tmp3),y
.95aa		95 00		sta $00,x	                sta 0,x
.95ac		c8		iny		                iny
.95ad		b1 28		lda ($28),y	                lda (tmp3),y
.95af		95 01		sta $01,x	                sta 1,x
.95b1		60		rts		z_name_to_int:  rts
.95b2						xt_name_to_string:
.95b2		20 42 d8	jsr $d842	                jsr underflow_1
.95b5		ca		dex		                dex
.95b6		ca		dex		                dex
.95b7		a1 02		lda ($02,x)	                lda (2,x)
.95b9		95 00		sta $00,x	                sta 0,x
.95bb		74 01		stz $01,x	                stz 1,x
.95bd		b5 02		lda $02,x	                lda 2,x         ; LSB
.95bf		18		clc		                clc
.95c0		69 08		adc #$08	                adc #8
.95c2		a8		tay		                tay
.95c3		b5 03		lda $03,x	                lda 3,x         ; MSB
.95c5		69 00		adc #$00	                adc #0          ; just need carry
.95c7		95 03		sta $03,x	                sta 3,x
.95c9		94 02		sty $02,x	                sty 2,x
.95cb						z_name_to_string:
.95cb		60		rts		                rts
.95cc						xt_nc_limit:
.95cc		ca		dex		                dex
.95cd		ca		dex		                dex
.95ce		a9 1a		lda #$1a	                lda #<nc_limit
.95d0		95 00		sta $00,x	                sta 0,x
.95d2		a9 00		lda #$00	                lda #>nc_limit
.95d4		95 01		sta $01,x	                sta 1,x
.95d6		60		rts		z_nc_limit:     rts
.95d7						xt_negate:
.95d7		20 42 d8	jsr $d842	                jsr underflow_1
.95da		a9 00		lda #$00	        	lda #0
.95dc		38		sec		                sec
.95dd		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.95df		95 00		sta $00,x	                sta 0,x
.95e1		a9 00		lda #$00	                lda #0
.95e3		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.95e5		95 01		sta $01,x	                sta 1,x
.95e7		60		rts		z_negate:       rts
.95e8						xt_never_native:
.95e8		20 84 d7	jsr $d784	                jsr current_to_dp
.95eb		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.95ed		b1 02		lda ($02),y	                lda (dp),y
.95ef		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.95f1		29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.95f3		91 02		sta ($02),y	                sta (dp),y
.95f5						z_never_native:
.95f5		60		rts		                rts
.95f6						xt_nip:
.95f6		20 47 d8	jsr $d847	                jsr underflow_2
.95f9		b5 00		lda $00,x	                lda 0,x         ; LSB
.95fb		95 02		sta $02,x	                sta 2,x
.95fd		b5 01		lda $01,x	                lda 1,x         ; MSB
.95ff		95 03		sta $03,x	                sta 3,x
.9601		e8		inx		                inx
.9602		e8		inx		                inx
.9603		60		rts		z_nip:          rts
.9604						xt_not_equals:
.9604		20 47 d8	jsr $d847	                jsr underflow_2
.9607		a0 00		ldy #$00	                ldy #0                  ; default is true
.9609		b5 00		lda $00,x	                lda 0,x                 ; LSB
.960b		d5 02		cmp $02,x	                cmp 2,x
.960d		d0 0a		bne $9619	                bne _not_equal
.960f		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9611		d5 03		cmp $03,x	                cmp 3,x
.9613		d0 04		bne $9619	                bne _not_equal
.9615		a9 ff		lda #$ff	                lda #$FF
.9617		80 01		bra $961a	                bra _done
.9619						_not_equal:
.9619		88		dey		                dey                     ; drop thru to done
.961a						_done:
.961a		98		tya		                tya
.961b		e8		inx		                inx
.961c		e8		inx		                inx
.961d		95 00		sta $00,x	                sta 0,x
.961f		95 01		sta $01,x	                sta 1,x
.9621		60		rts		z_not_equals:   rts
.9622						xt_not_rote:
.9622		20 4c d8	jsr $d84c	                jsr underflow_3
.9625		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9627		b5 03		lda $03,x	                lda 3,x
.9629		95 01		sta $01,x	                sta 1,x
.962b		b5 05		lda $05,x	                lda 5,x
.962d		95 03		sta $03,x	                sta 3,x
.962f		94 05		sty $05,x	                sty 5,x
.9631		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9633		b5 02		lda $02,x	                lda 2,x
.9635		95 00		sta $00,x	                sta 0,x
.9637		b5 04		lda $04,x	                lda 4,x
.9639		95 02		sta $02,x	                sta 2,x
.963b		94 04		sty $04,x	                sty 4,x
.963d		60		rts		z_not_rote:     rts
.963e						xt_number:
.963e		20 47 d8	jsr $d847	                jsr underflow_2
.9641		64 2a		stz $2a		                stz tmpdsp      ; flag for double
.9643		64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.9645		a5 18		lda $18		                lda base
.9647		48		pha		                pha
.9648		20 3d a3	jsr $a33d	                jsr xt_two_dup
.964b		a1 02		lda ($02,x)	                lda (2,x)
.964d						_check_dec:
.964d		c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.964f		d0 04		bne $9655	                bne _check_hex
.9651		a9 0a		lda #$0a	                lda #$0A
.9653		80 42		bra $9697	                bra _base_changed
.9655						_check_hex:
.9655		c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.9657		d0 04		bne $965d	                bne _check_binary
.9659		a9 10		lda #$10	                lda #$10
.965b		80 3a		bra $9697	                bra _base_changed
.965d						_check_binary:
.965d		c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.965f		d0 04		bne $9665	                bne _check_char
.9661		a9 02		lda #$02	                lda #$02
.9663		80 32		bra $9697	                bra _base_changed
.9665						_check_char:
.9665		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.9667		d0 3a		bne $96a3	                bne _check_minus
.9669		b5 00		lda $00,x	                lda 0,x         ; Get the length
.966b		c9 03		cmp #$03	                cmp #$03
.966d		d0 26		bne $9695	                bne _not_a_char
.966f		b5 01		lda $01,x	                lda 1,x
.9671		d0 22		bne $9695	                bne _not_a_char ; No compare needed to check for non-zero.
.9673		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9675		18		clc		                clc
.9676		69 02		adc #$02	                adc #2          ; length of string
.9678		85 2c		sta $2c		                sta tmptos
.967a		b5 03		lda $03,x	                lda 3,x
.967c		69 00		adc #$00	                adc #0          ; only need carry
.967e		85 2d		sta $2d		                sta tmptos+1
.9680		b2 2c		lda ($2c)	                lda (tmptos)
.9682		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.9684		d0 0f		bne $9695	                bne _not_a_char
.9686		f6 02		inc $02,x	                inc 2,x
.9688		d0 02		bne $968c	                bne +
.968a		f6 03		inc $03,x	                inc 3,x
.968c						+
.968c		a1 02		lda ($02,x)	                lda (2,x)
.968e		95 02		sta $02,x	                sta 2,x
.9690		74 03		stz $03,x	                stz 3,x
.9692		4c 13 97	jmp $9713	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9695						_not_a_char:
.9695		80 5a		bra $96f1	                bra _number_error
.9697						_base_changed:
.9697		85 18		sta $18		                sta base        ; Switch to the new base
.9699		f6 02		inc $02,x	                inc 2,x         ; start one character later
.969b		d0 02		bne $969f	                bne +
.969d		f6 03		inc $03,x	                inc 3,x
.969f						+
.969f		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96a1		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96a3						_check_minus:
.96a3		c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96a5		d0 0a		bne $96b1	                bne _check_dot
.96a7		c6 2b		dec $2b		                dec tmpdsp+1
.96a9		f6 02		inc $02,x	                inc 2,x         ; start one character later
.96ab		d0 02		bne $96af	                bne +
.96ad		f6 03		inc $03,x	                inc 3,x
.96af						+
.96af		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96b1						_check_dot:
.96b1		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96b3		18		clc		                clc
.96b4		75 00		adc $00,x	                adc 0,x         ; length of string
.96b6		85 2c		sta $2c		                sta tmptos
.96b8		b5 03		lda $03,x	                lda 3,x
.96ba		69 00		adc #$00	                adc #0          ; only need carry
.96bc		85 2d		sta $2d		                sta tmptos+1
.96be		a5 2c		lda $2c		                lda tmptos
.96c0		d0 02		bne $96c4	                bne +
.96c2		c6 2d		dec $2d		                dec tmptos+1
.96c4						+
.96c4		c6 2c		dec $2c		                dec tmptos
.96c6		b2 2c		lda ($2c)	                lda (tmptos)
.96c8		c9 2e		cmp #$2e	                cmp #'.'
.96ca		d0 04		bne $96d0	                bne _main
.96cc		c6 2a		dec $2a		                dec tmpdsp
.96ce		d6 00		dec $00,x	                dec 0,x
.96d0						_main:
.96d0		ca		dex		                dex
.96d1		ca		dex		                dex
.96d2		ca		dex		                dex
.96d3		ca		dex		                dex
.96d4		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.96d6		95 00		sta $00,x	                sta 0,x
.96d8		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.96da		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.96dc		95 02		sta $02,x	                sta 2,x
.96de		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.96e0		95 03		sta $03,x	                sta 3,x
.96e2		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.96e4		74 05		stz $05,x	                stz 5,x
.96e6		74 06		stz $06,x	                stz 6,x
.96e8		74 07		stz $07,x	                stz 7,x
.96ea		20 42 a2	jsr $a242	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.96ed		b5 00		lda $00,x	                lda 0,x
.96ef		f0 1e		beq $970f	                beq _all_converted
.96f1						_number_error:
.96f1		20 35 a3	jsr $a335	                jsr xt_two_drop ; >NUMBER modified addr u
.96f4		20 35 a3	jsr $a335	                jsr xt_two_drop ; ud   (partially converted number)
.96f7		a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.96f9		20 a9 8d	jsr $8da9	                jsr emit_a
.96fc		20 88 a4	jsr $a488	                jsr xt_type
.96ff		a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.9701		20 a9 8d	jsr $8da9	                jsr emit_a
.9704		20 a3 a0	jsr $a0a3	                jsr xt_space
.9707		68		pla		                pla
.9708		85 18		sta $18		                sta base
.970a		a9 08		lda #$08	                lda #err_syntax
.970c		4c 58 d8	jmp $d858	                jmp error
.970f						_all_converted:
.970f		e8		inx		                inx ; Drop the current addr u
.9710		e8		inx		                inx
.9711		e8		inx		                inx
.9712		e8		inx		                inx
.9713						_drop_original_string:
.9713		20 03 a4	jsr $a403	                jsr xt_two_swap  ; Drop the original addr u
.9716		20 35 a3	jsr $a335	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9719		a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.971b		f0 0d		beq $972a	                beq _single
.971d		a9 20		lda #$20	                lda #%00100000
.971f		04 20		tsb $20		                tsb status
.9721		a5 2b		lda $2b		                lda tmpdsp+1
.9723		f0 12		beq $9737	                beq _done       ; no minus, all done
.9725		20 08 8b	jsr $8b08	                jsr xt_dnegate
.9728		80 0d		bra $9737	                bra _done
.972a						_single:
.972a		e8		inx		                inx
.972b		e8		inx		                inx
.972c		a9 20		lda #$20	                lda #%00100000
.972e		14 20		trb $20		                trb status
.9730		a5 2b		lda $2b		                lda tmpdsp+1
.9732		f0 03		beq $9737	                beq _done       ; no minus, all done
.9734		20 d7 95	jsr $95d7	                jsr xt_negate
.9737						_done:
.9737		68		pla		                pla
.9738		85 18		sta $18		                sta base
.973a		60		rts		z_number:       rts
.973b						xt_number_sign:
.973b		20 47 d8	jsr $d847	                jsr underflow_2         ; double number
.973e		20 3d 83	jsr $833d	                jsr xt_base
.9741		20 33 8f	jsr $8f33	                jsr xt_fetch            ; ( ud1 base )
.9744		20 f5 a2	jsr $a2f5	                jsr xt_to_r             ; >r
.9747		20 2d a7	jsr $a72d	                jsr xt_zero             ; 0
.974a		20 31 9a	jsr $9a31	                jsr xt_r_fetch          ; r@
.974d		20 3f a5	jsr $a53f	                jsr xt_um_slash_mod     ; um/mod
.9750		20 0b 9b	jsr $9b0b	                jsr xt_rot              ; rot
.9753		20 0b 9b	jsr $9b0b	                jsr xt_rot              ; rot
.9756		20 46 9a	jsr $9a46	                jsr xt_r_from           ; r>
.9759		20 3f a5	jsr $a53f	                jsr xt_um_slash_mod     ; um/mod
.975c		20 0b 9b	jsr $9b0b	                jsr xt_rot              ; rot
.975f		20 0b 9b	jsr $9b0b	                jsr xt_rot              ; ( ud rem )
.9762		b5 00		lda $00,x	                lda 0,x
.9764		a8		tay		                tay
.9765		b9 0f d4	lda $d40f,y	                lda s_abc_upper,y
.9768		95 00		sta $00,x	                sta 0,x
.976a		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.976c		20 8a 91	jsr $918a	                jsr xt_hold
.976f						z_number_sign:
.976f		60		rts		                rts
.9770						xt_number_sign_greater:
.9770		20 47 d8	jsr $d847	                jsr underflow_2         ; double number
.9773		a5 34		lda $34		                lda tohold
.9775		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.9777		95 02		sta $02,x	                sta 2,x
.9779		a5 35		lda $35		                lda tohold+1
.977b		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.977d		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.977f		20 55 98	jsr $9855	                jsr xt_pad      ; ( addr addr pad )
.9782		38		sec		                sec
.9783		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.9785		f5 02		sbc $02,x	                sbc 2,x
.9787		95 02		sta $02,x	                sta 2,x
.9789		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.978b		f5 03		sbc $03,x	                sbc 3,x
.978d		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.978f		e8		inx		                inx
.9790		e8		inx		                inx
.9791						z_number_sign_greater:
.9791		60		rts		                rts
.9792						xt_number_sign_s:
.9792		20 47 d8	jsr $d847	                jsr underflow_2
.9795						_loop:
.9795		20 3b 97	jsr $973b	                jsr xt_number_sign
.9798		b5 00		lda $00,x	                lda 0,x
.979a		15 01		ora $01,x	                ora 1,x
.979c		15 02		ora $02,x	                ora 2,x
.979e		15 03		ora $03,x	                ora 3,x
.97a0		d0 f3		bne $9795	                bne _loop
.97a2						z_number_sign_s:
.97a2		60		rts		                rts
.97a3						xt_of:
.97a3		a0 98		ldy #$98	                ldy #>xt_over
.97a5		a9 47		lda #$47	                lda #<xt_over
.97a7		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.97aa		a0 8e		ldy #$8e	                ldy #>xt_equal
.97ac		a9 81		lda #$81	                lda #<xt_equal
.97ae		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.97b1		20 b4 91	jsr $91b4	                jsr xt_if
.97b4		a0 8c		ldy #$8c	                ldy #>xt_drop
.97b6		a9 e1		lda #$e1	                lda #<xt_drop
.97b8		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.97bb		60		rts		z_of:           rts
.97bc						xt_editor_wordlist:
.97bc						xt_one:
.97bc		ca		dex		                dex
.97bd		ca		dex		                dex
.97be		a9 01		lda #$01	                lda #1
.97c0		95 00		sta $00,x	                sta 0,x
.97c2		74 01		stz $01,x	                stz 1,x
.97c4						z_editor_wordlist:
.97c4						z_one:
.97c4		60		rts		                rts
.97c5						xt_one_minus:
.97c5		20 42 d8	jsr $d842	                jsr underflow_1
.97c8		b5 00		lda $00,x	                lda 0,x
.97ca		d0 02		bne $97ce	                bne +
.97cc		d6 01		dec $01,x	                dec 1,x
.97ce						+
.97ce		d6 00		dec $00,x	                dec 0,x
.97d0		60		rts		z_one_minus:    rts
.97d1						xt_char_plus:
.97d1						xt_one_plus:
.97d1		20 42 d8	jsr $d842	                jsr underflow_1
.97d4		f6 00		inc $00,x	                inc 0,x
.97d6		d0 02		bne $97da	                bne _done
.97d8		f6 01		inc $01,x	                inc 1,x
.97da						_done:
.97da						z_char_plus:
.97da		60		rts		z_one_plus:     rts
.97db						xt_only:
.97db		ca		dex		                dex
.97dc		ca		dex		                dex
.97dd		a9 ff		lda #$ff	                lda #$FF
.97df		95 00		sta $00,x	                sta 0,x
.97e1		95 01		sta $01,x	                sta 1,x
.97e3		20 cf 9c	jsr $9ccf	                jsr xt_set_order
.97e6		60		rts		z_only:         rts
.97e7						xt_or:
.97e7		20 47 d8	jsr $d847	                jsr underflow_2
.97ea		b5 00		lda $00,x	                lda 0,x
.97ec		15 02		ora $02,x	                ora 2,x
.97ee		95 02		sta $02,x	                sta 2,x
.97f0		b5 01		lda $01,x	                lda 1,x
.97f2		15 03		ora $03,x	                ora 3,x
.97f4		95 03		sta $03,x	                sta 3,x
.97f6		e8		inx		                inx
.97f7		e8		inx		                inx
.97f8		60		rts		z_or:           rts
.97f9						xt_order:
.97f9		20 2a 89	jsr $892a	                jsr xt_cr
.97fc		20 e7 90	jsr $90e7	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.97ff		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9801		f0 1e		beq $9821	                beq _drop_done
.9803						_have_wordlists:
.9803		a8		tay		                tay
.9804						_loop:
.9804		e8		inx		                inx
.9805		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.9806		b5 00		lda $00,x	                lda 0,x
.9808		5a		phy		                phy
.9809		20 24 98	jsr $9824	                jsr order_print_wid_string   ; internal helper function
.980c		7a		ply		                ply
.980d		88		dey		                dey
.980e		d0 f4		bne $9804	                bne _loop
.9810		20 a3 a0	jsr $a0a3	                jsr xt_space
.9813		20 a3 a0	jsr $a0a3	                jsr xt_space
.9816		20 dc 90	jsr $90dc	                jsr xt_get_current      ; ( wid )
.9819		b5 00		lda $00,x	                lda 0,x
.981b		20 24 98	jsr $9824	                jsr order_print_wid_string
.981e		20 2a 89	jsr $892a	                jsr xt_cr
.9821						_drop_done:
.9821		e8		inx		                inx
.9822		e8		inx		                inx
.9823						z_order:
.9823		60		rts		                rts
.9824						order_print_wid_string:
.9824		c9 04		cmp #$04	                cmp #4
.9826		90 09		bcc $9831	                bcc _output_string      ; less than 4, print a real string
.9828		ca		dex		                dex
.9829		ca		dex		                dex
.982a		95 00		sta $00,x	                sta 0,x
.982c		74 01		stz $01,x	                stz 1,x
.982e		4c b3 a4	jmp $a4b3	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.9831						_output_string:
.9831		a8		tay		                tay
.9832		b9 38 98	lda $9838,y	                lda _wid_data,y
.9835		4c 7e d8	jmp $d87e	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.9838						_wid_data:
>9838		04				        .byte str_wid_forth            ; WID 0: "Forth"
>9839		05				        .byte str_wid_editor           ; WID 1: "Editor"
>983a		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>983b		07				        .byte str_wid_root             ; WID 3: "Root"
.983c						xt_output:
.983c		ca		dex		                dex
.983d		ca		dex		                dex
.983e		a9 10		lda #$10	                lda #<output
.9840		95 00		sta $00,x	                sta 0,x
.9842		a9 00		lda #$00	                lda #>output
.9844		95 01		sta $01,x	                sta 1,x
.9846		60		rts		z_output:       rts
.9847						xt_over:
.9847		20 47 d8	jsr $d847	                jsr underflow_2
.984a		ca		dex		                dex
.984b		ca		dex		                dex
.984c		b5 04		lda $04,x	                lda 4,x         ; LSB
.984e		95 00		sta $00,x	                sta 0,x
.9850		b5 05		lda $05,x	                lda 5,x         ; MSB
.9852		95 01		sta $01,x	                sta 1,x
.9854		60		rts		z_over:         rts
.9855						xt_pad:
.9855		ca		dex		                dex
.9856		ca		dex		                dex
.9857		a5 00		lda $00		                lda cp
.9859		18		clc		                clc
.985a		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.985c		95 00		sta $00,x	                sta 0,x
.985e		a5 01		lda $01		                lda cp+1
.9860		69 00		adc #$00	                adc #0          ; only need carry
.9862		95 01		sta $01,x	                sta 1,x
.9864		60		rts		z_pad:          rts
.9865						xt_page:
.9865		a9 1b		lda #$1b	                lda #AscESC
.9867		20 a9 8d	jsr $8da9	                jsr emit_a
.986a		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.986c		20 a9 8d	jsr $8da9	                jsr emit_a
.986f		a9 32		lda #$32	                lda #'2'
.9871		20 a9 8d	jsr $8da9	                jsr emit_a
.9874		a9 4a		lda #$4a	                lda #'J'
.9876		20 a9 8d	jsr $8da9	                jsr emit_a
.9879		20 2d a7	jsr $a72d	                jsr xt_zero
.987c		20 2d a7	jsr $a72d	                jsr xt_zero
.987f		20 e4 82	jsr $82e4	                jsr xt_at_xy
.9882		60		rts		z_page:         rts
.9883						xt_paren:
.9883		ca		dex		                dex
.9884		ca		dex		                dex
.9885		a9 29		lda #$29	                lda #41     ; Right parenthesis
.9887		95 00		sta $00,x	                sta 0,x
.9889		74 01		stz $01,x	                stz 1,x
.988b		20 ee 98	jsr $98ee	                jsr xt_parse
.988e		e8		inx		                inx
.988f		e8		inx		                inx
.9890		e8		inx		                inx
.9891		e8		inx		                inx
.9892		60		rts		z_paren:        rts
.9893						xt_parse_name:
.9893		a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.9895		38		sec		                sec
.9896		e5 0c		sbc $0c		                sbc toin
.9898		85 24		sta $24		                sta tmp1
.989a		a5 0b		lda $0b		                lda ciblen+1            ; MSB
.989c		e5 0d		sbc $0d		                sbc toin+1
.989e		85 25		sta $25		                sta tmp1+1
.98a0		a5 24		lda $24		                lda tmp1
.98a2		05 25		ora $25		                ora tmp1+1
.98a4		f0 28		beq $98ce	                beq _empty_line
.98a6		a5 08		lda $08		                lda cib
.98a8		18		clc		                clc
.98a9		65 0c		adc $0c		                adc toin
.98ab		85 26		sta $26		                sta tmp2                ; LSB of first character
.98ad		a5 09		lda $09		                lda cib+1
.98af		65 0d		adc $0d		                adc toin+1
.98b1		85 27		sta $27		                sta tmp2+1              ; MSB
.98b3						_skip_loop:
.98b3		b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.98b5		20 35 d8	jsr $d835	                jsr is_whitespace
.98b8		90 1f		bcc $98d9	                bcc _char_found
.98ba		e6 26		inc $26		                inc tmp2
.98bc		d0 02		bne $98c0	                bne +
.98be		e6 27		inc $27		                inc tmp2+1
.98c0						+
.98c0		a5 24		lda $24		                lda tmp1
.98c2		d0 02		bne $98c6	                bne +
.98c4		c6 25		dec $25		                dec tmp1+1
.98c6		c6 24		dec $24		+               dec tmp1
.98c8		a5 24		lda $24		                lda tmp1
.98ca		05 25		ora $25		                ora tmp1+1
.98cc		d0 e5		bne $98b3	                bne _skip_loop          ; fall through if empty line
.98ce						_empty_line:
.98ce		ca		dex		                dex
.98cf		ca		dex		                dex
.98d0		ca		dex		                dex
.98d1		ca		dex		                dex
.98d2		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.98d4		74 01		stz $01,x	                stz 1,x
.98d6		4c 85 99	jmp $9985	                jmp z_parse_name        ; skip over PARSE
.98d9						_char_found:
.98d9		a5 26		lda $26		                lda tmp2
.98db		38		sec		                sec
.98dc		e5 08		sbc $08		                sbc cib
.98de		85 0c		sta $0c		                sta toin
.98e0		a5 27		lda $27		                lda tmp2+1
.98e2		e5 09		sbc $09		                sbc cib+1
.98e4		85 0d		sta $0d		                sta toin+1
.98e6		ca		dex		                dex
.98e7		ca		dex		                dex
.98e8		a9 20		lda #$20	                lda #AscSP
.98ea		95 00		sta $00,x	                sta 0,x
.98ec		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.98ee						xt_parse:
.98ee		20 42 d8	jsr $d842	                jsr underflow_1
.98f1		a5 0a		lda $0a		                lda ciblen
.98f3		05 0b		ora $0b		                ora ciblen+1
.98f5		f0 0c		beq $9903	                beq _abort_parse
.98f7		a5 0d		lda $0d		                lda toin+1              ; MSB
.98f9		c5 0b		cmp $0b		                cmp ciblen+1
.98fb		90 0e		bcc $990b	                bcc _go_parse           ; unsigned comparison
.98fd		a5 0c		lda $0c		                lda toin                ; LSB
.98ff		c5 0a		cmp $0a		                cmp ciblen
.9901		90 08		bcc $990b	                bcc _go_parse
.9903						_abort_parse:
.9903		ca		dex		                dex
.9904		ca		dex		                dex
.9905		74 00		stz $00,x	                stz 0,x
.9907		74 01		stz $01,x	                stz 1,x
.9909		80 7a		bra $9985	                bra _done
.990b						_go_parse:
.990b		b5 00		lda $00,x	                lda 0,x
.990d		85 2c		sta $2c		                sta tmptos
.990f		ca		dex		                dex
.9910		ca		dex		                dex
.9911		a5 08		lda $08		                lda cib
.9913		18		clc		                clc
.9914		65 0c		adc $0c		                adc toin        ; LSB
.9916		85 24		sta $24		                sta tmp1
.9918		85 26		sta $26		                sta tmp2
.991a		95 02		sta $02,x	                sta 2,x
.991c		a5 09		lda $09		                lda cib+1
.991e		65 0d		adc $0d		                adc toin+1      ; MSB
.9920		85 25		sta $25		                sta tmp1+1
.9922		85 27		sta $27		                sta tmp2+1
.9924		95 03		sta $03,x	                sta 3,x
.9926		a5 08		lda $08		                lda cib
.9928		18		clc		                clc
.9929		65 0a		adc $0a		                adc ciblen
.992b		85 28		sta $28		                sta tmp3
.992d		a5 09		lda $09		                lda cib+1
.992f		65 0b		adc $0b		                adc ciblen+1
.9931		85 29		sta $29		                sta tmp3+1
.9933		64 2d		stz $2d		                stz tmptos+1
.9935						_loop:
.9935		a5 26		lda $26		                lda tmp2
.9937		c5 28		cmp $28		                cmp tmp3
.9939		d0 06		bne $9941	                bne _not_empty
.993b		a5 27		lda $27		                lda tmp2+1
.993d		c5 29		cmp $29		                cmp tmp3+1
.993f		f0 1d		beq $995e	                beq _eol
.9941						_not_empty:
.9941		b2 26		lda ($26)	                lda (tmp2)
.9943		a4 2c		ldy $2c		                ldy tmptos
.9945		c0 20		cpy #$20	                cpy #AscSP
.9947		d0 07		bne $9950	                bne _not_whitespace
.9949		20 35 d8	jsr $d835	                jsr is_whitespace
.994c		90 02		bcc $9950	                bcc _not_whitespace
.994e		80 0c		bra $995c	                bra _found_delimiter
.9950						_not_whitespace:
.9950		c5 2c		cmp $2c		                cmp tmptos
.9952		f0 08		beq $995c	                beq _found_delimiter
.9954		e6 26		inc $26		                inc tmp2
.9956		d0 dd		bne $9935	                bne _loop
.9958		e6 27		inc $27		                inc tmp2+1
.995a		80 d9		bra $9935	                bra _loop
.995c						_found_delimiter:
.995c		e6 2d		inc $2d		                inc tmptos+1
.995e						_eol:
.995e		a5 26		lda $26		                lda tmp2
.9960		38		sec		                sec
.9961		e5 24		sbc $24		                sbc tmp1
.9963		95 00		sta $00,x	                sta 0,x
.9965		a5 27		lda $27		                lda tmp2+1
.9967		e5 25		sbc $25		                sbc tmp1+1
.9969		95 01		sta $01,x	                sta 1,x
.996b		a5 26		lda $26		                lda tmp2
.996d		38		sec		                sec
.996e		e5 08		sbc $08		                sbc cib
.9970		85 0c		sta $0c		                sta toin
.9972		a5 27		lda $27		                lda tmp2+1
.9974		e5 09		sbc $09		                sbc cib+1
.9976		85 0d		sta $0d		                sta toin+1
.9978		a5 0c		lda $0c		                lda toin
.997a		18		clc		                clc
.997b		65 2d		adc $2d		                adc tmptos+1
.997d		85 0c		sta $0c		                sta toin
.997f		a5 0d		lda $0d		                lda toin+1
.9981		69 00		adc #$00	                adc #0          ; we only need the carry
.9983		85 0d		sta $0d		                sta toin+1
.9985						_done:
.9985						z_parse_name:
.9985		60		rts		z_parse:        rts
.9986						xt_pick:
.9986		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.9988		8a		txa		                txa
.9989		75 00		adc $00,x	                adc 0,x
.998b		a8		tay		                tay
.998c		b9 02 00	lda $0002,y	                lda 0002,y
.998f		95 00		sta $00,x	                sta 0,x
.9991		b9 03 00	lda $0003,y	                lda 0003,y
.9994		95 01		sta $01,x	                sta 1,x
.9996		60		rts		z_pick:         rts
.9997						xt_plus:
.9997		20 47 d8	jsr $d847	                jsr underflow_2
.999a		18		clc		                clc
.999b		b5 00		lda $00,x	                lda 0,x         ; LSB
.999d		75 02		adc $02,x	                adc 2,x
.999f		95 02		sta $02,x	                sta 2,x
.99a1		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99a3		75 03		adc $03,x	                adc 3,x
.99a5		95 03		sta $03,x	                sta 3,x
.99a7		e8		inx		                inx
.99a8		e8		inx		                inx
.99a9		60		rts		z_plus:         rts
.99aa						xt_plus_store:
.99aa		20 47 d8	jsr $d847	                jsr underflow_2
.99ad		b5 00		lda $00,x	                lda 0,x
.99af		85 24		sta $24		                sta tmp1
.99b1		b5 01		lda $01,x	                lda 1,x
.99b3		85 25		sta $25		                sta tmp1+1
.99b5		a0 00		ldy #$00	                ldy #0          ; LSB
.99b7		b1 24		lda ($24),y	                lda (tmp1),y
.99b9		18		clc		                clc
.99ba		75 02		adc $02,x	                adc 2,x
.99bc		91 24		sta ($24),y	                sta (tmp1),y
.99be		c8		iny		                iny             ; MSB
.99bf		b1 24		lda ($24),y	                lda (tmp1),y
.99c1		75 03		adc $03,x	                adc 3,x
.99c3		91 24		sta ($24),y	                sta (tmp1),y
.99c5		e8		inx		                inx
.99c6		e8		inx		                inx
.99c7		e8		inx		                inx
.99c8		e8		inx		                inx
.99c9		60		rts		z_plus_store:   rts
.99ca						xt_postpone:
.99ca		20 93 98	jsr $9893	                jsr xt_parse_name               ; ( -- addr n )
.99cd		b5 00		lda $00,x	                lda 0,x
.99cf		15 01		ora $01,x	                ora 1,x
.99d1		d0 05		bne $99d8	                bne +
.99d3		a9 05		lda #$05	                lda #err_noname
.99d5		4c 58 d8	jmp $d858	                jmp error
.99d8						+
.99d8		20 8e 8f	jsr $8f8e	                jsr xt_find_name                ; ( -- nt | 0 )
.99db		d0 05		bne $99e2	                bne +
.99dd		a9 05		lda #$05	                lda #err_noname
.99df		4c 58 d8	jmp $d858	                jmp error
.99e2						+
.99e2		b5 00		lda $00,x	                lda 0,x
.99e4		85 24		sta $24		                sta tmp1
.99e6		b5 01		lda $01,x	                lda 1,x
.99e8		85 25		sta $25		                sta tmp1+1
.99ea		20 95 95	jsr $9595	                jsr xt_name_to_int              ; ( nt -- xt )
.99ed		e6 24		inc $24		                inc tmp1
.99ef		d0 02		bne $99f3	                bne +
.99f1		e6 25		inc $25		                inc tmp1+1
.99f3						+
.99f3		b2 24		lda ($24)	                lda (tmp1)
.99f5		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.99f7		f0 05		beq $99fe	                beq _not_immediate
.99f9		20 a3 87	jsr $87a3	                jsr xt_compile_comma
.99fc		80 0a		bra $9a08	                bra _done
.99fe						_not_immediate:
.99fe		20 3b 93	jsr $933b	                jsr xt_literal
.9a01		a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a03		a9 a3		lda #$a3	                lda #<xt_compile_comma
.9a05		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.9a08						_done:
.9a08		60		rts		z_postpone:     rts
.9a09						xt_previous:
.9a09		20 e7 90	jsr $90e7	                jsr xt_get_order
.9a0c		20 f6 95	jsr $95f6	                jsr xt_nip
.9a0f		20 c5 97	jsr $97c5	                jsr xt_one_minus
.9a12		20 cf 9c	jsr $9ccf	                jsr xt_set_order
.9a15		60		rts		z_previous:     rts
.9a16						xt_question:
.9a16		20 33 8f	jsr $8f33	                jsr xt_fetch
.9a19		20 e9 8b	jsr $8be9	                jsr xt_dot
.9a1c		60		rts		z_question:     rts
.9a1d						xt_question_dup:
.9a1d		20 42 d8	jsr $d842	                jsr underflow_1
.9a20		b5 00		lda $00,x	                lda 0,x
.9a22		15 01		ora $01,x	                ora 1,x
.9a24		f0 0a		beq $9a30	                beq _done
.9a26		ca		dex		                dex
.9a27		ca		dex		                dex
.9a28		b5 02		lda $02,x	                lda 2,x
.9a2a		95 00		sta $00,x	                sta 0,x
.9a2c		b5 03		lda $03,x	                lda 3,x
.9a2e		95 01		sta $01,x	                sta 1,x
.9a30						_done:
.9a30		60		rts		z_question_dup: rts
.9a31						xt_r_fetch:
.9a31		7a		ply		                ply             ; LSB
.9a32		84 24		sty $24		                sty tmp1
.9a34		7a		ply		                ply             ; MSB
.9a35		ca		dex		                dex
.9a36		ca		dex		                dex
.9a37		68		pla		                pla             ; LSB
.9a38		95 00		sta $00,x	                sta 0,x
.9a3a		68		pla		                pla             ; MSB
.9a3b		95 01		sta $01,x	                sta 1,x
.9a3d		48		pha		                pha
.9a3e		b5 00		lda $00,x	                lda 0,x
.9a40		48		pha		                pha
.9a41		5a		phy		                phy             ; MSB
.9a42		a4 24		ldy $24		                ldy tmp1
.9a44		5a		phy		                phy             ; LSB
.9a45		60		rts		z_r_fetch:      rts
.9a46						xt_r_from:
.9a46		68		pla		                pla             ; LSB
.9a47		85 2c		sta $2c		                sta tmptos
.9a49		7a		ply		                ply             ; MSB
.9a4a		ca		dex		                dex
.9a4b		ca		dex		                dex
.9a4c		68		pla		                pla             ; LSB
.9a4d		95 00		sta $00,x	                sta 0,x
.9a4f		68		pla		                pla             ; MSB
.9a50		95 01		sta $01,x	                sta 1,x
.9a52		5a		phy		                phy             ; MSB
.9a53		a5 2c		lda $2c		                lda tmptos
.9a55		48		pha		                pha             ; LSB
.9a56		60		rts		z_r_from:       rts
.9a57						xt_r_to_input:
.9a57		68		pla		                pla
.9a58		85 24		sta $24		                sta tmp1
.9a5a		68		pla		                pla
.9a5b		85 25		sta $25		                sta tmp1+1
.9a5d		a0 00		ldy #$00	                ldy #0
.9a5f						_loop:
.9a5f		68		pla		                pla
.9a60		99 06 00	sta $0006,y	                sta insrc,y
.9a63		c8		iny		                iny
.9a64		c0 08		cpy #$08	                cpy #8
.9a66		d0 f7		bne $9a5f	                bne _loop
.9a68		a5 25		lda $25		                lda tmp1+1
.9a6a		48		pha		                pha
.9a6b		a5 24		lda $24		                lda tmp1
.9a6d		48		pha		                pha
.9a6e		60		rts		z_r_to_input: 	rts
.9a6f						xt_recurse:
.9a6f		a0 00		ldy #$00	                ldy #0
.9a71		a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9a73		91 00		sta ($00),y	                sta (cp),y
.9a75		c8		iny		                iny
.9a76		24 20		bit $20		                bit status
.9a78		70 0c		bvs $9a86	                bvs _nt_in_workword
.9a7a		a5 04		lda $04		                lda workword
.9a7c		91 00		sta ($00),y	                sta (cp),y
.9a7e		c8		iny		                iny
.9a7f		a5 05		lda $05		                lda workword+1
.9a81		91 00		sta ($00),y	                sta (cp),y
.9a83		c8		iny		                iny
.9a84		80 1b		bra $9aa1	                bra _update_cp
.9a86						_nt_in_workword:
.9a86		a5 04		lda $04		                lda workword            ; LSB
.9a88		18		clc		                clc
.9a89		69 04		adc #$04	                adc #4
.9a8b		85 24		sta $24		                sta tmp1
.9a8d		a5 05		lda $05		                lda workword+1          ; MSB
.9a8f		69 00		adc #$00	                adc #0
.9a91		85 25		sta $25		                sta tmp1+1
.9a93		b2 24		lda ($24)	                lda (tmp1)
.9a95		91 00		sta ($00),y	                sta (cp),y
.9a97		5a		phy		                phy
.9a98		a0 01		ldy #$01	                ldy #1
.9a9a		b1 24		lda ($24),y	                lda (tmp1),y
.9a9c		7a		ply		                ply
.9a9d		c8		iny		                iny
.9a9e		91 00		sta ($00),y	                sta (cp),y
.9aa0		c8		iny		                iny
.9aa1						_update_cp:
.9aa1		98		tya		                tya
.9aa2		18		clc		                clc
.9aa3		65 00		adc $00		                adc cp
.9aa5		85 00		sta $00		                sta cp
.9aa7		90 02		bcc $9aab	                bcc _done
.9aa9		e6 01		inc $01		                inc cp+1
.9aab						_done:
.9aab		60		rts		z_recurse:      rts
.9aac						xt_refill:
.9aac		a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9aae		d0 2d		bne $9add	                bne _src_not_kbd
.9ab0		ca		dex		                dex
.9ab1		ca		dex		                dex
.9ab2		ca		dex		                dex
.9ab3		ca		dex		                dex
.9ab4		a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9ab6		95 02		sta $02,x	                sta 2,x
.9ab8		a5 09		lda $09		                lda cib+1
.9aba		95 03		sta $03,x	                sta 3,x
.9abc		64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9abe		64 0b		stz $0b		                stz ciblen+1
.9ac0		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9ac2		95 00		sta $00,x	                sta 0,x
.9ac4		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9ac6		20 e2 80	jsr $80e2	                jsr xt_accept           ; ( addr n1 -- n2)
.9ac9		b5 00		lda $00,x	                lda 0,x
.9acb		85 0a		sta $0a		                sta ciblen
.9acd		b5 01		lda $01,x	                lda 1,x
.9acf		85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9ad1		64 0c		stz $0c		                stz toin
.9ad3		64 0d		stz $0d		                stz toin+1
.9ad5		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9ad7		95 00		sta $00,x	                sta 0,x
.9ad9		95 01		sta $01,x	                sta 1,x
.9adb		80 10		bra $9aed	                bra _done
.9add						_src_not_kbd:
.9add		1a		inc a		                ina
.9ade		d0 08		bne $9ae8	                bne _src_not_string
.9ae0		ca		dex		                dex
.9ae1		ca		dex		                dex
.9ae2		74 00		stz $00,x	                stz 0,x
.9ae4		74 01		stz $01,x	                stz 1,x
.9ae6		80 05		bra $9aed	                bra z_refill
.9ae8						_src_not_string:
.9ae8		a9 01		lda #$01	                lda #err_badsource
.9aea		4c 58 d8	jmp $d858	                jmp error
.9aed						_done:
.9aed		60		rts		z_refill:       rts
.9aee						xt_repeat:
.9aee		20 1d 82	jsr $821d	                jsr xt_again
.9af1		20 25 91	jsr $9125	                jsr xt_here
.9af4		20 33 a1	jsr $a133	                jsr xt_swap
.9af7		20 12 a1	jsr $a112	                jsr xt_store
.9afa		60		rts		z_repeat:       rts
.9afb						xt_right_bracket:
.9afb		a9 ff		lda #$ff	                lda #$FF
.9afd		85 16		sta $16		                sta state
.9aff		85 17		sta $17		                sta state+1
.9b01						z_right_bracket:
.9b01		60		rts		                rts
.9b02						xt_root_wordlist:
.9b02		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b03		ca		dex		                dex
.9b04		a9 03		lda #$03	                lda #3
.9b06		95 00		sta $00,x	                sta 0,x
.9b08		74 01		stz $01,x	                stz 1,x
.9b0a						z_root_wordlist:
.9b0a		60		rts		                rts
.9b0b						xt_rot:
.9b0b		20 4c d8	jsr $d84c	                jsr underflow_3
.9b0e		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b10		b5 03		lda $03,x	                lda 3,x
.9b12		95 05		sta $05,x	                sta 5,x
.9b14		b5 01		lda $01,x	                lda 1,x
.9b16		95 03		sta $03,x	                sta 3,x
.9b18		94 01		sty $01,x	                sty 1,x
.9b1a		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b1c		b5 02		lda $02,x	                lda 2,x
.9b1e		95 04		sta $04,x	                sta 4,x
.9b20		b5 00		lda $00,x	                lda 0,x
.9b22		95 02		sta $02,x	                sta 2,x
.9b24		94 00		sty $00,x	                sty 0,x
.9b26		60		rts		z_rot:          rts
.9b27						xt_rshift:
.9b27		20 47 d8	jsr $d847	                jsr underflow_2
.9b2a		b5 00		lda $00,x	                lda 0,x
.9b2c		29 0f		and #$0f	                and #%00001111
.9b2e		f0 08		beq $9b38	                beq _done               ; if 0 shifts, quit
.9b30		a8		tay		                tay
.9b31						_loop:
.9b31		56 03		lsr $03,x	                lsr 3,x
.9b33		76 02		ror $02,x	                ror 2,x
.9b35		88		dey		                dey
.9b36		d0 f9		bne $9b31	                bne _loop
.9b38						_done:
.9b38		e8		inx		                inx
.9b39		e8		inx		                inx
.9b3a		60		rts		z_rshift:       rts
.9b3b						xt_s_backslash_quote:
.9b3b		a9 ff		lda #$ff	                lda #$FF
.9b3d		85 26		sta $26		                sta tmp2
.9b3f		64 27		stz $27		                stz tmp2+1
.9b41		20 07 9d	jsr $9d07	                jsr s_quote_start
.9b44						_done:
.9b44						z_s_backslash_quote:
.9b44		60		rts		                rts
.9b45						convert_hex_value:
.9b45		c9 41		cmp #$41	        cmp #'A'
.9b47		90 07		bcc $9b50	        bcc _digit
.9b49		29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b4b		38		sec		        sec
.9b4c		e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b4e		80 03		bra $9b53	        bra _done
.9b50						_digit:
.9b50		38		sec		        sec
.9b51		e9 30		sbc #$30	        sbc #'0'
.9b53						_done:
.9b53		60		rts		        rts
.9b54						xt_search_wordlist:
.9b54		20 4c d8	jsr $d84c	                jsr underflow_3
.9b57		a5 1e		lda $1e		                lda up
.9b59		18		clc		                clc
.9b5a		69 06		adc #$06	                adc #wordlists_offset
.9b5c		85 26		sta $26		                sta tmp2
.9b5e		a5 1f		lda $1f		                lda up+1
.9b60		69 00		adc #$00	                adc #0          ; Adding carry
.9b62		85 27		sta $27		                sta tmp2+1
.9b64		b5 00		lda $00,x	                lda 0,x
.9b66		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9b67		65 26		adc $26		                adc tmp2
.9b69		85 26		sta $26		                sta tmp2
.9b6b		90 02		bcc $9b6f	                bcc +
.9b6d		e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9b6f						+
.9b6f		e8		inx		                inx
.9b70		e8		inx		                inx
.9b71		b5 00		lda $00,x	                lda 0,x
.9b73		15 01		ora $01,x	                ora 1,x
.9b75		d0 03		bne $9b7a	                bne _check_wordlist
.9b77		4c 32 9c	jmp $9c32	                jmp _done
.9b7a						_check_wordlist:
.9b7a		a5 26		lda $26		                lda tmp2
.9b7c		05 27		ora $27		                ora tmp2+1
.9b7e		d0 03		bne $9b83	                bne _have_string
.9b80		4c 32 9c	jmp $9c32	                jmp _done
.9b83						_have_string:
.9b83		b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9b85		85 24		sta $24		                sta tmp1
.9b87		e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9b89		d0 02		bne $9b8d	                bne +
.9b8b		e6 27		inc $27		                inc tmp2+1
.9b8d						+
.9b8d		b2 26		lda ($26)	                lda (tmp2)
.9b8f		85 25		sta $25		                sta tmp1+1
.9b91		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9b93		85 26		sta $26		                sta tmp2
.9b95		b5 03		lda $03,x	                lda 3,x
.9b97		85 27		sta $27		                sta tmp2+1
.9b99						_loop:
.9b99		b2 24		lda ($24)	                lda (tmp1)
.9b9b		d5 00		cmp $00,x	                cmp 0,x
.9b9d		d0 7b		bne $9c1a	                bne _next_entry
.9b9f						_compare_string:
.9b9f		b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9ba1		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9ba3		b0 07		bcs $9bac	                bcs _compare_first
.9ba5		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9ba7		90 03		bcc $9bac	                bcc _compare_first
.9ba9		18		clc		                clc
.9baa		69 20		adc #$20	                adc #$20
.9bac						_compare_first:
.9bac		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9bae		d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9bb0		d0 68		bne $9c1a	                bne _next_entry
.9bb2		b5 00		lda $00,x	                lda 0,x
.9bb4		3a		dec a		                dea
.9bb5		f0 2c		beq $9be3	                beq _success
.9bb7		a5 24		lda $24		                lda tmp1
.9bb9		48		pha		                pha             ; Preserve tmp1 on the return stack.
.9bba		18		clc		                clc
.9bbb		69 08		adc #$08	                adc #8
.9bbd		85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9bbf		a5 25		lda $25		                lda tmp1+1
.9bc1		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9bc2		69 00		adc #$00	                adc #0          ; we only need the carry
.9bc4		85 25		sta $25		                sta tmp1+1
.9bc6		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9bc8		88		dey		                dey
.9bc9						_string_loop:
.9bc9		b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9bcb		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9bcd		b0 07		bcs $9bd6	                bcs _check_char
.9bcf		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bd1		90 03		bcc $9bd6	                bcc _check_char
.9bd3		18		clc		                clc
.9bd4		69 20		adc #$20	                adc #$20
.9bd6						_check_char:
.9bd6		d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9bd8		d0 3a		bne $9c14	                bne _next_entry_tmp1
.9bda		88		dey		                dey
.9bdb		d0 ec		bne $9bc9	                bne _string_loop
.9bdd						_success_tmp1:
.9bdd		68		pla		                pla             ; Restore tmp1 from the return stack.
.9bde		85 25		sta $25		                sta tmp1+1
.9be0		68		pla		                pla
.9be1		85 24		sta $24		                sta tmp1
.9be3						_success:
.9be3		e8		inx		                inx
.9be4		e8		inx		                inx
.9be5		a5 24		lda $24		                lda tmp1
.9be7		95 00		sta $00,x	                sta 0,x
.9be9		a5 25		lda $25		                lda tmp1+1
.9beb		95 01		sta $01,x	                sta 1,x
.9bed		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.9bf0		20 95 95	jsr $9595	                jsr xt_name_to_int      ; ( nt xt )
.9bf3		20 33 a1	jsr $a133	                jsr xt_swap             ; ( xt nt )
.9bf6		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9bf8		f6 00		inc $00,x	                inc 0,x
.9bfa		d0 02		bne $9bfe	                bne +
.9bfc		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9bfe						+
.9bfe		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c00		29 04		and #$04	                and #IM
.9c02		d0 08		bne $9c0c	                bne _immediate          ; bit set, we're immediate
.9c04		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c06		95 00		sta $00,x	                sta 0,x
.9c08		95 01		sta $01,x	                sta 1,x
.9c0a		80 28		bra $9c34	                bra _done_nodrop
.9c0c						_immediate:
.9c0c		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c0e		95 00		sta $00,x	                sta 0,x
.9c10		74 01		stz $01,x	                stz 1,x
.9c12		80 20		bra $9c34	                bra _done_nodrop
.9c14						_next_entry_tmp1:
.9c14		68		pla		                pla             ; Restore tmp1 from the return stack.
.9c15		85 25		sta $25		                sta tmp1+1
.9c17		68		pla		                pla
.9c18		85 24		sta $24		                sta tmp1
.9c1a						_next_entry:
.9c1a		a0 02		ldy #$02	                ldy #2
.9c1c		b1 24		lda ($24),y	                lda (tmp1),y
.9c1e		48		pha		                pha
.9c1f		c8		iny		                iny
.9c20		b1 24		lda ($24),y	                lda (tmp1),y
.9c22		85 25		sta $25		                sta tmp1+1
.9c24		68		pla		                pla
.9c25		85 24		sta $24		                sta tmp1
.9c27		05 25		ora $25		                ora tmp1+1
.9c29		f0 03		beq $9c2e	                beq _fail_done
.9c2b		4c 99 9b	jmp $9b99	                jmp _loop
.9c2e						_fail_done:
.9c2e		74 02		stz $02,x	                stz 2,x         ; failure flag
.9c30		74 03		stz $03,x	                stz 3,x
.9c32						_done:
.9c32		e8		inx		                inx
.9c33		e8		inx		                inx
.9c34						_done_nodrop:
.9c34						z_search_wordlist:
.9c34		60		rts		                rts
.9c35						xt_see:
.9c35		20 93 98	jsr $9893	                jsr xt_parse_name       ; ( addr u )
.9c38		20 8e 8f	jsr $8f8e	                jsr xt_find_name        ; ( nt | 0 )
.9c3b		b5 00		lda $00,x	                lda 0,x
.9c3d		15 01		ora $01,x	                ora 1,x
.9c3f		d0 05		bne $9c46	                bne +
.9c41		a9 05		lda #$05	                lda #err_noname
.9c43		4c 58 d8	jmp $d858	                jmp error
.9c46						+
.9c46		20 2a 89	jsr $892a	                jsr xt_cr
.9c49		a5 18		lda $18		                lda base
.9c4b		48		pha		                pha
.9c4c		20 30 91	jsr $9130	                jsr xt_hex
.9c4f		a9 09		lda #$09	                lda #str_see_nt
.9c51		20 7e d8	jsr $d87e	                jsr print_string_no_lf
.9c54		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.9c57		20 b3 a4	jsr $a4b3	                jsr xt_u_dot
.9c5a		20 a3 a0	jsr $a0a3	                jsr xt_space            ; ( nt )
.9c5d		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.9c60		20 95 95	jsr $9595	                jsr xt_name_to_int      ; ( nt xt )
.9c63		a9 0a		lda #$0a	                lda #str_see_xt
.9c65		20 7e d8	jsr $d87e	                jsr print_string_no_lf
.9c68		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt xt xt )
.9c6b		20 b3 a4	jsr $a4b3	                jsr xt_u_dot
.9c6e		20 2a 89	jsr $892a	                jsr xt_cr               ; ( nt xt )
.9c71		a9 08		lda #$08	                lda #str_see_flags
.9c73		20 7e d8	jsr $d87e	                jsr print_string_no_lf
.9c76		20 47 98	jsr $9847	                jsr xt_over             ; ( nt xt nt )
.9c79		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9c7c		20 33 8f	jsr $8f33	                jsr xt_fetch            ; ( nt xt flags )
.9c7f		b5 00		lda $00,x	                lda 0,x
.9c81		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9c83						_flag_loop:
.9c83		48		pha		                pha
.9c84		29 01		and #$01	                and #%00000001
.9c86		18		clc		                clc
.9c87		69 30		adc #$30	                adc #$30                ; ASCII "0"
.9c89		20 a9 8d	jsr $8da9	                jsr emit_a
.9c8c		20 a3 a0	jsr $a0a3	                jsr xt_space
.9c8f		68		pla		                pla
.9c90		6a		ror a		                ror                     ; Next flag
.9c91		88		dey		                dey
.9c92		d0 ef		bne $9c83	                bne _flag_loop
.9c94		20 2a 89	jsr $892a	                jsr xt_cr
.9c97		e8		inx		                inx
.9c98		e8		inx		                inx                     ; ( nt xt )
.9c99		a9 0b		lda #$0b	                lda #str_see_size
.9c9b		20 7e d8	jsr $d87e	                jsr print_string_no_lf
.9c9e		20 33 a1	jsr $a133	                jsr xt_swap             ; ( xt nt )
.9ca1		20 fa a6	jsr $a6fa	                jsr xt_wordsize         ; ( xt u )
.9ca4		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9ca7		20 6c 8a	jsr $8a6c	                jsr xt_decimal
.9caa		20 b3 a4	jsr $a4b3	                jsr xt_u_dot            ; ( xt u )
.9cad		20 30 91	jsr $9130	                jsr xt_hex
.9cb0		20 2a 89	jsr $892a	                jsr xt_cr
.9cb3		20 3d a3	jsr $a33d	                jsr xt_two_dup          ; ( xt u xt u )
.9cb6		20 e7 8c	jsr $8ce7	                jsr xt_dump
.9cb9		20 2a 89	jsr $892a	                jsr xt_cr
.9cbc		20 01 8b	jsr $8b01	                jsr xt_disasm
.9cbf		68		pla		                pla
.9cc0		85 18		sta $18		                sta base
.9cc2		60		rts		z_see:          rts
.9cc3						xt_set_current:
.9cc3		20 42 d8	jsr $d842	                jsr underflow_1
.9cc6		a0 04		ldy #$04	                ldy #current_offset
.9cc8		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9cca		91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9ccc		e8		inx		                inx
.9ccd		e8		inx		                inx
.9cce		60		rts		z_set_current:  rts
.9ccf						xt_set_order:
.9ccf		a9 ff		lda #$ff	                lda #$FF
.9cd1		d5 01		cmp $01,x	                cmp 1,x
.9cd3		d0 12		bne $9ce7	                bne _start
.9cd5		d5 00		cmp $00,x	                cmp 0,x
.9cd7		d0 0e		bne $9ce7	                bne _start
.9cd9		ca		dex		                dex             ; Make room for the count.
.9cda		ca		dex		                dex
.9cdb		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9cdd		a9 03		lda #$03	                lda #3
.9cdf		95 02		sta $02,x	                sta 2,x
.9ce1		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9ce3		a9 01		lda #$01	                lda #1
.9ce5		95 00		sta $00,x	                sta 0,x
.9ce7						_start:
.9ce7		a0 1e		ldy #$1e	                ldy #num_order_offset
.9ce9		b5 00		lda $00,x	                lda 0,x
.9ceb		91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9ced		85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9cef		e8		inx		                inx             ; Drop the count off the data stack.
.9cf0		e8		inx		                inx
.9cf1		a5 24		lda $24		                lda tmp1
.9cf3		f0 0d		beq $9d02	                beq _done       ; If zero, there are no wordlists.
.9cf5		a0 1f		ldy #$1f	                ldy #search_order_offset
.9cf7						_loop:
.9cf7		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9cf9		91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9cfb		c8		iny		                iny
.9cfc		e8		inx		                inx
.9cfd		e8		inx		                inx
.9cfe		c6 24		dec $24		                dec tmp1
.9d00		d0 f5		bne $9cf7	                bne _loop
.9d02						_done:
.9d02		60		rts		z_set_order:    rts
.9d03						xt_s_quote:
.9d03		64 26		stz $26		                stz tmp2
.9d05		64 27		stz $27		                stz tmp2+1
.9d07						s_quote_start:
.9d07		ca		dex		                dex
.9d08		ca		dex		                dex
.9d09		ca		dex		                dex
.9d0a		ca		dex		                dex
.9d0b		a9 4c		lda #$4c	                lda #$4C
.9d0d		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9d10		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9d13		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9d16		a5 00		lda $00		                lda cp
.9d18		95 02		sta $02,x	                sta 2,x
.9d1a		a5 01		lda $01		                lda cp+1
.9d1c		95 03		sta $03,x	                sta 3,x
.9d1e						_savechars_loop:
.9d1e		a5 0d		lda $0d		                lda toin+1              ; MSB
.9d20		c5 0b		cmp $0b		                cmp ciblen+1
.9d22		90 2a		bcc $9d4e	                bcc _input_fine         ; unsigned comparison
.9d24		a5 0c		lda $0c		                lda toin                ; LSB
.9d26		c5 0a		cmp $0a		                cmp ciblen
.9d28		90 24		bcc $9d4e	                bcc _input_fine
.9d2a		a5 26		lda $26		                lda tmp2
.9d2c		48		pha		                pha
.9d2d		a5 27		lda $27		                lda tmp2+1
.9d2f		48		pha		                pha
.9d30		a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d32		48		pha		                pha
.9d33		20 ac 9a	jsr $9aac	                jsr xt_refill           ; ( -- f )
.9d36		68		pla		                pla
.9d37		85 28		sta $28		                sta tmp3
.9d39		68		pla		                pla
.9d3a		85 27		sta $27		                sta tmp2+1
.9d3c		68		pla		                pla
.9d3d		85 26		sta $26		                sta tmp2
.9d3f		b5 00		lda $00,x	                lda 0,x
.9d41		15 01		ora $01,x	                ora 1,x
.9d43		d0 05		bne $9d4a	                bne _refill_ok
.9d45		a9 06		lda #$06	                lda #err_refill
.9d47		4c 58 d8	jmp $d858	                jmp error
.9d4a						_refill_ok:
.9d4a		e8		inx		                inx
.9d4b		e8		inx		                inx
.9d4c		80 d0		bra $9d1e	                bra _savechars_loop
.9d4e						_input_fine:
.9d4e		a5 08		lda $08		                lda cib
.9d50		18		clc		                clc
.9d51		65 0c		adc $0c		                adc toin        ; LSB
.9d53		85 24		sta $24		                sta tmp1
.9d55		a5 09		lda $09		                lda cib+1
.9d57		65 0d		adc $0d		                adc toin+1      ; MSB
.9d59		85 25		sta $25		                sta tmp1+1
.9d5b		b2 24		lda ($24)	                lda (tmp1)
.9d5d		24 26		bit $26		                bit tmp2
.9d5f		30 03		bmi $9d64	                bmi _handle_escapes    ; Only checking bit 7
.9d61		4c ed 9d	jmp $9ded	                jmp _regular_char
.9d64						_handle_escapes:
.9d64		24 27		bit $27		                bit tmp2+1
.9d66		30 03		bmi $9d6b	                bmi _escaped
.9d68		4c e3 9d	jmp $9de3	                jmp _not_escaped
.9d6b						_escaped:
.9d6b		70 3c		bvs $9da9	                bvs _check_esc_chars
.9d6d		a9 01		lda #$01	                lda #1
.9d6f		24 27		bit $27		                bit tmp2+1
.9d71		d0 10		bne $9d83	                bne _esc_x_second_digit
.9d73		e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9d75		b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9d77		20 45 9b	jsr $9b45	                jsr convert_hex_value
.9d7a		0a		asl a		                asl
.9d7b		0a		asl a		                asl
.9d7c		0a		asl a		                asl
.9d7d		0a		asl a		                asl
.9d7e		85 28		sta $28		                sta tmp3    ; Save it for later.
.9d80		4c f4 9d	jmp $9df4	                jmp _next_character
.9d83						_esc_x_second_digit:
.9d83		64 27		stz $27		                stz tmp2+1
.9d85		b2 24		lda ($24)	                lda (tmp1)
.9d87		20 45 9b	jsr $9b45	                jsr convert_hex_value
.9d8a		05 28		ora $28		                ora tmp3
.9d8c		4c f1 9d	jmp $9df1	                jmp _save_character
.9d8f						_esc_tr_table:
>9d8f		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9d90		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9d91		00 00				    .byte   0,0             ; c, d no escape
>9d93		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9d94		0c				    .byte   12              ; f -> FF (ASCII value 12)
>9d95		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9d9a		0a				    .byte   10              ; l -> LF (ASCII value 10)
>9d9b		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9d9c		0a				    .byte   10              ; n behaves like l --> lf
>9d9d		00 00				    .byte   0,0             ; o,p
>9d9f		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9da0		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9da1		00				    .byte   0               ; s
>9da2		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9da3		00				    .byte   0               ; u
>9da4		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9da5		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9da8		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9da9						_check_esc_chars:
.9da9		64 27		stz $27		                stz tmp2+1
.9dab		c9 61		cmp #$61	                cmp #'a'
.9dad		30 1a		bmi $9dc9	                bmi _check_esc_quote
.9daf		c9 7b		cmp #$7b	                cmp #'z'+1
.9db1		10 16		bpl $9dc9	                bpl _check_esc_quote
.9db3		a8		tay		                tay
.9db4		b9 2e 9d	lda $9d2e,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9db7		d0 03		bne $9dbc	                bne _esc_replace
.9db9		98		tya		                tya                     ; revert if no translation
.9dba		80 0d		bra $9dc9	                bra _check_esc_quote
.9dbc		10 33		bpl $9df1	_esc_replace:   bpl _save_character     ; simple replacement
.9dbe		29 7f		and #$7f	                and #$7f                ; clear hi bit
.9dc0		f0 2f		beq $9df1	                beq _save_character     ; NUL we can just output
.9dc2		20 f5 d6	jsr $d6f5	                jsr cmpl_a              ; else output first char (CR)
.9dc5		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9dc7		80 28		bra $9df1	                bra _save_character
.9dc9						_check_esc_quote:
.9dc9		c9 22		cmp #$22	                cmp #$22
.9dcb		d0 04		bne $9dd1	                bne _check_esc_x
.9dcd		a9 22		lda #$22	                lda #34
.9dcf		80 20		bra $9df1	                bra _save_character
.9dd1						_check_esc_x:
.9dd1		c9 78		cmp #$78	                cmp #'x'
.9dd3		d0 06		bne $9ddb	                bne _check_esc_backslash
.9dd5		a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9dd7		85 27		sta $27		                sta tmp2+1
.9dd9		80 19		bra $9df4	                bra _next_character
.9ddb						_check_esc_backslash:
.9ddb		c9 5c		cmp #$5c	                cmp #$5C
.9ddd		d0 04		bne $9de3	                bne _not_escaped
.9ddf		a9 5c		lda #$5c	                lda #92
.9de1		80 0e		bra $9df1	                bra _save_character
.9de3						_not_escaped:
.9de3		c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9de5		d0 06		bne $9ded	                bne _regular_char
.9de7		a9 ff		lda #$ff	                lda #$FF
.9de9		85 27		sta $27		                sta tmp2+1
.9deb		80 07		bra $9df4	                bra _next_character
.9ded						_regular_char:
.9ded		c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9def		f0 0c		beq $9dfd	                beq _found_string_end
.9df1						_save_character:
.9df1		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9df4						_next_character:
.9df4		e6 0c		inc $0c		                inc toin
.9df6		d0 02		bne $9dfa	                bne _savechars_loop_longjump
.9df8		e6 0d		inc $0d		                inc toin+1
.9dfa						_savechars_loop_longjump:
.9dfa		4c 1e 9d	jmp $9d1e	                jmp _savechars_loop
.9dfd						_found_string_end:
.9dfd		e6 0c		inc $0c		                inc toin
.9dff		d0 02		bne $9e03	                bne +
.9e01		e6 0d		inc $0d		                inc toin+1
.9e03						+
.9e03		a5 00		lda $00		                lda cp
.9e05		38		sec		                sec
.9e06		f5 02		sbc $02,x	                sbc 2,x
.9e08		95 00		sta $00,x	                sta 0,x         ; LSB
.9e0a		a5 01		lda $01		                lda cp+1
.9e0c		f5 03		sbc $03,x	                sbc 3,x
.9e0e		95 01		sta $01,x	                sta 1,x         ; MSB
.9e10		b5 02		lda $02,x	                lda 2,x
.9e12		38		sec		                sec
.9e13		e9 02		sbc #$02	                sbc #2
.9e15		85 24		sta $24		                sta tmp1
.9e17		b5 03		lda $03,x	                lda 3,x
.9e19		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e1b		85 25		sta $25		                sta tmp1+1
.9e1d		a5 00		lda $00		                lda cp
.9e1f		92 24		sta ($24)	                sta (tmp1)
.9e21		a0 01		ldy #$01	                ldy #1
.9e23		a5 01		lda $01		                lda cp+1
.9e25		91 24		sta ($24),y	                sta (tmp1),y
.9e27		a5 16		lda $16		                lda state
.9e29		05 17		ora $17		                ora state+1             ; paranoid
.9e2b		f0 03		beq $9e30	                beq _done
.9e2d		20 14 a0	jsr $a014	                jsr sliteral_const_str         ; ( addr u -- )
.9e30						_done:
.9e30		60		rts		z_s_quote:      rts
.9e31						xt_s_to_d:
.9e31		20 42 d8	jsr $d842	                jsr underflow_1
.9e34		ca		dex		                dex
.9e35		ca		dex		                dex
.9e36		74 00		stz $00,x	                stz 0,x
.9e38		74 01		stz $01,x	                stz 1,x
.9e3a		b5 03		lda $03,x	                lda 3,x
.9e3c		10 04		bpl $9e42	                bpl _done
.9e3e		d6 00		dec $00,x	                dec 0,x
.9e40		d6 01		dec $01,x	                dec 1,x
.9e42						_done:
.9e42		60		rts		z_s_to_d:       rts
.9e43						xt_save_buffers:
.9e43		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e45		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9e47		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9e49		d0 12		bne $9e5d	                bne _done       ; Either not used or not dirty = done!
.9e4b		20 69 83	jsr $8369	                jsr xt_blkbuffer
.9e4e		20 5b 85	jsr $855b	                jsr xt_buffblocknum
.9e51		20 33 8f	jsr $8f33	                jsr xt_fetch
.9e54		20 16 85	jsr $8516	                jsr xt_block_write
.9e57		a9 01		lda #$01	                lda #1
.9e59		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e5b		91 1e		sta ($1e),y	                sta (up),y
.9e5d						_done:
.9e5d		60		rts		z_save_buffers: rts
.9e5e						xt_scr:
.9e5e		ca		dex		                dex
.9e5f		ca		dex		                dex
.9e60		18		clc		                clc
.9e61		a5 1e		lda $1e		                lda up
.9e63		69 02		adc #$02	                adc #scr_offset ; Add offset
.9e65		95 00		sta $00,x	                sta 0,x
.9e67		a5 1f		lda $1f		                lda up+1
.9e69		69 00		adc #$00	                adc #0          ; Adding carry
.9e6b		95 01		sta $01,x	                sta 1,x
.9e6d		60		rts		z_scr:          rts
.9e6e						xt_search:
.9e6e		20 51 d8	jsr $d851	                jsr underflow_4
.9e71		b5 00		lda $00,x	                lda 0,x
.9e73		15 01		ora $01,x	                ora 1,x
.9e75		d0 0b		bne $9e82	                bne _start_search
.9e77		e8		inx		                inx             ; Remove u2
.9e78		e8		inx		                inx
.9e79		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9e7b		95 00		sta $00,x	                sta 0,x
.9e7d		95 01		sta $01,x	                sta 1,x
.9e7f		4c 0c 9f	jmp $9f0c	                jmp z_search
.9e82						_start_search:
.9e82		20 2d a7	jsr $a72d	                jsr xt_zero
.9e85						_search_loop:
.9e85		18		clc		                clc
.9e86		b5 00		lda $00,x	                lda 0,x
.9e88		75 02		adc $02,x	                adc 2,x
.9e8a		85 24		sta $24		                sta tmp1
.9e8c		b5 01		lda $01,x	                lda 1,x
.9e8e		75 03		adc $03,x	                adc 3,x
.9e90		d5 07		cmp $07,x	                cmp 7,x
.9e92		90 12		bcc $9ea6	                bcc _init_comparison ; Obviously less
.9e94		d0 06		bne $9e9c	                bne _not_found
.9e96		b5 06		lda $06,x	                lda 6,x
.9e98		c5 24		cmp $24		                cmp tmp1
.9e9a		b0 0a		bcs $9ea6	                bcs _init_comparison
.9e9c						_not_found:
.9e9c		e8		inx		                inx             ; Remove offset
.9e9d		e8		inx		                inx
.9e9e		e8		inx		                inx             ; Remove u2
.9e9f		e8		inx		                inx
.9ea0		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9ea2		74 01		stz $01,x	                stz 1,x
.9ea4		80 66		bra $9f0c	                bra z_search
.9ea6						_init_comparison:
.9ea6		18		clc		                clc
.9ea7		b5 08		lda $08,x	                lda 8,x
.9ea9		75 00		adc $00,x	                adc 0,x
.9eab		85 24		sta $24		                sta tmp1
.9ead		b5 09		lda $09,x	                lda 9,x
.9eaf		75 01		adc $01,x	                adc 1,x
.9eb1		85 25		sta $25		                sta tmp1+1
.9eb3		b5 04		lda $04,x	                lda 4,x
.9eb5		85 26		sta $26		                sta tmp2
.9eb7		b5 05		lda $05,x	                lda 5,x
.9eb9		85 27		sta $27		                sta tmp2+1
.9ebb		b5 02		lda $02,x	                lda 2,x
.9ebd		85 28		sta $28		                sta tmp3
.9ebf		b5 03		lda $03,x	                lda 3,x
.9ec1		85 29		sta $29		                sta tmp3+1
.9ec3						_comparison_loop:
.9ec3		b2 24		lda ($24)	                lda (tmp1)
.9ec5		d2 26		cmp ($26)	                cmp (tmp2)
.9ec7		f0 05		beq $9ece	                beq _letters_match
.9ec9		20 d1 97	jsr $97d1	                jsr xt_one_plus
.9ecc		80 b7		bra $9e85	                bra _search_loop
.9ece						_letters_match:
.9ece		e6 24		inc $24		                inc tmp1
.9ed0		d0 02		bne $9ed4	                bne +
.9ed2		e6 25		inc $25		                inc tmp1+1
.9ed4						+
.9ed4		e6 26		inc $26		                inc tmp2
.9ed6		d0 02		bne $9eda	                bne +
.9ed8		e6 27		inc $27		                inc tmp2+1
.9eda						+
.9eda		a5 28		lda $28		                lda tmp3
.9edc		d0 02		bne $9ee0	                bne +
.9ede		c6 29		dec $29		                dec tmp3+1
.9ee0						+
.9ee0		c6 28		dec $28		                dec tmp3
.9ee2		a5 28		lda $28		                lda tmp3
.9ee4		05 29		ora $29		                ora tmp3+1
.9ee6		d0 db		bne $9ec3	                bne _comparison_loop ; Check the next letter
.9ee8		18		clc		                clc
.9ee9		b5 00		lda $00,x	                lda 0,x
.9eeb		75 08		adc $08,x	                adc 8,x
.9eed		95 08		sta $08,x	                sta 8,x
.9eef		b5 01		lda $01,x	                lda 1,x
.9ef1		75 09		adc $09,x	                adc 9,x
.9ef3		95 09		sta $09,x	                sta 9,x
.9ef5		38		sec		                sec
.9ef6		b5 06		lda $06,x	                lda 6,x
.9ef8		f5 00		sbc $00,x	                sbc 0,x
.9efa		95 06		sta $06,x	                sta 6,x
.9efc		b5 07		lda $07,x	                lda 7,x
.9efe		f5 01		sbc $01,x	                sbc 1,x
.9f00		95 07		sta $07,x	                sta 7,x
.9f02		e8		inx		                inx             ; drop offset
.9f03		e8		inx		                inx
.9f04		e8		inx		                inx             ; drop u2
.9f05		e8		inx		                inx
.9f06		a9 ff		lda #$ff	                lda #$FF
.9f08		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f0a		95 01		sta $01,x	                sta 1,x
.9f0c		60		rts		z_search:       rts
.9f0d						xt_semicolon:
.9f0d		24 20		bit $20		                bit status
.9f0f		70 11		bvs $9f22	                bvs _colonword
.9f11		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f13		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9f16		ca		dex		                dex
.9f17		ca		dex		                dex
.9f18		a5 04		lda $04		                lda workword
.9f1a		95 00		sta $00,x	                sta 0,x
.9f1c		a5 05		lda $05		                lda workword+1
.9f1e		95 01		sta $01,x	                sta 1,x
.9f20		80 45		bra $9f67	                bra _semicolon_done
.9f22						_colonword:
.9f22		a0 06		ldy #$06	                ldy #6
.9f24		a5 00		lda $00		                lda cp
.9f26		91 04		sta ($04),y	                sta (workword),y
.9f28		c8		iny		                iny
.9f29		a5 01		lda $01		                lda cp+1
.9f2b		91 04		sta ($04),y	                sta (workword),y
.9f2d		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f2f		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9f32		24 20		bit $20		                bit status
.9f34		10 26		bpl $9f5c	                bpl _new_word   ; Bit 7 is clear = new word
.9f36		ca		dex		                dex
.9f37		ca		dex		                dex
.9f38		ca		dex		                dex
.9f39		ca		dex		                dex
.9f3a		b2 04		lda ($04)	                lda (workword)
.9f3c		95 00		sta $00,x	                sta 0,x
.9f3e		74 01		stz $01,x	                stz 1,x
.9f40		a5 04		lda $04		                lda workword
.9f42		18		clc		                clc
.9f43		69 08		adc #$08	                adc #8
.9f45		95 02		sta $02,x	                sta 2,x
.9f47		a5 05		lda $05		                lda workword+1
.9f49		69 00		adc #$00	                adc #0                  ; only want carry
.9f4b		95 03		sta $03,x	                sta 3,x
.9f4d		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9f4f		20 7e d8	jsr $d87e	                jsr print_string_no_lf
.9f52		20 88 a4	jsr $a488	                jsr xt_type
.9f55		20 a3 a0	jsr $a0a3	                jsr xt_space
.9f58		a9 80		lda #$80	                lda #%10000000
.9f5a		14 20		trb $20		                trb status
.9f5c						_new_word:
.9f5c		a5 04		lda $04		                lda workword
.9f5e		85 02		sta $02		                sta dp
.9f60		a5 05		lda $05		                lda workword+1
.9f62		85 03		sta $03		                sta dp+1
.9f64		20 97 d7	jsr $d797	                jsr dp_to_current       ; Save the updated DP to the
.9f67						_semicolon_done:
.9f67		64 16		stz $16		                stz state
.9f69		64 17		stz $17		                stz state+1
.9f6b		60		rts		z_semicolon:    rts
.9f6c						xt_sign:
.9f6c		20 42 d8	jsr $d842	                jsr underflow_1
.9f6f		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9f71		30 04		bmi $9f77	                bmi _minus
.9f73		e8		inx		                inx
.9f74		e8		inx		                inx
.9f75		80 09		bra $9f80	                bra _done
.9f77						_minus:
.9f77		a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9f79		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9f7b		74 01		stz $01,x	                stz 1,x         ; paranoid
.9f7d		20 8a 91	jsr $918a	                jsr xt_hold
.9f80						_done:
.9f80		60		rts		z_sign:         rts
.9f81						xt_slash:
.9f81		a9 00		lda #$00	                lda #0
.9f83		48		pha		                pha
.9f84		80 03		bra $9f89	                bra slashmod_common
.9f86						xt_slash_mod:
.9f86		a9 ff		lda #$ff	                lda #$FF
.9f88		48		pha		                pha             ; falls through to _common
.9f89						slashmod_common:
.9f89		20 f5 a2	jsr $a2f5	                jsr xt_to_r             ; >R
.9f8c		20 31 9e	jsr $9e31	                jsr xt_s_to_d           ; S>D
.9f8f		20 46 9a	jsr $9a46	                jsr xt_r_from           ; R>
.9f92		20 5a a0	jsr $a05a	                jsr xt_sm_slash_rem     ; SM/REM
.9f95		68		pla		                pla
.9f96		d0 05		bne $9f9d	                bne _done
.9f98		20 33 a1	jsr $a133	                jsr xt_swap
.9f9b		e8		inx		                inx             ; DROP
.9f9c		e8		inx		                inx
.9f9d						_done:
.9f9d						z_slash_mod:
.9f9d		60		rts		z_slash:        rts
.9f9e						xt_slash_string:
.9f9e		20 4c d8	jsr $d84c	                jsr underflow_3
.9fa1		18		clc		                clc             ; 3OS+TOS
.9fa2		b5 00		lda $00,x	                lda 0,x
.9fa4		75 04		adc $04,x	                adc 4,x
.9fa6		95 04		sta $04,x	                sta 4,x
.9fa8		b5 01		lda $01,x	                lda 1,x
.9faa		75 05		adc $05,x	                adc 5,x
.9fac		95 05		sta $05,x	                sta 5,x
.9fae		38		sec		                sec             ; NOS-TOS
.9faf		b5 02		lda $02,x	                lda 2,x
.9fb1		f5 00		sbc $00,x	                sbc 0,x
.9fb3		95 02		sta $02,x	                sta 2,x
.9fb5		b5 03		lda $03,x	                lda 3,x
.9fb7		f5 01		sbc $01,x	                sbc 1,x
.9fb9		95 03		sta $03,x	                sta 3,x
.9fbb		e8		inx		                inx
.9fbc		e8		inx		                inx
.9fbd		60		rts		z_slash_string: rts
.9fbe						xt_sliteral:
.9fbe		20 47 d8	jsr $d847	                jsr underflow_2
.9fc1		a9 4c		lda #$4c	                lda #$4C
.9fc3		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9fc6		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9fc9		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.9fcc		8a		txa		                txa
.9fcd		38		sec		                sec
.9fce		e9 06		sbc #$06	                sbc #6
.9fd0		aa		tax		                tax
.9fd1		b5 08		lda $08,x	                lda 8,x
.9fd3		95 04		sta $04,x	                sta 4,x
.9fd5		b5 09		lda $09,x	                lda 9,x
.9fd7		95 05		sta $05,x	                sta 5,x
.9fd9		b5 06		lda $06,x	                lda 6,x
.9fdb		95 00		sta $00,x	                sta 0,x
.9fdd		b5 07		lda $07,x	                lda 7,x
.9fdf		95 01		sta $01,x	                sta 1,x
.9fe1		a5 00		lda $00		                lda cp
.9fe3		95 08		sta $08,x	                sta 8,x
.9fe5		95 02		sta $02,x	                sta 2,x
.9fe7		a5 01		lda $01		                lda cp+1
.9fe9		95 09		sta $09,x	                sta 9,x
.9feb		95 03		sta $03,x	                sta 3,x
.9fed		20 76 95	jsr $9576	                jsr xt_move
.9ff0		18		clc		                clc
.9ff1		a5 00		lda $00		                lda cp
.9ff3		75 00		adc $00,x	                adc 0,x
.9ff5		85 00		sta $00		                sta cp
.9ff7		a5 01		lda $01		                lda cp+1
.9ff9		75 01		adc $01,x	                adc 1,x
.9ffb		85 01		sta $01		                sta cp+1
.9ffd		b5 02		lda $02,x	                lda 2,x
.9fff		38		sec		                sec
.a000		e9 02		sbc #$02	                sbc #2
.a002		85 24		sta $24		                sta tmp1
.a004		b5 03		lda $03,x	                lda 3,x
.a006		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a008		85 25		sta $25		                sta tmp1+1
.a00a		a5 00		lda $00		                lda cp
.a00c		92 24		sta ($24)	                sta (tmp1)
.a00e		a0 01		ldy #$01	                ldy #1
.a010		a5 01		lda $01		                lda cp+1
.a012		91 24		sta ($24),y	                sta (tmp1),y
.a014						sliteral_const_str:
.a014		a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a016		a9 2e		lda #$2e	                lda #<sliteral_runtime
.a018		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.a01b		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a01d		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a01f		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.a022		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a024		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a026		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.a029		e8		inx		                inx
.a02a		e8		inx		                inx
.a02b		e8		inx		                inx
.a02c		e8		inx		                inx
.a02d		60		rts		z_sliteral:     rts
.a02e						sliteral_runtime:
.a02e		ca		dex		                dex
.a02f		ca		dex		                dex
.a030		ca		dex		                dex
.a031		ca		dex		                dex
.a032		68		pla		                pla
.a033		85 24		sta $24		                sta tmp1        ; LSB of address
.a035		68		pla		                pla
.a036		85 25		sta $25		                sta tmp1+1      ; MSB of address
.a038		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a03a		b1 24		lda ($24),y	                lda (tmp1),y
.a03c		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a03e		c8		iny		                iny
.a03f		b1 24		lda ($24),y	                lda (tmp1),y
.a041		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a043		c8		iny		                iny
.a044		b1 24		lda ($24),y	                lda (tmp1),y
.a046		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a048		c8		iny		                iny
.a049		b1 24		lda ($24),y	                lda (tmp1),y
.a04b		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a04d		18		clc		                clc
.a04e		a5 24		lda $24		                lda tmp1
.a050		69 04		adc #$04	                adc #4
.a052		a8		tay		                tay             ; LSB
.a053		a5 25		lda $25		                lda tmp1+1
.a055		69 00		adc #$00	                adc #0          ; we only need carry
.a057		48		pha		                pha             ; MSB
.a058		5a		phy		                phy
.a059		60		rts		                rts
.a05a						xt_sm_slash_rem:
.a05a		20 4c d8	jsr $d84c	                jsr underflow_3 ; contains double number
.a05d		b5 03		lda $03,x	                lda 3,x
.a05f		48		pha		                pha
.a060		b5 01		lda $01,x	                lda 1,x
.a062		55 03		eor $03,x	                eor 3,x
.a064		48		pha		                pha
.a065		20 cd 80	jsr $80cd	                jsr xt_abs
.a068		e8		inx		                inx             ; pretend we pushed n1 to R
.a069		e8		inx		                inx
.a06a		20 4d 8a	jsr $8a4d	                jsr xt_dabs
.a06d		ca		dex		                dex
.a06e		ca		dex		                dex
.a06f		20 3f a5	jsr $a53f	                jsr xt_um_slash_mod     ; UM/MOD
.a072		68		pla		                pla
.a073		10 03		bpl $a078	                bpl +
.a075		20 d7 95	jsr $95d7	                jsr xt_negate
.a078						+
.a078		68		pla		                pla
.a079		10 07		bpl $a082	                bpl _done
.a07b		e8		inx		                inx             ; pretend we pushed quotient to R
.a07c		e8		inx		                inx
.a07d		20 d7 95	jsr $95d7	                jsr xt_negate
.a080		ca		dex		                dex
.a081		ca		dex		                dex
.a082						_done:
.a082		60		rts		z_sm_slash_rem: rts
.a083						xt_source:
.a083		ca		dex		                dex
.a084		ca		dex		                dex
.a085		a5 08		lda $08		                lda cib
.a087		95 00		sta $00,x	                sta 0,x
.a089		a5 09		lda $09		                lda cib+1
.a08b		95 01		sta $01,x	                sta 1,x
.a08d		ca		dex		                dex
.a08e		ca		dex		                dex
.a08f		a5 0a		lda $0a		                lda ciblen
.a091		95 00		sta $00,x	                sta 0,x
.a093		a5 0b		lda $0b		                lda ciblen+1
.a095		95 01		sta $01,x	                sta 1,x
.a097		60		rts		z_source:       rts
.a098						xt_source_id:
.a098		ca		dex		                dex
.a099		ca		dex		                dex
.a09a		a5 06		lda $06		                lda insrc
.a09c		95 00		sta $00,x	                sta 0,x
.a09e		a5 07		lda $07		                lda insrc+1
.a0a0		95 01		sta $01,x	                sta 1,x
.a0a2		60		rts		z_source_id:    rts
.a0a3						xt_space:
.a0a3		a9 20		lda #$20	                lda #AscSP
.a0a5		20 a9 8d	jsr $8da9	                jsr emit_a
.a0a8		60		rts		z_space:        rts
.a0a9						xt_spaces:
.a0a9		20 42 d8	jsr $d842	                jsr underflow_1
.a0ac		20 2d a7	jsr $a72d	                jsr xt_zero
.a0af		20 cc 94	jsr $94cc	                jsr xt_max
.a0b2		b5 00		lda $00,x	                lda 0,x
.a0b4		15 01		ora $01,x	                ora 1,x
.a0b6		f0 2a		beq $a0e2	                beq _done
.a0b8		b4 01		ldy $01,x	                ldy 1,x
.a0ba		d0 0c		bne $a0c8	                bne _lots_of_spaces
.a0bc		b4 00		ldy $00,x	                ldy 0,x
.a0be						_quick_loop:
.a0be		a9 20		lda #$20	                lda #AscSP
.a0c0		20 a9 8d	jsr $8da9	                jsr emit_a
.a0c3		88		dey		                dey
.a0c4		f0 1c		beq $a0e2	                beq _done
.a0c6		80 f6		bra $a0be	                bra _quick_loop
.a0c8						_lots_of_spaces:
.a0c8		b4 00		ldy $00,x	                ldy 0,x
.a0ca						_first_slow_loop:
.a0ca		f0 08		beq $a0d4	                beq _slow_outer_loop
.a0cc		a9 20		lda #$20	                lda #AscSP
.a0ce		20 a9 8d	jsr $8da9	                jsr emit_a
.a0d1		88		dey		                dey
.a0d2		80 f6		bra $a0ca	                bra _first_slow_loop
.a0d4						_slow_outer_loop:
.a0d4		a0 00		ldy #$00	                ldy #00
.a0d6						_slow_inner_loop:
.a0d6		a9 20		lda #$20	                lda #AscSP
.a0d8		20 a9 8d	jsr $8da9	                jsr emit_a
.a0db		88		dey		                dey
.a0dc		d0 f8		bne $a0d6	                bne _slow_inner_loop
.a0de		d6 01		dec $01,x	                dec 1,x
.a0e0		d0 f2		bne $a0d4	                bne _slow_outer_loop
.a0e2						_done:
.a0e2		e8		inx		                inx             ; drop
.a0e3		e8		inx		                inx
.a0e4		60		rts		z_spaces:       rts
.a0e5						xt_star:
.a0e5		20 47 d8	jsr $d847	                jsr underflow_2
.a0e8		20 81 a5	jsr $a581	                jsr xt_um_star
.a0eb		e8		inx		                inx
.a0ec		e8		inx		                inx
.a0ed		60		rts		z_star:         rts
.a0ee						xt_star_slash:
.a0ee		20 f7 a0	jsr $a0f7	                jsr xt_star_slash_mod
.a0f1		20 33 a1	jsr $a133	                jsr xt_swap
.a0f4		e8		inx		                inx
.a0f5		e8		inx		                inx
.a0f6						z_star_slash:
.a0f6		60		rts		                rts
.a0f7						xt_star_slash_mod:
.a0f7		20 4c d8	jsr $d84c	                jsr underflow_3
.a0fa		20 f5 a2	jsr $a2f5	                jsr xt_to_r
.a0fd		20 42 94	jsr $9442	                jsr xt_m_star
.a100		20 46 9a	jsr $9a46	                jsr xt_r_from
.a103		20 5a a0	jsr $a05a	                jsr xt_sm_slash_rem
.a106						z_star_slash_mod:
.a106		60		rts		                rts
.a107						xt_state:
.a107		ca		dex		                dex
.a108		ca		dex		                dex
.a109		a9 16		lda #$16	                lda #<state
.a10b		95 00		sta $00,x	                sta 0,x
.a10d		a9 00		lda #$00	                lda #>state
.a10f		95 01		sta $01,x	                sta 1,x
.a111		60		rts		z_state:        rts
.a112						xt_store:
.a112		20 47 d8	jsr $d847	                jsr underflow_2
.a115		b5 02		lda $02,x	                lda 2,x         ; LSB
.a117		81 00		sta ($00,x)	                sta (0,x)
.a119		f6 00		inc $00,x	                inc 0,x
.a11b		d0 02		bne $a11f	                bne +
.a11d		f6 01		inc $01,x	                inc 1,x
.a11f						+
.a11f		b5 03		lda $03,x	                lda 3,x         ; MSB
.a121		81 00		sta ($00,x)	                sta (0,x)
.a123		e8		inx		                inx             ; 2DROP
.a124		e8		inx		                inx
.a125		e8		inx		                inx
.a126		e8		inx		                inx
.a127		60		rts		z_store:        rts
.a128						xt_strip_underflow:
.a128		ca		dex		                dex
.a129		ca		dex		                dex
.a12a		a9 1c		lda #$1c	                lda #<uf_strip
.a12c		95 00		sta $00,x	                sta 0,x
.a12e		a9 00		lda #$00	                lda #>uf_strip
.a130		95 01		sta $01,x	                sta 1,x
.a132						z_strip_underflow:
.a132		60		rts		                rts
.a133						xt_swap:
.a133		20 47 d8	jsr $d847	                jsr underflow_2
.a136		b5 00		lda $00,x	                lda 0,x         ; LSB
.a138		b4 02		ldy $02,x	                ldy 2,x
.a13a		95 02		sta $02,x	                sta 2,x
.a13c		94 00		sty $00,x	                sty 0,x
.a13e		b5 01		lda $01,x	                lda 1,x         ; MSB
.a140		b4 03		ldy $03,x	                ldy 3,x
.a142		95 03		sta $03,x	                sta 3,x
.a144		94 01		sty $01,x	                sty 1,x
.a146		60		rts		z_swap:         rts
.a147						xt_then:
.a147		20 25 91	jsr $9125	                jsr xt_here
.a14a		20 33 a1	jsr $a133	                jsr xt_swap
.a14d		20 12 a1	jsr $a112	                jsr xt_store
.a150		60		rts		z_then:         rts
.a151						xt_thru:
.a151		20 47 d8	jsr $d847	                jsr underflow_2
.a154		b5 01		lda $01,x	                lda 1,x
.a156		48		pha		                pha
.a157		b5 00		lda $00,x	                lda 0,x
.a159		48		pha		                pha
.a15a		e8		inx		                inx
.a15b		e8		inx		                inx
.a15c						_thru_loop:
.a15c		b5 01		lda $01,x	                lda 1,x
.a15e		48		pha		                pha
.a15f		b5 00		lda $00,x	                lda 0,x
.a161		48		pha		                pha
.a162		20 68 93	jsr $9368	                jsr xt_load
.a165		68		pla		                pla
.a166		85 24		sta $24		                sta tmp1
.a168		68		pla		                pla
.a169		85 25		sta $25		                sta tmp1+1
.a16b		68		pla		                pla
.a16c		85 26		sta $26		                sta tmp2
.a16e		68		pla		                pla
.a16f		85 27		sta $27		                sta tmp2+1
.a171		c5 25		cmp $25		                cmp tmp1+1
.a173		d0 08		bne $a17d	                bne _next_screen
.a175		a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a177		c5 24		cmp $24		                cmp tmp1
.a179		d0 02		bne $a17d	                bne _next_screen
.a17b		80 18		bra $a195	                bra _done       ; We just did the last screen.
.a17d						_next_screen:
.a17d		a5 27		lda $27		                lda tmp2+1
.a17f		48		pha		                pha
.a180		a5 26		lda $26		                lda tmp2
.a182		48		pha		                pha
.a183		e6 24		inc $24		                inc tmp1
.a185		d0 02		bne $a189	                bne +
.a187		e6 25		inc $25		                inc tmp1+1
.a189						+
.a189		ca		dex		                dex
.a18a		ca		dex		                dex
.a18b		a5 24		lda $24		                lda tmp1
.a18d		95 00		sta $00,x	                sta 0,x
.a18f		a5 25		lda $25		                lda tmp1+1
.a191		95 01		sta $01,x	                sta 1,x
.a193		80 c7		bra $a15c	                bra _thru_loop
.a195						_done:
.a195		60		rts		z_thru:         rts
.a196						xt_tick:
.a196		20 93 98	jsr $9893	                jsr xt_parse_name       ; ( -- addr u )
.a199		b5 00		lda $00,x	                lda 0,x
.a19b		15 01		ora $01,x	                ora 1,x
.a19d		d0 05		bne $a1a4	                bne +
.a19f		a9 05		lda #$05	                lda #err_noname
.a1a1		4c 58 d8	jmp $d858	                jmp error
.a1a4						+
.a1a4		20 8e 8f	jsr $8f8e	                jsr xt_find_name        ; ( addr u -- nt )
.a1a7		b5 00		lda $00,x	                lda 0,x
.a1a9		15 01		ora $01,x	                ora 1,x
.a1ab		d0 05		bne $a1b2	                bne +
.a1ad		a9 08		lda #$08	                lda #err_syntax
.a1af		4c 58 d8	jmp $d858	                jmp error
.a1b2						+
.a1b2		20 95 95	jsr $9595	                jsr xt_name_to_int      ; ( nt -- xt )
.a1b5		60		rts		z_tick:         rts
.a1b6						xt_to:
.a1b6		20 96 a1	jsr $a196	                jsr xt_tick             ; ( [n] xt )
.a1b9		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a1bb		18		clc		                clc
.a1bc		69 03		adc #$03	                adc #3
.a1be		85 24		sta $24		                sta tmp1
.a1c0		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a1c2		69 00		adc #$00	                adc #0                  ; we just want the carry
.a1c4		85 25		sta $25		                sta tmp1+1
.a1c6		e8		inx		                inx
.a1c7		e8		inx		                inx                     ; ( [n] )
.a1c8		a5 16		lda $16		                lda state
.a1ca		05 17		ora $17		                ora state+1
.a1cc		f0 34		beq $a202	                beq _interpret
.a1ce		a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a1d0		a9 b5		lda #$b5	                lda #$B5
.a1d2		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.a1d5		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a1d7		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.a1da		a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a1dc		a5 24		lda $24		                lda tmp1
.a1de		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.a1e1		a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a1e3		a9 b5		lda #$b5	                lda #$B5
.a1e5		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.a1e8		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a1ea		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.a1ed		e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a1ef		d0 02		bne $a1f3	                bne +
.a1f1		e6 25		inc $25		                inc tmp1+1
.a1f3						+
.a1f3		a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a1f5		a5 24		lda $24		                lda tmp1
.a1f7		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.a1fa		a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a1fc		98		tya		                tya
.a1fd		20 f1 d6	jsr $d6f1	                jsr cmpl_word
.a200		80 0f		bra $a211	                bra _done
.a202						_interpret:
.a202		20 42 d8	jsr $d842	                jsr underflow_1
.a205		b5 00		lda $00,x	                lda 0,x
.a207		92 24		sta ($24)	                sta (tmp1)              ; LSB
.a209		a0 01		ldy #$01	                ldy #1
.a20b		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a20d		91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a20f		e8		inx		                inx                     ; DROP
.a210		e8		inx		                inx
.a211						_done:
.a211		60		rts		z_to:           rts
.a212						xt_to_body:
.a212		20 42 d8	jsr $d842	                jsr underflow_1
.a215		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( xt xt )
.a218		20 29 92	jsr $9229	                jsr xt_int_to_name      ; ( xt nt )
.a21b		f6 00		inc $00,x	                inc 0,x
.a21d		d0 02		bne $a221	                bne +
.a21f		f6 01		inc $01,x	                inc 1,x
.a221						+
.a221		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a223		29 20		and #$20	                and #HC
.a225		f0 0d		beq $a234	                beq _no_cfa
.a227		18		clc		                clc
.a228		b5 02		lda $02,x	                lda 2,x         ; LSB
.a22a		69 03		adc #$03	                adc #3
.a22c		95 02		sta $02,x	                sta 2,x
.a22e		b5 03		lda $03,x	                lda 3,x         ; MSB
.a230		69 00		adc #$00	                adc #0          ; we conly care about the carry
.a232		95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a234						_no_cfa:
.a234		e8		inx		                inx             ; get rid of the nt
.a235		e8		inx		                inx
.a236						_done:
.a236		60		rts		z_to_body:      rts
.a237						xt_to_in:
.a237		ca		dex		                dex
.a238		ca		dex		                dex
.a239		a9 0c		lda #$0c	                lda #<toin
.a23b		95 00		sta $00,x	                sta 0,x
.a23d		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a23f		95 01		sta $01,x	                sta 1,x
.a241		60		rts		z_to_in:        rts
.a242						xt_to_number:
.a242		20 51 d8	jsr $d851	                jsr underflow_4
.a245		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a247		85 36		sta $36		                sta scratch
.a249		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a24b		85 37		sta $37		                sta scratch+1
.a24d		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a24f		85 38		sta $38		                sta scratch+2
.a251		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a253		85 39		sta $39		                sta scratch+3
.a255		ca		dex		                dex
.a256		ca		dex		                dex
.a257						_loop:
.a257		a1 04		lda ($04,x)	                lda (4,x)
.a259		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a25b		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a25d		20 cc 8a	jsr $8acc	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a260		b5 00		lda $00,x	                lda 0,x
.a262		d0 04		bne $a268	                bne _digit_ok
.a264		e8		inx		                inx
.a265		e8		inx		                inx
.a266		80 67		bra $a2cf	                bra _done       ; ( ud-lo ud-hi addr u char )
.a268						_digit_ok:
.a268		b5 02		lda $02,x	                lda 2,x
.a26a		85 3a		sta $3a		                sta scratch+4
.a26c		b5 03		lda $03,x	                lda 3,x
.a26e		85 3b		sta $3b		                sta scratch+5
.a270		a5 38		lda $38		                lda scratch+2
.a272		95 02		sta $02,x	                sta 2,x         ; NOS
.a274		a5 39		lda $39		                lda scratch+3
.a276		95 03		sta $03,x	                sta 3,x
.a278		a5 18		lda $18		                lda base
.a27a		95 00		sta $00,x	                sta 0,x         ; TOS
.a27c		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a27e		20 81 a5	jsr $a581	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a281		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a283		85 3c		sta $3c		                sta scratch+6
.a285		b5 03		lda $03,x	                lda 3,x
.a287		85 3d		sta $3d		                sta scratch+7
.a289		a5 36		lda $36		                lda scratch
.a28b		95 02		sta $02,x	                sta 2,x
.a28d		a5 37		lda $37		                lda scratch+1
.a28f		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a291		a5 18		lda $18		                lda base
.a293		95 00		sta $00,x	                sta 0,x
.a295		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a297		20 81 a5	jsr $a581	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a29a		b5 00		lda $00,x	                lda 0,x
.a29c		85 38		sta $38		                sta scratch+2
.a29e		b5 01		lda $01,x	                lda 1,x
.a2a0		85 39		sta $39		                sta scratch+3
.a2a2		b5 02		lda $02,x	                lda 2,x
.a2a4		85 36		sta $36		                sta scratch
.a2a6		b5 03		lda $03,x	                lda 3,x
.a2a8		85 37		sta $37		                sta scratch+1
.a2aa		18		clc		                clc
.a2ab		a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a2ad		65 3a		adc $3a		                adc scratch+4   ; n LSB
.a2af		85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a2b1		a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a2b3		65 3b		adc $3b		                adc scratch+5   ; n MSB
.a2b5		85 37		sta $37		                sta scratch+1
.a2b7		a5 38		lda $38		                lda scratch+2   ; LSB
.a2b9		65 3c		adc $3c		                adc scratch+6
.a2bb		85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a2bd		a5 39		lda $39		                lda scratch+3   ; MSB
.a2bf		65 3d		adc $3d		                adc scratch+7
.a2c1		85 39		sta $39		                sta scratch+3
.a2c3		e8		inx		                inx
.a2c4		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a2c5		f6 04		inc $04,x	                inc 4,x
.a2c7		d0 02		bne $a2cb	                bne +
.a2c9		f6 05		inc $05,x	                inc 5,x
.a2cb						+
.a2cb		d6 02		dec $02,x	                dec 2,x
.a2cd		d0 88		bne $a257	                bne _loop
.a2cf						_done:
.a2cf		e8		inx		                inx
.a2d0		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a2d1		a5 36		lda $36		                lda scratch     ; new ud-lo
.a2d3		95 06		sta $06,x	                sta 6,x
.a2d5		a5 37		lda $37		                lda scratch+1
.a2d7		95 07		sta $07,x	                sta 7,x
.a2d9		a5 38		lda $38		                lda scratch+2
.a2db		95 04		sta $04,x	                sta 4,x
.a2dd		a5 39		lda $39		                lda scratch+3
.a2df		95 05		sta $05,x	                sta 5,x
.a2e1		60		rts		z_to_number:    rts
.a2e2						xt_to_order:
.a2e2		20 f5 a2	jsr $a2f5	                jsr xt_to_r
.a2e5		20 e7 90	jsr $90e7	                jsr xt_get_order
.a2e8		20 46 9a	jsr $9a46	                jsr xt_r_from
.a2eb		20 33 a1	jsr $a133	                jsr xt_swap
.a2ee		20 d1 97	jsr $97d1	                jsr xt_one_plus
.a2f1		20 cf 9c	jsr $9ccf	                jsr xt_set_order
.a2f4		60		rts		z_to_order:     rts
.a2f5						xt_to_r:
.a2f5		68		pla		                pla             ; LSB
.a2f6		85 2c		sta $2c		                sta tmptos
.a2f8		7a		ply		                ply             ; MSB
.a2f9		20 42 d8	jsr $d842	                jsr underflow_1
.a2fc		b5 01		lda $01,x	                lda 1,x         ; MSB
.a2fe		48		pha		                pha
.a2ff		b5 00		lda $00,x	                lda 0,x         ; LSB
.a301		48		pha		                pha
.a302		e8		inx		                inx
.a303		e8		inx		                inx
.a304		5a		phy		                phy             ; MSB
.a305		a5 2c		lda $2c		                lda tmptos
.a307		48		pha		                pha             ; LSB
.a308		60		rts		z_to_r:         rts
.a309						xt_true:
.a309		ca		dex		                dex
.a30a		ca		dex		                dex
.a30b		a9 ff		lda #$ff	                lda #$FF
.a30d		95 00		sta $00,x	                sta 0,x
.a30f		95 01		sta $01,x	                sta 1,x
.a311		60		rts		z_true:         rts
.a312						xt_tuck:
.a312		20 47 d8	jsr $d847	                jsr underflow_2
.a315		ca		dex		                dex
.a316		ca		dex		                dex
.a317		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a319		b5 02		lda $02,x	                lda 2,x
.a31b		95 04		sta $04,x	                sta 4,x
.a31d		94 02		sty $02,x	                sty 2,x
.a31f		95 00		sta $00,x	                sta 0,x
.a321		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a323		b5 03		lda $03,x	                lda 3,x
.a325		95 05		sta $05,x	                sta 5,x
.a327		94 03		sty $03,x	                sty 3,x         ; bba
.a329		95 01		sta $01,x	                sta 1,x         ; baa
.a32b		60		rts		z_tuck:         rts
.a32c						xt_assembler_wordlist:
.a32c						xt_two:
.a32c		ca		dex		                dex
.a32d		ca		dex		                dex
.a32e		a9 02		lda #$02	                lda #2
.a330		95 00		sta $00,x	                sta 0,x
.a332		74 01		stz $01,x	                stz 1,x
.a334						z_assembler_wordlist:
.a334		60		rts		z_two:          rts
.a335						xt_two_drop:
.a335		20 47 d8	jsr $d847	                jsr underflow_2
.a338		e8		inx		                inx
.a339		e8		inx		                inx
.a33a		e8		inx		                inx
.a33b		e8		inx		                inx
.a33c		60		rts		z_two_drop:     rts
.a33d						xt_two_dup:
.a33d		20 47 d8	jsr $d847	                jsr underflow_2
.a340		ca		dex		                dex
.a341		ca		dex		                dex
.a342		ca		dex		                dex
.a343		ca		dex		                dex
.a344		b5 04		lda $04,x	                lda 4,x         ; TOS
.a346		95 00		sta $00,x	                sta 0,x
.a348		b5 05		lda $05,x	                lda 5,x
.a34a		95 01		sta $01,x	                sta 1,x
.a34c		b5 06		lda $06,x	                lda 6,x         ; NOS
.a34e		95 02		sta $02,x	                sta 2,x
.a350		b5 07		lda $07,x	                lda 7,x
.a352		95 03		sta $03,x	                sta 3,x
.a354		60		rts		z_two_dup:      rts
.a355						xt_two_fetch:
.a355		20 42 d8	jsr $d842	                jsr underflow_1
.a358		b5 00		lda $00,x	                lda 0,x
.a35a		85 24		sta $24		                sta tmp1
.a35c		b4 01		ldy $01,x	                ldy 1,x
.a35e		84 25		sty $25		                sty tmp1+1
.a360		ca		dex		                dex             ; reuse one stack element
.a361		ca		dex		                dex
.a362		b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a364		95 00		sta $00,x	                sta 0,x
.a366		a0 01		ldy #$01	                ldy #1          ; copy next
.a368		b1 24		lda ($24),y	                lda (tmp1),y
.a36a		95 01		sta $01,x	                sta 1,x
.a36c		c8		iny		                iny             ; copy next
.a36d		b1 24		lda ($24),y	                lda (tmp1),y
.a36f		95 02		sta $02,x	                sta 2,x
.a371		c8		iny		                iny             ; copy next
.a372		b1 24		lda ($24),y	                lda (tmp1),y
.a374		95 03		sta $03,x	                sta 3,x
.a376		60		rts		z_two_fetch:    rts
.a377						xt_two_over:
.a377		20 51 d8	jsr $d851	                jsr underflow_4
.a37a		ca		dex		                dex
.a37b		ca		dex		                dex
.a37c		ca		dex		                dex
.a37d		ca		dex		                dex
.a37e		b5 08		lda $08,x	                lda 8,x
.a380		95 00		sta $00,x	                sta 0,x
.a382		b5 09		lda $09,x	                lda 9,x
.a384		95 01		sta $01,x	                sta 1,x
.a386		b5 0a		lda $0a,x	                lda 10,x
.a388		95 02		sta $02,x	                sta 2,x
.a38a		b5 0b		lda $0b,x	                lda 11,x
.a38c		95 03		sta $03,x	                sta 3,x
.a38e		60		rts		z_two_over:     rts
.a38f						xt_two_r_fetch:
.a38f		ca		dex		                dex
.a390		ca		dex		                dex
.a391		ca		dex		                dex
.a392		ca		dex		                dex
.a393		8a		txa		                txa
.a394		ba		tsx		                tsx
.a395		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a396		7a		ply		                ply
.a397		aa		tax		                tax
.a398		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a39b		95 00		sta $00,x	                sta 0,x
.a39d		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a3a0		95 01		sta $01,x	                sta 1,x
.a3a2		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a3a5		95 02		sta $02,x	                sta 2,x
.a3a7		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a3aa		95 03		sta $03,x	                sta 3,x
.a3ac		60		rts		z_two_r_fetch:  rts
.a3ad						xt_two_r_from:
.a3ad		68		pla		                pla                     ; LSB
.a3ae		85 24		sta $24		                sta tmp1
.a3b0		68		pla		                pla                     ; MSB
.a3b1		85 25		sta $25		                sta tmp1+1
.a3b3		ca		dex		                dex
.a3b4		ca		dex		                dex
.a3b5		ca		dex		                dex
.a3b6		ca		dex		                dex
.a3b7		68		pla		                pla                     ; LSB
.a3b8		95 00		sta $00,x	                sta 0,x
.a3ba		68		pla		                pla                     ; MSB
.a3bb		95 01		sta $01,x	                sta 1,x
.a3bd		68		pla		                pla                     ; LSB
.a3be		95 02		sta $02,x	                sta 2,x
.a3c0		68		pla		                pla                     ; MSB
.a3c1		95 03		sta $03,x	                sta 3,x
.a3c3		a5 25		lda $25		                lda tmp1+1              ; MSB
.a3c5		48		pha		                pha
.a3c6		a5 24		lda $24		                lda tmp1                ; LSB
.a3c8		48		pha		                pha
.a3c9		60		rts		z_two_r_from:   rts
.a3ca						xt_two_slash:
.a3ca		20 42 d8	jsr $d842	                jsr underflow_1
.a3cd		b5 01		lda $01,x	                lda 1,x
.a3cf		0a		asl a		                asl                     ; save the sign
.a3d0		76 01		ror $01,x	                ror 1,x
.a3d2		76 00		ror $00,x	                ror 0,x
.a3d4		60		rts		z_two_slash:    rts
.a3d5						xt_two_star:
.a3d5						xt_cells:
.a3d5		20 42 d8	jsr $d842	                jsr underflow_1
.a3d8		16 00		asl $00,x	                asl 0,x
.a3da		36 01		rol $01,x	                rol 1,x
.a3dc						z_cells:
.a3dc		60		rts		z_two_star:     rts
.a3dd						xt_two_store:
.a3dd		20 4c d8	jsr $d84c	                jsr underflow_3
.a3e0		b5 00		lda $00,x	                lda 0,x
.a3e2		85 24		sta $24		                sta tmp1
.a3e4		b4 01		ldy $01,x	                ldy 1,x
.a3e6		84 25		sty $25		                sty tmp1+1
.a3e8		e8		inx		                inx
.a3e9		e8		inx		                inx
.a3ea		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a3ec		92 24		sta ($24)	                sta (tmp1)
.a3ee		b5 01		lda $01,x	                lda 1,x         ; copy next
.a3f0		a0 01		ldy #$01	                ldy #1
.a3f2		91 24		sta ($24),y	                sta (tmp1),y
.a3f4		b5 02		lda $02,x	                lda 2,x         ; copy next
.a3f6		c8		iny		                iny
.a3f7		91 24		sta ($24),y	                sta (tmp1),y
.a3f9		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a3fb		c8		iny		                iny
.a3fc		91 24		sta ($24),y	                sta (tmp1),y
.a3fe		e8		inx		                inx             ; 2DROP
.a3ff		e8		inx		                inx
.a400		e8		inx		                inx
.a401		e8		inx		                inx
.a402		60		rts		z_two_store:    rts
.a403						xt_two_swap:
.a403		20 51 d8	jsr $d851	                jsr underflow_4
.a406		b5 00		lda $00,x	                lda 0,x
.a408		b4 04		ldy $04,x	                ldy 4,x
.a40a		95 04		sta $04,x	                sta 4,x
.a40c		94 00		sty $00,x	                sty 0,x
.a40e		b5 01		lda $01,x	                lda 1,x
.a410		b4 05		ldy $05,x	                ldy 5,x
.a412		95 05		sta $05,x	                sta 5,x
.a414		94 01		sty $01,x	                sty 1,x
.a416		b5 02		lda $02,x	                lda 2,x
.a418		b4 06		ldy $06,x	                ldy 6,x
.a41a		95 06		sta $06,x	                sta 6,x
.a41c		94 02		sty $02,x	                sty 2,x
.a41e		b5 03		lda $03,x	                lda 3,x
.a420		b4 07		ldy $07,x	                ldy 7,x
.a422		95 07		sta $07,x	                sta 7,x
.a424		94 03		sty $03,x	                sty 3,x
.a426		60		rts		z_two_swap:     rts
.a427						xt_two_to_r:
.a427		68		pla		                pla             ; LSB
.a428		85 24		sta $24		                sta tmp1
.a42a		68		pla		                pla             ; MSB
.a42b		85 25		sta $25		                sta tmp1+1
.a42d		20 47 d8	jsr $d847	                jsr underflow_2
.a430		b5 03		lda $03,x	                lda 3,x         ; MSB
.a432		48		pha		                pha
.a433		b5 02		lda $02,x	                lda 2,x         ; LSB
.a435		48		pha		                pha
.a436		b5 01		lda $01,x	                lda 1,x         ; MSB
.a438		48		pha		                pha
.a439		b5 00		lda $00,x	                lda 0,x         ; LSB
.a43b		48		pha		                pha
.a43c		e8		inx		                inx
.a43d		e8		inx		                inx
.a43e		e8		inx		                inx
.a43f		e8		inx		                inx
.a440		a5 25		lda $25		                lda tmp1+1      ; MSB
.a442		48		pha		                pha
.a443		a5 24		lda $24		                lda tmp1        ; LSB
.a445		48		pha		                pha
.a446		60		rts		z_two_to_r:     rts
.a447						xt_two_constant:
.a447		20 47 d8	jsr $d847	                jsr underflow_2
.a44a		20 30 89	jsr $8930	                jsr xt_create
.a44d		20 33 a1	jsr $a133	                jsr xt_swap
.a450		20 24 87	jsr $8724	                jsr xt_comma
.a453		20 24 87	jsr $8724	                jsr xt_comma
.a456		20 b7 8b	jsr $8bb7	                jsr does_runtime    ; does> turns into these two routines.
.a459		20 2b d7	jsr $d72b	                jsr dodoes
.a45c		20 62 8d	jsr $8d62	                jsr xt_dup
.a45f		20 33 8f	jsr $8f33	                jsr xt_fetch
.a462		20 33 a1	jsr $a133	                jsr xt_swap
.a465		20 d7 85	jsr $85d7	                jsr xt_cell_plus
.a468		20 33 8f	jsr $8f33	                jsr xt_fetch
.a46b		60		rts		z_two_constant: rts
.a46c						xt_two_literal:
.a46c		20 47 d8	jsr $d847	                jsr underflow_2 ; double number
.a46f		20 33 a1	jsr $a133	                jsr xt_swap
.a472		20 3b 93	jsr $933b	                jsr xt_literal
.a475		20 3b 93	jsr $933b	                jsr xt_literal
.a478		60		rts		z_two_literal:  rts
.a479						xt_two_variable:
.a479		20 30 89	jsr $8930	                jsr xt_create
.a47c		ca		dex		                dex
.a47d		ca		dex		                dex
.a47e		a9 04		lda #$04	                lda #4
.a480		95 00		sta $00,x	                sta 0,x
.a482		74 01		stz $01,x	                stz 1,x
.a484		20 3f 82	jsr $823f	                jsr xt_allot
.a487		60		rts		z_two_variable: rts
.a488						xt_type:
.a488		20 47 d8	jsr $d847	                jsr underflow_2
.a48b		b5 02		lda $02,x	                lda 2,x
.a48d		85 24		sta $24		                sta tmp1
.a48f		b5 03		lda $03,x	                lda 3,x
.a491		85 25		sta $25		                sta tmp1+1
.a493						_loop:
.a493		b5 00		lda $00,x	                lda 0,x
.a495		15 01		ora $01,x	                ora 1,x
.a497		f0 15		beq $a4ae	                beq _done
.a499		b2 24		lda ($24)	                lda (tmp1)
.a49b		20 a9 8d	jsr $8da9	                jsr emit_a      ; avoids stack foolery
.a49e		e6 24		inc $24		                inc tmp1
.a4a0		d0 02		bne $a4a4	                bne +
.a4a2		e6 25		inc $25		                inc tmp1+1
.a4a4						+
.a4a4		b5 00		lda $00,x	                lda 0,x
.a4a6		d0 02		bne $a4aa	                bne +
.a4a8		d6 01		dec $01,x	                dec 1,x
.a4aa						+
.a4aa		d6 00		dec $00,x	                dec 0,x
.a4ac		80 e5		bra $a493	                bra _loop
.a4ae						_done:
.a4ae		e8		inx		                inx
.a4af		e8		inx		                inx
.a4b0		e8		inx		                inx
.a4b1		e8		inx		                inx
.a4b2		60		rts		z_type:         rts
.a4b3						xt_u_dot:
.a4b3		20 42 d8	jsr $d842	                jsr underflow_1
.a4b6		20 af d8	jsr $d8af	                jsr print_u
.a4b9		a9 20		lda #$20	                lda #AscSP
.a4bb		20 a9 8d	jsr $8da9	                jsr emit_a
.a4be		60		rts		z_u_dot:        rts
.a4bf						xt_u_dot_r:
.a4bf		20 47 d8	jsr $d847	                jsr underflow_2
.a4c2		20 f5 a2	jsr $a2f5	                jsr xt_to_r
.a4c5		20 2d a7	jsr $a72d	                jsr xt_zero
.a4c8		20 0b 93	jsr $930b	                jsr xt_less_number_sign
.a4cb		20 92 97	jsr $9792	                jsr xt_number_sign_s
.a4ce		20 70 97	jsr $9770	                jsr xt_number_sign_greater
.a4d1		20 46 9a	jsr $9a46	                jsr xt_r_from
.a4d4		20 47 98	jsr $9847	                jsr xt_over
.a4d7		20 04 95	jsr $9504	                jsr xt_minus
.a4da		20 a9 a0	jsr $a0a9	                jsr xt_spaces
.a4dd		20 88 a4	jsr $a488	                jsr xt_type
.a4e0		60		rts		z_u_dot_r:      rts
.a4e1						xt_u_greater_than:
.a4e1		20 47 d8	jsr $d847	                jsr underflow_2
.a4e4		b5 00		lda $00,x	                lda 0,x
.a4e6		d5 02		cmp $02,x	                cmp 2,x
.a4e8		b5 01		lda $01,x	                lda 1,x
.a4ea		f5 03		sbc $03,x	                sbc 3,x
.a4ec		e8		inx		                inx
.a4ed		e8		inx		                inx
.a4ee		a9 00		lda #$00	                lda #0
.a4f0		69 ff		adc #$ff	                adc #$ff
.a4f2		95 00		sta $00,x	                sta 0,x         ; store flag
.a4f4		95 01		sta $01,x	                sta 1,x
.a4f6		60		rts		z_u_greater_than:    rts
.a4f7						xt_u_less_than:
.a4f7		20 47 d8	jsr $d847	                jsr underflow_2
.a4fa		b5 02		lda $02,x	                lda 2,x
.a4fc		d5 00		cmp $00,x	                cmp 0,x
.a4fe		b5 03		lda $03,x	                lda 3,x
.a500		f5 01		sbc $01,x	                sbc 1,x
.a502		e8		inx		                inx
.a503		e8		inx		                inx
.a504		a9 00		lda #$00	                lda #0
.a506		69 ff		adc #$ff	                adc #$ff
.a508		95 00		sta $00,x	                sta 0,x         ; store flag
.a50a		95 01		sta $01,x	                sta 1,x
.a50c		60		rts		z_u_less_than:    rts
.a50d						xt_ud_dot:
.a50d		20 47 d8	jsr $d847	                jsr underflow_2 ; double number
.a510		20 0b 93	jsr $930b	                jsr xt_less_number_sign
.a513		20 92 97	jsr $9792	                jsr xt_number_sign_s
.a516		20 70 97	jsr $9770	                jsr xt_number_sign_greater
.a519		20 88 a4	jsr $a488	                jsr xt_type
.a51c		20 a3 a0	jsr $a0a3	                jsr xt_space
.a51f		60		rts		z_ud_dot:        rts
.a520						xt_ud_dot_r:
.a520		20 4c d8	jsr $d84c	                jsr underflow_3
.a523		20 f5 a2	jsr $a2f5	                jsr xt_to_r
.a526		20 0b 93	jsr $930b	                jsr xt_less_number_sign
.a529		20 92 97	jsr $9792	                jsr xt_number_sign_s
.a52c		20 70 97	jsr $9770	                jsr xt_number_sign_greater
.a52f		20 46 9a	jsr $9a46	                jsr xt_r_from
.a532		20 47 98	jsr $9847	                jsr xt_over
.a535		20 04 95	jsr $9504	                jsr xt_minus
.a538		20 a9 a0	jsr $a0a9	                jsr xt_spaces
.a53b		20 88 a4	jsr $a488	                jsr xt_type
.a53e		60		rts		z_ud_dot_r:      rts
.a53f						xt_um_slash_mod:
.a53f		20 4c d8	jsr $d84c	                jsr underflow_3
.a542		b5 00		lda $00,x	                lda 0,x
.a544		15 01		ora $01,x	                ora 1,x
.a546		d0 05		bne $a54d	                bne _not_zero
.a548		a9 04		lda #$04	                lda #err_divzero
.a54a		4c 58 d8	jmp $d858	                jmp error
.a54d						_not_zero:
.a54d		a9 11		lda #$11	                lda #17
.a54f		85 2c		sta $2c		                sta tmptos
.a551						_loop:
.a551		36 04		rol $04,x	                rol 4,x
.a553		36 05		rol $05,x	                rol 5,x
.a555		c6 2c		dec $2c		                dec tmptos
.a557		f0 22		beq $a57b	                beq _done
.a559		36 02		rol $02,x	                rol 2,x
.a55b		36 03		rol $03,x	                rol 3,x
.a55d		64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a55f		26 24		rol $24		                rol tmp1
.a561		38		sec		                sec
.a562		b5 02		lda $02,x	                lda 2,x
.a564		f5 00		sbc $00,x	                sbc 0,x
.a566		85 25		sta $25		                sta tmp1+1
.a568		b5 03		lda $03,x	                lda 3,x
.a56a		f5 01		sbc $01,x	                sbc 1,x
.a56c		a8		tay		                tay
.a56d		a5 24		lda $24		                lda tmp1
.a56f		e9 00		sbc #$00	                sbc #0
.a571		90 de		bcc $a551	                bcc _loop
.a573		a5 25		lda $25		                lda tmp1+1
.a575		95 02		sta $02,x	                sta 2,x
.a577		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a579		80 d6		bra $a551	                bra _loop
.a57b						_done:
.a57b		e8		inx		                inx
.a57c		e8		inx		                inx
.a57d		20 33 a1	jsr $a133	                jsr xt_swap
.a580		60		rts		z_um_slash_mod: rts
.a581						xt_um_star:
.a581		20 47 d8	jsr $d847	                jsr underflow_2
.a584		18		clc		                clc
.a585		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a587		e9 00		sbc #$00	                sbc #0
.a589		85 26		sta $26		                sta tmp2
.a58b		b5 01		lda $01,x	                lda 1,x
.a58d		e9 00		sbc #$00	                sbc #0
.a58f		90 31		bcc $a5c2	                bcc _zero       ; is TOS zero?
.a591		85 27		sta $27		                sta tmp2+1
.a593		a9 00		lda #$00	                lda #0
.a595		85 24		sta $24		                sta tmp1
.a597		86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a599		ca		dex		                dex
.a59a		ca		dex		                dex
.a59b						_outer_loop:
.a59b		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a59d		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a59f						_inner_loop:
.a59f		90 0c		bcc $a5ad	                bcc _no_add
.a5a1		85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a5a3		a5 24		lda $24		                lda tmp1
.a5a5		65 26		adc $26		                adc tmp2
.a5a7		85 24		sta $24		                sta tmp1
.a5a9		a5 25		lda $25		                lda tmp1+1
.a5ab		65 27		adc $27		                adc tmp2+1
.a5ad						_no_add:
.a5ad		6a		ror a		                ror
.a5ae		66 24		ror $24		                ror tmp1
.a5b0		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a5b2		88		dey		                dey
.a5b3		d0 ea		bne $a59f	                bne _inner_loop ; go back for one more shift?
.a5b5		e8		inx		                inx
.a5b6		e4 28		cpx $28		                cpx tmp3
.a5b8		d0 e1		bne $a59b	                bne _outer_loop ; go back for eight more shifts?
.a5ba		95 01		sta $01,x	                sta 1,x
.a5bc		a5 24		lda $24		                lda tmp1
.a5be		95 00		sta $00,x	                sta 0,x
.a5c0		80 04		bra $a5c6	                bra _done
.a5c2						_zero:
.a5c2		74 02		stz $02,x	                stz 2,x
.a5c4		74 03		stz $03,x	                stz 3,x
.a5c6						_done:
.a5c6		60		rts		z_um_star:      rts
.a5c7						xt_unloop:
.a5c7		68		pla		                pla
.a5c8		68		pla		                pla
.a5c9		68		pla		                pla
.a5ca		68		pla		                pla
.a5cb		68		pla		                pla
.a5cc		68		pla		                pla
.a5cd		60		rts		z_unloop:       rts
.a5ce						xt_until:
.a5ce		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.a5d0		a9 c5		lda #$c5	                lda #<zero_branch_runtime
.a5d2		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.a5d5		20 24 87	jsr $8724	                jsr xt_comma
.a5d8		60		rts		z_until:        rts
.a5d9						xt_unused:
.a5d9		ca		dex		                dex
.a5da		ca		dex		                dex
.a5db		a9 00		lda #$00	                lda #<cp_end
.a5dd		38		sec		                sec
.a5de		e5 00		sbc $00		                sbc cp
.a5e0		95 00		sta $00,x	                sta 0,x
.a5e2		a9 7c		lda #$7c	                lda #>cp_end
.a5e4		e5 01		sbc $01		                sbc cp+1
.a5e6		95 01		sta $01,x	                sta 1,x
.a5e8		60		rts		z_unused:       rts
.a5e9						xt_update:
.a5e9		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a5eb		b1 1e		lda ($1e),y	                lda (up),y
.a5ed		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a5ef		91 1e		sta ($1e),y	                sta (up),y
.a5f1		60		rts		z_update:       rts
.a5f2						xt_useraddr:
.a5f2		ca		dex		                dex
.a5f3		ca		dex		                dex
.a5f4		a9 1e		lda #$1e	                lda #<up
.a5f6		95 00		sta $00,x	                sta 0,x
.a5f8		a9 00		lda #$00	                lda #>up
.a5fa		95 01		sta $01,x	                sta 1,x
.a5fc		60		rts		z_useraddr:     rts
.a5fd						xt_variable:
.a5fd		20 30 89	jsr $8930	                jsr xt_create
.a600		a9 00		lda #$00	                lda #0
.a602		92 00		sta ($00)	                sta (cp)
.a604		e6 00		inc $00		                inc cp
.a606		d0 02		bne $a60a	                bne +
.a608		e6 01		inc $01		                inc cp+1
.a60a						+
.a60a		92 00		sta ($00)	                sta (cp)
.a60c		e6 00		inc $00		                inc cp
.a60e		d0 02		bne $a612	                bne +
.a610		e6 01		inc $01		                inc cp+1
.a612						+
.a612		20 f8 88	jsr $88f8	                jsr adjust_z
.a615		60		rts		z_variable:     rts
.a616						xt_while:
.a616		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.a618		a9 c5		lda #$c5	                lda #<zero_branch_runtime
.a61a		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.a61d		20 25 91	jsr $9125	                jsr xt_here
.a620		20 2d a7	jsr $a72d	                jsr xt_zero
.a623		20 24 87	jsr $8724	                jsr xt_comma
.a626		20 33 a1	jsr $a133	                jsr xt_swap
.a629		60		rts		z_while:        rts
.a62a						xt_within:
.a62a		20 4c d8	jsr $d84c	                jsr underflow_3
.a62d		20 47 98	jsr $9847	                jsr xt_over
.a630		20 04 95	jsr $9504	                jsr xt_minus
.a633		20 f5 a2	jsr $a2f5	                jsr xt_to_r
.a636		20 04 95	jsr $9504	                jsr xt_minus
.a639		20 46 9a	jsr $9a46	                jsr xt_r_from
.a63c		20 f7 a4	jsr $a4f7	                jsr xt_u_less_than
.a63f		60		rts		z_within:       rts
.a640						xt_word:
.a640		20 42 d8	jsr $d842	                jsr underflow_1
.a643		a4 0c		ldy $0c		                ldy toin                ; >IN
.a645						_loop:
.a645		c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a647		f0 09		beq $a652	                beq _found_char
.a649		b1 08		lda ($08),y	                lda (cib),y
.a64b		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a64d		d0 03		bne $a652	                bne _found_char
.a64f		c8		iny		                iny
.a650		80 f3		bra $a645	                bra _loop
.a652						_found_char:
.a652		84 0c		sty $0c		                sty toin
.a654		20 ee 98	jsr $98ee	                jsr xt_parse            ; Returns ( addr u )
.a657		b5 00		lda $00,x	                lda 0,x
.a659		92 00		sta ($00)	                sta (cp)                ; Save length of string
.a65b		48		pha		                pha                     ; Keep copy of length for later
.a65c		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr u u )
.a65f		a5 00		lda $00		                lda cp
.a661		18		clc		                clc
.a662		69 01		adc #$01	                adc #1
.a664		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a666		a5 01		lda $01		                lda cp+1
.a668		69 00		adc #$00	                adc #0
.a66a		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a66c		20 76 95	jsr $9576	                jsr xt_move
.a66f		ca		dex		                dex
.a670		ca		dex		                dex
.a671		a5 00		lda $00		                lda cp
.a673		95 00		sta $00,x	                sta 0,x
.a675		a5 01		lda $01		                lda cp+1
.a677		95 01		sta $01,x	                sta 1,x
.a679		68		pla		                pla                     ; length of string
.a67a		18		clc		                clc
.a67b		65 00		adc $00		                adc cp
.a67d		85 00		sta $00		                sta cp
.a67f		a5 01		lda $01		                lda cp+1
.a681		69 00		adc #$00	                adc #0                  ; we only need the carry
.a683		85 01		sta $01		                sta cp+1
.a685		60		rts		z_word:         rts
.a686						xt_wordlist:
.a686		a0 05		ldy #$05	                ldy #num_wordlists_offset
.a688		b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a68a		c9 0c		cmp #$0c	                cmp #max_wordlists
.a68c		d0 05		bne $a693	                bne _ok
.a68e		a9 0b		lda #$0b	                lda #err_wordlist
.a690		4c 58 d8	jmp $d858	                jmp error
.a693						_ok:
.a693		1a		inc a		                ina             ; Increment the wordlist#
.a694		91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a696		ca		dex		                dex             ; and put it on the stack.
.a697		ca		dex		                dex
.a698		95 00		sta $00,x	                sta 0,x
.a69a		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a69c		60		rts		z_wordlist:     rts
.a69d						xt_words:
.a69d		20 2a 89	jsr $892a	                jsr xt_cr
.a6a0		a9 00		lda #$00	                lda #0
.a6a2		48		pha		                pha
.a6a3		ca		dex		                dex                     ; Make room on the stack for
.a6a4		ca		dex		                dex                     ; a dictionary pointer.
.a6a5		64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a6a7						_wordlist_loop:
.a6a7		a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a6a9		a5 28		lda $28		                lda tmp3
.a6ab		d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a6ad		d0 02		bne $a6b1	                bne _have_wordlist
.a6af		80 45		bra $a6f6	                bra _words_done
.a6b1						_have_wordlist:
.a6b1		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a6b2		69 1f		adc #$1f	                adc #search_order_offset
.a6b4		a8		tay		                tay
.a6b5		b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a6b7		0a		asl a		                asl                     ; Turn offset into cells offset.
.a6b8		18		clc		                clc
.a6b9		69 06		adc #$06	                adc #wordlists_offset
.a6bb		a8		tay		                tay
.a6bc		b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a6be		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a6c0		c8		iny		                iny
.a6c1		b1 1e		lda ($1e),y	                lda (up),y
.a6c3		95 01		sta $01,x	                sta 1,x
.a6c5						_loop:
.a6c5		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.a6c8		20 b2 95	jsr $95b2	                jsr xt_name_to_string   ; ( nt addr u )
.a6cb		68		pla		                pla
.a6cc		18		clc		                clc
.a6cd		75 00		adc $00,x	                adc 0,x
.a6cf		1a		inc a		                ina                     ; don't forget the space between words
.a6d0		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a6d2		90 06		bcc $a6da	                bcc +
.a6d4		20 2a 89	jsr $892a	                jsr xt_cr
.a6d7		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a6d9		1a		inc a		                ina                     ; with length of this word.
.a6da						+
.a6da		48		pha		                pha
.a6db		20 88 a4	jsr $a488	                jsr xt_type             ; ( nt )
.a6de		a9 20		lda #$20	                lda #AscSP
.a6e0		20 a9 8d	jsr $8da9	                jsr emit_a
.a6e3		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+
.a6e6		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+
.a6e9		20 33 8f	jsr $8f33	                jsr xt_fetch            ; @ ( nt+1 )
.a6ec		b5 00		lda $00,x	                lda 0,x
.a6ee		15 01		ora $01,x	                ora 1,x
.a6f0		d0 d3		bne $a6c5	                bne _loop
.a6f2		e6 28		inc $28		                inc tmp3
.a6f4		80 b1		bra $a6a7	                bra _wordlist_loop
.a6f6						_words_done:
.a6f6		68		pla		                pla                     ; dump counter
.a6f7		e8		inx		                inx
.a6f8		e8		inx		                inx
.a6f9		60		rts		z_words:        rts
.a6fa						xt_wordsize:
.a6fa		20 42 d8	jsr $d842	                jsr underflow_1
.a6fd		b5 00		lda $00,x	                lda 0,x
.a6ff		85 24		sta $24		                sta tmp1
.a701		b5 01		lda $01,x	                lda 1,x
.a703		85 25		sta $25		                sta tmp1+1
.a705		a0 06		ldy #$06	                ldy #6
.a707		b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a709		88		dey		                dey
.a70a		88		dey		                dey
.a70b		38		sec		                sec
.a70c		f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a70e		95 00		sta $00,x	                sta 0,x
.a710		a0 07		ldy #$07	                ldy #7
.a712		b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a714		88		dey		                dey
.a715		88		dey		                dey
.a716		f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a718		95 01		sta $01,x	                sta 1,x
.a71a		60		rts		z_wordsize:     rts
.a71b						xt_xor:
.a71b		20 47 d8	jsr $d847	                jsr underflow_2
.a71e		b5 00		lda $00,x	                lda 0,x
.a720		55 02		eor $02,x	                eor 2,x
.a722		95 02		sta $02,x	                sta 2,x
.a724		b5 01		lda $01,x	                lda 1,x
.a726		55 03		eor $03,x	                eor 3,x
.a728		95 03		sta $03,x	                sta 3,x
.a72a		e8		inx		                inx
.a72b		e8		inx		                inx
.a72c		60		rts		z_xor:          rts
.a72d						xt_case:
.a72d						xt_forth_wordlist:
.a72d						xt_zero:
.a72d		ca		dex		                dex             ; push
.a72e		ca		dex		                dex
.a72f		74 00		stz $00,x	                stz 0,x
.a731		74 01		stz $01,x	                stz 1,x
.a733						z_case:
.a733						z_forth_wordlist:
.a733						z_zero:
.a733		60		rts		                rts
.a734						xt_zero_equal:
.a734		20 42 d8	jsr $d842	                jsr underflow_1
.a737		b5 00		lda $00,x	                lda 0,x
.a739		15 01		ora $01,x	                ora 1,x
.a73b		f0 02		beq $a73f	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.a73d		a9 ff		lda #$ff	                lda #$ff        ; else set A inverse of the FALSE (0) we want
.a73f						_zero:
.a73f		49 ff		eor #$ff	                eor #$ff        ; now just invert
.a741						_store:
.a741		95 00		sta $00,x	                sta 0,x
.a743		95 01		sta $01,x	                sta 1,x
.a745		60		rts		z_zero_equal:   rts
.a746						xt_zero_greater:
.a746		20 42 d8	jsr $d842	                jsr underflow_1
.a749		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a74b		b5 01		lda $01,x	                lda 1,x         ; MSB
.a74d		30 05		bmi $a754	                bmi _done       ; TOS is negative, keep FLASE
.a74f		15 00		ora $00,x	                ora 0,x
.a751		f0 01		beq $a754	                beq _done       ; TOS is zero, keep FALSE
.a753		88		dey		                dey             ; TOS is postive, make true
.a754						_done:
.a754		98		tya		                tya
.a755		95 00		sta $00,x	                sta 0,x
.a757		95 01		sta $01,x	                sta 1,x
.a759		60		rts		z_zero_greater: rts
.a75a						xt_zero_less:
.a75a		20 42 d8	jsr $d842	                jsr underflow_1
.a75d		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a75f		b5 01		lda $01,x	                lda 1,x         ; MSB
.a761		10 01		bpl $a764	                bpl _done       ; TOS is positive, so keep FALSE
.a763		88		dey		                dey             ; TOS is negative, make TRUE
.a764						_done:
.a764		98		tya		                tya
.a765		95 00		sta $00,x	                sta 0,x
.a767		95 01		sta $01,x	                sta 1,x
.a769		60		rts		z_zero_less:    rts
.a76a						xt_zero_unequal:
.a76a		20 42 d8	jsr $d842	                jsr underflow_1
.a76d		b5 00		lda $00,x	                lda 0,x
.a76f		15 01		ora $01,x	                ora 1,x
.a771		f0 02		beq $a775	                beq _zero
.a773		a9 ff		lda #$ff	                lda #$ff
.a775						_zero:
.a775		95 00		sta $00,x	                sta 0,x
.a777		95 01		sta $01,x	                sta 1,x
.a779		60		rts		z_zero_unequal: rts
.a77a						xt_editor_screen_helper:
.a77a		20 62 8d	jsr $8d62	                jsr xt_dup
.a77d		20 5e 9e	jsr $9e5e	                jsr xt_scr
.a780		20 12 a1	jsr $a112	                jsr xt_store
.a783		20 6b 85	jsr $856b	                jsr xt_buffer
.a786						z_editor_screen_helper:
.a786		60		rts		                rts
.a787						xt_editor_enter_screen:
.a787		20 7a a7	jsr $a77a	                jsr xt_editor_screen_helper
.a78a		20 e1 8c	jsr $8ce1	                jsr xt_drop
.a78d		64 2e		stz $2e		                stz editor1
.a78f						_prompt_loop:
.a78f		ca		dex		                dex
.a790		ca		dex		                dex
.a791		a5 2e		lda $2e		                lda editor1
.a793		95 00		sta $00,x	                sta 0,x
.a795		74 01		stz $01,x	                stz 1,x
.a797		20 5c a8	jsr $a85c	                jsr xt_editor_o
.a79a		e6 2e		inc $2e		                inc editor1
.a79c		a9 10		lda #$10	                lda #16
.a79e		c5 2e		cmp $2e		                cmp editor1
.a7a0		d0 ed		bne $a78f	                bne _prompt_loop
.a7a2						z_editor_enter_screen:
.a7a2		60		rts		                rts
.a7a3						xt_editor_erase_screen:
.a7a3		20 7a a7	jsr $a77a	                jsr xt_editor_screen_helper
.a7a6		ca		dex		                dex
.a7a7		ca		dex		                dex
.a7a8		74 00		stz $00,x	                stz 0,x
.a7aa		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a7ac		95 01		sta $01,x	                sta 1,x
.a7ae		20 9d 8e	jsr $8e9d	                jsr xt_blank
.a7b1		20 e9 a5	jsr $a5e9	                jsr xt_update
.a7b4						z_editor_erase_screen:
.a7b4		60		rts		                rts
.a7b5						xt_editor_el:
.a7b5		20 43 a8	jsr $a843	                jsr xt_editor_line
.a7b8		ca		dex		                dex
.a7b9		ca		dex		                dex
.a7ba		a9 40		lda #$40	                lda #64
.a7bc		95 00		sta $00,x	                sta 0,x
.a7be		74 01		stz $01,x	                stz 1,x
.a7c0		20 9d 8e	jsr $8e9d	                jsr xt_blank
.a7c3		20 e9 a5	jsr $a5e9	                jsr xt_update
.a7c6		60		rts		z_editor_el:    rts
.a7c7						xt_editor_l:
.a7c7		ca		dex		                dex             ; Put SCR on the stack.
.a7c8		ca		dex		                dex
.a7c9		a0 02		ldy #$02	                ldy #scr_offset
.a7cb		b1 1e		lda ($1e),y	                lda (up),y
.a7cd		95 00		sta $00,x	                sta 0,x
.a7cf		c8		iny		                iny
.a7d0		b1 1e		lda ($1e),y	                lda (up),y
.a7d2		95 01		sta $01,x	                sta 1,x
.a7d4		20 77 83	jsr $8377	                jsr xt_block    ; Get the current screen.
.a7d7		20 2a 89	jsr $892a	                jsr xt_cr
.a7da		80 08		bra $a7e4	                bra _after_screen_msg
.a7dc						_screen_msg:
>a7dc		53 63 72 65 65 6e 20 23		                .text "Screen #"
.a7e4						_after_screen_msg:
.a7e4		20 2e a0	jsr $a02e	                jsr sliteral_runtime
>a7e7		dc a7 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a7eb		20 88 a4	jsr $a488	                jsr xt_type
.a7ee		20 5e 9e	jsr $9e5e	                jsr xt_scr
.a7f1		20 33 8f	jsr $8f33	                jsr xt_fetch
.a7f4		ca		dex		                dex
.a7f5		ca		dex		                dex
.a7f6		a9 04		lda #$04	                lda #4          ; four spaces
.a7f8		95 00		sta $00,x	                sta 0,x
.a7fa		74 01		stz $01,x	                stz 1,x
.a7fc		20 bf a4	jsr $a4bf	                jsr xt_u_dot_r
.a7ff		64 28		stz $28		                stz tmp3
.a801						_line_loop:
.a801		20 2a 89	jsr $892a	                jsr xt_cr
.a804		ca		dex		                dex
.a805		ca		dex		                dex
.a806		ca		dex		                dex
.a807		ca		dex		                dex
.a808		74 03		stz $03,x	                stz 3,x
.a80a		a5 28		lda $28		                lda tmp3
.a80c		95 02		sta $02,x	                sta 2,x
.a80e		74 01		stz $01,x	                stz 1,x
.a810		a9 02		lda #$02	                lda #2
.a812		95 00		sta $00,x	                sta 0,x
.a814		20 bf a4	jsr $a4bf	                jsr xt_u_dot_r
.a817		20 a3 a0	jsr $a0a3	                jsr xt_space
.a81a		20 62 8d	jsr $8d62	                jsr xt_dup
.a81d		ca		dex		                dex
.a81e		ca		dex		                dex
.a81f		a9 40		lda #$40	                lda #64
.a821		95 00		sta $00,x	                sta 0,x
.a823		74 01		stz $01,x	                stz 1,x
.a825		20 88 a4	jsr $a488	                jsr xt_type
.a828		18		clc		                clc
.a829		a9 40		lda #$40	                lda #64
.a82b		75 00		adc $00,x	                adc 0,x
.a82d		95 00		sta $00,x	                sta 0,x
.a82f		b5 01		lda $01,x	                lda 1,x
.a831		69 00		adc #$00	                adc #0      ; Add carry
.a833		95 01		sta $01,x	                sta 1,x
.a835		e6 28		inc $28		                inc tmp3
.a837		a5 28		lda $28		                lda tmp3
.a839		c9 10		cmp #$10	                cmp #16
.a83b		d0 c4		bne $a801	                bne _line_loop
.a83d		20 2a 89	jsr $892a	                jsr xt_cr
.a840		e8		inx		                inx
.a841		e8		inx		                inx
.a842		60		rts		z_editor_l:            rts
.a843						xt_editor_line:
.a843		20 42 d8	jsr $d842	                jsr underflow_1
.a846		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a848						_shift_tos_left:
.a848		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a84a		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a84c		88		dey		                dey
.a84d		d0 f9		bne $a848	                bne _shift_tos_left
.a84f		20 5e 9e	jsr $9e5e	                jsr xt_scr
.a852		20 33 8f	jsr $8f33	                jsr xt_fetch
.a855		20 77 83	jsr $8377	                jsr xt_block
.a858		20 97 99	jsr $9997	                jsr xt_plus
.a85b		60		rts		z_editor_line:  rts
.a85c						xt_editor_o:
.a85c		20 2a 89	jsr $892a	                jsr xt_cr
.a85f		20 62 8d	jsr $8d62	                jsr xt_dup
.a862		20 2c a3	jsr $a32c	                jsr xt_two
.a865		20 bf a4	jsr $a4bf	                jsr xt_u_dot_r
.a868		20 a3 a0	jsr $a0a3	                jsr xt_space
.a86b		a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a86d		20 a9 8d	jsr $8da9	                jsr emit_a
.a870		20 a3 a0	jsr $a0a3	                jsr xt_space
.a873		20 43 a8	jsr $a843	                jsr xt_editor_line
.a876		20 62 8d	jsr $8d62	                jsr xt_dup      ; Save a copy of the line address for later.
.a879		ca		dex		                dex
.a87a		ca		dex		                dex
.a87b		a9 40		lda #$40	                lda #64         ; chars/line
.a87d		95 00		sta $00,x	                sta 0,x
.a87f		74 01		stz $01,x	                stz 1,x
.a881		20 e2 80	jsr $80e2	                jsr xt_accept
.a884		20 62 8d	jsr $8d62	                jsr xt_dup
.a887		20 22 96	jsr $9622	                jsr xt_not_rote ; -rot
.a88a		20 97 99	jsr $9997	                jsr xt_plus
.a88d		ca		dex		                dex
.a88e		ca		dex		                dex
.a88f		a9 40		lda #$40	                lda #64         ; chars/line
.a891		95 00		sta $00,x	                sta 0,x
.a893		74 01		stz $01,x	                stz 1,x
.a895		20 0b 9b	jsr $9b0b	                jsr xt_rot
.a898		20 04 95	jsr $9504	                jsr xt_minus
.a89b		20 9d 8e	jsr $8e9d	                jsr xt_blank
.a89e		20 e9 a5	jsr $a5e9	                jsr xt_update
.a8a1		60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.a8a2						cold_zp_table:
>a8a2	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>a8a4	0002	56 bc				dp:         .word dictionary_start  ; Dictionary Pointer
>a8a6	0004	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>a8a8	0006	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>a8aa	0008	00 02				cib:        .word buffer0           ; address of current input buffer
>a8ac	000a	00 00				ciblen:     .word 0                 ; length of current input buffer
>a8ae	000c	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>a8b0	000e	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>a8b2	0010	27 f0				output:     .word kernel_putc       ; vector for EMIT
>a8b4	0012	21 f0				input:      .word kernel_getc       ; vector for KEY
>a8b6	0014	00 00				havekey:    .word 0                 ; vector for KEY?
>a8b8	0016	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>a8ba	0018	0a 00				base:       .word 10                ; number radix, default decimal
>a8bc	001a	14 00				nc_limit:   .word 20                ; byte limit for Native Compile size
>a8be	001c	00 00				uf_strip:   .word 0                 ; flag to strip underflow detection code (0 off)
>a8c0	001e	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>a8c2	0020	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>a8c4	0022					tmpbranch:  .word ?         ; temporary storage for 0BRANCH, BRANCH only
>a8c6	0024					tmp1:       .word ?         ; temporary storage
>a8c8	0026					tmp2:       .word ?         ; temporary storage
>a8ca	0028					tmp3:       .word ?         ; temporary storage (especially for print)
>a8cc	002a					tmpdsp:     .word ?         ; temporary DSP (X) storage (two bytes)
>a8ce	002c					tmptos:     .word ?         ; temporary TOS storage
>a8d0	002e					editor1:    .word ?         ; temporary for editors
>a8d2	0030					editor2:    .word ?         ; temporary for editors
>a8d4	0032					editor3:    .word ?         ; temporary for editors
>a8d6	0034					tohold:     .word ?         ; pointer for formatted output
>a8d8	0036					scratch:    .word ?         ; 8 byte scratchpad (see UM/MOD)
.a8c4						cold_zp_table_end:
.a8c4						cold_user_table:
>a8c4	0000	00 00				blk_offset:             .word 0         ; BLK
>a8c6	0002	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
>a8c8	0004	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>a8c9	0005	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.a8ca	0006					wordlists_offset:
>a8ca	0006	56 bc				    .word dictionary_start              ; FORTH-WORDLIST
>a8cc	0008	9e ca				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>a8ce	000a	ee ca				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>a8d0	000c	5d ca				    .word root_dictionary_start         ; ROOT-WORDLIST
>a8d2	000e	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>a8da	0016	00 00 00 00 00 00 00 00
>a8e2	001e	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.a8e3	001f					search_order_offset:
>a8e3	001f	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>a8eb	0027	00
>a8ec	0028	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>a8ee	002a	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>a8f0	002c	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>a8f2	002e	11 85				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>a8f4	0030	11 85				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.a8f6						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0a  ; line feed
=$0d						AscCR   = $0d  ; carriage return
=$1b						AscESC  = $1b  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7f  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a8f6						assembler:
.a8f6						xt_asm_adc_h:
.a8f6		a9 69		lda #$69	                lda #$69
.a8f8		4c 51 ac	jmp $ac51	                jmp asm_common
.a8fb						z_asm_adc_h:
.a8fb						xt_asm_adc_x:
.a8fb		a9 7d		lda #$7d	                lda #$7D
.a8fd		4c 51 ac	jmp $ac51	                jmp asm_common
.a900						z_asm_adc_x:
.a900						xt_asm_adc_y:
.a900		a9 79		lda #$79	                lda #$79
.a902		4c 51 ac	jmp $ac51	                jmp asm_common
.a905						z_asm_adc_y:
.a905						xt_asm_adc_z:
.a905		a9 65		lda #$65	                lda #$65
.a907		4c 51 ac	jmp $ac51	                jmp asm_common
.a90a						z_asm_adc_z:
.a90a						xt_asm_adc_zi:
.a90a		a9 72		lda #$72	                lda #$72
.a90c		4c 51 ac	jmp $ac51	                jmp asm_common
.a90f						z_asm_adc_zi:
.a90f						xt_asm_adc_ziy:
.a90f		a9 71		lda #$71	                lda #$71
.a911		4c 51 ac	jmp $ac51	                jmp asm_common
.a914						z_asm_adc_ziy:
.a914						xt_asm_adc_zx:
.a914		a9 75		lda #$75	                lda #$75
.a916		4c 51 ac	jmp $ac51	                jmp asm_common
.a919						z_asm_adc_zx:
.a919						xt_asm_adc_zxi:
.a919		a9 61		lda #$61	                lda #$61
.a91b		4c 51 ac	jmp $ac51	                jmp asm_common
.a91e						z_asm_adc_zxi:
.a91e						xt_asm_and:
.a91e		a9 2d		lda #$2d	                lda #$2D
.a920		4c 51 ac	jmp $ac51	                jmp asm_common
.a923						z_asm_and:
.a923						xt_asm_and_h:
.a923		a9 29		lda #$29	                lda #$29
.a925		4c 51 ac	jmp $ac51	                jmp asm_common
.a928						z_asm_and_h:
.a928						xt_asm_and_x:
.a928		a9 3d		lda #$3d	                lda #$3D
.a92a		4c 51 ac	jmp $ac51	                jmp asm_common
.a92d						z_asm_and_x:
.a92d						xt_asm_and_y:
.a92d		a9 39		lda #$39	                lda #$39
.a92f		4c 51 ac	jmp $ac51	                jmp asm_common
.a932						z_asm_and_y:
.a932						xt_asm_and_z:
.a932		a9 25		lda #$25	                lda #$25
.a934		4c 51 ac	jmp $ac51	                jmp asm_common
.a937						z_asm_and_z:
.a937						xt_asm_and_zi:
.a937		a9 32		lda #$32	                lda #$32
.a939		4c 51 ac	jmp $ac51	                jmp asm_common
.a93c						z_asm_and_zi:
.a93c						xt_asm_and_ziy:
.a93c		a9 31		lda #$31	                lda #$31
.a93e		4c 51 ac	jmp $ac51	                jmp asm_common
.a941						z_asm_and_ziy:
.a941						xt_asm_and_zx:
.a941		a9 35		lda #$35	                lda #$35
.a943		4c 51 ac	jmp $ac51	                jmp asm_common
.a946						z_asm_and_zx:
.a946						xt_asm_and_zxi:
.a946		a9 21		lda #$21	                lda #$21
.a948		4c 51 ac	jmp $ac51	                jmp asm_common
.a94b						z_asm_and_zxi:
.a94b						xt_asm_asl:
.a94b		a9 0e		lda #$0e	                lda #$0E
.a94d		4c 51 ac	jmp $ac51	                jmp asm_common
.a950						z_asm_asl:
.a950						xt_asm_asl_a:
.a950		a9 0a		lda #$0a	                lda #$0A
.a952		4c 51 ac	jmp $ac51	                jmp asm_common
.a955						z_asm_asl_a:
.a955						xt_asm_asl_x:
.a955		a9 1e		lda #$1e	                lda #$1E
.a957		4c 51 ac	jmp $ac51	                jmp asm_common
.a95a						z_asm_asl_x:
.a95a						xt_asm_asl_z:
.a95a		a9 06		lda #$06	                lda #$06
.a95c		4c 51 ac	jmp $ac51	                jmp asm_common
.a95f						z_asm_asl_z:
.a95f						xt_asm_asl_zx:
.a95f		a9 16		lda #$16	                lda #$16
.a961		4c 51 ac	jmp $ac51	                jmp asm_common
.a964						z_asm_asl_zx:
.a964						xt_asm_bcc:
.a964		a9 90		lda #$90	                lda #$90
.a966		4c 51 ac	jmp $ac51	                jmp asm_common
.a969						z_asm_bcc:
.a969						xt_asm_bcs:
.a969		a9 b0		lda #$b0	                lda #$B0
.a96b		a0 02		ldy #$02	                ldy #2
.a96d		4c 51 ac	jmp $ac51	                jmp asm_common
.a970						z_asm_bcs:
.a970						xt_asm_beq:
.a970		a9 f0		lda #$f0	                lda #$F0
.a972		4c 51 ac	jmp $ac51	                jmp asm_common
.a975						z_asm_beq:
.a975						xt_asm_bit:
.a975		a9 2c		lda #$2c	                lda #$2C
.a977		4c 51 ac	jmp $ac51	                jmp asm_common
.a97a						z_asm_bit:
.a97a						xt_asm_bit_h:
.a97a		a9 89		lda #$89	                lda #$89
.a97c		4c 51 ac	jmp $ac51	                jmp asm_common
.a97f						z_asm_bit_h:
.a97f						xt_asm_bit_x:
.a97f		a9 3c		lda #$3c	                lda #$3C
.a981		4c 51 ac	jmp $ac51	                jmp asm_common
.a984						z_asm_bit_x:
.a984						xt_asm_bit_z:
.a984		a9 24		lda #$24	                lda #$24
.a986		4c 51 ac	jmp $ac51	                jmp asm_common
.a989						z_asm_bit_z:
.a989						xt_asm_bit_zx:
.a989		a9 34		lda #$34	                lda #$34
.a98b		4c 51 ac	jmp $ac51	                jmp asm_common
.a98e						z_asm_bit_zx:
.a98e						xt_asm_bmi:
.a98e		a9 30		lda #$30	                lda #$30
.a990		4c 51 ac	jmp $ac51	                jmp asm_common
.a993						z_asm_bmi:
.a993						xt_asm_bne:
.a993		a9 d0		lda #$d0	                lda #$D0
.a995		4c 51 ac	jmp $ac51	                jmp asm_common
.a998						z_asm_bne:
.a998						xt_asm_bpl:
.a998		a9 10		lda #$10	                lda #$10
.a99a		4c 51 ac	jmp $ac51	                jmp asm_common
.a99d						z_asm_bpl:
.a99d						xt_asm_bra:
.a99d		a9 80		lda #$80	                lda #$80
.a99f		4c 51 ac	jmp $ac51	                jmp asm_common
.a9a2						z_asm_bra:
.a9a2						xt_asm_brk:
.a9a2		a9 00		lda #$00	                lda #$00
.a9a4		4c 51 ac	jmp $ac51	                jmp asm_common
.a9a7						z_asm_brk:
.a9a7						xt_asm_bvc:
.a9a7		a9 50		lda #$50	                lda #$50
.a9a9		4c 51 ac	jmp $ac51	                jmp asm_common
.a9ac						z_asm_bvc:
.a9ac						xt_asm_bvs:
.a9ac		a9 70		lda #$70	                lda #$70
.a9ae		4c 51 ac	jmp $ac51	                jmp asm_common
.a9b1						z_asm_bvs:
.a9b1						xt_asm_clc:
.a9b1		a9 18		lda #$18	                lda #$18
.a9b3		4c 51 ac	jmp $ac51	                jmp asm_common
.a9b6						z_asm_clc:
.a9b6						xt_asm_cld:
.a9b6		a9 d8		lda #$d8	                lda #$D8
.a9b8		4c 51 ac	jmp $ac51	                jmp asm_common
.a9bb						z_asm_cld:
.a9bb						xt_asm_cli:
.a9bb		a9 58		lda #$58	                lda #$58
.a9bd		4c 51 ac	jmp $ac51	                jmp asm_common
.a9c0						z_asm_cli:
.a9c0						xt_asm_clv:
.a9c0		a9 b8		lda #$b8	                lda #$B8
.a9c2		4c 51 ac	jmp $ac51	                jmp asm_common
.a9c5						z_asm_clv:
.a9c5						xt_asm_cmp:
.a9c5		a9 cd		lda #$cd	                lda #$CD
.a9c7		4c 51 ac	jmp $ac51	                jmp asm_common
.a9ca						z_asm_cmp:
.a9ca						xt_asm_cmp_h:
.a9ca		a9 c9		lda #$c9	                lda #$C9
.a9cc		4c 51 ac	jmp $ac51	                jmp asm_common
.a9cf						z_asm_cmp_h:
.a9cf						xt_asm_cmp_x:
.a9cf		a9 dd		lda #$dd	                lda #$DD
.a9d1		4c 51 ac	jmp $ac51	                jmp asm_common
.a9d4						z_asm_cmp_x:
.a9d4						xt_asm_cmp_y:
.a9d4		a9 d9		lda #$d9	                lda #$D9
.a9d6		4c 51 ac	jmp $ac51	                jmp asm_common
.a9d9						z_asm_cmp_y:
.a9d9						xt_asm_cmp_z:
.a9d9		a9 c5		lda #$c5	                lda #$C5
.a9db		4c 51 ac	jmp $ac51	                jmp asm_common
.a9de						z_asm_cmp_z:
.a9de						xt_asm_cmp_zi:
.a9de		a9 d2		lda #$d2	                lda #$D2
.a9e0		4c 51 ac	jmp $ac51	                jmp asm_common
.a9e3						z_asm_cmp_zi:
.a9e3						xt_asm_cmp_ziy:
.a9e3		a9 d1		lda #$d1	                lda #$D1
.a9e5		4c 51 ac	jmp $ac51	                jmp asm_common
.a9e8						z_asm_cmp_ziy:
.a9e8						xt_asm_cmp_zx:
.a9e8		a9 d5		lda #$d5	                lda #$D5
.a9ea		4c 51 ac	jmp $ac51	                jmp asm_common
.a9ed						z_asm_cmp_zx:
.a9ed						xt_asm_cmp_zxi:
.a9ed		a9 c1		lda #$c1	                lda #$C1
.a9ef		4c 51 ac	jmp $ac51	                jmp asm_common
.a9f2						z_asm_cmp_zxi:
.a9f2						xt_asm_cpx:
.a9f2		a9 ec		lda #$ec	                lda #$EC
.a9f4		4c 51 ac	jmp $ac51	                jmp asm_common
.a9f7						z_asm_cpx:
.a9f7						xt_asm_cpx_h:
.a9f7		a9 e0		lda #$e0	                lda #$E0
.a9f9		4c 51 ac	jmp $ac51	                jmp asm_common
.a9fc						z_asm_cpx_h:
.a9fc						xt_asm_cpx_z:
.a9fc		a9 e4		lda #$e4	                lda #$E4
.a9fe		4c 51 ac	jmp $ac51	                jmp asm_common
.aa01						z_asm_cpx_z:
.aa01						xt_asm_cpy:
.aa01		a9 cc		lda #$cc	                lda #$CC
.aa03		a0 03		ldy #$03	                ldy #3
.aa05		4c 51 ac	jmp $ac51	                jmp asm_common
.aa08						z_asm_cpy:
.aa08						xt_asm_cpy_h:
.aa08		a9 c0		lda #$c0	                lda #$C0
.aa0a		4c 51 ac	jmp $ac51	                jmp asm_common
.aa0d						z_asm_cpy_h:
.aa0d						xt_asm_cpy_z:
.aa0d		a9 c4		lda #$c4	                lda #$C4
.aa0f		4c 51 ac	jmp $ac51	                jmp asm_common
.aa12						z_asm_cpy_z:
.aa12						xt_asm_dec:
.aa12		a9 ce		lda #$ce	                lda #$CE
.aa14		4c 51 ac	jmp $ac51	                jmp asm_common
.aa17						z_asm_dec:
.aa17						xt_asm_dec_a:
.aa17		a9 3a		lda #$3a	                lda #$3A
.aa19		4c 51 ac	jmp $ac51	                jmp asm_common
.aa1c						z_asm_dec_a:
.aa1c						xt_asm_dec_x:
.aa1c		a9 de		lda #$de	                lda #$DE
.aa1e		4c 51 ac	jmp $ac51	                jmp asm_common
.aa21						z_asm_dec_x:
.aa21						xt_asm_dec_z:
.aa21		a9 c6		lda #$c6	                lda #$C6
.aa23		4c 51 ac	jmp $ac51	                jmp asm_common
.aa26						z_asm_dec_z:
.aa26						xt_asm_dec_zx:
.aa26		a9 d6		lda #$d6	                lda #$D6
.aa28		4c 51 ac	jmp $ac51	                jmp asm_common
.aa2b						z_asm_dec_zx:
.aa2b						xt_asm_dex:
.aa2b		a9 ca		lda #$ca	                lda #$CA
.aa2d		4c 51 ac	jmp $ac51	                jmp asm_common
.aa30						z_asm_dex:
.aa30						xt_asm_dey:
.aa30		a9 88		lda #$88	                lda #$88
.aa32		4c 51 ac	jmp $ac51	                jmp asm_common
.aa35						z_asm_dey:
.aa35						xt_asm_eor:
.aa35		a9 4d		lda #$4d	                lda #$4D
.aa37		4c 51 ac	jmp $ac51	                jmp asm_common
.aa3a						z_asm_eor:
.aa3a						xt_asm_eor_h:
.aa3a		a9 49		lda #$49	                lda #$49
.aa3c		4c 51 ac	jmp $ac51	                jmp asm_common
.aa3f						z_asm_eor_h:
.aa3f						xt_asm_eor_x:
.aa3f		a9 5d		lda #$5d	                lda #$5D
.aa41		4c 51 ac	jmp $ac51	                jmp asm_common
.aa44						z_asm_eor_x:
.aa44						xt_asm_eor_y:
.aa44		a9 59		lda #$59	                lda #$59
.aa46		4c 51 ac	jmp $ac51	                jmp asm_common
.aa49						z_asm_eor_y:
.aa49						xt_asm_eor_z:
.aa49		a9 45		lda #$45	                lda #$45
.aa4b		4c 51 ac	jmp $ac51	                jmp asm_common
.aa4e						z_asm_eor_z:
.aa4e						xt_asm_eor_zi:
.aa4e		a9 52		lda #$52	                lda #$52
.aa50		4c 51 ac	jmp $ac51	                jmp asm_common
.aa53						z_asm_eor_zi:
.aa53						xt_asm_eor_ziy:
.aa53		a9 51		lda #$51	                lda #$51
.aa55		4c 51 ac	jmp $ac51	                jmp asm_common
.aa58						z_asm_eor_ziy:
.aa58						xt_asm_eor_zx:
.aa58		a9 55		lda #$55	                lda #$55
.aa5a		4c 51 ac	jmp $ac51	                jmp asm_common
.aa5d						z_asm_eor_zx:
.aa5d						xt_asm_eor_zxi:
.aa5d		a9 41		lda #$41	                lda #$41
.aa5f		4c 51 ac	jmp $ac51	                jmp asm_common
.aa62						z_asm_eor_zxi:
.aa62						xt_asm_inc:
.aa62		a9 ee		lda #$ee	                lda #$EE
.aa64		4c 51 ac	jmp $ac51	                jmp asm_common
.aa67						z_asm_inc:
.aa67						xt_asm_inc_a:
.aa67		a9 1a		lda #$1a	                lda #$1A
.aa69		4c 51 ac	jmp $ac51	                jmp asm_common
.aa6c						z_asm_inc_a:
.aa6c						xt_asm_inc_x:
.aa6c		a9 fe		lda #$fe	                lda #$FE
.aa6e		4c 51 ac	jmp $ac51	                jmp asm_common
.aa71						z_asm_inc_x:
.aa71						xt_asm_inc_z:
.aa71		a9 e6		lda #$e6	                lda #$E6
.aa73		4c 51 ac	jmp $ac51	                jmp asm_common
.aa76						z_asm_inc_z:
.aa76						xt_asm_inc_zx:
.aa76		a9 f6		lda #$f6	                lda #$F6
.aa78		4c 51 ac	jmp $ac51	                jmp asm_common
.aa7b						z_asm_inc_zx:
.aa7b						xt_asm_inx:
.aa7b		a9 e8		lda #$e8	                lda #$E8
.aa7d		4c 51 ac	jmp $ac51	                jmp asm_common
.aa80						z_asm_inx:
.aa80						xt_asm_iny:
.aa80		a9 c8		lda #$c8	                lda #$C8
.aa82		4c 51 ac	jmp $ac51	                jmp asm_common
.aa85						z_asm_iny:
.aa85						xt_asm_jmp:
.aa85		a9 4c		lda #$4c	                lda #$4C
.aa87		4c 51 ac	jmp $ac51	                jmp asm_common
.aa8a						z_asm_jmp:
.aa8a						xt_asm_jmp_i:
.aa8a		a9 6c		lda #$6c	                lda #$6C
.aa8c		4c 51 ac	jmp $ac51	                jmp asm_common
.aa8f						z_asm_jmp_i:
.aa8f						xt_asm_jmp_xi:
.aa8f		a9 7c		lda #$7c	                lda #$7C
.aa91		4c 51 ac	jmp $ac51	                jmp asm_common
.aa94						z_asm_jmp_xi:
.aa94						xt_asm_jsr:
.aa94		a9 20		lda #$20	                lda #$20
.aa96		4c 51 ac	jmp $ac51	                jmp asm_common
.aa99						z_asm_jsr:
.aa99						xt_asm_lda:
.aa99		a9 ad		lda #$ad	                lda #$AD
.aa9b		4c 51 ac	jmp $ac51	                jmp asm_common
.aa9e						z_asm_lda:
.aa9e						xt_asm_lda_h:
.aa9e		a9 a9		lda #$a9	                lda #$A9
.aaa0		4c 51 ac	jmp $ac51	                jmp asm_common
.aaa3						z_asm_lda_h:
.aaa3						xt_asm_lda_x:
.aaa3		a9 bd		lda #$bd	                lda #$BD
.aaa5		4c 51 ac	jmp $ac51	                jmp asm_common
.aaa8						z_asm_lda_x:
.aaa8						xt_asm_lda_y:
.aaa8		a9 b9		lda #$b9	                lda #$B9
.aaaa		4c 51 ac	jmp $ac51	                jmp asm_common
.aaad						z_asm_lda_y:
.aaad						xt_asm_lda_z:
.aaad		a9 a5		lda #$a5	                lda #$A5
.aaaf		4c 51 ac	jmp $ac51	                jmp asm_common
.aab2						z_asm_lda_z:
.aab2						xt_asm_lda_zi:
.aab2		a9 b2		lda #$b2	                lda #$B2
.aab4		4c 51 ac	jmp $ac51	                jmp asm_common
.aab7						z_asm_lda_zi:
.aab7						xt_asm_lda_ziy:
.aab7		a9 b1		lda #$b1	                lda #$B1
.aab9		4c 51 ac	jmp $ac51	                jmp asm_common
.aabc						z_asm_lda_ziy:
.aabc						xt_asm_lda_zx:
.aabc		a9 b5		lda #$b5	                lda #$B5
.aabe		4c 51 ac	jmp $ac51	                jmp asm_common
.aac1						z_asm_lda_zx:
.aac1						xt_asm_lda_zxi:
.aac1		a9 a1		lda #$a1	                lda #$A1
.aac3		4c 51 ac	jmp $ac51	                jmp asm_common
.aac6						z_asm_lda_zxi:
.aac6						xt_asm_ldx:
.aac6		a9 ae		lda #$ae	                lda #$AE
.aac8		4c 51 ac	jmp $ac51	                jmp asm_common
.aacb						z_asm_ldx:
.aacb						xt_asm_ldx_h:
.aacb		a9 a2		lda #$a2	                lda #$A2
.aacd		4c 51 ac	jmp $ac51	                jmp asm_common
.aad0						z_asm_ldx_h:
.aad0						xt_asm_ldx_y:
.aad0		a9 be		lda #$be	                lda #$BE
.aad2		4c 51 ac	jmp $ac51	                jmp asm_common
.aad5						z_asm_ldx_y:
.aad5						xt_asm_ldx_z:
.aad5		a9 a6		lda #$a6	                lda #$A6
.aad7		4c 51 ac	jmp $ac51	                jmp asm_common
.aada						z_asm_ldx_z:
.aada						xt_asm_ldx_zy:
.aada		a9 b6		lda #$b6	                lda #$B6
.aadc		4c 51 ac	jmp $ac51	                jmp asm_common
.aadf						z_asm_ldx_zy:
.aadf						xt_asm_ldy:
.aadf		a9 ac		lda #$ac	                lda #$AC
.aae1		4c 51 ac	jmp $ac51	                jmp asm_common
.aae4						z_asm_ldy:
.aae4						xt_asm_ldy_h:
.aae4		a9 a0		lda #$a0	                lda #$A0
.aae6		4c 51 ac	jmp $ac51	                jmp asm_common
.aae9						z_asm_ldy_h:
.aae9						xt_asm_ldy_x:
.aae9		a9 bc		lda #$bc	                lda #$BC
.aaeb		4c 51 ac	jmp $ac51	                jmp asm_common
.aaee						z_asm_ldy_x:
.aaee						xt_asm_ldy_z:
.aaee		a9 a4		lda #$a4	                lda #$A4
.aaf0		4c 51 ac	jmp $ac51	                jmp asm_common
.aaf3						z_asm_ldy_z:
.aaf3						xt_asm_ldy_zx:
.aaf3		a9 b4		lda #$b4	                lda #$B4
.aaf5		4c 51 ac	jmp $ac51	                jmp asm_common
.aaf8						z_asm_ldy_zx:
.aaf8						xt_asm_lsr:
.aaf8		a9 4e		lda #$4e	                lda #$4E
.aafa		4c 51 ac	jmp $ac51	                jmp asm_common
.aafd						z_asm_lsr:
.aafd						xt_asm_lsr_a:
.aafd		a9 4a		lda #$4a	                lda #$4A
.aaff		4c 51 ac	jmp $ac51	                jmp asm_common
.ab02						z_asm_lsr_a:
.ab02						xt_asm_lsr_x:
.ab02		a9 5e		lda #$5e	                lda #$5E
.ab04		4c 51 ac	jmp $ac51	                jmp asm_common
.ab07						z_asm_lsr_x:
.ab07						xt_asm_lsr_z:
.ab07		a9 46		lda #$46	                lda #$46
.ab09		4c 51 ac	jmp $ac51	                jmp asm_common
.ab0c						z_asm_lsr_z:
.ab0c						xt_asm_lsr_zx:
.ab0c		a9 56		lda #$56	                lda #$56
.ab0e		4c 51 ac	jmp $ac51	                jmp asm_common
.ab11						z_asm_lsr_zx:
.ab11						xt_asm_nop:
.ab11		a9 ea		lda #$ea	                lda #$EA
.ab13		4c 51 ac	jmp $ac51	                jmp asm_common
.ab16						z_asm_nop:
.ab16						xt_asm_ora:
.ab16		a9 0d		lda #$0d	                lda #$0D
.ab18		4c 51 ac	jmp $ac51	                jmp asm_common
.ab1b						z_asm_ora:
.ab1b						xt_asm_ora_h:
.ab1b		a9 09		lda #$09	                lda #$09
.ab1d		4c 51 ac	jmp $ac51	                jmp asm_common
.ab20						z_asm_ora_h:
.ab20						xt_asm_ora_x:
.ab20		a9 1d		lda #$1d	                lda #$1D
.ab22		4c 51 ac	jmp $ac51	                jmp asm_common
.ab25						z_asm_ora_x:
.ab25						xt_asm_ora_y:
.ab25		a9 19		lda #$19	                lda #$19
.ab27		4c 51 ac	jmp $ac51	                jmp asm_common
.ab2a						z_asm_ora_y:
.ab2a						xt_asm_ora_z:
.ab2a		a9 05		lda #$05	                lda #$05
.ab2c		4c 51 ac	jmp $ac51	                jmp asm_common
.ab2f						z_asm_ora_z:
.ab2f						xt_asm_ora_zi:
.ab2f		a9 12		lda #$12	                lda #$12
.ab31		a0 02		ldy #$02	                ldy #2
.ab33		4c 51 ac	jmp $ac51	                jmp asm_common
.ab36						z_asm_ora_zi:
.ab36						xt_asm_ora_ziy:
.ab36		a9 11		lda #$11	                lda #$11
.ab38		4c 51 ac	jmp $ac51	                jmp asm_common
.ab3b						z_asm_ora_ziy:
.ab3b						xt_asm_ora_zx:
.ab3b		a9 15		lda #$15	                lda #$15
.ab3d		4c 51 ac	jmp $ac51	                jmp asm_common
.ab40						z_asm_ora_zx:
.ab40						xt_asm_ora_zxi:
.ab40		a9 01		lda #$01	                lda #$01
.ab42		4c 51 ac	jmp $ac51	                jmp asm_common
.ab45						z_asm_ora_zxi:
.ab45						xt_asm_pha:
.ab45		a9 48		lda #$48	                lda #$48
.ab47		4c 51 ac	jmp $ac51	                jmp asm_common
.ab4a						z_asm_pha:
.ab4a						xt_asm_php:
.ab4a		a9 08		lda #$08	                lda #$08
.ab4c		4c 51 ac	jmp $ac51	                jmp asm_common
.ab4f						z_asm_php:
.ab4f						xt_asm_phx:
.ab4f		a9 da		lda #$da	                lda #$DA
.ab51		4c 51 ac	jmp $ac51	                jmp asm_common
.ab54						z_asm_phx:
.ab54						xt_asm_phy:
.ab54		a9 5a		lda #$5a	                lda #$5A
.ab56		4c 51 ac	jmp $ac51	                jmp asm_common
.ab59						z_asm_phy:
.ab59						xt_asm_pla:
.ab59		a9 68		lda #$68	                lda #$68
.ab5b		4c 51 ac	jmp $ac51	                jmp asm_common
.ab5e						z_asm_pla:
.ab5e						xt_asm_plp:
.ab5e		a9 28		lda #$28	                lda #$28
.ab60		4c 51 ac	jmp $ac51	                jmp asm_common
.ab63						z_asm_plp:
.ab63						xt_asm_plx:
.ab63		a9 fa		lda #$fa	                lda #$FA
.ab65		4c 51 ac	jmp $ac51	                jmp asm_common
.ab68						z_asm_plx:
.ab68						xt_asm_ply:
.ab68		a9 7a		lda #$7a	                lda #$7A
.ab6a		4c 51 ac	jmp $ac51	                jmp asm_common
.ab6d						z_asm_ply:
.ab6d						xt_asm_rol:
.ab6d		a9 2e		lda #$2e	                lda #$2E
.ab6f		4c 51 ac	jmp $ac51	                jmp asm_common
.ab72						z_asm_rol:
.ab72						xt_asm_rol_a:
.ab72		a9 2a		lda #$2a	                lda #$2A
.ab74		4c 51 ac	jmp $ac51	                jmp asm_common
.ab77						z_asm_rol_a:
.ab77						xt_asm_rol_x:
.ab77		a9 3e		lda #$3e	                lda #$3E
.ab79		4c 51 ac	jmp $ac51	                jmp asm_common
.ab7c						z_asm_rol_x:
.ab7c						xt_asm_rol_z:
.ab7c		a9 26		lda #$26	                lda #$26
.ab7e		4c 51 ac	jmp $ac51	                jmp asm_common
.ab81						z_asm_rol_z:
.ab81						xt_asm_rol_zx:
.ab81		a9 36		lda #$36	                lda #$36
.ab83		4c 51 ac	jmp $ac51	                jmp asm_common
.ab86						z_asm_rol_zx:
.ab86						xt_asm_ror:
.ab86		a9 6e		lda #$6e	                lda #$6E
.ab88		4c 51 ac	jmp $ac51	                jmp asm_common
.ab8b						z_asm_ror:
.ab8b						xt_asm_ror_a:
.ab8b		a9 6a		lda #$6a	                lda #$6A
.ab8d		4c 51 ac	jmp $ac51	                jmp asm_common
.ab90						z_asm_ror_a:
.ab90						xt_asm_ror_x:
.ab90		a9 7e		lda #$7e	                lda #$7E
.ab92		4c 51 ac	jmp $ac51	                jmp asm_common
.ab95						z_asm_ror_x:
.ab95						xt_asm_ror_z:
.ab95		a9 66		lda #$66	                lda #$66
.ab97		4c 51 ac	jmp $ac51	                jmp asm_common
.ab9a						z_asm_ror_z:
.ab9a						xt_asm_ror_zx:
.ab9a		a9 76		lda #$76	                lda #$76
.ab9c		4c 51 ac	jmp $ac51	                jmp asm_common
.ab9f						z_asm_ror_zx:
.ab9f						xt_asm_rti:
.ab9f		a9 40		lda #$40	                lda #$40
.aba1		4c 51 ac	jmp $ac51	                jmp asm_common
.aba4						z_asm_rti:
.aba4						xt_asm_rts:
.aba4		a9 60		lda #$60	                lda #$60
.aba6		4c 51 ac	jmp $ac51	                jmp asm_common
.aba9						z_asm_rts:
.aba9						xt_asm_sbc:
.aba9		a9 ed		lda #$ed	                lda #$ED
.abab		4c 51 ac	jmp $ac51	                jmp asm_common
.abae						z_asm_sbc:
.abae						xt_asm_sbc_h:
.abae		a9 e9		lda #$e9	                lda #$E9
.abb0		4c 51 ac	jmp $ac51	                jmp asm_common
.abb3						z_asm_sbc_h:
.abb3						xt_asm_sbc_x:
.abb3		a9 fd		lda #$fd	                lda #$FD
.abb5		4c 51 ac	jmp $ac51	                jmp asm_common
.abb8						z_asm_sbc_x:
.abb8						xt_asm_sbc_y:
.abb8		a9 f9		lda #$f9	                lda #$F9
.abba		4c 51 ac	jmp $ac51	                jmp asm_common
.abbd						z_asm_sbc_y:
.abbd						xt_asm_sbc_z:
.abbd		a9 e5		lda #$e5	                lda #$E5
.abbf		4c 51 ac	jmp $ac51	                jmp asm_common
.abc2						z_asm_sbc_z:
.abc2						xt_asm_sbc_zi:
.abc2		a9 f2		lda #$f2	                lda #$F2
.abc4		4c 51 ac	jmp $ac51	                jmp asm_common
.abc7						z_asm_sbc_zi:
.abc7						xt_asm_sbc_ziy:
.abc7		a9 f1		lda #$f1	                lda #$F1
.abc9		4c 51 ac	jmp $ac51	                jmp asm_common
.abcc						z_asm_sbc_ziy:
.abcc						xt_asm_sbc_zx:
.abcc		a9 f5		lda #$f5	                lda #$F5
.abce		4c 51 ac	jmp $ac51	                jmp asm_common
.abd1						z_asm_sbc_zx:
.abd1						xt_asm_sbc_zxi:
.abd1		a9 e1		lda #$e1	                lda #$E1
.abd3		80 7c		bra $ac51	                bra asm_common  ; <-- limit for BRA instead of JMP
.abd5						z_asm_sbc_zxi:
.abd5						xt_asm_sec:
.abd5		a9 38		lda #$38	                lda #$38
.abd7		80 78		bra $ac51	                bra asm_common
.abd9						z_asm_sec:
.abd9						xt_asm_sed:
.abd9		a9 f8		lda #$f8	                lda #$F8
.abdb		80 74		bra $ac51	                bra asm_common
.abdd						z_asm_sed:
.abdd						xt_asm_sei:
.abdd		a9 78		lda #$78	                lda #$78
.abdf		80 70		bra $ac51	                bra asm_common
.abe1						z_asm_sei:
.abe1						xt_asm_sta:
.abe1		a9 8d		lda #$8d	                lda #$8D
.abe3		80 6c		bra $ac51	                bra asm_common
.abe5						z_asm_sta:
.abe5						xt_asm_sta_x:
.abe5		a9 9d		lda #$9d	                lda #$9D
.abe7		80 68		bra $ac51	                bra asm_common
.abe9						z_asm_sta_x:
.abe9						xt_asm_sta_y:
.abe9		a9 99		lda #$99	                lda #$99
.abeb		80 64		bra $ac51	                bra asm_common
.abed						z_asm_sta_y:
.abed						xt_asm_sta_z:
.abed		a9 85		lda #$85	                lda #$85
.abef		80 60		bra $ac51	                bra asm_common
.abf1						z_asm_sta_z:
.abf1						xt_asm_sta_zi:
.abf1		a9 92		lda #$92	                lda #$92
.abf3		80 5c		bra $ac51	                bra asm_common
.abf5						z_asm_sta_zi:
.abf5						xt_asm_sta_ziy:
.abf5		a9 91		lda #$91	                lda #$91
.abf7		80 58		bra $ac51	                bra asm_common
.abf9						z_asm_sta_ziy:
.abf9						xt_asm_sta_zx:
.abf9		a9 95		lda #$95	                lda #$95
.abfb		80 54		bra $ac51	                bra asm_common
.abfd						z_asm_sta_zx:
.abfd						xt_asm_sta_zxi:
.abfd		a9 81		lda #$81	                lda #$81
.abff		80 50		bra $ac51	                bra asm_common
.ac01						z_asm_sta_zxi:
.ac01						xt_asm_stx:
.ac01		a9 8e		lda #$8e	                lda #$8E
.ac03		80 4c		bra $ac51	                bra asm_common
.ac05						z_asm_stx:
.ac05						xt_asm_stx_z:
.ac05		a9 86		lda #$86	                lda #$86
.ac07		80 48		bra $ac51	                bra asm_common
.ac09						z_asm_stx_z:
.ac09						xt_asm_stx_zy:
.ac09		a9 96		lda #$96	                lda #$96
.ac0b		80 44		bra $ac51	                bra asm_common
.ac0d						z_asm_stx_zy:
.ac0d						xt_asm_sty:
.ac0d		a9 8c		lda #$8c	                lda #$8C
.ac0f		80 40		bra $ac51	                bra asm_common
.ac11						z_asm_sty:
.ac11						xt_asm_sty_z:
.ac11		a9 84		lda #$84	                lda #$84
.ac13		80 3c		bra $ac51	                bra asm_common
.ac15						z_asm_sty_z:
.ac15						xt_asm_sty_zx:
.ac15		a9 94		lda #$94	                lda #$94
.ac17		80 38		bra $ac51	                bra asm_common
.ac19						z_asm_sty_zx:
.ac19						xt_asm_stz:
.ac19		a9 9c		lda #$9c	                lda #$9C
.ac1b		80 34		bra $ac51	                bra asm_common
.ac1d						z_asm_stz:
.ac1d						xt_asm_stz_x:
.ac1d		a9 9e		lda #$9e	                lda #$9E
.ac1f		80 30		bra $ac51	                bra asm_common
.ac21						z_asm_stz_x:
.ac21						xt_asm_stz_z:
.ac21		a9 64		lda #$64	                lda #$64
.ac23		80 2c		bra $ac51	                bra asm_common
.ac25						z_asm_stz_z:
.ac25						xt_asm_stz_zx:
.ac25		a9 74		lda #$74	                lda #$74
.ac27		80 28		bra $ac51	                bra asm_common
.ac29						z_asm_stz_zx:
.ac29						xt_asm_tax:
.ac29		a9 aa		lda #$aa	                lda #$AA
.ac2b		80 24		bra $ac51	                bra asm_common
.ac2d						z_asm_tax:
.ac2d						xt_asm_tay:
.ac2d		a9 a8		lda #$a8	                lda #$A8
.ac2f		80 20		bra $ac51	                bra asm_common
.ac31						z_asm_tay:
.ac31						xt_asm_trb:
.ac31		a9 1c		lda #$1c	                lda #$1C
.ac33		80 1c		bra $ac51	                bra asm_common
.ac35						z_asm_trb:
.ac35						xt_asm_trb_z:
.ac35		a9 14		lda #$14	                lda #$14
.ac37		80 18		bra $ac51	                bra asm_common
.ac39						z_asm_trb_z:
.ac39						xt_asm_tsb:
.ac39		a9 0c		lda #$0c	                lda #$0C
.ac3b		80 14		bra $ac51	                bra asm_common
.ac3d						z_asm_tsb:
.ac3d						xt_asm_tsb_z:
.ac3d		a9 04		lda #$04	                lda #$04
.ac3f		80 10		bra $ac51	                bra asm_common
.ac41						z_asm_tsb_z:
.ac41						xt_asm_tsx:
.ac41		a9 ba		lda #$ba	                lda #$BA
.ac43		80 0c		bra $ac51	                bra asm_common
.ac45						z_asm_tsx:
.ac45						xt_asm_txa:
.ac45		a9 8a		lda #$8a	                lda #$8A
.ac47		80 08		bra $ac51	                bra asm_common
.ac49						z_asm_txa:
.ac49						xt_asm_txs:
.ac49		a9 9a		lda #$9a	                lda #$9A
.ac4b		80 04		bra $ac51	                bra asm_common
.ac4d						z_asm_txs:
.ac4d						xt_asm_tya:
.ac4d		a9 98		lda #$98	                lda #$98
.ac4f		80 00		bra $ac51	                bra asm_common
.ac51						z_asm_tya:
.ac51						asm_common:
.ac51		a8		tay		                tay
.ac52		20 f5 d6	jsr $d6f5	                jsr cmpl_a
.ac55		a9 fa		lda #$fa	                lda #<oc_index_table
.ac57		85 26		sta $26		                sta tmp2
.ac59		a9 ae		lda #$ae	                lda #>oc_index_table
.ac5b		85 27		sta $27		                sta tmp2+1
.ac5d		98		tya		                tya             ; retrieve opcode
.ac5e		0a		asl a		                asl             ; times two for offset
.ac5f		90 02		bcc $ac63	                bcc +
.ac61		e6 27		inc $27		                inc tmp2+1
.ac63						+
.ac63		a8		tay		                tay             ; use Y as the index
.ac64		b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac66		85 28		sta $28		                sta tmp3
.ac68		c8		iny		                iny
.ac69		b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac6b		85 29		sta $29		                sta tmp3+1
.ac6d		b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac6f		2a		rol a		                rol
.ac70		2a		rol a		                rol
.ac71		2a		rol a		                rol             ; Three times because we go through Carry
.ac72		29 03		and #$03	                and #%00000011
.ac74		a8		tay		                tay
.ac75		88		dey		                dey
.ac76		f0 12		beq $ac8a	                beq _done
.ac78		20 42 d8	jsr $d842	                jsr underflow_1
.ac7b		b5 00		lda $00,x	                lda 0,x
.ac7d		20 f5 d6	jsr $d6f5	                jsr cmpl_a      ; does not use Y
.ac80		88		dey		                dey
.ac81		f0 05		beq $ac88	                beq _done_drop
.ac83		b5 01		lda $01,x	                lda 1,x
.ac85		20 f5 d6	jsr $d6f5	                jsr cmpl_a      ; Fall through to _done_drop
.ac88						_done_drop:
.ac88		e8		inx		                inx
.ac89		e8		inx		                inx             ; Fall through to _done
.ac8a						_done:
.ac8a		60		rts		                rts             ; Returns to original caller
.ac8b						xt_asm_push_a:
.ac8b		a0 00		ldy #$00	                ldy #0
.ac8d						_loop:
.ac8d		b9 9b ac	lda $ac9b,y	                lda asm_push_a_data,y
.ac90		c9 ff		cmp #$ff	                cmp #$FF
.ac92		f0 06		beq $ac9a	                beq _done
.ac94		20 f5 d6	jsr $d6f5	                jsr cmpl_a      ; does not change Y
.ac97		c8		iny		                iny
.ac98		80 f3		bra $ac8d	                bra _loop
.ac9a						_done:
.ac9a						z_asm_push_a:
.ac9a		60		rts		                rts
.ac9b						asm_push_a_data:
>ac9b		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>aca1		ff				        .byte $FF               ; terminator
.aca2						xt_asm_back_jump:
.aca2						z_asm_back_jump:
.aca2		60		rts		                rts
.aca3						xt_asm_back_branch:
.aca3		20 25 91	jsr $9125	                jsr xt_here             ; ( addr-l addr-h )
.aca6		20 04 95	jsr $9504	                jsr xt_minus            ; ( offset )
.aca9		3a		dec a		                dea
.acaa		3a		dec a		                dea
.acab						z_asm_back_branch:
.acab		60		rts		                rts
.acac						assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acac						disassembler:
.acac		20 2a 89	jsr $892a	                jsr xt_cr       ; ( addr u )
.acaf						_byte_loop:
.acaf		20 47 98	jsr $9847	                jsr xt_over     ; ( addr u addr )
.acb2		20 b3 a4	jsr $a4b3	                jsr xt_u_dot    ; ( addr u )
.acb5		20 a3 a0	jsr $a0a3	                jsr xt_space
.acb8		a9 fa		lda #$fa	                lda #<oc_index_table
.acba		85 26		sta $26		                sta tmp2
.acbc		a9 ae		lda #$ae	                lda #>oc_index_table
.acbe		85 27		sta $27		                sta tmp2+1
.acc0		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.acc2		85 36		sta $36		                sta scratch     ; Save opcode
.acc4		0a		asl a		                asl             ; multiply by two for offset
.acc5		90 02		bcc $acc9	                bcc +
.acc7		e6 27		inc $27		                inc tmp2+1      ; we're on second page
.acc9						+
.acc9		a8		tay		                tay             ; use Y as the index
.acca		b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.accc		85 28		sta $28		                sta tmp3
.acce		48		pha		                pha
.accf		c8		iny		                iny
.acd0		b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acd2		85 29		sta $29		                sta tmp3+1
.acd4		48		pha		                pha
.acd5		b2 28		lda ($28)	                lda (tmp3)
.acd7		a8		tay		                tay                     ; save copy of lengths byte
.acd8		10 3c		bpl $ad16	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.acda		20 2d a7	jsr $a72d	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.acdd		f6 04		inc $04,x	                inc 4,x
.acdf		d0 02		bne $ace3	                bne +
.ace1		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ace3						+
.ace3		b5 02		lda $02,x	                lda 2,x
.ace5		d0 02		bne $ace9	                bne +
.ace7		d6 03		dec $03,x	                dec 3,x
.ace9						+
.ace9		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.aceb		a1 04		lda ($04,x)	                lda (4,x)
.aced		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.acef		85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.acf1		98		tya		                tya                     ; retrieve copy of lengths byte
.acf2		2a		rol a		                rol                     ; shift bit 6 to bit 7
.acf3		10 14		bpl $ad09	                bpl _print_operand
.acf5		f6 04		inc $04,x	                inc 4,x
.acf7		d0 02		bne $acfb	                bne +
.acf9		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.acfb						+
.acfb		b5 02		lda $02,x	                lda 2,x
.acfd		d0 02		bne $ad01	                bne +
.acff		d6 03		dec $03,x	                dec 3,x
.ad01						+
.ad01		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad03		a1 04		lda ($04,x)	                lda (4,x)
.ad05		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad07		85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad09						_print_operand:
.ad09		ca		dex		                dex
.ad0a		ca		dex		                dex
.ad0b		a9 05		lda #$05	                lda #5
.ad0d		95 00		sta $00,x	                sta 0,x
.ad0f		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad11		20 bf a4	jsr $a4bf	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad14		80 0b		bra $ad21	                bra _print_mnemonic
.ad16						_no_operand:
.ad16		ca		dex		                dex
.ad17		ca		dex		                dex
.ad18		a9 05		lda #$05	                lda #5
.ad1a		95 00		sta $00,x	                sta 0,x
.ad1c		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad1e		20 a9 a0	jsr $a0a9	                jsr xt_spaces           ; ( addr u )
.ad21						_print_mnemonic:
.ad21		20 a3 a0	jsr $a0a3	                jsr xt_space
.ad24		ca		dex		                dex
.ad25		ca		dex		                dex                     ; ( addr u ? )
.ad26		68		pla		                pla                     ; MSB
.ad27		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad29		68		pla		                pla                     ; LSB
.ad2a		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad2c		20 16 89	jsr $8916	                jsr xt_count            ; ( addr u addr-o u-o )
.ad2f		74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad31		b5 00		lda $00,x	                lda 0,x
.ad33		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad35		95 00		sta $00,x	                sta 0,x
.ad37		20 88 a4	jsr $a488	                jsr xt_type             ; ( addr u )
.ad3a		a5 36		lda $36		                lda scratch
.ad3c		c9 20		cmp #$20	                cmp #$20
.ad3e		d0 4e		bne $ad8e	                bne _not_jsr
.ad40		ca		dex		                dex
.ad41		ca		dex		                dex
.ad42		a9 05		lda #$05	                lda #5
.ad44		95 00		sta $00,x	                sta 0,x
.ad46		74 01		stz $01,x	                stz 1,x
.ad48		20 a9 a0	jsr $a0a9	                jsr xt_spaces
.ad4b		a0 10		ldy #$10	                ldy #(_end_handlers - _special_handlers - 4)
.ad4d		b9 7a ad	lda $ad7a,y	_check_handler: lda _special_handlers,y
.ad50		c5 37		cmp $37		                cmp scratch+1
.ad52		d0 07		bne $ad5b	                bne _next_handler
.ad54		b9 7b ad	lda $ad7b,y	                lda _special_handlers+1,y
.ad57		c5 38		cmp $38		                cmp scratch+2
.ad59		f0 0c		beq $ad67	                beq _run_handler
.ad5b		88		dey		_next_handler:  dey
.ad5c		88		dey		                dey
.ad5d		88		dey		                dey
.ad5e		88		dey		                dey
.ad5f		10 ec		bpl $ad4d	                bpl _check_handler
.ad61						_not_special:
.ad61		20 aa ae	jsr $aeaa	                jsr disasm_jsr
.ad64		4c f8 ad	jmp $adf8	                jmp _printing_done
.ad67						_run_handler:
.ad67		b9 7c ad	lda $ad7c,y	                lda _special_handlers+2,y
.ad6a		85 39		sta $39		                sta scratch+3
.ad6c		b9 7d ad	lda $ad7d,y	                lda _special_handlers+3,y
.ad6f		85 3a		sta $3a		                sta scratch+4
.ad71		20 77 ad	jsr $ad77	                jsr _dispatch_handler
.ad74		4c f8 ad	jmp $adf8	                jmp _printing_done
.ad77						_dispatch_handler:
.ad77		6c 39 00	jmp ($0039)	                jmp (scratch+3)
.ad7a						_special_handlers:
>ad7a		49 93 8c ae			    .word literal_runtime,      disasm_literal
>ad7e		2e a0 3e ae			    .word sliteral_runtime,     disasm_sliteral
>ad82		c5 91 75 ae			    .word zero_branch_runtime,  disasm_0branch
>ad86		8e 8d 7a ae			    .word branch_runtime,       disasm_branch
>ad8a		63 8b 81 ae			    .word do_runtime,           disasm_do
.ad8e						_end_handlers:
.ad8e						_not_jsr:
.ad8e		c9 4c		cmp #$4c	                cmp #$4C
.ad90		d0 2c		bne $adbe	                bne _not_jmp
.ad92		a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.ad94		85 39		sta $39		                sta scratch+3
.ad96		a5 38		lda $38		                lda scratch+2
.ad98		85 3a		sta $3a		                sta scratch+4
.ad9a		b2 39		lda ($39)	                lda (scratch+3)
.ad9c		c9 20		cmp #$20	                cmp #$20 ; check for JSR
.ad9e		d0 58		bne $adf8	                bne _printing_done
.ada0		e6 39		inc $39		                inc scratch+3
.ada2		d0 02		bne $ada6	                bne +
.ada4		e6 3a		inc $3a		                inc scratch+4
.ada6						+
.ada6		b2 39		lda ($39)	                lda (scratch+3)
.ada8		c9 2e		cmp #$2e	                cmp #<sliteral_runtime
.adaa		d0 4c		bne $adf8	                bne _printing_done
.adac		e6 39		inc $39		                inc scratch+3
.adae		d0 02		bne $adb2	                bne +
.adb0		e6 3a		inc $3a		                inc scratch+4
.adb2						+
.adb2		b2 39		lda ($39)	                lda (scratch+3)
.adb4		c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.adb6		d0 40		bne $adf8	                bne _printing_done
.adb8		20 14 ae	jsr $ae14	                jsr disasm_sliteral_jump
.adbb		4c f8 ad	jmp $adf8	                jmp _printing_done
.adbe						_not_jmp:
.adbe		c9 80		cmp #$80	                cmp #$80            ; is it bra?
.adc0		f0 06		beq $adc8	                beq _is_rel
.adc2		29 1f		and #$1f	                and #$1f
.adc4		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.adc6		d0 30		bne $adf8	                bne _printing_done
.adc8						_is_rel:
.adc8		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.adca		ca		dex		                dex
.adcb		ca		dex		                dex
.adcc		74 01		stz $01,x	                stz 1,x
.adce		a5 37		lda $37		                lda scratch+1
.add0		95 00		sta $00,x	                sta 0,x
.add2		10 04		bpl $add8	                bpl +
.add4		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.add6		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.add8		38		sec		+               sec                 ; start counting from address after opcode
.add9		75 04		adc $04,x	                adc 4,x
.addb		95 00		sta $00,x	                sta 0,x
.addd		b5 01		lda $01,x	                lda 1,x
.addf		75 05		adc $05,x	                adc 5,x
.ade1		95 01		sta $01,x	                sta 1,x
.ade3		5a		phy		                phy                 ; save the direction indicator
.ade4		ca		dex		                dex
.ade5		ca		dex		                dex
.ade6		a9 09		lda #$09	                lda #9
.ade8		95 00		sta $00,x	                sta 0,x
.adea		74 01		stz $01,x	                stz 1,x
.adec		20 bf a4	jsr $a4bf	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.adef		a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.adf1		20 a9 8d	jsr $8da9	                jsr emit_a
.adf4		68		pla		                pla
.adf5		20 a9 8d	jsr $8da9	                jsr emit_a
.adf8						_printing_done:
.adf8		20 2a 89	jsr $892a	                jsr xt_cr
.adfb		f6 02		inc $02,x	                inc 2,x
.adfd		d0 02		bne $ae01	                bne +
.adff		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ae01						+
.ae01		20 c5 97	jsr $97c5	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ae04		b5 00		lda $00,x	                lda 0,x                 ; All done?
.ae06		15 01		ora $01,x	                ora 1,x
.ae08		f0 07		beq $ae11	                beq _done
.ae0a		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae0c		30 03		bmi $ae11	                bmi _done
.ae0e		4c af ac	jmp $acaf	                jmp _byte_loop          ; out of range for BRA
.ae11						_done:
.ae11		4c 35 a3	jmp $a335	                jmp xt_two_drop         ; JSR/RTS
.ae14						disasm_sliteral_jump:
.ae14		20 33 a1	jsr $a133	                jsr xt_swap
.ae17		ca		dex		                dex
.ae18		ca		dex		                dex
.ae19		a5 37		lda $37		                lda scratch+1
.ae1b		95 00		sta $00,x	                sta 0,x
.ae1d		a5 38		lda $38		                lda scratch+2
.ae1f		95 01		sta $01,x	                sta 1,x
.ae21		20 33 a1	jsr $a133	                jsr xt_swap
.ae24		20 04 95	jsr $9504	                jsr xt_minus
.ae27		20 c5 97	jsr $97c5	                jsr xt_one_minus
.ae2a		20 04 95	jsr $9504	                jsr xt_minus
.ae2d		ca		dex		                dex
.ae2e		ca		dex		                dex
.ae2f		a5 37		lda $37		                lda scratch+1
.ae31		95 00		sta $00,x	                sta 0,x
.ae33		a5 38		lda $38		                lda scratch+2
.ae35		95 01		sta $01,x	                sta 1,x
.ae37		20 c5 97	jsr $97c5	                jsr xt_one_minus
.ae3a		20 33 a1	jsr $a133	                jsr xt_swap ; ( new_addr new_n )
.ae3d		60		rts		                rts
.ae3e						disasm_sliteral:
.ae3e		a9 53		lda #$53	                lda #'S'
.ae40		20 a9 8d	jsr $8da9	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae43		a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.ae45		20 7e d8	jsr $d87e	                jsr print_string_no_lf
.ae48		20 33 a1	jsr $a133	                jsr xt_swap             ; switch to (u addr)
.ae4b		20 d1 97	jsr $97d1	                jsr xt_one_plus
.ae4e		20 62 8d	jsr $8d62	                jsr xt_dup
.ae51		20 33 8f	jsr $8f33	                jsr xt_fetch
.ae54		20 b3 a4	jsr $a4b3	                jsr xt_u_dot            ; Print the address of the string
.ae57		20 2c a3	jsr $a32c	                jsr xt_two
.ae5a		20 97 99	jsr $9997	                jsr xt_plus
.ae5d		20 62 8d	jsr $8d62	                jsr xt_dup
.ae60		20 16 9a	jsr $9a16	                jsr xt_question         ; Print the length of the string
.ae63		20 d1 97	jsr $97d1	                jsr xt_one_plus
.ae66		20 33 a1	jsr $a133	                jsr xt_swap            ; ( addr+4 u )
.ae69		ca		dex		                dex
.ae6a		ca		dex		                dex
.ae6b		a9 04		lda #$04	                lda #4
.ae6d		95 00		sta $00,x	                sta 0,x
.ae6f		74 01		stz $01,x	                stz 1,x
.ae71		20 04 95	jsr $9504	                jsr xt_minus            ; ( addr+4 u-4 )
.ae74		60		rts		                rts
.ae75						disasm_0branch:
.ae75		a9 30		lda #$30	                lda #'0'
.ae77		20 a9 8d	jsr $8da9	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ae7a						disasm_branch:
.ae7a		a9 0e		lda #$0e	                lda #str_disasm_bra
.ae7c		20 7e d8	jsr $d87e	                jsr print_string_no_lf ; "BRANCH "
.ae7f		80 10		bra $ae91	                bra disasm_print_literal
.ae81						disasm_do:
.ae81		a9 44		lda #$44	                lda #'D'
.ae83		20 a9 8d	jsr $8da9	                jsr emit_a
.ae86		a9 4f		lda #$4f	                lda #'O'
.ae88		20 a9 8d	jsr $8da9	                jsr emit_a
.ae8b		60		rts		                rts
.ae8c						disasm_literal:
.ae8c		a9 0c		lda #$0c	                lda #str_disasm_lit
.ae8e		20 7e d8	jsr $d87e	                jsr print_string_no_lf ; "LITERAL "
.ae91						disasm_print_literal:
.ae91		20 33 a1	jsr $a133	                jsr xt_swap ; switch to (u addr)
.ae94		20 d1 97	jsr $97d1	                jsr xt_one_plus
.ae97		20 62 8d	jsr $8d62	                jsr xt_dup
.ae9a		20 16 9a	jsr $9a16	                jsr xt_question ; Print the value at the address
.ae9d		20 d1 97	jsr $97d1	                jsr xt_one_plus
.aea0		20 33 a1	jsr $a133	                jsr xt_swap ; (addr+2 u)
.aea3		20 c5 97	jsr $97c5	                jsr xt_one_minus
.aea6		20 c5 97	jsr $97c5	                jsr xt_one_minus ; (addr+2 u-2)
.aea9		60		rts		                rts
.aeaa						disasm_jsr:
.aeaa		ca		dex		                dex
.aeab		ca		dex		                dex
.aeac		a5 37		lda $37		                lda scratch+1
.aeae		95 00		sta $00,x	                sta 0,x
.aeb0		a5 38		lda $38		                lda scratch+2
.aeb2		95 01		sta $01,x	                sta 1,x
.aeb4		20 29 92	jsr $9229	                jsr xt_int_to_name
.aeb7		b5 00		lda $00,x	                lda 0,x
.aeb9		15 01		ora $01,x	                ora 1,x
.aebb		f0 07		beq $aec4	                beq _disasm_no_nt
.aebd		20 b2 95	jsr $95b2	                jsr xt_name_to_string
.aec0		20 88 a4	jsr $a488	                jsr xt_type
.aec3		60		rts		                rts
.aec4						_disasm_no_nt:
.aec4		20 e1 8c	jsr $8ce1	                jsr xt_drop ; the 0 indicating no name token
.aec7		ca		dex		                dex
.aec8		ca		dex		                dex
.aec9		a5 37		lda $37		                lda scratch+1
.aecb		95 00		sta $00,x	                sta 0,x
.aecd		a5 38		lda $38		                lda scratch+2
.aecf		95 01		sta $01,x	                sta 1,x
.aed1		ca		dex		                dex
.aed2		ca		dex		                dex
.aed3		a9 42		lda #$42	                lda #<underflow_1
.aed5		95 00		sta $00,x	                sta 0,x
.aed7		a9 d8		lda #$d8	                lda #>underflow_1
.aed9		95 01		sta $01,x	                sta 1,x
.aedb		20 69 d7	jsr $d769	                jsr compare_16bit
.aede		f0 02		beq $aee2	                beq _disasm_jsr_uflow_check_upper
.aee0		b0 14		bcs $aef6	                bcs _disasm_jsr_unknown
.aee2						_disasm_jsr_uflow_check_upper:
.aee2		a9 51		lda #$51	                lda #<underflow_4
.aee4		95 00		sta $00,x	                sta 0,x
.aee6		a9 d8		lda #$d8	                lda #>underflow_4
.aee8		95 01		sta $01,x	                sta 1,x
.aeea		20 69 d7	jsr $d769	                jsr compare_16bit
.aeed		f0 02		beq $aef1	                beq _disasm_jsr_soc
.aeef		90 05		bcc $aef6	                bcc _disasm_jsr_unknown
.aef1						_disasm_jsr_soc:
.aef1		a9 0d		lda #$0d	                lda #str_disasm_sdc
.aef3		20 7e d8	jsr $d87e	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.aef6						_disasm_jsr_unknown:
.aef6		20 35 a3	jsr $a335	                jsr xt_two_drop
.aef9		60		rts		                rts
.aefa						oc_index_table:
>aefa		fa b0 fe b0 92 b5 92 b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>af02		06 b1 0c b1 12 b1 92 b5
>af0a		18 b1 1c b1 22 b1 92 b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af12		28 b1 2c b1 30 b1 34 b1
>af1a		39 b1 3d b1 45 b1 92 b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af22		4c b1 52 b1 59 b1 60 b1
>af2a		67 b1 6b b1 71 b1 92 b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af32		77 b1 7b b1 92 b5 81 b1
>af3a		87 b1 8b b1 92 b5 92 b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af42		93 b1 99 b1 9f b1 a5 b1
>af4a		ac b1 b0 b1 b6 b1 92 b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af52		bc b1 c0 b1 c5 b1 c9 b1
>af5a		ce b1 d2 b1 da b1 92 b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af62		e1 b1 e9 b1 f0 b1 f7 b1
>af6a		fe b1 02 b2 08 b2 92 b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af72		0e b2 14 b2 1a b2 34 b1
>af7a		25 b2 29 b2 92 b5 92 b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>af82		92 b5 31 b2 37 b2 3d b2
>af8a		44 b2 48 b2 4e b2 92 b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>af92		54 b2 58 b2 5c b2 60 b2
>af9a		65 b2 69 b2 71 b2 92 b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>afa2		92 b5 78 b2 7f b2 86 b2
>afaa		8d b2 91 b2 97 b2 92 b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>afb2		92 b5 92 b5 a1 b2 a7 b2
>afba		ac b2 b0 b2 92 b5 92 b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>afc2		b8 b2 be b2 c4 b2 ca b2
>afca		d1 b2 d5 b2 db b2 92 b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>afd2		e1 b2 e7 b2 eb b2 ef b2
>afda		f4 b2 f8 b2 00 b3 92 b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>afe2		07 b3 0e b3 15 b3 1c b3
>afea		23 b3 27 b3 2d b3 92 b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>aff2		31 b3 38 b3 3e b3 44 b3
>affa		49 b3 4d b3 92 b5 92 b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b002		55 b3 5b b3 61 b3 92 b5
>b00a		67 b3 6b b3 71 b3 92 b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b012		75 b3 79 b3 7d b3 81 b3
>b01a		86 b3 8a b3 92 b3 92 b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b022		99 b3 a0 b3 a7 b3 ae b3
>b02a		b5 b3 b9 b3 bf b3 92 b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b032		c3 b3 c7 b3 cd b3 d3 b3
>b03a		d8 b3 de b3 e6 b3 92 b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b042		ec b3 f2 b3 f8 b3 fe b3
>b04a		05 b4 09 b4 0f b4 92 b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b052		13 b4 17 b4 1b b4 1f b4
>b05a		24 b4 28 b4 30 b4 92 b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b062		37 b4 3e b4 45 b4 4c b4
>b06a		53 b4 57 b4 5d b4 92 b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b072		61 b4 67 b4 6d b4 73 b4
>b07a		78 b4 7e b4 92 b5 92 b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b082		86 b4 8c b4 92 b4 98 b4
>b08a		9f b4 a3 b4 a9 b4 92 b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b092		ad b4 b1 b4 b5 b4 b9 b4
>b09a		be b4 c2 b4 ca b4 92 b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b0a2		92 b5 d1 b4 d8 b4 df b4
>b0aa		e6 b4 ea b4 f0 b4 92 b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0b2		92 b5 f4 b4 fa b4 00 b5
>b0ba		05 b5 0b b5 92 b5 92 b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b0c2		13 b5 19 b5 1f b5 25 b5
>b0ca		2c b5 30 b5 36 b5 92 b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b0d2		3a b5 3e b5 42 b5 46 b5
>b0da		4b b5 4f b5 57 b5 92 b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b0e2		92 b5 5e b5 65 b5 6c b5
>b0ea		73 b5 77 b5 7d b5 92 b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b0f2		92 b5 81 b5 87 b5 8d b5
.b0fa						oc_table:
>b0fa		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b0fe		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b106		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b10c		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b112		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b118		43 70 68 70				oc08:	.text 1*64+3, "php"
>b11c		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b122		45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b128		c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b12c		c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b130		c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b134		c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b139		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b13d		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b145		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b14c		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b152		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b159		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b160		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b167		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b16b		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b171		45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b177		c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b17b		c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b181		c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b187		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b18b		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b193		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b199		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b19f		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b1a5		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b1ac		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b1b0		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1b6		45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b1bc		c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b1c0		c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b1c5		c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b1c9		c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1ce		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b1d2		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b1da		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b1e1		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b1e9		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b1f0		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b1f7		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b1fe		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b202		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b208		45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b20e		c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b214		c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b21a		c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b220		c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b225		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b229		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b231		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b237		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b23d		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b244		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b248		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b24e		45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b254		c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b258		c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b25c		c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b260		c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b265		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b269		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b271		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b278		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b27f		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b286		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b28d		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b291		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b297		43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b29b		c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b2a1		c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b2a7		c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b2ac		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b2b0		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b2b8		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b2be		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b2c4		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b2ca		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b2d1		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b2d5		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b2db		45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b2e1		c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b2e7		c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b2eb		c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b2ef		c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b2f4		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b2f8		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b300		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b307		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b30e		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b315		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b31c		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b323		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b327		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b32d		43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b331		c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b338		c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b33e		c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b344		c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b349		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b34d		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b355		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b35b		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b361		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b367		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b36b		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b371		43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b375		c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b379		c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b37d		c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b381		c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b386		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b38a		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b392		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b399		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b3a0		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b3a7		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b3ae		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3b5		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b3b9		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b3bf		43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b3c3		c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b3c7		c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3cd		c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b3d3		c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b3d8		85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b3de		87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b3e6		85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b3ec		85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b3f2		85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b3f8		85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b3fe		86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b405		43 74 61 79				oca8:	.text 1*64+3, "tay"
>b409		85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b40f		43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b413		c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b417		c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b41b		c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b41f		c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b424		83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b428		87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b430		86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b437		86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b43e		86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b445		86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b44c		86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b453		43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b457		c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b45d		43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b461		c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b467		c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b46d		c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b473		c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b478		85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b47e		87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b486		85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b48c		85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b492		85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b498		86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b49f		43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b4a3		85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b4a9		43 64 65 78				occa:	.text 1*64+3, "dex"
>b4ad		c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b4b1		c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4b5		c3 64 65 63				occe:	.text 3*64+3, "dec"
>b4b9		c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b4be		83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b4c2		87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b4ca		86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b4d1		86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b4d8		86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b4df		86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b4e6		43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b4ea		c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b4f0		43 70 68 78				ocda:	.text 1*64+3, "phx"
>b4f4		c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b4fa		c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b500		c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b505		85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b50b		87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b513		85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b519		85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b51f		85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b525		86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b52c		43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b530		85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b536		43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b53a		c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b53e		c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b542		c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b546		c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b54b		83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b54f		87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b557		86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b55e		86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b565		86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b56c		86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b573		43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b577		c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b57d		43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b581		c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b587		c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b58d		c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b592		01 3f					oc__:	.text 1, "?"
.b594						disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=$002e						ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=$0030						ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=$0032						ed_flags = editor3  ; Flags used by ed, where
.b594						ed6502:
.b594		a5 18		lda $18		                lda base
.b596		85 33		sta $33		                sta editor3+1
.b598		a9 0a		lda #$0a	                lda #10
.b59a		85 18		sta $18		                sta base
.b59c		64 2e		stz $2e		                stz ed_head
.b59e		64 2f		stz $2f		                stz ed_head+1
.b5a0		64 30		stz $30		                stz ed_cur
.b5a2		64 31		stz $31		                stz ed_cur+1
.b5a4		64 32		stz $32		                stz ed_flags
.b5a6		20 2d a7	jsr $a72d	                jsr xt_zero
.b5a9		20 2d a7	jsr $a72d	                jsr xt_zero             ; ( addr-t u-t )
.b5ac		20 2a 89	jsr $892a	                jsr xt_cr
.b5af						ed_input_loop:
.b5af		a9 81		lda #$81	                lda #%10000001
.b5b1		14 32		trb $32		                trb ed_flags
.b5b3		20 8e ba	jsr $ba8e	                jsr ed_get_input
.b5b6		a5 0a		lda $0a		                lda ciblen
.b5b8		d0 1f		bne $b5d9	                bne _command_mode
.b5ba		ca		dex		                dex
.b5bb		ca		dex		                dex                     ; ( addr-t u-t ? )
.b5bc		a5 30		lda $30		                lda ed_cur
.b5be		95 00		sta $00,x	                sta 0,x
.b5c0		a5 31		lda $31		                lda ed_cur+1
.b5c2		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b5c4		a9 80		lda #$80	                lda #%10000000
.b5c6		04 32		tsb $32		                tsb ed_flags
.b5c8		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b5cb		20 aa ba	jsr $baaa	                jsr ed_is_valid_line
.b5ce		b0 03		bcs $b5d3	                bcs +
.b5d0		4c 7e ba	jmp $ba7e	                jmp ed_error_1drop
.b5d3						+
.b5d3		20 2d a7	jsr $a72d	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b5d6		4c a4 b6	jmp $b6a4	                jmp _line_number_only_from_external
.b5d9						_command_mode:
.b5d9		20 2d a7	jsr $a72d	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b5dc		20 2d a7	jsr $a72d	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b5df						_prefix_dot:
.b5df		b2 08		lda ($08)	                lda (cib)
.b5e1		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b5e3		d0 3a		bne $b61f	                bne _prefix_dollar
.b5e5		20 9f ba	jsr $ba9f	                jsr ed_have_text
.b5e8		a5 30		lda $30		                lda ed_cur
.b5ea		95 02		sta $02,x	                sta 2,x
.b5ec		a5 31		lda $31		                lda ed_cur+1
.b5ee		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b5f0		a9 80		lda #$80	                lda #%10000000
.b5f2		04 32		tsb $32		                tsb ed_flags
.b5f4		a5 0a		lda $0a		                lda ciblen
.b5f6		3a		dec a		                dea                     ; sets Z if A was 1
.b5f7		d0 03		bne $b5fc	                bne +
.b5f9		4c a4 b6	jmp $b6a4	                jmp _line_number_only_from_external
.b5fc						+
.b5fc		ca		dex		                dex
.b5fd		ca		dex		                dex
.b5fe		ca		dex		                dex
.b5ff		ca		dex		                dex
.b600		a5 08		lda $08		                lda cib
.b602		95 02		sta $02,x	                sta 2,x
.b604		a5 09		lda $09		                lda cib+1
.b606		95 03		sta $03,x	                sta 3,x
.b608		a5 0a		lda $0a		                lda ciblen
.b60a		95 00		sta $00,x	                sta 0,x
.b60c		a5 0b		lda $0b		                lda ciblen+1
.b60e		95 01		sta $01,x	                sta 1,x
.b610		20 c5 97	jsr $97c5	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b613		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b616		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b619		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b61c		4c fc b6	jmp $b6fc	                jmp _check_for_para2
.b61f						_prefix_dollar:
.b61f		b2 08		lda ($08)	                lda (cib)
.b621		c9 24		cmp #$24	                cmp #'$'
.b623		d0 1c		bne $b641	                bne _prefix_percent
.b625		20 9f ba	jsr $ba9f	                jsr ed_have_text
.b628		e8		inx		                inx
.b629		e8		inx		                inx                     ; ( addr-t u-t 0 )
.b62a		20 cc ba	jsr $bacc	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b62d		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b630		a9 80		lda #$80	                lda #%10000000
.b632		04 32		tsb $32		                tsb ed_flags
.b634		a5 0a		lda $0a		                lda ciblen
.b636		3a		dec a		                dea                     ; sets Z if A was 1
.b637		d0 03		bne $b63c	                bne +
.b639		4c a4 b6	jmp $b6a4	                jmp _line_number_only_from_external
.b63c						+
.b63c		a0 01		ldy #$01	                ldy #01
.b63e		4c 78 b7	jmp $b778	                jmp _check_command
.b641						_prefix_percent:
.b641		b2 08		lda ($08)	                lda (cib)
.b643		c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b645		f0 04		beq $b64b	                beq _whole_text
.b647		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b649		d0 17		bne $b662	                bne _prefix_semicolon
.b64b						_whole_text:
.b64b		20 9f ba	jsr $ba9f	                jsr ed_have_text
.b64e		a9 01		lda #$01	                lda #01
.b650		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b652		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b654						_semicolon_entry:
.b654		e8		inx		                inx
.b655		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b656		20 cc ba	jsr $bacc	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b659		a9 80		lda #$80	                lda #%10000000
.b65b		04 32		tsb $32		                tsb ed_flags
.b65d		a0 01		ldy #$01	                ldy #01
.b65f		4c 78 b7	jmp $b778	                jmp _check_command
.b662						_prefix_semicolon:
.b662		b2 08		lda ($08)	                lda (cib)
.b664		c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b666		d0 0d		bne $b675	                bne _prefix_number
.b668		20 9f ba	jsr $ba9f	                jsr ed_have_text
.b66b		a5 30		lda $30		                lda ed_cur
.b66d		95 02		sta $02,x	                sta 2,x
.b66f		a5 31		lda $31		                lda ed_cur+1
.b671		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b673		80 df		bra $b654	                bra _semicolon_entry
.b675						_prefix_number:
.b675		20 2d a7	jsr $a72d	                jsr xt_zero
.b678		20 2d a7	jsr $a72d	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b67b		ca		dex		                dex
.b67c		ca		dex		                dex
.b67d		ca		dex		                dex
.b67e		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b67f		a5 08		lda $08		                lda cib
.b681		95 02		sta $02,x	                sta 2,x
.b683		a5 09		lda $09		                lda cib+1
.b685		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b687		a5 0a		lda $0a		                lda ciblen
.b689		95 00		sta $00,x	                sta 0,x
.b68b		a5 0b		lda $0b		                lda ciblen+1
.b68d		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b68f		20 42 a2	jsr $a242	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b692		b5 00		lda $00,x	                lda 0,x
.b694		15 01		ora $01,x	                ora 1,x
.b696		d0 24		bne $b6bc	                bne _have_unconverted_chars
.b698		e8		inx		                inx
.b699		e8		inx		                inx
.b69a		e8		inx		                inx
.b69b		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b69c		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b69f		20 22 96	jsr $9622	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b6a2		e8		inx		                inx
.b6a3		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b6a4						_line_number_only_from_external:
.b6a4		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b6a7		20 aa ba	jsr $baaa	                jsr ed_is_valid_line
.b6aa		b0 03		bcs $b6af	                bcs +
.b6ac		4c 7c ba	jmp $ba7c	                jmp ed_error_2drop
.b6af						+
.b6af		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6b2		20 39 bb	jsr $bb39	                jsr ed_para1_to_cur
.b6b5		a9 80		lda #$80	                lda #%10000000
.b6b7		04 32		tsb $32		                tsb ed_flags
.b6b9		4c 57 b9	jmp $b957	                jmp ed_cmd_p_from_external
.b6bc						_have_unconverted_chars:
.b6bc		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b6bf		ca		dex		                dex
.b6c0		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b6c1		a5 0a		lda $0a		                lda ciblen
.b6c3		95 00		sta $00,x	                sta 0,x
.b6c5		a5 0b		lda $0b		                lda ciblen+1
.b6c7		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b6c9		20 81 8e	jsr $8e81	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b6cc		b5 00		lda $00,x	                lda 0,x
.b6ce		15 01		ora $01,x	                ora 1,x
.b6d0		f0 0e		beq $b6e0	                beq _no_command_yet
.b6d2		8a		txa		                txa
.b6d3		18		clc		                clc
.b6d4		69 0a		adc #$0a	                adc #10
.b6d6		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b6d7		a9 80		lda #$80	                lda #%10000000
.b6d9		14 32		trb $32		                trb ed_flags
.b6db		a0 00		ldy #$00	                ldy #00
.b6dd		4c 78 b7	jmp $b778	                jmp _check_command
.b6e0						_no_command_yet:
.b6e0		e8		inx		                inx
.b6e1		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b6e2		20 f5 a2	jsr $a2f5	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b6e5		20 22 96	jsr $9622	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b6e8		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b6eb		b5 00		lda $00,x	                lda 0,x                 ; LSB
.b6ed		95 06		sta $06,x	                sta 6,x
.b6ef		b5 01		lda $01,x	                lda 1,x                 ; MSB
.b6f1		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b6f3		e8		inx		                inx
.b6f4		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b6f5		20 46 9a	jsr $9a46	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b6f8		a9 80		lda #$80	                lda #%10000000
.b6fa		04 32		tsb $32		                tsb ed_flags
.b6fc						_check_for_para2:
.b6fc		a1 02		lda ($02,x)	                lda (2,x)
.b6fe		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b700		f0 0d		beq $b70f	                beq _got_comma
.b702		38		sec		                sec
.b703		a5 0a		lda $0a		                lda ciblen
.b705		f5 00		sbc $00,x	                sbc 0,x
.b707		a8		tay		                tay
.b708		e8		inx		                inx
.b709		e8		inx		                inx
.b70a		e8		inx		                inx
.b70b		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b70c		4c 78 b7	jmp $b778	                jmp _check_command
.b70f						_got_comma:
.b70f		f6 02		inc $02,x	                inc 2,x
.b711		d0 02		bne $b715	                bne +
.b713		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b715						+
.b715		b5 01		lda $01,x	                lda 1,x
.b717		f0 02		beq $b71b	                beq +
.b719		d6 01		dec $01,x	                dec 1,x
.b71b						+
.b71b		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b71d		a1 02		lda ($02,x)	                lda (2,x)
.b71f		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b721		d0 14		bne $b737	                bne _para2_not_dollar
.b723		38		sec		                sec
.b724		a5 0a		lda $0a		                lda ciblen
.b726		f5 02		sbc $02,x	                sbc 2,x
.b728		a8		tay		                tay
.b729		c8		iny		                iny
.b72a		5a		phy		                phy
.b72b		8a		txa		                txa
.b72c		18		clc		                clc
.b72d		69 06		adc #$06	                adc #06
.b72f		aa		tax		                tax                     ; ( addr-t u-t para1 )
.b730		20 cc ba	jsr $bacc	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b733		7a		ply		                ply
.b734		4c 78 b7	jmp $b778	                jmp _check_command
.b737						_para2_not_dollar:
.b737		20 f5 a2	jsr $a2f5	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b73a		20 2d a7	jsr $a72d	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b73d		20 2d a7	jsr $a72d	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b740		20 0b 9b	jsr $9b0b	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b743		20 46 9a	jsr $9a46	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b746		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b749		20 f5 a2	jsr $a2f5	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b74c		20 42 a2	jsr $a242	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b74f		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b752		20 46 9a	jsr $9a46	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b755		20 81 8e	jsr $8e81	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b758		b5 00		lda $00,x	                lda 0,x
.b75a		15 01		ora $01,x	                ora 1,x
.b75c		f0 08		beq $b766	                beq _second_number
.b75e		8a		txa		                txa
.b75f		18		clc		                clc
.b760		69 0c		adc #$0c	                adc #12
.b762		aa		tax		                tax                     ; back to ( addr-t u-t )
.b763		4c 80 ba	jmp $ba80	                jmp ed_error
.b766						_second_number:
.b766		e8		inx		                inx
.b767		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b768		38		sec		                sec
.b769		a5 0a		lda $0a		                lda ciblen
.b76b		f5 00		sbc $00,x	                sbc 0,x
.b76d		48		pha		                pha
.b76e		20 35 a3	jsr $a335	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b771		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b774		20 f6 95	jsr $95f6	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b777		7a		ply		                ply
.b778						_check_command:
.b778		24 32		bit $32		                bit ed_flags
.b77a		30 08		bmi $b784	                bmi _check_command_have_arg
.b77c		a5 30		lda $30		                lda ed_cur
.b77e		95 02		sta $02,x	                sta 2,x
.b780		a5 31		lda $31		                lda ed_cur+1
.b782		95 03		sta $03,x	                sta 3,x
.b784						_check_command_have_arg:
.b784		b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b786		85 24		sta $24		                sta tmp1
.b788		da		phx		                phx
.b789		a2 00		ldx #$00	                ldx #00
.b78b						_cmd_loop:
.b78b		bd 64 bb	lda $bb64,x	                lda ed_cmd_list,x
.b78e		f0 07		beq $b797	                beq _illegal_command    ; zero marks end of list
.b790		c5 24		cmp $24		                cmp tmp1
.b792		f0 07		beq $b79b	                beq _found_cmd
.b794		e8		inx		                inx
.b795		80 f4		bra $b78b	                bra _cmd_loop
.b797						_illegal_command:
.b797		fa		plx		                plx
.b798		4c 7c ba	jmp $ba7c	                jmp ed_error_2drop
.b79b						_found_cmd:
.b79b		8a		txa		                txa
.b79c		0a		asl a		                asl
.b79d		aa		tax		                tax                     ; X * 2 for table
.b79e		7c 6f bb	jmp ($bb6f,x)	                jmp (ed_cmd_table,x)
.b7a1						ed_next_command:
.b7a1		e8		inx		                inx
.b7a2		e8		inx		                inx
.b7a3		e8		inx		                inx
.b7a4		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b7a5						_next_command_empty:
.b7a5		4c af b5	jmp $b5af	                jmp ed_input_loop
.b7a8						ed_all_done:
.b7a8		64 0a		stz $0a		                stz ciblen
.b7aa		64 0b		stz $0b		                stz ciblen+1
.b7ac		20 35 a3	jsr $a335	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b7af		a5 33		lda $33		                lda editor3+1
.b7b1		85 18		sta $18		                sta base
.b7b3		60		rts		                rts
.b7b4						ed_cmd_a:
.b7b4		fa		plx		                plx
.b7b5		e8		inx		                inx
.b7b6		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7b7						ed_entry_cmd_i:
.b7b7						ed_cmd_a_have_para:
.b7b7		20 02 bb	jsr $bb02	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b7ba		20 2a 89	jsr $892a	                jsr xt_cr
.b7bd						_next_string_loop:
.b7bd		20 8e ba	jsr $ba8e	                jsr ed_get_input
.b7c0		b2 08		lda ($08)	                lda (cib)
.b7c2		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b7c4		d0 16		bne $b7dc	                bne _add_line
.b7c6		a4 0a		ldy $0a		                ldy ciblen
.b7c8		c0 01		cpy #$01	                cpy #01
.b7ca		d0 10		bne $b7dc	                bne _add_line
.b7cc		a4 0b		ldy $0b		                ldy ciblen+1
.b7ce		d0 0c		bne $b7dc	                bne _add_line
.b7d0		e8		inx		                inx
.b7d1		e8		inx		                inx
.b7d2		a9 40		lda #$40	                lda #%01000000
.b7d4		04 32		tsb $32		                tsb ed_flags
.b7d6		20 2a 89	jsr $892a	                jsr xt_cr
.b7d9		4c af b5	jmp $b5af	                jmp ed_input_loop
.b7dc						_add_line:
.b7dc		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b7df		20 25 91	jsr $9125	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b7e2		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b7e5		20 33 8f	jsr $8f33	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b7e8		20 24 87	jsr $8724	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b7eb		20 12 a3	jsr $a312	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b7ee		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b7f1		20 12 a1	jsr $a112	                jsr xt_store            ; ! ( addr-t u-t here )
.b7f4		20 25 91	jsr $9125	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b7f7		a5 00		lda $00		                lda cp
.b7f9		18		clc		                clc
.b7fa		69 04		adc #$04	                adc #04
.b7fc		85 00		sta $00		                sta cp
.b7fe		90 02		bcc $b802	                bcc +
.b800		e6 01		inc $01		                inc cp+1
.b802						+
.b802		e6 30		inc $30		                inc ed_cur
.b804		d0 02		bne $b808	                bne +
.b806		e6 31		inc $31		                inc ed_cur+1
.b808						+
.b808		20 25 91	jsr $9125	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b80b		20 62 8d	jsr $8d62	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b80e		ca		dex		                dex
.b80f		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b810		a5 08		lda $08		                lda cib
.b812		95 00		sta $00,x	                sta 0,x
.b814		a5 09		lda $09		                lda cib+1
.b816		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b818		20 33 a1	jsr $a133	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b81b		ca		dex		                dex
.b81c		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b81d		a5 0a		lda $0a		                lda ciblen
.b81f		95 00		sta $00,x	                sta 0,x
.b821		a5 0b		lda $0b		                lda ciblen+1
.b823		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b825		20 76 95	jsr $9576	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b828		18		clc		                clc
.b829		a5 00		lda $00		                lda cp
.b82b		65 0a		adc $0a		                adc ciblen
.b82d		85 00		sta $00		                sta cp
.b82f		90 06		bcc $b837	                bcc +
.b831		a5 01		lda $01		                lda cp+1
.b833		65 0b		adc $0b		                adc ciblen+1
.b835		85 01		sta $01		                sta cp+1
.b837						+
.b837		20 47 98	jsr $9847	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b83a		20 12 a1	jsr $a112	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b83d		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+
.b840		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b843		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b846		a5 0a		lda $0a		                lda ciblen
.b848		95 02		sta $02,x	                sta 2,x
.b84a		a5 0b		lda $0b		                lda ciblen+1
.b84c		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b84e		20 12 a1	jsr $a112	                jsr xt_store            ; ! ( addr-t u-t here )
.b851		20 2a 89	jsr $892a	                jsr xt_cr
.b854		4c bd b7	jmp $b7bd	                jmp _next_string_loop
.b857						ed_cmd_d:
.b857		fa		plx		                plx
.b858		20 9f ba	jsr $ba9f	                jsr ed_have_text
.b85b		20 f4 ba	jsr $baf4	                jsr ed_no_line_zero
.b85e		b5 00		lda $00,x	                lda 0,x
.b860		15 01		ora $01,x	                ora 1,x
.b862		d0 08		bne $b86c	                bne +
.b864		20 47 98	jsr $9847	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b867		20 a9 b8	jsr $b8a9	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b86a		80 33		bra $b89f	                bra _cmd_d_done
.b86c						+
.b86c		20 aa ba	jsr $baaa	                jsr ed_is_valid_line      ; result is in C flag
.b86f		b0 03		bcs $b874	                bcs _cmd_d_loop
.b871		4c 7c ba	jmp $ba7c	                jmp ed_error_2drop
.b874						_cmd_d_loop:
.b874		20 3d a3	jsr $a33d	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b877		20 10 91	jsr $9110	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b87a		b5 00		lda $00,x	                lda 0,x
.b87c		15 01		ora $01,x	                ora 1,x
.b87e		d0 0d		bne $b88d	                bne _cmd_d_done_with_flag
.b880		e8		inx		                inx
.b881		e8		inx		                inx                     ; Get rid of the flag from >
.b882		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b885		20 a9 b8	jsr $b8a9	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b888		20 c5 97	jsr $97c5	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b88b		80 e7		bra $b874	                bra _cmd_d_loop
.b88d						_cmd_d_done_with_flag:
.b88d		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b88e		e8		inx		                inx
.b88f		b5 02		lda $02,x	                lda 2,x
.b891		d0 02		bne $b895	                bne +
.b893		d6 03		dec $03,x	                dec 3,x
.b895						+
.b895		d6 02		dec $02,x	                dec 2,x
.b897		b5 02		lda $02,x	                lda 2,x
.b899		85 30		sta $30		                sta ed_cur
.b89b		b5 03		lda $03,x	                lda 3,x
.b89d		85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b89f						_cmd_d_done:
.b89f		a9 40		lda #$40	                lda #%01000000
.b8a1		04 32		tsb $32		                tsb ed_flags
.b8a3		20 2a 89	jsr $892a	                jsr xt_cr
.b8a6		4c a1 b7	jmp $b7a1	                jmp ed_next_command
.b8a9						_cmd_d_common:
.b8a9		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b8ac		20 02 bb	jsr $bb02	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b8af		20 33 8f	jsr $8f33	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8b2		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8b5		20 c5 97	jsr $97c5	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b8b8		20 02 bb	jsr $bb02	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b8bb		20 12 a1	jsr $a112	                jsr xt_store            ; ! ( addr-t u-t )
.b8be		60		rts		                rts
.b8bf						ed_cmd_equ:
.b8bf		fa		plx		                plx
.b8c0		a5 2e		lda $2e		                lda ed_head
.b8c2		05 2f		ora $2f		                ora ed_head+1
.b8c4		d0 08		bne $b8ce	                bne _cmd_equ_have_text
.b8c6		ca		dex		                dex
.b8c7		ca		dex		                dex
.b8c8		74 00		stz $00,x	                stz 0,x
.b8ca		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b8cc		80 21		bra $b8ef	                bra _cmd_equ_done
.b8ce						_cmd_equ_have_text:
.b8ce		20 f4 ba	jsr $baf4	                jsr ed_no_line_zero
.b8d1		24 32		bit $32		                bit ed_flags
.b8d3		30 0c		bmi $b8e1	                bmi _cmd_equ_have_para
.b8d5		ca		dex		                dex
.b8d6		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b8d7		a5 30		lda $30		                lda ed_cur
.b8d9		95 00		sta $00,x	                sta 0,x
.b8db		a5 31		lda $31		                lda ed_cur+1
.b8dd		95 01		sta $01,x	                sta 1,x
.b8df		80 0e		bra $b8ef	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b8e1						_cmd_equ_have_para:
.b8e1		b5 00		lda $00,x	                lda 0,x
.b8e3		15 01		ora $01,x	                ora 1,x
.b8e5		d0 05		bne $b8ec	                bne _cmd_equ_two_paras
.b8e7		20 47 98	jsr $9847	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b8ea		80 03		bra $b8ef	                bra _cmd_equ_done
.b8ec						_cmd_equ_two_paras:
.b8ec		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b8ef						_cmd_equ_done:
.b8ef		20 2a 89	jsr $892a	                jsr xt_cr               ; number goes on new line
.b8f2		20 b3 a4	jsr $a4b3	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b8f5		20 2a 89	jsr $892a	                jsr xt_cr
.b8f8		4c a1 b7	jmp $b7a1	                jmp ed_next_command
.b8fb						ed_cmd_f:
.b8fb		fa		plx		                plx
.b8fc		24 32		bit $32		                bit ed_flags
.b8fe		30 17		bmi $b917	                bmi _cmd_f_have_para
.b900		20 2a 89	jsr $892a	                jsr xt_cr
.b903		20 f5 a2	jsr $a2f5	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b906		20 0b 9b	jsr $9b0b	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b909		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b90c		20 b3 a4	jsr $a4b3	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b90f		20 22 96	jsr $9622	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b912		20 46 9a	jsr $9a46	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b915		80 11		bra $b928	                bra _cmd_f_done
.b917						_cmd_f_have_para:
.b917		20 47 98	jsr $9847	                jsr xt_over
.b91a		20 2a 89	jsr $892a	                jsr xt_cr
.b91d		20 b3 a4	jsr $a4b3	                jsr xt_u_dot
.b920		b5 02		lda $02,x	                lda 2,x
.b922		95 06		sta $06,x	                sta 6,x
.b924		b5 03		lda $03,x	                lda 3,x
.b926		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b928						_cmd_f_done:
.b928		20 2a 89	jsr $892a	                jsr xt_cr
.b92b		4c a1 b7	jmp $b7a1	                jmp ed_next_command
.b92e						ed_cmd_i:
.b92e		fa		plx		                plx
.b92f		e8		inx		                inx
.b930		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b931		24 32		bit $32		                bit ed_flags
.b933		30 08		bmi $b93d	                bmi _cmd_i_have_para
.b935		a5 30		lda $30		                lda ed_cur
.b937		95 00		sta $00,x	                sta 0,x
.b939		a5 31		lda $31		                lda ed_cur+1
.b93b		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b93d						_cmd_i_have_para:
.b93d		b5 00		lda $00,x	                lda 0,x
.b93f		15 01		ora $01,x	                ora 1,x
.b941		f0 09		beq $b94c	                beq _cmd_i_done
.b943		20 c5 97	jsr $97c5	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b946		20 2d a7	jsr $a72d	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b949		20 cc 94	jsr $94cc	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b94c						_cmd_i_done:
.b94c		4c b7 b7	jmp $b7b7	                jmp ed_entry_cmd_i
.b94f						ed_cmd_n:
.b94f		fa		plx		                plx
.b950		a9 01		lda #$01	                lda #%00000001
.b952		04 32		tsb $32		                tsb ed_flags
.b954		80 05		bra $b95b	                bra ed_cmd_p_entry_for_cmd_n
.b956						ed_cmd_p:
.b956		fa		plx		                plx
.b957						ed_cmd_p_from_external:
.b957		a9 01		lda #$01	                lda #%00000001
.b959		14 32		trb $32		                trb ed_flags
.b95b						ed_cmd_p_entry_for_cmd_n:
.b95b		20 9f ba	jsr $ba9f	                jsr ed_have_text
.b95e		20 f4 ba	jsr $baf4	                jsr ed_no_line_zero
.b961		20 2a 89	jsr $892a	                jsr xt_cr
.b964		b5 00		lda $00,x	                lda 0,x
.b966		15 01		ora $01,x	                ora 1,x
.b968		d0 10		bne $b97a	                bne _cmd_p_loop
.b96a		b5 02		lda $02,x	                lda 2,x
.b96c		85 30		sta $30		                sta ed_cur
.b96e		b5 03		lda $03,x	                lda 3,x
.b970		85 31		sta $31		                sta ed_cur+1
.b972		20 47 98	jsr $9847	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b975		20 a3 b9	jsr $b9a3	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b978		80 26		bra $b9a0	                bra _cmd_p_all_done
.b97a						_cmd_p_loop:
.b97a		20 3d a3	jsr $a33d	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b97d		20 10 91	jsr $9110	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b980		b5 00		lda $00,x	                lda 0,x
.b982		15 01		ora $01,x	                ora 1,x
.b984		d0 10		bne $b996	                bne _cmd_p_done
.b986		e8		inx		                inx
.b987		e8		inx		                inx                     ; Get rid of the flag from >
.b988		20 47 98	jsr $9847	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b98b		20 a3 b9	jsr $b9a3	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b98e		f6 02		inc $02,x	                inc 2,x
.b990		d0 02		bne $b994	                bne +
.b992		f6 03		inc $03,x	                inc 3,x
.b994						+
.b994		80 e4		bra $b97a	                bra _cmd_p_loop
.b996						_cmd_p_done:
.b996		e8		inx		                inx
.b997		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b998		b5 00		lda $00,x	                lda 0,x
.b99a		85 30		sta $30		                sta ed_cur
.b99c		b5 01		lda $01,x	                lda 1,x
.b99e		85 31		sta $31		                sta ed_cur+1
.b9a0						_cmd_p_all_done:
.b9a0		4c a1 b7	jmp $b7a1	                jmp ed_next_command
.b9a3						_cmd_p_common:
.b9a3		a5 32		lda $32		                lda ed_flags
.b9a5		4a		lsr a		                lsr                     ; bit 0 now in carry
.b9a6		90 0b		bcc $b9b3	                bcc _cmd_p_common_no_num
.b9a8		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b9ab		20 b3 a4	jsr $a4b3	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b9ae		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b9b0		20 a9 8d	jsr $8da9	                jsr emit_a
.b9b3						_cmd_p_common_no_num:
.b9b3		20 02 bb	jsr $bb02	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9b6		20 42 bb	jsr $bb42	                jsr ed_print_addr
.b9b9		60		rts		                rts
.b9ba						ed_cmd_q:
.b9ba		fa		plx		                plx
.b9bb		24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b9bd		50 03		bvc $b9c2	                bvc +
.b9bf		4c 7c ba	jmp $ba7c	                jmp ed_error_2drop
.b9c2						+
.b9c2		4c a8 b7	jmp $b7a8	                jmp ed_all_done            ; can't fall thru because of PLX
.b9c5						ed_cmd_qq:
.b9c5		fa		plx		                plx
.b9c6		4c a8 b7	jmp $b7a8	                jmp ed_all_done
.b9c9						ed_cmd_w:
.b9c9		fa		plx		                plx
.b9ca		20 9f ba	jsr $ba9f	                jsr ed_have_text
.b9cd		24 32		bit $32		                bit ed_flags
.b9cf		30 13		bmi $b9e4	                bmi _cmd_w_have_para
.b9d1		b5 06		lda $06,x	                lda 6,x
.b9d3		15 07		ora $07,x	                ora 7,x
.b9d5		d0 03		bne $b9da	                bne +
.b9d7		4c 7c ba	jmp $ba7c	                jmp ed_error_2drop
.b9da						+
.b9da		b5 06		lda $06,x	                lda 6,x
.b9dc		95 02		sta $02,x	                sta 2,x
.b9de		b5 07		lda $07,x	                lda 7,x
.b9e0		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b9e2		80 08		bra $b9ec	                bra _cmd_w_para_ready
.b9e4						_cmd_w_have_para:
.b9e4		b5 02		lda $02,x	                lda 2,x
.b9e6		95 06		sta $06,x	                sta 6,x
.b9e8		b5 03		lda $03,x	                lda 3,x
.b9ea		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b9ec						_cmd_w_para_ready:
.b9ec		a9 2e		lda #$2e	                lda #<ed_head
.b9ee		95 00		sta $00,x	                sta 0,x
.b9f0		a9 00		lda #$00	                lda #>ed_head
.b9f2		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.b9f4		20 47 98	jsr $9847	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.b9f7		20 f5 a2	jsr $a2f5	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.b9fa						_cmd_w_loop:
.b9fa		20 33 8f	jsr $8f33	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.b9fd		b5 00		lda $00,x	                lda 0,x
.b9ff		15 01		ora $01,x	                ora 1,x
.ba01		f0 55		beq $ba58	                beq _cmd_w_eol
.ba03		20 3d a3	jsr $a33d	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ba06		20 27 a4	jsr $a427	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ba09		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ba0c		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ba0f		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba12		20 33 8f	jsr $8f33	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba15		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba18		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba1b		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba1e		20 33 8f	jsr $8f33	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba21		20 22 96	jsr $9622	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba24		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba27		20 0b 9b	jsr $9b0b	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba2a		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba2d		20 f5 a2	jsr $a2f5	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba30		20 76 95	jsr $9576	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba33		20 46 9a	jsr $9a46	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba36		20 ad a3	jsr $a3ad	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba39		20 22 96	jsr $9622	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba3c		20 97 99	jsr $9997	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba3f		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba42		ca		dex		                dex
.ba43		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba44		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba46		95 00		sta $00,x	                sta 0,x
.ba48		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba4a		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba4d		20 12 a1	jsr $a112	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba50		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba53		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba56		80 a2		bra $b9fa	                bra _cmd_w_loop
.ba58						_cmd_w_eol:
.ba58		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba5b		20 46 9a	jsr $9a46	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba5e		20 04 95	jsr $9504	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba61		b5 00		lda $00,x	                lda 0,x
.ba63		95 04		sta $04,x	                sta 4,x
.ba65		b5 01		lda $01,x	                lda 1,x
.ba67		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba69		20 2a 89	jsr $892a	                jsr xt_cr
.ba6c		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba6f		20 b3 a4	jsr $a4b3	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba72		20 2a 89	jsr $892a	                jsr xt_cr
.ba75		a9 40		lda #$40	                lda #%01000000
.ba77		14 32		trb $32		                trb ed_flags
.ba79		4c a1 b7	jmp $b7a1	                jmp ed_next_command
.ba7c						ed_error_2drop:
.ba7c		e8		inx		                inx
.ba7d		e8		inx		                inx                     ; drop through to _error_1drop
.ba7e						ed_error_1drop:
.ba7e		e8		inx		                inx
.ba7f		e8		inx		                inx                     ; drop through to _error
.ba80						ed_error:
.ba80		20 2a 89	jsr $892a	                jsr xt_cr
.ba83		a9 3f		lda #$3f	                lda #'?'
.ba85		20 a9 8d	jsr $8da9	                jsr emit_a
.ba88		20 2a 89	jsr $892a	                jsr xt_cr
.ba8b		4c af b5	jmp $b5af	                jmp ed_input_loop
.ba8e						ed_get_input:
.ba8e		20 ac 9a	jsr $9aac	                jsr xt_refill           ;  ( addr-t u-t f )
.ba91		b5 00		lda $00,x	                lda 0,x
.ba93		15 01		ora $01,x	                ora 1,x
.ba95		d0 05		bne $ba9c	                bne +
.ba97		7a		ply		                ply
.ba98		7a		ply		                ply
.ba99		4c 7e ba	jmp $ba7e	                jmp ed_error_1drop
.ba9c						+
.ba9c		e8		inx		                inx
.ba9d		e8		inx		                inx
.ba9e		60		rts		                rts
.ba9f						ed_have_text:
.ba9f		a5 2e		lda $2e		                lda ed_head
.baa1		05 2f		ora $2f		                ora ed_head+1
.baa3		d0 04		bne $baa9	                bne +
.baa5		7a		ply		                ply
.baa6		7a		ply		                ply
.baa7		80 d7		bra $ba80	                bra ed_error
.baa9						+
.baa9		60		rts		                rts
.baaa						ed_is_valid_line:
.baaa		38		sec		                sec                             ; default is legal line number
.baab		b5 00		lda $00,x	                lda 0,x
.baad		15 01		ora $01,x	                ora 1,x
.baaf		f0 19		beq $baca	                beq _is_valid_line_nope_zero    ; ( n )
.bab1		20 62 8d	jsr $8d62	                jsr xt_dup                      ; DUP ( n n )
.bab4		20 cc ba	jsr $bacc	                jsr ed_last_line                  ; ( n n last )
.bab7		20 33 a1	jsr $a133	                jsr xt_swap                     ; SWAP ( n last n )
.baba		20 19 93	jsr $9319	                jsr xt_less_than                ; < ( n f )
.babd		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.babf		15 01		ora $01,x	                ora 1,x
.bac1		d0 05		bne $bac8	                bne _is_valid_line_too_small
.bac3		e8		inx		                inx
.bac4		e8		inx		                inx                     ; DROP flag ( n )
.bac5		38		sec		                sec                     ; Who knows what's happened to C by now
.bac6		80 03		bra $bacb	                bra _is_valid_line_done ; only one exit from this routine
.bac8						_is_valid_line_too_small:
.bac8		e8		inx		                inx
.bac9		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.baca						_is_valid_line_nope_zero:
.baca		18		clc		                clc                     ; drop through to _is_valid_line_done
.bacb						_is_valid_line_done:
.bacb		60		rts		                rts
.bacc						ed_last_line:
.bacc		64 24		stz $24		                stz tmp1
.bace		64 25		stz $25		                stz tmp1+1
.bad0		ca		dex		                dex
.bad1		ca		dex		                dex                     ; ( ? )
.bad2		a9 2e		lda #$2e	                lda #<ed_head
.bad4		95 00		sta $00,x	                sta 0,x
.bad6		a9 00		lda #$00	                lda #>ed_head
.bad8		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.bada						_last_line_loop:
.bada		20 33 8f	jsr $8f33	                jsr xt_fetch            ; ( addr | 0 )
.badd		b5 00		lda $00,x	                lda 0,x
.badf		15 01		ora $01,x	                ora 1,x
.bae1		f0 08		beq $baeb	                beq _last_line_done
.bae3		e6 24		inc $24		                inc tmp1
.bae5		d0 02		bne $bae9	                bne +
.bae7		e6 25		inc $25		                inc tmp1+1
.bae9						+
.bae9		80 ef		bra $bada	                bra _last_line_loop
.baeb						_last_line_done:
.baeb		a5 24		lda $24		                lda tmp1
.baed		95 00		sta $00,x	                sta 0,x
.baef		a5 25		lda $25		                lda tmp1+1
.baf1		95 01		sta $01,x	                sta 1,x                 ; ( u )
.baf3		60		rts		                rts
.baf4						ed_no_line_zero:
.baf4		b5 02		lda $02,x	                lda 2,x
.baf6		15 03		ora $03,x	                ora 3,x
.baf8		d0 07		bne $bb01	                bne _no_line_zero_done
.bafa		24 32		bit $32		                bit ed_flags
.bafc		10 03		bpl $bb01	                bpl _no_line_zero_done
.bafe		4c 7c ba	jmp $ba7c	                jmp ed_error_2drop
.bb01						_no_line_zero_done:
.bb01		60		rts		                rts
.bb02						ed_num_to_addr:
.bb02		ca		dex		                dex
.bb03		ca		dex		                dex                     ; ( u ? )
.bb04		a9 2e		lda #$2e	                lda #<ed_head
.bb06		95 00		sta $00,x	                sta 0,x
.bb08		a9 00		lda #$00	                lda #>ed_head
.bb0a		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bb0c		b5 02		lda $02,x	                lda 2,x
.bb0e		15 03		ora $03,x	                ora 3,x
.bb10		d0 05		bne $bb17	                bne _num_to_addr_loop
.bb12		20 f6 95	jsr $95f6	                jsr xt_nip              ; ( addr-h )
.bb15		80 21		bra $bb38	                bra _num_to_addr_done
.bb17						_num_to_addr_loop:
.bb17		20 33 8f	jsr $8f33	                jsr xt_fetch            ; @ ( u addr1 )
.bb1a		b5 00		lda $00,x	                lda 0,x
.bb1c		15 01		ora $01,x	                ora 1,x
.bb1e		d0 05		bne $bb25	                bne +
.bb20		20 f6 95	jsr $95f6	                jsr xt_nip              ; NIP ( addr1 )
.bb23		80 13		bra $bb38	                bra _num_to_addr_done
.bb25						+
.bb25		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr1 u )
.bb28		20 c5 97	jsr $97c5	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb2b		b5 00		lda $00,x	                lda 0,x
.bb2d		15 01		ora $01,x	                ora 1,x
.bb2f		f0 05		beq $bb36	                beq _num_to_addr_finished
.bb31		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb34		80 e1		bra $bb17	                bra _num_to_addr_loop
.bb36						_num_to_addr_finished:
.bb36		e8		inx		                inx
.bb37		e8		inx		                inx                     ; ( addr )
.bb38						_num_to_addr_done:
.bb38		60		rts		                rts
.bb39						ed_para1_to_cur:
.bb39		b5 02		lda $02,x	                lda 2,x
.bb3b		85 30		sta $30		                sta ed_cur
.bb3d		b5 03		lda $03,x	                lda 3,x
.bb3f		85 31		sta $31		                sta ed_cur+1
.bb41		60		rts		                rts
.bb42						ed_print_addr:
.bb42		20 d1 97	jsr $97d1	                jsr xt_one_plus
.bb45		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; ( addr+2 )
.bb48		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb4b		20 d1 97	jsr $97d1	                jsr xt_one_plus
.bb4e		20 d1 97	jsr $97d1	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb51		20 33 8f	jsr $8f33	                jsr xt_fetch            ; ( addr+2 u-s )
.bb54		20 33 a1	jsr $a133	                jsr xt_swap             ; ( u-s addr+2 )
.bb57		20 33 8f	jsr $8f33	                jsr xt_fetch            ; ( u-s addr-s )
.bb5a		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-s u-s )
.bb5d		20 88 a4	jsr $a488	                jsr xt_type
.bb60		20 2a 89	jsr $892a	                jsr xt_cr
.bb63		60		rts		                rts
>bb64		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb6c		71 51 00
.bb6f						ed_cmd_table:
>bb6f		b4 b7 fb b8 2e b9 57 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bb77		56 b9 4f b9
>bb7b		bf b8 c9 b9 ba b9 c5 b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bb83						ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bb83						forth_words_start:
>bb83		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb8b		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb9b		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bbab		20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bbbb		20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bbcb		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bbdb		2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bbeb		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bbfb		77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bc0b		20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bc1b		69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc2b		4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc3b		28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc4b		65 78 69 74 29 20 63 72 20
.bc54						forth_words_end:
.bc54						user_words_start:
>bc54		20 20				.binary "user_words.asc"
.bc56						user_words_end:

;******  Processing file: platform/../headers.asm

.bc56						dictionary_start:
.bc56						nt_drop:
>bc56		04 10				        .byte 4, UF
>bc58		62 bc e1 8c e6 8c		        .word nt_dup, xt_drop, z_drop
>bc5e		64 72 6f 70			        .text "drop"
.bc62						nt_dup:
>bc62		03 10				        .byte 3, UF
>bc64		6d bc 62 8d 6f 8d		        .word nt_swap, xt_dup, z_dup
>bc6a		64 75 70			        .text "dup"
.bc6d						nt_swap:
>bc6d		04 10				        .byte 4, UF
>bc6f		79 bc 33 a1 46 a1		        .word nt_store, xt_swap, z_swap
>bc75		73 77 61 70			        .text "swap"
.bc79						nt_store:
>bc79		01 10				        .byte 1, UF
>bc7b		82 bc 12 a1 27 a1		        .word nt_fetch, xt_store, z_store
>bc81		21				        .text "!"
.bc82						nt_fetch:
>bc82		01 10				        .byte 1, UF
>bc84		8b bc 33 8f 45 8f		        .word nt_over, xt_fetch, z_fetch
>bc8a		40				        .text "@"
.bc8b						nt_over:
>bc8b		04 10				        .byte 4, UF
>bc8d		97 bc 47 98 54 98		        .word nt_to_r, xt_over, z_over
>bc93		6f 76 65 72			        .text "over"
.bc97						nt_to_r:
>bc97		02 11				        .byte 2, CO+UF ; native is special case
>bc99		a1 bc f5 a2 08 a3		        .word nt_r_from, xt_to_r, z_to_r
>bc9f		3e 72				        .text ">r"
.bca1						nt_r_from:
>bca1		02 01				        .byte 2, CO    ; native is special case
>bca3		ab bc 46 9a 56 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bca9		72 3e				        .text "r>"
.bcab						nt_r_fetch:
>bcab		02 01				        .byte 2, CO    ; native is special case
>bcad		b5 bc 31 9a 45 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bcb3		72 40				        .text "r@"
.bcb5						nt_nip:
>bcb5		03 10				        .byte 3, UF
>bcb7		c0 bc f6 95 03 96		        .word nt_rot, xt_nip, z_nip
>bcbd		6e 69 70			        .text "nip"
.bcc0						nt_rot:
>bcc0		03 10				        .byte 3, UF
>bcc2		cb bc 0b 9b 26 9b		        .word nt_not_rote, xt_rot, z_rot
>bcc8		72 6f 74			        .text "rot"
.bccb						nt_not_rote:
>bccb		04 10				        .byte 4, UF
>bccd		d7 bc 22 96 3d 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bcd3		2d 72 6f 74			        .text "-rot"
.bcd7						nt_tuck:
>bcd7		04 10				        .byte 4, UF
>bcd9		e3 bc 12 a3 2b a3		        .word nt_comma, xt_tuck, z_tuck
>bcdf		74 75 63 6b			        .text "tuck"
.bce3						nt_comma:
>bce3		01 10				        .byte 1, UF
>bce5		ec bc 24 87 3d 87		        .word nt_c_fetch, xt_comma, z_comma
>bceb		2c				        .text ","
.bcec						nt_c_fetch:
>bcec		02 10				        .byte 2, UF
>bcee		f6 bc c1 85 ca 85		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bcf4		63 40				        .text "c@"
.bcf6						nt_c_store:
>bcf6		02 10				        .byte 2, UF
>bcf8		00 bd cb 85 d6 85		        .word nt_plus_store, xt_c_store, z_c_store
>bcfe		63 21				        .text "c!"
.bd00						nt_plus_store:
>bd00		02 10				        .byte 2, UF
>bd02		0a bd aa 99 c9 99		        .word nt_execute, xt_plus_store, z_plus_store
>bd08		2b 21				        .text "+!"
.bd0a						nt_execute:
>bd0a		07 10				        .byte 7, UF
>bd0c		19 bd f0 8e f6 8e		        .word nt_emit, xt_execute, z_execute
>bd12		65 78 65 63 75 74 65		        .text "execute"
.bd19						nt_emit:
>bd19		04 18				        .byte 4, NN+UF
>bd1b		25 bd a2 8d ac 8d		        .word nt_type, xt_emit, z_emit
>bd21		65 6d 69 74			        .text "emit"
.bd25						nt_type:
>bd25		04 10				        .byte 4, UF
>bd27		31 bd 88 a4 b2 a4		        .word nt_dot, xt_type, z_type
>bd2d		74 79 70 65			        .text "type"
.bd31						nt_dot:
>bd31		01 10				        .byte 1, UF
>bd33		3a bd e9 8b 0a 8c		        .word nt_u_dot, xt_dot, z_dot
>bd39		2e				        .text "."
.bd3a						nt_u_dot:
>bd3a		02 10				        .byte 2, UF
>bd3c		44 bd b3 a4 be a4		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd42		75 2e				        .text "u."
.bd44						nt_u_dot_r:
>bd44		03 10				        .byte 3, UF
>bd46		4f bd bf a4 e0 a4		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd4c		75 2e 72			        .text "u.r"
.bd4f						nt_dot_r:
>bd4f		02 10				        .byte 2, UF
>bd51		59 bd 25 8c 52 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd57		2e 72				        .text ".r"
.bd59						nt_d_dot:
>bd59		02 10				        .byte 2, UF
>bd5b		63 bd 97 8c b5 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd61		64 2e				        .text "d."
.bd63						nt_d_dot_r:
>bd63		03 10				        .byte 3, UF
>bd65		6e bd b6 8c e0 8c		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd6b		64 2e 72			        .text "d.r"
.bd6e						nt_ud_dot:
>bd6e		03 10				        .byte 3, UF
>bd70		79 bd 0d a5 1f a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd76		75 64 2e			        .text "ud."
.bd79						nt_ud_dot_r:
>bd79		04 10				        .byte 4, UF
>bd7b		85 bd 20 a5 3e a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd81		75 64 2e 72			        .text "ud.r"
.bd85						nt_question:
>bd85		01 00				        .byte 1, 0
>bd87		8e bd 16 9a 1c 9a		        .word nt_false, xt_question, z_question
>bd8d		3f				        .text "?"
.bd8e						nt_false:
>bd8e		05 00				        .byte 5, 0
>bd90		9b bd 2c 8f 32 8f		        .word nt_true, xt_false, z_false
>bd96		66 61 6c 73 65			        .text "false"
.bd9b						nt_true:
>bd9b		04 00				        .byte 4, 0
>bd9d		a7 bd 09 a3 11 a3		        .word nt_space, xt_true, z_true
>bda3		74 72 75 65			        .text "true"
.bda7						nt_space:
>bda7		05 00				        .byte 5, 0
>bda9		b4 bd a3 a0 a8 a0		        .word nt_zero, xt_space, z_space
>bdaf		73 70 61 63 65			        .text "space"
.bdb4						nt_zero:
>bdb4		01 00				        .byte 1, 0
>bdb6		bd bd 2d a7 33 a7		        .word nt_one, xt_zero, z_zero
>bdbc		30				        .text "0"
.bdbd						nt_one:
>bdbd		01 00				        .byte 1, 0
>bdbf		c6 bd bc 97 c4 97		        .word nt_two, xt_one, z_one
>bdc5		31				        .text "1"
.bdc6						nt_two:
>bdc6		01 00				        .byte 1, 0
>bdc8		cf bd 2c a3 34 a3		        .word nt_two_dup, xt_two, z_two
>bdce		32				        .text "2"
.bdcf						nt_two_dup:
>bdcf		04 10				        .byte 4, UF
>bdd1		db bd 3d a3 54 a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bdd7		32 64 75 70			        .text "2dup"
.bddb						nt_question_dup:
>bddb		04 10				        .byte 4, UF
>bddd		e7 bd 1d 9a 30 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bde3		3f 64 75 70			        .text "?dup"
.bde7						nt_plus:
>bde7		01 10				        .byte 1, UF
>bde9		f0 bd 97 99 a9 99		        .word nt_minus, xt_plus, z_plus
>bdef		2b				        .text "+"
.bdf0						nt_minus:
>bdf0		01 10				        .byte 1, UF
>bdf2		f9 bd 04 95 16 95		        .word nt_one_minus, xt_minus, z_minus
>bdf8		2d				        .text "-"
.bdf9						nt_one_minus:
>bdf9		02 10				        .byte 2, UF
>bdfb		03 be c5 97 d0 97		        .word nt_one_plus, xt_one_minus, z_one_minus
>be01		31 2d				        .text "1-"
.be03						nt_one_plus:
>be03		02 10				        .byte 2, UF
>be05		0d be d1 97 da 97		        .word nt_two_star, xt_one_plus, z_one_plus
>be0b		31 2b				        .text "1+"
.be0d						nt_two_star:
>be0d		02 10				        .byte 2, UF
>be0f		17 be d5 a3 dc a3		        .word nt_two_slash, xt_two_star, z_two_star
>be15		32 2a				        .text "2*"
.be17						nt_two_slash:
>be17		02 10				        .byte 2, UF
>be19		21 be ca a3 d4 a3		        .word nt_abs, xt_two_slash, z_two_slash
>be1f		32 2f				        .text "2/"
.be21						nt_abs:
>be21		03 10				        .byte 3, UF
>be23		2c be cd 80 e1 80		        .word nt_dabs, xt_abs, z_abs
>be29		61 62 73			        .text "abs"
.be2c						nt_dabs:
>be2c		04 10				        .byte 4, UF
>be2e		38 be 4d 8a 6b 8a		        .word nt_and, xt_dabs, z_dabs
>be34		64 61 62 73			        .text "dabs"
.be38						nt_and:
>be38		03 10				        .byte 3, UF
>be3a		43 be d2 82 e3 82		        .word nt_or, xt_and, z_and
>be40		61 6e 64			        .text "and"
.be43						nt_or:
>be43		02 10				        .byte 2, UF
>be45		4d be e7 97 f8 97		        .word nt_xor, xt_or, z_or
>be4b		6f 72				        .text "or"
.be4d						nt_xor:
>be4d		03 10				        .byte 3, UF
>be4f		58 be 1b a7 2c a7		        .word nt_rshift, xt_xor, z_xor
>be55		78 6f 72			        .text "xor"
.be58						nt_rshift:
>be58		06 10				        .byte 6, UF
>be5a		66 be 27 9b 3a 9b		        .word nt_lshift, xt_rshift, z_rshift
>be60		72 73 68 69 66 74		        .text "rshift"
.be66						nt_lshift:
>be66		06 10				        .byte 6, UF
>be68		74 be 2e 94 41 94		        .word nt_pick, xt_lshift, z_lshift
>be6e		6c 73 68 69 66 74		        .text "lshift"
.be74						nt_pick:
>be74		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be76		80 be 86 99 96 99		        .word nt_char, xt_pick, z_pick
>be7c		70 69 63 6b			        .text "pick"
.be80						nt_char:
>be80		04 00				        .byte 4, 0
>be82		8c be e7 85 fd 85		        .word nt_bracket_char, xt_char, z_char
>be88		63 68 61 72			        .text "char"
.be8c						nt_bracket_char:
>be8c		06 05				        .byte 6, CO+IM
>be8e		9a be 4d 85 53 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>be94		5b 63 68 61 72 5d		        .text "[char]"
.be9a						nt_char_plus:
>be9a		05 00				        .byte 5, 0
>be9c		a7 be d1 97 da 97		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bea2		63 68 61 72 2b			        .text "char+"
.bea7						nt_chars:
>bea7		05 12				        .byte 5, AN+UF   ; deleted during compile
>bea9		b4 be fe 85 01 86		        .word nt_cells, xt_chars, z_chars
>beaf		63 68 61 72 73			        .text "chars"
.beb4						nt_cells:
>beb4		05 00				        .byte 5, 0
>beb6		c1 be d5 a3 dc a3		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bebc		63 65 6c 6c 73			        .text "cells"
.bec1						nt_cell_plus:
>bec1		05 10				        .byte 5, UF
>bec3		ce be d7 85 e6 85		        .word nt_here, xt_cell_plus, z_cell_plus
>bec9		63 65 6c 6c 2b			        .text "cell+"
.bece						nt_here:
>bece		04 00				        .byte 4, 0
>bed0		da be 25 91 2f 91		        .word nt_equal, xt_here, z_here
>bed6		68 65 72 65			        .text "here"
.beda						nt_equal:
>beda		01 10				        .byte 1, UF
>bedc		e3 be 81 8e 9c 8e		        .word nt_not_equals, xt_equal, z_equal
>bee2		3d				        .text "="
.bee3						nt_not_equals:
>bee3		02 10				        .byte 2, UF
>bee5		ed be 04 96 21 96		        .word nt_less_than, xt_not_equals, z_not_equals
>beeb		3c 3e				        .text "<>"
.beed						nt_less_than:
>beed		01 10				        .byte 1, UF
>beef		f6 be 19 93 2d 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bef5		3c				        .text "<"
.bef6						nt_u_less_than:
>bef6		02 10				        .byte 2, UF
>bef8		00 bf f7 a4 0c a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>befe		75 3c				        .text "u<"
.bf00						nt_u_greater_than:
>bf00		02 10				        .byte 2, UF
>bf02		0a bf e1 a4 f6 a4		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bf08		75 3e				        .text "u>"
.bf0a						nt_greater_than:
>bf0a		01 10				        .byte 1, UF
>bf0c		13 bf 10 91 24 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bf12		3e				        .text ">"
.bf13						nt_zero_equal:
>bf13		02 10				        .byte 2, UF
>bf15		1d bf 34 a7 45 a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bf1b		30 3d				        .text "0="
.bf1d						nt_zero_unequal:
>bf1d		03 10				        .byte 3, UF
>bf1f		28 bf 6a a7 79 a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bf25		30 3c 3e			        .text "0<>"
.bf28						nt_zero_greater:
>bf28		02 10				        .byte 2, UF
>bf2a		32 bf 46 a7 59 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bf30		30 3e				        .text "0>"
.bf32						nt_zero_less:
>bf32		02 10				        .byte 2, UF
>bf34		3c bf 5a a7 69 a7		        .word nt_min, xt_zero_less, z_zero_less
>bf3a		30 3c				        .text "0<"
.bf3c						nt_min:
>bf3c		03 10				        .byte 3, UF
>bf3e		47 bf e8 94 03 95		        .word nt_max, xt_min, z_min
>bf44		6d 69 6e			        .text "min"
.bf47						nt_max:
>bf47		03 10				        .byte 3, UF
>bf49		52 bf cc 94 e7 94		        .word nt_two_drop, xt_max, z_max
>bf4f		6d 61 78			        .text "max"
.bf52						nt_two_drop:
>bf52		05 10				        .byte 5, UF
>bf54		5f bf 35 a3 3c a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf5a		32 64 72 6f 70			        .text "2drop"
.bf5f						nt_two_swap:
>bf5f		05 10				        .byte 5, UF
>bf61		6c bf 03 a4 26 a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf67		32 73 77 61 70			        .text "2swap"
.bf6c						nt_two_over:
>bf6c		05 10				        .byte 5, UF
>bf6e		79 bf 77 a3 8e a3		        .word nt_two_store, xt_two_over, z_two_over
>bf74		32 6f 76 65 72			        .text "2over"
.bf79						nt_two_store:
>bf79		02 10				        .byte 2, UF
>bf7b		83 bf dd a3 02 a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bf81		32 21				        .text "2!"
.bf83						nt_two_fetch:
>bf83		02 10				        .byte 2, UF
>bf85		8d bf 55 a3 76 a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bf8b		32 40				        .text "2@"
.bf8d						nt_two_variable:
>bf8d		09 00				        .byte 9, 0
>bf8f		9e bf 79 a4 87 a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>bf95		32 76 61 72 69 61 62 6c		        .text "2variable"
>bf9d		65
.bf9e						nt_two_constant:
>bf9e		09 10				        .byte 9, UF
>bfa0		af bf 47 a4 6b a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bfa6		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bfae		74
.bfaf						nt_two_literal:
>bfaf		08 14				        .byte 8, UF+IM
>bfb1		bf bf 6c a4 78 a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bfb7		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bfbf						nt_two_r_fetch:
>bfbf		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bfc1		ca bf 8f a3 ac a3		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bfc7		32 72 40			        .text "2r@"
.bfca						nt_two_r_from:
>bfca		03 01				        .byte 3, CO             ; native is special case
>bfcc		d5 bf ad a3 c9 a3		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bfd2		32 72 3e			        .text "2r>"
.bfd5						nt_two_to_r:
>bfd5		03 11				        .byte 3, CO+UF          ; native is special case
>bfd7		e0 bf 27 a4 46 a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>bfdd		32 3e 72			        .text "2>r"
.bfe0						nt_invert:
>bfe0		06 10				        .byte 6, UF
>bfe2		ee bf 9c 92 ab 92		        .word nt_negate, xt_invert, z_invert
>bfe8		69 6e 76 65 72 74		        .text "invert"
.bfee						nt_negate:
>bfee		06 10				        .byte 6, UF
>bff0		fc bf d7 95 e7 95		        .word nt_dnegate, xt_negate, z_negate
>bff6		6e 65 67 61 74 65		        .text "negate"
.bffc						nt_dnegate:
>bffc		07 10				        .byte 7, UF
>bffe		0b c0 08 8b 22 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>c004		64 6e 65 67 61 74 65		        .text "dnegate"
.c00b						nt_c_comma:
>c00b		02 10				        .byte 2, UF
>c00d		15 c0 b6 85 c0 85		        .word nt_bounds, xt_c_comma, z_c_comma
>c013		63 2c				        .text "c,"
.c015						nt_bounds:
>c015		06 10				        .byte 6, UF
>c017		23 c0 34 85 4c 85		        .word nt_spaces, xt_bounds, z_bounds
>c01d		62 6f 75 6e 64 73		        .text "bounds"
.c023						nt_spaces:
>c023		06 10				        .byte 6, UF
>c025		31 c0 a9 a0 e4 a0		        .word nt_bl, xt_spaces, z_spaces
>c02b		73 70 61 63 65 73		        .text "spaces"
.c031						nt_bl:
>c031		02 00				        .byte 2, 0
>c033		3b c0 50 83 58 83		        .word nt_minus_trailing, xt_bl, z_bl
>c039		62 6c				        .text "bl"
.c03b						nt_minus_trailing:
>c03b		09 10				        .byte 9, UF
>c03d		4c c0 30 95 6c 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c043		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c04b		67
.c04c						nt_minus_leading:
>c04c		08 10				        .byte 8, UF
>c04e		5c c0 17 95 2f 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c054		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c05c						nt_slash_string:
>c05c		07 10				        .byte 7, UF
>c05e		6b c0 9e 9f bd 9f		        .word nt_refill, xt_slash_string, z_slash_string
>c064		2f 73 74 72 69 6e 67		        .text "/string"
.c06b						nt_refill:
>c06b		06 00				        .byte 6, 0
>c06d		79 c0 ac 9a ed 9a		        .word nt_accept, xt_refill, z_refill
>c073		72 65 66 69 6c 6c		        .text "refill"
.c079						nt_accept:
>c079		06 18				        .byte 6, UF+NN
>c07b		87 c0 e2 80 da 81		        .word nt_input_to_r, xt_accept, z_accept
>c081		61 63 63 65 70 74		        .text "accept"
.c087						nt_input_to_r:
>c087		07 08				        .byte 7, NN
>c089		96 c0 13 92 28 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c08f		69 6e 70 75 74 3e 72		        .text "input>r"
.c096						nt_r_to_input:
>c096		07 08				        .byte 7, NN
>c098		a5 c0 57 9a 6e 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c09e		72 3e 69 6e 70 75 74		        .text "r>input"
.c0a5						nt_unused:
>c0a5		06 00				        .byte 6, 0
>c0a7		b3 c0 d9 a5 e8 a5		        .word nt_depth, xt_unused, z_unused
>c0ad		75 6e 75 73 65 64		        .text "unused"
.c0b3						nt_depth:
>c0b3		05 00				        .byte 5, 0
>c0b5		c0 c0 bd 8a cb 8a		        .word nt_key, xt_depth, z_depth
>c0bb		64 65 70 74 68			        .text "depth"
.c0c0						nt_key:
>c0c0		03 00				        .byte 3, 0
>c0c2		cb c0 df 92 e8 92		        .word nt_allot, xt_key, z_key
>c0c8		6b 65 79			        .text "key"
.c0cb						nt_allot:
>c0cb		05 10				        .byte 5, UF
>c0cd		d8 c0 3f 82 a7 82		        .word nt_create, xt_allot, z_allot
>c0d3		61 6c 6c 6f 74			        .text "allot"
.c0d8						nt_create:
>c0d8		06 00				        .byte 6, 0
>c0da		e6 c0 30 89 04 8a		        .word nt_does, xt_create, z_create
>c0e0		63 72 65 61 74 65		        .text "create"
.c0e6						nt_does:
>c0e6		05 05				        .byte 5, CO+IM
>c0e8		f3 c0 a8 8b b6 8b		        .word nt_variable, xt_does, z_does
>c0ee		64 6f 65 73 3e			        .text "does>"
.c0f3						nt_variable:
>c0f3		08 00				        .byte 8, 0
>c0f5		03 c1 fd a5 15 a6		        .word nt_constant, xt_variable, z_variable
>c0fb		76 61 72 69 61 62 6c 65		        .text "variable"
.c103						nt_constant:
>c103		08 10				        .byte 8, UF
>c105		13 c1 d8 88 15 89		        .word nt_value, xt_constant, z_constant
>c10b		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c113						nt_value:
>c113		05 10				        .byte 5, UF
>c115		20 c1 d8 88 15 89		        .word nt_to, xt_constant, z_constant
>c11b		76 61 6c 75 65			        .text "value"
.c120						nt_to:
>c120		02 0c				        .byte 2, NN+IM
>c122		2a c1 b6 a1 11 a2		        .word nt_s_to_d, xt_to, z_to
>c128		74 6f				        .text "to"
.c12a						nt_s_to_d:
>c12a		03 10				        .byte 3, UF
>c12c		35 c1 31 9e 42 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c132		73 3e 64			        .text "s>d"
.c135						nt_d_to_s:
>c135		03 10				        .byte 3, UF
>c137		40 c1 47 8a 4c 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c13d		64 3e 73			        .text "d>s"
.c140						nt_d_minus:
>c140		02 10				        .byte 2, UF
>c142		4a c1 05 8a 25 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c148		64 2d				        .text "d-"
.c14a						nt_d_plus:
>c14a		02 10				        .byte 2, UF
>c14c		54 c1 26 8a 46 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c152		64 2b				        .text "d+"
.c154						nt_erase:
>c154		05 00				        .byte 5, 0      ; underflow checked by FILL
>c156		61 c1 a7 8e ef 8e		        .word nt_blank, xt_erase, z_erase
>c15c		65 72 61 73 65			        .text "erase"
.c161						nt_blank:
>c161		05 00				        .byte 5, 0     ; underflow checked by FILL
>c163		6e c1 9d 8e ef 8e		        .word nt_fill, xt_blank, z_blank
>c169		62 6c 61 6e 6b			        .text "blank"
.c16e						nt_fill:
>c16e		04 10				        .byte 4, UF
>c170		7a c1 ad 8e ef 8e		        .word nt_find_name, xt_fill, z_fill
>c176		66 69 6c 6c			        .text "fill"
.c17a						nt_find_name:
>c17a		09 10				        .byte 9, UF
>c17c		8b c1 8e 8f 39 90		        .word nt_tick, xt_find_name, z_find_name
>c182		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c18a		65
.c18b						nt_tick:
>c18b		01 00				        .byte 1, 0
>c18d		94 c1 96 a1 b5 a1		        .word nt_bracket_tick, xt_tick, z_tick
>c193		27				        .text "'"
.c194						nt_bracket_tick:
>c194		03 05				        .byte 3, CO+IM
>c196		9f c1 54 85 5a 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c19c		5b 27 5d			        .text "[']"
.c19f						nt_name_to_int:
>c19f		08 10				        .byte 8, UF
>c1a1		af c1 95 95 b1 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c1a7		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c1af						nt_int_to_name:
>c1af		08 10				        .byte 8, UF
>c1b1		bf c1 29 92 9b 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c1b7		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c1bf						nt_name_to_string:
>c1bf		0b 10				        .byte 11, UF
>c1c1		d2 c1 b2 95 cb 95		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c1c7		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1cf		69 6e 67
.c1d2						nt_to_body:
>c1d2		05 10				        .byte 5, UF
>c1d4		df c1 12 a2 36 a2		        .word nt_defer, xt_to_body, z_to_body
>c1da		3e 62 6f 64 79			        .text ">body"
.c1df						nt_defer:
>c1df		05 00				        .byte 5, 0
>c1e1		ec c1 73 8a a5 8a		        .word nt_latestxt, xt_defer, z_defer
>c1e7		64 65 66 65 72			        .text "defer"
.c1ec						nt_latestxt:
>c1ec		08 00				        .byte 8, 0
>c1ee		fc c1 fa 92 00 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c1f4		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c1fc						nt_latestnt:
>c1fc		08 00				        .byte 8, 0
>c1fe		0c c2 ec 92 f9 92		        .word nt_parse_name, xt_latestnt, z_latestnt
>c204		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c20c						nt_parse_name:
>c20c		0a 08				        .byte 10, NN
>c20e		1e c2 93 98 85 99		        .word nt_parse, xt_parse_name, z_parse_name
>c214		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c21c		6d 65
.c21e						nt_parse:
>c21e		05 10				        .byte 5, UF
>c220		2b c2 ee 98 85 99		        .word nt_execute_parsing, xt_parse, z_parse
>c226		70 61 72 73 65			        .text "parse"
.c22b						nt_execute_parsing:
>c22b		0f 10				        .byte 15, UF
>c22d		42 c2 04 8f 2a 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c233		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c23b		70 61 72 73 69 6e 67
.c242						nt_source:
>c242		06 00				        .byte 6, 0
>c244		50 c2 83 a0 97 a0		        .word nt_source_id, xt_source, z_source
>c24a		73 6f 75 72 63 65		        .text "source"
.c250						nt_source_id:
>c250		09 00				        .byte 9, 0
>c252		61 c2 98 a0 a2 a0		        .word nt_colon, xt_source_id, z_source_id
>c258		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c260		64
.c261						nt_colon:
>c261		01 00				        .byte 1, 0
>c263		6a c2 c5 86 07 87		        .word nt_semicolon, xt_colon, z_colon
>c269		3a				        .text ":"
.c26a						nt_semicolon:
>c26a		01 05				        .byte 1, CO+IM
>c26c		73 c2 0d 9f 6b 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c272		3b				        .text ";"
.c273						nt_colon_noname:
>c273		07 00				        .byte 7, 0
>c275		82 c2 08 87 23 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c27b		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c282						nt_compile_comma:
>c282		08 18				        .byte 8, UF+NN
>c284		92 c2 a3 87 cb 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c28a		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c292						nt_left_bracket:
>c292		01 05				        .byte 1, IM+CO
>c294		9b c2 06 93 0a 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c29a		5b				        .text "["
.c29b						nt_right_bracket:
>c29b		01 04				        .byte 1, IM
>c29d		a4 c2 fb 9a 01 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c2a3		5d				        .text "]"
.c2a4						nt_literal:
>c2a4		07 15				        .byte 7, IM+CO+UF
>c2a6		b3 c2 3b 93 48 93		        .word nt_sliteral, xt_literal, z_literal
>c2ac		6c 69 74 65 72 61 6c		        .text "literal"
.c2b3						nt_sliteral:
>c2b3		08 15				        .byte 8, CO+IM+UF
>c2b5		c3 c2 be 9f 2d a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c2bb		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c2c3						nt_dot_quote:
>c2c3		02 05				        .byte 2, CO+IM
>c2c5		cd c2 1a 8c 24 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c2cb		2e 22				        .text ".", $22
.c2cd						nt_s_quote:
>c2cd		02 0c				        .byte 2, IM+NN
>c2cf		d7 c2 03 9d 30 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c2d5		73 22				        .text "s", $22
.c2d7						nt_s_backslash_quote:
>c2d7		03 04				        .byte 3, IM
>c2d9		e2 c2 3b 9b 44 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c2df		73 5c 22			        .text "s", $5C, $22
.c2e2						nt_postpone:
>c2e2		08 05				        .byte 8, IM+CO
>c2e4		f2 c2 ca 99 08 9a		        .word nt_immediate, xt_postpone, z_postpone
>c2ea		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c2f2						nt_immediate:
>c2f2		09 00				        .byte 9, 0
>c2f4		03 c3 fc 91 07 92		        .word nt_compile_only, xt_immediate, z_immediate
>c2fa		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c302		65
.c303						nt_compile_only:
>c303		0c 00				        .byte 12, 0
>c305		17 c3 cc 88 d7 88		        .word nt_never_native, xt_compile_only, z_compile_only
>c30b		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c313		6f 6e 6c 79
.c317						nt_never_native:
>c317		0c 00				        .byte 12, 0
>c319		2b c3 e8 95 f5 95		        .word nt_always_native, xt_never_native, z_never_native
>c31f		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c327		74 69 76 65
.c32b						nt_always_native:
>c32b		0d 00				        .byte 13, 0
>c32d		40 c3 c4 82 d1 82		        .word nt_allow_native, xt_always_native, z_always_native
>c333		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c33b		61 74 69 76 65
.c340						nt_allow_native:
>c340		0c 00				        .byte 12, 0
>c342		54 c3 a8 82 b3 82		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c348		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c350		74 69 76 65
.c354						nt_nc_limit:
>c354		08 00				        .byte 8, 0
>c356		64 c3 cc 95 d6 95		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c35c		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c364						nt_strip_underflow:
>c364		0f 00				        .byte 15, 0
>c366		7b c3 28 a1 32 a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c36c		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c374		64 65 72 66 6c 6f 77
.c37b						nt_abort:
>c37b		05 00				        .byte 5, 0
>c37d		88 c3 60 80 ad 80		        .word nt_abort_quote, xt_abort, z_abort
>c383		61 62 6f 72 74			        .text "abort"
.c388						nt_abort_quote:
>c388		06 0d				        .byte 6, CO+IM+NN
>c38a		96 c3 ad 80 b7 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c390		61 62 6f 72 74 22		        .text "abort", $22
.c396						nt_do:
>c396		02 0d				        .byte 2, CO+IM+NN
>c398		a0 c3 29 8b 62 8b		        .word nt_question_do, xt_do, z_do
>c39e		64 6f				        .text "do"
.c3a0						nt_question_do:
>c3a0		03 0d				        .byte 3, CO+IM+NN
>c3a2		ab c3 23 8b 62 8b		        .word nt_i, xt_question_do, z_question_do
>c3a8		3f 64 6f			        .text "?do"
.c3ab						nt_i:
>c3ab		01 03				        .byte 1, AN+CO
>c3ad		b4 c3 9c 91 b3 91		        .word nt_j, xt_i, z_i
>c3b3		69				        .text "i"
.c3b4						nt_j:
>c3b4		01 03				        .byte 1, AN+CO
>c3b6		bd c3 c5 92 de 92		        .word nt_loop, xt_j, z_j
>c3bc		6a				        .text "j"
.c3bd						nt_loop:
>c3bd		04 05				        .byte 4, CO+IM
>c3bf		c9 c3 ac 93 09 94		        .word nt_plus_loop, xt_loop, z_loop
>c3c5		6c 6f 6f 70			        .text "loop"
.c3c9						nt_plus_loop:
>c3c9		05 05				        .byte 5, CO+IM
>c3cb		d6 c3 bd 93 09 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3d1		2b 6c 6f 6f 70			        .text "+loop"
.c3d6						nt_exit:
>c3d6		04 03				        .byte 4, AN+CO
>c3d8		e2 c3 2b 8f 2c 8f		        .word nt_unloop, xt_exit, z_exit
>c3de		65 78 69 74			        .text "exit"
.c3e2						nt_unloop:
>c3e2		06 03				        .byte 6, AN+CO
>c3e4		f0 c3 c7 a5 cd a5		        .word nt_leave, xt_unloop, z_unloop
>c3ea		75 6e 6c 6f 6f 70		        .text "unloop"
.c3f0						nt_leave:
>c3f0		05 03				        .byte 5, AN+CO
>c3f2		fd c3 01 93 06 93		        .word nt_recurse, xt_leave, z_leave
>c3f8		6c 65 61 76 65			        .text "leave"
.c3fd						nt_recurse:
>c3fd		07 0d				        .byte 7, CO+IM+NN
>c3ff		0c c4 6f 9a ab 9a		        .word nt_quit, xt_recurse, z_recurse
>c405		72 65 63 75 72 73 65		        .text "recurse"
.c40c						nt_quit:
>c40c		04 00				        .byte 4, 0
>c40e		18 c4 62 80 ad 80		        .word nt_begin, xt_quit, z_quit
>c414		71 75 69 74			        .text "quit"
.c418						nt_begin:
>c418		05 07				        .byte 5, AN+CO+IM
>c41a		25 c4 46 83 49 83		        .word nt_again, xt_begin, z_begin
>c420		62 65 67 69 6e			        .text "begin"
.c425						nt_again:
>c425		05 17				        .byte 5, AN+CO+IM+UF
>c427		32 c4 1d 82 3d 82		        .word nt_state, xt_again, z_again
>c42d		61 67 61 69 6e			        .text "again"
.c432						nt_state:
>c432		05 00				        .byte 5, 0
>c434		3f c4 07 a1 11 a1		        .word nt_evaluate, xt_state, z_state
>c43a		73 74 61 74 65			        .text "state"
.c43f						nt_evaluate:
>c43f		08 10				        .byte 8, UF
>c441		4f c4 88 90 db 90		        .word nt_base, xt_evaluate, z_evaluate
>c447		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c44f						nt_base:
>c44f		04 00				        .byte 4, 0
>c451		5b c4 3d 83 45 83		        .word nt_digit_question, xt_base, z_base
>c457		62 61 73 65			        .text "base"
.c45b						nt_digit_question:
>c45b		06 10				        .byte 6, UF
>c45d		69 c4 cc 8a 00 8b		        .word nt_number, xt_digit_question, z_digit_question
>c463		64 69 67 69 74 3f		        .text "digit?"
.c469						nt_number:
>c469		06 10				        .byte 6, UF
>c46b		77 c4 3e 96 3a 97		        .word nt_to_number, xt_number, z_number
>c471		6e 75 6d 62 65 72		        .text "number"
.c477						nt_to_number:
>c477		07 10				        .byte 7, UF
>c479		86 c4 42 a2 e1 a2		        .word nt_hex, xt_to_number, z_to_number
>c47f		3e 6e 75 6d 62 65 72		        .text ">number"
.c486						nt_hex:
>c486		03 00				        .byte 3, 0
>c488		91 c4 30 91 36 91		        .word nt_decimal, xt_hex, z_hex
>c48e		68 65 78			        .text "hex"
.c491						nt_decimal:
>c491		07 00				        .byte 7, 0
>c493		a0 c4 6c 8a 72 8a		        .word nt_count, xt_decimal, z_decimal
>c499		64 65 63 69 6d 61 6c		        .text "decimal"
.c4a0						nt_count:
>c4a0		05 10				        .byte 5, UF
>c4a2		ad c4 16 89 29 89		        .word nt_m_star, xt_count, z_count
>c4a8		63 6f 75 6e 74			        .text "count"
.c4ad						nt_m_star:
>c4ad		02 10				        .byte 2, UF
>c4af		b7 c4 42 94 5c 94		        .word nt_um_star, xt_m_star, z_m_star
>c4b5		6d 2a				        .text "m*"
.c4b7						nt_um_star:
>c4b7		03 10				        .byte 3, UF
>c4b9		c2 c4 81 a5 c6 a5		        .word nt_star, xt_um_star, z_um_star
>c4bf		75 6d 2a			        .text "um*"
.c4c2						nt_star:
>c4c2		01 10				        .byte 1, UF
>c4c4		cb c4 e5 a0 ed a0		        .word nt_um_slash_mod, xt_star, z_star
>c4ca		2a				        .text "*"
.c4cb						nt_um_slash_mod:
>c4cb		06 10				        .byte 6, UF
>c4cd		d9 c4 3f a5 80 a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c4d3		75 6d 2f 6d 6f 64		        .text "um/mod"
.c4d9						nt_sm_slash_rem:
>c4d9		06 10				        .byte 6, UF
>c4db		e7 c4 5a a0 82 a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c4e1		73 6d 2f 72 65 6d		        .text "sm/rem"
.c4e7						nt_fm_slash_mod:
>c4e7		06 10				        .byte 6, UF
>c4e9		f5 c4 44 90 7a 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c4ef		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c4f5						nt_slash:
>c4f5		01 10				        .byte 1, UF
>c4f7		fe c4 81 9f 9d 9f		        .word nt_slash_mod, xt_slash, z_slash
>c4fd		2f				        .text "/"
.c4fe						nt_slash_mod:
>c4fe		04 10				        .byte 4, UF
>c500		0a c5 86 9f 9d 9f		        .word nt_mod, xt_slash_mod, z_slash_mod
>c506		2f 6d 6f 64			        .text "/mod"
.c50a						nt_mod:
>c50a		03 10				        .byte 3, UF
>c50c		15 c5 6d 95 75 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c512		6d 6f 64			        .text "mod"
.c515						nt_star_slash_mod:
>c515		05 10				        .byte 5, UF
>c517		22 c5 f7 a0 06 a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c51d		2a 2f 6d 6f 64			        .text "*/mod"
.c522						nt_star_slash:
>c522		02 10				        .byte 2, UF
>c524		2c c5 ee a0 f6 a0		        .word nt_backslash, xt_star_slash, z_star_slash
>c52a		2a 2f				        .text "*/"
.c52c						nt_backslash:
>c52c		01 04				        .byte 1, IM
>c52e		35 c5 12 83 3c 83		        .word nt_move, xt_backslash, z_backslash
>c534		5c				        .byte $5c
.c535						nt_move:
>c535		04 18				        .byte 4, NN+UF
>c537		41 c5 76 95 94 95		        .word nt_cmove_up, xt_move, z_move
>c53d		6d 6f 76 65			        .text "move"
.c541						nt_cmove_up:
>c541		06 10				        .byte 6, UF
>c543		4f c5 8a 86 c4 86		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c549		63 6d 6f 76 65 3e		        .text "cmove>"
.c54f						nt_cmove:
>c54f		05 10				        .byte 5, UF
>c551		5c c5 4f 86 89 86		        .word nt_pad, xt_cmove, z_cmove
>c557		63 6d 6f 76 65			        .text "cmove"
.c55c						nt_pad:
>c55c		03 00				        .byte 3, 0
>c55e		67 c5 55 98 64 98		        .word nt_cleave, xt_pad, z_pad
>c564		70 61 64			        .text "pad"
.c567						nt_cleave:
>c567		06 10				        .byte 6, UF
>c569		75 c5 02 86 4e 86		        .word nt_hexstore, xt_cleave, z_cleave
>c56f		63 6c 65 61 76 65		        .text "cleave"
.c575						nt_hexstore:
>c575		08 10				        .byte 8, UF
>c577		85 c5 37 91 89 91		        .word nt_within, xt_hexstore, z_hexstore
>c57d		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c585						nt_within:
>c585		06 10				        .byte 6, UF
>c587		93 c5 2a a6 3f a6		        .word nt_to_in, xt_within, z_within
>c58d		77 69 74 68 69 6e		        .text "within"
.c593						nt_to_in:
>c593		03 00				        .byte 3, 0
>c595		9e c5 37 a2 41 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c59b		3e 69 6e			        .text ">in"
.c59e						nt_less_number_sign:
>c59e		02 00				        .byte 2, 0
>c5a0		a8 c5 0b 93 18 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c5a6		3c 23				        .text "<#"
.c5a8						nt_number_sign:
>c5a8		01 10				        .byte 1, UF
>c5aa		b1 c5 3b 97 6f 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c5b0		23				        .text "#"
.c5b1						nt_number_sign_s:
>c5b1		02 10				        .byte 2, UF
>c5b3		bb c5 92 97 a2 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c5b9		23 73				        .text "#s"
.c5bb						nt_number_sign_greater:
>c5bb		02 10				        .byte 2, UF
>c5bd		c5 c5 70 97 91 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c5c3		23 3e				        .text "#>"
.c5c5						nt_hold:
>c5c5		04 10				        .byte 4, UF
>c5c7		d1 c5 8a 91 9b 91		        .word nt_sign, xt_hold, z_hold
>c5cd		68 6f 6c 64			        .text "hold"
.c5d1						nt_sign:
>c5d1		04 10				        .byte 4, UF
>c5d3		dd c5 6c 9f 80 9f		        .word nt_output, xt_sign, z_sign
>c5d9		73 69 67 6e			        .text "sign"
.c5dd						nt_output:
>c5dd		06 00				        .byte 6, 0
>c5df		eb c5 3c 98 46 98		        .word nt_input, xt_output, z_output
>c5e5		6f 75 74 70 75 74		        .text "output"
.c5eb						nt_input:
>c5eb		05 00				        .byte 5, 0
>c5ed		f8 c5 08 92 12 92		        .word nt_cr, xt_input, z_input
>c5f3		69 6e 70 75 74			        .text "input"
.c5f8						nt_cr:
>c5f8		02 00				        .byte 2, 0
>c5fa		02 c6 2a 89 2f 89		        .word nt_page, xt_cr, z_cr
>c600		63 72				        .text "cr"
.c602						nt_page:
>c602		04 00				        .byte 4, 0
>c604		0e c6 65 98 82 98		        .word nt_at_xy, xt_page, z_page
>c60a		70 61 67 65			        .text "page"
.c60e						nt_at_xy:
>c60e		05 10				        .byte 5, UF
>c610		1b c6 e4 82 11 83		        .word nt_marker, xt_at_xy, z_at_xy
>c616		61 74 2d 78 79			        .text "at-xy"
.c61b						nt_marker:
>c61b		06 04				        .byte 6, IM
>c61d		29 c6 5d 94 9a 94		        .word nt_words, xt_marker, z_marker
>c623		6d 61 72 6b 65 72		        .text "marker"
.c629						nt_words:
>c629		05 00				        .byte 5, 0
>c62b		36 c6 9d a6 f9 a6		        .word nt_wordsize, xt_words, z_words
>c631		77 6f 72 64 73			        .text "words"
.c636						nt_wordsize:
>c636		08 10				        .byte 8, UF
>c638		46 c6 fa a6 1a a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c63e		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c646						nt_aligned:
>c646		07 00				        .byte 7, 0
>c648		55 c6 3e 82 3e 82		        .word nt_align, xt_align, z_align
>c64e		61 6c 69 67 6e 65 64		        .text "aligned"
.c655						nt_align:
>c655		05 00				        .byte 5, 0
>c657		62 c6 3e 82 3e 82		        .word nt_bell, xt_align, z_align
>c65d		61 6c 69 67 6e			        .text "align"
.c662						nt_bell:
>c662		04 00				        .byte 4, 0
>c664		6e c6 4a 83 4f 83		        .word nt_dump, xt_bell, z_bell
>c66a		62 65 6c 6c			        .text "bell"
.c66e						nt_dump:
>c66e		04 10				        .byte 4, UF
>c670		7a c6 e7 8c 4d 8d		        .word nt_dot_s, xt_dump, z_dump
>c676		64 75 6d 70			        .text "dump"
.c67a						nt_dot_s:
>c67a		02 00				        .byte 2, 0
>c67c		84 c6 53 8c 96 8c		        .word +, xt_dot_s, z_dot_s
>c682		2e 73				        .text ".s"
.c684						+
.c684						nt_disasm:
>c684		06 10				        .byte 6, UF
>c686		92 c6 01 8b 07 8b		        .word +, xt_disasm, z_disasm
>c68c		64 69 73 61 73 6d		        .text "disasm"
.c692						+
.c692						nt_compare:
>c692		07 10				        .byte 7, UF
>c694		a1 c6 3e 87 a2 87		        .word nt_search, xt_compare, z_compare
>c69a		63 6f 6d 70 61 72 65		        .text "compare"
.c6a1						nt_search:
>c6a1		06 18				        .byte 6, UF+NN
>c6a3		af c6 6e 9e 0c 9f		        .word +, xt_search, z_search
>c6a9		73 65 61 72 63 68		        .text "search"
.c6af						+
.c6af						nt_environment_q:
>c6af		0c 10				        .byte 12, UF
>c6b1		c3 c6 c8 8d 44 8e		        .word +, xt_environment_q, z_environment_q
>c6b7		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c6bf		65 6e 74 3f
.c6c3						+
.c6c3						nt_find:
>c6c3		04 10				        .byte 4, UF
>c6c5		cf c6 46 8f 8d 8f		        .word nt_word, xt_find, z_find
>c6cb		66 69 6e 64			        .text "find"
.c6cf						nt_word:
>c6cf		04 10				        .byte 4, UF
>c6d1		db c6 40 a6 85 a6		        .word nt_paren, xt_word, z_word
>c6d7		77 6f 72 64			        .text "word"
.c6db						nt_paren:
>c6db		01 04				        .byte 1, IM
>c6dd		e4 c6 83 98 92 98		        .word nt_dot_paren, xt_paren, z_paren
>c6e3		28				        .text "("
.c6e4						nt_dot_paren:
>c6e4		02 04				        .byte 2, IM
>c6e6		ee c6 0b 8c 19 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c6ec		2e 28				        .text ".("
.c6ee						nt_if:
>c6ee		02 0d				        .byte 2, IM+CO+NN
>c6f0		f8 c6 b4 91 c4 91		        .word nt_then, xt_if, z_if
>c6f6		69 66				        .text "if"
.c6f8						nt_then:
>c6f8		04 0d				        .byte 4, IM+CO+NN
>c6fa		04 c7 47 a1 50 a1		        .word nt_else, xt_then, z_then
>c700		74 68 65 6e			        .text "then"
.c704						nt_else:
>c704		04 0d				        .byte 4, IM+CO+NN
>c706		10 c7 74 8d 8d 8d		        .word nt_repeat, xt_else, z_else
>c70c		65 6c 73 65			        .text "else"
.c710						nt_repeat:
>c710		06 0d				        .byte 6, IM+CO+NN
>c712		1e c7 ee 9a fa 9a		        .word nt_until, xt_repeat, z_repeat
>c718		72 65 70 65 61 74		        .text "repeat"
.c71e						nt_until:
>c71e		05 0d				        .byte 5, IM+CO+NN
>c720		2b c7 ce a5 d8 a5		        .word nt_while, xt_until, z_until
>c726		75 6e 74 69 6c			        .text "until"
.c72b						nt_while:
>c72b		05 0d				        .byte 5, IM+CO+NN
>c72d		38 c7 16 a6 29 a6		        .word nt_case, xt_while, z_while
>c733		77 68 69 6c 65			        .text "while"
.c738						nt_case:
>c738		04 0d				        .byte 4, IM+CO+NN
>c73a		44 c7 2d a7 33 a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c740		63 61 73 65			        .text "case"
.c744						nt_of:
>c744		02 0d				        .byte 2, IM+CO+NN
>c746		4e c7 a3 97 bb 97		        .word nt_endof, xt_of, z_of
>c74c		6f 66				        .text "of"
.c74e						nt_endof:
>c74e		05 0d				        .byte 5, IM+CO+NN
>c750		5b c7 74 8d 8d 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c756		65 6e 64 6f 66			        .text "endof"
.c75b						nt_endcase:
>c75b		07 0d				        .byte 7, IM+CO+NN
>c75d		6a c7 b3 8d c7 8d		        .word nt_defer_fetch, xt_endcase, z_endcase
>c763		65 6e 64 63 61 73 65		        .text "endcase"
.c76a						nt_defer_fetch:
>c76a		06 00				        .byte 6, 0
>c76c		78 c7 a6 8a ac 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c772		64 65 66 65 72 40		        .text "defer@"
.c778						nt_defer_store:
>c778		06 00				        .byte 6, 0
>c77a		86 c7 ad 8a b3 8a		        .word nt_is, xt_defer_store, z_defer_store
>c780		64 65 66 65 72 21		        .text "defer!"
.c786						nt_is:
>c786		02 04				        .byte 2, IM
>c788		90 c7 ac 92 c4 92		        .word nt_action_of, xt_is, z_is
>c78e		69 73				        .text "is"
.c790						nt_action_of:
>c790		09 04				        .byte 9, IM
>c792		a1 c7 04 82 1c 82		        .word nt_useraddr, xt_action_of, z_action_of
>c798		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c7a0		66
.c7a1						nt_useraddr:
>c7a1		08 00				        .byte 8, 0
>c7a3		b1 c7 f2 a5 fc a5		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c7a9		75 73 65 72 61 64 64 72		        .text "useraddr"
.c7b1						nt_buffer_colon:
>c7b1		07 00				        .byte 7, 0
>c7b3		c0 c7 9c 85 a2 85		        .word +, xt_buffer_colon, z_buffer_colon
>c7b9		62 75 66 66 65 72 3a		        .text "buffer:"
.c7c0						+
.c7c0						nt_buffstatus:
>c7c0		0a 00				        .byte 10, 0
>c7c2		d2 c7 a3 85 b2 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7c8		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7d0		75 73
.c7d2						nt_buffblocknum:
>c7d2		0c 00				        .byte 12, 0
>c7d4		e6 c7 5b 85 6a 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c7da		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c7e2		6b 6e 75 6d
.c7e6						nt_blkbuffer:
>c7e6		09 00				        .byte 9, 0
>c7e8		f7 c7 69 83 76 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c7ee		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c7f6		72
.c7f7						nt_scr:
>c7f7		03 00				        .byte 3, 0
>c7f9		02 c8 5e 9e 6d 9e		        .word nt_blk, xt_scr, z_scr
>c7ff		73 63 72			        .text "scr"
.c802						nt_blk:
>c802		03 00				        .byte 3, 0
>c804		0d c8 59 83 68 83		        .word nt_block_write, xt_blk, z_blk
>c80a		62 6c 6b			        .text "blk"
.c80d						nt_block_write:
>c80d		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c80f		20 c8 16 85 24 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c815		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c81d		69 74 65
.c820						nt_block_write_vector:
>c820		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c822		3a c8 24 85 33 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c828		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c830		69 74 65 2d 76 65 63 74 6f 72
.c83a						nt_block_read:
>c83a		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c83c		4c c8 f3 84 01 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c842		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c84a		61 64
.c84c						nt_block_read_vector:
>c84c		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c84e		65 c8 01 85 10 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c854		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c85c		61 64 2d 76 65 63 74 6f 72
.c865						nt_save_buffers:
>c865		0c 00				        .byte 12, 0
>c867		79 c8 43 9e 5d 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c86d		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c875		66 65 72 73
.c879						nt_block:
>c879		05 00				        .byte 5, 0
>c87b		86 c8 77 83 c9 83		        .word nt_update, xt_block, z_block
>c881		62 6c 6f 63 6b			        .text "block"
.c886						nt_update:
>c886		06 00				        .byte 6, 0
>c888		94 c8 e9 a5 f1 a5		        .word nt_buffer, xt_update, z_update
>c88e		75 70 64 61 74 65		        .text "update"
.c894						nt_buffer:
>c894		06 00				        .byte 6, 0
>c896		a2 c8 6b 85 9b 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c89c		62 75 66 66 65 72		        .text "buffer"
.c8a2						nt_empty_buffers:
>c8a2		0d 00				        .byte 13, 0
>c8a4		b7 c8 ac 8d b2 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c8aa		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c8b2		66 66 65 72 73
.c8b7						nt_flush:
>c8b7		05 00				        .byte 5, 0
>c8b9		c4 c8 3a 90 43 90		        .word nt_load, xt_flush, z_flush
>c8bf		66 6c 75 73 68			        .text "flush"
.c8c4						nt_load:
>c8c4		04 10				        .byte 4, UF
>c8c6		d0 c8 68 93 ab 93		        .word nt_thru, xt_load, z_load
>c8cc		6c 6f 61 64			        .text "load"
.c8d0						nt_thru:
>c8d0		04 10				        .byte 4, UF
>c8d2		dc c8 51 a1 95 a1		        .word nt_list, xt_thru, z_thru
>c8d8		74 68 72 75			        .text "thru"
.c8dc						nt_list:
>c8dc		04 10				        .byte 4, UF
>c8de		e8 c8 2e 93 3a 93		        .word +, xt_list, z_list
>c8e4		6c 69 73 74			        .text "list"
.c8e8						+
.c8e8						nt_block_ramdrive_init:
>c8e8		13 10				        .byte 19, UF
>c8ea		03 c9 ca 83 f2 84		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c8f0		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c8f8		6d 64 72 69 76 65 2d 69 6e 69 74
.c903						+
.c903						nt_definitions:
>c903		0b 00				        .byte 11, 0
>c905		16 c9 b4 8a bc 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c90b		64 65 66 69 6e 69 74 69		        .text "definitions"
>c913		6f 6e 73
.c916						nt_wordlist:
>c916		08 00				        .byte 8, 0
>c918		26 c9 86 a6 9c a6		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c91e		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c926						nt_search_wordlist:
>c926		0f 10				        .byte 15, UF
>c928		3d c9 54 9b 34 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c92e		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c936		6f 72 64 6c 69 73 74
.c93d						nt_set_current:
>c93d		0b 10				        .byte 11, UF
>c93f		50 c9 c3 9c ce 9c		        .word nt_get_current, xt_set_current, z_set_current
>c945		73 65 74 2d 63 75 72 72		        .text "set-current"
>c94d		65 6e 74
.c950						nt_get_current:
>c950		0b 00				        .byte 11, 0
>c952		63 c9 dc 90 e6 90		        .word nt_set_order, xt_get_current, z_get_current
>c958		67 65 74 2d 63 75 72 72		        .text "get-current"
>c960		65 6e 74
.c963						nt_set_order:
>c963		09 00				        .byte 9, 0
>c965		74 c9 cf 9c 02 9d		        .word nt_get_order, xt_set_order, z_set_order
>c96b		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c973		72
.c974						nt_get_order:
>c974		09 00				        .byte 9, 0
>c976		85 c9 e7 90 0f 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c97c		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c984		72
.c985						nt_root_wordlist:
>c985		0d 00				        .byte 13, 0
>c987		9a c9 02 9b 0a 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c98d		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c995		64 6c 69 73 74
.c99a						+
.c99a						nt_assembler_wordlist:
>c99a		12 00				        .byte 18, 0
>c99c		b4 c9 2c a3 34 a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c9a2		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c9aa		72 2d 77 6f 72 64 6c 69 73 74
.c9b4						+
.c9b4						nt_editor_wordlist:
>c9b4		0f 00				        .byte 15, 0
>c9b6		cb c9 bc 97 c4 97		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9bc		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9c4		6f 72 64 6c 69 73 74
.c9cb						+
.c9cb						nt_forth_wordlist:
>c9cb		0e 00				        .byte 14, 0
>c9cd		e1 c9 2d a7 33 a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c9d3		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9db		72 64 6c 69 73 74
.c9e1						nt_only:
>c9e1		04 00				        .byte 4, 0
>c9e3		ed c9 db 97 e6 97		        .word nt_also, xt_only, z_only
>c9e9		6f 6e 6c 79			        .text "only"
.c9ed						nt_also:
>c9ed		04 00				        .byte 4, 0
>c9ef		f9 c9 b4 82 c3 82		        .word nt_previous, xt_also, z_also
>c9f5		61 6c 73 6f			        .text "also"
.c9f9						nt_previous:
>c9f9		08 00				        .byte 8, 0
>c9fb		09 ca 09 9a 15 9a		        .word nt_to_order, xt_previous, z_previous
>ca01		70 72 65 76 69 6f 75 73		        .text "previous"
.ca09						nt_to_order:
>ca09		06 00				        .byte 6, 0
>ca0b		17 ca e2 a2 f4 a2		        .word nt_order, xt_to_order, z_to_order
>ca11		3e 6f 72 64 65 72		        .text ">order"
.ca17						nt_order:
>ca17		05 00				        .byte 5, 0
>ca19		24 ca f9 97 23 98		        .word nt_forth, xt_order, z_order
>ca1f		6f 72 64 65 72			        .text "order"
.ca24						nt_forth:
>ca24		05 00				        .byte 5, 0
>ca26		31 ca 7b 90 81 90		        .word +, xt_forth, z_forth
>ca2c		66 6f 72 74 68			        .text "forth"
.ca31						+
>ca31		03 08				nt_see: .byte 3, NN
>ca33		3c ca 35 9c c2 9c		        .word +, xt_see, z_see
>ca39		73 65 65			        .text "see"
.ca3c						+
.ca3c						nt_ed:
>ca3c		02 08				        .byte 2, NN
>ca3e		46 ca 70 8d 73 8d		        .word +, xt_ed, z_ed
>ca44		65 64				        .text "ed"
.ca46						+
.ca46						nt_cold:
>ca46		04 00				        .byte 4, 0
>ca48		52 ca 00 80 ad 80		        .word nt_bye, xt_cold, z_cold
>ca4e		63 6f 6c 64			        .text "cold"
.ca52						nt_bye:
>ca52		03				        .byte 3         ; length of word strings
>ca53		00				        .byte 0         ; status byte
>ca54		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca56		b3 85				        .word xt_bye    ; start of code block (xt of this word)
>ca58		b6 85				        .word z_bye     ; end of code (RTS)
>ca5a		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca5d						root_dictionary_start:
.ca5d						nt_root_set_order:
>ca5d		09 00				        .byte 9, 0
>ca5f		6e ca cf 9c 02 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca65		73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca6d		72
.ca6e						nt_root_forth:
>ca6e		05 00				        .byte 5, 0
>ca70		7b ca 7b 90 81 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca76		66 6f 72 74 68			        .text "forth"
.ca7b						nt_root_forth_wordlist:
>ca7b		0e 00				        .byte 14, 0
>ca7d		91 ca 2d a7 33 a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca83		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca8b		72 64 6c 69 73 74
.ca91						nt_root_words:
>ca91		05 00				        .byte 5, 0
>ca93		00 00 9d a6 f9 a6		        .word 0000, xt_words, z_words
>ca99		77 6f 72 64 73			        .text "words"
.ca9e						editor_dictionary_start:
.ca9e						nt_editor_o:
>ca9e		01 00				        .byte 1, 0
>caa0		a7 ca 5c a8 a1 a8		        .word nt_editor_line, xt_editor_o, z_editor_o
>caa6		6f				        .text "o"
.caa7						nt_editor_line:
>caa7		04 10				        .byte 4, UF
>caa9		b3 ca 43 a8 5b a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>caaf		6c 69 6e 65			        .text "line"
.cab3						nt_editor_l:
>cab3		01 00				        .byte 1, 0
>cab5		bc ca c7 a7 42 a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>cabb		6c				        .text "l"
.cabc						nt_editor_el:
>cabc		02 00				        .byte 2, 0
>cabe		c6 ca b5 a7 c6 a7		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cac4		65 6c				        .text "el"
.cac6						nt_editor_erase_screen:
>cac6		0c 00				        .byte 12, 0
>cac8		da ca a3 a7 b4 a7		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cace		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cad6		72 65 65 6e
.cada						nt_editor_enter_screen:
>cada		0c 00				        .byte 12, 0
>cadc		00 00 87 a7 a2 a7		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cae2		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>caea		72 65 65 6e
.caee						assembler_dictionary_start:
.caee						nt_asm_adc_h:
>caee		05 0c						.byte 5, IM+NN
>caf0		fb ca				                .word nt_asm_adc_x
>caf2		f6 a8 fb a8					.word xt_asm_adc_h, z_asm_adc_h
>caf6		61 64 63 2e 23					.text "adc.#"
.cafb						nt_asm_adc_x:
>cafb		05 0c						.byte 5, IM+NN
>cafd		08 cb				                .word nt_asm_adc_y
>caff		fb a8 00 a9					.word xt_asm_adc_x, z_asm_adc_x
>cb03		61 64 63 2e 78					.text "adc.x"
.cb08						nt_asm_adc_y:
>cb08		05 0c						.byte 5, IM+NN
>cb0a		15 cb				                .word nt_asm_adc_z
>cb0c		00 a9 05 a9					.word xt_asm_adc_y, z_asm_adc_y
>cb10		61 64 63 2e 79					.text "adc.y"
.cb15						nt_asm_adc_z:
>cb15		05 0c						.byte 5, IM+NN
>cb17		22 cb				                .word nt_asm_adc_zi
>cb19		05 a9 0a a9					.word xt_asm_adc_z, z_asm_adc_z
>cb1d		61 64 63 2e 7a					.text "adc.z"
.cb22						nt_asm_adc_zi:
>cb22		06 0c						.byte 6, IM+NN
>cb24		30 cb				                .word nt_asm_adc_ziy
>cb26		0a a9 0f a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cb2a		61 64 63 2e 7a 69				.text "adc.zi"
.cb30						nt_asm_adc_ziy:
>cb30		07 0c						.byte 7, IM+NN
>cb32		3f cb				                .word nt_asm_adc_zx
>cb34		0f a9 14 a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb38		61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb3f						nt_asm_adc_zx:
>cb3f		06 0c						.byte 6, IM+NN
>cb41		4d cb				                .word nt_asm_adc_zxi
>cb43		14 a9 19 a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cb47		61 64 63 2e 7a 78				.text "adc.zx"
.cb4d						nt_asm_adc_zxi:
>cb4d		07 0c						.byte 7, IM+NN
>cb4f		5c cb				                .word nt_asm_and
>cb51		19 a9 1e a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb55		61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb5c						nt_asm_and:
>cb5c		04 0c						.byte 4, IM+NN
>cb5e		68 cb				                .word nt_asm_and_h
>cb60		1e a9 23 a9					.word xt_asm_and, z_asm_and
>cb64		61 6e 64 2e					.text "and."
.cb68						nt_asm_and_h:
>cb68		05 0c						.byte 5, IM+NN
>cb6a		75 cb				                .word nt_asm_and_x
>cb6c		23 a9 28 a9					.word xt_asm_and_h, z_asm_and_h
>cb70		61 6e 64 2e 23					.text "and.#"
.cb75						nt_asm_and_x:
>cb75		05 0c						.byte 5, IM+NN
>cb77		82 cb				                .word nt_asm_and_y
>cb79		28 a9 2d a9					.word xt_asm_and_x, z_asm_and_x
>cb7d		61 6e 64 2e 78					.text "and.x"
.cb82						nt_asm_and_y:
>cb82		05 0c						.byte 5, IM+NN
>cb84		8f cb				                .word nt_asm_and_z
>cb86		2d a9 32 a9					.word xt_asm_and_y, z_asm_and_y
>cb8a		61 6e 64 2e 79					.text "and.y"
.cb8f						nt_asm_and_z:
>cb8f		05 0c						.byte 5, IM+NN
>cb91		9c cb				                .word nt_asm_and_zi
>cb93		32 a9 37 a9					.word xt_asm_and_z, z_asm_and_z
>cb97		61 6e 64 2e 7a					.text "and.z"
.cb9c						nt_asm_and_zi:
>cb9c		06 0c						.byte 6, IM+NN
>cb9e		aa cb				                .word nt_asm_and_ziy
>cba0		37 a9 3c a9					.word xt_asm_and_zi, z_asm_and_zi
>cba4		61 6e 64 2e 7a 69				.text "and.zi"
.cbaa						nt_asm_and_ziy:
>cbaa		07 0c						.byte 7, IM+NN
>cbac		b9 cb				                .word nt_asm_and_zx
>cbae		3c a9 41 a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cbb2		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cbb9						nt_asm_and_zx:
>cbb9		06 0c						.byte 6, IM+NN
>cbbb		c7 cb				                .word nt_asm_and_zxi
>cbbd		41 a9 46 a9					.word xt_asm_and_zx, z_asm_and_zx
>cbc1		61 6e 64 2e 7a 78				.text "and.zx"
.cbc7						nt_asm_and_zxi:
>cbc7		07 0c						.byte 7, IM+NN
>cbc9		d6 cb				                .word nt_asm_asl
>cbcb		46 a9 4b a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cbcf		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cbd6						nt_asm_asl:
>cbd6		03 0c						.byte 3, IM+NN
>cbd8		e1 cb				                .word nt_asm_asl_a
>cbda		4b a9 50 a9					.word xt_asm_asl, z_asm_asl
>cbde		61 73 6c					.text "asl"
.cbe1						nt_asm_asl_a:
>cbe1		05 0c						.byte 5, IM+NN
>cbe3		ee cb				                .word nt_asm_asl_x
>cbe5		50 a9 55 a9					.word xt_asm_asl_a, z_asm_asl_a
>cbe9		61 73 6c 2e 61					.text "asl.a"
.cbee						nt_asm_asl_x:
>cbee		05 0c						.byte 5, IM+NN
>cbf0		fb cb				                .word nt_asm_asl_z
>cbf2		55 a9 5a a9					.word xt_asm_asl_x, z_asm_asl_x
>cbf6		61 73 6c 2e 78					.text "asl.x"
.cbfb						nt_asm_asl_z:
>cbfb		05 0c						.byte 5, IM+NN
>cbfd		08 cc				                .word nt_asm_asl_zx
>cbff		5a a9 5f a9					.word xt_asm_asl_z, z_asm_asl_z
>cc03		61 73 6c 2e 7a					.text "asl.z"
.cc08						nt_asm_asl_zx:
>cc08		06 0c						.byte 6, IM+NN
>cc0a		16 cc				                .word nt_asm_bcc
>cc0c		5f a9 64 a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cc10		61 73 6c 2e 7a 78				.text "asl.zx"
.cc16						nt_asm_bcc:
>cc16		03 0c						.byte 3, IM+NN
>cc18		21 cc				                .word nt_asm_bcs
>cc1a		64 a9 69 a9					.word xt_asm_bcc, z_asm_bcc
>cc1e		62 63 63					.text "bcc"
.cc21						nt_asm_bcs:
>cc21		03 0c						.byte 3, IM+NN
>cc23		2c cc				                .word nt_asm_beq
>cc25		69 a9 70 a9					.word xt_asm_bcs, z_asm_bcs
>cc29		62 63 73					.text "bcs"
.cc2c						nt_asm_beq:
>cc2c		03 0c						.byte 3, IM+NN
>cc2e		37 cc				                .word nt_asm_bit
>cc30		70 a9 75 a9					.word xt_asm_beq, z_asm_beq
>cc34		62 65 71					.text "beq"
.cc37						nt_asm_bit:
>cc37		03 0c						.byte 3, IM+NN
>cc39		42 cc				                .word nt_asm_bit_h
>cc3b		75 a9 7a a9					.word xt_asm_bit, z_asm_bit
>cc3f		62 69 74					.text "bit"
.cc42						nt_asm_bit_h:
>cc42		05 0c						.byte 5, IM+NN
>cc44		4f cc				                .word nt_asm_bit_x
>cc46		7a a9 7f a9					.word xt_asm_bit_h, z_asm_bit_h
>cc4a		62 69 74 2e 23					.text "bit.#"
.cc4f						nt_asm_bit_x:
>cc4f		05 0c						.byte 5, IM+NN
>cc51		5c cc				                .word nt_asm_bit_z
>cc53		7f a9 84 a9					.word xt_asm_bit_x, z_asm_bit_x
>cc57		62 69 74 2e 78					.text "bit.x"
.cc5c						nt_asm_bit_z:
>cc5c		05 0c						.byte 5, IM+NN
>cc5e		69 cc				                .word nt_asm_bit_zx
>cc60		84 a9 89 a9					.word xt_asm_bit_z, z_asm_bit_z
>cc64		62 69 74 2e 7a					.text "bit.z"
.cc69						nt_asm_bit_zx:
>cc69		06 0c						.byte 6, IM+NN
>cc6b		77 cc				                .word nt_asm_bmi
>cc6d		89 a9 8e a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cc71		62 69 74 2e 7a 78				.text "bit.zx"
.cc77						nt_asm_bmi:
>cc77		03 0c						.byte 3, IM+NN
>cc79		82 cc				                .word nt_asm_bne
>cc7b		8e a9 93 a9					.word xt_asm_bmi, z_asm_bmi
>cc7f		62 6d 69					.text "bmi"
.cc82						nt_asm_bne:
>cc82		03 0c						.byte 3, IM+NN
>cc84		8d cc				                .word nt_asm_bpl
>cc86		93 a9 98 a9					.word xt_asm_bne, z_asm_bne
>cc8a		62 6e 65					.text "bne"
.cc8d						nt_asm_bpl:
>cc8d		03 0c						.byte 3, IM+NN
>cc8f		98 cc				                .word nt_asm_bra
>cc91		98 a9 9d a9					.word xt_asm_bpl, z_asm_bpl
>cc95		62 70 6c					.text "bpl"
.cc98						nt_asm_bra:
>cc98		03 0c						.byte 3, IM+NN
>cc9a		a3 cc				                .word nt_asm_brk
>cc9c		9d a9 a2 a9					.word xt_asm_bra, z_asm_bra
>cca0		62 72 61					.text "bra"
.cca3						nt_asm_brk:
>cca3		03 0c						.byte 3, IM+NN
>cca5		ae cc				                .word nt_asm_bvc
>cca7		a2 a9 a7 a9					.word xt_asm_brk, z_asm_brk
>ccab		62 72 6b					.text "brk"
.ccae						nt_asm_bvc:
>ccae		03 0c						.byte 3, IM+NN
>ccb0		b9 cc				                .word nt_asm_bvs
>ccb2		a7 a9 ac a9					.word xt_asm_bvc, z_asm_bvc
>ccb6		62 76 63					.text "bvc"
.ccb9						nt_asm_bvs:
>ccb9		03 0c						.byte 3, IM+NN
>ccbb		c4 cc				                .word nt_asm_clc
>ccbd		ac a9 b1 a9					.word xt_asm_bvs, z_asm_bvs
>ccc1		62 76 73					.text "bvs"
.ccc4						nt_asm_clc:
>ccc4		03 0c						.byte 3, IM+NN
>ccc6		cf cc				                .word nt_asm_cld
>ccc8		b1 a9 b6 a9					.word xt_asm_clc, z_asm_clc
>cccc		63 6c 63					.text "clc"
.cccf						nt_asm_cld:
>cccf		03 0c						.byte 3, IM+NN
>ccd1		da cc				                .word nt_asm_cli
>ccd3		b6 a9 bb a9					.word xt_asm_cld, z_asm_cld
>ccd7		63 6c 64					.text "cld"
.ccda						nt_asm_cli:
>ccda		03 0c						.byte 3, IM+NN
>ccdc		e5 cc				                .word nt_asm_clv
>ccde		bb a9 c0 a9					.word xt_asm_cli, z_asm_cli
>cce2		63 6c 69					.text "cli"
.cce5						nt_asm_clv:
>cce5		03 0c						.byte 3, IM+NN
>cce7		f0 cc				                .word nt_asm_cmp
>cce9		c0 a9 c5 a9					.word xt_asm_clv, z_asm_clv
>cced		63 6c 76					.text "clv"
.ccf0						nt_asm_cmp:
>ccf0		03 0c						.byte 3, IM+NN
>ccf2		fb cc				                .word nt_asm_cmp_h
>ccf4		c5 a9 ca a9					.word xt_asm_cmp, z_asm_cmp
>ccf8		63 6d 70					.text "cmp"
.ccfb						nt_asm_cmp_h:
>ccfb		05 0c						.byte 5, IM+NN
>ccfd		08 cd				                .word nt_asm_cmp_x
>ccff		ca a9 cf a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cd03		63 6d 70 2e 23					.text "cmp.#"
.cd08						nt_asm_cmp_x:
>cd08		05 0c						.byte 5, IM+NN
>cd0a		15 cd				                .word nt_asm_cmp_y
>cd0c		cf a9 d4 a9					.word xt_asm_cmp_x, z_asm_cmp_x
>cd10		63 6d 70 2e 78					.text "cmp.x"
.cd15						nt_asm_cmp_y:
>cd15		05 0c						.byte 5, IM+NN
>cd17		22 cd				                .word nt_asm_cmp_z
>cd19		d4 a9 d9 a9					.word xt_asm_cmp_y, z_asm_cmp_y
>cd1d		63 6d 70 2e 79					.text "cmp.y"
.cd22						nt_asm_cmp_z:
>cd22		05 0c						.byte 5, IM+NN
>cd24		2f cd				                .word nt_asm_cmp_zi
>cd26		d9 a9 de a9					.word xt_asm_cmp_z, z_asm_cmp_z
>cd2a		63 6d 70 2e 7a					.text "cmp.z"
.cd2f						nt_asm_cmp_zi:
>cd2f		06 0c						.byte 6, IM+NN
>cd31		3d cd				                .word nt_asm_cmp_ziy
>cd33		de a9 e3 a9					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd37		63 6d 70 2e 7a 69				.text "cmp.zi"
.cd3d						nt_asm_cmp_ziy:
>cd3d		07 0c						.byte 7, IM+NN
>cd3f		4c cd				                .word nt_asm_cmp_zx
>cd41		e3 a9 e8 a9					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd45		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd4c						nt_asm_cmp_zx:
>cd4c		06 0c						.byte 6, IM+NN
>cd4e		5a cd				                .word nt_asm_cmp_zxi
>cd50		e8 a9 ed a9					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd54		63 6d 70 2e 7a 78				.text "cmp.zx"
.cd5a						nt_asm_cmp_zxi:
>cd5a		07 0c						.byte 7, IM+NN
>cd5c		69 cd				                .word nt_asm_cpx
>cd5e		ed a9 f2 a9					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd62		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd69						nt_asm_cpx:
>cd69		03 0c						.byte 3, IM+NN
>cd6b		74 cd				                .word nt_asm_cpx_h
>cd6d		f2 a9 f7 a9					.word xt_asm_cpx, z_asm_cpx
>cd71		63 70 78					.text "cpx"
.cd74						nt_asm_cpx_h:
>cd74		05 0c						.byte 5, IM+NN
>cd76		81 cd				                .word nt_asm_cpx_z
>cd78		f7 a9 fc a9					.word xt_asm_cpx_h, z_asm_cpx_h
>cd7c		63 70 78 2e 23					.text "cpx.#"
.cd81						nt_asm_cpx_z:
>cd81		05 0c						.byte 5, IM+NN
>cd83		8e cd				                .word nt_asm_cpy
>cd85		fc a9 01 aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cd89		63 70 78 2e 7a					.text "cpx.z"
.cd8e						nt_asm_cpy:
>cd8e		03 0c						.byte 3, IM+NN
>cd90		99 cd				                .word nt_asm_cpy_h
>cd92		01 aa 08 aa					.word xt_asm_cpy, z_asm_cpy
>cd96		63 70 79					.text "cpy"
.cd99						nt_asm_cpy_h:
>cd99		05 0c						.byte 5, IM+NN
>cd9b		a6 cd				                .word nt_asm_cpy_z
>cd9d		08 aa 0d aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cda1		63 70 79 2e 23					.text "cpy.#"
.cda6						nt_asm_cpy_z:
>cda6		05 0c						.byte 5, IM+NN
>cda8		b3 cd				                .word nt_asm_dec
>cdaa		0d aa 12 aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cdae		63 70 79 2e 7a					.text "cpy.z"
.cdb3						nt_asm_dec:
>cdb3		03 0c						.byte 3, IM+NN
>cdb5		be cd				                .word nt_asm_dec_a
>cdb7		12 aa 17 aa					.word xt_asm_dec, z_asm_dec
>cdbb		64 65 63					.text "dec"
.cdbe						nt_asm_dec_a:
>cdbe		05 0c						.byte 5, IM+NN
>cdc0		cb cd				                .word nt_asm_dec_x
>cdc2		17 aa 1c aa					.word xt_asm_dec_a, z_asm_dec_a
>cdc6		64 65 63 2e 61					.text "dec.a"
.cdcb						nt_asm_dec_x:
>cdcb		05 0c						.byte 5, IM+NN
>cdcd		d8 cd				                .word nt_asm_dec_z
>cdcf		1c aa 21 aa					.word xt_asm_dec_x, z_asm_dec_x
>cdd3		64 65 63 2e 78					.text "dec.x"
.cdd8						nt_asm_dec_z:
>cdd8		05 0c						.byte 5, IM+NN
>cdda		e5 cd				                .word nt_asm_dec_zx
>cddc		21 aa 26 aa					.word xt_asm_dec_z, z_asm_dec_z
>cde0		64 65 63 2e 7a					.text "dec.z"
.cde5						nt_asm_dec_zx:
>cde5		06 0c						.byte 6, IM+NN
>cde7		f3 cd				                .word nt_asm_dex
>cde9		26 aa 2b aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cded		64 65 63 2e 7a 78				.text "dec.zx"
.cdf3						nt_asm_dex:
>cdf3		03 0c						.byte 3, IM+NN
>cdf5		fe cd				                .word nt_asm_dey
>cdf7		2b aa 30 aa					.word xt_asm_dex, z_asm_dex
>cdfb		64 65 78					.text "dex"
.cdfe						nt_asm_dey:
>cdfe		03 0c						.byte 3, IM+NN
>ce00		09 ce				                .word nt_asm_eor
>ce02		30 aa 35 aa					.word xt_asm_dey, z_asm_dey
>ce06		64 65 79					.text "dey"
.ce09						nt_asm_eor:
>ce09		03 0c						.byte 3, IM+NN
>ce0b		14 ce				                .word nt_asm_eor_h
>ce0d		35 aa 3a aa					.word xt_asm_eor, z_asm_eor
>ce11		65 6f 72					.text "eor"
.ce14						nt_asm_eor_h:
>ce14		05 0c						.byte 5, IM+NN
>ce16		21 ce				                .word nt_asm_eor_x
>ce18		3a aa 3f aa					.word xt_asm_eor_h, z_asm_eor_h
>ce1c		65 6f 72 2e 23					.text "eor.#"
.ce21						nt_asm_eor_x:
>ce21		05 0c						.byte 5, IM+NN
>ce23		2e ce				                .word nt_asm_eor_y
>ce25		3f aa 44 aa					.word xt_asm_eor_x, z_asm_eor_x
>ce29		65 6f 72 2e 78					.text "eor.x"
.ce2e						nt_asm_eor_y:
>ce2e		05 0c						.byte 5, IM+NN
>ce30		3b ce				                .word nt_asm_eor_z
>ce32		44 aa 49 aa					.word xt_asm_eor_y, z_asm_eor_y
>ce36		65 6f 72 2e 79					.text "eor.y"
.ce3b						nt_asm_eor_z:
>ce3b		05 0c						.byte 5, IM+NN
>ce3d		48 ce				                .word nt_asm_eor_zi
>ce3f		49 aa 4e aa					.word xt_asm_eor_z, z_asm_eor_z
>ce43		65 6f 72 2e 7a					.text "eor.z"
.ce48						nt_asm_eor_zi:
>ce48		06 0c						.byte 6, IM+NN
>ce4a		56 ce				                .word nt_asm_eor_ziy
>ce4c		4e aa 53 aa					.word xt_asm_eor_zi, z_asm_eor_zi
>ce50		65 6f 72 2e 7a 69				.text "eor.zi"
.ce56						nt_asm_eor_ziy:
>ce56		07 0c						.byte 7, IM+NN
>ce58		65 ce				                .word nt_asm_eor_zx
>ce5a		53 aa 58 aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce5e		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce65						nt_asm_eor_zx:
>ce65		06 0c						.byte 6, IM+NN
>ce67		73 ce				                .word nt_asm_eor_zxi
>ce69		58 aa 5d aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce6d		65 6f 72 2e 7a 78				.text "eor.zx"
.ce73						nt_asm_eor_zxi:
>ce73		07 0c						.byte 7, IM+NN
>ce75		82 ce				                .word nt_asm_inc
>ce77		5d aa 62 aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce7b		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce82						nt_asm_inc:
>ce82		03 0c						.byte 3, IM+NN
>ce84		8d ce				                .word nt_asm_inc_a
>ce86		62 aa 67 aa					.word xt_asm_inc, z_asm_inc
>ce8a		69 6e 63					.text "inc"
.ce8d						nt_asm_inc_a:
>ce8d		05 0c						.byte 5, IM+NN
>ce8f		9a ce				                .word nt_asm_inc_x
>ce91		67 aa 6c aa					.word xt_asm_inc_a, z_asm_inc_a
>ce95		69 6e 63 2e 61					.text "inc.a"
.ce9a						nt_asm_inc_x:
>ce9a		05 0c						.byte 5, IM+NN
>ce9c		a7 ce				                .word nt_asm_inc_z
>ce9e		6c aa 71 aa					.word xt_asm_inc_x, z_asm_inc_x
>cea2		69 6e 63 2e 78					.text "inc.x"
.cea7						nt_asm_inc_z:
>cea7		05 0c						.byte 5, IM+NN
>cea9		b4 ce				                .word nt_asm_inc_zx
>ceab		71 aa 76 aa					.word xt_asm_inc_z, z_asm_inc_z
>ceaf		69 6e 63 2e 7a					.text "inc.z"
.ceb4						nt_asm_inc_zx:
>ceb4		06 0c						.byte 6, IM+NN
>ceb6		c2 ce				                .word nt_asm_inx
>ceb8		76 aa 7b aa					.word xt_asm_inc_zx, z_asm_inc_zx
>cebc		69 6e 63 2e 7a 78				.text "inc.zx"
.cec2						nt_asm_inx:
>cec2		03 0c						.byte 3, IM+NN
>cec4		cd ce				                .word nt_asm_iny
>cec6		7b aa 80 aa					.word xt_asm_inx, z_asm_inx
>ceca		69 6e 78					.text "inx"
.cecd						nt_asm_iny:
>cecd		03 0c						.byte 3, IM+NN
>cecf		d8 ce				                .word nt_asm_jmp
>ced1		80 aa 85 aa					.word xt_asm_iny, z_asm_iny
>ced5		69 6e 79					.text "iny"
.ced8						nt_asm_jmp:
>ced8		03 0c						.byte 3, IM+NN
>ceda		e3 ce				                .word nt_asm_jmp_i
>cedc		85 aa 8a aa					.word xt_asm_jmp, z_asm_jmp
>cee0		6a 6d 70					.text "jmp"
.cee3						nt_asm_jmp_i:
>cee3		05 0c						.byte 5, IM+NN
>cee5		f0 ce				                .word nt_asm_jmp_xi
>cee7		8a aa 8f aa					.word xt_asm_jmp_i, z_asm_jmp_i
>ceeb		6a 6d 70 2e 69					.text "jmp.i"
.cef0						nt_asm_jmp_xi:
>cef0		06 0c						.byte 6, IM+NN
>cef2		fe ce				                .word nt_asm_jsr
>cef4		8f aa 94 aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cef8		6a 6d 70 2e 78 69				.text "jmp.xi"
.cefe						nt_asm_jsr:
>cefe		03 0c						.byte 3, IM+NN
>cf00		09 cf				                .word nt_asm_lda
>cf02		94 aa 99 aa					.word xt_asm_jsr, z_asm_jsr
>cf06		6a 73 72					.text "jsr"
.cf09						nt_asm_lda:
>cf09		03 0c						.byte 3, IM+NN
>cf0b		14 cf				                .word nt_asm_lda_h
>cf0d		99 aa 9e aa					.word xt_asm_lda, z_asm_lda
>cf11		6c 64 61					.text "lda"
.cf14						nt_asm_lda_h:
>cf14		05 0c						.byte 5, IM+NN
>cf16		21 cf				                .word nt_asm_lda_x
>cf18		9e aa a3 aa					.word xt_asm_lda_h, z_asm_lda_h
>cf1c		6c 64 61 2e 23					.text "lda.#"
.cf21						nt_asm_lda_x:
>cf21		05 0c						.byte 5, IM+NN
>cf23		2e cf				                .word nt_asm_lda_y
>cf25		a3 aa a8 aa					.word xt_asm_lda_x, z_asm_lda_x
>cf29		6c 64 61 2e 78					.text "lda.x"
.cf2e						nt_asm_lda_y:
>cf2e		05 0c						.byte 5, IM+NN
>cf30		3b cf				                .word nt_asm_lda_z
>cf32		a8 aa ad aa					.word xt_asm_lda_y, z_asm_lda_y
>cf36		6c 64 61 2e 79					.text "lda.y"
.cf3b						nt_asm_lda_z:
>cf3b		05 0c						.byte 5, IM+NN
>cf3d		48 cf				                .word nt_asm_lda_zi
>cf3f		ad aa b2 aa					.word xt_asm_lda_z, z_asm_lda_z
>cf43		6c 64 61 2e 7a					.text "lda.z"
.cf48						nt_asm_lda_zi:
>cf48		06 0c						.byte 6, IM+NN
>cf4a		56 cf				                .word nt_asm_lda_ziy
>cf4c		b2 aa b7 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cf50		6c 64 61 2e 7a 69				.text "lda.zi"
.cf56						nt_asm_lda_ziy:
>cf56		07 0c						.byte 7, IM+NN
>cf58		65 cf				                .word nt_asm_lda_zx
>cf5a		b7 aa bc aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf5e		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf65						nt_asm_lda_zx:
>cf65		06 0c						.byte 6, IM+NN
>cf67		73 cf				                .word nt_asm_lda_zxi
>cf69		bc aa c1 aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cf6d		6c 64 61 2e 7a 78				.text "lda.zx"
.cf73						nt_asm_lda_zxi:
>cf73		07 0c						.byte 7, IM+NN
>cf75		82 cf				                .word nt_asm_ldx
>cf77		c1 aa c6 aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf7b		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf82						nt_asm_ldx:
>cf82		03 0c						.byte 3, IM+NN
>cf84		8d cf				                .word nt_asm_ldx_h
>cf86		c6 aa cb aa					.word xt_asm_ldx, z_asm_ldx
>cf8a		6c 64 78					.text "ldx"
.cf8d						nt_asm_ldx_h:
>cf8d		05 0c						.byte 5, IM+NN
>cf8f		9a cf				                .word nt_asm_ldx_y
>cf91		cb aa d0 aa					.word xt_asm_ldx_h, z_asm_ldx_h
>cf95		6c 64 78 2e 23					.text "ldx.#"
.cf9a						nt_asm_ldx_y:
>cf9a		05 0c						.byte 5, IM+NN
>cf9c		a7 cf				                .word nt_asm_ldx_z
>cf9e		d0 aa d5 aa					.word xt_asm_ldx_y, z_asm_ldx_y
>cfa2		6c 64 78 2e 79					.text "ldx.y"
.cfa7						nt_asm_ldx_z:
>cfa7		05 0c						.byte 5, IM+NN
>cfa9		b4 cf				                .word nt_asm_ldx_zy
>cfab		d5 aa da aa					.word xt_asm_ldx_z, z_asm_ldx_z
>cfaf		6c 64 78 2e 7a					.text "ldx.z"
.cfb4						nt_asm_ldx_zy:
>cfb4		06 0c						.byte 6, IM+NN
>cfb6		c2 cf				                .word nt_asm_ldy
>cfb8		da aa df aa					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfbc		6c 64 78 2e 7a 79				.text "ldx.zy"
.cfc2						nt_asm_ldy:
>cfc2		03 0c						.byte 3, IM+NN
>cfc4		cd cf				                .word nt_asm_ldy_h
>cfc6		df aa e4 aa					.word xt_asm_ldy, z_asm_ldy
>cfca		6c 64 79					.text "ldy"
.cfcd						nt_asm_ldy_h:
>cfcd		05 0c						.byte 5, IM+NN
>cfcf		da cf				                .word nt_asm_ldy_x
>cfd1		e4 aa e9 aa					.word xt_asm_ldy_h, z_asm_ldy_h
>cfd5		6c 64 79 2e 23					.text "ldy.#"
.cfda						nt_asm_ldy_x:
>cfda		05 0c						.byte 5, IM+NN
>cfdc		e7 cf				                .word nt_asm_ldy_z
>cfde		e9 aa ee aa					.word xt_asm_ldy_x, z_asm_ldy_x
>cfe2		6c 64 79 2e 78					.text "ldy.x"
.cfe7						nt_asm_ldy_z:
>cfe7		05 0c						.byte 5, IM+NN
>cfe9		f4 cf				                .word nt_asm_ldy_zx
>cfeb		ee aa f3 aa					.word xt_asm_ldy_z, z_asm_ldy_z
>cfef		6c 64 79 2e 7a					.text "ldy.z"
.cff4						nt_asm_ldy_zx:
>cff4		06 0c						.byte 6, IM+NN
>cff6		02 d0				                .word nt_asm_lsr
>cff8		f3 aa f8 aa					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cffc		6c 64 79 2e 7a 78				.text "ldy.zx"
.d002						nt_asm_lsr:
>d002		03 0c						.byte 3, IM+NN
>d004		0d d0				                .word nt_asm_lsr_a
>d006		f8 aa fd aa					.word xt_asm_lsr, z_asm_lsr
>d00a		6c 73 72					.text "lsr"
.d00d						nt_asm_lsr_a:
>d00d		05 0c						.byte 5, IM+NN
>d00f		1a d0				                .word nt_asm_lsr_x
>d011		fd aa 02 ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d015		6c 73 72 2e 61					.text "lsr.a"
.d01a						nt_asm_lsr_x:
>d01a		05 0c						.byte 5, IM+NN
>d01c		27 d0				                .word nt_asm_lsr_z
>d01e		02 ab 07 ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d022		6c 73 72 2e 78					.text "lsr.x"
.d027						nt_asm_lsr_z:
>d027		05 0c						.byte 5, IM+NN
>d029		34 d0				                .word nt_asm_lsr_zx
>d02b		07 ab 0c ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d02f		6c 73 72 2e 7a					.text "lsr.z"
.d034						nt_asm_lsr_zx:
>d034		06 0c						.byte 6, IM+NN
>d036		42 d0				                .word nt_asm_nop
>d038		0c ab 11 ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d03c		6c 73 72 2e 7a 78				.text "lsr.zx"
.d042						nt_asm_nop:
>d042		03 0c						.byte 3, IM+NN
>d044		4d d0				                .word nt_asm_ora
>d046		11 ab 16 ab					.word xt_asm_nop, z_asm_nop
>d04a		6e 6f 70					.text "nop"
.d04d						nt_asm_ora:
>d04d		03 0c						.byte 3, IM+NN
>d04f		58 d0				                .word nt_asm_ora_h
>d051		16 ab 1b ab					.word xt_asm_ora, z_asm_ora
>d055		6f 72 61					.text "ora"
.d058						nt_asm_ora_h:
>d058		05 0c						.byte 5, IM+NN
>d05a		65 d0				                .word nt_asm_ora_x
>d05c		1b ab 20 ab					.word xt_asm_ora_h, z_asm_ora_h
>d060		6f 72 61 2e 23					.text "ora.#"
.d065						nt_asm_ora_x:
>d065		05 0c						.byte 5, IM+NN
>d067		72 d0				                .word nt_asm_ora_y
>d069		20 ab 25 ab					.word xt_asm_ora_x, z_asm_ora_x
>d06d		6f 72 61 2e 78					.text "ora.x"
.d072						nt_asm_ora_y:
>d072		05 0c						.byte 5, IM+NN
>d074		7f d0				                .word nt_asm_ora_z
>d076		25 ab 2a ab					.word xt_asm_ora_y, z_asm_ora_y
>d07a		6f 72 61 2e 79					.text "ora.y"
.d07f						nt_asm_ora_z:
>d07f		05 0c						.byte 5, IM+NN
>d081		8c d0				                .word nt_asm_ora_zi
>d083		2a ab 2f ab					.word xt_asm_ora_z, z_asm_ora_z
>d087		6f 72 61 2e 7a					.text "ora.z"
.d08c						nt_asm_ora_zi:
>d08c		06 0c						.byte 6, IM+NN
>d08e		9a d0				                .word nt_asm_ora_ziy
>d090		2f ab 36 ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d094		6f 72 61 2e 7a 69				.text "ora.zi"
.d09a						nt_asm_ora_ziy:
>d09a		07 0c						.byte 7, IM+NN
>d09c		a9 d0				                .word nt_asm_ora_zx
>d09e		36 ab 3b ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d0a2		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d0a9						nt_asm_ora_zx:
>d0a9		06 0c						.byte 6, IM+NN
>d0ab		b7 d0				                .word nt_asm_ora_zxi
>d0ad		3b ab 40 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d0b1		6f 72 61 2e 7a 78				.text "ora.zx"
.d0b7						nt_asm_ora_zxi:
>d0b7		07 0c						.byte 7, IM+NN
>d0b9		c6 d0				                .word nt_asm_pha
>d0bb		40 ab 45 ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0bf		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0c6						nt_asm_pha:
>d0c6		03 0c						.byte 3, IM+NN
>d0c8		d1 d0				                .word nt_asm_php
>d0ca		45 ab 4a ab					.word xt_asm_pha, z_asm_pha
>d0ce		70 68 61					.text "pha"
.d0d1						nt_asm_php:
>d0d1		03 0c						.byte 3, IM+NN
>d0d3		dc d0				                .word nt_asm_phx
>d0d5		4a ab 4f ab					.word xt_asm_php, z_asm_php
>d0d9		70 68 70					.text "php"
.d0dc						nt_asm_phx:
>d0dc		03 0c						.byte 3, IM+NN
>d0de		e7 d0				                .word nt_asm_phy
>d0e0		4f ab 54 ab					.word xt_asm_phx, z_asm_phx
>d0e4		70 68 78					.text "phx"
.d0e7						nt_asm_phy:
>d0e7		03 0c						.byte 3, IM+NN
>d0e9		f2 d0				                .word nt_asm_pla
>d0eb		54 ab 59 ab					.word xt_asm_phy, z_asm_phy
>d0ef		70 68 79					.text "phy"
.d0f2						nt_asm_pla:
>d0f2		03 0c						.byte 3, IM+NN
>d0f4		fd d0				                .word nt_asm_plp
>d0f6		59 ab 5e ab					.word xt_asm_pla, z_asm_pla
>d0fa		70 6c 61					.text "pla"
.d0fd						nt_asm_plp:
>d0fd		03 0c						.byte 3, IM+NN
>d0ff		08 d1				                .word nt_asm_plx
>d101		5e ab 63 ab					.word xt_asm_plp, z_asm_plp
>d105		70 6c 70					.text "plp"
.d108						nt_asm_plx:
>d108		03 0c						.byte 3, IM+NN
>d10a		13 d1				                .word nt_asm_ply
>d10c		63 ab 68 ab					.word xt_asm_plx, z_asm_plx
>d110		70 6c 78					.text "plx"
.d113						nt_asm_ply:
>d113		03 0c						.byte 3, IM+NN
>d115		1e d1				                .word nt_asm_rol
>d117		68 ab 6d ab					.word xt_asm_ply, z_asm_ply
>d11b		70 6c 79					.text "ply"
.d11e						nt_asm_rol:
>d11e		03 0c						.byte 3, IM+NN
>d120		29 d1				                .word nt_asm_rol_a
>d122		6d ab 72 ab					.word xt_asm_rol, z_asm_rol
>d126		72 6f 6c					.text "rol"
.d129						nt_asm_rol_a:
>d129		05 0c						.byte 5, IM+NN
>d12b		36 d1				                .word nt_asm_rol_x
>d12d		72 ab 77 ab					.word xt_asm_rol_a, z_asm_rol_a
>d131		72 6f 6c 2e 61					.text "rol.a"
.d136						nt_asm_rol_x:
>d136		05 0c						.byte 5, IM+NN
>d138		43 d1				                .word nt_asm_rol_z
>d13a		77 ab 7c ab					.word xt_asm_rol_x, z_asm_rol_x
>d13e		72 6f 6c 2e 78					.text "rol.x"
.d143						nt_asm_rol_z:
>d143		05 0c						.byte 5, IM+NN
>d145		50 d1				                .word nt_asm_rol_zx
>d147		7c ab 81 ab					.word xt_asm_rol_z, z_asm_rol_z
>d14b		72 6f 6c 2e 7a					.text "rol.z"
.d150						nt_asm_rol_zx:
>d150		06 0c						.byte 6, IM+NN
>d152		5e d1				                .word nt_asm_ror
>d154		81 ab 86 ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d158		72 6f 6c 2e 7a 78				.text "rol.zx"
.d15e						nt_asm_ror:
>d15e		03 0c						.byte 3, IM+NN
>d160		69 d1				                .word nt_asm_ror_a
>d162		86 ab 8b ab					.word xt_asm_ror, z_asm_ror
>d166		72 6f 72					.text "ror"
.d169						nt_asm_ror_a:
>d169		05 0c						.byte 5, IM+NN
>d16b		76 d1				                .word nt_asm_ror_x
>d16d		8b ab 90 ab					.word xt_asm_ror_a, z_asm_ror_a
>d171		72 6f 72 2e 61					.text "ror.a"
.d176						nt_asm_ror_x:
>d176		05 0c						.byte 5, IM+NN
>d178		83 d1				                .word nt_asm_ror_z
>d17a		90 ab 95 ab					.word xt_asm_ror_x, z_asm_ror_x
>d17e		72 6f 72 2e 78					.text "ror.x"
.d183						nt_asm_ror_z:
>d183		05 0c						.byte 5, IM+NN
>d185		90 d1				                .word nt_asm_ror_zx
>d187		95 ab 9a ab					.word xt_asm_ror_z, z_asm_ror_z
>d18b		72 6f 72 2e 7a					.text "ror.z"
.d190						nt_asm_ror_zx:
>d190		06 0c						.byte 6, IM+NN
>d192		9e d1				                .word nt_asm_rti
>d194		9a ab 9f ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d198		72 6f 72 2e 7a 78				.text "ror.zx"
.d19e						nt_asm_rti:
>d19e		03 0c						.byte 3, IM+NN
>d1a0		a9 d1				                .word nt_asm_rts
>d1a2		9f ab a4 ab					.word xt_asm_rti, z_asm_rti
>d1a6		72 74 69					.text "rti"
.d1a9						nt_asm_rts:
>d1a9		03 0c						.byte 3, IM+NN
>d1ab		b4 d1				                .word nt_asm_sbc
>d1ad		a4 ab a9 ab					.word xt_asm_rts, z_asm_rts
>d1b1		72 74 73					.text "rts"
.d1b4						nt_asm_sbc:
>d1b4		03 0c						.byte 3, IM+NN
>d1b6		bf d1				                .word nt_asm_sbc_h
>d1b8		a9 ab ae ab					.word xt_asm_sbc, z_asm_sbc
>d1bc		73 62 63					.text "sbc"
.d1bf						nt_asm_sbc_h:
>d1bf		05 0c						.byte 5, IM+NN
>d1c1		cc d1				                .word nt_asm_sbc_x
>d1c3		ae ab b3 ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d1c7		73 62 63 2e 23					.text "sbc.#"
.d1cc						nt_asm_sbc_x:
>d1cc		05 0c						.byte 5, IM+NN
>d1ce		d9 d1				                .word nt_asm_sbc_y
>d1d0		b3 ab b8 ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d1d4		73 62 63 2e 78					.text "sbc.x"
.d1d9						nt_asm_sbc_y:
>d1d9		05 0c						.byte 5, IM+NN
>d1db		e6 d1				                .word nt_asm_sbc_z
>d1dd		b8 ab bd ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d1e1		73 62 63 2e 79					.text "sbc.y"
.d1e6						nt_asm_sbc_z:
>d1e6		05 0c						.byte 5, IM+NN
>d1e8		f3 d1				                .word nt_asm_sbc_zi
>d1ea		bd ab c2 ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d1ee		73 62 63 2e 7a					.text "sbc.z"
.d1f3						nt_asm_sbc_zi:
>d1f3		06 0c						.byte 6, IM+NN
>d1f5		01 d2				                .word nt_asm_sbc_ziy
>d1f7		c2 ab c7 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d1fb		73 62 63 2e 7a 69				.text "sbc.zi"
.d201						nt_asm_sbc_ziy:
>d201		07 0c						.byte 7, IM+NN
>d203		10 d2				                .word nt_asm_sbc_zx
>d205		c7 ab cc ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d209		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d210						nt_asm_sbc_zx:
>d210		06 0c						.byte 6, IM+NN
>d212		1e d2				                .word nt_asm_sbc_zxi
>d214		cc ab d1 ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d218		73 62 63 2e 7a 78				.text "sbc.zx"
.d21e						nt_asm_sbc_zxi:
>d21e		07 0c						.byte 7, IM+NN
>d220		2d d2				                .word nt_asm_sec
>d222		d1 ab d5 ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d226		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d22d						nt_asm_sec:
>d22d		03 0c						.byte 3, IM+NN
>d22f		38 d2				                .word nt_asm_sed
>d231		d5 ab d9 ab					.word xt_asm_sec, z_asm_sec
>d235		73 65 63					.text "sec"
.d238						nt_asm_sed:
>d238		03 0c						.byte 3, IM+NN
>d23a		43 d2				                .word nt_asm_sei
>d23c		d9 ab dd ab					.word xt_asm_sed, z_asm_sed
>d240		73 65 64					.text "sed"
.d243						nt_asm_sei:
>d243		03 0c						.byte 3, IM+NN
>d245		4e d2				                .word nt_asm_sta
>d247		dd ab e1 ab					.word xt_asm_sei, z_asm_sei
>d24b		73 65 69					.text "sei"
.d24e						nt_asm_sta:
>d24e		03 0c						.byte 3, IM+NN
>d250		59 d2				                .word nt_asm_sta_x
>d252		e1 ab e5 ab					.word xt_asm_sta, z_asm_sta
>d256		73 74 61					.text "sta"
.d259						nt_asm_sta_x:
>d259		05 0c						.byte 5, IM+NN
>d25b		66 d2				                .word nt_asm_sta_y
>d25d		e5 ab e9 ab					.word xt_asm_sta_x, z_asm_sta_x
>d261		73 74 61 2e 78					.text "sta.x"
.d266						nt_asm_sta_y:
>d266		05 0c						.byte 5, IM+NN
>d268		73 d2				                .word nt_asm_sta_z
>d26a		e9 ab ed ab					.word xt_asm_sta_y, z_asm_sta_y
>d26e		73 74 61 2e 79					.text "sta.y"
.d273						nt_asm_sta_z:
>d273		05 0c						.byte 5, IM+NN
>d275		80 d2				                .word nt_asm_sta_zi
>d277		ed ab f1 ab					.word xt_asm_sta_z, z_asm_sta_z
>d27b		73 74 61 2e 7a					.text "sta.z"
.d280						nt_asm_sta_zi:
>d280		06 0c						.byte 6, IM+NN
>d282		8e d2				                .word nt_asm_sta_ziy
>d284		f1 ab f5 ab					.word xt_asm_sta_zi, z_asm_sta_zi
>d288		73 74 61 2e 7a 69				.text "sta.zi"
.d28e						nt_asm_sta_ziy:
>d28e		07 0c						.byte 7, IM+NN
>d290		9d d2				                .word nt_asm_sta_zx
>d292		f5 ab f9 ab					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d296		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d29d						nt_asm_sta_zx:
>d29d		06 0c						.byte 6, IM+NN
>d29f		ab d2				                .word nt_asm_sta_zxi
>d2a1		f9 ab fd ab					.word xt_asm_sta_zx, z_asm_sta_zx
>d2a5		73 74 61 2e 7a 78				.text "sta.zx"
.d2ab						nt_asm_sta_zxi:
>d2ab		07 0c						.byte 7, IM+NN
>d2ad		ba d2				                .word nt_asm_stx
>d2af		fd ab 01 ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2b3		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2ba						nt_asm_stx:
>d2ba		03 0c						.byte 3, IM+NN
>d2bc		c5 d2				                .word nt_asm_stx_z
>d2be		01 ac 05 ac					.word xt_asm_stx, z_asm_stx
>d2c2		73 74 78					.text "stx"
.d2c5						nt_asm_stx_z:
>d2c5		05 0c						.byte 5, IM+NN
>d2c7		d2 d2				                .word nt_asm_stx_zy
>d2c9		05 ac 09 ac					.word xt_asm_stx_z, z_asm_stx_z
>d2cd		73 74 78 2e 7a					.text "stx.z"
.d2d2						nt_asm_stx_zy:
>d2d2		06 0c						.byte 6, IM+NN
>d2d4		e0 d2				                .word nt_asm_sty
>d2d6		09 ac 0d ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d2da		73 74 78 2e 7a 79				.text "stx.zy"
.d2e0						nt_asm_sty:
>d2e0		03 0c						.byte 3, IM+NN
>d2e2		eb d2				                .word nt_asm_sty_z
>d2e4		0d ac 11 ac					.word xt_asm_sty, z_asm_sty
>d2e8		73 74 79					.text "sty"
.d2eb						nt_asm_sty_z:
>d2eb		05 0c						.byte 5, IM+NN
>d2ed		f8 d2				                .word nt_asm_sty_zx
>d2ef		11 ac 15 ac					.word xt_asm_sty_z, z_asm_sty_z
>d2f3		73 74 79 2e 7a					.text "sty.z"
.d2f8						nt_asm_sty_zx:
>d2f8		06 0c						.byte 6, IM+NN
>d2fa		06 d3				                .word nt_asm_stz
>d2fc		15 ac 19 ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d300		73 74 79 2e 7a 78				.text "sty.zx"
.d306						nt_asm_stz:
>d306		03 0c						.byte 3, IM+NN
>d308		11 d3				                .word nt_asm_stz_x
>d30a		19 ac 1d ac					.word xt_asm_stz, z_asm_stz
>d30e		73 74 7a					.text "stz"
.d311						nt_asm_stz_x:
>d311		05 0c						.byte 5, IM+NN
>d313		1e d3				                .word nt_asm_stz_z
>d315		1d ac 21 ac					.word xt_asm_stz_x, z_asm_stz_x
>d319		73 74 7a 2e 78					.text "stz.x"
.d31e						nt_asm_stz_z:
>d31e		05 0c						.byte 5, IM+NN
>d320		2b d3				                .word nt_asm_stz_zx
>d322		21 ac 25 ac					.word xt_asm_stz_z, z_asm_stz_z
>d326		73 74 7a 2e 7a					.text "stz.z"
.d32b						nt_asm_stz_zx:
>d32b		06 0c						.byte 6, IM+NN
>d32d		39 d3				                .word nt_asm_tax
>d32f		25 ac 29 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d333		73 74 7a 2e 7a 78				.text "stz.zx"
.d339						nt_asm_tax:
>d339		03 0c						.byte 3, IM+NN
>d33b		44 d3				                .word nt_asm_tay
>d33d		29 ac 2d ac					.word xt_asm_tax, z_asm_tax
>d341		74 61 78					.text "tax"
.d344						nt_asm_tay:
>d344		03 0c						.byte 3, IM+NN
>d346		4f d3				                .word nt_asm_trb
>d348		2d ac 31 ac					.word xt_asm_tay, z_asm_tay
>d34c		74 61 79					.text "tay"
.d34f						nt_asm_trb:
>d34f		03 0c						.byte 3, IM+NN
>d351		5a d3				                .word nt_asm_trb_z
>d353		31 ac 35 ac					.word xt_asm_trb, z_asm_trb
>d357		74 72 62					.text "trb"
.d35a						nt_asm_trb_z:
>d35a		05 0c						.byte 5, IM+NN
>d35c		67 d3				                .word nt_asm_tsb
>d35e		35 ac 39 ac					.word xt_asm_trb_z, z_asm_trb_z
>d362		74 72 62 2e 7a					.text "trb.z"
.d367						nt_asm_tsb:
>d367		03 0c						.byte 3, IM+NN
>d369		72 d3				                .word nt_asm_tsb_z
>d36b		39 ac 3d ac					.word xt_asm_tsb, z_asm_tsb
>d36f		74 73 62					.text "tsb"
.d372						nt_asm_tsb_z:
>d372		05 0c						.byte 5, IM+NN
>d374		7f d3				                .word nt_asm_tsx
>d376		3d ac 41 ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d37a		74 73 62 2e 7a					.text "tsb.z"
.d37f						nt_asm_tsx:
>d37f		03 0c						.byte 3, IM+NN
>d381		8a d3				                .word nt_asm_txa
>d383		41 ac 45 ac					.word xt_asm_tsx, z_asm_tsx
>d387		74 73 78					.text "tsx"
.d38a						nt_asm_txa:
>d38a		03 0c						.byte 3, IM+NN
>d38c		95 d3				                .word nt_asm_txs
>d38e		45 ac 49 ac					.word xt_asm_txa, z_asm_txa
>d392		74 78 61					.text "txa"
.d395						nt_asm_txs:
>d395		03 0c						.byte 3, IM+NN
>d397		a0 d3				                .word nt_asm_tya
>d399		49 ac 4d ac					.word xt_asm_txs, z_asm_txs
>d39d		74 78 73					.text "txs"
.d3a0						nt_asm_tya:
>d3a0		03 0c						.byte 3, IM+NN
>d3a2		ab d3				                .word nt_asm_arrow
>d3a4		4d ac 51 ac					.word xt_asm_tya, z_asm_tya
>d3a8		74 79 61					.text "tya"
.d3ab						nt_asm_arrow:
>d3ab		03 04				                .byte 3, IM
>d3ad		b6 d3				                .word nt_asm_back_jump
>d3af		25 91 2f 91			                .word xt_asm_arrow, z_asm_arrow
>d3b3		2d 2d 3e			                .text "-->"
.d3b6						nt_asm_back_jump:
>d3b6		02 04				                .byte 2, IM
>d3b8		c0 d3				                .word nt_asm_back_branch
>d3ba		a2 ac a2 ac			                .word xt_asm_back_jump, z_asm_back_jump
>d3be		3c 6a				                .text "<j"
.d3c0						nt_asm_back_branch:
>d3c0		02 04				                .byte 2, IM
>d3c2		ca d3				                .word nt_asm_push_a
>d3c4		a3 ac ab ac			                .word xt_asm_back_branch, z_asm_back_branch
>d3c8		3c 62				                .text "<b"
.d3ca						nt_asm_push_a:
>d3ca		06 0c				                .byte 6, IM+NN
>d3cc		00 00				                .word 0000
>d3ce		8b ac 9a ac			                .word xt_asm_push_a, z_asm_push_a
>d3d2		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix
=1						ix += 1
=1						str_compile        = ix
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_sdc     = ix
=14						ix += 1
=14						str_disasm_bra     = ix
=15						ix += 1
.d3d8						string_table:
>d3d8		f6 d3 fa d3 04 d4 0f d4		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d3e0		46 d4 3e d4 33 d4 4d d4		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d3e8		53 d4 6f d4 74 d4 79 d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d3f0		8a d4 93 d4 a5 d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 12-14
>d3f6		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d3fa		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d402		64 00
>d404		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d40c		64 20 00
>d40f		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d417		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d427		4f 50 51 52 53 54 55 56 57 58 59 5a
>d433		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d43b		72 20 00
>d43e		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d446		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d44d		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d453		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d45b		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d46b		29 3a 20 00
>d46f		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d474		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d479		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d481		63 69 6d 61 6c 29 3a 20 00
>d48a		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d492		00
>d493		53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d49b		50 54 48 20 43 48 45 43 4b 00
>d4a5		42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d4ad						error_table:
>d4ad		c9 d4 ea d4 0a d5 2b d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4b5		48 d5 59 d5 69 d5 97 d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4bd		af d5 d0 d5 e5 d5 01 d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4c5		18 d6 57 d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d4c9		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d4d1		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d4e1		65 20 6d 65 6d 6f 72 79 00
>d4ea		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d4f2		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d502		20 52 45 46 49 4c 4c 00
>d50a		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d512		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d522		6e 6c 79 20 77 6f 72 64 00
>d52b		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d533		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d543		20 79 65 74 00
>d548		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d550		20 62 79 20 7a 65 72 6f 00
>d559		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d561		66 61 69 6c 75 72 65 00
>d569		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d571		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d581		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d591		64 20 2d 31 29 00
>d597		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d59f		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5af		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d5b7		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d5c7		64 20 6e 75 6d 62 65 72 00
>d5d0		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d5d8		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d5e5		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d5ed		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d5fd		4c 4f 54 00
>d601		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d609		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d618		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d620		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d630		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d640		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d650		56 45 43 54 4f 52 00
>d657		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d65f		74 61 63 6b 3a 00
>d665		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d66d		44 2d 53 54 52 49 4e 47
>d675		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d67b		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d680		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d688		2d 55 4e 49 54 2d 42 49 54 53
>d692		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d69a		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6a2		52
>d6a3		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6a9		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6af		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6b7		53 54 41 43 4b 2d 43 45 4c 4c 53
>d6c2		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d6ca		45 4c 4c 53
>d6ce		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d6d6		54 53
>d6d8		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d6de		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d6e5						cmpl_subroutine:
.d6e5		48		pha		                pha             ; save LSB of address
.d6e6		a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d6e8		80 03		bra $d6ed	                bra cmpl_common
.d6ea						cmpl_jump:
.d6ea		48		pha		                pha             ; save LSB of address
.d6eb		a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d6ed						cmpl_common:
.d6ed		20 f5 d6	jsr $d6f5	                jsr cmpl_a      ; compile opcode
.d6f0		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d6f1						cmpl_word:
.d6f1		20 f5 d6	jsr $d6f5	                jsr cmpl_a      ; compile LSB of address
.d6f4		98		tya		                tya             ; fall thru for MSB
.d6f5						cmpl_a:
.d6f5		92 00		sta ($00)	                sta (cp)
.d6f7		e6 00		inc $00		                inc cp
.d6f9		d0 02		bne $d6fd	                bne _done
.d6fb		e6 01		inc $01		                inc cp+1
.d6fd						_done:
.d6fd		60		rts		                rts
.d6fe						doconst:
.d6fe		ca		dex		                dex             ; make room for constant
.d6ff		ca		dex		                dex
.d700		68		pla		                pla             ; LSB of return address
.d701		85 24		sta $24		                sta tmp1
.d703		68		pla		                pla             ; MSB of return address
.d704		85 25		sta $25		                sta tmp1+1
.d706		a0 01		ldy #$01	                ldy #1
.d708		b1 24		lda ($24),y	                lda (tmp1),y
.d70a		95 00		sta $00,x	                sta 0,x
.d70c		c8		iny		                iny
.d70d		b1 24		lda ($24),y	                lda (tmp1),y
.d70f		95 01		sta $01,x	                sta 1,x
.d711		60		rts		                rts
.d712						dodefer:
.d712		68		pla		                pla             ; LSB
.d713		85 24		sta $24		                sta tmp1
.d715		68		pla		                pla             ; MSB
.d716		85 25		sta $25		                sta tmp1+1
.d718		a0 01		ldy #$01	                ldy #1
.d71a		b1 24		lda ($24),y	                lda (tmp1),y
.d71c		85 26		sta $26		                sta tmp2
.d71e		c8		iny		                iny
.d71f		b1 24		lda ($24),y	                lda (tmp1),y
.d721		85 27		sta $27		                sta tmp2+1
.d723		6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d726						defer_error:
.d726		a9 03		lda #$03	                lda #err_defer
.d728		4c 58 d8	jmp $d858	                jmp error
.d72b						dodoes:
.d72b		7a		ply		                ply             ; LSB
.d72c		68		pla		                pla             ; MSB
.d72d		c8		iny		                iny
.d72e		d0 01		bne $d731	                bne +
.d730		1a		inc a		                ina
.d731						+
.d731		84 26		sty $26		                sty tmp2
.d733		85 27		sta $27		                sta tmp2+1
.d735		ca		dex		                dex
.d736		ca		dex		                dex
.d737		7a		ply		                ply
.d738		68		pla		                pla
.d739		c8		iny		                iny
.d73a		d0 01		bne $d73d	                bne +
.d73c		1a		inc a		                ina
.d73d						+
.d73d		94 00		sty $00,x	                sty 0,x         ; LSB
.d73f		95 01		sta $01,x	                sta 1,x         ; MSB
.d741		6c 26 00	jmp ($0026)	                jmp (tmp2)
.d744						dovar:
.d744		7a		ply		                ply             ; LSB
.d745		68		pla		                pla             ; MSB
.d746		c8		iny		                iny
.d747		d0 01		bne $d74a	                bne +
.d749		1a		inc a		                ina
.d74a						+
.d74a		ca		dex		                dex
.d74b		ca		dex		                dex
.d74c		95 01		sta $01,x	                sta 1,x
.d74e		98		tya		                tya
.d74f		95 00		sta $00,x	                sta 0,x
.d751		60		rts		                rts
.d752						byte_to_ascii:
.d752		48		pha		                pha
.d753		4a		lsr a		                lsr             ; convert high nibble first
.d754		4a		lsr a		                lsr
.d755		4a		lsr a		                lsr
.d756		4a		lsr a		                lsr
.d757		20 5b d7	jsr $d75b	                jsr _nibble_to_ascii
.d75a		68		pla		                pla
.d75b						_nibble_to_ascii:
.d75b		29 0f		and #$0f	                and #$0F
.d75d		09 30		ora #$30	                ora #'0'
.d75f		c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d761		90 02		bcc $d765	                bcc +
.d763		69 06		adc #$06	                adc #$06
.d765		4c a9 8d	jmp $8da9	+               jmp emit_a
.d768		60		rts		                rts
.d769						compare_16bit:
.d769		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d76b		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d76d		f0 0a		beq $d779	                beq _equal
.d76f		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d771		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d773		09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d775		70 08		bvs $d77f	                bvs _overflow
.d777		80 08		bra $d781	                bra _not_equal
.d779						_equal:
.d779		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d77b		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d77d		50 04		bvc $d783	                bvc _done
.d77f						_overflow:
.d77f		49 80		eor #$80	                eor #$80                ; complement negative flag
.d781						_not_equal:
.d781		09 01		ora #$01	                ora #1                  ; if overflow, we can't be equal
.d783						_done:
.d783		60		rts		                rts
.d784						current_to_dp:
.d784		a0 04		ldy #$04	                ldy #current_offset
.d786		b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d788		0a		asl a		                asl             ; turn it into an offset (in cells)
.d789		18		clc		                clc
.d78a		69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d78c		a8		tay		                tay
.d78d		b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d78f		85 02		sta $02		                sta dp
.d791		c8		iny		                iny
.d792		b1 1e		lda ($1e),y	                lda (up),y
.d794		85 03		sta $03		                sta dp+1
.d796		60		rts		                rts
.d797						dp_to_current:
.d797		a0 04		ldy #$04	                ldy #current_offset
.d799		b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d79b		0a		asl a		                asl             ; turn it into an offset (in cells)
.d79c		18		clc		                clc
.d79d		69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d79f		a8		tay		                tay
.d7a0		a5 02		lda $02		                lda dp
.d7a2		91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d7a4		c8		iny		                iny
.d7a5		a5 03		lda $03		                lda dp+1
.d7a7		91 1e		sta ($1e),y	                sta (up),y
.d7a9		60		rts		                rts
.d7aa						interpret:
.d7aa						_loop:
.d7aa		20 93 98	jsr $9893	                jsr xt_parse_name       ; ( "string" -- addr u )
.d7ad		b5 00		lda $00,x	                lda 0,x
.d7af		15 01		ora $01,x	                ora 1,x
.d7b1		f0 70		beq $d823	                beq _line_done
.d7b3		20 3d a3	jsr $a33d	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d7b6		20 8e 8f	jsr $8f8e	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d7b9		b5 00		lda $00,x	                lda 0,x
.d7bb		15 01		ora $01,x	                ora 1,x
.d7bd		d0 28		bne $d7e7	                bne _got_name_token
.d7bf		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d7c0		e8		inx		                inx
.d7c1		20 3e 96	jsr $963e	                jsr xt_number           ; ( addr u -- u|d )
.d7c4		a5 16		lda $16		                lda state
.d7c6		f0 e2		beq $d7aa	                beq _loop
.d7c8		a9 20		lda #$20	                lda #$20
.d7ca		24 20		bit $20		                bit status
.d7cc		f0 0d		beq $d7db	                beq _single_number
.d7ce		20 33 a1	jsr $a133	                jsr xt_swap
.d7d1		a0 93		ldy #$93	                ldy #>literal_runtime
.d7d3		a9 49		lda #$49	                lda #<literal_runtime
.d7d5		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.d7d8		20 24 87	jsr $8724	                jsr xt_comma
.d7db						_single_number:
.d7db		a0 93		ldy #$93	                ldy #>literal_runtime
.d7dd		a9 49		lda #$49	                lda #<literal_runtime
.d7df		20 e5 d6	jsr $d6e5	                jsr cmpl_subroutine
.d7e2		20 24 87	jsr $8724	                jsr xt_comma
.d7e5		80 c3		bra $d7aa	                bra _loop
.d7e7						_got_name_token:
.d7e7		b5 00		lda $00,x	                lda 0,x
.d7e9		95 04		sta $04,x	                sta 4,x
.d7eb		b5 01		lda $01,x	                lda 1,x
.d7ed		95 05		sta $05,x	                sta 5,x
.d7ef		e8		inx		                inx
.d7f0		e8		inx		                inx
.d7f1		e8		inx		                inx
.d7f2		e8		inx		                inx                     ; ( nt )
.d7f3		b5 00		lda $00,x	                lda 0,x
.d7f5		85 22		sta $22		                sta tmpbranch
.d7f7		b5 01		lda $01,x	                lda 1,x
.d7f9		85 23		sta $23		                sta tmpbranch+1
.d7fb		20 95 95	jsr $9595	                jsr xt_name_to_int      ; ( nt - xt )
.d7fe		a5 16		lda $16		                lda state
.d800		d0 13		bne $d815	                bne _compile
.d802		a0 01		ldy #$01	                ldy #1
.d804		b1 22		lda ($22),y	                lda (tmpbranch),y
.d806		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d808		f0 05		beq $d80f	                beq _interpret
.d80a		a9 02		lda #$02	                lda #err_compileonly
.d80c		4c 58 d8	jmp $d858	                jmp error
.d80f						_interpret:
.d80f		20 f0 8e	jsr $8ef0	                jsr xt_execute
.d812		4c aa d7	jmp $d7aa	                jmp _loop
.d815						_compile:
.d815		a0 01		ldy #$01	                ldy #1
.d817		b1 22		lda ($22),y	                lda (tmpbranch),y
.d819		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d81b		d0 f2		bne $d80f	                bne _interpret          ; IMMEDIATE word, execute right now
.d81d		20 a3 87	jsr $87a3	                jsr xt_compile_comma
.d820		4c aa d7	jmp $d7aa	                jmp _loop
.d823						_line_done:
.d823		e8		inx		                inx
.d824		e8		inx		                inx
.d825		e8		inx		                inx
.d826		e8		inx		                inx
.d827		60		rts		                rts
.d828						is_printable:
.d828		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d82a		90 08		bcc $d834	                bcc _done
.d82c		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d82e		b0 03		bcs $d833	                bcs _failed
.d830		38		sec		                sec
.d831		80 01		bra $d834	                bra _done
.d833						_failed:
.d833		18		clc		                clc
.d834						_done:
.d834		60		rts		                rts
.d835						is_whitespace:
.d835		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d837		90 08		bcc $d841	                bcc _done
.d839		c9 21		cmp #$21	                cmp #AscSP+1
.d83b		b0 03		bcs $d840	                bcs _failed
.d83d		38		sec		                sec
.d83e		80 01		bra $d841	                bra _done
.d840						_failed:
.d840		18		clc		                clc
.d841						_done:
.d841		60		rts		                rts
.d842						underflow_1:
.d842		e0 77		cpx #$77	                cpx #dsp0-1
.d844		10 10		bpl $d856	                bpl underflow_error
.d846		60		rts		                rts
.d847						underflow_2:
.d847		e0 75		cpx #$75	                cpx #dsp0-3
.d849		10 0b		bpl $d856	                bpl underflow_error
.d84b		60		rts		                rts
.d84c						underflow_3:
.d84c		e0 73		cpx #$73	                cpx #dsp0-5
.d84e		10 06		bpl $d856	                bpl underflow_error
.d850		60		rts		                rts
.d851						underflow_4:
.d851		e0 71		cpx #$71	                cpx #dsp0-7
.d853		10 01		bpl $d856	                bpl underflow_error
.d855		60		rts		                rts
.d856						underflow_error:
.d856		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d858						error:
.d858		48		pha		                pha                     ; save error
.d859		20 98 d8	jsr $d898	                jsr print_error
.d85c		20 2a 89	jsr $892a	                jsr xt_cr
.d85f		68		pla		                pla
.d860		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d862		d0 17		bne $d87b	                bne _no_underflow
.d864		a9 0d		lda #$0d	                lda #err_returnstack
.d866		20 98 d8	jsr $d898	                jsr print_error
.d869		ba		tsx		                tsx
.d86a						-
.d86a		e8		inx		                inx
.d86b		f0 0b		beq $d878	                beq +
.d86d		20 a3 a0	jsr $a0a3	                jsr xt_space
.d870		bd 00 01	lda $0100,x	                lda $100,x
.d873		20 52 d7	jsr $d752	                jsr byte_to_ascii
.d876		80 f2		bra $d86a	                bra -
.d878						+
.d878		20 2a 89	jsr $892a	                jsr xt_cr
.d87b						_no_underflow:
.d87b		4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d87e						print_string_no_lf:
.d87e		0a		asl a		                asl
.d87f		a8		tay		                tay
.d880		b9 d8 d3	lda $d3d8,y	                lda string_table,y
.d883		85 28		sta $28		                sta tmp3                ; LSB
.d885		c8		iny		                iny
.d886		b9 d8 d3	lda $d3d8,y	                lda string_table,y
.d889		85 29		sta $29		                sta tmp3+1              ; MSB
.d88b						print_common:
.d88b		a0 00		ldy #$00	                ldy #0
.d88d						_loop:
.d88d		b1 28		lda ($28),y	                lda (tmp3),y
.d88f		f0 06		beq $d897	                beq _done               ; strings are zero-terminated
.d891		20 a9 8d	jsr $8da9	                jsr emit_a              ; allows vectoring via output
.d894		c8		iny		                iny
.d895		80 f6		bra $d88d	                bra _loop
.d897						_done:
.d897		60		rts		                rts
.d898						print_error:
.d898		0a		asl a		                asl
.d899		a8		tay		                tay
.d89a		b9 ad d4	lda $d4ad,y	                lda error_table,y
.d89d		85 28		sta $28		                sta tmp3                ; LSB
.d89f		c8		iny		                iny
.d8a0		b9 ad d4	lda $d4ad,y	                lda error_table,y
.d8a3		85 29		sta $29		                sta tmp3+1              ; MSB
.d8a5		20 8b d8	jsr $d88b	                jsr print_common
.d8a8		60		rts		                rts
.d8a9						print_string:
.d8a9		20 7e d8	jsr $d87e	                jsr print_string_no_lf
.d8ac		4c 2a 89	jmp $892a	                jmp xt_cr               ; JSR/RTS because never compiled
.d8af						print_u:
.d8af		20 2d a7	jsr $a72d	                jsr xt_zero                     ; 0
.d8b2		20 0b 93	jsr $930b	                jsr xt_less_number_sign         ; <#
.d8b5		20 92 97	jsr $9792	                jsr xt_number_sign_s            ; #S
.d8b8		20 70 97	jsr $9770	                jsr xt_number_sign_greater      ; #>
.d8bb		4c 88 a4	jmp $a488	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010						v_nmi:
.f010						v_reset:
.f010						v_irq:
.f010						kernel_init:
.f010		78		sei		                sei             ; Disable interrupts
.f011		a2 00		ldx #$00	                ldx #0
.f013		bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016		f0 06		beq $f01e	                beq _done
.f018		20 27 f0	jsr $f027	                jsr kernel_putc
.f01b		e8		inx		                inx
.f01c		80 f5		bra $f013	                bra -
.f01e						_done:
.f01e		4c 00 80	jmp $8000	                jmp forth
.f021						kernel_getc:
.f021						_loop:
.f021		ad 04 f0	lda $f004	                lda $f004
.f024		f0 fb		beq $f021	                beq _loop
.f026		60		rts		                rts
.f027						kernel_putc:
.f027		8d 01 f0	sta $f001	                sta $f001
.f02a		60		rts		                rts
.f02b						platform_bye:
.f02b		00		brk #		                brk
.f02c						s_kernel_id:
>f02c		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		10 f0				.word v_nmi
>fffc		10 f0				.word v_reset
>fffe		10 f0				.word v_irq

;******  End of listing
