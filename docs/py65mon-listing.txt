
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Sat May 11 21:41:10 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 2d		lda #$2d	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd 6c b3	lda $b36c,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad 6c b3	lda $b36c	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f		a9 00		lda #$00	                lda #0
.8021						_load_user_vars_loop:
.8021		b9 8a b3	lda $b38a,y	                lda cold_user_table,y
.8024		91 08		sta ($08),y	                sta (up),y
.8026		88		dey		                dey
.8027		d0 f8		bne $8021	                bne _load_user_vars_loop
.8029		ad 8a b3	lda $b38a	                lda cold_user_table
.802c		92 08		sta ($08)	                sta (up)
.802e		20 3c 84	jsr $843c	                jsr xt_cr
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		ca		dex		                dex
.8034		ca		dex		                dex
.8035		a9 6d		lda #$6d	                lda #<forth_words_start
.8037		95 02		sta $02,x	                sta 2,x
.8039		a9 ba		lda #$ba	                lda #>forth_words_start
.803b		95 03		sta $03,x	                sta 3,x
.803d		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803f		95 00		sta $00,x	                sta 0,x
.8041		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043		95 01		sta $01,x	                sta 1,x
.8045		20 b1 88	jsr $88b1	                jsr xt_evaluate
.8048		9c 00 7c	stz $7c00	                stz hist_buff
.804b		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e		9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057		9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d		9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060						xt_abort:
.8060		a2 78		ldx #$78	                ldx #dsp0
.8062						xt_quit:
.8062		8a		txa		                txa             ; Save the DSP that we just defined
.8063		a2 ff		ldx #$ff	                ldx #rsp0
.8065		9a		txs		                txs
.8066		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067		64 04		stz $04		                stz ip
.8069		64 05		stz $05		                stz ip+1
.806b		64 0a		stz $0a		                stz insrc
.806d		64 0b		stz $0b		                stz insrc+1
.806f		a9 00		lda #$00	                lda #0
.8071		a0 04		ldy #$04	                ldy #blk_offset
.8073		91 08		sta ($08),y	                sta (up),y
.8075		c8		iny		                iny
.8076		91 08		sta ($08),y	                sta (up),y
.8078		a9 fc		lda #$fc	                lda #(256-4)
.807a		85 1f		sta $1f		                sta loopctrl
.807c		64 1a		stz $1a		                stz state
.807e		64 1b		stz $1b		                stz state+1
.8080						_get_line:
.8080		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8082		85 0c		sta $0c		                sta cib
.8084		a9 02		lda #$02	                lda #>buffer0
.8086		85 0d		sta $0d		                sta cib+1
.8088		64 0e		stz $0e		                stz ciblen
.808a		64 0f		stz $0f		                stz ciblen+1
.808c		20 34 8f	jsr $8f34	                jsr xt_refill           ; ( -- f )
.808f		b5 00		lda $00,x	                lda 0,x
.8091		d0 05		bne $8098	                bne _success
.8093		a9 06		lda #$06	                lda #err_refill
.8095		4c b3 d7	jmp $d7b3	                jmp error
.8098						_success:
.8098		e8		inx		                inx                     ; drop
.8099		e8		inx		                inx
.809a		20 1a d7	jsr $d71a	                jsr interpret
.809d		e0 78		cpx #$78	                cpx #dsp0
.809f		f0 05		beq $80a6	                beq _stack_ok
.80a1		90 03		bcc $80a6	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a3		4c b1 d7	jmp $d7b1	                jmp underflow_error
.80a6						_stack_ok:
.80a6		a5 1a		lda $1a		                lda state
.80a8		f0 02		beq $80ac	                beq _print
.80aa		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80ac						_print:
.80ac		20 04 d8	jsr $d804	                jsr print_string
.80af		80 cf		bra $8080	                bra _get_line
.80b1						z_cold:
.80b1						z_abort:
.80b1						z_quit:

;******  Processing file: platform/../words/core.asm

.80b1						xt_abort_quote:
.80b1		20 cc 8f	jsr $8fcc	                jsr xt_s_quote          ; S"
.80b4		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b6		a9 bc		lda #$bc	                lda #<abort_quote_runtime
.80b8		20 8d 97	jsr $978d	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80bb		60		rts		z_abort_quote:  rts
.80bc						abort_quote_runtime:
.80bc		b5 04		lda $04,x	                lda 4,x
.80be		15 05		ora $05,x	                ora 5,x
.80c0		f0 09		beq $80cb	                beq _done       ; if FALSE, we're done
.80c2		20 c9 94	jsr $94c9	                jsr xt_type
.80c5		20 3c 84	jsr $843c	                jsr xt_cr
.80c8		4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.80cb						_done:
.80cb		8a		txa		                txa
.80cc		18		clc		                clc
.80cd		69 06		adc #$06	                adc #6
.80cf		aa		tax		                tax
.80d0		60		rts		                rts
.80d1						xt_abs:
.80d1		20 9d d7	jsr $d79d	                jsr underflow_1
.80d4		b5 01		lda $01,x	                lda 1,x
.80d6		10 0d		bpl $80e5	                bpl _done       ; positive number, easy money!
.80d8		38		sec		                sec
.80d9		a9 00		lda #$00	                lda #0
.80db		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80dd		95 00		sta $00,x	                sta 0,x
.80df		a9 00		lda #$00	                lda #0          ; MSB
.80e1		f5 01		sbc $01,x	                sbc 1,x
.80e3		95 01		sta $01,x	                sta 1,x
.80e5						_done:
.80e5		60		rts		z_abs:          rts
.80e6						xt_accept:
.80e6		20 a2 d7	jsr $d7a2	                jsr underflow_2
.80e9		b5 00		lda $00,x	                lda 0,x
.80eb		15 01		ora $01,x	                ora 1,x
.80ed		d0 09		bne $80f8	                bne _not_zero
.80ef		e8		inx		                inx
.80f0		e8		inx		                inx
.80f1		74 00		stz $00,x	                stz 0,x
.80f3		74 01		stz $01,x	                stz 1,x
.80f5		4c c4 81	jmp $81c4	                jmp accept_done
.80f8						_not_zero:
.80f8		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80fa		85 27		sta $27		                sta tmp2
.80fc		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fe		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8100		85 25		sta $25		                sta tmp1
.8102		b5 03		lda $03,x	                lda 3,x
.8104		85 26		sta $26		                sta tmp1+1
.8106		e8		inx		                inx
.8107		e8		inx		                inx
.8108		a0 00		ldy #$00	                ldy #0
.810a		a5 1c		lda $1c		                lda status
.810c		29 f7		and #$f7	                and #$F7
.810e		1a		inc a		               ina
.810f		09 08		ora #$08	                ora #%00001000
.8111		85 1c		sta $1c		                sta status
.8113						accept_loop:
.8113		20 b0 89	jsr $89b0	                jsr key_a
.8116		c9 0a		cmp #$0a	                cmp #AscLF
.8118		f0 20		beq $813a	                beq _eol
.811a		c9 0d		cmp #$0d	                cmp #AscCR
.811c		f0 1c		beq $813a	                beq _eol
.811e		c9 08		cmp #$08	                cmp #AscBS
.8120		f0 22		beq $8144	                beq _backspace
.8122		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8124		f0 1e		beq $8144	                beq _backspace
.8126		c9 10		cmp #$10	                cmp #AscCP
.8128		f0 36		beq $8160	                beq _ctrl_p
.812a		c9 0e		cmp #$0e	                cmp #AscCN
.812c		f0 44		beq $8172	                beq _ctrl_n
.812e		91 25		sta ($25),y	                sta (tmp1),y
.8130		c8		iny		                iny
.8131		20 c4 86	jsr $86c4	                jsr emit_a
.8134		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8136		d0 db		bne $8113	                bne accept_loop       ; fall through if buffer limit reached
.8138		80 03		bra $813d	                bra _buffer_full
.813a						_eol:
.813a		20 bd 91	jsr $91bd	                jsr xt_space    ; print final space
.813d						_buffer_full:
.813d		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813f		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.8141		4c c4 81	jmp $81c4	                jmp accept_done
.8144						_backspace:
.8144		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8146		d0 06		bne $814e	                bne +
.8148		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.814a		20 c4 86	jsr $86c4	                jsr emit_a
.814d		c8		iny		                iny
.814e						+
.814e		88		dey		                dey
.814f		a9 08		lda #$08	                lda #AscBS      ; move back one
.8151		20 c4 86	jsr $86c4	                jsr emit_a
.8154		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8156		20 c4 86	jsr $86c4	                jsr emit_a
.8159		a9 08		lda #$08	                lda #AscBS      ; move back over space
.815b		20 c4 86	jsr $86c4	                jsr emit_a
.815e		80 b3		bra $8113	                bra accept_loop
.8160						_ctrl_p:
.8160		a5 1c		lda $1c		                lda status
.8162		29 07		and #$07	                and #7
.8164		d0 08		bne $816e	                bne _ctrl_p_dec
.8166		a5 1c		lda $1c		                lda status
.8168		09 07		ora #$07	                ora #7
.816a		85 1c		sta $1c		                sta status
.816c		80 11		bra $817f	                bra _recall_history
.816e						_ctrl_p_dec:
.816e		c6 1c		dec $1c		                dec status
.8170		80 0d		bra $817f	                bra _recall_history
.8172						_ctrl_n:
.8172		a9 08		lda #$08	                lda #$8
.8174		24 1c		bit $1c		                bit status
.8176		d0 07		bne $817f	                bne _recall_history
.8178		a5 1c		lda $1c		                lda status
.817a		29 f7		and #$f7	                and #$F7
.817c		1a		inc a		               ina
.817d		85 1c		sta $1c		                sta status
.817f						_recall_history:
.817f		a9 08		lda #$08	                lda #%00001000
.8181		14 1c		trb $1c		                trb status
.8183		20 df 81	jsr $81df	                jsr accept_total_recall
.8186		a9 0d		lda #$0d	                lda #AscCR
.8188		20 c4 86	jsr $86c4	                jsr emit_a
.818b						input_clear:
.818b		c0 00		cpy #$00	                cpy #0
.818d		f0 08		beq $8197	                beq input_cleared
.818f		a9 20		lda #$20	                lda #AscSP
.8191		20 c4 86	jsr $86c4	                jsr emit_a
.8194		88		dey		                dey
.8195		80 f4		bra $818b	                bra input_clear
.8197						input_cleared:
.8197		a9 0d		lda #$0d	                lda #AscCR
.8199		20 c4 86	jsr $86c4	                jsr emit_a
.819c		b1 29		lda ($29),y	                lda (tmp3),y
.819e		85 1d		sta $1d		                sta status+1
.81a0		e6 29		inc $29		                inc tmp3
.81a2		d0 02		bne $81a6	                bne +           ; Increment the upper byte on carry.
.81a4		e6 2a		inc $2a		                inc tmp3+1
.81a6						+
.81a6		a9 0d		lda #$0d	                lda #AscCR
.81a8		20 c4 86	jsr $86c4	                jsr emit_a
.81ab						_history_loop:
.81ab		c4 1d		cpy $1d		                cpy status+1
.81ad		d0 03		bne $81b2	                bne +
.81af		4c 13 81	jmp $8113	                jmp accept_loop       ; Needs a long jump
.81b2						+
.81b2		c4 27		cpy $27		                cpy tmp2
.81b4		f0 0a		beq $81c0	                beq _hist_filled_buffer
.81b6		b1 29		lda ($29),y	                lda (tmp3),y
.81b8		91 25		sta ($25),y	                sta (tmp1),y
.81ba		20 c4 86	jsr $86c4	                jsr emit_a
.81bd		c8		iny		                iny
.81be		80 eb		bra $81ab	                bra _history_loop
.81c0						_hist_filled_buffer:
.81c0		88		dey		                dey
.81c1		4c 13 81	jmp $8113	                jmp accept_loop
.81c4						accept_done:
.81c4		20 df 81	jsr $81df	                jsr accept_total_recall
.81c7		85 1d		sta $1d		                sta status+1
.81c9		a0 00		ldy #$00	                ldy #0
.81cb		91 29		sta ($29),y	                sta (tmp3),y
.81cd		e6 29		inc $29		                inc tmp3
.81cf		d0 02		bne $81d3	                bne +           ; Increment the upper byte on carry.
.81d1		e6 2a		inc $2a		                inc tmp3+1
.81d3						+
.81d3						_save_history_loop:
.81d3		c4 1d		cpy $1d		                cpy status+1
.81d5		f0 07		beq $81de	                beq _save_history_done
.81d7		b1 25		lda ($25),y	                lda (tmp1),y
.81d9		91 29		sta ($29),y	                sta (tmp3),y
.81db		c8		iny		                iny
.81dc		80 f5		bra $81d3	                bra _save_history_loop
.81de						_save_history_done:
.81de						z_accept:
.81de		60		rts		                rts
.81df						accept_total_recall:
.81df		a9 00		lda #$00	                lda #<hist_buff
.81e1		85 29		sta $29		                sta tmp3
.81e3		a9 7c		lda #$7c	                lda #>hist_buff
.81e5		85 2a		sta $2a		                sta tmp3+1
.81e7		a5 1c		lda $1c		                lda status
.81e9		6a		ror a		                ror
.81ea		29 03		and #$03	                and #3
.81ec		18		clc		                clc
.81ed		65 2a		adc $2a		                adc tmp3+1
.81ef		85 2a		sta $2a		                sta tmp3+1
.81f1		a5 1c		lda $1c		                lda status
.81f3		6a		ror a		                ror             ; Rotate through carry into msb.
.81f4		6a		ror a		                ror
.81f5		29 80		and #$80	                and #$80
.81f7		18		clc		                clc
.81f8		65 29		adc $29		                adc tmp3
.81fa		85 29		sta $29		                sta tmp3
.81fc		90 02		bcc $8200	                bcc +           ; Increment the upper byte on carry.
.81fe		e6 2a		inc $2a		                inc tmp3+1
.8200						+
.8200		98		tya		                tya
.8201		c9 80		cmp #$80	                cmp #$80
.8203		90 02		bcc $8207	                bcc +
.8205		a9 7f		lda #$7f	                lda #$7F
.8207						+
.8207		60		rts		                rts
.8208						xt_action_of:
.8208		a5 1a		lda $1a		                lda state
.820a		05 1b		ora $1b		                ora state+1
.820c		f0 0c		beq $821a	                beq _interpreting
.820e		20 16 83	jsr $8316	                jsr xt_bracket_tick
.8211		a0 85		ldy #$85	                ldy #>xt_defer_fetch
.8213		a9 46		lda #$46	                lda #<xt_defer_fetch
.8215		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.8218		80 06		bra $8220	                bra _done
.821a						_interpreting:
.821a		20 56 92	jsr $9256	                jsr xt_tick
.821d		20 46 85	jsr $8546	                jsr xt_defer_fetch
.8220						_done:
.8220		60		rts		z_action_of:           rts
.8221						xt_again:
.8221		20 9d d7	jsr $d79d	                jsr underflow_1
.8224		20 a6 97	jsr $97a6	                jsr cmpl_jump_tos
.8227		60		rts		z_again:        rts
.8228						xt_align:
.8228						xt_aligned:
.8228						z_align:
.8228						z_aligned:
.8228		60		rts		                rts             ; stripped out during native compile
.8229						xt_allot:
.8229		20 9d d7	jsr $d79d	                jsr underflow_1
.822c		b5 01		lda $01,x	                lda 1,x
.822e		30 22		bmi $8252	                bmi _release
.8230		18		clc		                clc
.8231		a5 00		lda $00		                lda cp
.8233		75 00		adc $00,x	                adc 0,x
.8235		85 00		sta $00		                sta cp
.8237		a5 01		lda $01		                lda cp+1
.8239		75 01		adc $01,x	                adc 1,x
.823b		85 01		sta $01		                sta cp+1
.823d		a0 00		ldy #$00	                ldy #<cp_end
.823f		c4 00		cpy $00		                cpy cp
.8241		a9 7c		lda #$7c	                lda #>cp_end
.8243		e5 01		sbc $01		                sbc cp+1
.8245		b0 48		bcs $828f	                bcs _done               ; we're fine.
.8247		84 00		sty $00		                sty cp                  ; still #<cp_end
.8249		a9 7c		lda #$7c	                lda #>cp_end
.824b		85 01		sta $01		                sta cp+1
.824d		a9 00		lda #$00	                lda #err_allot
.824f		4c b3 d7	jmp $d7b3	                jmp error
.8252						_release:
.8252		ca		dex		                dex
.8253		ca		dex		                dex
.8254		a5 00		lda $00		                lda cp
.8256		95 00		sta $00,x	                sta 0,x
.8258		a5 01		lda $01		                lda cp+1
.825a		95 01		sta $01,x	                sta 1,x
.825c		20 4b 8e	jsr $8e4b	                jsr xt_plus                     ; new CP is now TOS
.825f		ca		dex		                dex
.8260		ca		dex		                dex                             ; new CP now NOS
.8261		a9 00		lda #$00	                lda #<cp0
.8263		95 00		sta $00,x	                sta 0,x
.8265		a9 03		lda #$03	                lda #>cp0
.8267		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8269		20 db d6	jsr $d6db	                jsr compare_16bit               ; still ( CP CP0 )
.826c		f0 17		beq $8285	                beq _nega_done
.826e		30 15		bmi $8285	                bmi _nega_done
.8270		a9 00		lda #$00	                lda #<cp0
.8272		85 00		sta $00		                sta cp
.8274		a9 03		lda #$03	                lda #>cp0
.8276		85 01		sta $01		                sta cp+1
.8278		a9 4f		lda #$4f	                lda #<dictionary_start
.827a		85 02		sta $02		                sta dp
.827c		a9 bb		lda #$bb	                lda #>dictionary_start
.827e		85 03		sta $03		                sta dp+1
.8280		a9 0a		lda #$0a	                lda #err_negallot
.8282		4c b3 d7	jmp $d7b3	                jmp error
.8285						_nega_done:
.8285		b5 02		lda $02,x	                lda 2,x
.8287		85 00		sta $00		                sta cp
.8289		b5 03		lda $03,x	                lda 3,x
.828b		85 01		sta $01		                sta cp+1
.828d		e8		inx		                inx
.828e		e8		inx		                inx                     ; drop through to _done
.828f						_done:
.828f		e8		inx		                inx
.8290		e8		inx		                inx
.8291						z_allot:
.8291		60		rts		                rts
.8292						xt_and:
.8292		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8295		b5 00		lda $00,x	                lda 0,x
.8297		35 02		and $02,x	                and 2,x
.8299		95 02		sta $02,x	                sta 2,x
.829b		b5 01		lda $01,x	                lda 1,x
.829d		35 03		and $03,x	                and 3,x
.829f		95 03		sta $03,x	                sta 3,x
.82a1		e8		inx		                inx
.82a2		e8		inx		                inx
.82a3		60		rts		z_and:          rts
.82a4						xt_at_xy:
.82a4		20 a2 d7	jsr $d7a2	                jsr underflow_2
.82a7		a5 18		lda $18		                lda base
.82a9		48		pha		                pha
.82aa		a9 0a		lda #$0a	                lda #10
.82ac		85 18		sta $18		                sta base
.82ae		a9 1b		lda #$1b	                lda #AscESC
.82b0		20 c4 86	jsr $86c4	                jsr emit_a
.82b3		a9 5b		lda #$5b	                lda #'['
.82b5		20 c4 86	jsr $86c4	                jsr emit_a
.82b8		20 e1 8c	jsr $8ce1	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82bb		20 0a d8	jsr $d80a	                jsr print_u
.82be		a9 3b		lda #$3b	                lda #';'
.82c0		20 c4 86	jsr $86c4	                jsr emit_a
.82c3		20 e1 8c	jsr $8ce1	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c6		20 0a d8	jsr $d80a	                jsr print_u
.82c9		a9 48		lda #$48	                lda #'H'
.82cb		20 c4 86	jsr $86c4	                jsr emit_a
.82ce		68		pla		                pla
.82cf		85 18		sta $18		                sta base
.82d1		60		rts		z_at_xy:        rts
.82d2						xt_backslash:
.82d2		a0 04		ldy #$04	                ldy #blk_offset
.82d4		b1 08		lda ($08),y	                lda (up),y
.82d6		c8		iny		                iny
.82d7		11 08		ora ($08),y	                ora (up),y
.82d9		f0 19		beq $82f4	                beq backslash_not_block
.82db		a5 10		lda $10		                lda toin
.82dd		29 3f		and #$3f	                and #$3F
.82df		f0 1b		beq $82fc	                beq z_backslash
.82e1		c9 01		cmp #$01	                cmp #$1
.82e3		f0 17		beq $82fc	                beq z_backslash
.82e5		a5 10		lda $10		                lda toin
.82e7		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82e9		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82ea		69 40		adc #$40	                adc #$40
.82ec		85 10		sta $10		                sta toin
.82ee		90 0c		bcc $82fc	                bcc z_backslash
.82f0		e6 11		inc $11		                inc toin+1
.82f2		80 08		bra $82fc	                bra z_backslash
.82f4						backslash_not_block:
.82f4		a5 0e		lda $0e		                lda ciblen
.82f6		85 10		sta $10		                sta toin
.82f8		a5 0f		lda $0f		                lda ciblen+1
.82fa		85 11		sta $11		                sta toin+1
.82fc		60		rts		z_backslash:    rts
.82fd						xt_base:
.82fd		ca		dex		                dex
.82fe		ca		dex		                dex
.82ff		a9 18		lda #$18	                lda #<base
.8301		95 00		sta $00,x	                sta 0,x         ; LSB
.8303		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8305		60		rts		z_base:         rts
.8306						xt_bl:
.8306		ca		dex		                dex
.8307		ca		dex		                dex
.8308		a9 20		lda #$20	                lda #AscSP
.830a		95 00		sta $00,x	                sta 0,x
.830c		74 01		stz $01,x	                stz 1,x
.830e		60		rts		z_bl:           rts
.830f						xt_bracket_char:
.830f		20 55 83	jsr $8355	                jsr xt_char
.8312		20 f1 89	jsr $89f1	                jsr xt_literal
.8315		60		rts		z_bracket_char: rts
.8316						xt_bracket_tick:
.8316		20 56 92	jsr $9256	                jsr xt_tick
.8319		20 f1 89	jsr $89f1	                jsr xt_literal
.831c		60		rts		z_bracket_tick: rts
.831d						xt_buffer_colon:
.831d		20 42 84	jsr $8442	                jsr xt_create
.8320		20 29 82	jsr $8229	                jsr xt_allot
.8323		60		rts		z_buffer_colon: rts
.8324						xt_c_comma:
.8324		20 9d d7	jsr $d79d	                jsr underflow_1
.8327		b5 00		lda $00,x	                lda 0,x
.8329		20 9d 97	jsr $979d	                jsr cmpl_a
.832c		e8		inx		                inx
.832d		e8		inx		                inx
.832e		60		rts		z_c_comma:      rts
.832f						xt_c_fetch:
.832f		20 9d d7	jsr $d79d	                jsr underflow_1
.8332		a1 00		lda ($00,x)	                lda (0,x)
.8334		95 00		sta $00,x	                sta 0,x
.8336		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8338		60		rts		z_c_fetch:      rts
.8339						xt_c_store:
.8339		20 a2 d7	jsr $d7a2	                jsr underflow_2
.833c		b5 02		lda $02,x	                lda 2,x
.833e		81 00		sta ($00,x)	                sta (0,x)
.8340		e8		inx		                inx
.8341		e8		inx		                inx
.8342		e8		inx		                inx
.8343		e8		inx		                inx
.8344		60		rts		z_c_store:      rts
.8345						xt_cell_plus:
.8345		20 9d d7	jsr $d79d	                jsr underflow_1
.8348		f6 00		inc $00,x	                inc 0,x
.834a		d0 02		bne $834e	                bne +
.834c		f6 01		inc $01,x	                inc 1,x
.834e						+
.834e		f6 00		inc $00,x	                inc 0,x
.8350		d0 02		bne $8354	                bne _done
.8352		f6 01		inc $01,x	                inc 1,x
.8354						_done:
.8354		60		rts		z_cell_plus:    rts
.8355						xt_char:
.8355		20 49 8d	jsr $8d49	                jsr xt_parse_name
.8358		b5 00		lda $00,x	                lda 0,x
.835a		15 01		ora $01,x	                ora 1,x
.835c		d0 05		bne $8363	                bne _not_empty
.835e		a9 05		lda #$05	                lda #err_noname
.8360		4c b3 d7	jmp $d7b3	                jmp error
.8363						_not_empty:
.8363		e8		inx		                inx             ; drop number of characters, leave addr
.8364		e8		inx		                inx
.8365		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8367		95 00		sta $00,x	                sta 0,x
.8369		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.836b		60		rts		z_char:         rts
.836c						xt_chars:
.836c		20 9d d7	jsr $d79d	                jsr underflow_1
.836f		60		rts		z_chars:        rts
.8370						xt_colon:
.8370		a5 1a		lda $1a		                lda state
.8372		05 1b		ora $1b		                ora state+1
.8374		f0 05		beq $837b	                beq +
.8376		a9 07		lda #$07	                lda #err_state
.8378		4c b3 d7	jmp $d7b3	                jmp error
.837b						+
.837b		c6 1a		dec $1a		                dec state
.837d		c6 1b		dec $1b		                dec state+1
.837f		a9 40		lda #$40	                lda #%01000000
.8381		04 1c		tsb $1c		                tsb status
.8383		20 f4 d6	jsr $d6f4	                jsr current_to_dp
.8386		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8388		48		pha		                pha
.8389		a5 02		lda $02		                lda dp
.838b		48		pha		                pha
.838c		a9 80		lda #$80	                lda #%10000000
.838e		04 1c		tsb $1c		                tsb status
.8390		20 42 84	jsr $8442	                jsr xt_create
.8393		20 f4 d6	jsr $d6f4	                jsr current_to_dp   ; This might be able to be omitted
.8396		a5 02		lda $02		                lda dp
.8398		85 06		sta $06		                sta workword
.839a		a5 03		lda $03		                lda dp+1
.839c		85 07		sta $07		                sta workword+1
.839e		68		pla		                pla
.839f		85 02		sta $02		                sta dp
.83a1		68		pla		                pla
.83a2		85 03		sta $03		                sta dp+1
.83a4		20 07 d7	jsr $d707	                jsr dp_to_current
.83a7		a5 00		lda $00		                lda cp
.83a9		38		sec		                sec
.83aa		e9 03		sbc #$03	                sbc #3
.83ac		85 00		sta $00		                sta cp
.83ae		b0 02		bcs $83b2	                bcs _done
.83b0		c6 01		dec $01		                dec cp+1
.83b2						_done:
.83b2		60		rts		z_colon:        rts
.83b3						xt_colon_noname:
.83b3		a5 1a		lda $1a		                lda state
.83b5		05 1b		ora $1b		                ora state+1
.83b7		f0 05		beq $83be	                beq +
.83b9		a9 07		lda #$07	                lda #err_state
.83bb		4c b3 d7	jmp $d7b3	                jmp error
.83be						+
.83be		c6 1a		dec $1a		                dec state
.83c0		c6 1b		dec $1b		                dec state+1
.83c2		a9 40		lda #$40	                lda #%01000000
.83c4		14 1c		trb $1c		                trb status
.83c6		a5 00		lda $00		                lda cp
.83c8		85 06		sta $06		                sta workword
.83ca		a5 01		lda $01		                lda cp+1
.83cc		85 07		sta $07		                sta workword+1
.83ce		60		rts		z_colon_noname:        rts
.83cf						xt_comma:
.83cf		20 9d d7	jsr $d79d	                jsr underflow_1
.83d2		a0 02		ldy #$02	                ldy #2
.83d4		b5 00		lda $00,x	_twice:         lda 0,x
.83d6		20 9d 97	jsr $979d	                jsr cmpl_a
.83d9		e8		inx		                inx
.83da		88		dey		                dey
.83db		d0 f7		bne $83d4	                bne _twice
.83dd		60		rts		z_comma:        rts
.83de						xt_compile_only:
.83de		20 f4 d6	jsr $d6f4	                jsr current_to_dp
.83e1		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.83e3		b1 02		lda ($02),y	                lda (dp),y
.83e5		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.83e7		91 02		sta ($02),y	                sta (dp),y
.83e9		60		rts		z_compile_only: rts
.83ea						xt_value:
.83ea						xt_constant:
.83ea		20 9d d7	jsr $d79d	                jsr underflow_1
.83ed		20 42 84	jsr $8442	                jsr xt_create
.83f0		38		sec		                sec
.83f1		a5 00		lda $00		                lda cp
.83f3		e9 02		sbc #$02	                sbc #2
.83f5		85 25		sta $25		                sta tmp1
.83f7		a5 01		lda $01		                lda cp+1
.83f9		e9 00		sbc #$00	                sbc #0
.83fb		85 26		sta $26		                sta tmp1+1
.83fd		a9 05		lda #$05	                lda #<doconst           ; LSB of DOCONST
.83ff		92 25		sta ($25)	                sta (tmp1)
.8401		a0 01		ldy #$01	                ldy #1
.8403		a9 d6		lda #$d6	                lda #>doconst           ; MSB of DOCONST
.8405		91 25		sta ($25),y	                sta (tmp1),y
.8407		20 cf 83	jsr $83cf	                jsr xt_comma            ; drop through to adjust_z
.840a						adjust_z:
.840a		20 2c 9c	jsr $9c2c	                jsr xt_latestnt         ; gives us ( -- nt )
.840d		b5 00		lda $00,x	                lda 0,x
.840f		85 25		sta $25		                sta tmp1
.8411		b5 01		lda $01,x	                lda 1,x
.8413		85 26		sta $26		                sta tmp1+1
.8415		a0 06		ldy #$06	                ldy #6
.8417		b1 25		lda ($25),y	                lda (tmp1),y
.8419		18		clc		                clc
.841a		69 02		adc #$02	                adc #2
.841c		91 25		sta ($25),y	                sta (tmp1),y
.841e		c8		iny		                iny
.841f		b1 25		lda ($25),y	                lda (tmp1),y
.8421		69 00		adc #$00	                adc #0                  ; only need carry
.8423		91 25		sta ($25),y	                sta (tmp1),y
.8425		e8		inx		                inx
.8426		e8		inx		                inx
.8427						z_value:
.8427		60		rts		z_constant:     rts
.8428						xt_count:
.8428		20 9d d7	jsr $d79d	                jsr underflow_1
.842b		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.842d		a8		tay		                tay
.842e		f6 00		inc $00,x	                inc 0,x         ; LSB
.8430		d0 02		bne $8434	                bne +
.8432		f6 01		inc $01,x	                inc 1,x         ; MSB
.8434		98		tya		+               tya
.8435		ca		dex		                dex
.8436		ca		dex		                dex
.8437		95 00		sta $00,x	                sta 0,x         ; LSB
.8439		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.843b		60		rts		z_count:        rts
.843c						xt_cr:
.843c		a9 0a		lda #$0a	                lda #AscLF
.843e		20 c4 86	jsr $86c4	                jsr emit_a
.8441		60		rts		z_cr:           rts
.8442						xt_create:
.8442		20 49 8d	jsr $8d49	                jsr xt_parse_name       ; ( addr u )
.8445		b5 00		lda $00,x	                lda 0,x
.8447		15 01		ora $01,x	                ora 1,x
.8449		d0 05		bne $8450	                bne _got_name
.844b		a9 05		lda #$05	                lda #err_noname
.844d		4c b3 d7	jmp $d7b3	                jmp error
.8450						_got_name:
.8450		74 01		stz $01,x	                stz 1,x
.8452		20 bf 93	jsr $93bf	                jsr xt_two_dup          ; ( addr u addr u )
.8455		20 03 9b	jsr $9b03	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8458		b5 00		lda $00,x	                lda 0,x
.845a		15 01		ora $01,x	                ora 1,x
.845c		f0 1e		beq $847c	                beq _new_name           ; We haven't seen this one before.
.845e		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.845f		e8		inx		                inx
.8460		24 1c		bit $1c		                bit status
.8462		10 08		bpl $846c	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8464		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8466		05 1c		ora $1c		                ora status
.8468		85 1c		sta $1c		                sta status
.846a		80 18		bra $8484	                bra _process_name
.846c						_redefined_name:
.846c		a9 02		lda #$02	                lda #str_redefined
.846e		20 d9 d7	jsr $d7d9	                jsr print_string_no_lf
.8471		20 bf 93	jsr $93bf	                jsr xt_two_dup           ; ( addr u addr u )
.8474		20 c9 94	jsr $94c9	                jsr xt_type
.8477		20 bd 91	jsr $91bd	                jsr xt_space
.847a		80 08		bra $8484	                bra _process_name
.847c						_new_name:
.847c		e8		inx		                inx                     ; Drop flag (0) from find-name.
.847d		e8		inx		                inx
.847e		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.8480		25 1c		and $1c		                and status
.8482		85 1c		sta $1c		                sta status
.8484						_process_name:
.8484		b5 00		lda $00,x	                lda 0,x
.8486		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8488		a5 00		lda $00		                lda cp
.848a		85 25		sta $25		                sta tmp1
.848c		a5 01		lda $01		                lda cp+1
.848e		85 26		sta $26		                sta tmp1+1
.8490		b5 00		lda $00,x	                lda 0,x
.8492		18		clc		                clc
.8493		69 08		adc #$08	                adc #8
.8495		85 29		sta $29		                sta tmp3                ; total header length
.8497		95 00		sta $00,x	                sta 0,x
.8499		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.849b		20 29 82	jsr $8229	                jsr xt_allot    ; ( addr )
.849e		20 f4 d6	jsr $d6f4	                jsr current_to_dp
.84a1		a0 00		ldy #$00	                ldy #0
.84a3		a5 27		lda $27		                lda tmp2
.84a5		91 25		sta ($25),y	                sta (tmp1),y
.84a7		a9 08		lda #$08	                lda #NN
.84a9		09 20		ora #$20	                ora #HC
.84ab		c8		iny		                iny
.84ac		91 25		sta ($25),y	                sta (tmp1),y
.84ae		c8		iny		                iny
.84af		a5 02		lda $02		                lda dp
.84b1		91 25		sta ($25),y	                sta (tmp1),y
.84b3		c8		iny		                iny
.84b4		a5 03		lda $03		                lda dp+1
.84b6		91 25		sta ($25),y	                sta (tmp1),y
.84b8		c8		iny		                iny
.84b9		a5 26		lda $26		                lda tmp1+1
.84bb		85 03		sta $03		                sta dp+1
.84bd		a5 25		lda $25		                lda tmp1
.84bf		85 02		sta $02		                sta dp
.84c1		18		clc		                clc
.84c2		65 29		adc $29		                adc tmp3        ; add total header length
.84c4		91 25		sta ($25),y	                sta (tmp1),y
.84c6		48		pha		                pha             ; we need this in the next step
.84c7		c8		iny		                iny
.84c8		a5 26		lda $26		                lda tmp1+1
.84ca		69 00		adc #$00	                adc #0          ; only need the carry
.84cc		91 25		sta ($25),y	                sta (tmp1),y
.84ce		c8		iny		                iny
.84cf		68		pla		                pla             ; LSB of "z_" address
.84d0		18		clc		                clc
.84d1		69 03		adc #$03	                adc #3
.84d3		91 25		sta ($25),y	                sta (tmp1),y
.84d5		88		dey		                dey             ; get the MSB of xt back
.84d6		b1 25		lda ($25),y	                lda (tmp1),y
.84d8		69 00		adc #$00	                adc #0          ; only need the carry
.84da		c8		iny		                iny
.84db		c8		iny		                iny
.84dc		91 25		sta ($25),y	                sta (tmp1),y
.84de		c8		iny		                iny
.84df		b5 00		lda $00,x	                lda 0,x
.84e1		38		sec		                sec
.84e2		e9 08		sbc #$08	                sbc #8
.84e4		85 23		sta $23		                sta tmptos
.84e6		b5 01		lda $01,x	                lda 1,x
.84e8		e9 00		sbc #$00	                sbc #0          ; only need carry
.84ea		85 24		sta $24		                sta tmptos+1
.84ec						_name_loop:
.84ec		b1 23		lda ($23),y	                lda (tmptos),y
.84ee		c9 5b		cmp #$5b	                cmp #'Z'+1
.84f0		b0 06		bcs $84f8	                bcs _store_name
.84f2		c9 41		cmp #$41	                cmp #'A'
.84f4		90 02		bcc $84f8	                bcc _store_name
.84f6		09 20		ora #$20	                ora #$20
.84f8						_store_name:
.84f8		91 25		sta ($25),y	                sta (tmp1),y
.84fa		c8		iny		                iny
.84fb		c6 27		dec $27		                dec tmp2
.84fd		d0 ed		bne $84ec	                bne _name_loop
.84ff		a0 d6		ldy #$d6	                ldy #>dovar
.8501		a9 4b		lda #$4b	                lda #<dovar
.8503		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.8506		20 07 d7	jsr $d707	                jsr dp_to_current
.8509		e8		inx		                inx
.850a		e8		inx		                inx
.850b		60		rts		z_create:       rts
.850c						xt_decimal:
.850c		a9 0a		lda #$0a	                lda #10
.850e		85 18		sta $18		                sta base
.8510		64 19		stz $19		                stz base+1              ; paranoid
.8512		60		rts		z_decimal:      rts
.8513						xt_defer:
.8513		20 42 84	jsr $8442	                jsr xt_create
.8516		a5 00		lda $00		                lda cp          ; LSB
.8518		38		sec		                sec
.8519		e9 02		sbc #$02	                sbc #2
.851b		85 25		sta $25		                sta tmp1
.851d		a5 01		lda $01		                lda cp+1        ; MSB
.851f		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8521		85 26		sta $26		                sta tmp1+1
.8523		a0 00		ldy #$00	                ldy #0
.8525		a9 19		lda #$19	                lda #<dodefer   ; LSB
.8527		91 25		sta ($25),y	                sta (tmp1),y
.8529		c8		iny		                iny
.852a		a9 d6		lda #$d6	                lda #>dodefer   ; MSB
.852c		91 25		sta ($25),y	                sta (tmp1),y
.852e		a9 2d		lda #$2d	                lda #<defer_error
.8530		92 00		sta ($00)	                sta (cp)
.8532		e6 00		inc $00		                inc cp
.8534		d0 02		bne $8538	                bne +
.8536		e6 01		inc $01		                inc cp+1
.8538						+
.8538		a9 d6		lda #$d6	                lda #>defer_error
.853a		92 00		sta ($00)	                sta (cp)
.853c		e6 00		inc $00		                inc cp
.853e		d0 02		bne $8542	                bne +
.8540		e6 01		inc $01		                inc cp+1
.8542						+
.8542		20 0a 84	jsr $840a	                jsr adjust_z    ; adjust header to correct length
.8545		60		rts		z_defer:        rts
.8546						xt_defer_fetch:
.8546		20 b2 92	jsr $92b2	                jsr xt_to_body
.8549		20 19 88	jsr $8819	                jsr xt_fetch
.854c		60		rts		z_defer_fetch:  rts
.854d						xt_defer_store:
.854d		20 b2 92	jsr $92b2	                jsr xt_to_body
.8550		20 2c 92	jsr $922c	                jsr xt_store
.8553		60		rts		z_defer_store:  rts
.8554						xt_depth:
.8554		a9 78		lda #$78	                lda #dsp0
.8556		86 1e		stx $1e		                stx tmpdsp
.8558		38		sec		                sec
.8559		e5 1e		sbc $1e		                sbc tmpdsp
.855b		4a		lsr a		                lsr
.855c		ca		dex		                dex
.855d		ca		dex		                dex
.855e		95 00		sta $00,x	                sta 0,x
.8560		74 01		stz $01,x	                stz 1,x
.8562		60		rts		z_depth:        rts
.8563						xt_question_do:
.8563		ca		dex		                dex
.8564		ca		dex		                dex
.8565		ca		dex		                dex
.8566		ca		dex		                dex
.8567		a9 a3		lda #$a3	                lda #<question_do_runtime
.8569		95 02		sta $02,x	                sta 2,x
.856b		a9 85		lda #$85	                lda #>question_do_runtime
.856d		95 03		sta $03,x	                sta 3,x
.856f		a9 10		lda #$10	                lda #question_do_runtime_size
.8571		95 00		sta $00,x	                sta 0,x
.8573		74 01		stz $01,x	                stz 1,x
.8575		20 1c 97	jsr $971c	                jsr cmpl_by_limit
.8578		90 0b		bcc $8585	                bcc _native
.857a		20 1a 89	jsr $891a	                jsr xt_here
.857d		20 04 9e	jsr $9e04	                jsr xt_zero
.8580		20 cf 83	jsr $83cf	                jsr xt_comma
.8583		80 08		bra $858d	                bra do_common
.8585						_native:
.8585		20 ae 97	jsr $97ae	                jsr cmpl_jump_later
.8588		80 03		bra $858d	                bra do_common
.858a						xt_do:
.858a		20 04 9e	jsr $9e04	                jsr xt_zero             ; push 0 TOS
.858d						do_common:
.858d		ca		dex		                dex
.858e		ca		dex		                dex
.858f		a5 21		lda $21		                lda loopleave
.8591		95 00		sta $00,x	                sta 0,x
.8593		a5 22		lda $22		                lda loopleave+1
.8595		95 01		sta $01,x	                sta 1,x
.8597		64 22		stz $22		                stz loopleave+1
.8599		a0 85		ldy #$85	                ldy #>do_runtime
.859b		a9 bb		lda #$bb	                lda #<do_runtime
.859d		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.85a0		4c 1a 89	jmp $891a	                jmp xt_here
.85a3						z_question_do:
.85a3						z_do:
.85a3						question_do_runtime:
.85a3		b5 00		lda $00,x	                lda 0,x
.85a5		d5 02		cmp $02,x	                cmp 2,x
.85a7		d0 0d		bne $85b6	                bne _begin
.85a9		b5 01		lda $01,x	                lda 1,x
.85ab		d5 03		cmp $03,x	                cmp 3,x
.85ad		d0 07		bne $85b6	                bne _begin
.85af		e8		inx		                inx                     ; drop loop limits and skip
.85b0		e8		inx		                inx
.85b1		e8		inx		                inx
.85b2		e8		inx		                inx
=16						question_do_runtime_size = * - question_do_runtime
.85b3		a9 00		lda #$00	                lda #0
>85b5		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.85b6		a9 01		lda #$01	_begin:         lda #1
.85b8		4c 47 98	jmp $9847	                jmp zbranch_runtime
.85bb						do_runtime:
.85bb		a4 1f		ldy $1f		                ldy loopctrl
.85bd		30 05		bmi $85c4	                bmi +                   ; is this the first LCB?
.85bf		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.85c1		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.85c4						+
.85c4		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.85c5		c8		iny		                iny
.85c6		c8		iny		                iny
.85c7		c8		iny		                iny
.85c8		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.85ca		38		sec		                sec
.85cb		a9 00		lda #$00	                lda #0
.85cd		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.85cf		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.85d2		a9 80		lda #$80	                lda #$80
.85d4		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.85d6		99 03 01	sta $0103,y	                sta loopfufa+1,y
.85d9		18		clc		                clc
.85da		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.85dc		79 02 01	adc $0102,y	                adc loopfufa,y
.85df		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.85e1		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.85e3		79 03 01	adc $0103,y	                adc loopfufa+1,y
.85e6		99 01 01	sta $0101,y	                sta loopindex+1,y
.85e9		e8		inx		                inx                 ; clean up the stack
.85ea		e8		inx		                inx
.85eb		e8		inx		                inx
.85ec		e8		inx		                inx
.85ed		60		rts		                rts
.85ee						xt_does:
.85ee		a0 85		ldy #$85	                ldy #>does_runtime
.85f0		a9 fd		lda #$fd	                lda #<does_runtime
.85f2		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.85f5		a0 d6		ldy #$d6	                ldy #>dodoes
.85f7		a9 32		lda #$32	                lda #<dodoes
.85f9		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.85fc		60		rts		z_does:         rts
.85fd						does_runtime:
.85fd		7a		ply		                ply             ; LSB
.85fe		68		pla		                pla             ; MSB
.85ff		c8		iny		                iny
.8600		d0 01		bne $8603	                bne +
.8602		1a		inc a		                ina
.8603						+
.8603		84 25		sty $25		                sty tmp1
.8605		85 26		sta $26		                sta tmp1+1
.8607		20 f4 d6	jsr $d6f4	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.860a		a5 02		lda $02		                lda dp
.860c		18		clc		                clc
.860d		69 04		adc #$04	                adc #4
.860f		85 27		sta $27		                sta tmp2
.8611		a5 03		lda $03		                lda dp+1
.8613		69 00		adc #$00	                adc #0          ; we only care about the carry
.8615		85 28		sta $28		                sta tmp2+1
.8617		b2 27		lda ($27)	                lda (tmp2)
.8619		18		clc		                clc
.861a		69 01		adc #$01	                adc #1
.861c		85 29		sta $29		                sta tmp3
.861e		a0 01		ldy #$01	                ldy #1
.8620		b1 27		lda ($27),y	                lda (tmp2),y
.8622		69 00		adc #$00	                adc #0          ; we only care about the carry
.8624		85 2a		sta $2a		                sta tmp3+1
.8626		a5 25		lda $25		                lda tmp1        ; LSB
.8628		92 29		sta ($29)	                sta (tmp3)
.862a		a5 26		lda $26		                lda tmp1+1
.862c		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.862e		60		rts		                rts
.862f						xt_dot:
.862f		20 9d d7	jsr $d79d	                jsr underflow_1
.8632		20 9f 86	jsr $869f	                jsr xt_dup                      ; ( n n )
.8635		20 d1 80	jsr $80d1	                jsr xt_abs                      ; ( n u )
.8638		20 04 9e	jsr $9e04	                jsr xt_zero                     ; ( n u 0 )
.863b		20 ce 89	jsr $89ce	                jsr xt_less_number_sign         ; ( n u 0 )
.863e		20 ab 8c	jsr $8cab	                jsr xt_number_sign_s            ; ( n ud )
.8641		20 83 8f	jsr $8f83	                jsr xt_rot                      ; ( ud n )
.8644		20 42 91	jsr $9142	                jsr xt_sign                     ; ( ud )
.8647		20 89 8c	jsr $8c89	                jsr xt_number_sign_greater      ; ( addr u )
.864a		20 c9 94	jsr $94c9	                jsr xt_type
.864d		20 bd 91	jsr $91bd	                jsr xt_space
.8650		60		rts		z_dot:          rts
.8651						xt_dot_paren:
.8651		ca		dex		                dex
.8652		ca		dex		                dex
.8653		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8655		95 00		sta $00,x	                sta 0,x
.8657		74 01		stz $01,x	                stz 1,x
.8659		20 a4 8d	jsr $8da4	                jsr xt_parse
.865c		20 c9 94	jsr $94c9	                jsr xt_type
.865f		60		rts		z_dot_paren:    rts
.8660						xt_dot_quote:
.8660		20 cc 8f	jsr $8fcc	                jsr xt_s_quote
.8663		a0 94		ldy #$94	                ldy #>xt_type
.8665		a9 c9		lda #$c9	                lda #<xt_type
.8667		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.866a		60		rts		z_dot_quote:    rts
.866b						xt_dot_r:
.866b		20 a2 d7	jsr $d7a2	                jsr underflow_2
.866e		20 80 93	jsr $9380	                jsr xt_to_r
.8671		20 9f 86	jsr $869f	                jsr xt_dup
.8674		20 d1 80	jsr $80d1	                jsr xt_abs
.8677		20 04 9e	jsr $9e04	                jsr xt_zero
.867a		20 ce 89	jsr $89ce	                jsr xt_less_number_sign
.867d		20 ab 8c	jsr $8cab	                jsr xt_number_sign_s
.8680		20 83 8f	jsr $8f83	                jsr xt_rot
.8683		20 42 91	jsr $9142	                jsr xt_sign
.8686		20 89 8c	jsr $8c89	                jsr xt_number_sign_greater
.8689		20 e6 8e	jsr $8ee6	                jsr xt_r_from
.868c		20 fd 8c	jsr $8cfd	                jsr xt_over
.868f		20 dc 8b	jsr $8bdc	                jsr xt_minus
.8692		20 c3 91	jsr $91c3	                jsr xt_spaces
.8695		20 c9 94	jsr $94c9	                jsr xt_type
.8698		60		rts		z_dot_r:        rts
.8699						xt_drop:
.8699		20 9d d7	jsr $d79d	                jsr underflow_1
.869c		e8		inx		                inx
.869d		e8		inx		                inx
.869e		60		rts		z_drop:         rts
.869f						xt_dup:
.869f		20 9d d7	jsr $d79d	                jsr underflow_1
.86a2		ca		dex		                dex
.86a3		ca		dex		                dex
.86a4		b5 02		lda $02,x	                lda 2,x         ; LSB
.86a6		95 00		sta $00,x	                sta 0,x
.86a8		b5 03		lda $03,x	                lda 3,x         ; MSB
.86aa		95 01		sta $01,x	                sta 1,x
.86ac		60		rts		z_dup:          rts
.86ad						xt_else:
.86ad						xt_endof:
.86ad		20 ae 97	jsr $97ae	                jsr cmpl_jump_later
.86b0		20 42 92	jsr $9242	                jsr xt_swap         ; ( target orig )
.86b3						xt_then:
.86b3		20 1a 89	jsr $891a	                jsr xt_here
.86b6		20 42 92	jsr $9242	                jsr xt_swap
.86b9		20 2c 92	jsr $922c	                jsr xt_store
.86bc						z_else:
.86bc						z_endof:
.86bc		60		rts		z_then:         rts
.86bd						xt_emit:
.86bd		20 9d d7	jsr $d79d	                jsr underflow_1
.86c0		b5 00		lda $00,x	                lda 0,x
.86c2		e8		inx		                inx
.86c3		e8		inx		                inx
.86c4						emit_a:
.86c4		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.86c7						z_emit:
.86c7						xt_endcase:
.86c7		a0 86		ldy #$86	                ldy #>xt_drop
.86c9		a9 99		lda #$99	                lda #<xt_drop
.86cb		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.86ce						_endcase_loop:
.86ce		b5 00		lda $00,x	                lda 0,x
.86d0		15 01		ora $01,x	                ora 1,x
.86d2		f0 05		beq $86d9	                beq _done
.86d4		20 b3 86	jsr $86b3	                jsr xt_then
.86d7		80 f5		bra $86ce	                bra _endcase_loop
.86d9						_done:
.86d9		e8		inx		                inx
.86da		e8		inx		                inx
.86db		60		rts		z_endcase:      rts
.86dc						xt_environment_q:
.86dc		20 9d d7	jsr $d79d	                jsr underflow_1
.86df		a0 00		ldy #$00	                ldy #00                 ; counter for table
.86e1		5a		phy		                phy
.86e2						_table_loop:
.86e2		20 bf 93	jsr $93bf	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.86e5		ca		dex		                dex
.86e6		ca		dex		                dex                     ; ( addr u addr u ? )
.86e7		b9 59 87	lda $8759,y	                lda env_table_single,y
.86ea		95 00		sta $00,x	                sta 0,x
.86ec		c8		iny		                iny
.86ed		b9 59 87	lda $8759,y	                lda env_table_single,y
.86f0		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.86f2		c8		iny		                iny
.86f3		15 00		ora $00,x	                ora 0,x
.86f5		f0 4d		beq $8744	                beq _table_done
.86f7		5a		phy		                phy                     ; save Y, which is used by COUNT
.86f8		20 28 84	jsr $8428	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.86fb		20 cb 9f	jsr $9fcb	                jsr xt_compare          ; ( addr u f )
.86fe		7a		ply		                ply
.86ff		b5 00		lda $00,x	                lda 0,x
.8701		15 01		ora $01,x	                ora 1,x
.8703		f0 04		beq $8709	                beq _got_result
.8705		e8		inx		                inx                     ; DROP, now ( addr u )
.8706		e8		inx		                inx
.8707		80 d9		bra $86e2	                bra _table_loop
.8709						_got_result:
.8709		e8		inx		                inx                     ; drop flag, now ( addr u )
.870a		e8		inx		                inx
.870b		88		dey		                dey                     ; go back to index we had
.870c		88		dey		                dey
.870d		68		pla		                pla
.870e		d0 0d		bne $871d	                bne _double_result
.8710		b9 77 87	lda $8777,y	                lda env_results_single,y
.8713		95 02		sta $02,x	                sta 2,x
.8715		c8		iny		                iny
.8716		b9 77 87	lda $8777,y	                lda env_results_single,y
.8719		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.871b		80 1f		bra $873c	                bra _set_flag
.871d						_double_result:
.871d		ca		dex		                dex                     ; ( addr u ? )
.871e		ca		dex		                dex
.871f		98		tya		                tya
.8720		38		sec		                sec
.8721		e9 18		sbc #$18	                sbc #24
.8723		0a		asl a		                asl
.8724		a8		tay		                tay
.8725		b9 8d 87	lda $878d,y	                lda env_results_double,y
.8728		95 02		sta $02,x	                sta 2,x
.872a		c8		iny		                iny
.872b		b9 8d 87	lda $878d,y	                lda env_results_double,y
.872e		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8730		c8		iny		                iny
.8731		b9 8d 87	lda $878d,y	                lda env_results_double,y
.8734		95 04		sta $04,x	                sta 4,x
.8736		c8		iny		                iny
.8737		b9 8d 87	lda $878d,y	                lda env_results_double,y
.873a		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.873c						_set_flag:
.873c		a9 ff		lda #$ff	                lda #$FF
.873e		95 00		sta $00,x	                sta 0,x
.8740		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8742		80 14		bra $8758	                bra _done
.8744						_table_done:
.8744		68		pla		                pla
.8745		d0 09		bne $8750	                bne _no_match
.8747		1a		inc a		                ina
.8748		48		pha		                pha
.8749		8a		txa		                txa
.874a		18		clc		                clc
.874b		69 06		adc #$06	                adc #6                  ; skip six bytes
.874d		aa		tax		                tax                     ; ( addr u )
.874e		80 92		bra $86e2	                bra _table_loop
.8750						_no_match:
.8750		8a		txa		                txa
.8751		18		clc		                clc
.8752		69 0a		adc #$0a	                adc #10
.8754		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8755		20 04 9e	jsr $9e04	                jsr xt_false
.8758						_done:
.8758						z_environment_q:
.8758		60		rts		                rts
.8759						env_table_single:
>8759		85 d5 95 d5 9b d5 a0 d5		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8761		b2 d5
>8763		ba d5 c3 d5 c9 d5 cf d5		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>876b		e2 d5 ee d5 00 00		        .word envs_sc, envs_wl, 0000
.8771						env_table_double:
>8771		f8 d5 fe d5 00 00		        .word envs_max_d, envs_max_ud, 0000
.8777						env_results_single:
>8777		ff 00				        .word $00FF     ; /COUNTED-STRING
>8779		ff 00				        .word $00FF     ; /HOLD
>877b		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>877d		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>877f		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8781		ff 00				        .word $00FF     ; MAX-CHAR
>8783		ff 7f				        .word $7FFF     ; MAX-N
>8785		ff ff				        .word $FFFF     ; MAX-U
>8787		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8789		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>878b		09 00				        .word $0009     ; WORDLISTS
.878d						env_results_double:
>878d		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8791		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8795						xt_equal:
.8795		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8798		b5 00		lda $00,x	                lda 0,x                 ; LSB
.879a		d5 02		cmp $02,x	                cmp 2,x
.879c		d0 0a		bne $87a8	                bne _false
.879e		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87a0		d5 03		cmp $03,x	                cmp 3,x
.87a2		d0 04		bne $87a8	                bne _false
.87a4		a9 ff		lda #$ff	                lda #$FF
.87a6		80 02		bra $87aa	                bra _done
.87a8		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.87aa		95 02		sta $02,x	_done:          sta 2,x
.87ac		95 03		sta $03,x	                sta 3,x
.87ae		e8		inx		                inx
.87af		e8		inx		                inx
.87b0		60		rts		z_equal:        rts
.87b1						xt_blank:
.87b1		ca		dex		                dex
.87b2		ca		dex		                dex
.87b3		a9 20		lda #$20	                lda #AscSP
.87b5		95 00		sta $00,x	                sta 0,x
.87b7		74 01		stz $01,x	                stz 1,x
.87b9		80 06		bra $87c1	                bra xt_fill     ; skip over code for ERASE
.87bb						xt_erase:
.87bb		ca		dex		                dex
.87bc		ca		dex		                dex
.87bd		74 00		stz $00,x	                stz 0,x
.87bf		74 01		stz $01,x	                stz 1,x
.87c1						xt_fill:
.87c1		20 a7 d7	jsr $d7a7	                jsr underflow_3
.87c4		b5 04		lda $04,x	                lda 4,x         ; LSB
.87c6		85 25		sta $25		                sta tmp1
.87c8		b5 05		lda $05,x	                lda 5,x
.87ca		85 26		sta $26		                sta tmp1+1
.87cc		b5 02		lda $02,x	                lda 2,x
.87ce		85 27		sta $27		                sta tmp2
.87d0		b5 03		lda $03,x	                lda 3,x
.87d2		85 28		sta $28		                sta tmp2+1
.87d4		b5 00		lda $00,x	                lda 0,x
.87d6		a8		tay		                tay
.87d7						_loop:
.87d7		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.87d9		c5 26		cmp $26		                cmp tmp1+1
.87db		90 21		bcc $87fe	                bcc _done               ; RAM_END < TMP1, so leave
.87dd		d0 06		bne $87e5	                bne _check_counter      ; RAM_END is not smaller and not equal
.87df		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.87e1		c5 25		cmp $25		                cmp tmp1
.87e3		90 19		bcc $87fe	                bcc _done               ; RAM_END < TMP1, so leave
.87e5						_check_counter:
.87e5		a5 27		lda $27		                lda tmp2
.87e7		05 28		ora $28		                ora tmp2+1
.87e9		f0 13		beq $87fe	                beq _done
.87eb		98		tya		                tya
.87ec		92 25		sta ($25)	                sta (tmp1)
.87ee		a5 27		lda $27		                lda tmp2
.87f0		d0 02		bne $87f4	                bne +
.87f2		c6 28		dec $28		                dec tmp2+1
.87f4		c6 27		dec $27		+               dec tmp2
.87f6		e6 25		inc $25		                inc tmp1
.87f8		d0 dd		bne $87d7	                bne _loop
.87fa		e6 26		inc $26		                inc tmp1+1
.87fc		80 d9		bra $87d7	                bra _loop
.87fe						_done:
.87fe		8a		txa		                txa
.87ff		18		clc		                clc
.8800		69 06		adc #$06	                adc #6
.8802		aa		tax		                tax
.8803						z_blank:
.8803						z_erase:
.8803		60		rts		z_fill:         rts
.8804						xt_execute:
.8804		20 9d d7	jsr $d79d	                jsr underflow_1
.8807		20 0b 88	jsr $880b	                jsr doexecute   ; do not combine to JMP (native coding)
.880a		60		rts		z_execute:      rts
.880b						doexecute:
.880b		b5 00		lda $00,x	                lda 0,x
.880d		85 04		sta $04		                sta ip
.880f		b5 01		lda $01,x	                lda 1,x
.8811		85 05		sta $05		                sta ip+1
.8813		e8		inx		                inx
.8814		e8		inx		                inx
.8815		6c 04 00	jmp ($0004)	                jmp (ip)
.8818						xt_exit:
.8818		60		rts		                rts             ; keep before z_exit
.8819						z_exit:
.8819						xt_fetch:
.8819		20 9d d7	jsr $d79d	                jsr underflow_1
.881c		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.881e		a8		tay		                tay
.881f		f6 00		inc $00,x	                inc 0,x
.8821		d0 02		bne $8825	                bne +
.8823		f6 01		inc $01,x	                inc 1,x
.8825						+
.8825		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8827		95 01		sta $01,x	                sta 1,x
.8829		94 00		sty $00,x	                sty 0,x
.882b		60		rts		z_fetch:        rts
.882c						xt_find:
.882c		20 9d d7	jsr $d79d	                jsr underflow_1
.882f		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8831		48		pha		                pha
.8832		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8834		48		pha		                pha
.8835		20 28 84	jsr $8428	                jsr xt_count            ; ( caddr -- addr u )
.8838		20 03 9b	jsr $9b03	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.883b		b5 00		lda $00,x	                lda 0,x
.883d		15 01		ora $01,x	                ora 1,x
.883f		d0 0b		bne $884c	                bne _found_word
.8841		20 04 9e	jsr $9e04	                jsr xt_false            ; ( 0 0 )
.8844		68		pla		                pla                     ; LSB of address
.8845		95 02		sta $02,x	                sta 2,x
.8847		68		pla		                pla
.8848		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.884a		80 27		bra $8873	                bra _done               ; ( addr 0 )
.884c						_found_word:
.884c		68		pla		                pla
.884d		68		pla		                pla
.884e		20 9f 86	jsr $869f	                jsr xt_dup              ; ( nt nt )
.8851		20 41 9c	jsr $9c41	                jsr xt_name_to_int      ; ( nt xt )
.8854		20 42 92	jsr $9242	                jsr xt_swap             ; ( xt nt )
.8857		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8859		f6 00		inc $00,x	                inc 0,x
.885b		d0 02		bne $885f	                bne +
.885d		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.885f						+
.885f		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8861		29 04		and #$04	                and #IM
.8863		d0 08		bne $886d	                bne _immediate          ; bit set, we're immediate
.8865		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8867		95 00		sta $00,x	                sta 0,x
.8869		95 01		sta $01,x	                sta 1,x
.886b		80 06		bra $8873	                bra _done
.886d						_immediate:
.886d		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.886f		95 00		sta $00,x	                sta 0,x
.8871		74 01		stz $01,x	                stz 1,x
.8873						_done:
.8873		60		rts		z_find:         rts
.8874						xt_fm_slash_mod:
.8874		20 a7 d7	jsr $d7a7	                jsr underflow_3
.8877		64 27		stz $27		                stz tmp2        ; default: n is positive
.8879		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.887b		10 0e		bpl $888b	                bpl _check_d
.887d		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.887f		20 17 8c	jsr $8c17	                jsr xt_negate   ; NEGATE
.8882		20 80 93	jsr $9380	                jsr xt_to_r     ; >R
.8885		20 72 9e	jsr $9e72	                jsr xt_dnegate  ; DNEGATE
.8888		20 e6 8e	jsr $8ee6	                jsr xt_r_from   ; R>
.888b						_check_d:
.888b		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.888d		10 0d		bpl $889c	                bpl _multiply
.888f		18		clc		                clc
.8890		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.8892		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.8894		95 02		sta $02,x	                sta 2,x
.8896		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8898		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.889a		95 03		sta $03,x	                sta 3,x
.889c						_multiply:
.889c		20 4e 95	jsr $954e	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.889f		a5 27		lda $27		                lda tmp2
.88a1		f0 07		beq $88aa	                beq _done
.88a3		e8		inx		                inx             ; pretend that we SWAP
.88a4		e8		inx		                inx
.88a5		20 17 8c	jsr $8c17	                jsr xt_negate
.88a8		ca		dex		                dex
.88a9		ca		dex		                dex
.88aa						_done:
.88aa		60		rts		z_fm_slash_mod: rts
.88ab						load_evaluate:
.88ab		a9 ff		lda #$ff	                lda #$FF
.88ad		85 25		sta $25		                sta tmp1
.88af		80 11		bra $88c2	                bra load_evaluate_start
.88b1						xt_evaluate:
.88b1		20 a2 d7	jsr $d7a2	                jsr underflow_2
.88b4		64 25		stz $25		                stz tmp1
.88b6		b5 00		lda $00,x	                lda 0,x
.88b8		15 01		ora $01,x	                ora 1,x
.88ba		d0 06		bne $88c2	                bne evaluate_got_work
.88bc		e8		inx		                inx
.88bd		e8		inx		                inx
.88be		e8		inx		                inx
.88bf		e8		inx		                inx
.88c0		80 42		bra $8904	                bra evaluate_done
.88c2						load_evaluate_start:
.88c2						evaluate_got_work:
.88c2		a0 05		ldy #$05	                ldy #blk_offset+1
.88c4		b1 08		lda ($08),y	                lda (up),y
.88c6		48		pha		                pha
.88c7		88		dey		                dey
.88c8		b1 08		lda ($08),y	                lda (up),y
.88ca		48		pha		                pha
.88cb		a5 25		lda $25		                lda tmp1
.88cd		d0 05		bne $88d4	                bne _nozero
.88cf		91 08		sta ($08),y	                sta (up),y
.88d1		c8		iny		                iny
.88d2		91 08		sta ($08),y	                sta (up),y
.88d4						_nozero:
.88d4		20 a5 9b	jsr $9ba5	                jsr xt_input_to_r
.88d7		a9 ff		lda #$ff	                lda #$FF
.88d9		85 0a		sta $0a		                sta insrc
.88db		85 0b		sta $0b		                sta insrc+1
.88dd		64 10		stz $10		                stz toin
.88df		64 11		stz $11		                stz toin+1
.88e1		b5 00		lda $00,x	                lda 0,x
.88e3		85 0e		sta $0e		                sta ciblen
.88e5		b5 01		lda $01,x	                lda 1,x
.88e7		85 0f		sta $0f		                sta ciblen+1
.88e9		b5 02		lda $02,x	                lda 2,x
.88eb		85 0c		sta $0c		                sta cib
.88ed		b5 03		lda $03,x	                lda 3,x
.88ef		85 0d		sta $0d		                sta cib+1
.88f1		e8		inx		                inx             ; A clean stack is a clean mind
.88f2		e8		inx		                inx
.88f3		e8		inx		                inx
.88f4		e8		inx		                inx
.88f5		20 1a d7	jsr $d71a	                jsr interpret   ; ( -- )
.88f8		20 b2 9d	jsr $9db2	                jsr xt_r_to_input
.88fb		a0 04		ldy #$04	                ldy #blk_offset
.88fd		68		pla		                pla
.88fe		91 08		sta ($08),y	                sta (up),y
.8900		c8		iny		                iny
.8901		68		pla		                pla
.8902		91 08		sta ($08),y	                sta (up),y
.8904						evaluate_done:
.8904		60		rts		z_evaluate:     rts
.8905						xt_greater_than:
.8905		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8908		a0 00		ldy #$00	                ldy #0          ; default false
.890a		20 db d6	jsr $d6db	                jsr compare_16bit
.890d		f0 03		beq $8912	                beq _false
.890f		10 01		bpl $8912	                bpl _false
.8911		88		dey		                dey
.8912						_false:
.8912		98		tya		                tya
.8913		e8		inx		                inx
.8914		e8		inx		                inx
.8915		95 00		sta $00,x	                sta 0,x
.8917		95 01		sta $01,x	                sta 1,x
.8919		60		rts		z_greater_than: rts
.891a						xt_here:
.891a						xt_begin:
.891a						xt_asm_arrow:
.891a		ca		dex		                dex
.891b		ca		dex		                dex
.891c		a5 00		lda $00		                lda cp
.891e		95 00		sta $00,x	                sta 0,x
.8920		a5 01		lda $01		                lda cp+1
.8922		95 01		sta $01,x	                sta 1,x
.8924						z_here:
.8924						z_begin:
.8924						z_asm_arrow:
.8924		60		rts		                rts
.8925						xt_hex:
.8925		a9 10		lda #$10	                lda #16
.8927		85 18		sta $18		                sta base
.8929		64 19		stz $19		                stz base+1              ; paranoid
.892b		60		rts		z_hex:          rts
.892c						xt_hold:
.892c		20 9d d7	jsr $d79d	                jsr underflow_1
.892f		a5 2b		lda $2b		                lda tohold
.8931		d0 02		bne $8935	                bne +
.8933		c6 2c		dec $2c		                dec tohold+1
.8935						+
.8935		c6 2b		dec $2b		                dec tohold
.8937		b5 00		lda $00,x	                lda 0,x
.8939		92 2b		sta ($2b)	                sta (tohold)
.893b		e8		inx		                inx
.893c		e8		inx		                inx
.893d		60		rts		z_hold:         rts
.893e						xt_i:
.893e		ca		dex		                dex
.893f		ca		dex		                dex
.8940		a4 1f		ldy $1f		                ldy loopctrl
.8942		38		sec		                sec
.8943		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.8945		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8948		95 00		sta $00,x	                sta 0,x
.894a		b9 01 01	lda $0101,y	                lda loopindex+1,y
.894d		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8950		95 01		sta $01,x	                sta 1,x
.8952		60		rts		z_i:            rts
.8953						xt_if:
.8953		20 ca 97	jsr $97ca	                jsr cmpl_0branch_later
.8956		60		rts		z_if:           rts
.8957						xt_immediate:
.8957		20 f4 d6	jsr $d6f4	                jsr current_to_dp
.895a		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.895c		b1 02		lda ($02),y	                lda (dp),y
.895e		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.8960		91 02		sta ($02),y	                sta (dp),y
.8962		60		rts		z_immediate:    rts
.8963						xt_invert:
.8963		20 9d d7	jsr $d79d	                jsr underflow_1
.8966		a9 ff		lda #$ff	                lda #$FF
.8968		55 00		eor $00,x	                eor 0,x         ; LSB
.896a		95 00		sta $00,x	                sta 0,x
.896c		a9 ff		lda #$ff	                lda #$FF
.896e		55 01		eor $01,x	                eor 1,x         ; MSB
.8970		95 01		sta $01,x	                sta 1,x
.8972		60		rts		z_invert:       rts
.8973						xt_is:
.8973		a5 1a		lda $1a		                lda state
.8975		05 1b		ora $1b		                ora state+1
.8977		f0 0c		beq $8985	                beq _interpreting
.8979		20 16 83	jsr $8316	                jsr xt_bracket_tick
.897c		a0 85		ldy #$85	                ldy #>xt_defer_store
.897e		a9 4d		lda #$4d	                lda #<xt_defer_store
.8980		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.8983		80 06		bra $898b	                bra _done
.8985						_interpreting:
.8985		20 56 92	jsr $9256	                jsr xt_tick
.8988		20 4d 85	jsr $854d	                jsr xt_defer_store
.898b						_done:
.898b		60		rts		z_is:           rts
.898c						xt_j:
.898c		ca		dex		                dex                 ; make space on the stack
.898d		ca		dex		                dex
.898e		a5 1f		lda $1f		                lda loopctrl
.8990		38		sec		                sec
.8991		e9 04		sbc #$04	                sbc #4
.8993		a8		tay		                tay
.8994		38		sec		                sec
.8995		b9 00 01	lda $0100,y	                lda loopindex,y
.8998		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.899b		95 00		sta $00,x	                sta 0,x
.899d		b9 01 01	lda $0101,y	                lda loopindex+1,y
.89a0		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.89a3		95 01		sta $01,x	                sta 1,x
.89a5		60		rts		z_j:            rts
.89a6						xt_key:
.89a6		20 b0 89	jsr $89b0	                jsr key_a               ; returns char in A
.89a9		ca		dex		                dex
.89aa		ca		dex		                dex
.89ab		95 00		sta $00,x	                sta 0,x
.89ad		74 01		stz $01,x	                stz 1,x
.89af		60		rts		z_key:          rts
.89b0						key_a:
.89b0		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.89b3						xt_leave:
.89b3		a5 21		lda $21		                lda loopleave
.89b5		a4 22		ldy $22		                ldy loopleave+1
.89b7		20 92 97	jsr $9792	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.89ba		38		sec		                sec
.89bb		a5 00		lda $00		                lda cp
.89bd		e9 02		sbc #$02	                sbc #2
.89bf		85 21		sta $21		                sta loopleave
.89c1		a5 01		lda $01		                lda cp+1
.89c3		b0 01		bcs $89c6	                bcs +
.89c5		3a		dec a		                dea
.89c6		85 22		sta $22		+               sta loopleave+1
.89c8						z_leave:
.89c8		60		rts		                rts
.89c9						xt_left_bracket:
.89c9		64 1a		stz $1a		                stz state
.89cb		64 1b		stz $1b		                stz state+1
.89cd		60		rts		z_left_bracket: rts
.89ce						xt_less_number_sign:
.89ce		20 0b 8d	jsr $8d0b	                jsr xt_pad      ; ( addr )
.89d1		b5 00		lda $00,x	                lda 0,x
.89d3		85 2b		sta $2b		                sta tohold
.89d5		b5 01		lda $01,x	                lda 1,x
.89d7		85 2c		sta $2c		                sta tohold+1
.89d9		e8		inx		                inx
.89da		e8		inx		                inx
.89db						z_less_number_sign:
.89db		60		rts		                rts
.89dc						xt_less_than:
.89dc		20 a2 d7	jsr $d7a2	                jsr underflow_2
.89df		a0 00		ldy #$00	                ldy #0          ; default false
.89e1		20 db d6	jsr $d6db	                jsr compare_16bit
.89e4		f0 03		beq $89e9	                beq _false
.89e6		30 01		bmi $89e9	                bmi _false
.89e8		88		dey		                dey
.89e9						_false:
.89e9		98		tya		                tya
.89ea		e8		inx		                inx
.89eb		e8		inx		                inx
.89ec		95 00		sta $00,x	                sta 0,x
.89ee		95 01		sta $01,x	                sta 1,x
.89f0		60		rts		z_less_than:    rts
.89f1						xt_literal:
.89f1		20 9d d7	jsr $d79d	                jsr underflow_1
.89f4		a9 0a		lda #$0a	                lda # z_template_push_tos - template_push_tos
.89f6		20 b8 97	jsr $97b8	                jsr check_nc_limit
.89f9		90 0c		bcc $8a07	                bcc _inline
.89fb		a0 8a		ldy #$8a	                ldy #>literal_runtime
.89fd		a9 39		lda #$39	                lda #<literal_runtime
.89ff		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.8a02		20 cf 83	jsr $83cf	                jsr xt_comma
.8a05		80 27		bra $8a2e	                bra z_literal
.8a07						_inline:
.8a07		a9 94		lda #$94	                lda #$94        ; sty zp,x
.8a09		b4 01		ldy $01,x	                ldy 1,x
.8a0b		d0 02		bne $8a0f	                bne +
.8a0d		a9 74		lda #$74	                lda #$74        ; stz zp,x
.8a0f						+
.8a0f		48		pha		                pha
.8a10		b5 00		lda $00,x	                lda 0,x
.8a12		48		pha		                pha
.8a13		98		tya		                tya             ; Y has the MSB
.8a14		f0 03		beq $8a19	                beq +
.8a16		48		pha		                pha
.8a17		a9 02		lda #$02	                lda #2
.8a19						+
.8a19		49 02		eor #$02	                eor #2          ; invert A=0/2 to Y=2/0
.8a1b		a8		tay		                tay
.8a1c		b9 2f 8a	lda $8a2f,y	_copy:          lda template_push_tos,y
.8a1f		c9 ff		cmp #$ff	                cmp #$ff
.8a21		d0 01		bne $8a24	                bne +
.8a23		68		pla		                pla
.8a24		20 9d 97	jsr $979d	+               jsr cmpl_a
.8a27		c8		iny		                iny
.8a28		c0 0a		cpy #$0a	                cpy #z_template_push_tos - template_push_tos
.8a2a		d0 f0		bne $8a1c	                bne _copy
.8a2c		e8		inx		                inx             ; drop the literal
.8a2d		e8		inx		                inx
.8a2e		60		rts		z_literal:      rts
.8a2f						template_push_tos:
.8a2f		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8a31		a9 ff		lda #$ff	                lda #$ff
.8a33		ca		dex		                dex
.8a34		ca		dex		                dex
.8a35		95 00		sta $00,x	                sta 0,x
>8a37		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
.8a39						z_template_push_tos:
.8a39						literal_runtime:
.8a39		ca		dex		                dex
.8a3a		ca		dex		                dex
.8a3b		68		pla		                pla             ; LSB
.8a3c		85 25		sta $25		                sta tmp1
.8a3e		68		pla		                pla             ; MSB
.8a3f		85 26		sta $26		                sta tmp1+1
.8a41		a0 01		ldy #$01	                ldy #1
.8a43		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8a45		95 00		sta $00,x	                sta 0,x
.8a47		c8		iny		                iny
.8a48		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8a4a		95 01		sta $01,x	                sta 1,x
.8a4c		98		tya		                tya
.8a4d		18		clc		                clc
.8a4e		65 25		adc $25		                adc tmp1
.8a50		a8		tay		                tay
.8a51		a5 26		lda $26		                lda tmp1+1
.8a53		69 00		adc #$00	                adc #0
.8a55		48		pha		                pha
.8a56		5a		phy		                phy
.8a57		60		rts		                rts
.8a58						xt_loop:
.8a58		ca		dex		                dex
.8a59		ca		dex		                dex
.8a5a		ca		dex		                dex
.8a5b		ca		dex		                dex
.8a5c		a9 cb		lda #$cb	                lda #<loop_runtime
.8a5e		95 02		sta $02,x	                sta 2,x
.8a60		a9 8a		lda #$8a	                lda #>loop_runtime
.8a62		95 03		sta $03,x	                sta 3,x
.8a64		a9 11		lda #$11	                lda #loop_runtime_size
.8a66		95 00		sta $00,x	                sta 0,x
.8a68		74 01		stz $01,x	                stz 1,x
.8a6a		80 12		bra $8a7e	                bra xt_loop_common
.8a6c						xt_plus_loop:
.8a6c		ca		dex		                dex
.8a6d		ca		dex		                dex
.8a6e		ca		dex		                dex
.8a6f		ca		dex		                dex
.8a70		a9 e4		lda #$e4	                lda #<plus_loop_runtime
.8a72		95 02		sta $02,x	                sta 2,x
.8a74		a9 8a		lda #$8a	                lda #>plus_loop_runtime
.8a76		95 03		sta $03,x	                sta 3,x
.8a78		a9 1a		lda #$1a	                lda #plus_loop_runtime_size
.8a7a		95 00		sta $00,x	                sta 0,x
.8a7c		74 01		stz $01,x	                stz 1,x
.8a7e						xt_loop_common:
.8a7e		20 1c 97	jsr $971c	                jsr cmpl_by_limit
.8a81		90 05		bcc $8a88	                bcc _native
.8a83		20 cf 83	jsr $83cf	                jsr xt_comma
.8a86		80 03		bra $8a8b	                bra +
.8a88						_native:
.8a88		20 a6 97	jsr $97a6	                jsr cmpl_jump_tos
.8a8b						+
.8a8b		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8a8d		f0 19		beq $8aa8	                beq _noleave
.8a8f						_next:
.8a8f		a0 01		ldy #$01	                ldy #1
.8a91		b1 21		lda ($21),y	                lda (loopleave),y
.8a93		48		pha		                pha
.8a94		a5 01		lda $01		                lda cp+1
.8a96		91 21		sta ($21),y	                sta (loopleave),y
.8a98		88		dey		                dey
.8a99		b1 21		lda ($21),y	                lda (loopleave),y
.8a9b		48		pha		                pha
.8a9c		a5 00		lda $00		                lda cp
.8a9e		91 21		sta ($21),y	                sta (loopleave),y
.8aa0		68		pla		                pla
.8aa1		85 21		sta $21		                sta loopleave
.8aa3		68		pla		                pla
.8aa4		85 22		sta $22		                sta loopleave+1
.8aa6		d0 e7		bne $8a8f	                bne _next
.8aa8						_noleave:
.8aa8		b5 00		lda $00,x	                lda 0,x
.8aaa		85 21		sta $21		                sta loopleave
.8aac		b5 01		lda $01,x	                lda 1,x
.8aae		85 22		sta $22		                sta loopleave+1
.8ab0		a9 d6		lda #$d6	                lda #<xt_unloop
.8ab2		95 00		sta $00,x	                sta 0,x
.8ab4		a9 95		lda #$95	                lda #>xt_unloop
.8ab6		95 01		sta $01,x	                sta 1,x
.8ab8		20 cc 96	jsr $96cc	                jsr xt_compile_comma
.8abb		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8abd		f0 09		beq $8ac8	                beq +
.8abf		20 1a 89	jsr $891a	                jsr xt_here
.8ac2		20 42 92	jsr $9242	                jsr xt_swap
.8ac5		4c 2c 92	jmp $922c	                jmp xt_store            ; write here as ?DO jmp target and return
.8ac8		e8		inx		+               inx                     ; drop the ignored word for DO
.8ac9		e8		inx		                inx
.8aca						z_loop:
.8aca		60		rts		z_plus_loop:    rts
.8acb						loop_runtime:
.8acb		e6 20		inc $20		                inc loopidx0            ; increment the LSB of loopindex
.8acd		d0 0d		bne $8adc	                bne _repeat             ; avoid expensive test most of the time
.8acf		a4 1f		ldy $1f		                ldy loopctrl
.8ad1		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8ad4		1a		inc a		                ina
.8ad5		c9 80		cmp #$80	                cmp #$80
.8ad7		f0 06		beq $8adf	                beq _done
.8ad9		99 01 01	sta $0101,y	                sta loopindex+1,y
=17						loop_runtime_size = * - loop_runtime
.8adc						_repeat:
.8adc		a9 00		lda #$00	                lda #0
>8ade		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8adf		a9 01		lda #$01	_done:          lda #1
.8ae1		4c 47 98	jmp $9847	                jmp zbranch_runtime
.8ae4						plus_loop_runtime:
.8ae4		18		clc		                clc
.8ae5		b5 00		lda $00,x	                lda 0,x                 ; LSB of step
.8ae7		65 20		adc $20		                adc loopidx0
.8ae9		85 20		sta $20		                sta loopidx0
.8aeb		e8		inx		                inx                     ; dump step from TOS before MSB test
.8aec		e8		inx		                inx                     ; since we might skip it
.8aed		b5 ff		lda $ff,x	                lda $FF,x               ; MSB of step since 1,x == -1,x+2
.8aef		d0 02		bne $8af3	                bne _chkv               ; if it's non-zero we have to check
.8af1		90 0b		bcc $8afe	                bcc _repeat             ; but if 0 and no carry, we're good
.8af3		b8		clv		_chkv:          clv
.8af4		a4 1f		ldy $1f		                ldy loopctrl            ; get LCB offset
.8af6		79 01 01	adc $0101,y	                adc loopindex+1,y       ; MSB of index
.8af9		99 01 01	sta $0101,y	                sta loopindex+1,y       ; put MSB of index back on stack
.8afc		70 03		bvs $8b01	                bvs _done               ; skip over JMP instruction
=26						plus_loop_runtime_size = * - plus_loop_runtime
.8afe						_repeat:
.8afe		a9 00		lda #$00	                lda #0
>8b00		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8b01		a9 01		lda #$01	_done:          lda #1
.8b03		4c 47 98	jmp $9847	                jmp zbranch_runtime
.8b06						xt_lshift:
.8b06		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8b09		b5 00		lda $00,x	                lda 0,x
.8b0b		29 0f		and #$0f	                and #%00001111
.8b0d		f0 08		beq $8b17	                beq _done
.8b0f		a8		tay		                tay
.8b10						_loop:
.8b10		16 02		asl $02,x	                asl 2,x
.8b12		36 03		rol $03,x	                rol 3,x
.8b14		88		dey		                dey
.8b15		d0 f9		bne $8b10	                bne _loop
.8b17						_done:
.8b17		e8		inx		                inx
.8b18		e8		inx		                inx
.8b19		60		rts		z_lshift:       rts
.8b1a						xt_m_star:
.8b1a		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8b1d		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8b1f		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8b21		48		pha		                pha
.8b22		20 d1 80	jsr $80d1	                jsr xt_abs
.8b25		20 42 92	jsr $9242	                jsr xt_swap
.8b28		20 d1 80	jsr $80d1	                jsr xt_abs
.8b2b		20 90 95	jsr $9590	                jsr xt_um_star          ; ( d )
.8b2e		68		pla		                pla
.8b2f		10 03		bpl $8b34	                bpl _done
.8b31		20 72 9e	jsr $9e72	                jsr xt_dnegate
.8b34						_done:
.8b34		60		rts		z_m_star:       rts
.8b35						xt_marker:
.8b35		20 f4 d6	jsr $d6f4	                jsr current_to_dp
.8b38		a5 02		lda $02		                lda dp
.8b3a		48		pha		                pha
.8b3b		a5 03		lda $03		                lda dp+1
.8b3d		48		pha		                pha
.8b3e		a5 00		lda $00		                lda cp
.8b40		48		pha		                pha
.8b41		a5 01		lda $01		                lda cp+1
.8b43		48		pha		                pha
.8b44		20 42 84	jsr $8442	                jsr xt_create
.8b47		a5 00		lda $00		                lda cp          ; LSB
.8b49		38		sec		                sec
.8b4a		e9 02		sbc #$02	                sbc #2
.8b4c		85 00		sta $00		                sta cp
.8b4e		a5 01		lda $01		                lda cp+1        ; MSB
.8b50		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8b52		85 01		sta $01		                sta cp+1
.8b54		a0 8b		ldy #$8b	                ldy #>marker_runtime
.8b56		a9 73		lda #$73	                lda #<marker_runtime
.8b58		20 99 97	jsr $9799	                jsr cmpl_word
.8b5b		7a		ply		                ply                     ; MSB
.8b5c		68		pla		                pla                     ; LSB
.8b5d		20 99 97	jsr $9799	                jsr cmpl_word
.8b60		7a		ply		                ply                     ; MSB
.8b61		68		pla		                pla                     ; LSB
.8b62		20 99 97	jsr $9799	                jsr cmpl_word
.8b65		a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.8b67						_marker_loop:
.8b67		b1 08		lda ($08),y	                lda (up),y
.8b69		20 9d 97	jsr $979d	                jsr cmpl_a
.8b6c		c8		iny		                iny
.8b6d		98		tya		                tya
.8b6e		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.8b70		d0 f5		bne $8b67	                bne _marker_loop
.8b72		60		rts		z_marker:       rts
.8b73						marker_runtime:
.8b73		68		pla		                pla
.8b74		85 25		sta $25		                sta tmp1        ; LSB of address
.8b76		68		pla		                pla
.8b77		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8b79		e6 25		inc $25		                inc tmp1
.8b7b		d0 02		bne $8b7f	                bne +
.8b7d		e6 26		inc $26		                inc tmp1+1
.8b7f						+
.8b7f		a0 00		ldy #$00	                ldy #0
.8b81		b1 25		lda ($25),y	                lda (tmp1),y
.8b83		85 00		sta $00		                sta cp
.8b85		c8		iny		                iny
.8b86		b1 25		lda ($25),y	                lda (tmp1),y
.8b88		85 01		sta $01		                sta cp+1
.8b8a		c8		iny		                iny
.8b8b		b1 25		lda ($25),y	                lda (tmp1),y
.8b8d		85 02		sta $02		                sta dp
.8b8f		c8		iny		                iny
.8b90		b1 25		lda ($25),y	                lda (tmp1),y
.8b92		85 03		sta $03		                sta dp+1
.8b94		a0 04		ldy #$04	                ldy #4
.8b96						_marker_restore_loop:
.8b96		b1 25		lda ($25),y	                lda (tmp1), y
.8b98		91 08		sta ($08),y	                sta (up), y
.8b9a		c8		iny		                iny
.8b9b		98		tya		                tya
.8b9c		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.8b9e		d0 f6		bne $8b96	                bne _marker_restore_loop
.8ba0		20 07 d7	jsr $d707	                jsr dp_to_current       ; Move the CURRENT DP back.
.8ba3		60		rts		                rts
.8ba4						xt_max:
.8ba4		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8ba7		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8ba9		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8bab		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bad		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8baf		50 02		bvc $8bb3	                bvc _no_overflow
.8bb1		49 80		eor #$80	                eor #$80        ; complement negative flag
.8bb3						_no_overflow:
.8bb3		30 08		bmi $8bbd	                bmi _keep_nos
.8bb5		b5 00		lda $00,x	                lda 0,x
.8bb7		95 02		sta $02,x	                sta 2,x
.8bb9		b5 01		lda $01,x	                lda 1,x
.8bbb		95 03		sta $03,x	                sta 3,x
.8bbd						_keep_nos:
.8bbd		e8		inx		                inx
.8bbe		e8		inx		                inx
.8bbf		60		rts		z_max:          rts
.8bc0						xt_min:
.8bc0		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8bc3		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bc5		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8bc7		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bc9		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bcb		50 02		bvc $8bcf	                bvc _no_overflow
.8bcd		49 80		eor #$80	                eor #$80
.8bcf						_no_overflow:
.8bcf		10 08		bpl $8bd9	                bpl _keep_nos
.8bd1		b5 00		lda $00,x	                lda 0,x
.8bd3		95 02		sta $02,x	                sta 2,x
.8bd5		b5 01		lda $01,x	                lda 1,x
.8bd7		95 03		sta $03,x	                sta 3,x
.8bd9						_keep_nos:
.8bd9		e8		inx		                inx
.8bda		e8		inx		                inx
.8bdb		60		rts		z_min:          rts
.8bdc						xt_minus:
.8bdc		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8bdf		38		sec		                sec
.8be0		b5 02		lda $02,x	                lda 2,x         ; LSB
.8be2		f5 00		sbc $00,x	                sbc 0,x
.8be4		95 02		sta $02,x	                sta 2,x
.8be6		b5 03		lda $03,x	                lda 3,x         ; MSB
.8be8		f5 01		sbc $01,x	                sbc 1,x
.8bea		95 03		sta $03,x	                sta 3,x
.8bec		e8		inx		                inx
.8bed		e8		inx		                inx
.8bee		60		rts		z_minus:        rts
.8bef						xt_mod:
.8bef		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8bf2		20 5c 91	jsr $915c	                jsr xt_slash_mod
.8bf5		e8		inx		                inx             ; DROP
.8bf6		e8		inx		                inx
.8bf7						z_mod:
.8bf7		60		rts		                rts
.8bf8						xt_move:
.8bf8		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8bfa		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8bfc		f0 05		beq $8c03	                beq _lsb                ; wasn't helpful, move to LSB
.8bfe		b0 0e		bcs $8c0e	                bcs _to_move_up         ; we want CMOVE>
.8c00		4c 55 9f	jmp $9f55	                jmp xt_cmove            ; JSR/RTS
.8c03						_lsb:
.8c03		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8c05		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8c07		f0 08		beq $8c11	                beq _equal              ; LSB is equal as well
.8c09		b0 03		bcs $8c0e	                bcs _to_move_up         ; we want CMOVE>
.8c0b		4c 55 9f	jmp $9f55	                jmp xt_cmove            ; JSR/RTS
.8c0e						_to_move_up:
.8c0e		4c 90 9f	jmp $9f90	                jmp xt_cmove_up         ; JSR/RTS
.8c11						_equal:
.8c11		8a		txa		                txa
.8c12		18		clc		                clc
.8c13		69 06		adc #$06	                adc #6
.8c15		aa		tax		                tax
.8c16		60		rts		z_move:         rts
.8c17						xt_negate:
.8c17		20 9d d7	jsr $d79d	                jsr underflow_1
.8c1a		a9 00		lda #$00	        	lda #0
.8c1c		38		sec		                sec
.8c1d		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8c1f		95 00		sta $00,x	                sta 0,x
.8c21		a9 00		lda #$00	                lda #0
.8c23		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8c25		95 01		sta $01,x	                sta 1,x
.8c27		60		rts		z_negate:       rts
.8c28						xt_nip:
.8c28		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8c2b		b5 00		lda $00,x	                lda 0,x         ; LSB
.8c2d		95 02		sta $02,x	                sta 2,x
.8c2f		b5 01		lda $01,x	                lda 1,x         ; MSB
.8c31		95 03		sta $03,x	                sta 3,x
.8c33		e8		inx		                inx
.8c34		e8		inx		                inx
.8c35		60		rts		z_nip:          rts
.8c36						xt_not_equals:
.8c36		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8c39		a0 00		ldy #$00	                ldy #0                  ; default is true
.8c3b		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8c3d		d5 02		cmp $02,x	                cmp 2,x
.8c3f		d0 0a		bne $8c4b	                bne _not_equal
.8c41		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8c43		d5 03		cmp $03,x	                cmp 3,x
.8c45		d0 04		bne $8c4b	                bne _not_equal
.8c47		a9 ff		lda #$ff	                lda #$FF
.8c49		80 01		bra $8c4c	                bra _done
.8c4b						_not_equal:
.8c4b		88		dey		                dey                     ; drop thru to done
.8c4c						_done:
.8c4c		98		tya		                tya
.8c4d		e8		inx		                inx
.8c4e		e8		inx		                inx
.8c4f		95 00		sta $00,x	                sta 0,x
.8c51		95 01		sta $01,x	                sta 1,x
.8c53		60		rts		z_not_equals:   rts
.8c54						xt_number_sign:
.8c54		20 a2 d7	jsr $d7a2	                jsr underflow_2         ; double number
.8c57		20 fd 82	jsr $82fd	                jsr xt_base
.8c5a		20 19 88	jsr $8819	                jsr xt_fetch            ; ( ud1 base )
.8c5d		20 80 93	jsr $9380	                jsr xt_to_r             ; >r
.8c60		20 04 9e	jsr $9e04	                jsr xt_zero             ; 0
.8c63		20 d1 8e	jsr $8ed1	                jsr xt_r_fetch          ; r@
.8c66		20 4e 95	jsr $954e	                jsr xt_um_slash_mod     ; um/mod
.8c69		20 83 8f	jsr $8f83	                jsr xt_rot              ; rot
.8c6c		20 83 8f	jsr $8f83	                jsr xt_rot              ; rot
.8c6f		20 e6 8e	jsr $8ee6	                jsr xt_r_from           ; r>
.8c72		20 4e 95	jsr $954e	                jsr xt_um_slash_mod     ; um/mod
.8c75		20 83 8f	jsr $8f83	                jsr xt_rot              ; rot
.8c78		20 83 8f	jsr $8f83	                jsr xt_rot              ; ( ud rem )
.8c7b		b5 00		lda $00,x	                lda 0,x
.8c7d		a8		tay		                tay
.8c7e		b9 23 d3	lda $d323,y	                lda s_abc_upper,y
.8c81		95 00		sta $00,x	                sta 0,x
.8c83		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8c85		20 2c 89	jsr $892c	                jsr xt_hold
.8c88						z_number_sign:
.8c88		60		rts		                rts
.8c89						xt_number_sign_greater:
.8c89		20 a2 d7	jsr $d7a2	                jsr underflow_2         ; double number
.8c8c		a5 2b		lda $2b		                lda tohold
.8c8e		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8c90		95 02		sta $02,x	                sta 2,x
.8c92		a5 2c		lda $2c		                lda tohold+1
.8c94		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8c96		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8c98		20 0b 8d	jsr $8d0b	                jsr xt_pad      ; ( addr addr pad )
.8c9b		38		sec		                sec
.8c9c		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8c9e		f5 02		sbc $02,x	                sbc 2,x
.8ca0		95 02		sta $02,x	                sta 2,x
.8ca2		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8ca4		f5 03		sbc $03,x	                sbc 3,x
.8ca6		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8ca8		e8		inx		                inx
.8ca9		e8		inx		                inx
.8caa						z_number_sign_greater:
.8caa		60		rts		                rts
.8cab						xt_number_sign_s:
.8cab		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8cae						_loop:
.8cae		20 54 8c	jsr $8c54	                jsr xt_number_sign
.8cb1		b5 00		lda $00,x	                lda 0,x
.8cb3		15 01		ora $01,x	                ora 1,x
.8cb5		15 02		ora $02,x	                ora 2,x
.8cb7		15 03		ora $03,x	                ora 3,x
.8cb9		d0 f3		bne $8cae	                bne _loop
.8cbb						z_number_sign_s:
.8cbb		60		rts		                rts
.8cbc						xt_of:
.8cbc		a0 8c		ldy #$8c	                ldy #>xt_over
.8cbe		a9 fd		lda #$fd	                lda #<xt_over
.8cc0		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.8cc3		a0 87		ldy #$87	                ldy #>xt_equal
.8cc5		a9 95		lda #$95	                lda #<xt_equal
.8cc7		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.8cca		20 53 89	jsr $8953	                jsr xt_if
.8ccd		a0 86		ldy #$86	                ldy #>xt_drop
.8ccf		a9 99		lda #$99	                lda #<xt_drop
.8cd1		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.8cd4		60		rts		z_of:           rts
.8cd5						xt_one_minus:
.8cd5		20 9d d7	jsr $d79d	                jsr underflow_1
.8cd8		b5 00		lda $00,x	                lda 0,x
.8cda		d0 02		bne $8cde	                bne +
.8cdc		d6 01		dec $01,x	                dec 1,x
.8cde						+
.8cde		d6 00		dec $00,x	                dec 0,x
.8ce0		60		rts		z_one_minus:    rts
.8ce1						xt_char_plus:
.8ce1						xt_one_plus:
.8ce1		20 9d d7	jsr $d79d	                jsr underflow_1
.8ce4		f6 00		inc $00,x	                inc 0,x
.8ce6		d0 02		bne $8cea	                bne _done
.8ce8		f6 01		inc $01,x	                inc 1,x
.8cea						_done:
.8cea						z_char_plus:
.8cea		60		rts		z_one_plus:     rts
.8ceb						xt_or:
.8ceb		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8cee		b5 00		lda $00,x	                lda 0,x
.8cf0		15 02		ora $02,x	                ora 2,x
.8cf2		95 02		sta $02,x	                sta 2,x
.8cf4		b5 01		lda $01,x	                lda 1,x
.8cf6		15 03		ora $03,x	                ora 3,x
.8cf8		95 03		sta $03,x	                sta 3,x
.8cfa		e8		inx		                inx
.8cfb		e8		inx		                inx
.8cfc		60		rts		z_or:           rts
.8cfd						xt_over:
.8cfd		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8d00		ca		dex		                dex
.8d01		ca		dex		                dex
.8d02		b5 04		lda $04,x	                lda 4,x         ; LSB
.8d04		95 00		sta $00,x	                sta 0,x
.8d06		b5 05		lda $05,x	                lda 5,x         ; MSB
.8d08		95 01		sta $01,x	                sta 1,x
.8d0a		60		rts		z_over:         rts
.8d0b						xt_pad:
.8d0b		ca		dex		                dex
.8d0c		ca		dex		                dex
.8d0d		a5 00		lda $00		                lda cp
.8d0f		18		clc		                clc
.8d10		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8d12		95 00		sta $00,x	                sta 0,x
.8d14		a5 01		lda $01		                lda cp+1
.8d16		69 00		adc #$00	                adc #0          ; only need carry
.8d18		95 01		sta $01,x	                sta 1,x
.8d1a		60		rts		z_pad:          rts
.8d1b						xt_page:
.8d1b		a9 1b		lda #$1b	                lda #AscESC
.8d1d		20 c4 86	jsr $86c4	                jsr emit_a
.8d20		a9 5b		lda #$5b	                lda #'['
.8d22		20 c4 86	jsr $86c4	                jsr emit_a
.8d25		a9 32		lda #$32	                lda #'2'
.8d27		20 c4 86	jsr $86c4	                jsr emit_a
.8d2a		a9 4a		lda #$4a	                lda #'J'
.8d2c		20 c4 86	jsr $86c4	                jsr emit_a
.8d2f		20 04 9e	jsr $9e04	                jsr xt_zero
.8d32		20 04 9e	jsr $9e04	                jsr xt_zero
.8d35		20 a4 82	jsr $82a4	                jsr xt_at_xy
.8d38		60		rts		z_page:         rts
.8d39						xt_paren:
.8d39		ca		dex		                dex
.8d3a		ca		dex		                dex
.8d3b		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8d3d		95 00		sta $00,x	                sta 0,x
.8d3f		74 01		stz $01,x	                stz 1,x
.8d41		20 a4 8d	jsr $8da4	                jsr xt_parse
.8d44		e8		inx		                inx
.8d45		e8		inx		                inx
.8d46		e8		inx		                inx
.8d47		e8		inx		                inx
.8d48		60		rts		z_paren:        rts
.8d49						xt_parse_name:
.8d49		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8d4b		38		sec		                sec
.8d4c		e5 10		sbc $10		                sbc toin
.8d4e		85 25		sta $25		                sta tmp1
.8d50		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8d52		e5 11		sbc $11		                sbc toin+1
.8d54		85 26		sta $26		                sta tmp1+1
.8d56		a5 25		lda $25		                lda tmp1
.8d58		05 26		ora $26		                ora tmp1+1
.8d5a		f0 28		beq $8d84	                beq _empty_line
.8d5c		a5 0c		lda $0c		                lda cib
.8d5e		18		clc		                clc
.8d5f		65 10		adc $10		                adc toin
.8d61		85 27		sta $27		                sta tmp2                ; LSB of first character
.8d63		a5 0d		lda $0d		                lda cib+1
.8d65		65 11		adc $11		                adc toin+1
.8d67		85 28		sta $28		                sta tmp2+1              ; MSB
.8d69						_skip_loop:
.8d69		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8d6b		20 90 d7	jsr $d790	                jsr is_whitespace
.8d6e		90 1f		bcc $8d8f	                bcc _char_found
.8d70		e6 27		inc $27		                inc tmp2
.8d72		d0 02		bne $8d76	                bne +
.8d74		e6 28		inc $28		                inc tmp2+1
.8d76						+
.8d76		a5 25		lda $25		                lda tmp1
.8d78		d0 02		bne $8d7c	                bne +
.8d7a		c6 26		dec $26		                dec tmp1+1
.8d7c		c6 25		dec $25		+               dec tmp1
.8d7e		a5 25		lda $25		                lda tmp1
.8d80		05 26		ora $26		                ora tmp1+1
.8d82		d0 e5		bne $8d69	                bne _skip_loop          ; fall through if empty line
.8d84						_empty_line:
.8d84		ca		dex		                dex
.8d85		ca		dex		                dex
.8d86		ca		dex		                dex
.8d87		ca		dex		                dex
.8d88		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8d8a		74 01		stz $01,x	                stz 1,x
.8d8c		4c 39 8e	jmp $8e39	                jmp z_parse_name        ; skip over PARSE
.8d8f						_char_found:
.8d8f		a5 27		lda $27		                lda tmp2
.8d91		38		sec		                sec
.8d92		e5 0c		sbc $0c		                sbc cib
.8d94		85 10		sta $10		                sta toin
.8d96		a5 28		lda $28		                lda tmp2+1
.8d98		e5 0d		sbc $0d		                sbc cib+1
.8d9a		85 11		sta $11		                sta toin+1
.8d9c		ca		dex		                dex
.8d9d		ca		dex		                dex
.8d9e		a9 20		lda #$20	                lda #AscSP
.8da0		95 00		sta $00,x	                sta 0,x
.8da2		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8da4						xt_parse:
.8da4		20 9d d7	jsr $d79d	                jsr underflow_1
.8da7		a5 0e		lda $0e		                lda ciblen
.8da9		05 0f		ora $0f		                ora ciblen+1
.8dab		f0 0c		beq $8db9	                beq _abort_parse
.8dad		a5 11		lda $11		                lda toin+1              ; MSB
.8daf		c5 0f		cmp $0f		                cmp ciblen+1
.8db1		90 0e		bcc $8dc1	                bcc _go_parse           ; unsigned comparison
.8db3		a5 10		lda $10		                lda toin                ; LSB
.8db5		c5 0e		cmp $0e		                cmp ciblen
.8db7		90 08		bcc $8dc1	                bcc _go_parse
.8db9						_abort_parse:
.8db9		ca		dex		                dex
.8dba		ca		dex		                dex
.8dbb		74 00		stz $00,x	                stz 0,x
.8dbd		74 01		stz $01,x	                stz 1,x
.8dbf		80 78		bra $8e39	                bra _done
.8dc1						_go_parse:
.8dc1		b5 00		lda $00,x	                lda 0,x
.8dc3		85 23		sta $23		                sta tmptos
.8dc5		ca		dex		                dex
.8dc6		ca		dex		                dex
.8dc7		a5 0c		lda $0c		                lda cib
.8dc9		18		clc		                clc
.8dca		65 10		adc $10		                adc toin        ; LSB
.8dcc		85 25		sta $25		                sta tmp1
.8dce		85 27		sta $27		                sta tmp2
.8dd0		95 02		sta $02,x	                sta 2,x
.8dd2		a5 0d		lda $0d		                lda cib+1
.8dd4		65 11		adc $11		                adc toin+1      ; MSB
.8dd6		85 26		sta $26		                sta tmp1+1
.8dd8		85 28		sta $28		                sta tmp2+1
.8dda		95 03		sta $03,x	                sta 3,x
.8ddc		a5 0c		lda $0c		                lda cib
.8dde		18		clc		                clc
.8ddf		65 0e		adc $0e		                adc ciblen
.8de1		85 29		sta $29		                sta tmp3
.8de3		a5 0d		lda $0d		                lda cib+1
.8de5		65 0f		adc $0f		                adc ciblen+1
.8de7		85 2a		sta $2a		                sta tmp3+1
.8de9		64 24		stz $24		                stz tmptos+1
.8deb						_loop:
.8deb		a5 27		lda $27		                lda tmp2
.8ded		c5 29		cmp $29		                cmp tmp3
.8def		d0 06		bne $8df7	                bne _not_empty
.8df1		a5 28		lda $28		                lda tmp2+1
.8df3		c5 2a		cmp $2a		                cmp tmp3+1
.8df5		f0 1d		beq $8e14	                beq _eol
.8df7						_not_empty:
.8df7		b2 27		lda ($27)	                lda (tmp2)
.8df9		a4 23		ldy $23		                ldy tmptos
.8dfb		c0 20		cpy #$20	                cpy #AscSP
.8dfd		d0 07		bne $8e06	                bne _not_whitespace
.8dff		20 90 d7	jsr $d790	                jsr is_whitespace
.8e02		90 02		bcc $8e06	                bcc _not_whitespace
.8e04		80 0c		bra $8e12	                bra _found_delimiter
.8e06						_not_whitespace:
.8e06		c5 23		cmp $23		                cmp tmptos
.8e08		f0 08		beq $8e12	                beq _found_delimiter
.8e0a		e6 27		inc $27		                inc tmp2
.8e0c		d0 dd		bne $8deb	                bne _loop
.8e0e		e6 28		inc $28		                inc tmp2+1
.8e10		80 d9		bra $8deb	                bra _loop
.8e12						_found_delimiter:
.8e12		e6 24		inc $24		                inc tmptos+1
.8e14						_eol:
.8e14		a5 27		lda $27		                lda tmp2
.8e16		38		sec		                sec
.8e17		e5 25		sbc $25		                sbc tmp1
.8e19		95 00		sta $00,x	                sta 0,x
.8e1b		a5 28		lda $28		                lda tmp2+1
.8e1d		e5 26		sbc $26		                sbc tmp1+1
.8e1f		95 01		sta $01,x	                sta 1,x
.8e21		a5 27		lda $27		                lda tmp2
.8e23		38		sec		                sec
.8e24		e5 0c		sbc $0c		                sbc cib
.8e26		85 10		sta $10		                sta toin
.8e28		a5 28		lda $28		                lda tmp2+1
.8e2a		e5 0d		sbc $0d		                sbc cib+1
.8e2c		85 11		sta $11		                sta toin+1
.8e2e		a5 10		lda $10		                lda toin
.8e30		18		clc		                clc
.8e31		65 24		adc $24		                adc tmptos+1
.8e33		85 10		sta $10		                sta toin
.8e35		90 02		bcc $8e39	                bcc +
.8e37		e6 11		inc $11		                inc toin+1
.8e39						+
.8e39						_done:
.8e39						z_parse_name:
.8e39		60		rts		z_parse:        rts
.8e3a						xt_pick:
.8e3a		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8e3c		8a		txa		                txa
.8e3d		75 00		adc $00,x	                adc 0,x
.8e3f		a8		tay		                tay
.8e40		b9 02 00	lda $0002,y	                lda 0002,y
.8e43		95 00		sta $00,x	                sta 0,x
.8e45		b9 03 00	lda $0003,y	                lda 0003,y
.8e48		95 01		sta $01,x	                sta 1,x
.8e4a		60		rts		z_pick:         rts
.8e4b						xt_plus:
.8e4b		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8e4e		18		clc		                clc
.8e4f		b5 00		lda $00,x	                lda 0,x         ; LSB
.8e51		75 02		adc $02,x	                adc 2,x
.8e53		95 02		sta $02,x	                sta 2,x
.8e55		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8e57		75 03		adc $03,x	                adc 3,x
.8e59		95 03		sta $03,x	                sta 3,x
.8e5b		e8		inx		                inx
.8e5c		e8		inx		                inx
.8e5d		60		rts		z_plus:         rts
.8e5e						xt_plus_store:
.8e5e		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8e61		b5 00		lda $00,x	                lda 0,x
.8e63		85 25		sta $25		                sta tmp1
.8e65		b5 01		lda $01,x	                lda 1,x
.8e67		85 26		sta $26		                sta tmp1+1
.8e69		a0 00		ldy #$00	                ldy #0          ; LSB
.8e6b		b1 25		lda ($25),y	                lda (tmp1),y
.8e6d		18		clc		                clc
.8e6e		75 02		adc $02,x	                adc 2,x
.8e70		91 25		sta ($25),y	                sta (tmp1),y
.8e72		c8		iny		                iny             ; MSB
.8e73		b1 25		lda ($25),y	                lda (tmp1),y
.8e75		75 03		adc $03,x	                adc 3,x
.8e77		91 25		sta ($25),y	                sta (tmp1),y
.8e79		e8		inx		                inx
.8e7a		e8		inx		                inx
.8e7b		e8		inx		                inx
.8e7c		e8		inx		                inx
.8e7d		60		rts		z_plus_store:   rts
.8e7e						xt_postpone:
.8e7e		20 49 8d	jsr $8d49	                jsr xt_parse_name               ; ( -- addr n )
.8e81		b5 00		lda $00,x	                lda 0,x
.8e83		15 01		ora $01,x	                ora 1,x
.8e85		d0 05		bne $8e8c	                bne +
.8e87		a9 05		lda #$05	                lda #err_noname
.8e89		4c b3 d7	jmp $d7b3	                jmp error
.8e8c						+
.8e8c		20 03 9b	jsr $9b03	                jsr xt_find_name                ; ( -- nt | 0 )
.8e8f		d0 05		bne $8e96	                bne +
.8e91		a9 05		lda #$05	                lda #err_noname
.8e93		4c b3 d7	jmp $d7b3	                jmp error
.8e96						+
.8e96		b5 00		lda $00,x	                lda 0,x
.8e98		85 25		sta $25		                sta tmp1
.8e9a		b5 01		lda $01,x	                lda 1,x
.8e9c		85 26		sta $26		                sta tmp1+1
.8e9e		20 41 9c	jsr $9c41	                jsr xt_name_to_int              ; ( nt -- xt )
.8ea1		e6 25		inc $25		                inc tmp1
.8ea3		d0 02		bne $8ea7	                bne +
.8ea5		e6 26		inc $26		                inc tmp1+1
.8ea7						+
.8ea7		b2 25		lda ($25)	                lda (tmp1)
.8ea9		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.8eab		f0 05		beq $8eb2	                beq _not_immediate
.8ead		20 cc 96	jsr $96cc	                jsr xt_compile_comma
.8eb0		80 0a		bra $8ebc	                bra _done
.8eb2						_not_immediate:
.8eb2		20 f1 89	jsr $89f1	                jsr xt_literal
.8eb5		a0 96		ldy #$96	                ldy #>xt_compile_comma
.8eb7		a9 cc		lda #$cc	                lda #<xt_compile_comma
.8eb9		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.8ebc						_done:
.8ebc		60		rts		z_postpone:     rts
.8ebd						xt_question_dup:
.8ebd		20 9d d7	jsr $d79d	                jsr underflow_1
.8ec0		b5 00		lda $00,x	                lda 0,x
.8ec2		15 01		ora $01,x	                ora 1,x
.8ec4		f0 0a		beq $8ed0	                beq _done
.8ec6		ca		dex		                dex
.8ec7		ca		dex		                dex
.8ec8		b5 02		lda $02,x	                lda 2,x
.8eca		95 00		sta $00,x	                sta 0,x
.8ecc		b5 03		lda $03,x	                lda 3,x
.8ece		95 01		sta $01,x	                sta 1,x
.8ed0						_done:
.8ed0		60		rts		z_question_dup: rts
.8ed1						xt_r_fetch:
.8ed1		7a		ply		                ply             ; LSB
.8ed2		84 25		sty $25		                sty tmp1
.8ed4		7a		ply		                ply             ; MSB
.8ed5		ca		dex		                dex
.8ed6		ca		dex		                dex
.8ed7		68		pla		                pla             ; LSB
.8ed8		95 00		sta $00,x	                sta 0,x
.8eda		68		pla		                pla             ; MSB
.8edb		95 01		sta $01,x	                sta 1,x
.8edd		48		pha		                pha
.8ede		b5 00		lda $00,x	                lda 0,x
.8ee0		48		pha		                pha
.8ee1		5a		phy		                phy             ; MSB
.8ee2		a4 25		ldy $25		                ldy tmp1
.8ee4		5a		phy		                phy             ; LSB
.8ee5		60		rts		z_r_fetch:      rts
.8ee6						xt_r_from:
.8ee6		68		pla		                pla             ; LSB
.8ee7		85 23		sta $23		                sta tmptos
.8ee9		7a		ply		                ply             ; MSB
.8eea		ca		dex		                dex
.8eeb		ca		dex		                dex
.8eec		68		pla		                pla             ; LSB
.8eed		95 00		sta $00,x	                sta 0,x
.8eef		68		pla		                pla             ; MSB
.8ef0		95 01		sta $01,x	                sta 1,x
.8ef2		5a		phy		                phy             ; MSB
.8ef3		a5 23		lda $23		                lda tmptos
.8ef5		48		pha		                pha             ; LSB
.8ef6		60		rts		z_r_from:       rts
.8ef7						xt_recurse:
.8ef7		a0 00		ldy #$00	                ldy #0
.8ef9		a9 20		lda #$20	                lda #OpJSR
.8efb		91 00		sta ($00),y	                sta (cp),y
.8efd		c8		iny		                iny
.8efe		24 1c		bit $1c		                bit status
.8f00		70 0c		bvs $8f0e	                bvs _nt_in_workword
.8f02		a5 06		lda $06		                lda workword
.8f04		91 00		sta ($00),y	                sta (cp),y
.8f06		c8		iny		                iny
.8f07		a5 07		lda $07		                lda workword+1
.8f09		91 00		sta ($00),y	                sta (cp),y
.8f0b		c8		iny		                iny
.8f0c		80 1b		bra $8f29	                bra _update_cp
.8f0e						_nt_in_workword:
.8f0e		a5 06		lda $06		                lda workword            ; LSB
.8f10		18		clc		                clc
.8f11		69 04		adc #$04	                adc #4
.8f13		85 25		sta $25		                sta tmp1
.8f15		a5 07		lda $07		                lda workword+1          ; MSB
.8f17		69 00		adc #$00	                adc #0
.8f19		85 26		sta $26		                sta tmp1+1
.8f1b		b2 25		lda ($25)	                lda (tmp1)
.8f1d		91 00		sta ($00),y	                sta (cp),y
.8f1f		5a		phy		                phy
.8f20		a0 01		ldy #$01	                ldy #1
.8f22		b1 25		lda ($25),y	                lda (tmp1),y
.8f24		7a		ply		                ply
.8f25		c8		iny		                iny
.8f26		91 00		sta ($00),y	                sta (cp),y
.8f28		c8		iny		                iny
.8f29						_update_cp:
.8f29		98		tya		                tya
.8f2a		18		clc		                clc
.8f2b		65 00		adc $00		                adc cp
.8f2d		85 00		sta $00		                sta cp
.8f2f		90 02		bcc $8f33	                bcc _done
.8f31		e6 01		inc $01		                inc cp+1
.8f33						_done:
.8f33		60		rts		z_recurse:      rts
.8f34						xt_refill:
.8f34		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.8f36		d0 2d		bne $8f65	                bne _src_not_kbd
.8f38		ca		dex		                dex
.8f39		ca		dex		                dex
.8f3a		ca		dex		                dex
.8f3b		ca		dex		                dex
.8f3c		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.8f3e		95 02		sta $02,x	                sta 2,x
.8f40		a5 0d		lda $0d		                lda cib+1
.8f42		95 03		sta $03,x	                sta 3,x
.8f44		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.8f46		64 0f		stz $0f		                stz ciblen+1
.8f48		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.8f4a		95 00		sta $00,x	                sta 0,x
.8f4c		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.8f4e		20 e6 80	jsr $80e6	                jsr xt_accept           ; ( addr n1 -- n2)
.8f51		b5 00		lda $00,x	                lda 0,x
.8f53		85 0e		sta $0e		                sta ciblen
.8f55		b5 01		lda $01,x	                lda 1,x
.8f57		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.8f59		64 10		stz $10		                stz toin
.8f5b		64 11		stz $11		                stz toin+1
.8f5d		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.8f5f		95 00		sta $00,x	                sta 0,x
.8f61		95 01		sta $01,x	                sta 1,x
.8f63		80 10		bra $8f75	                bra _done
.8f65						_src_not_kbd:
.8f65		1a		inc a		                ina
.8f66		d0 08		bne $8f70	                bne _src_not_string
.8f68		ca		dex		                dex
.8f69		ca		dex		                dex
.8f6a		74 00		stz $00,x	                stz 0,x
.8f6c		74 01		stz $01,x	                stz 1,x
.8f6e		80 05		bra $8f75	                bra z_refill
.8f70						_src_not_string:
.8f70		a9 01		lda #$01	                lda #err_badsource
.8f72		4c b3 d7	jmp $d7b3	                jmp error
.8f75						_done:
.8f75		60		rts		z_refill:       rts
.8f76						xt_repeat:
.8f76		20 21 82	jsr $8221	                jsr xt_again
.8f79		4c b3 86	jmp $86b3	                jmp xt_then
.8f7c						z_repeat:
.8f7c						xt_right_bracket:
.8f7c		a9 ff		lda #$ff	                lda #$FF
.8f7e		85 1a		sta $1a		                sta state
.8f80		85 1b		sta $1b		                sta state+1
.8f82						z_right_bracket:
.8f82		60		rts		                rts
.8f83						xt_rot:
.8f83		20 a7 d7	jsr $d7a7	                jsr underflow_3
.8f86		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.8f88		b5 03		lda $03,x	                lda 3,x
.8f8a		95 05		sta $05,x	                sta 5,x
.8f8c		b5 01		lda $01,x	                lda 1,x
.8f8e		95 03		sta $03,x	                sta 3,x
.8f90		94 01		sty $01,x	                sty 1,x
.8f92		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.8f94		b5 02		lda $02,x	                lda 2,x
.8f96		95 04		sta $04,x	                sta 4,x
.8f98		b5 00		lda $00,x	                lda 0,x
.8f9a		95 02		sta $02,x	                sta 2,x
.8f9c		94 00		sty $00,x	                sty 0,x
.8f9e		60		rts		z_rot:          rts
.8f9f						xt_rshift:
.8f9f		20 a2 d7	jsr $d7a2	                jsr underflow_2
.8fa2		b5 00		lda $00,x	                lda 0,x
.8fa4		29 0f		and #$0f	                and #%00001111
.8fa6		f0 08		beq $8fb0	                beq _done               ; if 0 shifts, quit
.8fa8		a8		tay		                tay
.8fa9						_loop:
.8fa9		56 03		lsr $03,x	                lsr 3,x
.8fab		76 02		ror $02,x	                ror 2,x
.8fad		88		dey		                dey
.8fae		d0 f9		bne $8fa9	                bne _loop
.8fb0						_done:
.8fb0		e8		inx		                inx
.8fb1		e8		inx		                inx
.8fb2		60		rts		z_rshift:       rts
.8fb3						xt_s_backslash_quote:
.8fb3		a9 ff		lda #$ff	                lda #$FF
.8fb5		85 27		sta $27		                sta tmp2
.8fb7		64 28		stz $28		                stz tmp2+1
.8fb9		20 d0 8f	jsr $8fd0	                jsr s_quote_start
.8fbc						z_s_backslash_quote:
.8fbc		60		rts		                rts
.8fbd						convert_hex_value:
.8fbd		c9 41		cmp #$41	        cmp #'A'
.8fbf		90 07		bcc $8fc8	        bcc _digit
.8fc1		29 df		and #$df	        and #$DF                ; Make it uppercase.
.8fc3		38		sec		        sec
.8fc4		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.8fc6		80 03		bra $8fcb	        bra _done
.8fc8						_digit:
.8fc8		38		sec		        sec
.8fc9		e9 30		sbc #$30	        sbc #'0'
.8fcb						_done:
.8fcb		60		rts		        rts
.8fcc						xt_s_quote:
.8fcc		64 27		stz $27		                stz tmp2
.8fce		64 28		stz $28		                stz tmp2+1
.8fd0						s_quote_start:
.8fd0		20 ae 97	jsr $97ae	                jsr cmpl_jump_later
.8fd3		20 1a 89	jsr $891a	                jsr xt_here             ; the start of the string
.8fd6						_savechars_loop:
.8fd6		a5 11		lda $11		                lda toin+1              ; MSB
.8fd8		c5 0f		cmp $0f		                cmp ciblen+1
.8fda		90 2a		bcc $9006	                bcc _input_fine         ; unsigned comparison
.8fdc		a5 10		lda $10		                lda toin                ; LSB
.8fde		c5 0e		cmp $0e		                cmp ciblen
.8fe0		90 24		bcc $9006	                bcc _input_fine
.8fe2		a5 27		lda $27		                lda tmp2
.8fe4		48		pha		                pha
.8fe5		a5 28		lda $28		                lda tmp2+1
.8fe7		48		pha		                pha
.8fe8		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.8fea		48		pha		                pha
.8feb		20 34 8f	jsr $8f34	                jsr xt_refill           ; ( -- f )
.8fee		68		pla		                pla
.8fef		85 29		sta $29		                sta tmp3
.8ff1		68		pla		                pla
.8ff2		85 28		sta $28		                sta tmp2+1
.8ff4		68		pla		                pla
.8ff5		85 27		sta $27		                sta tmp2
.8ff7		b5 00		lda $00,x	                lda 0,x
.8ff9		15 01		ora $01,x	                ora 1,x
.8ffb		d0 05		bne $9002	                bne _refill_ok
.8ffd		a9 06		lda #$06	                lda #err_refill
.8fff		4c b3 d7	jmp $d7b3	                jmp error
.9002						_refill_ok:
.9002		e8		inx		                inx
.9003		e8		inx		                inx
.9004		80 d0		bra $8fd6	                bra _savechars_loop
.9006						_input_fine:
.9006		a5 0c		lda $0c		                lda cib
.9008		18		clc		                clc
.9009		65 10		adc $10		                adc toin        ; LSB
.900b		85 25		sta $25		                sta tmp1
.900d		a5 0d		lda $0d		                lda cib+1
.900f		65 11		adc $11		                adc toin+1      ; MSB
.9011		85 26		sta $26		                sta tmp1+1
.9013		b2 25		lda ($25)	                lda (tmp1)
.9015		24 27		bit $27		                bit tmp2
.9017		30 03		bmi $901c	                bmi _handle_escapes    ; Only checking bit 7
.9019		4c 9f 90	jmp $909f	                jmp _regular_char
.901c						_handle_escapes:
.901c		24 28		bit $28		                bit tmp2+1
.901e		30 03		bmi $9023	                bmi _escaped
.9020		4c 95 90	jmp $9095	                jmp _not_escaped
.9023						_escaped:
.9023		70 3c		bvs $9061	                bvs _check_esc_chars
.9025		a9 01		lda #$01	                lda #1
.9027		24 28		bit $28		                bit tmp2+1
.9029		d0 10		bne $903b	                bne _esc_x_second_digit
.902b		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.902d		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.902f		20 bd 8f	jsr $8fbd	                jsr convert_hex_value
.9032		0a		asl a		                asl
.9033		0a		asl a		                asl
.9034		0a		asl a		                asl
.9035		0a		asl a		                asl
.9036		85 29		sta $29		                sta tmp3    ; Save it for later.
.9038		4c a6 90	jmp $90a6	                jmp _next_character
.903b						_esc_x_second_digit:
.903b		64 28		stz $28		                stz tmp2+1
.903d		b2 25		lda ($25)	                lda (tmp1)
.903f		20 bd 8f	jsr $8fbd	                jsr convert_hex_value
.9042		05 29		ora $29		                ora tmp3
.9044		4c a3 90	jmp $90a3	                jmp _save_character
.9047						_esc_tr_table:
>9047		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9048		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9049		00 00				    .byte   0,0             ; c, d no escape
>904b		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>904c		0c				    .byte   12              ; f -> FF (ASCII value 12)
>904d		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9052		0a				    .byte   10              ; l -> LF (ASCII value 10)
>9053		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9054		0a				    .byte   10              ; n behaves like l --> lf
>9055		00 00				    .byte   0,0             ; o,p
>9057		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9058		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9059		00				    .byte   0               ; s
>905a		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>905b		00				    .byte   0               ; u
>905c		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>905d		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9060		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9061						_check_esc_chars:
.9061		64 28		stz $28		                stz tmp2+1
.9063		c9 61		cmp #$61	                cmp #'a'
.9065		30 1a		bmi $9081	                bmi _check_esc_quote
.9067		c9 7b		cmp #$7b	                cmp #'z'+1
.9069		10 16		bpl $9081	                bpl _check_esc_quote
.906b		a8		tay		                tay
.906c		b9 e6 8f	lda $8fe6,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.906f		d0 03		bne $9074	                bne _esc_replace
.9071		98		tya		                tya                     ; revert if no translation
.9072		80 0d		bra $9081	                bra _check_esc_quote
.9074		10 2d		bpl $90a3	_esc_replace:   bpl _save_character     ; simple replacement
.9076		29 7f		and #$7f	                and #$7F                ; clear hi bit
.9078		f0 29		beq $90a3	                beq _save_character     ; NUL we can just output
.907a		20 9d 97	jsr $979d	                jsr cmpl_a              ; else output first char (CR)
.907d		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.907f		80 22		bra $90a3	                bra _save_character
.9081						_check_esc_quote:
.9081		c9 22		cmp #$22	                cmp #'"'
.9083		f0 1e		beq $90a3	                beq _save_character
.9085		c9 78		cmp #$78	                cmp #'x'
.9087		d0 06		bne $908f	                bne _check_esc_backslash
.9089		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.908b		85 28		sta $28		                sta tmp2+1
.908d		80 17		bra $90a6	                bra _next_character
.908f						_check_esc_backslash:
.908f		c9 5c		cmp #$5c	                cmp #'\'
.9091		d0 0c		bne $909f	                bne _regular_char
.9093		80 0e		bra $90a3	                bra _save_character
.9095						_not_escaped:
.9095		c9 5c		cmp #$5c	                cmp #'\'
.9097		d0 06		bne $909f	                bne _regular_char
.9099		a9 ff		lda #$ff	                lda #$FF
.909b		85 28		sta $28		                sta tmp2+1
.909d		80 07		bra $90a6	                bra _next_character
.909f						_regular_char:
.909f		c9 22		cmp #$22	                cmp #'"'
.90a1		f0 0c		beq $90af	                beq _found_string_end
.90a3						_save_character:
.90a3		20 9d 97	jsr $979d	                jsr cmpl_a
.90a6						_next_character:
.90a6		e6 10		inc $10		                inc toin
.90a8		d0 02		bne $90ac	                bne _savechars_loop_longjump
.90aa		e6 11		inc $11		                inc toin+1
.90ac						_savechars_loop_longjump:
.90ac		4c d6 8f	jmp $8fd6	                jmp _savechars_loop
.90af						_found_string_end:
.90af		e6 10		inc $10		                inc toin
.90b1		d0 02		bne $90b5	                bne +
.90b3		e6 11		inc $11		                inc toin+1
.90b5						+
.90b5		20 1a 89	jsr $891a	                jsr xt_here
.90b8		20 83 8f	jsr $8f83	                jsr xt_rot
.90bb		20 2c 92	jsr $922c	                jsr xt_store    ; Update the jmp target
.90be		20 1a 89	jsr $891a	                jsr xt_here
.90c1		20 fd 8c	jsr $8cfd	                jsr xt_over
.90c4		20 dc 8b	jsr $8bdc	                jsr xt_minus    ; HERE - addr gives string length
.90c7		a5 1a		lda $1a		                lda state
.90c9		05 1b		ora $1b		                ora state+1             ; paranoid
.90cb		f0 03		beq $90d0	                beq _done
.90cd		20 6f a1	jsr $a16f	                jsr cmpl_sliteral         ; ( addr u -- )
.90d0						_done:
.90d0		60		rts		z_s_quote:      rts
.90d1						xt_s_to_d:
.90d1		20 9d d7	jsr $d79d	                jsr underflow_1
.90d4		ca		dex		                dex
.90d5		ca		dex		                dex
.90d6		74 00		stz $00,x	                stz 0,x
.90d8		74 01		stz $01,x	                stz 1,x
.90da		b5 03		lda $03,x	                lda 3,x
.90dc		10 04		bpl $90e2	                bpl _done
.90de		d6 00		dec $00,x	                dec 0,x
.90e0		d6 01		dec $01,x	                dec 1,x
.90e2						_done:
.90e2		60		rts		z_s_to_d:       rts
.90e3						xt_semicolon:
.90e3		24 1c		bit $1c		                bit status
.90e5		70 11		bvs $90f8	                bvs _colonword
.90e7		a9 60		lda #$60	                lda #OpRTS
.90e9		20 9d 97	jsr $979d	                jsr cmpl_a
.90ec		ca		dex		                dex
.90ed		ca		dex		                dex
.90ee		a5 06		lda $06		                lda workword
.90f0		95 00		sta $00,x	                sta 0,x
.90f2		a5 07		lda $07		                lda workword+1
.90f4		95 01		sta $01,x	                sta 1,x
.90f6		80 45		bra $913d	                bra _semicolon_done
.90f8						_colonword:
.90f8		a0 06		ldy #$06	                ldy #6
.90fa		a5 00		lda $00		                lda cp
.90fc		91 06		sta ($06),y	                sta (workword),y
.90fe		c8		iny		                iny
.90ff		a5 01		lda $01		                lda cp+1
.9101		91 06		sta ($06),y	                sta (workword),y
.9103		a9 60		lda #$60	                lda #OpRTS
.9105		20 9d 97	jsr $979d	                jsr cmpl_a
.9108		24 1c		bit $1c		                bit status
.910a		10 26		bpl $9132	                bpl _new_word   ; Bit 7 is clear = new word
.910c		ca		dex		                dex
.910d		ca		dex		                dex
.910e		ca		dex		                dex
.910f		ca		dex		                dex
.9110		b2 06		lda ($06)	                lda (workword)
.9112		95 00		sta $00,x	                sta 0,x
.9114		74 01		stz $01,x	                stz 1,x
.9116		a5 06		lda $06		                lda workword
.9118		18		clc		                clc
.9119		69 08		adc #$08	                adc #8
.911b		95 02		sta $02,x	                sta 2,x
.911d		a5 07		lda $07		                lda workword+1
.911f		69 00		adc #$00	                adc #0                  ; only want carry
.9121		95 03		sta $03,x	                sta 3,x
.9123		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9125		20 d9 d7	jsr $d7d9	                jsr print_string_no_lf
.9128		20 c9 94	jsr $94c9	                jsr xt_type
.912b		20 bd 91	jsr $91bd	                jsr xt_space
.912e		a9 80		lda #$80	                lda #%10000000
.9130		14 1c		trb $1c		                trb status
.9132						_new_word:
.9132		a5 06		lda $06		                lda workword
.9134		85 02		sta $02		                sta dp
.9136		a5 07		lda $07		                lda workword+1
.9138		85 03		sta $03		                sta dp+1
.913a		20 07 d7	jsr $d707	                jsr dp_to_current       ; Save the updated DP to the
.913d						_semicolon_done:
.913d		64 1a		stz $1a		                stz state
.913f		64 1b		stz $1b		                stz state+1
.9141		60		rts		z_semicolon:    rts
.9142						xt_sign:
.9142		20 9d d7	jsr $d79d	                jsr underflow_1
.9145		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9147		30 04		bmi $914d	                bmi _minus
.9149		e8		inx		                inx
.914a		e8		inx		                inx
.914b		80 09		bra $9156	                bra _done
.914d						_minus:
.914d		a9 2d		lda #$2d	                lda #'-'
.914f		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9151		74 01		stz $01,x	                stz 1,x         ; paranoid
.9153		20 2c 89	jsr $892c	                jsr xt_hold
.9156						_done:
.9156		60		rts		z_sign:         rts
.9157						xt_slash:
.9157		a9 00		lda #$00	                lda #0
.9159		48		pha		                pha
.915a		80 03		bra $915f	                bra slashmod_common
.915c						xt_slash_mod:
.915c		a9 ff		lda #$ff	                lda #$FF
.915e		48		pha		                pha             ; falls through to _common
.915f						slashmod_common:
.915f		20 80 93	jsr $9380	                jsr xt_to_r             ; >R
.9162		20 d1 90	jsr $90d1	                jsr xt_s_to_d           ; S>D
.9165		20 e6 8e	jsr $8ee6	                jsr xt_r_from           ; R>
.9168		20 74 91	jsr $9174	                jsr xt_sm_slash_rem     ; SM/REM
.916b		68		pla		                pla
.916c		d0 05		bne $9173	                bne _done
.916e		20 42 92	jsr $9242	                jsr xt_swap
.9171		e8		inx		                inx             ; DROP
.9172		e8		inx		                inx
.9173						_done:
.9173						z_slash_mod:
.9173		60		rts		z_slash:        rts
.9174						xt_sm_slash_rem:
.9174		20 a7 d7	jsr $d7a7	                jsr underflow_3 ; contains double number
.9177		b5 03		lda $03,x	                lda 3,x
.9179		48		pha		                pha
.917a		b5 01		lda $01,x	                lda 1,x
.917c		55 03		eor $03,x	                eor 3,x
.917e		48		pha		                pha
.917f		20 d1 80	jsr $80d1	                jsr xt_abs
.9182		e8		inx		                inx             ; pretend we pushed n1 to R
.9183		e8		inx		                inx
.9184		20 53 9e	jsr $9e53	                jsr xt_dabs
.9187		ca		dex		                dex
.9188		ca		dex		                dex
.9189		20 4e 95	jsr $954e	                jsr xt_um_slash_mod     ; UM/MOD
.918c		68		pla		                pla
.918d		10 03		bpl $9192	                bpl +
.918f		20 17 8c	jsr $8c17	                jsr xt_negate
.9192						+
.9192		68		pla		                pla
.9193		10 07		bpl $919c	                bpl _done
.9195		e8		inx		                inx             ; pretend we pushed quotient to R
.9196		e8		inx		                inx
.9197		20 17 8c	jsr $8c17	                jsr xt_negate
.919a		ca		dex		                dex
.919b		ca		dex		                dex
.919c						_done:
.919c		60		rts		z_sm_slash_rem: rts
.919d						xt_source:
.919d		ca		dex		                dex
.919e		ca		dex		                dex
.919f		a5 0c		lda $0c		                lda cib
.91a1		95 00		sta $00,x	                sta 0,x
.91a3		a5 0d		lda $0d		                lda cib+1
.91a5		95 01		sta $01,x	                sta 1,x
.91a7		ca		dex		                dex
.91a8		ca		dex		                dex
.91a9		a5 0e		lda $0e		                lda ciblen
.91ab		95 00		sta $00,x	                sta 0,x
.91ad		a5 0f		lda $0f		                lda ciblen+1
.91af		95 01		sta $01,x	                sta 1,x
.91b1		60		rts		z_source:       rts
.91b2						xt_source_id:
.91b2		ca		dex		                dex
.91b3		ca		dex		                dex
.91b4		a5 0a		lda $0a		                lda insrc
.91b6		95 00		sta $00,x	                sta 0,x
.91b8		a5 0b		lda $0b		                lda insrc+1
.91ba		95 01		sta $01,x	                sta 1,x
.91bc		60		rts		z_source_id:    rts
.91bd						xt_space:
.91bd		a9 20		lda #$20	                lda #AscSP
.91bf		20 c4 86	jsr $86c4	                jsr emit_a
.91c2		60		rts		z_space:        rts
.91c3						xt_spaces:
.91c3		20 9d d7	jsr $d79d	                jsr underflow_1
.91c6		20 04 9e	jsr $9e04	                jsr xt_zero
.91c9		20 a4 8b	jsr $8ba4	                jsr xt_max
.91cc		b5 00		lda $00,x	                lda 0,x
.91ce		15 01		ora $01,x	                ora 1,x
.91d0		f0 2a		beq $91fc	                beq _done
.91d2		b4 01		ldy $01,x	                ldy 1,x
.91d4		d0 0c		bne $91e2	                bne _lots_of_spaces
.91d6		b4 00		ldy $00,x	                ldy 0,x
.91d8						_quick_loop:
.91d8		a9 20		lda #$20	                lda #AscSP
.91da		20 c4 86	jsr $86c4	                jsr emit_a
.91dd		88		dey		                dey
.91de		f0 1c		beq $91fc	                beq _done
.91e0		80 f6		bra $91d8	                bra _quick_loop
.91e2						_lots_of_spaces:
.91e2		b4 00		ldy $00,x	                ldy 0,x
.91e4						_first_slow_loop:
.91e4		f0 08		beq $91ee	                beq _slow_outer_loop
.91e6		a9 20		lda #$20	                lda #AscSP
.91e8		20 c4 86	jsr $86c4	                jsr emit_a
.91eb		88		dey		                dey
.91ec		80 f6		bra $91e4	                bra _first_slow_loop
.91ee						_slow_outer_loop:
.91ee		a0 00		ldy #$00	                ldy #00
.91f0						_slow_inner_loop:
.91f0		a9 20		lda #$20	                lda #AscSP
.91f2		20 c4 86	jsr $86c4	                jsr emit_a
.91f5		88		dey		                dey
.91f6		d0 f8		bne $91f0	                bne _slow_inner_loop
.91f8		d6 01		dec $01,x	                dec 1,x
.91fa		d0 f2		bne $91ee	                bne _slow_outer_loop
.91fc						_done:
.91fc		e8		inx		                inx             ; drop
.91fd		e8		inx		                inx
.91fe		60		rts		z_spaces:       rts
.91ff						xt_star:
.91ff		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9202		20 90 95	jsr $9590	                jsr xt_um_star
.9205		e8		inx		                inx
.9206		e8		inx		                inx
.9207		60		rts		z_star:         rts
.9208						xt_star_slash:
.9208		20 11 92	jsr $9211	                jsr xt_star_slash_mod
.920b		20 42 92	jsr $9242	                jsr xt_swap
.920e		e8		inx		                inx
.920f		e8		inx		                inx
.9210						z_star_slash:
.9210		60		rts		                rts
.9211						xt_star_slash_mod:
.9211		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9214		20 80 93	jsr $9380	                jsr xt_to_r
.9217		20 1a 8b	jsr $8b1a	                jsr xt_m_star
.921a		20 e6 8e	jsr $8ee6	                jsr xt_r_from
.921d		20 74 91	jsr $9174	                jsr xt_sm_slash_rem
.9220						z_star_slash_mod:
.9220		60		rts		                rts
.9221						xt_state:
.9221		ca		dex		                dex
.9222		ca		dex		                dex
.9223		a9 1a		lda #$1a	                lda #<state
.9225		95 00		sta $00,x	                sta 0,x
.9227		a9 00		lda #$00	                lda #>state
.9229		95 01		sta $01,x	                sta 1,x
.922b		60		rts		z_state:        rts
.922c						xt_store:
.922c		20 a2 d7	jsr $d7a2	                jsr underflow_2
.922f		b5 02		lda $02,x	                lda 2,x         ; LSB
.9231		81 00		sta ($00,x)	                sta (0,x)
.9233		f6 00		inc $00,x	                inc 0,x
.9235		d0 02		bne $9239	                bne +
.9237		f6 01		inc $01,x	                inc 1,x
.9239						+
.9239		b5 03		lda $03,x	                lda 3,x         ; MSB
.923b		81 00		sta ($00,x)	                sta (0,x)
.923d		e8		inx		                inx             ; 2DROP
.923e		e8		inx		                inx
.923f		e8		inx		                inx
.9240		e8		inx		                inx
.9241		60		rts		z_store:        rts
.9242						xt_swap:
.9242		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9245		b5 00		lda $00,x	                lda 0,x         ; LSB
.9247		b4 02		ldy $02,x	                ldy 2,x
.9249		95 02		sta $02,x	                sta 2,x
.924b		94 00		sty $00,x	                sty 0,x
.924d		b5 01		lda $01,x	                lda 1,x         ; MSB
.924f		b4 03		ldy $03,x	                ldy 3,x
.9251		95 03		sta $03,x	                sta 3,x
.9253		94 01		sty $01,x	                sty 1,x
.9255		60		rts		z_swap:         rts
.9256						xt_tick:
.9256		20 49 8d	jsr $8d49	                jsr xt_parse_name       ; ( -- addr u )
.9259		b5 00		lda $00,x	                lda 0,x
.925b		15 01		ora $01,x	                ora 1,x
.925d		d0 05		bne $9264	                bne +
.925f		a9 05		lda #$05	                lda #err_noname
.9261		4c b3 d7	jmp $d7b3	                jmp error
.9264						+
.9264		20 03 9b	jsr $9b03	                jsr xt_find_name        ; ( addr u -- nt )
.9267		b5 00		lda $00,x	                lda 0,x
.9269		15 01		ora $01,x	                ora 1,x
.926b		d0 05		bne $9272	                bne +
.926d		a9 08		lda #$08	                lda #err_syntax
.926f		4c b3 d7	jmp $d7b3	                jmp error
.9272						+
.9272		20 41 9c	jsr $9c41	                jsr xt_name_to_int      ; ( nt -- xt )
.9275		60		rts		z_tick:         rts
.9276						xt_to:
.9276		20 56 92	jsr $9256	                jsr xt_tick             ; ( [n] xt )
.9279		b5 00		lda $00,x	                lda 0,x                 ; LSB
.927b		18		clc		                clc
.927c		69 03		adc #$03	                adc #3
.927e		85 25		sta $25		                sta tmp1
.9280		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9282		69 00		adc #$00	                adc #0                  ; we just want the carry
.9284		85 26		sta $26		                sta tmp1+1
.9286		a5 1a		lda $1a		                lda state
.9288		05 1b		ora $1b		                ora state+1
.928a		f0 14		beq $92a0	                beq _interpret
.928c		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.928e		95 00		sta $00,x	                sta 0,x
.9290		a5 26		lda $26		                lda tmp1+1
.9292		95 01		sta $01,x	                sta 1,x
.9294		20 f1 89	jsr $89f1	                jsr xt_literal      ; generate the runtime for LITERAL tmp1
.9297		a0 92		ldy #$92	                ldy #>xt_store      ; write the runtime for !
.9299		a9 2c		lda #$2c	                lda #<xt_store
.929b		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.929e		80 11		bra $92b1	                bra _done
.92a0						_interpret:
.92a0		20 a2 d7	jsr $d7a2	                jsr underflow_2
.92a3		e8		inx		                inx
.92a4		e8		inx		                inx                     ; leaving just ( n )
.92a5		b5 00		lda $00,x	                lda 0,x
.92a7		92 25		sta ($25)	                sta (tmp1)              ; LSB
.92a9		a0 01		ldy #$01	                ldy #1
.92ab		b5 01		lda $01,x	                lda 1,x                 ; MSB
.92ad		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.92af		e8		inx		                inx                     ; DROP
.92b0		e8		inx		                inx
.92b1						_done:
.92b1		60		rts		z_to:           rts
.92b2						xt_to_body:
.92b2		20 9d d7	jsr $d79d	                jsr underflow_1
.92b5		20 9f 86	jsr $869f	                jsr xt_dup              ; ( xt xt )
.92b8		20 bb 9b	jsr $9bbb	                jsr xt_int_to_name      ; ( xt nt )
.92bb		f6 00		inc $00,x	                inc 0,x
.92bd		d0 02		bne $92c1	                bne +
.92bf		f6 01		inc $01,x	                inc 1,x
.92c1						+
.92c1		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.92c3		29 20		and #$20	                and #HC
.92c5		f0 0b		beq $92d2	                beq _no_cfa
.92c7		18		clc		                clc
.92c8		b5 02		lda $02,x	                lda 2,x         ; LSB
.92ca		69 03		adc #$03	                adc #3
.92cc		95 02		sta $02,x	                sta 2,x
.92ce		90 02		bcc $92d2	                bcc _no_cfa
.92d0		f6 03		inc $03,x	                inc 3,x         ; MSB
.92d2						_no_cfa:
.92d2		e8		inx		                inx             ; get rid of the nt
.92d3		e8		inx		                inx
.92d4		60		rts		z_to_body:      rts
.92d5						xt_to_in:
.92d5		ca		dex		                dex
.92d6		ca		dex		                dex
.92d7		a9 10		lda #$10	                lda #<toin
.92d9		95 00		sta $00,x	                sta 0,x
.92db		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.92dd		95 01		sta $01,x	                sta 1,x
.92df		60		rts		z_to_in:        rts
.92e0						xt_to_number:
.92e0		20 ac d7	jsr $d7ac	                jsr underflow_4
.92e3		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.92e5		85 2d		sta $2d		                sta scratch
.92e7		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.92e9		85 2e		sta $2e		                sta scratch+1
.92eb		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.92ed		85 2f		sta $2f		                sta scratch+2
.92ef		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.92f1		85 30		sta $30		                sta scratch+3
.92f3		ca		dex		                dex
.92f4		ca		dex		                dex
.92f5						_loop:
.92f5		a1 04		lda ($04,x)	                lda (4,x)
.92f7		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.92f9		74 01		stz $01,x	                stz 1,x                 ; paranoid
.92fb		20 a7 9a	jsr $9aa7	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.92fe		b5 00		lda $00,x	                lda 0,x
.9300		d0 04		bne $9306	                bne _digit_ok
.9302		e8		inx		                inx
.9303		e8		inx		                inx
.9304		80 67		bra $936d	                bra _done       ; ( ud-lo ud-hi addr u char )
.9306						_digit_ok:
.9306		b5 02		lda $02,x	                lda 2,x
.9308		85 31		sta $31		                sta scratch+4
.930a		b5 03		lda $03,x	                lda 3,x
.930c		85 32		sta $32		                sta scratch+5
.930e		a5 2f		lda $2f		                lda scratch+2
.9310		95 02		sta $02,x	                sta 2,x         ; NOS
.9312		a5 30		lda $30		                lda scratch+3
.9314		95 03		sta $03,x	                sta 3,x
.9316		a5 18		lda $18		                lda base
.9318		95 00		sta $00,x	                sta 0,x         ; TOS
.931a		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.931c		20 90 95	jsr $9590	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.931f		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.9321		85 33		sta $33		                sta scratch+6
.9323		b5 03		lda $03,x	                lda 3,x
.9325		85 34		sta $34		                sta scratch+7
.9327		a5 2d		lda $2d		                lda scratch
.9329		95 02		sta $02,x	                sta 2,x
.932b		a5 2e		lda $2e		                lda scratch+1
.932d		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.932f		a5 18		lda $18		                lda base
.9331		95 00		sta $00,x	                sta 0,x
.9333		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.9335		20 90 95	jsr $9590	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9338		b5 00		lda $00,x	                lda 0,x
.933a		85 2f		sta $2f		                sta scratch+2
.933c		b5 01		lda $01,x	                lda 1,x
.933e		85 30		sta $30		                sta scratch+3
.9340		b5 02		lda $02,x	                lda 2,x
.9342		85 2d		sta $2d		                sta scratch
.9344		b5 03		lda $03,x	                lda 3,x
.9346		85 2e		sta $2e		                sta scratch+1
.9348		18		clc		                clc
.9349		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.934b		65 31		adc $31		                adc scratch+4   ; n LSB
.934d		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.934f		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.9351		65 32		adc $32		                adc scratch+5   ; n MSB
.9353		85 2e		sta $2e		                sta scratch+1
.9355		a5 2f		lda $2f		                lda scratch+2   ; LSB
.9357		65 33		adc $33		                adc scratch+6
.9359		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.935b		a5 30		lda $30		                lda scratch+3   ; MSB
.935d		65 34		adc $34		                adc scratch+7
.935f		85 30		sta $30		                sta scratch+3
.9361		e8		inx		                inx
.9362		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.9363		f6 04		inc $04,x	                inc 4,x
.9365		d0 02		bne $9369	                bne +
.9367		f6 05		inc $05,x	                inc 5,x
.9369						+
.9369		d6 02		dec $02,x	                dec 2,x
.936b		d0 88		bne $92f5	                bne _loop
.936d						_done:
.936d		e8		inx		                inx
.936e		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.936f		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.9371		95 06		sta $06,x	                sta 6,x
.9373		a5 2e		lda $2e		                lda scratch+1
.9375		95 07		sta $07,x	                sta 7,x
.9377		a5 2f		lda $2f		                lda scratch+2
.9379		95 04		sta $04,x	                sta 4,x
.937b		a5 30		lda $30		                lda scratch+3
.937d		95 05		sta $05,x	                sta 5,x
.937f		60		rts		z_to_number:    rts
.9380						xt_to_r:
.9380		68		pla		                pla             ; LSB
.9381		85 23		sta $23		                sta tmptos
.9383		7a		ply		                ply             ; MSB
.9384		20 9d d7	jsr $d79d	                jsr underflow_1
.9387		b5 01		lda $01,x	                lda 1,x         ; MSB
.9389		48		pha		                pha
.938a		b5 00		lda $00,x	                lda 0,x         ; LSB
.938c		48		pha		                pha
.938d		e8		inx		                inx
.938e		e8		inx		                inx
.938f		5a		phy		                phy             ; MSB
.9390		a5 23		lda $23		                lda tmptos
.9392		48		pha		                pha             ; LSB
.9393		60		rts		z_to_r:         rts
.9394						xt_true:
.9394		ca		dex		                dex
.9395		ca		dex		                dex
.9396		a9 ff		lda #$ff	                lda #$FF
.9398		95 00		sta $00,x	                sta 0,x
.939a		95 01		sta $01,x	                sta 1,x
.939c		60		rts		z_true:         rts
.939d						xt_tuck:
.939d		20 a2 d7	jsr $d7a2	                jsr underflow_2
.93a0		ca		dex		                dex
.93a1		ca		dex		                dex
.93a2		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.93a4		b5 02		lda $02,x	                lda 2,x
.93a6		95 04		sta $04,x	                sta 4,x
.93a8		94 02		sty $02,x	                sty 2,x
.93aa		95 00		sta $00,x	                sta 0,x
.93ac		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.93ae		b5 03		lda $03,x	                lda 3,x
.93b0		95 05		sta $05,x	                sta 5,x
.93b2		94 03		sty $03,x	                sty 3,x         ; bba
.93b4		95 01		sta $01,x	                sta 1,x         ; baa
.93b6		60		rts		z_tuck:         rts
.93b7						xt_two_drop:
.93b7		20 a2 d7	jsr $d7a2	                jsr underflow_2
.93ba		e8		inx		                inx
.93bb		e8		inx		                inx
.93bc		e8		inx		                inx
.93bd		e8		inx		                inx
.93be		60		rts		z_two_drop:     rts
.93bf						xt_two_dup:
.93bf		20 a2 d7	jsr $d7a2	                jsr underflow_2
.93c2		ca		dex		                dex
.93c3		ca		dex		                dex
.93c4		ca		dex		                dex
.93c5		ca		dex		                dex
.93c6		b5 04		lda $04,x	                lda 4,x         ; TOS
.93c8		95 00		sta $00,x	                sta 0,x
.93ca		b5 05		lda $05,x	                lda 5,x
.93cc		95 01		sta $01,x	                sta 1,x
.93ce		b5 06		lda $06,x	                lda 6,x         ; NOS
.93d0		95 02		sta $02,x	                sta 2,x
.93d2		b5 07		lda $07,x	                lda 7,x
.93d4		95 03		sta $03,x	                sta 3,x
.93d6		60		rts		z_two_dup:      rts
.93d7						xt_two_fetch:
.93d7		20 9d d7	jsr $d79d	                jsr underflow_1
.93da		b5 00		lda $00,x	                lda 0,x
.93dc		85 25		sta $25		                sta tmp1
.93de		b4 01		ldy $01,x	                ldy 1,x
.93e0		84 26		sty $26		                sty tmp1+1
.93e2		ca		dex		                dex             ; reuse one stack element
.93e3		ca		dex		                dex
.93e4		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.93e6		95 00		sta $00,x	                sta 0,x
.93e8		a0 01		ldy #$01	                ldy #1          ; copy next
.93ea		b1 25		lda ($25),y	                lda (tmp1),y
.93ec		95 01		sta $01,x	                sta 1,x
.93ee		c8		iny		                iny             ; copy next
.93ef		b1 25		lda ($25),y	                lda (tmp1),y
.93f1		95 02		sta $02,x	                sta 2,x
.93f3		c8		iny		                iny             ; copy next
.93f4		b1 25		lda ($25),y	                lda (tmp1),y
.93f6		95 03		sta $03,x	                sta 3,x
.93f8		60		rts		z_two_fetch:    rts
.93f9						xt_two_over:
.93f9		20 ac d7	jsr $d7ac	                jsr underflow_4
.93fc		ca		dex		                dex
.93fd		ca		dex		                dex
.93fe		ca		dex		                dex
.93ff		ca		dex		                dex
.9400		b5 08		lda $08,x	                lda 8,x
.9402		95 00		sta $00,x	                sta 0,x
.9404		b5 09		lda $09,x	                lda 9,x
.9406		95 01		sta $01,x	                sta 1,x
.9408		b5 0a		lda $0a,x	                lda 10,x
.940a		95 02		sta $02,x	                sta 2,x
.940c		b5 0b		lda $0b,x	                lda 11,x
.940e		95 03		sta $03,x	                sta 3,x
.9410		60		rts		z_two_over:     rts
.9411						xt_two_r_fetch:
.9411		ca		dex		                dex
.9412		ca		dex		                dex
.9413		ca		dex		                dex
.9414		ca		dex		                dex
.9415		8a		txa		                txa
.9416		ba		tsx		                tsx
.9417		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.9418		7a		ply		                ply
.9419		aa		tax		                tax
.941a		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.941d		95 00		sta $00,x	                sta 0,x
.941f		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.9422		95 01		sta $01,x	                sta 1,x
.9424		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.9427		95 02		sta $02,x	                sta 2,x
.9429		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.942c		95 03		sta $03,x	                sta 3,x
.942e		60		rts		z_two_r_fetch:  rts
.942f						xt_two_r_from:
.942f		68		pla		                pla                     ; LSB
.9430		85 25		sta $25		                sta tmp1
.9432		68		pla		                pla                     ; MSB
.9433		85 26		sta $26		                sta tmp1+1
.9435		ca		dex		                dex
.9436		ca		dex		                dex
.9437		ca		dex		                dex
.9438		ca		dex		                dex
.9439		68		pla		                pla                     ; LSB
.943a		95 00		sta $00,x	                sta 0,x
.943c		68		pla		                pla                     ; MSB
.943d		95 01		sta $01,x	                sta 1,x
.943f		68		pla		                pla                     ; LSB
.9440		95 02		sta $02,x	                sta 2,x
.9442		68		pla		                pla                     ; MSB
.9443		95 03		sta $03,x	                sta 3,x
.9445		a5 26		lda $26		                lda tmp1+1              ; MSB
.9447		48		pha		                pha
.9448		a5 25		lda $25		                lda tmp1                ; LSB
.944a		48		pha		                pha
.944b		60		rts		z_two_r_from:   rts
.944c						xt_two_slash:
.944c		20 9d d7	jsr $d79d	                jsr underflow_1
.944f		b5 01		lda $01,x	                lda 1,x
.9451		0a		asl a		                asl                     ; save the sign
.9452		76 01		ror $01,x	                ror 1,x
.9454		76 00		ror $00,x	                ror 0,x
.9456		60		rts		z_two_slash:    rts
.9457						xt_two_star:
.9457						xt_cells:
.9457		20 9d d7	jsr $d79d	                jsr underflow_1
.945a		16 00		asl $00,x	                asl 0,x
.945c		36 01		rol $01,x	                rol 1,x
.945e						z_cells:
.945e		60		rts		z_two_star:     rts
.945f						xt_two_store:
.945f		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9462		b5 00		lda $00,x	                lda 0,x
.9464		85 25		sta $25		                sta tmp1
.9466		b4 01		ldy $01,x	                ldy 1,x
.9468		84 26		sty $26		                sty tmp1+1
.946a		e8		inx		                inx
.946b		e8		inx		                inx
.946c		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.946e		92 25		sta ($25)	                sta (tmp1)
.9470		b5 01		lda $01,x	                lda 1,x         ; copy next
.9472		a0 01		ldy #$01	                ldy #1
.9474		91 25		sta ($25),y	                sta (tmp1),y
.9476		b5 02		lda $02,x	                lda 2,x         ; copy next
.9478		c8		iny		                iny
.9479		91 25		sta ($25),y	                sta (tmp1),y
.947b		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.947d		c8		iny		                iny
.947e		91 25		sta ($25),y	                sta (tmp1),y
.9480		e8		inx		                inx             ; 2DROP
.9481		e8		inx		                inx
.9482		e8		inx		                inx
.9483		e8		inx		                inx
.9484		60		rts		z_two_store:    rts
.9485						xt_two_swap:
.9485		20 ac d7	jsr $d7ac	                jsr underflow_4
.9488		b5 00		lda $00,x	                lda 0,x
.948a		b4 04		ldy $04,x	                ldy 4,x
.948c		95 04		sta $04,x	                sta 4,x
.948e		94 00		sty $00,x	                sty 0,x
.9490		b5 01		lda $01,x	                lda 1,x
.9492		b4 05		ldy $05,x	                ldy 5,x
.9494		95 05		sta $05,x	                sta 5,x
.9496		94 01		sty $01,x	                sty 1,x
.9498		b5 02		lda $02,x	                lda 2,x
.949a		b4 06		ldy $06,x	                ldy 6,x
.949c		95 06		sta $06,x	                sta 6,x
.949e		94 02		sty $02,x	                sty 2,x
.94a0		b5 03		lda $03,x	                lda 3,x
.94a2		b4 07		ldy $07,x	                ldy 7,x
.94a4		95 07		sta $07,x	                sta 7,x
.94a6		94 03		sty $03,x	                sty 3,x
.94a8		60		rts		z_two_swap:     rts
.94a9						xt_two_to_r:
.94a9		68		pla		                pla             ; LSB
.94aa		85 25		sta $25		                sta tmp1
.94ac		68		pla		                pla             ; MSB
.94ad		85 26		sta $26		                sta tmp1+1
.94af		20 a2 d7	jsr $d7a2	                jsr underflow_2
.94b2		b5 03		lda $03,x	                lda 3,x         ; MSB
.94b4		48		pha		                pha
.94b5		b5 02		lda $02,x	                lda 2,x         ; LSB
.94b7		48		pha		                pha
.94b8		b5 01		lda $01,x	                lda 1,x         ; MSB
.94ba		48		pha		                pha
.94bb		b5 00		lda $00,x	                lda 0,x         ; LSB
.94bd		48		pha		                pha
.94be		e8		inx		                inx
.94bf		e8		inx		                inx
.94c0		e8		inx		                inx
.94c1		e8		inx		                inx
.94c2		a5 26		lda $26		                lda tmp1+1      ; MSB
.94c4		48		pha		                pha
.94c5		a5 25		lda $25		                lda tmp1        ; LSB
.94c7		48		pha		                pha
.94c8		60		rts		z_two_to_r:     rts
.94c9						xt_type:
.94c9		20 a2 d7	jsr $d7a2	                jsr underflow_2
.94cc		b5 02		lda $02,x	                lda 2,x
.94ce		85 25		sta $25		                sta tmp1
.94d0		b5 03		lda $03,x	                lda 3,x
.94d2		85 26		sta $26		                sta tmp1+1
.94d4						_loop:
.94d4		b5 00		lda $00,x	                lda 0,x
.94d6		15 01		ora $01,x	                ora 1,x
.94d8		f0 15		beq $94ef	                beq _done
.94da		b2 25		lda ($25)	                lda (tmp1)
.94dc		20 c4 86	jsr $86c4	                jsr emit_a      ; avoids stack foolery
.94df		e6 25		inc $25		                inc tmp1
.94e1		d0 02		bne $94e5	                bne +
.94e3		e6 26		inc $26		                inc tmp1+1
.94e5						+
.94e5		b5 00		lda $00,x	                lda 0,x
.94e7		d0 02		bne $94eb	                bne +
.94e9		d6 01		dec $01,x	                dec 1,x
.94eb						+
.94eb		d6 00		dec $00,x	                dec 0,x
.94ed		80 e5		bra $94d4	                bra _loop
.94ef						_done:
.94ef		e8		inx		                inx
.94f0		e8		inx		                inx
.94f1		e8		inx		                inx
.94f2		e8		inx		                inx
.94f3		60		rts		z_type:         rts
.94f4						xt_u_dot:
.94f4		20 9d d7	jsr $d79d	                jsr underflow_1
.94f7		20 0a d8	jsr $d80a	                jsr print_u
.94fa		a9 20		lda #$20	                lda #AscSP
.94fc		20 c4 86	jsr $86c4	                jsr emit_a
.94ff		60		rts		z_u_dot:        rts
.9500						xt_u_dot_r:
.9500		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9503		20 80 93	jsr $9380	                jsr xt_to_r
.9506		20 04 9e	jsr $9e04	                jsr xt_zero
.9509		20 ce 89	jsr $89ce	                jsr xt_less_number_sign
.950c		20 ab 8c	jsr $8cab	                jsr xt_number_sign_s
.950f		20 89 8c	jsr $8c89	                jsr xt_number_sign_greater
.9512		20 e6 8e	jsr $8ee6	                jsr xt_r_from
.9515		20 fd 8c	jsr $8cfd	                jsr xt_over
.9518		20 dc 8b	jsr $8bdc	                jsr xt_minus
.951b		20 c3 91	jsr $91c3	                jsr xt_spaces
.951e		20 c9 94	jsr $94c9	                jsr xt_type
.9521		60		rts		z_u_dot_r:      rts
.9522						xt_u_greater_than:
.9522		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9525		b5 00		lda $00,x	                lda 0,x
.9527		d5 02		cmp $02,x	                cmp 2,x
.9529		b5 01		lda $01,x	                lda 1,x
.952b		f5 03		sbc $03,x	                sbc 3,x
.952d		e8		inx		                inx
.952e		e8		inx		                inx
.952f		a9 00		lda #$00	                lda #0
.9531		69 ff		adc #$ff	                adc #$FF
.9533		95 00		sta $00,x	                sta 0,x         ; store flag
.9535		95 01		sta $01,x	                sta 1,x
.9537		60		rts		z_u_greater_than:    rts
.9538						xt_u_less_than:
.9538		20 a2 d7	jsr $d7a2	                jsr underflow_2
.953b		b5 02		lda $02,x	                lda 2,x
.953d		d5 00		cmp $00,x	                cmp 0,x
.953f		b5 03		lda $03,x	                lda 3,x
.9541		f5 01		sbc $01,x	                sbc 1,x
.9543		e8		inx		                inx
.9544		e8		inx		                inx
.9545		a9 00		lda #$00	                lda #0
.9547		69 ff		adc #$ff	                adc #$FF
.9549		95 00		sta $00,x	                sta 0,x         ; store flag
.954b		95 01		sta $01,x	                sta 1,x
.954d		60		rts		z_u_less_than:    rts
.954e						xt_um_slash_mod:
.954e		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9551		b5 00		lda $00,x	                lda 0,x
.9553		15 01		ora $01,x	                ora 1,x
.9555		d0 05		bne $955c	                bne _not_zero
.9557		a9 04		lda #$04	                lda #err_divzero
.9559		4c b3 d7	jmp $d7b3	                jmp error
.955c						_not_zero:
.955c		a9 11		lda #$11	                lda #17
.955e		85 23		sta $23		                sta tmptos
.9560						_loop:
.9560		36 04		rol $04,x	                rol 4,x
.9562		36 05		rol $05,x	                rol 5,x
.9564		c6 23		dec $23		                dec tmptos
.9566		f0 22		beq $958a	                beq _done
.9568		36 02		rol $02,x	                rol 2,x
.956a		36 03		rol $03,x	                rol 3,x
.956c		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.956e		26 25		rol $25		                rol tmp1
.9570		38		sec		                sec
.9571		b5 02		lda $02,x	                lda 2,x
.9573		f5 00		sbc $00,x	                sbc 0,x
.9575		85 26		sta $26		                sta tmp1+1
.9577		b5 03		lda $03,x	                lda 3,x
.9579		f5 01		sbc $01,x	                sbc 1,x
.957b		a8		tay		                tay
.957c		a5 25		lda $25		                lda tmp1
.957e		e9 00		sbc #$00	                sbc #0
.9580		90 de		bcc $9560	                bcc _loop
.9582		a5 26		lda $26		                lda tmp1+1
.9584		95 02		sta $02,x	                sta 2,x
.9586		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.9588		80 d6		bra $9560	                bra _loop
.958a						_done:
.958a		e8		inx		                inx
.958b		e8		inx		                inx
.958c		20 42 92	jsr $9242	                jsr xt_swap
.958f		60		rts		z_um_slash_mod: rts
.9590						xt_um_star:
.9590		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9593		18		clc		                clc
.9594		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.9596		e9 00		sbc #$00	                sbc #0
.9598		85 27		sta $27		                sta tmp2
.959a		b5 01		lda $01,x	                lda 1,x
.959c		e9 00		sbc #$00	                sbc #0
.959e		90 31		bcc $95d1	                bcc _zero       ; is TOS zero?
.95a0		85 28		sta $28		                sta tmp2+1
.95a2		a9 00		lda #$00	                lda #0
.95a4		85 25		sta $25		                sta tmp1
.95a6		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.95a8		ca		dex		                dex
.95a9		ca		dex		                dex
.95aa						_outer_loop:
.95aa		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.95ac		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.95ae						_inner_loop:
.95ae		90 0c		bcc $95bc	                bcc _no_add
.95b0		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.95b2		a5 25		lda $25		                lda tmp1
.95b4		65 27		adc $27		                adc tmp2
.95b6		85 25		sta $25		                sta tmp1
.95b8		a5 26		lda $26		                lda tmp1+1
.95ba		65 28		adc $28		                adc tmp2+1
.95bc						_no_add:
.95bc		6a		ror a		                ror
.95bd		66 25		ror $25		                ror tmp1
.95bf		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.95c1		88		dey		                dey
.95c2		d0 ea		bne $95ae	                bne _inner_loop ; go back for one more shift?
.95c4		e8		inx		                inx
.95c5		e4 29		cpx $29		                cpx tmp3
.95c7		d0 e1		bne $95aa	                bne _outer_loop ; go back for eight more shifts?
.95c9		95 01		sta $01,x	                sta 1,x
.95cb		a5 25		lda $25		                lda tmp1
.95cd		95 00		sta $00,x	                sta 0,x
.95cf		80 04		bra $95d5	                bra _done
.95d1						_zero:
.95d1		74 02		stz $02,x	                stz 2,x
.95d3		74 03		stz $03,x	                stz 3,x
.95d5						_done:
.95d5		60		rts		z_um_star:      rts
.95d6						xt_unloop:
.95d6		a4 1f		ldy $1f		                ldy loopctrl
.95d8		88		dey		                dey
.95d9		88		dey		                dey
.95da		88		dey		                dey
.95db		88		dey		                dey
.95dc		84 1f		sty $1f		                sty loopctrl
.95de		30 05		bmi $95e5	                bmi z_unloop            ; no active loops?
.95e0		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.95e3		85 20		sta $20		                sta loopidx0
.95e5		60		rts		z_unloop:       rts
.95e6						xt_until:
.95e6		20 df 97	jsr $97df	                jsr cmpl_0branch_tos
.95e9		60		rts		z_until:        rts
.95ea						xt_unused:
.95ea		ca		dex		                dex
.95eb		ca		dex		                dex
.95ec		a9 00		lda #$00	                lda #<cp_end
.95ee		38		sec		                sec
.95ef		e5 00		sbc $00		                sbc cp
.95f1		95 00		sta $00,x	                sta 0,x
.95f3		a9 7c		lda #$7c	                lda #>cp_end
.95f5		e5 01		sbc $01		                sbc cp+1
.95f7		95 01		sta $01,x	                sta 1,x
.95f9		60		rts		z_unused:       rts
.95fa						xt_variable:
.95fa		20 42 84	jsr $8442	                jsr xt_create
.95fd		a9 00		lda #$00	                lda #0
.95ff		92 00		sta ($00)	                sta (cp)
.9601		e6 00		inc $00		                inc cp
.9603		d0 02		bne $9607	                bne +
.9605		e6 01		inc $01		                inc cp+1
.9607						+
.9607		92 00		sta ($00)	                sta (cp)
.9609		e6 00		inc $00		                inc cp
.960b		d0 02		bne $960f	                bne +
.960d		e6 01		inc $01		                inc cp+1
.960f						+
.960f		20 0a 84	jsr $840a	                jsr adjust_z
.9612		60		rts		z_variable:     rts
.9613						xt_while:
.9613		20 ca 97	jsr $97ca	                jsr cmpl_0branch_later          ; branch to location we'll determine later
.9616		20 42 92	jsr $9242	                jsr xt_swap
.9619		60		rts		z_while:        rts
.961a						xt_within:
.961a		20 a7 d7	jsr $d7a7	                jsr underflow_3
.961d		20 fd 8c	jsr $8cfd	                jsr xt_over
.9620		20 dc 8b	jsr $8bdc	                jsr xt_minus
.9623		20 80 93	jsr $9380	                jsr xt_to_r
.9626		20 dc 8b	jsr $8bdc	                jsr xt_minus
.9629		20 e6 8e	jsr $8ee6	                jsr xt_r_from
.962c		20 38 95	jsr $9538	                jsr xt_u_less_than
.962f		60		rts		z_within:       rts
.9630						xt_word:
.9630		20 9d d7	jsr $d79d	                jsr underflow_1
.9633		a4 10		ldy $10		                ldy toin                ; >IN
.9635						_loop:
.9635		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.9637		f0 09		beq $9642	                beq _found_char
.9639		b1 0c		lda ($0c),y	                lda (cib),y
.963b		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.963d		d0 03		bne $9642	                bne _found_char
.963f		c8		iny		                iny
.9640		80 f3		bra $9635	                bra _loop
.9642						_found_char:
.9642		84 10		sty $10		                sty toin
.9644		20 a4 8d	jsr $8da4	                jsr xt_parse            ; Returns ( addr u )
.9647		b5 00		lda $00,x	                lda 0,x
.9649		92 00		sta ($00)	                sta (cp)                ; Save length of string
.964b		48		pha		                pha                     ; Keep copy of length for later
.964c		20 9f 86	jsr $869f	                jsr xt_dup              ; ( addr u u )
.964f		a5 00		lda $00		                lda cp
.9651		18		clc		                clc
.9652		69 01		adc #$01	                adc #1
.9654		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.9656		a5 01		lda $01		                lda cp+1
.9658		69 00		adc #$00	                adc #0
.965a		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.965c		20 f8 8b	jsr $8bf8	                jsr xt_move
.965f		ca		dex		                dex
.9660		ca		dex		                dex
.9661		a5 00		lda $00		                lda cp
.9663		95 00		sta $00,x	                sta 0,x
.9665		a5 01		lda $01		                lda cp+1
.9667		95 01		sta $01,x	                sta 1,x
.9669		68		pla		                pla                     ; length of string
.966a		18		clc		                clc
.966b		65 00		adc $00		                adc cp
.966d		85 00		sta $00		                sta cp
.966f		90 02		bcc $9673	                bcc z_word
.9671		e6 01		inc $01		                inc cp+1
.9673		60		rts		z_word:         rts
.9674						xt_xor:
.9674		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9677		b5 00		lda $00,x	                lda 0,x
.9679		55 02		eor $02,x	                eor 2,x
.967b		95 02		sta $02,x	                sta 2,x
.967d		b5 01		lda $01,x	                lda 1,x
.967f		55 03		eor $03,x	                eor 3,x
.9681		95 03		sta $03,x	                sta 3,x
.9683		e8		inx		                inx
.9684		e8		inx		                inx
.9685		60		rts		z_xor:          rts
.9686						xt_zero_equal:
.9686		20 9d d7	jsr $d79d	                jsr underflow_1
.9689		b5 00		lda $00,x	                lda 0,x
.968b		15 01		ora $01,x	                ora 1,x
.968d		f0 02		beq $9691	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.968f		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.9691						_zero:
.9691		49 ff		eor #$ff	                eor #$FF        ; now just invert:
.9693		95 00		sta $00,x	                sta 0,x
.9695		95 01		sta $01,x	                sta 1,x
.9697		60		rts		z_zero_equal:   rts
.9698						xt_zero_greater:
.9698		20 9d d7	jsr $d79d	                jsr underflow_1
.969b		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.969d		b5 01		lda $01,x	                lda 1,x         ; MSB
.969f		30 05		bmi $96a6	                bmi _done       ; TOS is negative, keep FLASE
.96a1		15 00		ora $00,x	                ora 0,x
.96a3		f0 01		beq $96a6	                beq _done       ; TOS is zero, keep FALSE
.96a5		88		dey		                dey             ; TOS is postive, make true
.96a6						_done:
.96a6		98		tya		                tya
.96a7		95 00		sta $00,x	                sta 0,x
.96a9		95 01		sta $01,x	                sta 1,x
.96ab		60		rts		z_zero_greater: rts
.96ac						xt_zero_less:
.96ac		20 9d d7	jsr $d79d	                jsr underflow_1
.96af		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.96b1		b5 01		lda $01,x	                lda 1,x         ; MSB
.96b3		10 01		bpl $96b6	                bpl _done       ; TOS is positive, so keep FALSE
.96b5		88		dey		                dey             ; TOS is negative, make TRUE
.96b6						_done:
.96b6		98		tya		                tya
.96b7		95 00		sta $00,x	                sta 0,x
.96b9		95 01		sta $01,x	                sta 1,x
.96bb		60		rts		z_zero_less:    rts
.96bc						xt_zero_unequal:
.96bc		20 9d d7	jsr $d79d	                jsr underflow_1
.96bf		b5 00		lda $00,x	                lda 0,x
.96c1		15 01		ora $01,x	                ora 1,x
.96c3		f0 02		beq $96c7	                beq _zero
.96c5		a9 ff		lda #$ff	                lda #$FF
.96c7						_zero:
.96c7		95 00		sta $00,x	                sta 0,x
.96c9		95 01		sta $01,x	                sta 1,x
.96cb		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/compile.asm

.96cc						xt_compile_comma:
.96cc		20 9d d7	jsr $d79d	                jsr underflow_1
.96cf		20 9f 86	jsr $869f	                jsr xt_dup
.96d2		20 bb 9b	jsr $9bbb	                jsr xt_int_to_name
.96d5		b5 00		lda $00,x	                lda 0,x
.96d7		15 01		ora $01,x	                ora 1,x
.96d9		f0 52		beq $972d	                beq cmpl_as_call        ; No nt so unknown size; must compile as a JSR
.96db		20 9f 86	jsr $869f	                jsr xt_dup
.96de		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; status is at nt+1
.96e1		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.96e3		e8		inx		                inx                     ; drop pointer
.96e4		e8		inx		                inx
.96e5		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.96e7		29 08		and #$08	                and #NN
.96e9		d0 42		bne $972d	                bne cmpl_as_call        ; never native
.96eb		20 e3 9d	jsr $9de3	                jsr xt_wordsize
.96ee		20 4a 97	jsr $974a	                jsr check_strip_table
.96f1		a5 29		lda $29		                lda tmp3
.96f3		29 10		and #$10	                and #UF
.96f5		f0 1f		beq $9716	                beq _check_limit
.96f7		a0 02		ldy #$02	                ldy #uf_strip_offset
.96f9		b1 08		lda ($08),y	                lda (up),y
.96fb		c8		iny		                iny
.96fc		11 08		ora ($08),y	                ora (up),y
.96fe		f0 16		beq $9716	                beq _check_limit
.9700		18		clc		                clc
.9701		b5 02		lda $02,x	                lda 2,x
.9703		69 03		adc #$03	                adc #3
.9705		95 02		sta $02,x	                sta 2,x
.9707		90 02		bcc $970b	                bcc +
.9709		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.970b						+
.970b		38		sec		                sec
.970c		b5 00		lda $00,x	                lda 0,x
.970e		e9 03		sbc #$03	                sbc #3
.9710		95 00		sta $00,x	                sta 0,x
.9712		b0 02		bcs $9716	                bcs +
.9714		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.9716						+
.9716						_check_limit:
.9716		a5 29		lda $29		                lda tmp3
.9718		29 02		and #$02	                and #AN                 ; check Always Native (AN) bit
.971a		d0 1d		bne $9739	                bne cmpl_inline         ; always natively compile
.971c						cmpl_by_limit:
.971c		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.971e		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.9720		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.9722		90 15		bcc $9739	                bcc cmpl_inline         ; borrow (C=0) means size < limit
.9724		d0 07		bne $972d	                bne cmpl_as_call        ; else non-zero means size > limit
.9726		88		dey		                dey
.9727		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.9729		d5 00		cmp $00,x	                cmp 0,x
.972b		b0 0c		bcs $9739	                bcs cmpl_inline         ; not bigger, so good to go
.972d						cmpl_as_call:
.972d		e8		inx		                inx             ; either way drop TOS
.972e		e8		inx		                inx
.972f		a9 20		lda #$20	                lda #OpJSR
.9731		20 9d 97	jsr $979d	                jsr cmpl_a
.9734		20 cf 83	jsr $83cf	                jsr xt_comma
.9737		38		sec		                sec
.9738		60		rts		                rts
.9739						cmpl_inline:
.9739		20 1a 89	jsr $891a	                jsr xt_here
.973c		20 42 92	jsr $9242	                jsr xt_swap
.973f		20 9f 86	jsr $869f	                jsr xt_dup
.9742		20 29 82	jsr $8229	                jsr xt_allot            ; allocate space for the word
.9745		20 f8 8b	jsr $8bf8	                jsr xt_move
.9748		18		clc		                clc
.9749		60		rts		                rts
.974a						check_strip_table:
.974a		a0 00		ldy #$00	                ldy #0
.974c						_strip_loop:
.974c		b9 7e 97	lda $977e,y	                lda _strip_table,y       ; LSB of first word
.974f		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of xt
.9751		d0 07		bne $975a	                bne _next_entry
.9753		b9 7f 97	lda $977f,y	                lda _strip_table+1,y
.9756		d5 03		cmp $03,x	                cmp 3,x
.9758		f0 07		beq $9761	                beq _found_entry
.975a						_next_entry:
.975a		c8		iny		                iny
.975b		c8		iny		                iny
.975c		c0 0a		cpy #$0a	                cpy #_strip_table_size
.975e		d0 ec		bne $974c	                bne _strip_loop
.9760		60		rts		                rts
.9761						_found_entry:
.9761		98		tya		                tya
.9762		4a		lsr a		                lsr
.9763		a8		tay		                tay
.9764		b9 88 97	lda $9788,y	                lda _strip_size,y
.9767		48		pha		                pha                     ; save a copy
.9768		18		clc		                clc
.9769		75 02		adc $02,x	                adc 2,x
.976b		95 02		sta $02,x	                sta 2,x
.976d		90 02		bcc $9771	                bcc +
.976f		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.9771						+
.9771		68		pla		                pla
.9772		0a		asl a		                asl a                   ; Double to cut off both top and bottom.
.9773		f5 00		sbc $00,x	                sbc 0,x
.9775		49 ff		eor #$ff	                eor #$ff
.9777		95 00		sta $00,x	                sta 0,x
.9779		90 02		bcc $977d	                bcc +                   ; note inverted carry check
.977b		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.977d						+
.977d		60		rts		                rts
.977e						_strip_table:
>977e		e6 8e d1 8e 80 93		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>9784		a9 94 2f 94			                .word xt_two_to_r, xt_two_r_from        ; 2>R, 2R>
=10						_strip_table_size = * - _strip_table
.9788						_strip_size:
>9788		04 04 04			                .byte 4, 4, 4                           ; R>, R@, >R
>978b		06 06				                .byte 6, 6                              ; 2>R, 2R>
.978d						z_compile_comma:
.978d						cmpl_subroutine:
.978d		48		pha		                pha             ; save LSB of address
.978e		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR
.9790		80 03		bra $9795	                bra +
.9792						cmpl_jump:
.9792		48		pha		                pha             ; save LSB of address
.9793		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP, fall thru
.9795						+
.9795		20 9d 97	jsr $979d	                jsr cmpl_a      ; compile opcode
.9798		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.9799						cmpl_word:
.9799		20 9d 97	jsr $979d	                jsr cmpl_a      ; compile LSB of address
.979c		98		tya		                tya             ; fall thru for MSB
.979d						cmpl_a:
.979d		92 00		sta ($00)	                sta (cp)
.979f		e6 00		inc $00		                inc cp
.97a1		d0 02		bne $97a5	                bne _done
.97a3		e6 01		inc $01		                inc cp+1
.97a5						_done:
.97a5		60		rts		                rts
.97a6						cmpl_jump_tos:
.97a6		a9 4c		lda #$4c	                lda #OpJMP
.97a8		20 9d 97	jsr $979d	                jsr cmpl_a
.97ab		4c cf 83	jmp $83cf	                jmp xt_comma
.97ae						cmpl_jump_later:
.97ae		a9 4c		lda #$4c	                lda #OpJMP
.97b0		20 9d 97	jsr $979d	                jsr cmpl_a
.97b3		20 1a 89	jsr $891a	                jsr xt_here
.97b6		80 e1		bra $9799	                bra cmpl_word
.97b8						check_nc_limit:
.97b8		48		pha		                pha
.97b9		38		sec		                sec
.97ba		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.97bc		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're good, leave with C=0
.97be		f0 01		beq $97c1	                beq +
.97c0		18		clc		                clc
.97c1						+
.97c1		68		pla		                pla
.97c2		90 05		bcc $97c9	                bcc _done
.97c4		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.97c5		88		dey		                dey
.97c6		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.97c8		1a		inc a		                ina                     ; restore A, preserves carry
.97c9						_done:
.97c9		60		rts		                rts
.97ca						cmpl_0branch_later:
.97ca		20 04 9e	jsr $9e04	                jsr xt_zero             ; dummy placeholder, which forces long jmp in native version
.97cd		20 df 97	jsr $97df	                jsr cmpl_0branch_tos    ; generate native or subroutine branch code
.97d0		20 1a 89	jsr $891a	                jsr xt_here             ; either way the target address is two bytes before here
.97d3		38		sec		                sec
.97d4		b5 00		lda $00,x	                lda 0,x
.97d6		e9 02		sbc #$02	                sbc #2
.97d8		95 00		sta $00,x	                sta 0,x
.97da		b0 02		bcs $97de	                bcs +
.97dc		d6 01		dec $01,x	                dec 1,x
.97de						+
.97de		60		rts		                rts
.97df						cmpl_0branch_tos:
.97df		a9 0b		lda #$0b	                lda #ztest_runtime_size+5       ; typical size of inline form
.97e1		20 b8 97	jsr $97b8	                jsr check_nc_limit              ; returns C=0 if we should native compile
.97e4		90 0a		bcc $97f0	                bcc _inline
.97e6		a0 98		ldy #$98	                ldy #>zero_branch_runtime
.97e8		a9 41		lda #$41	                lda #<zero_branch_runtime
.97ea		20 8d 97	jsr $978d	                jsr cmpl_subroutine             ; call the 0branch runtime
.97ed		4c cf 83	jmp $83cf	                jmp xt_comma                    ; add the payload and return
.97f0						_inline:
.97f0		a0 00		ldy #$00	                ldy #0
.97f2						-
.97f2		b9 41 98	lda $9841,y	                lda ztest_runtime,y
.97f5		20 9d 97	jsr $979d	                jsr cmpl_a
.97f8		c8		iny		                iny
.97f9		c0 06		cpy #$06	                cpy #ztest_runtime_size
.97fb		d0 f5		bne $97f2	                bne -
.97fd		b5 00		lda $00,x	                lda 0,x
.97ff		15 01		ora $01,x	                ora 1,x
.9801		f0 31		beq $9834	                beq _long               ; always use the long form if target is 0
.9803		20 9f 86	jsr $869f	                jsr xt_dup
.9806		20 1a 89	jsr $891a	                jsr xt_here
.9809		18		clc		                clc
.980a		a9 02		lda #$02	                lda #2
.980c		75 00		adc $00,x	                adc 0,x
.980e		95 00		sta $00,x	                sta 0,x
.9810		90 02		bcc $9814	                bcc +
.9812		f6 01		inc $01,x	                inc 1,x
.9814						+
.9814		20 dc 8b	jsr $8bdc	                jsr xt_minus
.9817		e8		inx		                inx             ; pre-drop offset and use wraparound indexing to preserve flags
.9818		e8		inx		                inx
.9819		b5 ff		lda $ff,x	                lda $ff,x
.981b		a8		tay		                tay             ; Y=MSB of offset
.981c		b5 fe		lda $fe,x	                lda $fe,x       ; A=LSB, setting N flag to bit 7
.981e		30 04		bmi $9824	                bmi _minus
.9820		c0 00		cpy #$00	                cpy #0          ; if LSB is positive we need MSB = 0
.9822		80 02		bra $9826	                bra +
.9824		c0 ff		cpy #$ff	_minus:         cpy #$ff        ; if LSB is negative we need MSB = ff
.9826		d0 0c		bne $9834	+               bne _long
.9828		a9 f0		lda #$f0	                lda #OpBEQ
.982a		20 9d 97	jsr $979d	                jsr cmpl_a
.982d		b5 fe		lda $fe,x	                lda $fe,x
.982f		e8		inx		                inx             ; drop the original address we used to calc offset
.9830		e8		inx		                inx
.9831		4c 9d 97	jmp $979d	                jmp cmpl_a
.9834						_long:
.9834		a9 d0		lda #$d0	                lda #OpBNE
.9836		20 9d 97	jsr $979d	                jsr cmpl_a
.9839		a9 03		lda #$03	                lda #3
.983b		20 9d 97	jsr $979d	                jsr cmpl_a
.983e		4c a6 97	jmp $97a6	                jmp cmpl_jump_tos
.9841						zero_branch_runtime:
.9841						ztest_runtime:
.9841		e8		inx		                inx
.9842		e8		inx		                inx
.9843		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.9845		15 ff		ora $ff,x	                ora $FF,x
=6						ztest_runtime_size = * - ztest_runtime
.9847						zbranch_runtime:
.9847		7a		ply		                ply
.9848		84 25		sty $25		                sty tmp1
.984a		7a		ply		                ply
.984b		84 26		sty $26		                sty tmp1+1
.984d		a8		tay		                tay             ; test if A = 0 which tells us whether to branch
.984e		f0 0d		beq $985d	                beq _branch
.9850		18		clc		                clc
.9851		a5 25		lda $25		                lda tmp1        ; LSB
.9853		69 03		adc #$03	                adc #3          ; skip two bytes plus the extra for jsr/rts behavior
.9855		85 25		sta $25		                sta tmp1
.9857		90 11		bcc $986a	                bcc _jmp
.9859		e6 26		inc $26		                inc tmp1+1
.985b		80 0d		bra $986a	                bra _jmp
.985d						_branch:
.985d		a0 01		ldy #$01	                ldy #1
.985f		b1 25		lda ($25),y	                lda (tmp1),y
.9861		48		pha		                pha                     ; stash the LSB until we've read the MSB too
.9862		c8		iny		                iny
.9863		b1 25		lda ($25),y	                lda (tmp1),y
.9865		85 26		sta $26		                sta tmp1+1              ; update tmp1 with our branch target
.9867		68		pla		                pla
.9868		85 25		sta $25		                sta tmp1
.986a						_jmp:
.986a		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.986d						xt_bye:
.986d		4c 31 f0	jmp $f031	                jmp kernel_bye
.9870						z_bye:
.9870						xt_dot_s:
.9870		20 54 85	jsr $8554	                jsr xt_depth    ; ( -- u )
.9873		a9 3c		lda #$3c	                lda #'<'
.9875		20 c4 86	jsr $86c4	                jsr emit_a
.9878		b5 00		lda $00,x	                lda 0,x
.987a		48		pha		                pha
.987b		ca		dex		                dex             ; DUP
.987c		ca		dex		                dex
.987d		95 00		sta $00,x	                sta 0,x
.987f		74 01		stz $01,x	                stz 1,x
.9881		20 0a d8	jsr $d80a	                jsr print_u
.9884		a9 3e		lda #$3e	                lda #'>'
.9886		20 c4 86	jsr $86c4	                jsr emit_a
.9889		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.988b		20 c4 86	jsr $86c4	                jsr emit_a
.988e		e8		inx		                inx
.988f		e8		inx		                inx
.9890		e0 78		cpx #$78	                cpx #dsp0
.9892		f0 1e		beq $98b2	                beq _done
.9894		7a		ply		                ply
.9895		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.9897		85 29		sta $29		                sta tmp3
.9899		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.989b						_loop:
.989b		ca		dex		                dex
.989c		ca		dex		                dex
.989d		b2 29		lda ($29)	                lda (tmp3)
.989f		95 01		sta $01,x	                sta 1,x
.98a1		c6 29		dec $29		                dec tmp3
.98a3		b2 29		lda ($29)	                lda (tmp3)
.98a5		95 00		sta $00,x	                sta 0,x
.98a7		c6 29		dec $29		                dec tmp3
.98a9		5a		phy		                phy
.98aa		20 2f 86	jsr $862f	                jsr xt_dot
.98ad		7a		ply		                ply
.98ae		88		dey		                dey
.98af		d0 ea		bne $989b	                bne _loop
.98b1		48		pha		                pha             ; dummy to balance stack
.98b2						_done:
.98b2		68		pla		                pla
.98b3		60		rts		z_dot_s:        rts
.98b4						xt_dump:
.98b4		20 a2 d7	jsr $d7a2	                jsr underflow_2
.98b7						_row:
.98b7		a0 10		ldy #$10	                ldy #16
.98b9		64 27		stz $27		                stz tmp2
.98bb		20 3c 84	jsr $843c	                jsr xt_cr
.98be		b5 03		lda $03,x	                lda 3,x
.98c0		20 68 d6	jsr $d668	                jsr byte_to_ascii
.98c3		b5 02		lda $02,x	                lda 2,x
.98c5		20 68 d6	jsr $d668	                jsr byte_to_ascii
.98c8		20 bd 91	jsr $91bd	                jsr xt_space
.98cb		20 bd 91	jsr $91bd	                jsr xt_space
.98ce						_loop:
.98ce		b5 00		lda $00,x	                lda 0,x
.98d0		15 01		ora $01,x	                ora 1,x
.98d2		f0 39		beq $990d	                beq _all_printed
.98d4		a1 02		lda ($02,x)	                lda (2,x)
.98d6		48		pha		                pha                     ; byte_to_ascii destroys A
.98d7		20 68 d6	jsr $d668	                jsr byte_to_ascii
.98da		20 bd 91	jsr $91bd	                jsr xt_space
.98dd		68		pla		                pla
.98de		20 83 d7	jsr $d783	                jsr is_printable
.98e1		b0 02		bcs $98e5	                bcs _printable
.98e3		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.98e5						_printable:
.98e5		5a		phy		                phy                     ; save counter
.98e6		a4 27		ldy $27		                ldy tmp2
.98e8		91 00		sta ($00),y	                sta (cp),y
.98ea		e6 27		inc $27		                inc tmp2
.98ec		7a		ply		                ply
.98ed		c0 09		cpy #$09	                cpy #9
.98ef		d0 03		bne $98f4	                bne _next_char
.98f1		20 bd 91	jsr $91bd	                jsr xt_space
.98f4						_next_char:
.98f4		f6 02		inc $02,x	                inc 2,x
.98f6		d0 02		bne $98fa	                bne _counter
.98f8		f6 03		inc $03,x	                inc 3,x
.98fa						_counter:
.98fa		b5 00		lda $00,x	                lda 0,x
.98fc		d0 02		bne $9900	                bne +
.98fe		d6 01		dec $01,x	                dec 1,x
.9900						+
.9900		d6 00		dec $00,x	                dec 0,x
.9902		88		dey		                dey
.9903		d0 c9		bne $98ce	                bne _loop               ; next byte
.9905		20 bd 91	jsr $91bd	                jsr xt_space
.9908		20 1b 99	jsr $991b	                jsr dump_print_ascii
.990b		80 aa		bra $98b7	                bra _row                ; new row
.990d						_all_printed:
.990d		a5 27		lda $27		                lda tmp2
.990f		f0 06		beq $9917	                beq _done
.9911		20 bd 91	jsr $91bd	                jsr xt_space
.9914		20 1b 99	jsr $991b	                jsr dump_print_ascii
.9917						_done:
.9917		20 b7 93	jsr $93b7	                jsr xt_two_drop         ; one byte less than 4x INX
.991a		60		rts		z_dump:         rts
.991b						dump_print_ascii:
.991b		a0 00		ldy #$00	                ldy #0
.991d						_ascii_loop:
.991d		b1 00		lda ($00),y	                lda (cp),y
.991f		20 c4 86	jsr $86c4	                jsr emit_a
.9922		c8		iny		                iny
.9923		c0 08		cpy #$08	                cpy #8
.9925		d0 03		bne $992a	                bne +
.9927		20 bd 91	jsr $91bd	                jsr xt_space
.992a						+
.992a		c6 27		dec $27		                dec tmp2
.992c		d0 ef		bne $991d	                bne _ascii_loop
.992e		60		rts		                rts
.992f						xt_question:
.992f		20 19 88	jsr $8819	                jsr xt_fetch
.9932		20 2f 86	jsr $862f	                jsr xt_dot
.9935		60		rts		z_question:     rts
.9936						xt_see:
.9936		20 49 8d	jsr $8d49	                jsr xt_parse_name       ; ( addr u )
.9939		20 03 9b	jsr $9b03	                jsr xt_find_name        ; ( nt | 0 )
.993c		b5 00		lda $00,x	                lda 0,x
.993e		15 01		ora $01,x	                ora 1,x
.9940		d0 05		bne $9947	                bne +
.9942		a9 05		lda #$05	                lda #err_noname
.9944		4c b3 d7	jmp $d7b3	                jmp error
.9947						+
.9947		20 3c 84	jsr $843c	                jsr xt_cr
.994a		a5 18		lda $18		                lda base
.994c		48		pha		                pha
.994d		20 25 89	jsr $8925	                jsr xt_hex
.9950		a9 09		lda #$09	                lda #str_see_nt
.9952		20 d9 d7	jsr $d7d9	                jsr print_string_no_lf
.9955		20 9f 86	jsr $869f	                jsr xt_dup              ; ( nt nt )
.9958		20 f4 94	jsr $94f4	                jsr xt_u_dot
.995b		20 bd 91	jsr $91bd	                jsr xt_space            ; ( nt )
.995e		20 9f 86	jsr $869f	                jsr xt_dup              ; ( nt nt )
.9961		20 41 9c	jsr $9c41	                jsr xt_name_to_int      ; ( nt xt )
.9964		a9 0a		lda #$0a	                lda #str_see_xt
.9966		20 d9 d7	jsr $d7d9	                jsr print_string_no_lf
.9969		20 9f 86	jsr $869f	                jsr xt_dup              ; ( nt xt xt )
.996c		20 f4 94	jsr $94f4	                jsr xt_u_dot
.996f		20 3c 84	jsr $843c	                jsr xt_cr               ; ( nt xt )
.9972		a9 08		lda #$08	                lda #str_see_flags
.9974		20 d9 d7	jsr $d7d9	                jsr print_string_no_lf
.9977		20 fd 8c	jsr $8cfd	                jsr xt_over             ; ( nt xt nt )
.997a		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; ( nt xt nt+1 )
.997d		20 19 88	jsr $8819	                jsr xt_fetch            ; ( nt xt flags )
.9980		b5 00		lda $00,x	                lda 0,x
.9982		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9984						_flag_loop:
.9984		48		pha		                pha
.9985		29 01		and #$01	                and #%00000001
.9987		18		clc		                clc
.9988		69 30		adc #$30	                adc #'0'
.998a		20 c4 86	jsr $86c4	                jsr emit_a
.998d		20 bd 91	jsr $91bd	                jsr xt_space
.9990		68		pla		                pla
.9991		6a		ror a		                ror                     ; Next flag
.9992		88		dey		                dey
.9993		d0 ef		bne $9984	                bne _flag_loop
.9995		20 3c 84	jsr $843c	                jsr xt_cr
.9998		e8		inx		                inx
.9999		e8		inx		                inx                     ; ( nt xt )
.999a		a9 0b		lda #$0b	                lda #str_see_size
.999c		20 d9 d7	jsr $d7d9	                jsr print_string_no_lf
.999f		20 42 92	jsr $9242	                jsr xt_swap             ; ( xt nt )
.99a2		20 e3 9d	jsr $9de3	                jsr xt_wordsize         ; ( xt u )
.99a5		20 9f 86	jsr $869f	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.99a8		20 0c 85	jsr $850c	                jsr xt_decimal
.99ab		20 f4 94	jsr $94f4	                jsr xt_u_dot            ; ( xt u )
.99ae		20 25 89	jsr $8925	                jsr xt_hex
.99b1		20 3c 84	jsr $843c	                jsr xt_cr
.99b4		20 bf 93	jsr $93bf	                jsr xt_two_dup          ; ( xt u xt u )
.99b7		20 b4 98	jsr $98b4	                jsr xt_dump
.99ba		20 3c 84	jsr $843c	                jsr xt_cr
.99bd		20 b1 a1	jsr $a1b1	                jsr xt_disasm
.99c0		68		pla		                pla
.99c1		85 18		sta $18		                sta base
.99c3		60		rts		z_see:          rts
.99c4						xt_words:
.99c4		20 3c 84	jsr $843c	                jsr xt_cr
.99c7		a9 00		lda #$00	                lda #0
.99c9		48		pha		                pha
.99ca		ca		dex		                dex                     ; Make room on the stack for
.99cb		ca		dex		                dex                     ; a dictionary pointer.
.99cc		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.99ce						_wordlist_loop:
.99ce		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.99d0		a5 29		lda $29		                lda tmp3
.99d2		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.99d4		d0 02		bne $99d8	                bne _have_wordlist
.99d6		80 45		bra $9a1d	                bra _words_done
.99d8						_have_wordlist:
.99d8		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.99d9		69 23		adc #$23	                adc #search_order_offset
.99db		a8		tay		                tay
.99dc		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.99de		0a		asl a		                asl                     ; Turn offset into cells offset.
.99df		18		clc		                clc
.99e0		69 0a		adc #$0a	                adc #wordlists_offset
.99e2		a8		tay		                tay
.99e3		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.99e5		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.99e7		c8		iny		                iny
.99e8		b1 08		lda ($08),y	                lda (up),y
.99ea		95 01		sta $01,x	                sta 1,x
.99ec						_loop:
.99ec		20 9f 86	jsr $869f	                jsr xt_dup              ; ( nt nt )
.99ef		20 5e 9c	jsr $9c5e	                jsr xt_name_to_string   ; ( nt addr u )
.99f2		68		pla		                pla
.99f3		18		clc		                clc
.99f4		75 00		adc $00,x	                adc 0,x
.99f6		1a		inc a		                ina                     ; don't forget the space between words
.99f7		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.99f9		90 06		bcc $9a01	                bcc +
.99fb		20 3c 84	jsr $843c	                jsr xt_cr
.99fe		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.9a00		1a		inc a		                ina                     ; with length of this word.
.9a01						+
.9a01		48		pha		                pha
.9a02		20 c9 94	jsr $94c9	                jsr xt_type             ; ( nt )
.9a05		a9 20		lda #$20	                lda #AscSP
.9a07		20 c4 86	jsr $86c4	                jsr emit_a
.9a0a		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+
.9a0d		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+
.9a10		20 19 88	jsr $8819	                jsr xt_fetch            ; @ ( nt+1 )
.9a13		b5 00		lda $00,x	                lda 0,x
.9a15		15 01		ora $01,x	                ora 1,x
.9a17		d0 d3		bne $99ec	                bne _loop
.9a19		e6 29		inc $29		                inc tmp3
.9a1b		80 b1		bra $99ce	                bra _wordlist_loop
.9a1d						_words_done:
.9a1d		68		pla		                pla                     ; dump counter
.9a1e		e8		inx		                inx
.9a1f		e8		inx		                inx
.9a20		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.9a21						xt_allow_native:
.9a21		20 f4 d6	jsr $d6f4	                jsr current_to_dp
.9a24		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a26		b1 02		lda ($02),y	                lda (dp),y
.9a28		29 f5		and #$f5	                and #$FF-NN-AN  ; AN and NN flag is clear.
.9a2a		91 02		sta ($02),y	                sta (dp),y
.9a2c						z_allow_native:
.9a2c		60		rts		                rts
.9a2d						xt_always_native:
.9a2d		20 f4 d6	jsr $d6f4	                jsr current_to_dp
.9a30		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a32		b1 02		lda ($02),y	                lda (dp),y
.9a34		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.9a36		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9a38		91 02		sta ($02),y	                sta (dp),y
.9a3a						z_always_native:
.9a3a		60		rts		                rts
.9a3b						xt_bell:
.9a3b		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.9a3d		20 c4 86	jsr $86c4	                jsr emit_a
.9a40		60		rts		z_bell:         rts
.9a41						xt_bounds:
.9a41		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9a44		18		clc		                clc
.9a45		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9a47		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9a49		75 02		adc $02,x	                adc 2,x
.9a4b		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9a4d		94 00		sty $00,x	                sty 0,x
.9a4f		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9a51		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9a53		75 03		adc $03,x	                adc 3,x
.9a55		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9a57		94 01		sty $01,x	                sty 1,x
.9a59		60		rts		z_bounds:       rts
.9a5a						xt_cleave:
.9a5a		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9a5d		20 30 a0	jsr $a030	                jsr xt_minus_leading    ; -LEADING ( addr u )
.9a60		20 a5 9b	jsr $9ba5	                jsr xt_input_to_r       ; save old imput state
.9a63		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9a65		85 0e		sta $0e		                sta ciblen
.9a67		b5 01		lda $01,x	                lda 1,x
.9a69		85 0f		sta $0f		                sta ciblen+1
.9a6b		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9a6d		85 0c		sta $0c		                sta cib
.9a6f		b5 03		lda $03,x	                lda 3,x
.9a71		85 0d		sta $0d		                sta cib+1
.9a73		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9a75		64 11		stz $11		                stz toin+1
.9a77		20 49 8d	jsr $8d49	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.9a7a		b5 00		lda $00,x	                lda 0,x
.9a7c		15 01		ora $01,x	                ora 1,x
.9a7e		f0 23		beq $9aa3	                beq _done
.9a80		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9a82		38		sec		                sec
.9a83		f5 00		sbc $00,x	                sbc 0,x
.9a85		95 04		sta $04,x	                sta 4,x
.9a87		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9a89		f5 01		sbc $01,x	                sbc 1,x
.9a8b		95 05		sta $05,x	                sta 5,x
.9a8d		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9a8f		18		clc		                clc
.9a90		75 00		adc $00,x	                adc 0,x
.9a92		95 06		sta $06,x	                sta 6,x
.9a94		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9a96		75 01		adc $01,x	                adc 1,x
.9a98		95 07		sta $07,x	                sta 7,x
.9a9a		20 85 94	jsr $9485	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.9a9d		20 30 a0	jsr $a030	                jsr xt_minus_leading
.9aa0		20 85 94	jsr $9485	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.9aa3						_done:
.9aa3		20 b2 9d	jsr $9db2	                jsr xt_r_to_input
.9aa6		60		rts		z_cleave:       rts
.9aa7						xt_digit_question:
.9aa7		20 9d d7	jsr $d79d	                jsr underflow_1
.9aaa		ca		dex		                dex
.9aab		ca		dex		                dex
.9aac		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9aae		74 01		stz $01,x	                stz 1,x
.9ab0		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9ab2		b5 02		lda $02,x	                lda 2,x
.9ab4		c9 30		cmp #$30	                cmp #'0'
.9ab6		90 23		bcc $9adb	                bcc _done               ; failure flag already set
.9ab8		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9aba		90 12		bcc $9ace	                bcc _checkbase
.9abc		c9 41		cmp #$41	                cmp #'A'
.9abe		90 1b		bcc $9adb	                bcc _done               ; failure flag is already set
.9ac0		c9 61		cmp #$61	                cmp #'a'
.9ac2		90 07		bcc $9acb	                bcc _case_done          ; not lower case, too low
.9ac4		c9 7b		cmp #$7b	                cmp #'z'+1
.9ac6		b0 03		bcs $9acb	                bcs _case_done          ; not lower case, too high
.9ac8		18		clc		                clc                     ; just right
.9ac9		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9acb						_case_done:
.9acb		38		sec		                sec
.9acc		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9ace						_checkbase:
.9ace		38		sec		                sec
.9acf		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9ad1		c5 18		cmp $18		                cmp base
.9ad3		b0 06		bcs $9adb	                bcs _done               ; already have false flag
.9ad5		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9ad7		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9ad9		d6 01		dec $01,x	                dec 1,x
.9adb						_done:
.9adb						z_digit_question:
.9adb		60		rts		                rts
.9adc						xt_execute_parsing:
.9adc		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9adf		20 a5 9b	jsr $9ba5	                jsr xt_input_to_r       ; save normal input for later
.9ae2		20 88 9c	jsr $9c88	                jsr xt_not_rote         ; -ROT ( xt addr u )
.9ae5		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9ae7		85 0e		sta $0e		                sta ciblen
.9ae9		b5 01		lda $01,x	                lda 1,x
.9aeb		85 0f		sta $0f		                sta ciblen+1
.9aed		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9aef		85 0c		sta $0c		                sta cib
.9af1		b5 03		lda $03,x	                lda 3,x
.9af3		85 0d		sta $0d		                sta cib+1
.9af5		64 10		stz $10		                stz toin                ; Set >IN to zero
.9af7		64 11		stz $11		                stz toin+1
.9af9		20 b7 93	jsr $93b7	                jsr xt_two_drop         ; 2DROP ( xt )
.9afc		20 04 88	jsr $8804	                jsr xt_execute
.9aff		20 b2 9d	jsr $9db2	                jsr xt_r_to_input
.9b02						z_execute_parsing:
.9b02		60		rts		                rts
.9b03						xt_find_name:
.9b03		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9b06		b5 00		lda $00,x	                lda 0,x
.9b08		15 01		ora $01,x	                ora 1,x
.9b0a		d0 03		bne $9b0f	                bne _nonempty
.9b0c		4c 40 9b	jmp $9b40	                jmp _fail_done
.9b0f						_nonempty:
.9b0f		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9b11						_wordlist_loop:
.9b11		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9b13		a5 29		lda $29		                lda tmp3
.9b15		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9b17		f0 27		beq $9b40	                beq _fail_done
.9b19		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9b1a		69 23		adc #$23	                adc #search_order_offset
.9b1c		a8		tay		                tay
.9b1d		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9b1f		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b20		18		clc		                clc
.9b21		69 0a		adc #$0a	                adc #wordlists_offset
.9b23		a8		tay		                tay
.9b24		b1 08		lda ($08),y	                lda (up),y
.9b26		85 25		sta $25		                sta tmp1
.9b28		c8		iny		                iny
.9b29		b1 08		lda ($08),y	                lda (up),y
.9b2b		85 26		sta $26		                sta tmp1+1
.9b2d		20 7f d6	jsr $d67f	                jsr find_header_name
.9b30		d0 04		bne $9b36	                bne _success
.9b32		e6 29		inc $29		                inc tmp3
.9b34		80 db		bra $9b11	                bra _wordlist_loop
.9b36						_success:
.9b36		a5 25		lda $25		                lda tmp1
.9b38		95 02		sta $02,x	                sta 2,x
.9b3a		a5 26		lda $26		                lda tmp1+1
.9b3c		95 03		sta $03,x	                sta 3,x
.9b3e		80 04		bra $9b44	                bra _done
.9b40						_fail_done:
.9b40		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b42		74 03		stz $03,x	                stz 3,x
.9b44						_done:
.9b44		e8		inx		                inx
.9b45		e8		inx		                inx
.9b46		60		rts		z_find_name:    rts
.9b47						xt_hexstore:
.9b47		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9b4a		20 9f 86	jsr $869f	                jsr xt_dup              ; Save copy of original address
.9b4d		20 a9 94	jsr $94a9	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b50						_loop:
.9b50		b5 00		lda $00,x	                lda 0,x
.9b52		15 01		ora $01,x	                ora 1,x
.9b54		f0 36		beq $9b8c	                beq _done
.9b56		20 5a 9a	jsr $9a5a	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9b59		20 a9 94	jsr $94a9	                jsr xt_two_to_r
.9b5c		20 04 9e	jsr $9e04	                jsr xt_zero
.9b5f		20 04 9e	jsr $9e04	                jsr xt_zero
.9b62		20 2f 94	jsr $942f	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9b65		20 e0 92	jsr $92e0	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9b68		b5 00		lda $00,x	                lda 0,x
.9b6a		15 01		ora $01,x	                ora 1,x
.9b6c		d0 17		bne $9b85	                bne _have_chars_left
.9b6e		20 b7 93	jsr $93b7	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9b71		20 4d 9e	jsr $9e4d	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9b74		20 d1 8e	jsr $8ed1	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9b77		20 39 83	jsr $8339	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b7a		20 e6 8e	jsr $8ee6	                jsr xt_r_from           ; R>
.9b7d		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+
.9b80		20 80 93	jsr $9380	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9b83		80 cb		bra $9b50	                bra _loop
.9b85						_have_chars_left:
.9b85		8a		txa		                txa
.9b86		18		clc		                clc
.9b87		69 08		adc #$08	                adc #8
.9b89		aa		tax		                tax
.9b8a		80 c4		bra $9b50	                bra _loop
.9b8c						_done:
.9b8c		e8		inx		                inx
.9b8d		e8		inx		                inx
.9b8e		e8		inx		                inx
.9b8f		e8		inx		                inx                     ; 2DROP
.9b90		20 2f 94	jsr $942f	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9b93		20 42 92	jsr $9242	                jsr xt_swap
.9b96		20 dc 8b	jsr $8bdc	                jsr xt_minus            ; ( n )
.9b99		60		rts		z_hexstore:     rts
.9b9a						xt_input:
.9b9a		ca		dex		                dex
.9b9b		ca		dex		                dex
.9b9c		a9 14		lda #$14	                lda #<input
.9b9e		95 00		sta $00,x	                sta 0,x
.9ba0		a9 00		lda #$00	                lda #>input
.9ba2		95 01		sta $01,x	                sta 1,x
.9ba4		60		rts		z_input:        rts
.9ba5						xt_input_to_r:
.9ba5		68		pla		                pla
.9ba6		85 25		sta $25		                sta tmp1
.9ba8		68		pla		                pla
.9ba9		85 26		sta $26		                sta tmp1+1
.9bab		a0 07		ldy #$07	                ldy #7
.9bad						_loop:
.9bad		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9bb0		48		pha		                pha
.9bb1		88		dey		                dey
.9bb2		10 f9		bpl $9bad	                bpl _loop
.9bb4		a5 26		lda $26		                lda tmp1+1
.9bb6		48		pha		                pha
.9bb7		a5 25		lda $25		                lda tmp1
.9bb9		48		pha		                pha
.9bba		60		rts		z_input_to_r: 	rts
.9bbb						xt_int_to_name:
.9bbb		20 9d d7	jsr $d79d	                jsr underflow_1
.9bbe		ca		dex		                dex
.9bbf		ca		dex		                dex
.9bc0		74 00		stz $00,x	                stz 0,x
.9bc2		74 01		stz $01,x	                stz 1,x
.9bc4						_wordlist_loop:
.9bc4		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9bc6		0a		asl a		                asl                     ; Turn offset into cells offset.
.9bc7		18		clc		                clc
.9bc8		69 0a		adc #$0a	                adc #wordlists_offset
.9bca		a8		tay		                tay
.9bcb		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9bcd		85 27		sta $27		                sta tmp2                ; into tmp2
.9bcf		c8		iny		                iny
.9bd0		b1 08		lda ($08),y	                lda (up),y
.9bd2		85 28		sta $28		                sta tmp2+1
.9bd4		a5 27		lda $27		                lda tmp2
.9bd6		05 28		ora $28		                ora tmp2+1
.9bd8		f0 36		beq $9c10	                beq _next_wordlist
.9bda		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9bdc		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9bde		b5 03		lda $03,x	                lda 3,x
.9be0		85 2a		sta $2a		                sta tmp3+1
.9be2						_loop:
.9be2		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9be4		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9be6		c5 29		cmp $29		                cmp tmp3
.9be8		d0 07		bne $9bf1	                bne _no_match
.9bea		c8		iny		                iny
.9beb		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9bed		c5 2a		cmp $2a		                cmp tmp3+1
.9bef		f0 30		beq $9c21	                beq _match
.9bf1						_no_match:
.9bf1		18		clc		                clc
.9bf2		a5 27		lda $27		                lda tmp2
.9bf4		69 02		adc #$02	                adc #2
.9bf6		85 27		sta $27		                sta tmp2
.9bf8		90 02		bcc $9bfc	                bcc +
.9bfa		e6 28		inc $28		                inc tmp2+1
.9bfc						+
.9bfc		a0 00		ldy #$00	                ldy #0
.9bfe		b1 27		lda ($27),y	                lda (tmp2),y
.9c00		48		pha		                pha
.9c01		c8		iny		                iny
.9c02		11 27		ora ($27),y	                ora (tmp2),y
.9c04		f0 09		beq $9c0f	                beq _zero
.9c06		b1 27		lda ($27),y	                lda (tmp2),y
.9c08		85 28		sta $28		                sta tmp2+1
.9c0a		68		pla		                pla
.9c0b		85 27		sta $27		                sta tmp2
.9c0d		80 d3		bra $9be2	                bra _loop
.9c0f						_zero:
.9c0f		68		pla		                pla             ; Leftover from above loop
.9c10						_next_wordlist:
.9c10		b5 00		lda $00,x	                lda 0,x
.9c12		1a		inc a		                ina
.9c13		95 00		sta $00,x	                sta 0,x
.9c15		c9 0c		cmp #$0c	                cmp #max_wordlists
.9c17		d0 ab		bne $9bc4	                bne _wordlist_loop
.9c19		e8		inx		                inx
.9c1a		e8		inx		                inx
.9c1b		74 00		stz $00,x	                stz 0,x
.9c1d		74 01		stz $01,x	                stz 1,x
.9c1f		80 0a		bra $9c2b	                bra z_int_to_name
.9c21						_match:
.9c21		e8		inx		                inx
.9c22		e8		inx		                inx
.9c23		a5 27		lda $27		                lda tmp2
.9c25		95 00		sta $00,x	                sta 0,x
.9c27		a5 28		lda $28		                lda tmp2+1
.9c29		95 01		sta $01,x	                sta 1,x
.9c2b		60		rts		z_int_to_name:  rts
.9c2c						xt_latestnt:
.9c2c		ca		dex		                dex
.9c2d		ca		dex		                dex
.9c2e		20 f4 d6	jsr $d6f4	                jsr current_to_dp
.9c31		a5 02		lda $02		                lda dp
.9c33		95 00		sta $00,x	                sta 0,x
.9c35		a5 03		lda $03		                lda dp+1
.9c37		95 01		sta $01,x	                sta 1,x
.9c39		60		rts		z_latestnt:     rts
.9c3a						xt_latestxt:
.9c3a		20 2c 9c	jsr $9c2c	                jsr xt_latestnt         ; ( nt )
.9c3d		20 41 9c	jsr $9c41	                jsr xt_name_to_int      ; ( xt )
.9c40		60		rts		z_latestxt:     rts
.9c41						xt_name_to_int:
.9c41		20 9d d7	jsr $d79d	                jsr underflow_1
.9c44		b5 00		lda $00,x	                lda 0,x
.9c46		18		clc		                clc
.9c47		69 04		adc #$04	                adc #4
.9c49		85 29		sta $29		                sta tmp3
.9c4b		b5 01		lda $01,x	                lda 1,x
.9c4d		90 01		bcc $9c50	                bcc _done
.9c4f		1a		inc a		                ina
.9c50						_done:
.9c50		85 2a		sta $2a		                sta tmp3+1
.9c52		a0 00		ldy #$00	                ldy #0
.9c54		b1 29		lda ($29),y	                lda (tmp3),y
.9c56		95 00		sta $00,x	                sta 0,x
.9c58		c8		iny		                iny
.9c59		b1 29		lda ($29),y	                lda (tmp3),y
.9c5b		95 01		sta $01,x	                sta 1,x
.9c5d		60		rts		z_name_to_int:  rts
.9c5e						xt_name_to_string:
.9c5e		20 9d d7	jsr $d79d	                jsr underflow_1
.9c61		ca		dex		                dex
.9c62		ca		dex		                dex
.9c63		a1 02		lda ($02,x)	                lda (2,x)
.9c65		95 00		sta $00,x	                sta 0,x
.9c67		74 01		stz $01,x	                stz 1,x
.9c69		b5 02		lda $02,x	                lda 2,x         ; LSB
.9c6b		18		clc		                clc
.9c6c		69 08		adc #$08	                adc #8
.9c6e		95 02		sta $02,x	                sta 2,x
.9c70		90 02		bcc $9c74	                bcc z_name_to_string
.9c72		f6 03		inc $03,x	                inc 3,x         ; MSB
.9c74						z_name_to_string:
.9c74		60		rts		                rts
.9c75						xt_nc_limit:
.9c75		a9 00		lda #$00	                lda #nc_limit_offset
.9c77		4c 59 d6	jmp $d659	                jmp push_upvar_tos
.9c7a						z_nc_limit:
.9c7a						xt_never_native:
.9c7a		20 f4 d6	jsr $d6f4	                jsr current_to_dp
.9c7d		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9c7f		b1 02		lda ($02),y	                lda (dp),y
.9c81		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9c83		29 fd		and #$fd	                and #$FF-AN     ; and AN flag is clear.
.9c85		91 02		sta ($02),y	                sta (dp),y
.9c87						z_never_native:
.9c87		60		rts		                rts
.9c88						xt_not_rote:
.9c88		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9c8b		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9c8d		b5 03		lda $03,x	                lda 3,x
.9c8f		95 01		sta $01,x	                sta 1,x
.9c91		b5 05		lda $05,x	                lda 5,x
.9c93		95 03		sta $03,x	                sta 3,x
.9c95		94 05		sty $05,x	                sty 5,x
.9c97		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9c99		b5 02		lda $02,x	                lda 2,x
.9c9b		95 00		sta $00,x	                sta 0,x
.9c9d		b5 04		lda $04,x	                lda 4,x
.9c9f		95 02		sta $02,x	                sta 2,x
.9ca1		94 04		sty $04,x	                sty 4,x
.9ca3		60		rts		z_not_rote:     rts
.9ca4						xt_number:
.9ca4		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9ca7		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9ca9		a5 18		lda $18		                lda base
.9cab		48		pha		                pha
.9cac		20 bf 93	jsr $93bf	                jsr xt_two_dup
.9caf		a1 02		lda ($02,x)	                lda (2,x)
.9cb1		c9 23		cmp #$23	                cmp #'#'                ; decimal?
.9cb3		d0 04		bne $9cb9	                bne _check_hex
.9cb5		a9 0a		lda #$0a	                lda #10
.9cb7		80 42		bra $9cfb	                bra _base_changed
.9cb9						_check_hex:
.9cb9		c9 24		cmp #$24	                cmp #'$'
.9cbb		d0 04		bne $9cc1	                bne _check_binary
.9cbd		a9 10		lda #$10	                lda #16
.9cbf		80 3a		bra $9cfb	                bra _base_changed
.9cc1						_check_binary:
.9cc1		c9 25		cmp #$25	                cmp #'%'
.9cc3		d0 04		bne $9cc9	                bne _check_char
.9cc5		a9 02		lda #$02	                lda #2
.9cc7		80 32		bra $9cfb	                bra _base_changed
.9cc9						_check_char:
.9cc9		c9 27		cmp #$27	                cmp #"'"
.9ccb		d0 3a		bne $9d07	                bne _check_minus
.9ccd		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9ccf		c9 03		cmp #$03	                cmp #3
.9cd1		d0 26		bne $9cf9	                bne _not_a_char
.9cd3		b5 01		lda $01,x	                lda 1,x
.9cd5		d0 22		bne $9cf9	                bne _not_a_char ; No compare needed to check for non-zero.
.9cd7		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9cd9		18		clc		                clc
.9cda		69 02		adc #$02	                adc #2          ; length of string
.9cdc		85 23		sta $23		                sta tmptos
.9cde		b5 03		lda $03,x	                lda 3,x
.9ce0		69 00		adc #$00	                adc #0          ; only need carry
.9ce2		85 24		sta $24		                sta tmptos+1
.9ce4		b2 23		lda ($23)	                lda (tmptos)
.9ce6		c9 27		cmp #$27	                cmp #"'"
.9ce8		d0 0f		bne $9cf9	                bne _not_a_char
.9cea		f6 02		inc $02,x	                inc 2,x
.9cec		d0 02		bne $9cf0	                bne +
.9cee		f6 03		inc $03,x	                inc 3,x
.9cf0						+
.9cf0		a1 02		lda ($02,x)	                lda (2,x)
.9cf2		95 02		sta $02,x	                sta 2,x
.9cf4		74 03		stz $03,x	                stz 3,x
.9cf6		4c 79 9d	jmp $9d79	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9cf9						_not_a_char:
.9cf9		80 5c		bra $9d57	                bra _number_error
.9cfb						_base_changed:
.9cfb		85 18		sta $18		                sta base        ; Switch to the new base
.9cfd		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9cff		d0 02		bne $9d03	                bne +
.9d01		f6 03		inc $03,x	                inc 3,x
.9d03						+
.9d03		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d05		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9d07						_check_minus:
.9d07		c9 2d		cmp #$2d	                cmp #'-'
.9d09		d0 0c		bne $9d17	                bne _check_dot
.9d0b		a9 80		lda #$80	                lda #$80
.9d0d		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9d0f		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d11		d0 02		bne $9d15	                bne +
.9d13		f6 03		inc $03,x	                inc 3,x
.9d15						+
.9d15		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d17						_check_dot:
.9d17		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d19		18		clc		                clc
.9d1a		75 00		adc $00,x	                adc 0,x         ; length of string
.9d1c		85 23		sta $23		                sta tmptos
.9d1e		b5 03		lda $03,x	                lda 3,x
.9d20		69 00		adc #$00	                adc #0          ; only need carry
.9d22		85 24		sta $24		                sta tmptos+1
.9d24		a5 23		lda $23		                lda tmptos
.9d26		d0 02		bne $9d2a	                bne +
.9d28		c6 24		dec $24		                dec tmptos+1
.9d2a						+
.9d2a		c6 23		dec $23		                dec tmptos
.9d2c		b2 23		lda ($23)	                lda (tmptos)
.9d2e		c9 2e		cmp #$2e	                cmp #'.'
.9d30		d0 04		bne $9d36	                bne _main
.9d32		e6 1e		inc $1e		                inc tmpdsp
.9d34		d6 00		dec $00,x	                dec 0,x
.9d36						_main:
.9d36		ca		dex		                dex
.9d37		ca		dex		                dex
.9d38		ca		dex		                dex
.9d39		ca		dex		                dex
.9d3a		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9d3c		95 00		sta $00,x	                sta 0,x
.9d3e		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9d40		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9d42		95 02		sta $02,x	                sta 2,x
.9d44		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9d46		95 03		sta $03,x	                sta 3,x
.9d48		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9d4a		74 05		stz $05,x	                stz 5,x
.9d4c		74 06		stz $06,x	                stz 6,x
.9d4e		74 07		stz $07,x	                stz 7,x
.9d50		20 e0 92	jsr $92e0	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9d53		b5 00		lda $00,x	                lda 0,x
.9d55		f0 1e		beq $9d75	                beq _all_converted
.9d57						_number_error:
.9d57		20 b7 93	jsr $93b7	                jsr xt_two_drop ; >NUMBER modified addr u
.9d5a		20 b7 93	jsr $93b7	                jsr xt_two_drop ; ud   (partially converted number)
.9d5d		a9 3e		lda #$3e	                lda #'>'
.9d5f		20 c4 86	jsr $86c4	                jsr emit_a
.9d62		20 c9 94	jsr $94c9	                jsr xt_type
.9d65		a9 3c		lda #$3c	                lda #'<'
.9d67		20 c4 86	jsr $86c4	                jsr emit_a
.9d6a		20 bd 91	jsr $91bd	                jsr xt_space
.9d6d		68		pla		                pla
.9d6e		85 18		sta $18		                sta base
.9d70		a9 08		lda #$08	                lda #err_syntax
.9d72		4c b3 d7	jmp $d7b3	                jmp error
.9d75						_all_converted:
.9d75		e8		inx		                inx ; Drop the current addr u
.9d76		e8		inx		                inx
.9d77		e8		inx		                inx
.9d78		e8		inx		                inx
.9d79						_drop_original_string:
.9d79		20 85 94	jsr $9485	                jsr xt_two_swap  ; Drop the original addr u
.9d7c		20 b7 93	jsr $93b7	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9d7f		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9d81		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9d83		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9d84		f0 0a		beq $9d90	                beq _single
.9d86		98		tya		                tya
.9d87		04 1c		tsb $1c		                tsb status
.9d89		90 0f		bcc $9d9a	                bcc _done       ; no minus, all done
.9d8b		20 72 9e	jsr $9e72	                jsr xt_dnegate
.9d8e		80 0a		bra $9d9a	                bra _done
.9d90						_single:
.9d90		e8		inx		                inx
.9d91		e8		inx		                inx
.9d92		98		tya		                tya
.9d93		14 1c		trb $1c		                trb status
.9d95		90 03		bcc $9d9a	                bcc _done       ; no minus, all done
.9d97		20 17 8c	jsr $8c17	                jsr xt_negate
.9d9a						_done:
.9d9a		68		pla		                pla
.9d9b		85 18		sta $18		                sta base
.9d9d		60		rts		z_number:       rts
.9d9e						xt_editor_wordlist:
.9d9e						xt_one:
.9d9e		ca		dex		                dex
.9d9f		ca		dex		                dex
.9da0		a9 01		lda #$01	                lda #1
.9da2		95 00		sta $00,x	                sta 0,x
.9da4		74 01		stz $01,x	                stz 1,x
.9da6						z_editor_wordlist:
.9da6						z_one:
.9da6		60		rts		                rts
.9da7						xt_output:
.9da7		ca		dex		                dex
.9da8		ca		dex		                dex
.9da9		a9 12		lda #$12	                lda #<output
.9dab		95 00		sta $00,x	                sta 0,x
.9dad		a9 00		lda #$00	                lda #>output
.9daf		95 01		sta $01,x	                sta 1,x
.9db1		60		rts		z_output:       rts
.9db2						xt_r_to_input:
.9db2		68		pla		                pla
.9db3		85 25		sta $25		                sta tmp1
.9db5		68		pla		                pla
.9db6		85 26		sta $26		                sta tmp1+1
.9db8		a0 00		ldy #$00	                ldy #0
.9dba						_loop:
.9dba		68		pla		                pla
.9dbb		99 0a 00	sta $000a,y	                sta insrc,y
.9dbe		c8		iny		                iny
.9dbf		c0 08		cpy #$08	                cpy #8
.9dc1		d0 f7		bne $9dba	                bne _loop
.9dc3		a5 26		lda $26		                lda tmp1+1
.9dc5		48		pha		                pha
.9dc6		a5 25		lda $25		                lda tmp1
.9dc8		48		pha		                pha
.9dc9		60		rts		z_r_to_input: 	rts
.9dca						xt_strip_underflow:
.9dca		a9 02		lda #$02	                lda #uf_strip_offset
.9dcc		4c 59 d6	jmp $d659	                jmp push_upvar_tos
.9dcf						z_strip_underflow:
.9dcf						xt_assembler_wordlist:
.9dcf						xt_two:
.9dcf		ca		dex		                dex
.9dd0		ca		dex		                dex
.9dd1		a9 02		lda #$02	                lda #2
.9dd3		95 00		sta $00,x	                sta 0,x
.9dd5		74 01		stz $01,x	                stz 1,x
.9dd7						z_assembler_wordlist:
.9dd7		60		rts		z_two:          rts
.9dd8						xt_useraddr:
.9dd8		ca		dex		                dex
.9dd9		ca		dex		                dex
.9dda		a9 08		lda #$08	                lda #<up
.9ddc		95 00		sta $00,x	                sta 0,x
.9dde		a9 00		lda #$00	                lda #>up
.9de0		95 01		sta $01,x	                sta 1,x
.9de2		60		rts		z_useraddr:     rts
.9de3						xt_wordsize:
.9de3		20 9d d7	jsr $d79d	                jsr underflow_1
.9de6		b5 00		lda $00,x	                lda 0,x
.9de8		85 25		sta $25		                sta tmp1
.9dea		b5 01		lda $01,x	                lda 1,x
.9dec		85 26		sta $26		                sta tmp1+1
.9dee		a0 06		ldy #$06	                ldy #6
.9df0		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9df2		88		dey		                dey
.9df3		88		dey		                dey
.9df4		38		sec		                sec
.9df5		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9df7		95 00		sta $00,x	                sta 0,x
.9df9		a0 07		ldy #$07	                ldy #7
.9dfb		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9dfd		88		dey		                dey
.9dfe		88		dey		                dey
.9dff		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9e01		95 01		sta $01,x	                sta 1,x
.9e03		60		rts		z_wordsize:     rts
.9e04						xt_case:
.9e04						xt_false:
.9e04						xt_forth_wordlist:
.9e04						xt_zero:
.9e04		ca		dex		                dex             ; push
.9e05		ca		dex		                dex
.9e06		74 00		stz $00,x	                stz 0,x
.9e08		74 01		stz $01,x	                stz 1,x
.9e0a						z_case:
.9e0a						z_false:
.9e0a						z_forth_wordlist:
.9e0a						z_zero:
.9e0a		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9e0b						xt_d_minus:
.9e0b		20 ac d7	jsr $d7ac	                jsr underflow_4 ; two double numbers
.9e0e		38		sec		                sec
.9e0f		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9e11		f5 02		sbc $02,x	                sbc 2,x
.9e13		95 06		sta $06,x	                sta 6,x
.9e15		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9e17		f5 03		sbc $03,x	                sbc 3,x
.9e19		95 07		sta $07,x	                sta 7,x
.9e1b		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9e1d		f5 00		sbc $00,x	                sbc 0,x
.9e1f		95 04		sta $04,x	                sta 4,x
.9e21		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9e23		f5 01		sbc $01,x	                sbc 1,x
.9e25		95 05		sta $05,x	                sta 5,x
.9e27		e8		inx		                inx
.9e28		e8		inx		                inx
.9e29		e8		inx		                inx
.9e2a		e8		inx		                inx
.9e2b		60		rts		z_d_minus:      rts
.9e2c						xt_d_plus:
.9e2c		20 ac d7	jsr $d7ac	                jsr underflow_4 ; two double numbers
.9e2f		18		clc		                clc
.9e30		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9e32		75 06		adc $06,x	                adc 6,x
.9e34		95 06		sta $06,x	                sta 6,x
.9e36		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9e38		75 07		adc $07,x	                adc 7,x
.9e3a		95 07		sta $07,x	                sta 7,x
.9e3c		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9e3e		75 04		adc $04,x	                adc 4,x
.9e40		95 04		sta $04,x	                sta 4,x
.9e42		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9e44		75 05		adc $05,x	                adc 5,x
.9e46		95 05		sta $05,x	                sta 5,x
.9e48		e8		inx		                inx
.9e49		e8		inx		                inx
.9e4a		e8		inx		                inx
.9e4b		e8		inx		                inx
.9e4c		60		rts		z_d_plus:       rts
.9e4d						xt_d_to_s:
.9e4d		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9e50		e8		inx		                inx
.9e51		e8		inx		                inx
.9e52		60		rts		z_d_to_s:       rts
.9e53						xt_dabs:
.9e53		20 a2 d7	jsr $d7a2	                jsr underflow_2 ; double number
.9e56		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9e58		10 17		bpl $9e71	                bpl _done       ; positive, we get off light
.9e5a		a0 00		ldy #$00	                ldy #0
.9e5c		38		sec		                sec
.9e5d		98		tya		                tya
.9e5e		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e60		95 02		sta $02,x	                sta 2,x
.9e62		98		tya		                tya
.9e63		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e65		95 03		sta $03,x	                sta 3,x
.9e67		98		tya		                tya
.9e68		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e6a		95 00		sta $00,x	                sta 0,x
.9e6c		98		tya		                tya
.9e6d		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e6f		95 01		sta $01,x	                sta 1,x
.9e71						_done:
.9e71		60		rts		z_dabs:         rts
.9e72						xt_dnegate:
.9e72		20 a2 d7	jsr $d7a2	                jsr underflow_2 ; double number
.9e75		a0 00		ldy #$00	     		ldy #0
.9e77		38		sec		                sec
.9e78		98		tya		                tya
.9e79		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e7b		95 02		sta $02,x	                sta 2,x
.9e7d		98		tya		                tya
.9e7e		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e80		95 03		sta $03,x	                sta 3,x
.9e82		98		tya		                tya
.9e83		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e85		95 00		sta $00,x	                sta 0,x
.9e87		98		tya		                tya
.9e88		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e8a		95 01		sta $01,x	                sta 1,x
.9e8c		60		rts		z_dnegate:      rts
.9e8d						xt_d_dot:
.9e8d		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9e90		20 9d 93	jsr $939d	                jsr xt_tuck
.9e93		20 53 9e	jsr $9e53	                jsr xt_dabs
.9e96		20 ce 89	jsr $89ce	                jsr xt_less_number_sign
.9e99		20 ab 8c	jsr $8cab	                jsr xt_number_sign_s
.9e9c		20 83 8f	jsr $8f83	                jsr xt_rot
.9e9f		20 42 91	jsr $9142	                jsr xt_sign
.9ea2		20 89 8c	jsr $8c89	                jsr xt_number_sign_greater
.9ea5		20 c9 94	jsr $94c9	                jsr xt_type
.9ea8		20 bd 91	jsr $91bd	                jsr xt_space
.9eab		60		rts		z_d_dot:        rts
.9eac						xt_d_dot_r:
.9eac		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9eaf		20 80 93	jsr $9380	                jsr xt_to_r
.9eb2		20 9d 93	jsr $939d	                jsr xt_tuck
.9eb5		20 53 9e	jsr $9e53	                jsr xt_dabs
.9eb8		20 ce 89	jsr $89ce	                jsr xt_less_number_sign
.9ebb		20 ab 8c	jsr $8cab	                jsr xt_number_sign_s
.9ebe		20 83 8f	jsr $8f83	                jsr xt_rot
.9ec1		20 42 91	jsr $9142	                jsr xt_sign
.9ec4		20 89 8c	jsr $8c89	                jsr xt_number_sign_greater
.9ec7		20 e6 8e	jsr $8ee6	                jsr xt_r_from
.9eca		20 fd 8c	jsr $8cfd	                jsr xt_over
.9ecd		20 dc 8b	jsr $8bdc	                jsr xt_minus
.9ed0		20 c3 91	jsr $91c3	                jsr xt_spaces
.9ed3		20 c9 94	jsr $94c9	                jsr xt_type
.9ed6		60		rts		z_d_dot_r:      rts
.9ed7						xt_two_constant:
.9ed7		20 a2 d7	jsr $d7a2	                jsr underflow_2
.9eda		20 42 84	jsr $8442	                jsr xt_create
.9edd		20 42 92	jsr $9242	                jsr xt_swap
.9ee0		20 cf 83	jsr $83cf	                jsr xt_comma
.9ee3		20 cf 83	jsr $83cf	                jsr xt_comma
.9ee6		20 fd 85	jsr $85fd	                jsr does_runtime    ; does> turns into these two routines.
.9ee9		20 32 d6	jsr $d632	                jsr dodoes
.9eec		20 9f 86	jsr $869f	                jsr xt_dup
.9eef		20 19 88	jsr $8819	                jsr xt_fetch
.9ef2		20 42 92	jsr $9242	                jsr xt_swap
.9ef5		20 45 83	jsr $8345	                jsr xt_cell_plus
.9ef8		20 19 88	jsr $8819	                jsr xt_fetch
.9efb		60		rts		z_two_constant: rts
.9efc						xt_two_literal:
.9efc		20 a2 d7	jsr $d7a2	                jsr underflow_2 ; double number
.9eff		a9 0a		lda #$0a	                lda # z_template_push_tos - template_push_tos
.9f01		0a		asl a		                asl
.9f02		20 b8 97	jsr $97b8	                jsr check_nc_limit
.9f05		b0 09		bcs $9f10	                bcs _no_inline
.9f07		20 42 92	jsr $9242	                jsr xt_swap
.9f0a		20 f1 89	jsr $89f1	                jsr xt_literal
.9f0d		4c f1 89	jmp $89f1	                jmp xt_literal
.9f10						_no_inline:
.9f10		20 6f a1	jsr $a16f	                jsr cmpl_two_literal
.9f13		60		rts		z_two_literal:  rts
.9f14						xt_two_variable:
.9f14		20 42 84	jsr $8442	                jsr xt_create
.9f17		ca		dex		                dex
.9f18		ca		dex		                dex
.9f19		a9 04		lda #$04	                lda #4
.9f1b		95 00		sta $00,x	                sta 0,x
.9f1d		74 01		stz $01,x	                stz 1,x
.9f1f		20 29 82	jsr $8229	                jsr xt_allot
.9f22		60		rts		z_two_variable: rts
.9f23						xt_ud_dot:
.9f23		20 a2 d7	jsr $d7a2	                jsr underflow_2 ; double number
.9f26		20 ce 89	jsr $89ce	                jsr xt_less_number_sign
.9f29		20 ab 8c	jsr $8cab	                jsr xt_number_sign_s
.9f2c		20 89 8c	jsr $8c89	                jsr xt_number_sign_greater
.9f2f		20 c9 94	jsr $94c9	                jsr xt_type
.9f32		20 bd 91	jsr $91bd	                jsr xt_space
.9f35		60		rts		z_ud_dot:        rts
.9f36						xt_ud_dot_r:
.9f36		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9f39		20 80 93	jsr $9380	                jsr xt_to_r
.9f3c		20 ce 89	jsr $89ce	                jsr xt_less_number_sign
.9f3f		20 ab 8c	jsr $8cab	                jsr xt_number_sign_s
.9f42		20 89 8c	jsr $8c89	                jsr xt_number_sign_greater
.9f45		20 e6 8e	jsr $8ee6	                jsr xt_r_from
.9f48		20 fd 8c	jsr $8cfd	                jsr xt_over
.9f4b		20 dc 8b	jsr $8bdc	                jsr xt_minus
.9f4e		20 c3 91	jsr $91c3	                jsr xt_spaces
.9f51		20 c9 94	jsr $94c9	                jsr xt_type
.9f54		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.9f55						xt_cmove:
.9f55		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9f58		b5 02		lda $02,x	                lda 2,x
.9f5a		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f5c		b5 03		lda $03,x	                lda 3,x
.9f5e		85 28		sta $28		                sta tmp2+1
.9f60		b5 04		lda $04,x	                lda 4,x
.9f62		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9f64		b5 05		lda $05,x	                lda 5,x
.9f66		85 26		sta $26		                sta tmp1+1
.9f68		a0 00		ldy #$00	                ldy #0
.9f6a		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.9f6c		f0 0f		beq $9f7d	                beq _dopartial
.9f6e						_page:
.9f6e		b1 25		lda ($25),y	                lda (tmp1),y
.9f70		91 27		sta ($27),y	                sta (tmp2),y
.9f72		c8		iny		                iny
.9f73		d0 f9		bne $9f6e	                bne _page
.9f75		e6 26		inc $26		                inc tmp1+1
.9f77		e6 28		inc $28		                inc tmp2+1
.9f79		d6 01		dec $01,x	                dec 1,x
.9f7b		d0 f1		bne $9f6e	                bne _page
.9f7d						_dopartial:
.9f7d		b5 00		lda $00,x	                lda 0,x         ; length of last page
.9f7f		f0 09		beq $9f8a	                beq _done
.9f81						_partial:
.9f81		b1 25		lda ($25),y	                lda (tmp1),y
.9f83		91 27		sta ($27),y	                sta (tmp2),y
.9f85		c8		iny		                iny
.9f86		d6 00		dec $00,x	                dec 0,x
.9f88		d0 f7		bne $9f81	                bne _partial
.9f8a						_done:
.9f8a		8a		txa		                txa
.9f8b		18		clc		                clc
.9f8c		69 06		adc #$06	                adc #6
.9f8e		aa		tax		                tax
.9f8f		60		rts		z_cmove:        rts
.9f90						xt_cmove_up:
.9f90		20 a7 d7	jsr $d7a7	                jsr underflow_3
.9f93		b5 02		lda $02,x	                lda 2,x
.9f95		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f97		b5 03		lda $03,x	                lda 3,x
.9f99		18		clc		                clc
.9f9a		75 01		adc $01,x	                adc 1,x
.9f9c		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.9f9e		b5 04		lda $04,x	                lda 4,x
.9fa0		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9fa2		b5 05		lda $05,x	                lda 5,x
.9fa4		18		clc		                clc
.9fa5		75 01		adc $01,x	                adc 1,x
.9fa7		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.9fa9		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.9fab		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.9fad		f0 0e		beq $9fbd	                beq _nopartial
.9faf						_outerloop:
.9faf		88		dey		                dey
.9fb0		f0 07		beq $9fb9	                beq _finishpage
.9fb2						_innerloop:
.9fb2		b1 25		lda ($25),y	                lda (tmp1),y
.9fb4		91 27		sta ($27),y	                sta (tmp2),y
.9fb6		88		dey		                dey
.9fb7		d0 f9		bne $9fb2	                bne _innerloop
.9fb9						_finishpage:
.9fb9		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.9fbb		92 27		sta ($27)	                sta (tmp2)
.9fbd						_nopartial:
.9fbd		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.9fbf		c6 28		dec $28		                dec tmp2+1
.9fc1		d6 01		dec $01,x	                dec 1,x
.9fc3		d0 ea		bne $9faf	                bne _outerloop
.9fc5		8a		txa		                txa
.9fc6		18		clc		                clc
.9fc7		69 06		adc #$06	                adc #6
.9fc9		aa		tax		                tax
.9fca		60		rts		z_cmove_up:     rts
.9fcb						xt_compare:
.9fcb		20 ac d7	jsr $d7ac	                jsr underflow_4
.9fce		b5 02		lda $02,x	                lda 2,x
.9fd0		85 27		sta $27		                sta tmp2
.9fd2		b5 03		lda $03,x	                lda 3,x
.9fd4		85 28		sta $28		                sta tmp2+1
.9fd6		b5 06		lda $06,x	                lda 6,x
.9fd8		85 25		sta $25		                sta tmp1
.9fda		b5 07		lda $07,x	                lda 7,x
.9fdc		85 26		sta $26		                sta tmp1+1
.9fde						_compare_loop:
.9fde		b5 04		lda $04,x	                lda 4,x
.9fe0		15 05		ora $05,x	                ora 5,x
.9fe2		f0 2c		beq $a010	                beq _str1_done
.9fe4		b5 00		lda $00,x	                lda 0,x
.9fe6		15 01		ora $01,x	                ora 1,x
.9fe8		f0 3a		beq $a024	                beq _greater    ; Str2 empty first
.9fea		b2 25		lda ($25)	                lda (tmp1)
.9fec		d2 27		cmp ($27)	                cmp (tmp2)
.9fee		90 26		bcc $a016	                bcc _less
.9ff0		d0 32		bne $a024	                bne _greater
.9ff2		e6 25		inc $25		                inc tmp1
.9ff4		d0 02		bne $9ff8	                bne +
.9ff6		e6 26		inc $26		                inc tmp1+1
.9ff8						+
.9ff8		e6 27		inc $27		                inc tmp2
.9ffa		d0 02		bne $9ffe	                bne +
.9ffc		e6 28		inc $28		                inc tmp2+1
.9ffe						+
.9ffe		b5 04		lda $04,x	                lda 4,x
.a000		d0 02		bne $a004	                bne +
.a002		d6 05		dec $05,x	                dec 5,x
.a004						+
.a004		d6 04		dec $04,x	                dec 4,x
.a006		b5 00		lda $00,x	                lda 0,x
.a008		d0 02		bne $a00c	                bne +
.a00a		d6 01		dec $01,x	                dec 1,x
.a00c						+
.a00c		d6 00		dec $00,x	                dec 0,x
.a00e		80 ce		bra $9fde	                bra _compare_loop
.a010						_str1_done:
.a010		b5 00		lda $00,x	                lda 0,x
.a012		15 01		ora $01,x	                ora 1,x
.a014		f0 08		beq $a01e	                beq _equal      ; Both out of letters
.a016						_less:
.a016		a9 ff		lda #$ff	                lda #$FF
.a018		95 06		sta $06,x	                sta 6,x
.a01a		95 07		sta $07,x	                sta 7,x
.a01c		80 0c		bra $a02a	                bra _done
.a01e						_equal:
.a01e		74 06		stz $06,x	                stz 6,x
.a020		74 07		stz $07,x	                stz 7,x
.a022		80 06		bra $a02a	                bra _done
.a024						_greater:
.a024		a9 01		lda #$01	                lda #1
.a026		95 06		sta $06,x	                sta 6,x
.a028		74 07		stz $07,x	                stz 7,x
.a02a						_done:
.a02a		8a		txa		                txa
.a02b		18		clc		                clc
.a02c		69 06		adc #$06	                adc #6
.a02e		aa		tax		                tax
.a02f		60		rts		z_compare:      rts
.a030						xt_minus_leading:
.a030		20 a2 d7	jsr $d7a2	                jsr underflow_2
.a033						_loop:
.a033		b5 00		lda $00,x	                lda 0,x
.a035		15 01		ora $01,x	                ora 1,x
.a037		f0 0f		beq $a048	                beq _done
.a039		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a03b		20 90 d7	jsr $d790	                jsr is_whitespace
.a03e		90 08		bcc $a048	                bcc _done
.a040		20 9e 9d	jsr $9d9e	                jsr xt_one              ; ( addr u 1 )
.a043		20 25 a1	jsr $a125	                jsr xt_slash_string     ; ( addr+ u-1 )
.a046		80 eb		bra $a033	                bra _loop
.a048						_done:
.a048						z_minus_leading:
.a048		60		rts		                rts
.a049						xt_minus_trailing:
.a049		20 a2 d7	jsr $d7a2	                jsr underflow_2
.a04c		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a04e		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a050		f0 33		beq $a085	                beq _done
.a052		18		clc		                clc
.a053		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a055		75 00		adc $00,x	                adc 0,x
.a057		85 25		sta $25		                sta tmp1
.a059		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a05b		75 01		adc $01,x	                adc 1,x
.a05d		85 26		sta $26		                sta tmp1+1
.a05f		a5 25		lda $25		                lda tmp1
.a061		d0 02		bne $a065	                bne +
.a063		c6 26		dec $26		                dec tmp1+1
.a065						+
.a065		c6 25		dec $25		                dec tmp1
.a067						_loop:
.a067		b2 25		lda ($25)	                lda (tmp1)
.a069		c9 20		cmp #$20	                cmp #AscSP
.a06b		d0 18		bne $a085	                bne _done
.a06d		a5 25		lda $25		                lda tmp1
.a06f		d0 02		bne $a073	                bne +
.a071		c6 26		dec $26		                dec tmp1+1
.a073						+
.a073		c6 25		dec $25		                dec tmp1
.a075		b5 00		lda $00,x	                lda 0,x
.a077		d0 02		bne $a07b	                bne +
.a079		d6 01		dec $01,x	                dec 1,x
.a07b						+
.a07b		d6 00		dec $00,x	                dec 0,x
.a07d		b5 00		lda $00,x	                lda 0,x
.a07f		15 01		ora $01,x	                ora 1,x
.a081		f0 02		beq $a085	                beq _done       ; Count has reached zero - we're done!
.a083		80 e2		bra $a067	                bra _loop
.a085						_done:
.a085						z_minus_trailing:
.a085		60		rts		                rts
.a086						xt_search:
.a086		20 ac d7	jsr $d7ac	                jsr underflow_4
.a089		b5 00		lda $00,x	                lda 0,x
.a08b		15 01		ora $01,x	                ora 1,x
.a08d		d0 0b		bne $a09a	                bne _start_search
.a08f		e8		inx		                inx             ; Remove u2
.a090		e8		inx		                inx
.a091		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a093		95 00		sta $00,x	                sta 0,x
.a095		95 01		sta $01,x	                sta 1,x
.a097		4c 24 a1	jmp $a124	                jmp z_search
.a09a						_start_search:
.a09a		20 04 9e	jsr $9e04	                jsr xt_zero
.a09d						_search_loop:
.a09d		18		clc		                clc
.a09e		b5 00		lda $00,x	                lda 0,x
.a0a0		75 02		adc $02,x	                adc 2,x
.a0a2		85 25		sta $25		                sta tmp1
.a0a4		b5 01		lda $01,x	                lda 1,x
.a0a6		75 03		adc $03,x	                adc 3,x
.a0a8		d5 07		cmp $07,x	                cmp 7,x
.a0aa		90 12		bcc $a0be	                bcc _init_comparison ; Obviously less
.a0ac		d0 06		bne $a0b4	                bne _not_found
.a0ae		b5 06		lda $06,x	                lda 6,x
.a0b0		c5 25		cmp $25		                cmp tmp1
.a0b2		b0 0a		bcs $a0be	                bcs _init_comparison
.a0b4						_not_found:
.a0b4		e8		inx		                inx             ; Remove offset
.a0b5		e8		inx		                inx
.a0b6		e8		inx		                inx             ; Remove u2
.a0b7		e8		inx		                inx
.a0b8		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a0ba		74 01		stz $01,x	                stz 1,x
.a0bc		80 66		bra $a124	                bra z_search
.a0be						_init_comparison:
.a0be		18		clc		                clc
.a0bf		b5 08		lda $08,x	                lda 8,x
.a0c1		75 00		adc $00,x	                adc 0,x
.a0c3		85 25		sta $25		                sta tmp1
.a0c5		b5 09		lda $09,x	                lda 9,x
.a0c7		75 01		adc $01,x	                adc 1,x
.a0c9		85 26		sta $26		                sta tmp1+1
.a0cb		b5 04		lda $04,x	                lda 4,x
.a0cd		85 27		sta $27		                sta tmp2
.a0cf		b5 05		lda $05,x	                lda 5,x
.a0d1		85 28		sta $28		                sta tmp2+1
.a0d3		b5 02		lda $02,x	                lda 2,x
.a0d5		85 29		sta $29		                sta tmp3
.a0d7		b5 03		lda $03,x	                lda 3,x
.a0d9		85 2a		sta $2a		                sta tmp3+1
.a0db						_comparison_loop:
.a0db		b2 25		lda ($25)	                lda (tmp1)
.a0dd		d2 27		cmp ($27)	                cmp (tmp2)
.a0df		f0 05		beq $a0e6	                beq _letters_match
.a0e1		20 e1 8c	jsr $8ce1	                jsr xt_one_plus
.a0e4		80 b7		bra $a09d	                bra _search_loop
.a0e6						_letters_match:
.a0e6		e6 25		inc $25		                inc tmp1
.a0e8		d0 02		bne $a0ec	                bne +
.a0ea		e6 26		inc $26		                inc tmp1+1
.a0ec						+
.a0ec		e6 27		inc $27		                inc tmp2
.a0ee		d0 02		bne $a0f2	                bne +
.a0f0		e6 28		inc $28		                inc tmp2+1
.a0f2						+
.a0f2		a5 29		lda $29		                lda tmp3
.a0f4		d0 02		bne $a0f8	                bne +
.a0f6		c6 2a		dec $2a		                dec tmp3+1
.a0f8						+
.a0f8		c6 29		dec $29		                dec tmp3
.a0fa		a5 29		lda $29		                lda tmp3
.a0fc		05 2a		ora $2a		                ora tmp3+1
.a0fe		d0 db		bne $a0db	                bne _comparison_loop ; Check the next letter
.a100		18		clc		                clc
.a101		b5 00		lda $00,x	                lda 0,x
.a103		75 08		adc $08,x	                adc 8,x
.a105		95 08		sta $08,x	                sta 8,x
.a107		b5 01		lda $01,x	                lda 1,x
.a109		75 09		adc $09,x	                adc 9,x
.a10b		95 09		sta $09,x	                sta 9,x
.a10d		38		sec		                sec
.a10e		b5 06		lda $06,x	                lda 6,x
.a110		f5 00		sbc $00,x	                sbc 0,x
.a112		95 06		sta $06,x	                sta 6,x
.a114		b5 07		lda $07,x	                lda 7,x
.a116		f5 01		sbc $01,x	                sbc 1,x
.a118		95 07		sta $07,x	                sta 7,x
.a11a		e8		inx		                inx             ; drop offset
.a11b		e8		inx		                inx
.a11c		e8		inx		                inx             ; drop u2
.a11d		e8		inx		                inx
.a11e		a9 ff		lda #$ff	                lda #$FF
.a120		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a122		95 01		sta $01,x	                sta 1,x
.a124		60		rts		z_search:       rts
.a125						xt_slash_string:
.a125		20 a7 d7	jsr $d7a7	                jsr underflow_3
.a128		18		clc		                clc             ; 3OS+TOS
.a129		b5 00		lda $00,x	                lda 0,x
.a12b		75 04		adc $04,x	                adc 4,x
.a12d		95 04		sta $04,x	                sta 4,x
.a12f		b5 01		lda $01,x	                lda 1,x
.a131		75 05		adc $05,x	                adc 5,x
.a133		95 05		sta $05,x	                sta 5,x
.a135		38		sec		                sec             ; NOS-TOS
.a136		b5 02		lda $02,x	                lda 2,x
.a138		f5 00		sbc $00,x	                sbc 0,x
.a13a		95 02		sta $02,x	                sta 2,x
.a13c		b5 03		lda $03,x	                lda 3,x
.a13e		f5 01		sbc $01,x	                sbc 1,x
.a140		95 03		sta $03,x	                sta 3,x
.a142		e8		inx		                inx
.a143		e8		inx		                inx
.a144		60		rts		z_slash_string: rts
.a145						xt_sliteral:
.a145		20 a2 d7	jsr $d7a2	                jsr underflow_2
.a148		20 ae 97	jsr $97ae	                jsr cmpl_jump_later
.a14b		20 80 93	jsr $9380	                jsr xt_to_r
.a14e		20 1a 89	jsr $891a	                jsr xt_here
.a151		20 42 92	jsr $9242	                jsr xt_swap
.a154		20 9f 86	jsr $869f	                jsr xt_dup
.a157		20 29 82	jsr $8229	                jsr xt_allot            ; reserve u bytes for string
.a15a		20 1a 89	jsr $891a	                jsr xt_here
.a15d		20 e6 8e	jsr $8ee6	                jsr xt_r_from
.a160		20 2c 92	jsr $922c	                jsr xt_store            ; point jmp past string
.a163		20 bf 93	jsr $93bf	                jsr xt_two_dup
.a166		20 a9 94	jsr $94a9	                jsr xt_two_to_r
.a169		20 f8 8b	jsr $8bf8	                jsr xt_move             ; copy u bytes from addr -> addr'
.a16c		20 2f 94	jsr $942f	                jsr xt_two_r_from
.a16f						cmpl_sliteral:
.a16f						cmpl_two_literal:
.a16f		a0 a1		ldy #$a1	                ldy #>sliteral_runtime
.a171		a9 89		lda #$89	                lda #<sliteral_runtime
.a173		20 8d 97	jsr $978d	                jsr cmpl_subroutine
.a176		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a178		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a17a		20 99 97	jsr $9799	                jsr cmpl_word
.a17d		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a17f		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a181		20 99 97	jsr $9799	                jsr cmpl_word
.a184		e8		inx		                inx
.a185		e8		inx		                inx
.a186		e8		inx		                inx
.a187		e8		inx		                inx
.a188		60		rts		z_sliteral:     rts
.a189						sliteral_runtime:
.a189		ca		dex		                dex
.a18a		ca		dex		                dex
.a18b		ca		dex		                dex
.a18c		ca		dex		                dex
.a18d		68		pla		                pla
.a18e		85 25		sta $25		                sta tmp1        ; LSB of address
.a190		7a		ply		                ply
.a191		84 26		sty $26		                sty tmp1+1      ; MSB of address
.a193		18		clc		                clc
.a194		69 04		adc #$04	                adc #4
.a196		90 01		bcc $a199	                bcc +
.a198		c8		iny		                iny
.a199						+
.a199		5a		phy		                phy
.a19a		48		pha		                pha
.a19b		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a19d		b1 25		lda ($25),y	                lda (tmp1),y
.a19f		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a1a1		c8		iny		                iny
.a1a2		b1 25		lda ($25),y	                lda (tmp1),y
.a1a4		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a1a6		c8		iny		                iny
.a1a7		b1 25		lda ($25),y	                lda (tmp1),y
.a1a9		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a1ab		c8		iny		                iny
.a1ac		b1 25		lda ($25),y	                lda (tmp1),y
.a1ae		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a1b0		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a1b1						xt_disasm:
.a1b1		20 a2 d7	jsr $d7a2	                jsr underflow_2
.a1b4		20 b8 a1	jsr $a1b8	                jsr disassembler
.a1b7		60		rts		z_disasm:       rts
.a1b8						disassembler:
.a1b8		64 32		stz $32		                stz scratch+5   ; flag indicating whether we're arriving at sliteral (vs 2literal)
.a1ba		20 3c 84	jsr $843c	                jsr xt_cr       ; ( addr u )
.a1bd						_byte_loop:
.a1bd		20 fd 8c	jsr $8cfd	                jsr xt_over     ; ( addr u addr )
.a1c0		20 f4 94	jsr $94f4	                jsr xt_u_dot    ; ( addr u )
.a1c3		20 bd 91	jsr $91bd	                jsr xt_space
.a1c6		a9 c0		lda #$c0	                lda #<oc_index_table
.a1c8		85 27		sta $27		                sta tmp2
.a1ca		a9 b3		lda #$b3	                lda #>oc_index_table
.a1cc		85 28		sta $28		                sta tmp2+1
.a1ce		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a1d0		85 2d		sta $2d		                sta scratch     ; Save opcode
.a1d2		0a		asl a		                asl             ; multiply by two for offset
.a1d3		90 02		bcc $a1d7	                bcc +
.a1d5		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a1d7						+
.a1d7		a8		tay		                tay             ; use Y as the index
.a1d8		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a1da		85 29		sta $29		                sta tmp3
.a1dc		48		pha		                pha
.a1dd		c8		iny		                iny
.a1de		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a1e0		85 2a		sta $2a		                sta tmp3+1
.a1e2		48		pha		                pha
.a1e3		b2 29		lda ($29)	                lda (tmp3)
.a1e5		a8		tay		                tay                     ; save copy of lengths byte
.a1e6		10 3c		bpl $a224	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a1e8		20 04 9e	jsr $9e04	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.a1eb		f6 04		inc $04,x	                inc 4,x
.a1ed		d0 02		bne $a1f1	                bne +
.a1ef		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.a1f1						+
.a1f1		b5 02		lda $02,x	                lda 2,x
.a1f3		d0 02		bne $a1f7	                bne +
.a1f5		d6 03		dec $03,x	                dec 3,x
.a1f7						+
.a1f7		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.a1f9		a1 04		lda ($04,x)	                lda (4,x)
.a1fb		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a1fd		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a1ff		98		tya		                tya                     ; retrieve copy of lengths byte
.a200		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a201		10 14		bpl $a217	                bpl _print_operand
.a203		f6 04		inc $04,x	                inc 4,x
.a205		d0 02		bne $a209	                bne +
.a207		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.a209						+
.a209		b5 02		lda $02,x	                lda 2,x
.a20b		d0 02		bne $a20f	                bne +
.a20d		d6 03		dec $03,x	                dec 3,x
.a20f						+
.a20f		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.a211		a1 04		lda ($04,x)	                lda (4,x)
.a213		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a215		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a217						_print_operand:
.a217		ca		dex		                dex
.a218		ca		dex		                dex
.a219		a9 05		lda #$05	                lda #5
.a21b		95 00		sta $00,x	                sta 0,x
.a21d		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.a21f		20 00 95	jsr $9500	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.a222		80 0b		bra $a22f	                bra _print_mnemonic
.a224						_no_operand:
.a224		ca		dex		                dex
.a225		ca		dex		                dex
.a226		a9 05		lda #$05	                lda #5
.a228		95 00		sta $00,x	                sta 0,x
.a22a		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.a22c		20 c3 91	jsr $91c3	                jsr xt_spaces           ; ( addr u )
.a22f						_print_mnemonic:
.a22f		20 bd 91	jsr $91bd	                jsr xt_space
.a232		ca		dex		                dex
.a233		ca		dex		                dex                     ; ( addr u ? )
.a234		68		pla		                pla                     ; MSB
.a235		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a237		68		pla		                pla                     ; LSB
.a238		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a23a		20 28 84	jsr $8428	                jsr xt_count            ; ( addr u addr-o u-o )
.a23d		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a23f		b5 00		lda $00,x	                lda 0,x
.a241		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a243		95 00		sta $00,x	                sta 0,x
.a245		20 c9 94	jsr $94c9	                jsr xt_type             ; ( addr u )
.a248		a5 2d		lda $2d		                lda scratch
.a24a		c9 20		cmp #$20	                cmp #OpJSR
.a24c		d0 15		bne $a263	                bne _not_jsr
.a24e		ca		dex		                dex
.a24f		ca		dex		                dex
.a250		a9 05		lda #$05	                lda #5
.a252		95 00		sta $00,x	                sta 0,x
.a254		74 01		stz $01,x	                stz 1,x
.a256		20 c3 91	jsr $91c3	                jsr xt_spaces
.a259		20 34 a3	jsr $a334	                jsr disasm_special
.a25c		b0 70		bcs $a2ce	                bcs _printing_done
.a25e		20 14 a3	jsr $a314	                jsr disasm_jsr
.a261		b0 6b		bcs $a2ce	                bcs _printing_done
.a263						_not_jsr:
.a263		c9 4c		cmp #$4c	                cmp #OpJMP
.a265		d0 2d		bne $a294	                bne _not_jmp
.a267		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.a269		85 30		sta $30		                sta scratch+3
.a26b		a5 2f		lda $2f		                lda scratch+2
.a26d		85 31		sta $31		                sta scratch+4
.a26f		b2 30		lda ($30)	                lda (scratch+3)
.a271		c9 20		cmp #$20	                cmp #OpJSR          ; check for JSR
.a273		d0 59		bne $a2ce	                bne _printing_done
.a275		e6 30		inc $30		                inc scratch+3
.a277		d0 02		bne $a27b	                bne +
.a279		e6 31		inc $31		                inc scratch+4
.a27b						+
.a27b		b2 30		lda ($30)	                lda (scratch+3)
.a27d		c9 89		cmp #$89	                cmp #<sliteral_runtime
.a27f		d0 4d		bne $a2ce	                bne _printing_done
.a281		e6 30		inc $30		                inc scratch+3
.a283		d0 02		bne $a287	                bne +
.a285		e6 31		inc $31		                inc scratch+4
.a287						+
.a287		b2 30		lda ($30)	                lda (scratch+3)
.a289		c9 a1		cmp #$a1	                cmp #>sliteral_runtime
.a28b		d0 41		bne $a2ce	                bne _printing_done
.a28d		c6 32		dec $32		                dec scratch+5                   ; flag for next go round
.a28f		20 ea a2	jsr $a2ea	                jsr disasm_sliteral_jump
.a292		80 3a		bra $a2ce	                bra _printing_done
.a294						_not_jmp:
.a294		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a296		f0 06		beq $a29e	                beq _is_rel
.a298		29 1f		and #$1f	                and #$1F
.a29a		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a29c		d0 30		bne $a2ce	                bne _printing_done
.a29e						_is_rel:
.a29e		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a2a0		ca		dex		                dex
.a2a1		ca		dex		                dex
.a2a2		74 01		stz $01,x	                stz 1,x
.a2a4		a5 2e		lda $2e		                lda scratch+1
.a2a6		95 00		sta $00,x	                sta 0,x
.a2a8		10 04		bpl $a2ae	                bpl +
.a2aa		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a2ac		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a2ae		38		sec		+               sec                 ; start counting from address after opcode
.a2af		75 04		adc $04,x	                adc 4,x
.a2b1		95 00		sta $00,x	                sta 0,x
.a2b3		b5 01		lda $01,x	                lda 1,x
.a2b5		75 05		adc $05,x	                adc 5,x
.a2b7		95 01		sta $01,x	                sta 1,x
.a2b9		5a		phy		                phy                 ; save the direction indicator
.a2ba		ca		dex		                dex
.a2bb		ca		dex		                dex
.a2bc		a9 09		lda #$09	                lda #9
.a2be		95 00		sta $00,x	                sta 0,x
.a2c0		74 01		stz $01,x	                stz 1,x
.a2c2		20 00 95	jsr $9500	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.a2c5		a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.a2c7		20 c4 86	jsr $86c4	                jsr emit_a
.a2ca		68		pla		                pla
.a2cb		20 c4 86	jsr $86c4	                jsr emit_a
.a2ce						_printing_done:
.a2ce		20 3c 84	jsr $843c	                jsr xt_cr
.a2d1		f6 02		inc $02,x	                inc 2,x
.a2d3		d0 02		bne $a2d7	                bne +
.a2d5		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.a2d7						+
.a2d7		20 d5 8c	jsr $8cd5	                jsr xt_one_minus        ; ( addr+1 u-1 )
.a2da		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a2dc		15 01		ora $01,x	                ora 1,x
.a2de		f0 07		beq $a2e7	                beq _done
.a2e0		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a2e2		30 03		bmi $a2e7	                bmi _done
.a2e4		4c bd a1	jmp $a1bd	                jmp _byte_loop          ; out of range for BRA
.a2e7						_done:
.a2e7		4c b7 93	jmp $93b7	                jmp xt_two_drop         ; JSR/RTS
.a2ea						disasm_sliteral_jump:
.a2ea		20 42 92	jsr $9242	                jsr xt_swap
.a2ed		ca		dex		                dex
.a2ee		ca		dex		                dex
.a2ef		a5 2e		lda $2e		                lda scratch+1
.a2f1		95 00		sta $00,x	                sta 0,x
.a2f3		a5 2f		lda $2f		                lda scratch+2
.a2f5		95 01		sta $01,x	                sta 1,x
.a2f7		20 42 92	jsr $9242	                jsr xt_swap
.a2fa		20 dc 8b	jsr $8bdc	                jsr xt_minus
.a2fd		20 d5 8c	jsr $8cd5	                jsr xt_one_minus
.a300		20 dc 8b	jsr $8bdc	                jsr xt_minus
.a303		ca		dex		                dex
.a304		ca		dex		                dex
.a305		a5 2e		lda $2e		                lda scratch+1
.a307		95 00		sta $00,x	                sta 0,x
.a309		a5 2f		lda $2f		                lda scratch+2
.a30b		95 01		sta $01,x	                sta 1,x
.a30d		20 d5 8c	jsr $8cd5	                jsr xt_one_minus
.a310		20 42 92	jsr $9242	                jsr xt_swap ; ( new_addr new_n )
.a313		60		rts		                rts
.a314						disasm_jsr:
.a314		ca		dex		                dex
.a315		ca		dex		                dex
.a316		a5 2e		lda $2e		                lda scratch+1
.a318		95 00		sta $00,x	                sta 0,x
.a31a		a5 2f		lda $2f		                lda scratch+2
.a31c		95 01		sta $01,x	                sta 1,x
.a31e		20 bb 9b	jsr $9bbb	                jsr xt_int_to_name
.a321		b5 00		lda $00,x	                lda 0,x
.a323		15 01		ora $01,x	                ora 1,x
.a325		f0 08		beq $a32f	                beq _no_nt
.a327		20 5e 9c	jsr $9c5e	                jsr xt_name_to_string
.a32a		20 c9 94	jsr $94c9	                jsr xt_type
.a32d		38		sec		                sec
.a32e		60		rts		                rts
.a32f						_no_nt:
.a32f		20 b7 93	jsr $93b7	                jsr xt_two_drop
.a332		18		clc		                clc
.a333		60		rts		                rts
.a334						disasm_special:
.a334		a0 2c		ldy #$2c	                ldy #(_end_handlers - _special_handlers - 4)
.a336		b9 c2 a3	lda $a3c2,y	_check:         lda _special_handlers,y
.a339		c5 2e		cmp $2e		                cmp scratch+1
.a33b		d0 07		bne $a344	                bne _next
.a33d		b9 c3 a3	lda $a3c3,y	                lda _special_handlers+1,y
.a340		c5 2f		cmp $2f		                cmp scratch+2
.a342		f0 08		beq $a34c	                beq _found_handler
.a344		88		dey		_next:          dey
.a345		88		dey		                dey
.a346		88		dey		                dey
.a347		88		dey		                dey
.a348		10 ec		bpl $a336	                bpl _check
.a34a		18		clc		                clc
.a34b		60		rts		                rts
.a34c						_found_handler:
.a34c		a5 32		lda $32		                lda scratch+5               ; are we expecting sliteral?
.a34e		f0 04		beq $a354	                beq +
.a350		64 32		stz $32		                stz scratch+5               ; yes, skip 2literal and match again
.a352		80 f0		bra $a344	                bra _next
.a354						+
.a354		b9 c5 a3	lda $a3c5,y	                lda _special_handlers+3,y   ; payload + prefix
.a357		48		pha		                pha                         ; stash a copy for payload later
.a358		4a		lsr a		                lsr
.a359		4a		lsr a		                lsr
.a35a		f0 06		beq $a362	                beq _no_prefix
.a35c		18		clc		                clc
.a35d		69 20		adc #$20	                adc #32
.a35f		20 c4 86	jsr $86c4	                jsr emit_a
.a362						_no_prefix:
.a362		b9 c4 a3	lda $a3c4,y	                lda _special_handlers+2,y   ; string index
.a365		20 d9 d7	jsr $d7d9	                jsr print_string_no_lf
.a368		68		pla		                pla
.a369		29 03		and #$03	                and #3                      ; payload is 0, 1 or 2 words
.a36b		f0 0f		beq $a37c	                beq _done
.a36d		c9 03		cmp #$03	                cmp #3                      ; but 3 means a double-word
.a36f		d0 03		bne $a374	                bne _show_payload
.a371		4c 96 a3	jmp $a396	                jmp _print_2literal
.a374						_show_payload:
.a374		48		pha		                pha
.a375		20 7e a3	jsr $a37e	                jsr _print_literal
.a378		68		pla		                pla
.a379		3a		dec a		                dea
.a37a		d0 f8		bne $a374	                bne _show_payload
.a37c		38		sec		_done:          sec
.a37d		60		rts		                rts
.a37e						_print_literal:
.a37e		20 42 92	jsr $9242	                jsr xt_swap ; switch to (u addr)
.a381		20 e1 8c	jsr $8ce1	                jsr xt_one_plus
.a384		20 9f 86	jsr $869f	                jsr xt_dup
.a387		20 2f 99	jsr $992f	                jsr xt_question ; Print the value at the address
.a38a		20 e1 8c	jsr $8ce1	                jsr xt_one_plus
.a38d		20 42 92	jsr $9242	                jsr xt_swap ; (addr+2 u)
.a390		20 d5 8c	jsr $8cd5	                jsr xt_one_minus
.a393		4c d5 8c	jmp $8cd5	                jmp xt_one_minus ; (addr+2 u-2)
.a396						_print_2literal:
.a396		20 42 92	jsr $9242	                jsr xt_swap
.a399		20 e1 8c	jsr $8ce1	                jsr xt_one_plus
.a39c		20 9f 86	jsr $869f	                jsr xt_dup
.a39f		20 d7 93	jsr $93d7	                jsr xt_two_fetch
.a3a2		20 42 92	jsr $9242	                jsr xt_swap             ; 2! / 2@ put MSW first; but 2literal writes LSW first
.a3a5		20 8d 9e	jsr $9e8d	                jsr xt_d_dot
.a3a8		18		clc		                clc
.a3a9		b5 00		lda $00,x	                lda 0,x
.a3ab		69 03		adc #$03	                adc #3
.a3ad		95 00		sta $00,x	                sta 0,x
.a3af		90 02		bcc $a3b3	                bcc +
.a3b1		f6 01		inc $01,x	                inc 1,x
.a3b3						+
.a3b3		20 42 92	jsr $9242	                jsr xt_swap ; ( addr+4 u )
.a3b6		38		sec		                sec
.a3b7		b5 00		lda $00,x	                lda 0,x
.a3b9		e9 04		sbc #$04	                sbc #4
.a3bb		95 00		sta $00,x	                sta 0,x
.a3bd		b0 02		bcs $a3c1	                bcs +
.a3bf		d6 01		dec $01,x	                dec 1,x
.a3c1						+
.a3c1		60		rts		                rts
.a3c2						_special_handlers:
>a3c2		9d d7				    .word underflow_1
>a3c4		0c 44				        .byte str_disasm_sdc, 0 + ('1'-32)*4
>a3c6		a2 d7				    .word underflow_2
>a3c8		0c 48				        .byte str_disasm_sdc, 0 + ('2'-32)*4
>a3ca		a7 d7				    .word underflow_3
>a3cc		0c 4c				        .byte str_disasm_sdc, 0 + ('3'-32)*4
>a3ce		ac d7				    .word underflow_4
>a3d0		0c 50				        .byte str_disasm_sdc, 0 + ('4'-32)*4
>a3d2		39 8a				    .word literal_runtime
>a3d4		0d 01				        .byte str_disasm_lit, 1
>a3d6		89 a1				    .word sliteral_runtime
>a3d8		0d ce				        .byte str_disasm_lit, 2 + ('S'-32)*4
>a3da		89 a1				    .word sliteral_runtime                      ; 2literal and sliteral use the same runtime
>a3dc		0d 4b				        .byte str_disasm_lit, 3 + ('2'-32)*4    ; list is searched in reverse, put 2literal first
>a3de		41 98				    .word zero_branch_runtime
>a3e0		0e 01				        .byte str_disasm_0bra, 1
>a3e2		cb 8a				    .word loop_runtime
>a3e4		0f 01				        .byte str_disasm_loop, 1
>a3e6		e4 8a				    .word plus_loop_runtime
>a3e8		0f 2d				        .byte str_disasm_loop, 1 + ('+'-32)*4
>a3ea		bb 85				    .word do_runtime
>a3ec		10 00				        .byte str_disasm_do, 0
>a3ee		a3 85				    .word question_do_runtime
>a3f0		10 7d				        .byte str_disasm_do, 1 + ('?'-32)*4
.a3f2						_end_handlers:
.a3f2						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a3f2						assembler:
.a3f2						xt_asm_adc_h:
.a3f2		a9 69		lda #$69	                lda #$69
.a3f4		4c 4d a7	jmp $a74d	                jmp asm_common
.a3f7						z_asm_adc_h:
.a3f7						xt_asm_adc_x:
.a3f7		a9 7d		lda #$7d	                lda #$7D
.a3f9		4c 4d a7	jmp $a74d	                jmp asm_common
.a3fc						z_asm_adc_x:
.a3fc						xt_asm_adc_y:
.a3fc		a9 79		lda #$79	                lda #$79
.a3fe		4c 4d a7	jmp $a74d	                jmp asm_common
.a401						z_asm_adc_y:
.a401						xt_asm_adc_z:
.a401		a9 65		lda #$65	                lda #$65
.a403		4c 4d a7	jmp $a74d	                jmp asm_common
.a406						z_asm_adc_z:
.a406						xt_asm_adc_zi:
.a406		a9 72		lda #$72	                lda #$72
.a408		4c 4d a7	jmp $a74d	                jmp asm_common
.a40b						z_asm_adc_zi:
.a40b						xt_asm_adc_ziy:
.a40b		a9 71		lda #$71	                lda #$71
.a40d		4c 4d a7	jmp $a74d	                jmp asm_common
.a410						z_asm_adc_ziy:
.a410						xt_asm_adc_zx:
.a410		a9 75		lda #$75	                lda #$75
.a412		4c 4d a7	jmp $a74d	                jmp asm_common
.a415						z_asm_adc_zx:
.a415						xt_asm_adc_zxi:
.a415		a9 61		lda #$61	                lda #$61
.a417		4c 4d a7	jmp $a74d	                jmp asm_common
.a41a						z_asm_adc_zxi:
.a41a						xt_asm_and:
.a41a		a9 2d		lda #$2d	                lda #$2D
.a41c		4c 4d a7	jmp $a74d	                jmp asm_common
.a41f						z_asm_and:
.a41f						xt_asm_and_h:
.a41f		a9 29		lda #$29	                lda #$29
.a421		4c 4d a7	jmp $a74d	                jmp asm_common
.a424						z_asm_and_h:
.a424						xt_asm_and_x:
.a424		a9 3d		lda #$3d	                lda #$3D
.a426		4c 4d a7	jmp $a74d	                jmp asm_common
.a429						z_asm_and_x:
.a429						xt_asm_and_y:
.a429		a9 39		lda #$39	                lda #$39
.a42b		4c 4d a7	jmp $a74d	                jmp asm_common
.a42e						z_asm_and_y:
.a42e						xt_asm_and_z:
.a42e		a9 25		lda #$25	                lda #$25
.a430		4c 4d a7	jmp $a74d	                jmp asm_common
.a433						z_asm_and_z:
.a433						xt_asm_and_zi:
.a433		a9 32		lda #$32	                lda #$32
.a435		4c 4d a7	jmp $a74d	                jmp asm_common
.a438						z_asm_and_zi:
.a438						xt_asm_and_ziy:
.a438		a9 31		lda #$31	                lda #$31
.a43a		4c 4d a7	jmp $a74d	                jmp asm_common
.a43d						z_asm_and_ziy:
.a43d						xt_asm_and_zx:
.a43d		a9 35		lda #$35	                lda #$35
.a43f		4c 4d a7	jmp $a74d	                jmp asm_common
.a442						z_asm_and_zx:
.a442						xt_asm_and_zxi:
.a442		a9 21		lda #$21	                lda #$21
.a444		4c 4d a7	jmp $a74d	                jmp asm_common
.a447						z_asm_and_zxi:
.a447						xt_asm_asl:
.a447		a9 0e		lda #$0e	                lda #$0E
.a449		4c 4d a7	jmp $a74d	                jmp asm_common
.a44c						z_asm_asl:
.a44c						xt_asm_asl_a:
.a44c		a9 0a		lda #$0a	                lda #$0A
.a44e		4c 4d a7	jmp $a74d	                jmp asm_common
.a451						z_asm_asl_a:
.a451						xt_asm_asl_x:
.a451		a9 1e		lda #$1e	                lda #$1E
.a453		4c 4d a7	jmp $a74d	                jmp asm_common
.a456						z_asm_asl_x:
.a456						xt_asm_asl_z:
.a456		a9 06		lda #$06	                lda #$06
.a458		4c 4d a7	jmp $a74d	                jmp asm_common
.a45b						z_asm_asl_z:
.a45b						xt_asm_asl_zx:
.a45b		a9 16		lda #$16	                lda #$16
.a45d		4c 4d a7	jmp $a74d	                jmp asm_common
.a460						z_asm_asl_zx:
.a460						xt_asm_bcc:
.a460		a9 90		lda #$90	                lda #$90
.a462		4c 4d a7	jmp $a74d	                jmp asm_common
.a465						z_asm_bcc:
.a465						xt_asm_bcs:
.a465		a9 b0		lda #$b0	                lda #$B0
.a467		a0 02		ldy #$02	                ldy #2
.a469		4c 4d a7	jmp $a74d	                jmp asm_common
.a46c						z_asm_bcs:
.a46c						xt_asm_beq:
.a46c		a9 f0		lda #$f0	                lda #$F0
.a46e		4c 4d a7	jmp $a74d	                jmp asm_common
.a471						z_asm_beq:
.a471						xt_asm_bit:
.a471		a9 2c		lda #$2c	                lda #$2C
.a473		4c 4d a7	jmp $a74d	                jmp asm_common
.a476						z_asm_bit:
.a476						xt_asm_bit_h:
.a476		a9 89		lda #$89	                lda #$89
.a478		4c 4d a7	jmp $a74d	                jmp asm_common
.a47b						z_asm_bit_h:
.a47b						xt_asm_bit_x:
.a47b		a9 3c		lda #$3c	                lda #$3C
.a47d		4c 4d a7	jmp $a74d	                jmp asm_common
.a480						z_asm_bit_x:
.a480						xt_asm_bit_z:
.a480		a9 24		lda #$24	                lda #$24
.a482		4c 4d a7	jmp $a74d	                jmp asm_common
.a485						z_asm_bit_z:
.a485						xt_asm_bit_zx:
.a485		a9 34		lda #$34	                lda #$34
.a487		4c 4d a7	jmp $a74d	                jmp asm_common
.a48a						z_asm_bit_zx:
.a48a						xt_asm_bmi:
.a48a		a9 30		lda #$30	                lda #$30
.a48c		4c 4d a7	jmp $a74d	                jmp asm_common
.a48f						z_asm_bmi:
.a48f						xt_asm_bne:
.a48f		a9 d0		lda #$d0	                lda #$D0
.a491		4c 4d a7	jmp $a74d	                jmp asm_common
.a494						z_asm_bne:
.a494						xt_asm_bpl:
.a494		a9 10		lda #$10	                lda #$10
.a496		4c 4d a7	jmp $a74d	                jmp asm_common
.a499						z_asm_bpl:
.a499						xt_asm_bra:
.a499		a9 80		lda #$80	                lda #$80
.a49b		4c 4d a7	jmp $a74d	                jmp asm_common
.a49e						z_asm_bra:
.a49e						xt_asm_brk:
.a49e		a9 00		lda #$00	                lda #$00
.a4a0		4c 4d a7	jmp $a74d	                jmp asm_common
.a4a3						z_asm_brk:
.a4a3						xt_asm_bvc:
.a4a3		a9 50		lda #$50	                lda #$50
.a4a5		4c 4d a7	jmp $a74d	                jmp asm_common
.a4a8						z_asm_bvc:
.a4a8						xt_asm_bvs:
.a4a8		a9 70		lda #$70	                lda #$70
.a4aa		4c 4d a7	jmp $a74d	                jmp asm_common
.a4ad						z_asm_bvs:
.a4ad						xt_asm_clc:
.a4ad		a9 18		lda #$18	                lda #$18
.a4af		4c 4d a7	jmp $a74d	                jmp asm_common
.a4b2						z_asm_clc:
.a4b2						xt_asm_cld:
.a4b2		a9 d8		lda #$d8	                lda #$D8
.a4b4		4c 4d a7	jmp $a74d	                jmp asm_common
.a4b7						z_asm_cld:
.a4b7						xt_asm_cli:
.a4b7		a9 58		lda #$58	                lda #$58
.a4b9		4c 4d a7	jmp $a74d	                jmp asm_common
.a4bc						z_asm_cli:
.a4bc						xt_asm_clv:
.a4bc		a9 b8		lda #$b8	                lda #$B8
.a4be		4c 4d a7	jmp $a74d	                jmp asm_common
.a4c1						z_asm_clv:
.a4c1						xt_asm_cmp:
.a4c1		a9 cd		lda #$cd	                lda #$CD
.a4c3		4c 4d a7	jmp $a74d	                jmp asm_common
.a4c6						z_asm_cmp:
.a4c6						xt_asm_cmp_h:
.a4c6		a9 c9		lda #$c9	                lda #$C9
.a4c8		4c 4d a7	jmp $a74d	                jmp asm_common
.a4cb						z_asm_cmp_h:
.a4cb						xt_asm_cmp_x:
.a4cb		a9 dd		lda #$dd	                lda #$DD
.a4cd		4c 4d a7	jmp $a74d	                jmp asm_common
.a4d0						z_asm_cmp_x:
.a4d0						xt_asm_cmp_y:
.a4d0		a9 d9		lda #$d9	                lda #$D9
.a4d2		4c 4d a7	jmp $a74d	                jmp asm_common
.a4d5						z_asm_cmp_y:
.a4d5						xt_asm_cmp_z:
.a4d5		a9 c5		lda #$c5	                lda #$C5
.a4d7		4c 4d a7	jmp $a74d	                jmp asm_common
.a4da						z_asm_cmp_z:
.a4da						xt_asm_cmp_zi:
.a4da		a9 d2		lda #$d2	                lda #$D2
.a4dc		4c 4d a7	jmp $a74d	                jmp asm_common
.a4df						z_asm_cmp_zi:
.a4df						xt_asm_cmp_ziy:
.a4df		a9 d1		lda #$d1	                lda #$D1
.a4e1		4c 4d a7	jmp $a74d	                jmp asm_common
.a4e4						z_asm_cmp_ziy:
.a4e4						xt_asm_cmp_zx:
.a4e4		a9 d5		lda #$d5	                lda #$D5
.a4e6		4c 4d a7	jmp $a74d	                jmp asm_common
.a4e9						z_asm_cmp_zx:
.a4e9						xt_asm_cmp_zxi:
.a4e9		a9 c1		lda #$c1	                lda #$C1
.a4eb		4c 4d a7	jmp $a74d	                jmp asm_common
.a4ee						z_asm_cmp_zxi:
.a4ee						xt_asm_cpx:
.a4ee		a9 ec		lda #$ec	                lda #$EC
.a4f0		4c 4d a7	jmp $a74d	                jmp asm_common
.a4f3						z_asm_cpx:
.a4f3						xt_asm_cpx_h:
.a4f3		a9 e0		lda #$e0	                lda #$E0
.a4f5		4c 4d a7	jmp $a74d	                jmp asm_common
.a4f8						z_asm_cpx_h:
.a4f8						xt_asm_cpx_z:
.a4f8		a9 e4		lda #$e4	                lda #$E4
.a4fa		4c 4d a7	jmp $a74d	                jmp asm_common
.a4fd						z_asm_cpx_z:
.a4fd						xt_asm_cpy:
.a4fd		a9 cc		lda #$cc	                lda #$CC
.a4ff		a0 03		ldy #$03	                ldy #3
.a501		4c 4d a7	jmp $a74d	                jmp asm_common
.a504						z_asm_cpy:
.a504						xt_asm_cpy_h:
.a504		a9 c0		lda #$c0	                lda #$C0
.a506		4c 4d a7	jmp $a74d	                jmp asm_common
.a509						z_asm_cpy_h:
.a509						xt_asm_cpy_z:
.a509		a9 c4		lda #$c4	                lda #$C4
.a50b		4c 4d a7	jmp $a74d	                jmp asm_common
.a50e						z_asm_cpy_z:
.a50e						xt_asm_dec:
.a50e		a9 ce		lda #$ce	                lda #$CE
.a510		4c 4d a7	jmp $a74d	                jmp asm_common
.a513						z_asm_dec:
.a513						xt_asm_dec_a:
.a513		a9 3a		lda #$3a	                lda #$3A
.a515		4c 4d a7	jmp $a74d	                jmp asm_common
.a518						z_asm_dec_a:
.a518						xt_asm_dec_x:
.a518		a9 de		lda #$de	                lda #$DE
.a51a		4c 4d a7	jmp $a74d	                jmp asm_common
.a51d						z_asm_dec_x:
.a51d						xt_asm_dec_z:
.a51d		a9 c6		lda #$c6	                lda #$C6
.a51f		4c 4d a7	jmp $a74d	                jmp asm_common
.a522						z_asm_dec_z:
.a522						xt_asm_dec_zx:
.a522		a9 d6		lda #$d6	                lda #$D6
.a524		4c 4d a7	jmp $a74d	                jmp asm_common
.a527						z_asm_dec_zx:
.a527						xt_asm_dex:
.a527		a9 ca		lda #$ca	                lda #$CA
.a529		4c 4d a7	jmp $a74d	                jmp asm_common
.a52c						z_asm_dex:
.a52c						xt_asm_dey:
.a52c		a9 88		lda #$88	                lda #$88
.a52e		4c 4d a7	jmp $a74d	                jmp asm_common
.a531						z_asm_dey:
.a531						xt_asm_eor:
.a531		a9 4d		lda #$4d	                lda #$4D
.a533		4c 4d a7	jmp $a74d	                jmp asm_common
.a536						z_asm_eor:
.a536						xt_asm_eor_h:
.a536		a9 49		lda #$49	                lda #$49
.a538		4c 4d a7	jmp $a74d	                jmp asm_common
.a53b						z_asm_eor_h:
.a53b						xt_asm_eor_x:
.a53b		a9 5d		lda #$5d	                lda #$5D
.a53d		4c 4d a7	jmp $a74d	                jmp asm_common
.a540						z_asm_eor_x:
.a540						xt_asm_eor_y:
.a540		a9 59		lda #$59	                lda #$59
.a542		4c 4d a7	jmp $a74d	                jmp asm_common
.a545						z_asm_eor_y:
.a545						xt_asm_eor_z:
.a545		a9 45		lda #$45	                lda #$45
.a547		4c 4d a7	jmp $a74d	                jmp asm_common
.a54a						z_asm_eor_z:
.a54a						xt_asm_eor_zi:
.a54a		a9 52		lda #$52	                lda #$52
.a54c		4c 4d a7	jmp $a74d	                jmp asm_common
.a54f						z_asm_eor_zi:
.a54f						xt_asm_eor_ziy:
.a54f		a9 51		lda #$51	                lda #$51
.a551		4c 4d a7	jmp $a74d	                jmp asm_common
.a554						z_asm_eor_ziy:
.a554						xt_asm_eor_zx:
.a554		a9 55		lda #$55	                lda #$55
.a556		4c 4d a7	jmp $a74d	                jmp asm_common
.a559						z_asm_eor_zx:
.a559						xt_asm_eor_zxi:
.a559		a9 41		lda #$41	                lda #$41
.a55b		4c 4d a7	jmp $a74d	                jmp asm_common
.a55e						z_asm_eor_zxi:
.a55e						xt_asm_inc:
.a55e		a9 ee		lda #$ee	                lda #$EE
.a560		4c 4d a7	jmp $a74d	                jmp asm_common
.a563						z_asm_inc:
.a563						xt_asm_inc_a:
.a563		a9 1a		lda #$1a	                lda #$1A
.a565		4c 4d a7	jmp $a74d	                jmp asm_common
.a568						z_asm_inc_a:
.a568						xt_asm_inc_x:
.a568		a9 fe		lda #$fe	                lda #$FE
.a56a		4c 4d a7	jmp $a74d	                jmp asm_common
.a56d						z_asm_inc_x:
.a56d						xt_asm_inc_z:
.a56d		a9 e6		lda #$e6	                lda #$E6
.a56f		4c 4d a7	jmp $a74d	                jmp asm_common
.a572						z_asm_inc_z:
.a572						xt_asm_inc_zx:
.a572		a9 f6		lda #$f6	                lda #$F6
.a574		4c 4d a7	jmp $a74d	                jmp asm_common
.a577						z_asm_inc_zx:
.a577						xt_asm_inx:
.a577		a9 e8		lda #$e8	                lda #$E8
.a579		4c 4d a7	jmp $a74d	                jmp asm_common
.a57c						z_asm_inx:
.a57c						xt_asm_iny:
.a57c		a9 c8		lda #$c8	                lda #$C8
.a57e		4c 4d a7	jmp $a74d	                jmp asm_common
.a581						z_asm_iny:
.a581						xt_asm_jmp:
.a581		a9 4c		lda #$4c	                lda #$4C
.a583		4c 4d a7	jmp $a74d	                jmp asm_common
.a586						z_asm_jmp:
.a586						xt_asm_jmp_i:
.a586		a9 6c		lda #$6c	                lda #$6C
.a588		4c 4d a7	jmp $a74d	                jmp asm_common
.a58b						z_asm_jmp_i:
.a58b						xt_asm_jmp_xi:
.a58b		a9 7c		lda #$7c	                lda #$7C
.a58d		4c 4d a7	jmp $a74d	                jmp asm_common
.a590						z_asm_jmp_xi:
.a590						xt_asm_jsr:
.a590		a9 20		lda #$20	                lda #$20
.a592		4c 4d a7	jmp $a74d	                jmp asm_common
.a595						z_asm_jsr:
.a595						xt_asm_lda:
.a595		a9 ad		lda #$ad	                lda #$AD
.a597		4c 4d a7	jmp $a74d	                jmp asm_common
.a59a						z_asm_lda:
.a59a						xt_asm_lda_h:
.a59a		a9 a9		lda #$a9	                lda #$A9
.a59c		4c 4d a7	jmp $a74d	                jmp asm_common
.a59f						z_asm_lda_h:
.a59f						xt_asm_lda_x:
.a59f		a9 bd		lda #$bd	                lda #$BD
.a5a1		4c 4d a7	jmp $a74d	                jmp asm_common
.a5a4						z_asm_lda_x:
.a5a4						xt_asm_lda_y:
.a5a4		a9 b9		lda #$b9	                lda #$B9
.a5a6		4c 4d a7	jmp $a74d	                jmp asm_common
.a5a9						z_asm_lda_y:
.a5a9						xt_asm_lda_z:
.a5a9		a9 a5		lda #$a5	                lda #$A5
.a5ab		4c 4d a7	jmp $a74d	                jmp asm_common
.a5ae						z_asm_lda_z:
.a5ae						xt_asm_lda_zi:
.a5ae		a9 b2		lda #$b2	                lda #$B2
.a5b0		4c 4d a7	jmp $a74d	                jmp asm_common
.a5b3						z_asm_lda_zi:
.a5b3						xt_asm_lda_ziy:
.a5b3		a9 b1		lda #$b1	                lda #$B1
.a5b5		4c 4d a7	jmp $a74d	                jmp asm_common
.a5b8						z_asm_lda_ziy:
.a5b8						xt_asm_lda_zx:
.a5b8		a9 b5		lda #$b5	                lda #$B5
.a5ba		4c 4d a7	jmp $a74d	                jmp asm_common
.a5bd						z_asm_lda_zx:
.a5bd						xt_asm_lda_zxi:
.a5bd		a9 a1		lda #$a1	                lda #$A1
.a5bf		4c 4d a7	jmp $a74d	                jmp asm_common
.a5c2						z_asm_lda_zxi:
.a5c2						xt_asm_ldx:
.a5c2		a9 ae		lda #$ae	                lda #$AE
.a5c4		4c 4d a7	jmp $a74d	                jmp asm_common
.a5c7						z_asm_ldx:
.a5c7						xt_asm_ldx_h:
.a5c7		a9 a2		lda #$a2	                lda #$A2
.a5c9		4c 4d a7	jmp $a74d	                jmp asm_common
.a5cc						z_asm_ldx_h:
.a5cc						xt_asm_ldx_y:
.a5cc		a9 be		lda #$be	                lda #$BE
.a5ce		4c 4d a7	jmp $a74d	                jmp asm_common
.a5d1						z_asm_ldx_y:
.a5d1						xt_asm_ldx_z:
.a5d1		a9 a6		lda #$a6	                lda #$A6
.a5d3		4c 4d a7	jmp $a74d	                jmp asm_common
.a5d6						z_asm_ldx_z:
.a5d6						xt_asm_ldx_zy:
.a5d6		a9 b6		lda #$b6	                lda #$B6
.a5d8		4c 4d a7	jmp $a74d	                jmp asm_common
.a5db						z_asm_ldx_zy:
.a5db						xt_asm_ldy:
.a5db		a9 ac		lda #$ac	                lda #$AC
.a5dd		4c 4d a7	jmp $a74d	                jmp asm_common
.a5e0						z_asm_ldy:
.a5e0						xt_asm_ldy_h:
.a5e0		a9 a0		lda #$a0	                lda #$A0
.a5e2		4c 4d a7	jmp $a74d	                jmp asm_common
.a5e5						z_asm_ldy_h:
.a5e5						xt_asm_ldy_x:
.a5e5		a9 bc		lda #$bc	                lda #$BC
.a5e7		4c 4d a7	jmp $a74d	                jmp asm_common
.a5ea						z_asm_ldy_x:
.a5ea						xt_asm_ldy_z:
.a5ea		a9 a4		lda #$a4	                lda #$A4
.a5ec		4c 4d a7	jmp $a74d	                jmp asm_common
.a5ef						z_asm_ldy_z:
.a5ef						xt_asm_ldy_zx:
.a5ef		a9 b4		lda #$b4	                lda #$B4
.a5f1		4c 4d a7	jmp $a74d	                jmp asm_common
.a5f4						z_asm_ldy_zx:
.a5f4						xt_asm_lsr:
.a5f4		a9 4e		lda #$4e	                lda #$4E
.a5f6		4c 4d a7	jmp $a74d	                jmp asm_common
.a5f9						z_asm_lsr:
.a5f9						xt_asm_lsr_a:
.a5f9		a9 4a		lda #$4a	                lda #$4A
.a5fb		4c 4d a7	jmp $a74d	                jmp asm_common
.a5fe						z_asm_lsr_a:
.a5fe						xt_asm_lsr_x:
.a5fe		a9 5e		lda #$5e	                lda #$5E
.a600		4c 4d a7	jmp $a74d	                jmp asm_common
.a603						z_asm_lsr_x:
.a603						xt_asm_lsr_z:
.a603		a9 46		lda #$46	                lda #$46
.a605		4c 4d a7	jmp $a74d	                jmp asm_common
.a608						z_asm_lsr_z:
.a608						xt_asm_lsr_zx:
.a608		a9 56		lda #$56	                lda #$56
.a60a		4c 4d a7	jmp $a74d	                jmp asm_common
.a60d						z_asm_lsr_zx:
.a60d						xt_asm_nop:
.a60d		a9 ea		lda #$ea	                lda #$EA
.a60f		4c 4d a7	jmp $a74d	                jmp asm_common
.a612						z_asm_nop:
.a612						xt_asm_ora:
.a612		a9 0d		lda #$0d	                lda #$0D
.a614		4c 4d a7	jmp $a74d	                jmp asm_common
.a617						z_asm_ora:
.a617						xt_asm_ora_h:
.a617		a9 09		lda #$09	                lda #$09
.a619		4c 4d a7	jmp $a74d	                jmp asm_common
.a61c						z_asm_ora_h:
.a61c						xt_asm_ora_x:
.a61c		a9 1d		lda #$1d	                lda #$1D
.a61e		4c 4d a7	jmp $a74d	                jmp asm_common
.a621						z_asm_ora_x:
.a621						xt_asm_ora_y:
.a621		a9 19		lda #$19	                lda #$19
.a623		4c 4d a7	jmp $a74d	                jmp asm_common
.a626						z_asm_ora_y:
.a626						xt_asm_ora_z:
.a626		a9 05		lda #$05	                lda #$05
.a628		4c 4d a7	jmp $a74d	                jmp asm_common
.a62b						z_asm_ora_z:
.a62b						xt_asm_ora_zi:
.a62b		a9 12		lda #$12	                lda #$12
.a62d		a0 02		ldy #$02	                ldy #2
.a62f		4c 4d a7	jmp $a74d	                jmp asm_common
.a632						z_asm_ora_zi:
.a632						xt_asm_ora_ziy:
.a632		a9 11		lda #$11	                lda #$11
.a634		4c 4d a7	jmp $a74d	                jmp asm_common
.a637						z_asm_ora_ziy:
.a637						xt_asm_ora_zx:
.a637		a9 15		lda #$15	                lda #$15
.a639		4c 4d a7	jmp $a74d	                jmp asm_common
.a63c						z_asm_ora_zx:
.a63c						xt_asm_ora_zxi:
.a63c		a9 01		lda #$01	                lda #$01
.a63e		4c 4d a7	jmp $a74d	                jmp asm_common
.a641						z_asm_ora_zxi:
.a641						xt_asm_pha:
.a641		a9 48		lda #$48	                lda #$48
.a643		4c 4d a7	jmp $a74d	                jmp asm_common
.a646						z_asm_pha:
.a646						xt_asm_php:
.a646		a9 08		lda #$08	                lda #$08
.a648		4c 4d a7	jmp $a74d	                jmp asm_common
.a64b						z_asm_php:
.a64b						xt_asm_phx:
.a64b		a9 da		lda #$da	                lda #$DA
.a64d		4c 4d a7	jmp $a74d	                jmp asm_common
.a650						z_asm_phx:
.a650						xt_asm_phy:
.a650		a9 5a		lda #$5a	                lda #$5A
.a652		4c 4d a7	jmp $a74d	                jmp asm_common
.a655						z_asm_phy:
.a655						xt_asm_pla:
.a655		a9 68		lda #$68	                lda #$68
.a657		4c 4d a7	jmp $a74d	                jmp asm_common
.a65a						z_asm_pla:
.a65a						xt_asm_plp:
.a65a		a9 28		lda #$28	                lda #$28
.a65c		4c 4d a7	jmp $a74d	                jmp asm_common
.a65f						z_asm_plp:
.a65f						xt_asm_plx:
.a65f		a9 fa		lda #$fa	                lda #$FA
.a661		4c 4d a7	jmp $a74d	                jmp asm_common
.a664						z_asm_plx:
.a664						xt_asm_ply:
.a664		a9 7a		lda #$7a	                lda #$7A
.a666		4c 4d a7	jmp $a74d	                jmp asm_common
.a669						z_asm_ply:
.a669						xt_asm_rol:
.a669		a9 2e		lda #$2e	                lda #$2E
.a66b		4c 4d a7	jmp $a74d	                jmp asm_common
.a66e						z_asm_rol:
.a66e						xt_asm_rol_a:
.a66e		a9 2a		lda #$2a	                lda #$2A
.a670		4c 4d a7	jmp $a74d	                jmp asm_common
.a673						z_asm_rol_a:
.a673						xt_asm_rol_x:
.a673		a9 3e		lda #$3e	                lda #$3E
.a675		4c 4d a7	jmp $a74d	                jmp asm_common
.a678						z_asm_rol_x:
.a678						xt_asm_rol_z:
.a678		a9 26		lda #$26	                lda #$26
.a67a		4c 4d a7	jmp $a74d	                jmp asm_common
.a67d						z_asm_rol_z:
.a67d						xt_asm_rol_zx:
.a67d		a9 36		lda #$36	                lda #$36
.a67f		4c 4d a7	jmp $a74d	                jmp asm_common
.a682						z_asm_rol_zx:
.a682						xt_asm_ror:
.a682		a9 6e		lda #$6e	                lda #$6E
.a684		4c 4d a7	jmp $a74d	                jmp asm_common
.a687						z_asm_ror:
.a687						xt_asm_ror_a:
.a687		a9 6a		lda #$6a	                lda #$6A
.a689		4c 4d a7	jmp $a74d	                jmp asm_common
.a68c						z_asm_ror_a:
.a68c						xt_asm_ror_x:
.a68c		a9 7e		lda #$7e	                lda #$7E
.a68e		4c 4d a7	jmp $a74d	                jmp asm_common
.a691						z_asm_ror_x:
.a691						xt_asm_ror_z:
.a691		a9 66		lda #$66	                lda #$66
.a693		4c 4d a7	jmp $a74d	                jmp asm_common
.a696						z_asm_ror_z:
.a696						xt_asm_ror_zx:
.a696		a9 76		lda #$76	                lda #$76
.a698		4c 4d a7	jmp $a74d	                jmp asm_common
.a69b						z_asm_ror_zx:
.a69b						xt_asm_rti:
.a69b		a9 40		lda #$40	                lda #$40
.a69d		4c 4d a7	jmp $a74d	                jmp asm_common
.a6a0						z_asm_rti:
.a6a0						xt_asm_rts:
.a6a0		a9 60		lda #$60	                lda #$60
.a6a2		4c 4d a7	jmp $a74d	                jmp asm_common
.a6a5						z_asm_rts:
.a6a5						xt_asm_sbc:
.a6a5		a9 ed		lda #$ed	                lda #$ED
.a6a7		4c 4d a7	jmp $a74d	                jmp asm_common
.a6aa						z_asm_sbc:
.a6aa						xt_asm_sbc_h:
.a6aa		a9 e9		lda #$e9	                lda #$E9
.a6ac		4c 4d a7	jmp $a74d	                jmp asm_common
.a6af						z_asm_sbc_h:
.a6af						xt_asm_sbc_x:
.a6af		a9 fd		lda #$fd	                lda #$FD
.a6b1		4c 4d a7	jmp $a74d	                jmp asm_common
.a6b4						z_asm_sbc_x:
.a6b4						xt_asm_sbc_y:
.a6b4		a9 f9		lda #$f9	                lda #$F9
.a6b6		4c 4d a7	jmp $a74d	                jmp asm_common
.a6b9						z_asm_sbc_y:
.a6b9						xt_asm_sbc_z:
.a6b9		a9 e5		lda #$e5	                lda #$E5
.a6bb		4c 4d a7	jmp $a74d	                jmp asm_common
.a6be						z_asm_sbc_z:
.a6be						xt_asm_sbc_zi:
.a6be		a9 f2		lda #$f2	                lda #$F2
.a6c0		4c 4d a7	jmp $a74d	                jmp asm_common
.a6c3						z_asm_sbc_zi:
.a6c3						xt_asm_sbc_ziy:
.a6c3		a9 f1		lda #$f1	                lda #$F1
.a6c5		4c 4d a7	jmp $a74d	                jmp asm_common
.a6c8						z_asm_sbc_ziy:
.a6c8						xt_asm_sbc_zx:
.a6c8		a9 f5		lda #$f5	                lda #$F5
.a6ca		4c 4d a7	jmp $a74d	                jmp asm_common
.a6cd						z_asm_sbc_zx:
.a6cd						xt_asm_sbc_zxi:
.a6cd		a9 e1		lda #$e1	                lda #$E1
.a6cf		80 7c		bra $a74d	                bra asm_common  ; <-- limit for BRA instead of JMP
.a6d1						z_asm_sbc_zxi:
.a6d1						xt_asm_sec:
.a6d1		a9 38		lda #$38	                lda #$38
.a6d3		80 78		bra $a74d	                bra asm_common
.a6d5						z_asm_sec:
.a6d5						xt_asm_sed:
.a6d5		a9 f8		lda #$f8	                lda #$F8
.a6d7		80 74		bra $a74d	                bra asm_common
.a6d9						z_asm_sed:
.a6d9						xt_asm_sei:
.a6d9		a9 78		lda #$78	                lda #$78
.a6db		80 70		bra $a74d	                bra asm_common
.a6dd						z_asm_sei:
.a6dd						xt_asm_sta:
.a6dd		a9 8d		lda #$8d	                lda #$8D
.a6df		80 6c		bra $a74d	                bra asm_common
.a6e1						z_asm_sta:
.a6e1						xt_asm_sta_x:
.a6e1		a9 9d		lda #$9d	                lda #$9D
.a6e3		80 68		bra $a74d	                bra asm_common
.a6e5						z_asm_sta_x:
.a6e5						xt_asm_sta_y:
.a6e5		a9 99		lda #$99	                lda #$99
.a6e7		80 64		bra $a74d	                bra asm_common
.a6e9						z_asm_sta_y:
.a6e9						xt_asm_sta_z:
.a6e9		a9 85		lda #$85	                lda #$85
.a6eb		80 60		bra $a74d	                bra asm_common
.a6ed						z_asm_sta_z:
.a6ed						xt_asm_sta_zi:
.a6ed		a9 92		lda #$92	                lda #$92
.a6ef		80 5c		bra $a74d	                bra asm_common
.a6f1						z_asm_sta_zi:
.a6f1						xt_asm_sta_ziy:
.a6f1		a9 91		lda #$91	                lda #$91
.a6f3		80 58		bra $a74d	                bra asm_common
.a6f5						z_asm_sta_ziy:
.a6f5						xt_asm_sta_zx:
.a6f5		a9 95		lda #$95	                lda #$95
.a6f7		80 54		bra $a74d	                bra asm_common
.a6f9						z_asm_sta_zx:
.a6f9						xt_asm_sta_zxi:
.a6f9		a9 81		lda #$81	                lda #$81
.a6fb		80 50		bra $a74d	                bra asm_common
.a6fd						z_asm_sta_zxi:
.a6fd						xt_asm_stx:
.a6fd		a9 8e		lda #$8e	                lda #$8E
.a6ff		80 4c		bra $a74d	                bra asm_common
.a701						z_asm_stx:
.a701						xt_asm_stx_z:
.a701		a9 86		lda #$86	                lda #$86
.a703		80 48		bra $a74d	                bra asm_common
.a705						z_asm_stx_z:
.a705						xt_asm_stx_zy:
.a705		a9 96		lda #$96	                lda #$96
.a707		80 44		bra $a74d	                bra asm_common
.a709						z_asm_stx_zy:
.a709						xt_asm_sty:
.a709		a9 8c		lda #$8c	                lda #$8C
.a70b		80 40		bra $a74d	                bra asm_common
.a70d						z_asm_sty:
.a70d						xt_asm_sty_z:
.a70d		a9 84		lda #$84	                lda #$84
.a70f		80 3c		bra $a74d	                bra asm_common
.a711						z_asm_sty_z:
.a711						xt_asm_sty_zx:
.a711		a9 94		lda #$94	                lda #$94
.a713		80 38		bra $a74d	                bra asm_common
.a715						z_asm_sty_zx:
.a715						xt_asm_stz:
.a715		a9 9c		lda #$9c	                lda #$9C
.a717		80 34		bra $a74d	                bra asm_common
.a719						z_asm_stz:
.a719						xt_asm_stz_x:
.a719		a9 9e		lda #$9e	                lda #$9E
.a71b		80 30		bra $a74d	                bra asm_common
.a71d						z_asm_stz_x:
.a71d						xt_asm_stz_z:
.a71d		a9 64		lda #$64	                lda #$64
.a71f		80 2c		bra $a74d	                bra asm_common
.a721						z_asm_stz_z:
.a721						xt_asm_stz_zx:
.a721		a9 74		lda #$74	                lda #$74
.a723		80 28		bra $a74d	                bra asm_common
.a725						z_asm_stz_zx:
.a725						xt_asm_tax:
.a725		a9 aa		lda #$aa	                lda #$AA
.a727		80 24		bra $a74d	                bra asm_common
.a729						z_asm_tax:
.a729						xt_asm_tay:
.a729		a9 a8		lda #$a8	                lda #$A8
.a72b		80 20		bra $a74d	                bra asm_common
.a72d						z_asm_tay:
.a72d						xt_asm_trb:
.a72d		a9 1c		lda #$1c	                lda #$1C
.a72f		80 1c		bra $a74d	                bra asm_common
.a731						z_asm_trb:
.a731						xt_asm_trb_z:
.a731		a9 14		lda #$14	                lda #$14
.a733		80 18		bra $a74d	                bra asm_common
.a735						z_asm_trb_z:
.a735						xt_asm_tsb:
.a735		a9 0c		lda #$0c	                lda #$0C
.a737		80 14		bra $a74d	                bra asm_common
.a739						z_asm_tsb:
.a739						xt_asm_tsb_z:
.a739		a9 04		lda #$04	                lda #$04
.a73b		80 10		bra $a74d	                bra asm_common
.a73d						z_asm_tsb_z:
.a73d						xt_asm_tsx:
.a73d		a9 ba		lda #$ba	                lda #$BA
.a73f		80 0c		bra $a74d	                bra asm_common
.a741						z_asm_tsx:
.a741						xt_asm_txa:
.a741		a9 8a		lda #$8a	                lda #$8A
.a743		80 08		bra $a74d	                bra asm_common
.a745						z_asm_txa:
.a745						xt_asm_txs:
.a745		a9 9a		lda #$9a	                lda #$9A
.a747		80 04		bra $a74d	                bra asm_common
.a749						z_asm_txs:
.a749						xt_asm_tya:
.a749		a9 98		lda #$98	                lda #$98
.a74b		80 00		bra $a74d	                bra asm_common
.a74d						z_asm_tya:
.a74d						asm_common:
.a74d		a8		tay		                tay
.a74e		20 9d 97	jsr $979d	                jsr cmpl_a
.a751		a9 c0		lda #$c0	                lda #<oc_index_table
.a753		85 27		sta $27		                sta tmp2
.a755		a9 b3		lda #$b3	                lda #>oc_index_table
.a757		85 28		sta $28		                sta tmp2+1
.a759		98		tya		                tya             ; retrieve opcode
.a75a		0a		asl a		                asl             ; times two for offset
.a75b		90 02		bcc $a75f	                bcc +
.a75d		e6 28		inc $28		                inc tmp2+1
.a75f						+
.a75f		a8		tay		                tay             ; use Y as the index
.a760		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a762		85 29		sta $29		                sta tmp3
.a764		c8		iny		                iny
.a765		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a767		85 2a		sta $2a		                sta tmp3+1
.a769		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a76b		2a		rol a		                rol
.a76c		2a		rol a		                rol
.a76d		2a		rol a		                rol             ; Three times because we go through Carry
.a76e		29 03		and #$03	                and #%00000011
.a770		a8		tay		                tay
.a771		88		dey		                dey
.a772		f0 12		beq $a786	                beq _done
.a774		20 9d d7	jsr $d79d	                jsr underflow_1
.a777		b5 00		lda $00,x	                lda 0,x
.a779		20 9d 97	jsr $979d	                jsr cmpl_a      ; does not use Y
.a77c		88		dey		                dey
.a77d		f0 05		beq $a784	                beq _done_drop
.a77f		b5 01		lda $01,x	                lda 1,x
.a781		20 9d 97	jsr $979d	                jsr cmpl_a      ; Fall through to _done_drop
.a784						_done_drop:
.a784		e8		inx		                inx
.a785		e8		inx		                inx             ; Fall through to _done
.a786						_done:
.a786		60		rts		                rts             ; Returns to original caller
.a787						xt_asm_push_a:
.a787		a0 00		ldy #$00	                ldy #0
.a789						_loop:
.a789		b9 97 a7	lda $a797,y	                lda asm_push_a_data,y
.a78c		c9 ff		cmp #$ff	                cmp #$FF
.a78e		f0 06		beq $a796	                beq _done
.a790		20 9d 97	jsr $979d	                jsr cmpl_a      ; does not change Y
.a793		c8		iny		                iny
.a794		80 f3		bra $a789	                bra _loop
.a796						_done:
.a796						z_asm_push_a:
.a796		60		rts		                rts
.a797						asm_push_a_data:
>a797		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>a79d		ff				        .byte $FF               ; terminator
.a79e						xt_asm_back_jump:
.a79e						z_asm_back_jump:
.a79e		60		rts		                rts
.a79f						xt_asm_back_branch:
.a79f		20 1a 89	jsr $891a	                jsr xt_here             ; ( addr-l addr-h )
.a7a2		20 dc 8b	jsr $8bdc	                jsr xt_minus            ; ( offset )
.a7a5		3a		dec a		                dea
.a7a6		3a		dec a		                dea
.a7a7						z_asm_back_branch:
.a7a7		60		rts		                rts
.a7a8						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a7a8						xt_ed:
.a7a8		20 ac a7	jsr $a7ac	                jsr ed6502      ; kept in separate file
.a7ab		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a7ac						ed6502:
.a7ac		a5 18		lda $18		                lda base
.a7ae		85 3a		sta $3a		                sta ed_base
.a7b0		a9 0a		lda #$0a	                lda #10
.a7b2		85 18		sta $18		                sta base
.a7b4		64 35		stz $35		                stz ed_head
.a7b6		64 36		stz $36		                stz ed_head+1
.a7b8		64 37		stz $37		                stz ed_cur
.a7ba		64 38		stz $38		                stz ed_cur+1
.a7bc		64 39		stz $39		                stz ed_flags
.a7be		20 04 9e	jsr $9e04	                jsr xt_zero
.a7c1		20 04 9e	jsr $9e04	                jsr xt_zero             ; ( addr-t u-t )
.a7c4		20 3c 84	jsr $843c	                jsr xt_cr
.a7c7						ed_input_loop:
.a7c7		a9 81		lda #$81	                lda #%10000001
.a7c9		14 39		trb $39		                trb ed_flags
.a7cb		20 a6 ac	jsr $aca6	                jsr ed_get_input
.a7ce		a5 0e		lda $0e		                lda ciblen
.a7d0		d0 1f		bne $a7f1	                bne _command_mode
.a7d2		ca		dex		                dex
.a7d3		ca		dex		                dex                     ; ( addr-t u-t ? )
.a7d4		a5 37		lda $37		                lda ed_cur
.a7d6		95 00		sta $00,x	                sta 0,x
.a7d8		a5 38		lda $38		                lda ed_cur+1
.a7da		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a7dc		a9 80		lda #$80	                lda #%10000000
.a7de		04 39		tsb $39		                tsb ed_flags
.a7e0		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.a7e3		20 c2 ac	jsr $acc2	                jsr ed_is_valid_line
.a7e6		b0 03		bcs $a7eb	                bcs +
.a7e8		4c 96 ac	jmp $ac96	                jmp ed_error_1drop
.a7eb						+
.a7eb		20 04 9e	jsr $9e04	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.a7ee		4c bc a8	jmp $a8bc	                jmp _line_number_only_from_external
.a7f1						_command_mode:
.a7f1		20 04 9e	jsr $9e04	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a7f4		20 04 9e	jsr $9e04	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a7f7		b2 0c		lda ($0c)	                lda (cib)
.a7f9		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a7fb		d0 3a		bne $a837	                bne _prefix_dollar
.a7fd		20 b7 ac	jsr $acb7	                jsr ed_have_text
.a800		a5 37		lda $37		                lda ed_cur
.a802		95 02		sta $02,x	                sta 2,x
.a804		a5 38		lda $38		                lda ed_cur+1
.a806		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a808		a9 80		lda #$80	                lda #%10000000
.a80a		04 39		tsb $39		                tsb ed_flags
.a80c		a5 0e		lda $0e		                lda ciblen
.a80e		3a		dec a		                dea                     ; sets Z if A was 1
.a80f		d0 03		bne $a814	                bne +
.a811		4c bc a8	jmp $a8bc	                jmp _line_number_only_from_external
.a814						+
.a814		ca		dex		                dex
.a815		ca		dex		                dex
.a816		ca		dex		                dex
.a817		ca		dex		                dex
.a818		a5 0c		lda $0c		                lda cib
.a81a		95 02		sta $02,x	                sta 2,x
.a81c		a5 0d		lda $0d		                lda cib+1
.a81e		95 03		sta $03,x	                sta 3,x
.a820		a5 0e		lda $0e		                lda ciblen
.a822		95 00		sta $00,x	                sta 0,x
.a824		a5 0f		lda $0f		                lda ciblen+1
.a826		95 01		sta $01,x	                sta 1,x
.a828		20 d5 8c	jsr $8cd5	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a82b		20 42 92	jsr $9242	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a82e		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a831		20 42 92	jsr $9242	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a834		4c 14 a9	jmp $a914	                jmp _check_for_para2
.a837						_prefix_dollar:
.a837		b2 0c		lda ($0c)	                lda (cib)
.a839		c9 24		cmp #$24	                cmp #'$'
.a83b		d0 1c		bne $a859	                bne _prefix_percent
.a83d		20 b7 ac	jsr $acb7	                jsr ed_have_text
.a840		e8		inx		                inx
.a841		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a842		20 e4 ac	jsr $ace4	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a845		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.a848		a9 80		lda #$80	                lda #%10000000
.a84a		04 39		tsb $39		                tsb ed_flags
.a84c		a5 0e		lda $0e		                lda ciblen
.a84e		3a		dec a		                dea                     ; sets Z if A was 1
.a84f		d0 03		bne $a854	                bne +
.a851		4c bc a8	jmp $a8bc	                jmp _line_number_only_from_external
.a854						+
.a854		a0 01		ldy #$01	                ldy #01
.a856		4c 90 a9	jmp $a990	                jmp _check_command
.a859						_prefix_percent:
.a859		b2 0c		lda ($0c)	                lda (cib)
.a85b		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a85d		f0 04		beq $a863	                beq _whole_text
.a85f		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a861		d0 17		bne $a87a	                bne _prefix_semicolon
.a863						_whole_text:
.a863		20 b7 ac	jsr $acb7	                jsr ed_have_text
.a866		a9 01		lda #$01	                lda #01
.a868		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a86a		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a86c						_semicolon_entry:
.a86c		e8		inx		                inx
.a86d		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a86e		20 e4 ac	jsr $ace4	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a871		a9 80		lda #$80	                lda #%10000000
.a873		04 39		tsb $39		                tsb ed_flags
.a875		a0 01		ldy #$01	                ldy #01
.a877		4c 90 a9	jmp $a990	                jmp _check_command
.a87a						_prefix_semicolon:
.a87a		b2 0c		lda ($0c)	                lda (cib)
.a87c		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a87e		d0 0d		bne $a88d	                bne _prefix_number
.a880		20 b7 ac	jsr $acb7	                jsr ed_have_text
.a883		a5 37		lda $37		                lda ed_cur
.a885		95 02		sta $02,x	                sta 2,x
.a887		a5 38		lda $38		                lda ed_cur+1
.a889		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a88b		80 df		bra $a86c	                bra _semicolon_entry
.a88d						_prefix_number:
.a88d		20 04 9e	jsr $9e04	                jsr xt_zero
.a890		20 04 9e	jsr $9e04	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.a893		ca		dex		                dex
.a894		ca		dex		                dex
.a895		ca		dex		                dex
.a896		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a897		a5 0c		lda $0c		                lda cib
.a899		95 02		sta $02,x	                sta 2,x
.a89b		a5 0d		lda $0d		                lda cib+1
.a89d		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a89f		a5 0e		lda $0e		                lda ciblen
.a8a1		95 00		sta $00,x	                sta 0,x
.a8a3		a5 0f		lda $0f		                lda ciblen+1
.a8a5		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a8a7		20 e0 92	jsr $92e0	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a8aa		b5 00		lda $00,x	                lda 0,x
.a8ac		15 01		ora $01,x	                ora 1,x
.a8ae		d0 24		bne $a8d4	                bne _have_unconverted_chars
.a8b0		e8		inx		                inx
.a8b1		e8		inx		                inx
.a8b2		e8		inx		                inx
.a8b3		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a8b4		20 4d 9e	jsr $9e4d	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a8b7		20 88 9c	jsr $9c88	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.a8ba		e8		inx		                inx
.a8bb		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a8bc						_line_number_only_from_external:
.a8bc		20 42 92	jsr $9242	                jsr xt_swap             ; ( addr-t u-t 0 u )
.a8bf		20 c2 ac	jsr $acc2	                jsr ed_is_valid_line
.a8c2		b0 03		bcs $a8c7	                bcs +
.a8c4		4c 94 ac	jmp $ac94	                jmp ed_error_2drop
.a8c7						+
.a8c7		20 42 92	jsr $9242	                jsr xt_swap             ; ( addr-t u-t u 0 )
.a8ca		20 51 ad	jsr $ad51	                jsr ed_para1_to_cur
.a8cd		a9 80		lda #$80	                lda #%10000000
.a8cf		04 39		tsb $39		                tsb ed_flags
.a8d1		4c 6f ab	jmp $ab6f	                jmp ed_cmd_p_from_external
.a8d4						_have_unconverted_chars:
.a8d4		20 9f 86	jsr $869f	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a8d7		ca		dex		                dex
.a8d8		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a8d9		a5 0e		lda $0e		                lda ciblen
.a8db		95 00		sta $00,x	                sta 0,x
.a8dd		a5 0f		lda $0f		                lda ciblen+1
.a8df		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a8e1		20 95 87	jsr $8795	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a8e4		b5 00		lda $00,x	                lda 0,x
.a8e6		15 01		ora $01,x	                ora 1,x
.a8e8		f0 0e		beq $a8f8	                beq _no_command_yet
.a8ea		8a		txa		                txa
.a8eb		18		clc		                clc
.a8ec		69 0a		adc #$0a	                adc #10
.a8ee		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a8ef		a9 80		lda #$80	                lda #%10000000
.a8f1		14 39		trb $39		                trb ed_flags
.a8f3		a0 00		ldy #$00	                ldy #00
.a8f5		4c 90 a9	jmp $a990	                jmp _check_command
.a8f8						_no_command_yet:
.a8f8		e8		inx		                inx
.a8f9		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a8fa		20 80 93	jsr $9380	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a8fd		20 88 9c	jsr $9c88	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a900		20 4d 9e	jsr $9e4d	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a903		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a905		95 06		sta $06,x	                sta 6,x
.a907		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a909		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a90b		e8		inx		                inx
.a90c		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a90d		20 e6 8e	jsr $8ee6	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a910		a9 80		lda #$80	                lda #%10000000
.a912		04 39		tsb $39		                tsb ed_flags
.a914						_check_for_para2:
.a914		a1 02		lda ($02,x)	                lda (2,x)
.a916		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a918		f0 0d		beq $a927	                beq _got_comma
.a91a		38		sec		                sec
.a91b		a5 0e		lda $0e		                lda ciblen
.a91d		f5 00		sbc $00,x	                sbc 0,x
.a91f		a8		tay		                tay
.a920		e8		inx		                inx
.a921		e8		inx		                inx
.a922		e8		inx		                inx
.a923		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a924		4c 90 a9	jmp $a990	                jmp _check_command
.a927						_got_comma:
.a927		f6 02		inc $02,x	                inc 2,x
.a929		d0 02		bne $a92d	                bne +
.a92b		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a92d						+
.a92d		b5 01		lda $01,x	                lda 1,x
.a92f		f0 02		beq $a933	                beq +
.a931		d6 01		dec $01,x	                dec 1,x
.a933						+
.a933		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a935		a1 02		lda ($02,x)	                lda (2,x)
.a937		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a939		d0 14		bne $a94f	                bne _para2_not_dollar
.a93b		38		sec		                sec
.a93c		a5 0e		lda $0e		                lda ciblen
.a93e		f5 02		sbc $02,x	                sbc 2,x
.a940		a8		tay		                tay
.a941		c8		iny		                iny
.a942		5a		phy		                phy
.a943		8a		txa		                txa
.a944		18		clc		                clc
.a945		69 06		adc #$06	                adc #06
.a947		aa		tax		                tax                     ; ( addr-t u-t para1 )
.a948		20 e4 ac	jsr $ace4	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a94b		7a		ply		                ply
.a94c		4c 90 a9	jmp $a990	                jmp _check_command
.a94f						_para2_not_dollar:
.a94f		20 80 93	jsr $9380	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.a952		20 04 9e	jsr $9e04	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.a955		20 04 9e	jsr $9e04	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.a958		20 83 8f	jsr $8f83	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.a95b		20 e6 8e	jsr $8ee6	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.a95e		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.a961		20 80 93	jsr $9380	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.a964		20 e0 92	jsr $92e0	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.a967		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.a96a		20 e6 8e	jsr $8ee6	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.a96d		20 95 87	jsr $8795	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.a970		b5 00		lda $00,x	                lda 0,x
.a972		15 01		ora $01,x	                ora 1,x
.a974		f0 08		beq $a97e	                beq _second_number
.a976		8a		txa		                txa
.a977		18		clc		                clc
.a978		69 0c		adc #$0c	                adc #12
.a97a		aa		tax		                tax                     ; back to ( addr-t u-t )
.a97b		4c 98 ac	jmp $ac98	                jmp ed_error
.a97e						_second_number:
.a97e		e8		inx		                inx
.a97f		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.a980		38		sec		                sec
.a981		a5 0e		lda $0e		                lda ciblen
.a983		f5 00		sbc $00,x	                sbc 0,x
.a985		48		pha		                pha
.a986		20 b7 93	jsr $93b7	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.a989		20 4d 9e	jsr $9e4d	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.a98c		20 28 8c	jsr $8c28	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.a98f		7a		ply		                ply
.a990						_check_command:
.a990		24 39		bit $39		                bit ed_flags
.a992		30 08		bmi $a99c	                bmi _check_command_have_arg
.a994		a5 37		lda $37		                lda ed_cur
.a996		95 02		sta $02,x	                sta 2,x
.a998		a5 38		lda $38		                lda ed_cur+1
.a99a		95 03		sta $03,x	                sta 3,x
.a99c						_check_command_have_arg:
.a99c		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.a99e		85 25		sta $25		                sta tmp1
.a9a0		da		phx		                phx
.a9a1		a2 00		ldx #$00	                ldx #00
.a9a3						_cmd_loop:
.a9a3		bd 7c ad	lda $ad7c,x	                lda ed_cmd_list,x
.a9a6		f0 07		beq $a9af	                beq _illegal_command    ; zero marks end of list
.a9a8		c5 25		cmp $25		                cmp tmp1
.a9aa		f0 07		beq $a9b3	                beq _found_cmd
.a9ac		e8		inx		                inx
.a9ad		80 f4		bra $a9a3	                bra _cmd_loop
.a9af						_illegal_command:
.a9af		fa		plx		                plx
.a9b0		4c 94 ac	jmp $ac94	                jmp ed_error_2drop
.a9b3						_found_cmd:
.a9b3		8a		txa		                txa
.a9b4		0a		asl a		                asl
.a9b5		aa		tax		                tax                     ; X * 2 for table
.a9b6		7c 87 ad	jmp ($ad87,x)	                jmp (ed_cmd_table,x)
.a9b9						ed_next_command:
.a9b9		e8		inx		                inx
.a9ba		e8		inx		                inx
.a9bb		e8		inx		                inx
.a9bc		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.a9bd		4c c7 a7	jmp $a7c7	                jmp ed_input_loop
.a9c0						ed_all_done:
.a9c0		64 0e		stz $0e		                stz ciblen
.a9c2		64 0f		stz $0f		                stz ciblen+1
.a9c4		20 b7 93	jsr $93b7	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.a9c7		a5 3a		lda $3a		                lda ed_base
.a9c9		85 18		sta $18		                sta base
.a9cb		60		rts		                rts
.a9cc						ed_cmd_a:
.a9cc		fa		plx		                plx
.a9cd		e8		inx		                inx
.a9ce		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.a9cf						ed_entry_cmd_i:
.a9cf		20 1a ad	jsr $ad1a	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.a9d2		20 3c 84	jsr $843c	                jsr xt_cr
.a9d5						_next_string_loop:
.a9d5		20 a6 ac	jsr $aca6	                jsr ed_get_input
.a9d8		b2 0c		lda ($0c)	                lda (cib)
.a9da		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.a9dc		d0 16		bne $a9f4	                bne _add_line
.a9de		a4 0e		ldy $0e		                ldy ciblen
.a9e0		c0 01		cpy #$01	                cpy #01
.a9e2		d0 10		bne $a9f4	                bne _add_line
.a9e4		a4 0f		ldy $0f		                ldy ciblen+1
.a9e6		d0 0c		bne $a9f4	                bne _add_line
.a9e8		e8		inx		                inx
.a9e9		e8		inx		                inx
.a9ea		a9 40		lda #$40	                lda #%01000000
.a9ec		04 39		tsb $39		                tsb ed_flags
.a9ee		20 3c 84	jsr $843c	                jsr xt_cr
.a9f1		4c c7 a7	jmp $a7c7	                jmp ed_input_loop
.a9f4						_add_line:
.a9f4		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.a9f7		20 1a 89	jsr $891a	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.a9fa		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.a9fd		20 19 88	jsr $8819	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.aa00		20 cf 83	jsr $83cf	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.aa03		20 9d 93	jsr $939d	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.aa06		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.aa09		20 2c 92	jsr $922c	                jsr xt_store            ; ! ( addr-t u-t here )
.aa0c		20 1a 89	jsr $891a	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.aa0f		a5 00		lda $00		                lda cp
.aa11		18		clc		                clc
.aa12		69 04		adc #$04	                adc #04
.aa14		85 00		sta $00		                sta cp
.aa16		90 02		bcc $aa1a	                bcc +
.aa18		e6 01		inc $01		                inc cp+1
.aa1a						+
.aa1a		e6 37		inc $37		                inc ed_cur
.aa1c		d0 02		bne $aa20	                bne +
.aa1e		e6 38		inc $38		                inc ed_cur+1
.aa20						+
.aa20		20 1a 89	jsr $891a	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.aa23		20 9f 86	jsr $869f	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.aa26		ca		dex		                dex
.aa27		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.aa28		a5 0c		lda $0c		                lda cib
.aa2a		95 00		sta $00,x	                sta 0,x
.aa2c		a5 0d		lda $0d		                lda cib+1
.aa2e		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.aa30		20 42 92	jsr $9242	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.aa33		ca		dex		                dex
.aa34		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aa35		a5 0e		lda $0e		                lda ciblen
.aa37		95 00		sta $00,x	                sta 0,x
.aa39		a5 0f		lda $0f		                lda ciblen+1
.aa3b		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.aa3d		20 f8 8b	jsr $8bf8	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.aa40		18		clc		                clc
.aa41		a5 00		lda $00		                lda cp
.aa43		65 0e		adc $0e		                adc ciblen
.aa45		85 00		sta $00		                sta cp
.aa47		90 06		bcc $aa4f	                bcc +
.aa49		a5 01		lda $01		                lda cp+1
.aa4b		65 0f		adc $0f		                adc ciblen+1
.aa4d		85 01		sta $01		                sta cp+1
.aa4f						+
.aa4f		20 fd 8c	jsr $8cfd	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.aa52		20 2c 92	jsr $922c	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.aa55		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+
.aa58		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.aa5b		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.aa5e		a5 0e		lda $0e		                lda ciblen
.aa60		95 02		sta $02,x	                sta 2,x
.aa62		a5 0f		lda $0f		                lda ciblen+1
.aa64		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.aa66		20 2c 92	jsr $922c	                jsr xt_store            ; ! ( addr-t u-t here )
.aa69		20 3c 84	jsr $843c	                jsr xt_cr
.aa6c		4c d5 a9	jmp $a9d5	                jmp _next_string_loop
.aa6f						ed_cmd_d:
.aa6f		fa		plx		                plx
.aa70		20 b7 ac	jsr $acb7	                jsr ed_have_text
.aa73		20 0c ad	jsr $ad0c	                jsr ed_no_line_zero
.aa76		b5 00		lda $00,x	                lda 0,x
.aa78		15 01		ora $01,x	                ora 1,x
.aa7a		d0 08		bne $aa84	                bne +
.aa7c		20 fd 8c	jsr $8cfd	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.aa7f		20 c1 aa	jsr $aac1	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.aa82		80 33		bra $aab7	                bra _cmd_d_done
.aa84						+
.aa84		20 c2 ac	jsr $acc2	                jsr ed_is_valid_line      ; result is in C flag
.aa87		b0 03		bcs $aa8c	                bcs _cmd_d_loop
.aa89		4c 94 ac	jmp $ac94	                jmp ed_error_2drop
.aa8c						_cmd_d_loop:
.aa8c		20 bf 93	jsr $93bf	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.aa8f		20 05 89	jsr $8905	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.aa92		b5 00		lda $00,x	                lda 0,x
.aa94		15 01		ora $01,x	                ora 1,x
.aa96		d0 0d		bne $aaa5	                bne _cmd_d_done_with_flag
.aa98		e8		inx		                inx
.aa99		e8		inx		                inx                     ; Get rid of the flag from >
.aa9a		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.aa9d		20 c1 aa	jsr $aac1	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.aaa0		20 d5 8c	jsr $8cd5	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.aaa3		80 e7		bra $aa8c	                bra _cmd_d_loop
.aaa5						_cmd_d_done_with_flag:
.aaa5		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.aaa6		e8		inx		                inx
.aaa7		b5 02		lda $02,x	                lda 2,x
.aaa9		d0 02		bne $aaad	                bne +
.aaab		d6 03		dec $03,x	                dec 3,x
.aaad						+
.aaad		d6 02		dec $02,x	                dec 2,x
.aaaf		b5 02		lda $02,x	                lda 2,x
.aab1		85 37		sta $37		                sta ed_cur
.aab3		b5 03		lda $03,x	                lda 3,x
.aab5		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.aab7						_cmd_d_done:
.aab7		a9 40		lda #$40	                lda #%01000000
.aab9		04 39		tsb $39		                tsb ed_flags
.aabb		20 3c 84	jsr $843c	                jsr xt_cr
.aabe		4c b9 a9	jmp $a9b9	                jmp ed_next_command
.aac1						_cmd_d_common:
.aac1		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.aac4		20 1a ad	jsr $ad1a	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.aac7		20 19 88	jsr $8819	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.aaca		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.aacd		20 d5 8c	jsr $8cd5	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.aad0		20 1a ad	jsr $ad1a	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.aad3		20 2c 92	jsr $922c	                jsr xt_store            ; ! ( addr-t u-t )
.aad6		60		rts		                rts
.aad7						ed_cmd_equ:
.aad7		fa		plx		                plx
.aad8		a5 35		lda $35		                lda ed_head
.aada		05 36		ora $36		                ora ed_head+1
.aadc		d0 08		bne $aae6	                bne _cmd_equ_have_text
.aade		ca		dex		                dex
.aadf		ca		dex		                dex
.aae0		74 00		stz $00,x	                stz 0,x
.aae2		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.aae4		80 21		bra $ab07	                bra _cmd_equ_done
.aae6						_cmd_equ_have_text:
.aae6		20 0c ad	jsr $ad0c	                jsr ed_no_line_zero
.aae9		24 39		bit $39		                bit ed_flags
.aaeb		30 0c		bmi $aaf9	                bmi _cmd_equ_have_para
.aaed		ca		dex		                dex
.aaee		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.aaef		a5 37		lda $37		                lda ed_cur
.aaf1		95 00		sta $00,x	                sta 0,x
.aaf3		a5 38		lda $38		                lda ed_cur+1
.aaf5		95 01		sta $01,x	                sta 1,x
.aaf7		80 0e		bra $ab07	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.aaf9						_cmd_equ_have_para:
.aaf9		b5 00		lda $00,x	                lda 0,x
.aafb		15 01		ora $01,x	                ora 1,x
.aafd		d0 05		bne $ab04	                bne _cmd_equ_two_paras
.aaff		20 fd 8c	jsr $8cfd	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.ab02		80 03		bra $ab07	                bra _cmd_equ_done
.ab04						_cmd_equ_two_paras:
.ab04		20 9f 86	jsr $869f	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.ab07						_cmd_equ_done:
.ab07		20 3c 84	jsr $843c	                jsr xt_cr               ; number goes on new line
.ab0a		20 f4 94	jsr $94f4	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.ab0d		20 3c 84	jsr $843c	                jsr xt_cr
.ab10		4c b9 a9	jmp $a9b9	                jmp ed_next_command
.ab13						ed_cmd_f:
.ab13		fa		plx		                plx
.ab14		24 39		bit $39		                bit ed_flags
.ab16		30 17		bmi $ab2f	                bmi _cmd_f_have_para
.ab18		20 3c 84	jsr $843c	                jsr xt_cr
.ab1b		20 80 93	jsr $9380	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.ab1e		20 83 8f	jsr $8f83	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.ab21		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.ab24		20 f4 94	jsr $94f4	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.ab27		20 88 9c	jsr $9c88	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.ab2a		20 e6 8e	jsr $8ee6	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.ab2d		80 11		bra $ab40	                bra _cmd_f_done
.ab2f						_cmd_f_have_para:
.ab2f		20 fd 8c	jsr $8cfd	                jsr xt_over
.ab32		20 3c 84	jsr $843c	                jsr xt_cr
.ab35		20 f4 94	jsr $94f4	                jsr xt_u_dot
.ab38		b5 02		lda $02,x	                lda 2,x
.ab3a		95 06		sta $06,x	                sta 6,x
.ab3c		b5 03		lda $03,x	                lda 3,x
.ab3e		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.ab40						_cmd_f_done:
.ab40		20 3c 84	jsr $843c	                jsr xt_cr
.ab43		4c b9 a9	jmp $a9b9	                jmp ed_next_command
.ab46						ed_cmd_i:
.ab46		fa		plx		                plx
.ab47		e8		inx		                inx
.ab48		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.ab49		24 39		bit $39		                bit ed_flags
.ab4b		30 08		bmi $ab55	                bmi _cmd_i_have_para
.ab4d		a5 37		lda $37		                lda ed_cur
.ab4f		95 00		sta $00,x	                sta 0,x
.ab51		a5 38		lda $38		                lda ed_cur+1
.ab53		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.ab55						_cmd_i_have_para:
.ab55		b5 00		lda $00,x	                lda 0,x
.ab57		15 01		ora $01,x	                ora 1,x
.ab59		f0 09		beq $ab64	                beq _cmd_i_done
.ab5b		20 d5 8c	jsr $8cd5	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.ab5e		20 04 9e	jsr $9e04	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.ab61		20 a4 8b	jsr $8ba4	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.ab64						_cmd_i_done:
.ab64		4c cf a9	jmp $a9cf	                jmp ed_entry_cmd_i
.ab67						ed_cmd_n:
.ab67		fa		plx		                plx
.ab68		a9 01		lda #$01	                lda #%00000001
.ab6a		04 39		tsb $39		                tsb ed_flags
.ab6c		80 05		bra $ab73	                bra ed_cmd_p_entry_for_cmd_n
.ab6e						ed_cmd_p:
.ab6e		fa		plx		                plx
.ab6f						ed_cmd_p_from_external:
.ab6f		a9 01		lda #$01	                lda #%00000001
.ab71		14 39		trb $39		                trb ed_flags
.ab73						ed_cmd_p_entry_for_cmd_n:
.ab73		20 b7 ac	jsr $acb7	                jsr ed_have_text
.ab76		20 0c ad	jsr $ad0c	                jsr ed_no_line_zero
.ab79		20 3c 84	jsr $843c	                jsr xt_cr
.ab7c		b5 00		lda $00,x	                lda 0,x
.ab7e		15 01		ora $01,x	                ora 1,x
.ab80		d0 10		bne $ab92	                bne _cmd_p_loop
.ab82		b5 02		lda $02,x	                lda 2,x
.ab84		85 37		sta $37		                sta ed_cur
.ab86		b5 03		lda $03,x	                lda 3,x
.ab88		85 38		sta $38		                sta ed_cur+1
.ab8a		20 fd 8c	jsr $8cfd	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ab8d		20 bb ab	jsr $abbb	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ab90		80 26		bra $abb8	                bra _cmd_p_all_done
.ab92						_cmd_p_loop:
.ab92		20 bf 93	jsr $93bf	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab95		20 05 89	jsr $8905	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab98		b5 00		lda $00,x	                lda 0,x
.ab9a		15 01		ora $01,x	                ora 1,x
.ab9c		d0 10		bne $abae	                bne _cmd_p_done
.ab9e		e8		inx		                inx
.ab9f		e8		inx		                inx                     ; Get rid of the flag from >
.aba0		20 fd 8c	jsr $8cfd	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.aba3		20 bb ab	jsr $abbb	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.aba6		f6 02		inc $02,x	                inc 2,x
.aba8		d0 02		bne $abac	                bne +
.abaa		f6 03		inc $03,x	                inc 3,x
.abac						+
.abac		80 e4		bra $ab92	                bra _cmd_p_loop
.abae						_cmd_p_done:
.abae		e8		inx		                inx
.abaf		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.abb0		b5 00		lda $00,x	                lda 0,x
.abb2		85 37		sta $37		                sta ed_cur
.abb4		b5 01		lda $01,x	                lda 1,x
.abb6		85 38		sta $38		                sta ed_cur+1
.abb8						_cmd_p_all_done:
.abb8		4c b9 a9	jmp $a9b9	                jmp ed_next_command
.abbb						_cmd_p_common:
.abbb		a5 39		lda $39		                lda ed_flags
.abbd		4a		lsr a		                lsr                     ; bit 0 now in carry
.abbe		90 0b		bcc $abcb	                bcc _cmd_p_common_no_num
.abc0		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.abc3		20 f4 94	jsr $94f4	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.abc6		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.abc8		20 c4 86	jsr $86c4	                jsr emit_a
.abcb						_cmd_p_common_no_num:
.abcb		20 1a ad	jsr $ad1a	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.abce		20 5a ad	jsr $ad5a	                jsr ed_print_addr
.abd1		60		rts		                rts
.abd2						ed_cmd_q:
.abd2		fa		plx		                plx
.abd3		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.abd5		50 03		bvc $abda	                bvc +
.abd7		4c 94 ac	jmp $ac94	                jmp ed_error_2drop
.abda						+
.abda		4c c0 a9	jmp $a9c0	                jmp ed_all_done            ; can't fall thru because of PLX
.abdd						ed_cmd_qq:
.abdd		fa		plx		                plx
.abde		4c c0 a9	jmp $a9c0	                jmp ed_all_done
.abe1						ed_cmd_w:
.abe1		fa		plx		                plx
.abe2		20 b7 ac	jsr $acb7	                jsr ed_have_text
.abe5		24 39		bit $39		                bit ed_flags
.abe7		30 13		bmi $abfc	                bmi _cmd_w_have_para
.abe9		b5 06		lda $06,x	                lda 6,x
.abeb		15 07		ora $07,x	                ora 7,x
.abed		d0 03		bne $abf2	                bne +
.abef		4c 94 ac	jmp $ac94	                jmp ed_error_2drop
.abf2						+
.abf2		b5 06		lda $06,x	                lda 6,x
.abf4		95 02		sta $02,x	                sta 2,x
.abf6		b5 07		lda $07,x	                lda 7,x
.abf8		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.abfa		80 08		bra $ac04	                bra _cmd_w_para_ready
.abfc						_cmd_w_have_para:
.abfc		b5 02		lda $02,x	                lda 2,x
.abfe		95 06		sta $06,x	                sta 6,x
.ac00		b5 03		lda $03,x	                lda 3,x
.ac02		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.ac04						_cmd_w_para_ready:
.ac04		a9 35		lda #$35	                lda #<ed_head
.ac06		95 00		sta $00,x	                sta 0,x
.ac08		a9 00		lda #$00	                lda #>ed_head
.ac0a		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ac0c		20 fd 8c	jsr $8cfd	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ac0f		20 80 93	jsr $9380	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ac12						_cmd_w_loop:
.ac12		20 19 88	jsr $8819	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ac15		b5 00		lda $00,x	                lda 0,x
.ac17		15 01		ora $01,x	                ora 1,x
.ac19		f0 55		beq $ac70	                beq _cmd_w_eol
.ac1b		20 bf 93	jsr $93bf	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ac1e		20 a9 94	jsr $94a9	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ac21		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ac24		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ac27		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ac2a		20 19 88	jsr $8819	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ac2d		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ac30		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ac33		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ac36		20 19 88	jsr $8819	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ac39		20 88 9c	jsr $9c88	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ac3c		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ac3f		20 83 8f	jsr $8f83	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ac42		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ac45		20 80 93	jsr $9380	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ac48		20 f8 8b	jsr $8bf8	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ac4b		20 e6 8e	jsr $8ee6	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ac4e		20 2f 94	jsr $942f	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ac51		20 88 9c	jsr $9c88	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ac54		20 4b 8e	jsr $8e4b	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ac57		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ac5a		ca		dex		                dex
.ac5b		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ac5c		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ac5e		95 00		sta $00,x	                sta 0,x
.ac60		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ac62		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ac65		20 2c 92	jsr $922c	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ac68		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ac6b		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ac6e		80 a2		bra $ac12	                bra _cmd_w_loop
.ac70						_cmd_w_eol:
.ac70		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ac73		20 e6 8e	jsr $8ee6	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ac76		20 dc 8b	jsr $8bdc	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ac79		b5 00		lda $00,x	                lda 0,x
.ac7b		95 04		sta $04,x	                sta 4,x
.ac7d		b5 01		lda $01,x	                lda 1,x
.ac7f		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ac81		20 3c 84	jsr $843c	                jsr xt_cr
.ac84		20 9f 86	jsr $869f	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ac87		20 f4 94	jsr $94f4	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ac8a		20 3c 84	jsr $843c	                jsr xt_cr
.ac8d		a9 40		lda #$40	                lda #%01000000
.ac8f		14 39		trb $39		                trb ed_flags
.ac91		4c b9 a9	jmp $a9b9	                jmp ed_next_command
.ac94						ed_error_2drop:
.ac94		e8		inx		                inx
.ac95		e8		inx		                inx                     ; drop through to _error_1drop
.ac96						ed_error_1drop:
.ac96		e8		inx		                inx
.ac97		e8		inx		                inx                     ; drop through to _error
.ac98						ed_error:
.ac98		20 3c 84	jsr $843c	                jsr xt_cr
.ac9b		a9 3f		lda #$3f	                lda #'?'
.ac9d		20 c4 86	jsr $86c4	                jsr emit_a
.aca0		20 3c 84	jsr $843c	                jsr xt_cr
.aca3		4c c7 a7	jmp $a7c7	                jmp ed_input_loop
.aca6						ed_get_input:
.aca6		20 34 8f	jsr $8f34	                jsr xt_refill           ;  ( addr-t u-t f )
.aca9		b5 00		lda $00,x	                lda 0,x
.acab		15 01		ora $01,x	                ora 1,x
.acad		d0 05		bne $acb4	                bne +
.acaf		7a		ply		                ply
.acb0		7a		ply		                ply
.acb1		4c 96 ac	jmp $ac96	                jmp ed_error_1drop
.acb4						+
.acb4		e8		inx		                inx
.acb5		e8		inx		                inx
.acb6		60		rts		                rts
.acb7						ed_have_text:
.acb7		a5 35		lda $35		                lda ed_head
.acb9		05 36		ora $36		                ora ed_head+1
.acbb		d0 04		bne $acc1	                bne +
.acbd		7a		ply		                ply
.acbe		7a		ply		                ply
.acbf		80 d7		bra $ac98	                bra ed_error
.acc1						+
.acc1		60		rts		                rts
.acc2						ed_is_valid_line:
.acc2		38		sec		                sec                             ; default is legal line number
.acc3		b5 00		lda $00,x	                lda 0,x
.acc5		15 01		ora $01,x	                ora 1,x
.acc7		f0 19		beq $ace2	                beq _is_valid_line_nope_zero    ; ( n )
.acc9		20 9f 86	jsr $869f	                jsr xt_dup                      ; DUP ( n n )
.accc		20 e4 ac	jsr $ace4	                jsr ed_last_line                  ; ( n n last )
.accf		20 42 92	jsr $9242	                jsr xt_swap                     ; SWAP ( n last n )
.acd2		20 dc 89	jsr $89dc	                jsr xt_less_than                ; < ( n f )
.acd5		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.acd7		15 01		ora $01,x	                ora 1,x
.acd9		d0 05		bne $ace0	                bne _is_valid_line_too_small
.acdb		e8		inx		                inx
.acdc		e8		inx		                inx                     ; DROP flag ( n )
.acdd		38		sec		                sec                     ; Who knows what's happened to C by now
.acde		80 03		bra $ace3	                bra _is_valid_line_done ; only one exit from this routine
.ace0						_is_valid_line_too_small:
.ace0		e8		inx		                inx
.ace1		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ace2						_is_valid_line_nope_zero:
.ace2		18		clc		                clc                     ; drop through to _is_valid_line_done
.ace3						_is_valid_line_done:
.ace3		60		rts		                rts
.ace4						ed_last_line:
.ace4		64 25		stz $25		                stz tmp1
.ace6		64 26		stz $26		                stz tmp1+1
.ace8		ca		dex		                dex
.ace9		ca		dex		                dex                     ; ( ? )
.acea		a9 35		lda #$35	                lda #<ed_head
.acec		95 00		sta $00,x	                sta 0,x
.acee		a9 00		lda #$00	                lda #>ed_head
.acf0		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.acf2						_last_line_loop:
.acf2		20 19 88	jsr $8819	                jsr xt_fetch            ; ( addr | 0 )
.acf5		b5 00		lda $00,x	                lda 0,x
.acf7		15 01		ora $01,x	                ora 1,x
.acf9		f0 08		beq $ad03	                beq _last_line_done
.acfb		e6 25		inc $25		                inc tmp1
.acfd		d0 02		bne $ad01	                bne +
.acff		e6 26		inc $26		                inc tmp1+1
.ad01						+
.ad01		80 ef		bra $acf2	                bra _last_line_loop
.ad03						_last_line_done:
.ad03		a5 25		lda $25		                lda tmp1
.ad05		95 00		sta $00,x	                sta 0,x
.ad07		a5 26		lda $26		                lda tmp1+1
.ad09		95 01		sta $01,x	                sta 1,x                 ; ( u )
.ad0b		60		rts		                rts
.ad0c						ed_no_line_zero:
.ad0c		b5 02		lda $02,x	                lda 2,x
.ad0e		15 03		ora $03,x	                ora 3,x
.ad10		d0 07		bne $ad19	                bne _no_line_zero_done
.ad12		24 39		bit $39		                bit ed_flags
.ad14		10 03		bpl $ad19	                bpl _no_line_zero_done
.ad16		4c 94 ac	jmp $ac94	                jmp ed_error_2drop
.ad19						_no_line_zero_done:
.ad19		60		rts		                rts
.ad1a						ed_num_to_addr:
.ad1a		ca		dex		                dex
.ad1b		ca		dex		                dex                     ; ( u ? )
.ad1c		a9 35		lda #$35	                lda #<ed_head
.ad1e		95 00		sta $00,x	                sta 0,x
.ad20		a9 00		lda #$00	                lda #>ed_head
.ad22		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.ad24		b5 02		lda $02,x	                lda 2,x
.ad26		15 03		ora $03,x	                ora 3,x
.ad28		d0 05		bne $ad2f	                bne _num_to_addr_loop
.ad2a		20 28 8c	jsr $8c28	                jsr xt_nip              ; ( addr-h )
.ad2d		80 21		bra $ad50	                bra _num_to_addr_done
.ad2f						_num_to_addr_loop:
.ad2f		20 19 88	jsr $8819	                jsr xt_fetch            ; @ ( u addr1 )
.ad32		b5 00		lda $00,x	                lda 0,x
.ad34		15 01		ora $01,x	                ora 1,x
.ad36		d0 05		bne $ad3d	                bne +
.ad38		20 28 8c	jsr $8c28	                jsr xt_nip              ; NIP ( addr1 )
.ad3b		80 13		bra $ad50	                bra _num_to_addr_done
.ad3d						+
.ad3d		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( addr1 u )
.ad40		20 d5 8c	jsr $8cd5	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.ad43		b5 00		lda $00,x	                lda 0,x
.ad45		15 01		ora $01,x	                ora 1,x
.ad47		f0 05		beq $ad4e	                beq _num_to_addr_finished
.ad49		20 42 92	jsr $9242	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.ad4c		80 e1		bra $ad2f	                bra _num_to_addr_loop
.ad4e						_num_to_addr_finished:
.ad4e		e8		inx		                inx
.ad4f		e8		inx		                inx                     ; ( addr )
.ad50						_num_to_addr_done:
.ad50		60		rts		                rts
.ad51						ed_para1_to_cur:
.ad51		b5 02		lda $02,x	                lda 2,x
.ad53		85 37		sta $37		                sta ed_cur
.ad55		b5 03		lda $03,x	                lda 3,x
.ad57		85 38		sta $38		                sta ed_cur+1
.ad59		60		rts		                rts
.ad5a						ed_print_addr:
.ad5a		20 e1 8c	jsr $8ce1	                jsr xt_one_plus
.ad5d		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; ( addr+2 )
.ad60		20 9f 86	jsr $869f	                jsr xt_dup              ; ( addr+2 addr+2 )
.ad63		20 e1 8c	jsr $8ce1	                jsr xt_one_plus
.ad66		20 e1 8c	jsr $8ce1	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.ad69		20 19 88	jsr $8819	                jsr xt_fetch            ; ( addr+2 u-s )
.ad6c		20 42 92	jsr $9242	                jsr xt_swap             ; ( u-s addr+2 )
.ad6f		20 19 88	jsr $8819	                jsr xt_fetch            ; ( u-s addr-s )
.ad72		20 42 92	jsr $9242	                jsr xt_swap             ; ( addr-s u-s )
.ad75		20 c9 94	jsr $94c9	                jsr xt_type
.ad78		20 3c 84	jsr $843c	                jsr xt_cr
.ad7b		60		rts		                rts
>ad7c		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ad84		71 51 00
.ad87						ed_cmd_table:
>ad87		cc a9 13 ab 46 ab 6f aa		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ad8f		6e ab 67 ab
>ad93		d7 aa e1 ab d2 ab dd ab		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ad9b						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ad9b						xt_blk:
.ad9b		a9 04		lda #$04	                lda #blk_offset
.ad9d		4c 59 d6	jmp $d659	                jmp push_upvar_tos
.ada0						z_blk:
.ada0						xt_blkbuffer:
.ada0		ca		dex		                dex
.ada1		ca		dex		                dex
.ada2		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ada4		b1 08		lda ($08),y	                lda (up),y
.ada6		95 00		sta $00,x	                sta 0,x
.ada8		c8		iny		                iny             ; Move along to the next byte
.ada9		b1 08		lda ($08),y	                lda (up),y
.adab		95 01		sta $01,x	                sta 1,x
.adad		60		rts		z_blkbuffer:    rts
.adae						xt_block:
.adae		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.adb0		b1 08		lda ($08),y	                lda (up),y
.adb2		d5 00		cmp $00,x	                cmp 0,x
.adb4		d0 0f		bne $adc5	                bne _not_in_buffer
.adb6		c8		iny		                iny
.adb7		b1 08		lda ($08),y	                lda (up),y
.adb9		d5 01		cmp $01,x	                cmp 1,x
.adbb		d0 08		bne $adc5	                bne _not_in_buffer
.adbd		a0 30		ldy #$30	                ldy #buffstatus_offset
.adbf		b1 08		lda ($08),y	                lda (up),y
.adc1		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.adc3		d0 30		bne $adf5	                bne _done       ; It's already in the buffer and in use.
.adc5						_not_in_buffer:
.adc5		a0 30		ldy #$30	                ldy #buffstatus_offset
.adc7		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.adc9		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.adcb		d0 0c		bne $add9	                bne _buffer_available ; Unused or not dirty = available
.adcd		20 a0 ad	jsr $ada0	                jsr xt_blkbuffer
.add0		20 aa af	jsr $afaa	                jsr xt_buffblocknum
.add3		20 19 88	jsr $8819	                jsr xt_fetch
.add6		20 97 af	jsr $af97	                jsr xt_block_write
.add9						_buffer_available:
.add9		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.addb		b5 00		lda $00,x	                lda 0,x
.addd		91 08		sta ($08),y	                sta (up),y
.addf		c8		iny		                iny
.ade0		b5 01		lda $01,x	                lda 1,x
.ade2		91 08		sta ($08),y	                sta (up),y
.ade4		20 a0 ad	jsr $ada0	                jsr xt_blkbuffer
.ade7		20 42 92	jsr $9242	                jsr xt_swap
.adea		20 7f af	jsr $af7f	                jsr xt_block_read
.aded		a9 01		lda #$01	                lda #1
.adef		a0 30		ldy #$30	                ldy #buffstatus_offset
.adf1		91 08		sta ($08),y	                sta (up),y
.adf3		ca		dex		                dex
.adf4		ca		dex		                dex
.adf5						_done:
.adf5		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.adf7		b1 08		lda ($08),y	                lda (up),y
.adf9		95 00		sta $00,x	                sta 0,x
.adfb		c8		iny		                iny
.adfc		b1 08		lda ($08),y	                lda (up),y
.adfe		95 01		sta $01,x	                sta 1,x
.ae00		60		rts		z_block:        rts
.ae01						xt_block_c65_init:
=0						io_blk_status = 0
=0						io_blk_action = 0
=0						io_blk_number = 0
=0						io_blk_buffer = 0
.ae01		a9 ff		lda #$ff	                lda #$ff
.ae03		8d 11 f0	sta $f011	                sta io_blk_status
.ae06		a9 00		lda #$00	                lda #$0
.ae08		8d 10 f0	sta $f010	                sta io_blk_action
.ae0b		ad 11 f0	lda $f011	                lda io_blk_status      ; $0 if OK, $ff otherwise
.ae0e		49 ff		eor #$ff	                eor #$ff            ; invert to forth true/false
.ae10		ca		dex		                dex
.ae11		ca		dex		                dex
.ae12		95 00		sta $00,x	                sta 0,x             ; true ($ff) if OK, false (0) otherwise
.ae14		95 01		sta $01,x	                sta 1,x
.ae16		ca		dex		                dex
.ae17		ca		dex		                dex
.ae18		a9 3b		lda #$3b	                lda #<c65_blk_read
.ae1a		95 00		sta $00,x	                sta 0,x
.ae1c		a9 ae		lda #$ae	                lda #>c65_blk_read
.ae1e		95 01		sta $01,x	                sta 1,x
.ae20		20 8d af	jsr $af8d	                jsr xt_block_read_vector
.ae23		20 2c 92	jsr $922c	                jsr xt_store
.ae26		ca		dex		                dex
.ae27		ca		dex		                dex
.ae28		a9 37		lda #$37	                lda #<c65_blk_write
.ae2a		95 00		sta $00,x	                sta 0,x
.ae2c		a9 ae		lda #$ae	                lda #>c65_blk_write
.ae2e		95 01		sta $01,x	                sta 1,x
.ae30		20 a5 af	jsr $afa5	                jsr xt_block_write_vector
.ae33		20 2c 92	jsr $922c	                jsr xt_store
.ae36						z_block_c65_init:
.ae36		60		rts		                rts
.ae37		a0 02		ldy #$02	c65_blk_write:  ldy #2
.ae39		80 02		bra $ae3d	                bra c65_blk_rw
.ae3b		a0 01		ldy #$01	c65_blk_read:   ldy #1
.ae3d		b5 00		lda $00,x	c65_blk_rw:     lda 0,x                 ; ( addr blk# )
.ae3f		8d 12 f0	sta $f012	                sta io_blk_number
.ae42		b5 01		lda $01,x	                lda 1,x
.ae44		8d 13 f0	sta $f013	                sta io_blk_number+1
.ae47		b5 02		lda $02,x	                lda 2,x
.ae49		8d 14 f0	sta $f014	                sta io_blk_buffer
.ae4c		b5 03		lda $03,x	                lda 3,x
.ae4e		8d 15 f0	sta $f015	                sta io_blk_buffer+1
.ae51		8c 10 f0	sty $f010	                sty io_blk_action       ; trigger the r/w
.ae54		e8		inx		                inx                     ; clean up stack
.ae55		e8		inx		                inx
.ae56		e8		inx		                inx
.ae57		e8		inx		                inx
.ae58		60		rts		                rts
.ae59						xt_block_ramdrive_init:
.ae59		20 9d d7	jsr $d79d	                jsr underflow_1
.ae5c		20 89 a1	jsr $a189	                jsr sliteral_runtime
>ae5f		67 ae 18 01			                .word ramdrive_code, ramdrive_code_end-ramdrive_code
.ae63		20 b1 88	jsr $88b1	                jsr xt_evaluate
.ae66						z_block_ramdrive_init:
.ae66		60		rts		                rts
.ae67						ramdrive_code:
>ae67		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>ae6f		77 61 70 20 64 65 63 69 6d 61 6c
>ae7a		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>ae81		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>ae85		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>ae8d		20 72 61 6d 64 72 69 76 65
>ae96		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>ae9e		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>aeac		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>aeb4		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>aec4		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>aed4		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>aedc		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>aeeb		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>aef3		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af03		31 30 32 34 20 6d 6f 76 65 20 3b
>af0e		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>af16		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>af26		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>af36		20 21
>af38		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>af40		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>af50		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>af60		6f 72 20 21
>af64		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>af6c		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>af7c		65 20 21
.af7f						ramdrive_code_end:
.af7f						xt_block_read:
.af7f		a0 32		ldy #$32	                ldy #blockread_offset
.af81		b1 08		lda ($08),y	                lda (up),y
.af83		85 25		sta $25		                sta tmp1
.af85		c8		iny		                iny
.af86		b1 08		lda ($08),y	                lda (up),y
.af88		85 26		sta $26		                sta tmp1+1
.af8a		6c 25 00	jmp ($0025)	                jmp (tmp1)
.af8d						z_block_read:
.af8d						xt_block_read_vector:
.af8d		a9 32		lda #$32	                lda #blockread_offset
.af8f		4c 59 d6	jmp $d659	                jmp push_upvar_tos
.af92						z_block_read_vector:
.af92						xt_block_word_error:
.af92		a9 0c		lda #$0c	                lda #err_blockwords
.af94		4c b3 d7	jmp $d7b3	                jmp error       ; no RTS needed
.af97						xt_block_write:
.af97		a0 34		ldy #$34	                ldy #blockwrite_offset
.af99		b1 08		lda ($08),y	                lda (up),y
.af9b		85 25		sta $25		                sta tmp1
.af9d		c8		iny		                iny
.af9e		b1 08		lda ($08),y	                lda (up),y
.afa0		85 26		sta $26		                sta tmp1+1
.afa2		6c 25 00	jmp ($0025)	                jmp (tmp1)
.afa5						z_block_write:
.afa5						xt_block_write_vector:
.afa5		a9 34		lda #$34	                lda #blockwrite_offset
.afa7		4c 59 d6	jmp $d659	                jmp push_upvar_tos
.afaa						z_block_write_vector:
.afaa						xt_buffblocknum:
.afaa		a9 2e		lda #$2e	                lda #buffblocknum_offset
.afac		4c 59 d6	jmp $d659	                jmp push_upvar_tos
.afaf						z_buffblocknum:
.afaf						xt_buffer:
.afaf		a0 30		ldy #$30	                ldy #buffstatus_offset
.afb1		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.afb3		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.afb5		d0 0c		bne $afc3	                bne _buffer_available ; Unused or not dirty = available
.afb7		20 a0 ad	jsr $ada0	                jsr xt_blkbuffer
.afba		20 aa af	jsr $afaa	                jsr xt_buffblocknum
.afbd		20 19 88	jsr $8819	                jsr xt_fetch
.afc0		20 97 af	jsr $af97	                jsr xt_block_write
.afc3						_buffer_available:
.afc3		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.afc5		b5 00		lda $00,x	                lda 0,x
.afc7		91 08		sta ($08),y	                sta (up),y
.afc9		c8		iny		                iny
.afca		b5 01		lda $01,x	                lda 1,x
.afcc		91 08		sta ($08),y	                sta (up),y
.afce		a9 01		lda #$01	                lda #1
.afd0		a0 30		ldy #$30	                ldy #buffstatus_offset
.afd2		91 08		sta ($08),y	                sta (up),y
.afd4		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.afd6		b1 08		lda ($08),y	                lda (up),y
.afd8		95 00		sta $00,x	                sta 0,x
.afda		c8		iny		                iny
.afdb		b1 08		lda ($08),y	                lda (up),y
.afdd		95 01		sta $01,x	                sta 1,x
.afdf		60		rts		z_buffer:       rts
.afe0						xt_buffstatus:
.afe0		a9 30		lda #$30	                lda #buffstatus_offset
.afe2		4c 59 d6	jmp $d659	                jmp push_upvar_tos
.afe5						z_buffstatus:
.afe5						xt_empty_buffers:
.afe5		a0 30		ldy #$30	                ldy #buffstatus_offset
.afe7		a9 00		lda #$00	                lda #0
.afe9		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.afeb						z_empty_buffers:
.afeb		60		rts		                rts
.afec						xt_flush:
.afec		20 47 b0	jsr $b047	                jsr xt_save_buffers
.afef		a0 30		ldy #$30	                ldy #buffstatus_offset
.aff1		a9 00		lda #$00	                lda #0
.aff3		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.aff5						z_flush:
.aff5		60		rts		                rts
.aff6						xt_list:
.aff6		20 9d d7	jsr $d79d	                jsr underflow_1
.aff9		20 62 b0	jsr $b062	                jsr xt_scr
.affc		20 2c 92	jsr $922c	                jsr xt_store
.afff		20 01 b1	jsr $b101	                jsr xt_editor_l
.b002		60		rts		z_list:         rts
.b003						xt_load:
.b003		20 9d d7	jsr $d79d	                jsr underflow_1
.b006		a0 05		ldy #$05	                ldy #blk_offset+1
.b008		b1 08		lda ($08),y	                lda (up),y
.b00a		48		pha		                pha
.b00b		88		dey		                dey
.b00c		b1 08		lda ($08),y	                lda (up),y
.b00e		48		pha		                pha
.b00f		b5 00		lda $00,x	                lda 0,x
.b011		91 08		sta ($08),y	                sta (up),y
.b013		c8		iny		                iny
.b014		b5 01		lda $01,x	                lda 1,x
.b016		91 08		sta ($08),y	                sta (up),y
.b018		20 ae ad	jsr $adae	                jsr xt_block
.b01b		ca		dex		                dex
.b01c		ca		dex		                dex
.b01d		a9 04		lda #$04	                lda #4
.b01f		95 01		sta $01,x	                sta 1,x
.b021		74 00		stz $00,x	                stz 0,x
.b023		20 ab 88	jsr $88ab	                jsr load_evaluate
.b026		a0 04		ldy #$04	                ldy #blk_offset
.b028		68		pla		                pla
.b029		91 08		sta ($08),y	                sta (up),y
.b02b		c8		iny		                iny
.b02c		68		pla		                pla
.b02d		91 08		sta ($08),y	                sta (up),y
.b02f		88		dey		                dey
.b030		11 08		ora ($08),y	                ora (up),y
.b032		f0 12		beq $b046	                beq _done
.b034		ca		dex		                dex
.b035		ca		dex		                dex
.b036		a0 04		ldy #$04	                ldy #blk_offset
.b038		b1 08		lda ($08),y	                lda (up),y
.b03a		95 00		sta $00,x	                sta 0,x
.b03c		c8		iny		                iny
.b03d		b1 08		lda ($08),y	                lda (up),y
.b03f		95 01		sta $01,x	                sta 1,x
.b041		20 ae ad	jsr $adae	                jsr xt_block
.b044		e8		inx		                inx
.b045		e8		inx		                inx
.b046						_done:
.b046		60		rts		z_load:         rts
.b047						xt_save_buffers:
.b047		a0 30		ldy #$30	                ldy #buffstatus_offset
.b049		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b04b		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b04d		d0 12		bne $b061	                bne _done       ; Either not used or not dirty = done!
.b04f		20 a0 ad	jsr $ada0	                jsr xt_blkbuffer
.b052		20 aa af	jsr $afaa	                jsr xt_buffblocknum
.b055		20 19 88	jsr $8819	                jsr xt_fetch
.b058		20 97 af	jsr $af97	                jsr xt_block_write
.b05b		a9 01		lda #$01	                lda #1
.b05d		a0 30		ldy #$30	                ldy #buffstatus_offset
.b05f		91 08		sta ($08),y	                sta (up),y
.b061						_done:
.b061		60		rts		z_save_buffers: rts
.b062						xt_scr:
.b062		a9 06		lda #$06	                lda #scr_offset
.b064		4c 59 d6	jmp $d659	                jmp push_upvar_tos
.b067						z_scr:
.b067						xt_thru:
.b067		20 a2 d7	jsr $d7a2	                jsr underflow_2
.b06a		b5 01		lda $01,x	                lda 1,x
.b06c		48		pha		                pha
.b06d		b5 00		lda $00,x	                lda 0,x
.b06f		48		pha		                pha
.b070		e8		inx		                inx
.b071		e8		inx		                inx
.b072						_thru_loop:
.b072		b5 01		lda $01,x	                lda 1,x
.b074		48		pha		                pha
.b075		b5 00		lda $00,x	                lda 0,x
.b077		48		pha		                pha
.b078		20 03 b0	jsr $b003	                jsr xt_load
.b07b		68		pla		                pla
.b07c		85 25		sta $25		                sta tmp1
.b07e		68		pla		                pla
.b07f		85 26		sta $26		                sta tmp1+1
.b081		68		pla		                pla
.b082		85 27		sta $27		                sta tmp2
.b084		68		pla		                pla
.b085		85 28		sta $28		                sta tmp2+1
.b087		c5 26		cmp $26		                cmp tmp1+1
.b089		d0 08		bne $b093	                bne _next_screen
.b08b		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b08d		c5 25		cmp $25		                cmp tmp1
.b08f		d0 02		bne $b093	                bne _next_screen
.b091		80 18		bra $b0ab	                bra _done       ; We just did the last screen.
.b093						_next_screen:
.b093		a5 28		lda $28		                lda tmp2+1
.b095		48		pha		                pha
.b096		a5 27		lda $27		                lda tmp2
.b098		48		pha		                pha
.b099		e6 25		inc $25		                inc tmp1
.b09b		d0 02		bne $b09f	                bne +
.b09d		e6 26		inc $26		                inc tmp1+1
.b09f						+
.b09f		ca		dex		                dex
.b0a0		ca		dex		                dex
.b0a1		a5 25		lda $25		                lda tmp1
.b0a3		95 00		sta $00,x	                sta 0,x
.b0a5		a5 26		lda $26		                lda tmp1+1
.b0a7		95 01		sta $01,x	                sta 1,x
.b0a9		80 c7		bra $b072	                bra _thru_loop
.b0ab						_done:
.b0ab		60		rts		z_thru:         rts
.b0ac						xt_update:
.b0ac		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0ae		b1 08		lda ($08),y	                lda (up),y
.b0b0		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b0b2		91 08		sta ($08),y	                sta (up),y
.b0b4		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b0b5						xt_editor_screen_helper:
.b0b5		20 9f 86	jsr $869f	                jsr xt_dup
.b0b8		20 62 b0	jsr $b062	                jsr xt_scr
.b0bb		20 2c 92	jsr $922c	                jsr xt_store
.b0be		4c af af	jmp $afaf	                jmp xt_buffer
.b0c1						xt_editor_enter_screen:
.b0c1		20 b5 b0	jsr $b0b5	                jsr xt_editor_screen_helper
.b0c4		20 99 86	jsr $8699	                jsr xt_drop
.b0c7		64 35		stz $35		                stz ed_head
.b0c9						_prompt_loop:
.b0c9		ca		dex		                dex
.b0ca		ca		dex		                dex
.b0cb		a5 35		lda $35		                lda ed_head
.b0cd		95 00		sta $00,x	                sta 0,x
.b0cf		74 01		stz $01,x	                stz 1,x
.b0d1		20 94 b1	jsr $b194	                jsr xt_editor_o
.b0d4		e6 35		inc $35		                inc ed_head
.b0d6		a9 10		lda #$10	                lda #16
.b0d8		c5 35		cmp $35		                cmp ed_head
.b0da		d0 ed		bne $b0c9	                bne _prompt_loop
.b0dc						z_editor_enter_screen:
.b0dc		60		rts		                rts
.b0dd						xt_editor_erase_screen:
.b0dd		20 b5 b0	jsr $b0b5	                jsr xt_editor_screen_helper
.b0e0		ca		dex		                dex
.b0e1		ca		dex		                dex
.b0e2		74 00		stz $00,x	                stz 0,x
.b0e4		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b0e6		95 01		sta $01,x	                sta 1,x
.b0e8		20 b1 87	jsr $87b1	                jsr xt_blank
.b0eb		20 ac b0	jsr $b0ac	                jsr xt_update
.b0ee						z_editor_erase_screen:
.b0ee		60		rts		                rts
.b0ef						xt_editor_el:
.b0ef		20 7b b1	jsr $b17b	                jsr xt_editor_line
.b0f2		ca		dex		                dex
.b0f3		ca		dex		                dex
.b0f4		a9 40		lda #$40	                lda #64
.b0f6		95 00		sta $00,x	                sta 0,x
.b0f8		74 01		stz $01,x	                stz 1,x
.b0fa		20 b1 87	jsr $87b1	                jsr xt_blank
.b0fd		20 ac b0	jsr $b0ac	                jsr xt_update
.b100		60		rts		z_editor_el:    rts
.b101						xt_editor_l:
.b101		ca		dex		                dex             ; Put SCR on the stack.
.b102		ca		dex		                dex
.b103		a0 06		ldy #$06	                ldy #scr_offset
.b105		b1 08		lda ($08),y	                lda (up),y
.b107		95 00		sta $00,x	                sta 0,x
.b109		c8		iny		                iny
.b10a		b1 08		lda ($08),y	                lda (up),y
.b10c		95 01		sta $01,x	                sta 1,x
.b10e		20 ae ad	jsr $adae	                jsr xt_block    ; Get the current screen.
.b111		20 3c 84	jsr $843c	                jsr xt_cr
.b114		80 08		bra $b11e	                bra _after_screen_msg
.b116						_screen_msg:
>b116		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b11e						_after_screen_msg:
.b11e		20 89 a1	jsr $a189	                jsr sliteral_runtime
>b121		16 b1 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.b125		20 c9 94	jsr $94c9	                jsr xt_type
.b128		20 62 b0	jsr $b062	                jsr xt_scr
.b12b		20 19 88	jsr $8819	                jsr xt_fetch
.b12e		ca		dex		                dex
.b12f		ca		dex		                dex
.b130		a9 04		lda #$04	                lda #4          ; four spaces
.b132		95 00		sta $00,x	                sta 0,x
.b134		74 01		stz $01,x	                stz 1,x
.b136		20 00 95	jsr $9500	                jsr xt_u_dot_r
.b139		64 29		stz $29		                stz tmp3
.b13b						_line_loop:
.b13b		20 3c 84	jsr $843c	                jsr xt_cr
.b13e		ca		dex		                dex
.b13f		ca		dex		                dex
.b140		ca		dex		                dex
.b141		ca		dex		                dex
.b142		74 03		stz $03,x	                stz 3,x
.b144		a5 29		lda $29		                lda tmp3
.b146		95 02		sta $02,x	                sta 2,x
.b148		74 01		stz $01,x	                stz 1,x
.b14a		a9 02		lda #$02	                lda #2
.b14c		95 00		sta $00,x	                sta 0,x
.b14e		20 00 95	jsr $9500	                jsr xt_u_dot_r
.b151		20 bd 91	jsr $91bd	                jsr xt_space
.b154		20 9f 86	jsr $869f	                jsr xt_dup
.b157		ca		dex		                dex
.b158		ca		dex		                dex
.b159		a9 40		lda #$40	                lda #64
.b15b		95 00		sta $00,x	                sta 0,x
.b15d		74 01		stz $01,x	                stz 1,x
.b15f		20 c9 94	jsr $94c9	                jsr xt_type
.b162		18		clc		                clc
.b163		a9 40		lda #$40	                lda #64
.b165		75 00		adc $00,x	                adc 0,x
.b167		95 00		sta $00,x	                sta 0,x
.b169		90 02		bcc $b16d	                bcc +
.b16b		f6 01		inc $01,x	                inc 1,x
.b16d						+
.b16d		e6 29		inc $29		                inc tmp3
.b16f		a5 29		lda $29		                lda tmp3
.b171		c9 10		cmp #$10	                cmp #16
.b173		d0 c6		bne $b13b	                bne _line_loop
.b175		20 3c 84	jsr $843c	                jsr xt_cr
.b178		e8		inx		                inx
.b179		e8		inx		                inx
.b17a		60		rts		z_editor_l:            rts
.b17b						xt_editor_line:
.b17b		20 9d d7	jsr $d79d	                jsr underflow_1
.b17e		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b180						_shift_tos_left:
.b180		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b182		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b184		88		dey		                dey
.b185		d0 f9		bne $b180	                bne _shift_tos_left
.b187		20 62 b0	jsr $b062	                jsr xt_scr
.b18a		20 19 88	jsr $8819	                jsr xt_fetch
.b18d		20 ae ad	jsr $adae	                jsr xt_block
.b190		20 4b 8e	jsr $8e4b	                jsr xt_plus
.b193		60		rts		z_editor_line:  rts
.b194						xt_editor_o:
.b194		20 3c 84	jsr $843c	                jsr xt_cr
.b197		20 9f 86	jsr $869f	                jsr xt_dup
.b19a		20 cf 9d	jsr $9dcf	                jsr xt_two
.b19d		20 00 95	jsr $9500	                jsr xt_u_dot_r
.b1a0		20 bd 91	jsr $91bd	                jsr xt_space
.b1a3		a9 2a		lda #$2a	                lda #'*'
.b1a5		20 c4 86	jsr $86c4	                jsr emit_a
.b1a8		20 bd 91	jsr $91bd	                jsr xt_space
.b1ab		20 7b b1	jsr $b17b	                jsr xt_editor_line
.b1ae		20 9f 86	jsr $869f	                jsr xt_dup      ; Save a copy of the line address for later.
.b1b1		ca		dex		                dex
.b1b2		ca		dex		                dex
.b1b3		a9 40		lda #$40	                lda #64         ; chars/line
.b1b5		95 00		sta $00,x	                sta 0,x
.b1b7		74 01		stz $01,x	                stz 1,x
.b1b9		20 e6 80	jsr $80e6	                jsr xt_accept
.b1bc		20 9f 86	jsr $869f	                jsr xt_dup
.b1bf		20 88 9c	jsr $9c88	                jsr xt_not_rote ; -rot
.b1c2		20 4b 8e	jsr $8e4b	                jsr xt_plus
.b1c5		ca		dex		                dex
.b1c6		ca		dex		                dex
.b1c7		a9 40		lda #$40	                lda #64         ; chars/line
.b1c9		95 00		sta $00,x	                sta 0,x
.b1cb		74 01		stz $01,x	                stz 1,x
.b1cd		20 83 8f	jsr $8f83	                jsr xt_rot
.b1d0		20 dc 8b	jsr $8bdc	                jsr xt_minus
.b1d3		20 b1 87	jsr $87b1	                jsr xt_blank
.b1d6		20 ac b0	jsr $b0ac	                jsr xt_update
.b1d9		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b1da						xt_also:
.b1da		20 05 b2	jsr $b205	                jsr xt_get_order
.b1dd		20 fd 8c	jsr $8cfd	                jsr xt_over
.b1e0		20 42 92	jsr $9242	                jsr xt_swap
.b1e3		20 e1 8c	jsr $8ce1	                jsr xt_one_plus
.b1e6		20 0e b3	jsr $b30e	                jsr xt_set_order
.b1e9		60		rts		z_also:         rts
.b1ea						xt_definitions:
.b1ea		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b1ec		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b1ee		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b1f0		91 08		sta ($08),y	                sta (up),y
.b1f2		60		rts		z_definitions:  rts
.b1f3						xt_forth:
.b1f3		a0 23		ldy #$23	                ldy #search_order_offset
.b1f5		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b1f7		91 08		sta ($08),y	                sta (up),y
.b1f9						z_forth:
.b1f9		60		rts		                rts
.b1fa						xt_get_current:
.b1fa		ca		dex		                dex
.b1fb		ca		dex		                dex
.b1fc		a0 08		ldy #$08	                ldy #current_offset
.b1fe		b1 08		lda ($08),y	                lda (up),y
.b200		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b202		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b204		60		rts		z_get_current:  rts
.b205						xt_get_order:
.b205		a0 22		ldy #$22	                ldy #num_order_offset
.b207		b1 08		lda ($08),y	                lda (up),y
.b209		85 25		sta $25		                sta tmp1
.b20b		f0 16		beq $b223	                beq _done       ; If zero, there are no wordlists.
.b20d						_loop:
.b20d		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b20f		a9 23		lda #$23	                lda #search_order_offset
.b211		18		clc		                clc
.b212		65 25		adc $25		                adc tmp1
.b214		a8		tay		                tay
.b215		ca		dex		                dex
.b216		ca		dex		                dex
.b217		b1 08		lda ($08),y	                lda (up),y
.b219		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b21b		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b21d		a9 00		lda #$00	                lda #0
.b21f		c5 25		cmp $25		                cmp tmp1
.b221		d0 ea		bne $b20d	                bne _loop
.b223						_done:
.b223		ca		dex		                dex
.b224		ca		dex		                dex
.b225		a0 22		ldy #$22	                ldy #num_order_offset
.b227		b1 08		lda ($08),y	                lda (up),y
.b229		95 00		sta $00,x	                sta 0,x
.b22b		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b22d		60		rts		z_get_order:    rts
.b22e						xt_only:
.b22e		20 94 93	jsr $9394	                jsr xt_true
.b231		20 0e b3	jsr $b30e	                jsr xt_set_order
.b234		60		rts		z_only:         rts
.b235						xt_order:
.b235		20 3c 84	jsr $843c	                jsr xt_cr
.b238		20 05 b2	jsr $b205	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.b23b		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.b23d		f0 1e		beq $b25d	                beq _drop_done
.b23f		a8		tay		                tay
.b240						_loop:
.b240		e8		inx		                inx
.b241		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.b242		b5 00		lda $00,x	                lda 0,x
.b244		5a		phy		                phy
.b245		20 60 b2	jsr $b260	                jsr order_print_wid_string   ; internal helper function
.b248		7a		ply		                ply
.b249		88		dey		                dey
.b24a		d0 f4		bne $b240	                bne _loop
.b24c		20 bd 91	jsr $91bd	                jsr xt_space
.b24f		20 bd 91	jsr $91bd	                jsr xt_space
.b252		20 fa b1	jsr $b1fa	                jsr xt_get_current      ; ( wid )
.b255		b5 00		lda $00,x	                lda 0,x
.b257		20 60 b2	jsr $b260	                jsr order_print_wid_string
.b25a		20 3c 84	jsr $843c	                jsr xt_cr
.b25d						_drop_done:
.b25d		e8		inx		                inx
.b25e		e8		inx		                inx
.b25f						z_order:
.b25f		60		rts		                rts
.b260						order_print_wid_string:
.b260		c9 04		cmp #$04	                cmp #4
.b262		90 09		bcc $b26d	                bcc _output_string      ; less than 4, print a real string
.b264		ca		dex		                dex
.b265		ca		dex		                dex
.b266		95 00		sta $00,x	                sta 0,x
.b268		74 01		stz $01,x	                stz 1,x
.b26a		4c f4 94	jmp $94f4	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.b26d						_output_string:
.b26d		a8		tay		                tay
.b26e		b9 74 b2	lda $b274,y	                lda _wid_data,y
.b271		4c d9 d7	jmp $d7d9	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b274						_wid_data:
>b274		04				        .byte str_wid_forth            ; WID 0: "Forth"
>b275		05				        .byte str_wid_editor           ; WID 1: "Editor"
>b276		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>b277		07				        .byte str_wid_root             ; WID 3: "Root"
.b278						xt_previous:
.b278		20 05 b2	jsr $b205	                jsr xt_get_order
.b27b		20 28 8c	jsr $8c28	                jsr xt_nip
.b27e		20 d5 8c	jsr $8cd5	                jsr xt_one_minus
.b281		20 0e b3	jsr $b30e	                jsr xt_set_order
.b284		60		rts		z_previous:     rts
.b285						xt_root_wordlist:
.b285		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b286		ca		dex		                dex
.b287		a9 03		lda #$03	                lda #3
.b289		95 00		sta $00,x	                sta 0,x
.b28b		74 01		stz $01,x	                stz 1,x
.b28d						z_root_wordlist:
.b28d		60		rts		                rts
.b28e						xt_search_wordlist:
.b28e		20 a7 d7	jsr $d7a7	                jsr underflow_3
.b291		a5 08		lda $08		                lda up
.b293		18		clc		                clc
.b294		69 0a		adc #$0a	                adc #wordlists_offset
.b296		85 27		sta $27		                sta tmp2
.b298		a5 09		lda $09		                lda up+1
.b29a		69 00		adc #$00	                adc #0          ; Adding carry
.b29c		85 28		sta $28		                sta tmp2+1
.b29e		b5 00		lda $00,x	                lda 0,x
.b2a0		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b2a1		65 27		adc $27		                adc tmp2
.b2a3		85 27		sta $27		                sta tmp2
.b2a5		90 02		bcc $b2a9	                bcc +
.b2a7		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b2a9						+
.b2a9		e8		inx		                inx
.b2aa		e8		inx		                inx
.b2ab		b5 00		lda $00,x	                lda 0,x
.b2ad		15 01		ora $01,x	                ora 1,x
.b2af		f0 4e		beq $b2ff	                beq _done
.b2b1		a5 27		lda $27		                lda tmp2
.b2b3		05 28		ora $28		                ora tmp2+1
.b2b5		f0 48		beq $b2ff	                beq _done
.b2b7		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b2b9		85 25		sta $25		                sta tmp1
.b2bb		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b2bd		d0 02		bne $b2c1	                bne +
.b2bf		e6 28		inc $28		                inc tmp2+1
.b2c1						+
.b2c1		b2 27		lda ($27)	                lda (tmp2)
.b2c3		85 26		sta $26		                sta tmp1+1
.b2c5		20 7f d6	jsr $d67f	                jsr find_header_name
.b2c8		f0 31		beq $b2fb	                beq _fail_done
.b2ca		e8		inx		                inx
.b2cb		e8		inx		                inx
.b2cc		a5 25		lda $25		                lda tmp1
.b2ce		95 00		sta $00,x	                sta 0,x
.b2d0		a5 26		lda $26		                lda tmp1+1
.b2d2		95 01		sta $01,x	                sta 1,x
.b2d4		20 9f 86	jsr $869f	                jsr xt_dup              ; ( nt nt )
.b2d7		20 41 9c	jsr $9c41	                jsr xt_name_to_int      ; ( nt xt )
.b2da		20 42 92	jsr $9242	                jsr xt_swap             ; ( xt nt )
.b2dd		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b2df		f6 00		inc $00,x	                inc 0,x
.b2e1		d0 02		bne $b2e5	                bne +
.b2e3		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b2e5						+
.b2e5		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b2e7		29 04		and #$04	                and #IM
.b2e9		d0 08		bne $b2f3	                bne _immediate          ; bit set, we're immediate
.b2eb		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b2ed		95 00		sta $00,x	                sta 0,x
.b2ef		95 01		sta $01,x	                sta 1,x
.b2f1		80 0e		bra $b301	                bra _done_nodrop
.b2f3						_immediate:
.b2f3		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b2f5		95 00		sta $00,x	                sta 0,x
.b2f7		74 01		stz $01,x	                stz 1,x
.b2f9		80 06		bra $b301	                bra _done_nodrop
.b2fb						_fail_done:
.b2fb		74 02		stz $02,x	                stz 2,x         ; failure flag
.b2fd		74 03		stz $03,x	                stz 3,x
.b2ff						_done:
.b2ff		e8		inx		                inx
.b300		e8		inx		                inx
.b301						_done_nodrop:
.b301						z_search_wordlist:
.b301		60		rts		                rts
.b302						xt_set_current:
.b302		20 9d d7	jsr $d79d	                jsr underflow_1
.b305		a0 08		ldy #$08	                ldy #current_offset
.b307		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b309		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b30b		e8		inx		                inx
.b30c		e8		inx		                inx
.b30d		60		rts		z_set_current:  rts
.b30e						xt_set_order:
.b30e		a9 ff		lda #$ff	                lda #$FF
.b310		d5 01		cmp $01,x	                cmp 1,x
.b312		d0 12		bne $b326	                bne _start
.b314		d5 00		cmp $00,x	                cmp 0,x
.b316		d0 0e		bne $b326	                bne _start
.b318		ca		dex		                dex             ; Make room for the count.
.b319		ca		dex		                dex
.b31a		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b31c		a9 03		lda #$03	                lda #3
.b31e		95 02		sta $02,x	                sta 2,x
.b320		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b322		a9 01		lda #$01	                lda #1
.b324		95 00		sta $00,x	                sta 0,x
.b326						_start:
.b326		a0 22		ldy #$22	                ldy #num_order_offset
.b328		b5 00		lda $00,x	                lda 0,x
.b32a		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b32c		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b32e		e8		inx		                inx             ; Drop the count off the data stack.
.b32f		e8		inx		                inx
.b330		a5 25		lda $25		                lda tmp1
.b332		f0 0d		beq $b341	                beq _done       ; If zero, there are no wordlists.
.b334		a0 23		ldy #$23	                ldy #search_order_offset
.b336						_loop:
.b336		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b338		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b33a		c8		iny		                iny
.b33b		e8		inx		                inx
.b33c		e8		inx		                inx
.b33d		c6 25		dec $25		                dec tmp1
.b33f		d0 f5		bne $b336	                bne _loop
.b341						_done:
.b341		60		rts		z_set_order:    rts
.b342						xt_to_order:
.b342		20 80 93	jsr $9380	                jsr xt_to_r
.b345		20 05 b2	jsr $b205	                jsr xt_get_order
.b348		20 e6 8e	jsr $8ee6	                jsr xt_r_from
.b34b		20 42 92	jsr $9242	                jsr xt_swap
.b34e		20 e1 8c	jsr $8ce1	                jsr xt_one_plus
.b351		20 0e b3	jsr $b30e	                jsr xt_set_order
.b354		60		rts		z_to_order:     rts
.b355						xt_wordlist:
.b355		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b357		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b359		c9 0c		cmp #$0c	                cmp #max_wordlists
.b35b		d0 05		bne $b362	                bne _ok
.b35d		a9 0b		lda #$0b	                lda #err_wordlist
.b35f		4c b3 d7	jmp $d7b3	                jmp error
.b362						_ok:
.b362		1a		inc a		                ina             ; Increment the wordlist#
.b363		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b365		ca		dex		                dex             ; and put it on the stack.
.b366		ca		dex		                dex
.b367		95 00		sta $00,x	                sta 0,x
.b369		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b36b		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b36c						cold_zp_table:
>b36c	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b36e	0002	4f bb				dp:         .word dictionary_start  ; Dictionary Pointer
>b370	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b372	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b374	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b376	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b378	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b37a	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b37c	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b37e	0012	2d f0				output:     .word kernel_putc       ; vector for EMIT
>b380	0014	27 f0				input:      .word kernel_getc       ; vector for KEY
>b382	0016	00 00				havekey:    .word 0                 ; vector for KEY?  (unused see https://github.com/SamCoVT/TaliForth2/issues/62)
>b384	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b386	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b388	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>b38a	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b38b	001f					loopctrl:   .byte ?         ; Offset and flags for DO/LOOP/+LOOP control.
>b38c	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$100						lcbstack = $100
=256						loopindex = lcbstack+0      ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack+2      ; loop control block offset for limit fudge factor
>b38d	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b38f	0023					tmptos:     .word ?         ; temporary TOS storage
>b391	0025					tmp1:       .word ?         ; temporary storage
>b393	0027					tmp2:       .word ?         ; temporary storage
>b395	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b397	002b					tohold:     .word ?         ; pointer for formatted output
>b399	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b3a1	0035					tmped:      .word ?,?,?     ; temporary for editors
.b38a						cold_zp_table_end:
.b38a						cold_user_table:
>b38a	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b38c	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b38e	0004	00 00				blk_offset:             .word 0         ; BLK
>b390	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
>b392	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b393	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b394	000a					wordlists_offset:
>b394	000a	4f bb				    .word dictionary_start              ; FORTH-WORDLIST
>b396	000c	ae c9				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b398	000e	fe c9				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b39a	0010	6d c9				    .word root_dictionary_start         ; ROOT-WORDLIST
>b39c	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b3a4	001a	00 00 00 00 00 00 00 00
>b3ac	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b3ad	0023					search_order_offset:
>b3ad	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b3b5	002b	00
>b3b6	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b3b8	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b3ba	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b3bc	0032	92 af				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b3be	0034	92 af				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b3c0						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$d0						OpBNE   = $D0
=$f0						OpBEQ   = $F0
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b3c0						oc_index_table:
>b3c0		c0 b5 c4 b5 6b ba 6b ba		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc07
>b3c8		cc b5 d2 b5 d8 b5 de b5
>b3d0		e5 b5 e9 b5 ef b5 6b ba		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b3d8		f5 b5 f9 b5 fd b5 01 b6
>b3e0		06 b6 0a b6 12 b6 6b ba		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b3e8		19 b6 1f b6 26 b6 2d b6
>b3f0		34 b6 38 b6 3e b6 6b ba		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc1E, oc1F
>b3f8		44 b6 48 b6 4e b6 54 b6
>b400		59 b6 5d b6 6b ba 6b ba		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b408		65 b6 6b b6 71 b6 77 b6
>b410		7e b6 82 b6 88 b6 6b ba		        .word oc28, oc29, oc2A, oc__, OC2C, oc2D, oc2E, oc2F
>b418		8e b6 92 b6 97 b6 9b b6
>b420		a0 b6 a4 b6 ac b6 6b ba		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b428		b3 b6 bb b6 c2 b6 c9 b6
>b430		d0 b6 d4 b6 da b6 6b ba		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc3F
>b438		e0 b6 e6 b6 ec b6 f2 b6
>b440		f7 b6 fb b6 6b ba 6b ba		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b448		6b ba 03 b7 09 b7 0f b7
>b450		16 b7 1a b7 20 b7 6b ba		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b458		26 b7 2a b7 2e b7 32 b7
>b460		37 b7 3b b7 43 b7 6b ba		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b468		6b ba 4a b7 51 b7 58 b7
>b470		5f b7 63 b7 69 b7 6b ba		        .word oc58, oc59, oc5A, oc__, oc__, oc5D, oc5E, oc5F
>b478		6b ba 6d b7 73 b7 79 b7
>b480		7e b7 82 b7 6b ba 6b ba		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b488		8a b7 90 b7 96 b7 9c b7
>b490		a3 b7 a7 b7 ad b7 6b ba		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b498		b3 b7 b9 b7 bd b7 c1 b7
>b4a0		c6 b7 ca b7 d2 b7 6b ba		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b4a8		d9 b7 e0 b7 e7 b7 ee b7
>b4b0		f5 b7 f9 b7 ff b7 6b ba		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b4b8		03 b8 0a b8 10 b8 16 b8
>b4c0		1b b8 1f b8 6b ba 6b ba		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc87
>b4c8		27 b8 2d b8 33 b8 39 b8
>b4d0		40 b8 44 b8 4a b8 6b ba		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b4d8		4e b8 52 b8 56 b8 5a b8
>b4e0		5f b8 63 b8 6b b8 6b ba		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b4e8		72 b8 79 b8 80 b8 87 b8
>b4f0		8e b8 92 b8 98 b8 6b ba		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b4f8		9c b8 a0 b8 a6 b8 ac b8
>b500		b1 b8 b7 b8 bf b8 6b ba		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b508		c5 b8 cb b8 d1 b8 d7 b8
>b510		de b8 e2 b8 e8 b8 6b ba		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b518		ec b8 f0 b8 f4 b8 f8 b8
>b520		fd b8 01 b9 09 b9 6b ba		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b528		10 b9 17 b9 1e b9 25 b9
>b530		2c b9 30 b9 36 b9 6b ba		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b538		3a b9 40 b9 46 b9 4c b9
>b540		51 b9 57 b9 6b ba 6b ba		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b548		5f b9 65 b9 6b b9 71 b9
>b550		78 b9 7c b9 82 b9 6b ba		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b558		86 b9 8a b9 8e b9 92 b9
>b560		97 b9 9b b9 a3 b9 6b ba		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b568		6b ba aa b9 b1 b9 b8 b9
>b570		bf b9 c3 b9 c9 b9 6b ba		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b578		6b ba cd b9 d3 b9 d9 b9
>b580		de b9 e4 b9 6b ba 6b ba		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b588		ec b9 f2 b9 f8 b9 fe b9
>b590		05 ba 09 ba 0f ba 6b ba		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b598		13 ba 17 ba 1b ba 1f ba
>b5a0		24 ba 28 ba 30 ba 6b ba		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b5a8		6b ba 37 ba 3e ba 45 ba
>b5b0		4c ba 50 ba 56 ba 6b ba		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b5b8		6b ba 5a ba 60 ba 66 ba
>b5c0		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b5c4		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b5cc		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b5d2		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b5d8		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b5de		86 72 6d 62 30 2e 7a			oc07:	.text 2*64+6, "rmb0.z"
>b5e5		43 70 68 70				oc08:	.text 1*64+3, "php"
>b5e9		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b5ef		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b5f5		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b5f9		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b5fd		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b601		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b606		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b60a		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b612		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b619		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b61f		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b626		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b62d		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b634		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b638		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b63e		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b644		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b648		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b64e		c5 61 73 6c 2e 78			oc1E:	.text 3*64+5, "asl.x"
>b654		c4 62 62 72 31				oc1F:	.text 3*64+4, "bbr1"
>b659		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b65d		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b665		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b66b		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b671		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b677		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b67e		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b682		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b688		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b68e		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b692		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b697		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b69b		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b6a0		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b6a4		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b6ac		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b6b3		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b6bb		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b6c2		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b6c9		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b6d0		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b6d4		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b6da		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b6e0		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b6e6		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b6ec		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b6f2		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b6f7		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b6fb		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b703		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b709		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b70f		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b716		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b71a		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b720		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b726		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b72a		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b72e		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b732		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b737		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b73b		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b743		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b74a		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b751		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b758		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b75f		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b763		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b769		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b76d		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b773		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b779		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b77e		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b782		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b78a		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b790		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b796		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b79c		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b7a3		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b7a7		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b7ad		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b7b3		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b7b9		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b7bd		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b7c1		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b7c6		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b7ca		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b7d2		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b7d9		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b7e0		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b7e7		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b7ee		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b7f5		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b7f9		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b7ff		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b803		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b80a		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b810		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b816		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b81b		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b81f		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b827		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b82d		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b833		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b839		86 73 6d 62 30 2e 7a			oc87:	.text 2*64+6, "smb0.z"
>b840		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b844		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b84a		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b84e		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b852		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b856		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b85a		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b85f		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b863		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b86b		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b872		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b879		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b880		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b887		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b88e		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b892		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b898		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b89c		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b8a0		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b8a6		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b8ac		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b8b1		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b8b7		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b8bf		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b8c5		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b8cb		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b8d1		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b8d7		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b8de		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b8e2		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b8e8		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b8ec		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b8f0		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b8f4		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b8f8		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b8fd		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b901		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b909		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b910		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b917		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b91e		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b925		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b92c		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b930		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b936		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b93a		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b940		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b946		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b94c		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b951		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b957		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b95f		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b965		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b96b		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b971		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b978		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b97c		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b982		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>b986		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>b98a		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>b98e		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>b992		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>b997		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>b99b		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>b9a3		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>b9aa		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>b9b1		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>b9b8		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>b9bf		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>b9c3		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>b9c9		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>b9cd		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>b9d3		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>b9d9		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>b9de		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>b9e4		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>b9ec		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>b9f2		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>b9f8		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>b9fe		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>ba05		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>ba09		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>ba0f		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>ba13		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>ba17		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>ba1b		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>ba1f		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>ba24		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>ba28		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>ba30		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>ba37		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>ba3e		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>ba45		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>ba4c		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>ba50		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>ba56		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>ba5a		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>ba60		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>ba66		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>ba6b		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.ba6d						forth_words_start:
>ba6d		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>ba75		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>ba85		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>ba95		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>baa5		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>bab5		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bac5		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>bad5		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bae5		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>baf5		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bb05		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bb15		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bb25		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bb35		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bb45		78 69 74 29 20 63 72 20
.bb4d						forth_words_end:
.bb4d						user_words_start:
>bb4d		20 20				.binary "user_words.asc"
.bb4f						user_words_end:

;******  Processing file: platform/../headers.asm

.bb4f						dictionary_start:
.bb4f						nt_drop:
>bb4f		04 10				        .byte 4, UF
>bb51		5b bb 99 86 9e 86		        .word nt_dup, xt_drop, z_drop
>bb57		64 72 6f 70			        .text "drop"
.bb5b						nt_dup:
>bb5b		03 10				        .byte 3, UF
>bb5d		66 bb 9f 86 ac 86		        .word nt_swap, xt_dup, z_dup
>bb63		64 75 70			        .text "dup"
.bb66						nt_swap:
>bb66		04 10				        .byte 4, UF
>bb68		72 bb 42 92 55 92		        .word nt_store, xt_swap, z_swap
>bb6e		73 77 61 70			        .text "swap"
.bb72						nt_store:
>bb72		01 10				        .byte 1, UF
>bb74		7b bb 2c 92 41 92		        .word nt_fetch, xt_store, z_store
>bb7a		21				        .text "!"
.bb7b						nt_fetch:
>bb7b		01 10				        .byte 1, UF
>bb7d		84 bb 19 88 2b 88		        .word nt_over, xt_fetch, z_fetch
>bb83		40				        .text "@"
.bb84						nt_over:
>bb84		04 10				        .byte 4, UF
>bb86		90 bb fd 8c 0a 8d		        .word nt_to_r, xt_over, z_over
>bb8c		6f 76 65 72			        .text "over"
.bb90						nt_to_r:
>bb90		02 11				        .byte 2, CO+UF ; native is special case
>bb92		9a bb 80 93 93 93		        .word nt_r_from, xt_to_r, z_to_r
>bb98		3e 72				        .text ">r"
.bb9a						nt_r_from:
>bb9a		02 01				        .byte 2, CO    ; native is special case
>bb9c		a4 bb e6 8e f6 8e		        .word nt_r_fetch, xt_r_from, z_r_from
>bba2		72 3e				        .text "r>"
.bba4						nt_r_fetch:
>bba4		02 01				        .byte 2, CO    ; native is special case
>bba6		ae bb d1 8e e5 8e		        .word nt_nip, xt_r_fetch, z_r_fetch
>bbac		72 40				        .text "r@"
.bbae						nt_nip:
>bbae		03 10				        .byte 3, UF
>bbb0		b9 bb 28 8c 35 8c		        .word nt_rot, xt_nip, z_nip
>bbb6		6e 69 70			        .text "nip"
.bbb9						nt_rot:
>bbb9		03 10				        .byte 3, UF
>bbbb		c4 bb 83 8f 9e 8f		        .word nt_not_rote, xt_rot, z_rot
>bbc1		72 6f 74			        .text "rot"
.bbc4						nt_not_rote:
>bbc4		04 10				        .byte 4, UF
>bbc6		d0 bb 88 9c a3 9c		        .word nt_tuck, xt_not_rote, z_not_rote
>bbcc		2d 72 6f 74			        .text "-rot"
.bbd0						nt_tuck:
>bbd0		04 10				        .byte 4, UF
>bbd2		dc bb 9d 93 b6 93		        .word nt_comma, xt_tuck, z_tuck
>bbd8		74 75 63 6b			        .text "tuck"
.bbdc						nt_comma:
>bbdc		01 10				        .byte 1, UF
>bbde		e5 bb cf 83 dd 83		        .word nt_c_fetch, xt_comma, z_comma
>bbe4		2c				        .text ","
.bbe5						nt_c_fetch:
>bbe5		02 10				        .byte 2, UF
>bbe7		ef bb 2f 83 38 83		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bbed		63 40				        .text "c@"
.bbef						nt_c_store:
>bbef		02 10				        .byte 2, UF
>bbf1		f9 bb 39 83 44 83		        .word nt_plus_store, xt_c_store, z_c_store
>bbf7		63 21				        .text "c!"
.bbf9						nt_plus_store:
>bbf9		02 10				        .byte 2, UF
>bbfb		03 bc 5e 8e 7d 8e		        .word nt_zero, xt_plus_store, z_plus_store
>bc01		2b 21				        .text "+!"
.bc03						nt_zero:
>bc03		01 00				        .byte 1, 0
>bc05		0c bc 04 9e 0a 9e		        .word nt_one, xt_zero, z_zero
>bc0b		30				        .text "0"
.bc0c						nt_one:
>bc0c		01 00				        .byte 1, 0
>bc0e		15 bc 9e 9d a6 9d		        .word nt_two, xt_one, z_one
>bc14		31				        .text "1"
.bc15						nt_two:
>bc15		01 00				        .byte 1, 0
>bc17		1e bc cf 9d d7 9d		        .word nt_execute, xt_two, z_two
>bc1d		32				        .text "2"
.bc1e						nt_execute:
>bc1e		07 10				        .byte 7, UF
>bc20		2d bc 04 88 0a 88		        .word nt_emit, xt_execute, z_execute
>bc26		65 78 65 63 75 74 65		        .text "execute"
.bc2d						nt_emit:
>bc2d		04 18				        .byte 4, NN+UF
>bc2f		39 bc bd 86 c7 86		        .word nt_type, xt_emit, z_emit
>bc35		65 6d 69 74			        .text "emit"
.bc39						nt_type:
>bc39		04 10				        .byte 4, UF
>bc3b		45 bc c9 94 f3 94		        .word nt_dot, xt_type, z_type
>bc41		74 79 70 65			        .text "type"
.bc45						nt_dot:
>bc45		01 10				        .byte 1, UF
>bc47		4e bc 2f 86 50 86		        .word nt_u_dot, xt_dot, z_dot
>bc4d		2e				        .text "."
.bc4e						nt_u_dot:
>bc4e		02 10				        .byte 2, UF
>bc50		58 bc f4 94 ff 94		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bc56		75 2e				        .text "u."
.bc58						nt_u_dot_r:
>bc58		03 10				        .byte 3, UF
>bc5a		63 bc 00 95 21 95		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bc60		75 2e 72			        .text "u.r"
.bc63						nt_dot_r:
>bc63		02 10				        .byte 2, UF
>bc65		6d bc 6b 86 98 86		        .word nt_d_dot, xt_dot_r, z_dot_r
>bc6b		2e 72				        .text ".r"
.bc6d						nt_d_dot:
>bc6d		02 10				        .byte 2, UF
>bc6f		77 bc 8d 9e ab 9e		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bc75		64 2e				        .text "d."
.bc77						nt_d_dot_r:
>bc77		03 10				        .byte 3, UF
>bc79		82 bc ac 9e d6 9e		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bc7f		64 2e 72			        .text "d.r"
.bc82						nt_ud_dot:
>bc82		03 10				        .byte 3, UF
>bc84		8d bc 23 9f 35 9f		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bc8a		75 64 2e			        .text "ud."
.bc8d						nt_ud_dot_r:
>bc8d		04 10				        .byte 4, UF
>bc8f		99 bc 36 9f 54 9f		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bc95		75 64 2e 72			        .text "ud.r"
.bc99						nt_question:
>bc99		01 00				        .byte 1, 0
>bc9b		a2 bc 2f 99 35 99		        .word nt_false, xt_question, z_question
>bca1		3f				        .text "?"
.bca2						nt_false:
>bca2		05 00				        .byte 5, 0
>bca4		af bc 04 9e 0a 9e		        .word nt_true, xt_false, z_false
>bcaa		66 61 6c 73 65			        .text "false"
.bcaf						nt_true:
>bcaf		04 00				        .byte 4, 0
>bcb1		bb bc 94 93 9c 93		        .word nt_space, xt_true, z_true
>bcb7		74 72 75 65			        .text "true"
.bcbb						nt_space:
>bcbb		05 00				        .byte 5, 0
>bcbd		c8 bc bd 91 c2 91		        .word nt_two_dup, xt_space, z_space
>bcc3		73 70 61 63 65			        .text "space"
.bcc8						nt_two_dup:
>bcc8		04 10				        .byte 4, UF
>bcca		d4 bc bf 93 d6 93		        .word nt_question_dup, xt_two_dup, z_two_dup
>bcd0		32 64 75 70			        .text "2dup"
.bcd4						nt_question_dup:
>bcd4		04 10				        .byte 4, UF
>bcd6		e0 bc bd 8e d0 8e		        .word nt_plus, xt_question_dup, z_question_dup
>bcdc		3f 64 75 70			        .text "?dup"
.bce0						nt_plus:
>bce0		01 10				        .byte 1, UF
>bce2		e9 bc 4b 8e 5d 8e		        .word nt_minus, xt_plus, z_plus
>bce8		2b				        .text "+"
.bce9						nt_minus:
>bce9		01 10				        .byte 1, UF
>bceb		f2 bc dc 8b ee 8b		        .word nt_one_minus, xt_minus, z_minus
>bcf1		2d				        .text "-"
.bcf2						nt_one_minus:
>bcf2		02 10				        .byte 2, UF
>bcf4		fc bc d5 8c e0 8c		        .word nt_one_plus, xt_one_minus, z_one_minus
>bcfa		31 2d				        .text "1-"
.bcfc						nt_one_plus:
>bcfc		02 10				        .byte 2, UF
>bcfe		06 bd e1 8c ea 8c		        .word nt_two_star, xt_one_plus, z_one_plus
>bd04		31 2b				        .text "1+"
.bd06						nt_two_star:
>bd06		02 10				        .byte 2, UF
>bd08		10 bd 57 94 5e 94		        .word nt_two_slash, xt_two_star, z_two_star
>bd0e		32 2a				        .text "2*"
.bd10						nt_two_slash:
>bd10		02 10				        .byte 2, UF
>bd12		1a bd 4c 94 56 94		        .word nt_abs, xt_two_slash, z_two_slash
>bd18		32 2f				        .text "2/"
.bd1a						nt_abs:
>bd1a		03 10				        .byte 3, UF
>bd1c		25 bd d1 80 e5 80		        .word nt_dabs, xt_abs, z_abs
>bd22		61 62 73			        .text "abs"
.bd25						nt_dabs:
>bd25		04 10				        .byte 4, UF
>bd27		31 bd 53 9e 71 9e		        .word nt_and, xt_dabs, z_dabs
>bd2d		64 61 62 73			        .text "dabs"
.bd31						nt_and:
>bd31		03 10				        .byte 3, UF
>bd33		3c bd 92 82 a3 82		        .word nt_or, xt_and, z_and
>bd39		61 6e 64			        .text "and"
.bd3c						nt_or:
>bd3c		02 10				        .byte 2, UF
>bd3e		46 bd eb 8c fc 8c		        .word nt_xor, xt_or, z_or
>bd44		6f 72				        .text "or"
.bd46						nt_xor:
>bd46		03 10				        .byte 3, UF
>bd48		51 bd 74 96 85 96		        .word nt_rshift, xt_xor, z_xor
>bd4e		78 6f 72			        .text "xor"
.bd51						nt_rshift:
>bd51		06 10				        .byte 6, UF
>bd53		5f bd 9f 8f b2 8f		        .word nt_lshift, xt_rshift, z_rshift
>bd59		72 73 68 69 66 74		        .text "rshift"
.bd5f						nt_lshift:
>bd5f		06 10				        .byte 6, UF
>bd61		6d bd 06 8b 19 8b		        .word nt_pick, xt_lshift, z_lshift
>bd67		6c 73 68 69 66 74		        .text "lshift"
.bd6d						nt_pick:
>bd6d		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bd6f		79 bd 3a 8e 4a 8e		        .word nt_char, xt_pick, z_pick
>bd75		70 69 63 6b			        .text "pick"
.bd79						nt_char:
>bd79		04 00				        .byte 4, 0
>bd7b		85 bd 55 83 6b 83		        .word nt_bracket_char, xt_char, z_char
>bd81		63 68 61 72			        .text "char"
.bd85						nt_bracket_char:
>bd85		06 05				        .byte 6, CO+IM
>bd87		93 bd 0f 83 15 83		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bd8d		5b 63 68 61 72 5d		        .text "[char]"
.bd93						nt_char_plus:
>bd93		05 00				        .byte 5, 0
>bd95		a0 bd e1 8c ea 8c		        .word nt_chars, xt_char_plus, z_char_plus ; same as 1+
>bd9b		63 68 61 72 2b			        .text "char+"
.bda0						nt_chars:
>bda0		05 10				        .byte 5, UF     ; deleted during compile
>bda2		ad bd 6c 83 6f 83		        .word nt_cells, xt_chars, z_chars
>bda8		63 68 61 72 73			        .text "chars"
.bdad						nt_cells:
>bdad		05 00				        .byte 5, 0
>bdaf		ba bd 57 94 5e 94		        .word nt_cell_plus, xt_cells, z_cells  ; same as 2*
>bdb5		63 65 6c 6c 73			        .text "cells"
.bdba						nt_cell_plus:
>bdba		05 10				        .byte 5, UF
>bdbc		c7 bd 45 83 54 83		        .word nt_here, xt_cell_plus, z_cell_plus
>bdc2		63 65 6c 6c 2b			        .text "cell+"
.bdc7						nt_here:
>bdc7		04 00				        .byte 4, 0
>bdc9		d3 bd 1a 89 24 89		        .word nt_equal, xt_here, z_here
>bdcf		68 65 72 65			        .text "here"
.bdd3						nt_equal:
>bdd3		01 10				        .byte 1, UF
>bdd5		dc bd 95 87 b0 87		        .word nt_not_equals, xt_equal, z_equal
>bddb		3d				        .text "="
.bddc						nt_not_equals:
>bddc		02 10				        .byte 2, UF
>bdde		e6 bd 36 8c 53 8c		        .word nt_less_than, xt_not_equals, z_not_equals
>bde4		3c 3e				        .text "<>"
.bde6						nt_less_than:
>bde6		01 10				        .byte 1, UF
>bde8		ef bd dc 89 f0 89		        .word nt_u_less_than, xt_less_than, z_less_than
>bdee		3c				        .text "<"
.bdef						nt_u_less_than:
>bdef		02 10				        .byte 2, UF
>bdf1		f9 bd 38 95 4d 95		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bdf7		75 3c				        .text "u<"
.bdf9						nt_u_greater_than:
>bdf9		02 10				        .byte 2, UF
>bdfb		03 be 22 95 37 95		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>be01		75 3e				        .text "u>"
.be03						nt_greater_than:
>be03		01 10				        .byte 1, UF
>be05		0c be 05 89 19 89		        .word nt_zero_equal, xt_greater_than, z_greater_than
>be0b		3e				        .text ">"
.be0c						nt_zero_equal:
>be0c		02 10				        .byte 2, UF
>be0e		16 be 86 96 97 96		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>be14		30 3d				        .text "0="
.be16						nt_zero_unequal:
>be16		03 10				        .byte 3, UF
>be18		21 be bc 96 cb 96		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>be1e		30 3c 3e			        .text "0<>"
.be21						nt_zero_greater:
>be21		02 10				        .byte 2, UF
>be23		2b be 98 96 ab 96		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>be29		30 3e				        .text "0>"
.be2b						nt_zero_less:
>be2b		02 10				        .byte 2, UF
>be2d		35 be ac 96 bb 96		        .word nt_min, xt_zero_less, z_zero_less
>be33		30 3c				        .text "0<"
.be35						nt_min:
>be35		03 10				        .byte 3, UF
>be37		40 be c0 8b db 8b		        .word nt_max, xt_min, z_min
>be3d		6d 69 6e			        .text "min"
.be40						nt_max:
>be40		03 10				        .byte 3, UF
>be42		4b be a4 8b bf 8b		        .word nt_two_drop, xt_max, z_max
>be48		6d 61 78			        .text "max"
.be4b						nt_two_drop:
>be4b		05 10				        .byte 5, UF
>be4d		58 be b7 93 be 93		        .word nt_two_swap, xt_two_drop, z_two_drop
>be53		32 64 72 6f 70			        .text "2drop"
.be58						nt_two_swap:
>be58		05 10				        .byte 5, UF
>be5a		65 be 85 94 a8 94		        .word nt_two_over, xt_two_swap, z_two_swap
>be60		32 73 77 61 70			        .text "2swap"
.be65						nt_two_over:
>be65		05 10				        .byte 5, UF
>be67		72 be f9 93 10 94		        .word nt_two_store, xt_two_over, z_two_over
>be6d		32 6f 76 65 72			        .text "2over"
.be72						nt_two_store:
>be72		02 10				        .byte 2, UF
>be74		7c be 5f 94 84 94		        .word nt_two_fetch, xt_two_store, z_two_store
>be7a		32 21				        .text "2!"
.be7c						nt_two_fetch:
>be7c		02 10				        .byte 2, UF
>be7e		86 be d7 93 f8 93		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>be84		32 40				        .text "2@"
.be86						nt_two_variable:
>be86		09 00				        .byte 9, 0
>be88		97 be 14 9f 22 9f		        .word nt_two_constant, xt_two_variable, z_two_variable
>be8e		32 76 61 72 69 61 62 6c		        .text "2variable"
>be96		65
.be97						nt_two_constant:
>be97		09 10				        .byte 9, UF
>be99		a8 be d7 9e fb 9e		        .word nt_two_literal, xt_two_constant, z_two_constant
>be9f		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bea7		74
.bea8						nt_two_literal:
>bea8		08 14				        .byte 8, UF+IM
>beaa		b8 be fc 9e 13 9f		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>beb0		32 6c 69 74 65 72 61 6c		        .text "2literal"
.beb8						nt_two_r_fetch:
>beb8		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>beba		c3 be 11 94 2e 94		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bec0		32 72 40			        .text "2r@"
.bec3						nt_two_r_from:
>bec3		03 01				        .byte 3, CO             ; native is special case
>bec5		ce be 2f 94 4b 94		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>becb		32 72 3e			        .text "2r>"
.bece						nt_two_to_r:
>bece		03 11				        .byte 3, CO+UF          ; native is special case
>bed0		d9 be a9 94 c8 94		        .word nt_invert, xt_two_to_r, z_two_to_r
>bed6		32 3e 72			        .text "2>r"
.bed9						nt_invert:
>bed9		06 10				        .byte 6, UF
>bedb		e7 be 63 89 72 89		        .word nt_negate, xt_invert, z_invert
>bee1		69 6e 76 65 72 74		        .text "invert"
.bee7						nt_negate:
>bee7		06 10				        .byte 6, UF
>bee9		f5 be 17 8c 27 8c		        .word nt_dnegate, xt_negate, z_negate
>beef		6e 65 67 61 74 65		        .text "negate"
.bef5						nt_dnegate:
>bef5		07 10				        .byte 7, UF
>bef7		04 bf 72 9e 8c 9e		        .word nt_c_comma, xt_dnegate, z_dnegate
>befd		64 6e 65 67 61 74 65		        .text "dnegate"
.bf04						nt_c_comma:
>bf04		02 10				        .byte 2, UF
>bf06		0e bf 24 83 2e 83		        .word nt_bounds, xt_c_comma, z_c_comma
>bf0c		63 2c				        .text "c,"
.bf0e						nt_bounds:
>bf0e		06 10				        .byte 6, UF
>bf10		1c bf 41 9a 59 9a		        .word nt_spaces, xt_bounds, z_bounds
>bf16		62 6f 75 6e 64 73		        .text "bounds"
.bf1c						nt_spaces:
>bf1c		06 10				        .byte 6, UF
>bf1e		2a bf c3 91 fe 91		        .word nt_bl, xt_spaces, z_spaces
>bf24		73 70 61 63 65 73		        .text "spaces"
.bf2a						nt_bl:
>bf2a		02 00				        .byte 2, 0
>bf2c		34 bf 06 83 0e 83		        .word nt_minus_trailing, xt_bl, z_bl
>bf32		62 6c				        .text "bl"
.bf34						nt_minus_trailing:
>bf34		09 10				        .byte 9, UF
>bf36		45 bf 49 a0 85 a0		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>bf3c		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>bf44		67
.bf45						nt_minus_leading:
>bf45		08 10				        .byte 8, UF
>bf47		55 bf 30 a0 48 a0		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>bf4d		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.bf55						nt_slash_string:
>bf55		07 10				        .byte 7, UF
>bf57		64 bf 25 a1 44 a1		        .word nt_refill, xt_slash_string, z_slash_string
>bf5d		2f 73 74 72 69 6e 67		        .text "/string"
.bf64						nt_refill:
>bf64		06 00				        .byte 6, 0
>bf66		72 bf 34 8f 75 8f		        .word nt_accept, xt_refill, z_refill
>bf6c		72 65 66 69 6c 6c		        .text "refill"
.bf72						nt_accept:
>bf72		06 18				        .byte 6, UF+NN
>bf74		80 bf e6 80 de 81		        .word nt_input_to_r, xt_accept, z_accept
>bf7a		61 63 63 65 70 74		        .text "accept"
.bf80						nt_input_to_r:
>bf80		07 08				        .byte 7, NN
>bf82		8f bf a5 9b ba 9b		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>bf88		69 6e 70 75 74 3e 72		        .text "input>r"
.bf8f						nt_r_to_input:
>bf8f		07 08				        .byte 7, NN
>bf91		9e bf b2 9d c9 9d		        .word nt_unused, xt_r_to_input, z_r_to_input
>bf97		72 3e 69 6e 70 75 74		        .text "r>input"
.bf9e						nt_unused:
>bf9e		06 00				        .byte 6, 0
>bfa0		ac bf ea 95 f9 95		        .word nt_depth, xt_unused, z_unused
>bfa6		75 6e 75 73 65 64		        .text "unused"
.bfac						nt_depth:
>bfac		05 00				        .byte 5, 0
>bfae		b9 bf 54 85 62 85		        .word nt_key, xt_depth, z_depth
>bfb4		64 65 70 74 68			        .text "depth"
.bfb9						nt_key:
>bfb9		03 00				        .byte 3, 0
>bfbb		c4 bf a6 89 af 89		        .word nt_allot, xt_key, z_key
>bfc1		6b 65 79			        .text "key"
.bfc4						nt_allot:
>bfc4		05 10				        .byte 5, UF
>bfc6		d1 bf 29 82 91 82		        .word nt_create, xt_allot, z_allot
>bfcc		61 6c 6c 6f 74			        .text "allot"
.bfd1						nt_create:
>bfd1		06 00				        .byte 6, 0
>bfd3		df bf 42 84 0b 85		        .word nt_does, xt_create, z_create
>bfd9		63 72 65 61 74 65		        .text "create"
.bfdf						nt_does:
>bfdf		05 05				        .byte 5, CO+IM
>bfe1		ec bf ee 85 fc 85		        .word nt_variable, xt_does, z_does
>bfe7		64 6f 65 73 3e			        .text "does>"
.bfec						nt_variable:
>bfec		08 00				        .byte 8, 0
>bfee		fc bf fa 95 12 96		        .word nt_constant, xt_variable, z_variable
>bff4		76 61 72 69 61 62 6c 65		        .text "variable"
.bffc						nt_constant:
>bffc		08 10				        .byte 8, UF
>bffe		0c c0 ea 83 27 84		        .word nt_value, xt_constant, z_constant
>c004		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c00c						nt_value:
>c00c		05 10				        .byte 5, UF
>c00e		19 c0 ea 83 27 84		        .word nt_to, xt_value, z_value          ; same code as CONSTANT
>c014		76 61 6c 75 65			        .text "value"
.c019						nt_to:
>c019		02 0c				        .byte 2, NN+IM
>c01b		23 c0 76 92 b1 92		        .word nt_s_to_d, xt_to, z_to
>c021		74 6f				        .text "to"
.c023						nt_s_to_d:
>c023		03 10				        .byte 3, UF
>c025		2e c0 d1 90 e2 90		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c02b		73 3e 64			        .text "s>d"
.c02e						nt_d_to_s:
>c02e		03 10				        .byte 3, UF
>c030		39 c0 4d 9e 52 9e		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c036		64 3e 73			        .text "d>s"
.c039						nt_d_minus:
>c039		02 10				        .byte 2, UF
>c03b		43 c0 0b 9e 2b 9e		        .word nt_d_plus, xt_d_minus, z_d_minus
>c041		64 2d				        .text "d-"
.c043						nt_d_plus:
>c043		02 10				        .byte 2, UF
>c045		4d c0 2c 9e 4c 9e		        .word nt_erase, xt_d_plus, z_d_plus
>c04b		64 2b				        .text "d+"
.c04d						nt_erase:
>c04d		05 00				        .byte 5, 0      ; underflow checked by FILL
>c04f		5a c0 bb 87 03 88		        .word nt_blank, xt_erase, z_erase
>c055		65 72 61 73 65			        .text "erase"
.c05a						nt_blank:
>c05a		05 00				        .byte 5, 0     ; underflow checked by FILL
>c05c		67 c0 b1 87 03 88		        .word nt_fill, xt_blank, z_blank
>c062		62 6c 61 6e 6b			        .text "blank"
.c067						nt_fill:
>c067		04 10				        .byte 4, UF
>c069		73 c0 c1 87 03 88		        .word nt_find_name, xt_fill, z_fill
>c06f		66 69 6c 6c			        .text "fill"
.c073						nt_find_name:
>c073		09 10				        .byte 9, UF
>c075		84 c0 03 9b 46 9b		        .word nt_tick, xt_find_name, z_find_name
>c07b		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c083		65
.c084						nt_tick:
>c084		01 00				        .byte 1, 0
>c086		8d c0 56 92 75 92		        .word nt_bracket_tick, xt_tick, z_tick
>c08c		27				        .text "'"
.c08d						nt_bracket_tick:
>c08d		03 05				        .byte 3, CO+IM
>c08f		98 c0 16 83 1c 83		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c095		5b 27 5d			        .text "[']"
.c098						nt_name_to_int:
>c098		08 10				        .byte 8, UF
>c09a		a8 c0 41 9c 5d 9c		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c0a0		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c0a8						nt_int_to_name:
>c0a8		08 10				        .byte 8, UF
>c0aa		b8 c0 bb 9b 2b 9c		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c0b0		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c0b8						nt_name_to_string:
>c0b8		0b 10				        .byte 11, UF
>c0ba		cb c0 5e 9c 74 9c		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c0c0		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c0c8		69 6e 67
.c0cb						nt_to_body:
>c0cb		05 10				        .byte 5, UF
>c0cd		d8 c0 b2 92 d4 92		        .word nt_defer, xt_to_body, z_to_body
>c0d3		3e 62 6f 64 79			        .text ">body"
.c0d8						nt_defer:
>c0d8		05 00				        .byte 5, 0
>c0da		e5 c0 13 85 45 85		        .word nt_latestxt, xt_defer, z_defer
>c0e0		64 65 66 65 72			        .text "defer"
.c0e5						nt_latestxt:
>c0e5		08 00				        .byte 8, 0
>c0e7		f5 c0 3a 9c 40 9c		        .word nt_latestnt, xt_latestxt, z_latestxt
>c0ed		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c0f5						nt_latestnt:
>c0f5		08 00				        .byte 8, 0
>c0f7		05 c1 2c 9c 39 9c		        .word nt_parse_name, xt_latestnt, z_latestnt
>c0fd		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c105						nt_parse_name:
>c105		0a 08				        .byte 10, NN
>c107		17 c1 49 8d 39 8e		        .word nt_parse, xt_parse_name, z_parse_name
>c10d		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c115		6d 65
.c117						nt_parse:
>c117		05 10				        .byte 5, UF
>c119		24 c1 a4 8d 39 8e		        .word nt_execute_parsing, xt_parse, z_parse
>c11f		70 61 72 73 65			        .text "parse"
.c124						nt_execute_parsing:
>c124		0f 10				        .byte 15, UF
>c126		3b c1 dc 9a 02 9b		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c12c		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c134		70 61 72 73 69 6e 67
.c13b						nt_source:
>c13b		06 00				        .byte 6, 0
>c13d		49 c1 9d 91 b1 91		        .word nt_source_id, xt_source, z_source
>c143		73 6f 75 72 63 65		        .text "source"
.c149						nt_source_id:
>c149		09 00				        .byte 9, 0
>c14b		5a c1 b2 91 bc 91		        .word nt_colon, xt_source_id, z_source_id
>c151		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c159		64
.c15a						nt_colon:
>c15a		01 00				        .byte 1, 0
>c15c		63 c1 70 83 b2 83		        .word nt_semicolon, xt_colon, z_colon
>c162		3a				        .text ":"
.c163						nt_semicolon:
>c163		01 05				        .byte 1, CO+IM
>c165		6c c1 e3 90 41 91		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c16b		3b				        .text ";"
.c16c						nt_colon_noname:
>c16c		07 00				        .byte 7, 0
>c16e		7b c1 b3 83 ce 83		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c174		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c17b						nt_compile_comma:
>c17b		08 18				        .byte 8, UF+NN
>c17d		8b c1 cc 96 8d 97		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c183		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c18b						nt_left_bracket:
>c18b		01 05				        .byte 1, IM+CO
>c18d		94 c1 c9 89 cd 89		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c193		5b				        .text "["
.c194						nt_right_bracket:
>c194		01 04				        .byte 1, IM
>c196		9d c1 7c 8f 82 8f		        .word nt_literal, xt_right_bracket, z_right_bracket
>c19c		5d				        .text "]"
.c19d						nt_literal:
>c19d		07 15				        .byte 7, IM+CO+UF
>c19f		ac c1 f1 89 2e 8a		        .word nt_sliteral, xt_literal, z_literal
>c1a5		6c 69 74 65 72 61 6c		        .text "literal"
.c1ac						nt_sliteral:
>c1ac		08 15				        .byte 8, CO+IM+UF
>c1ae		bc c1 45 a1 88 a1		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c1b4		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c1bc						nt_dot_quote:
>c1bc		02 05				        .byte 2, CO+IM
>c1be		c6 c1 60 86 6a 86		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c1c4		2e 22				        .text ".", $22
.c1c6						nt_s_quote:
>c1c6		02 0c				        .byte 2, IM+NN
>c1c8		d0 c1 cc 8f d0 90		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c1ce		73 22				        .text "s", $22
.c1d0						nt_s_backslash_quote:
>c1d0		03 04				        .byte 3, IM
>c1d2		db c1 b3 8f bc 8f		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c1d8		73 5c 22			        .text "s", $5C, $22
.c1db						nt_postpone:
>c1db		08 05				        .byte 8, IM+CO
>c1dd		eb c1 7e 8e bc 8e		        .word nt_immediate, xt_postpone, z_postpone
>c1e3		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c1eb						nt_immediate:
>c1eb		09 00				        .byte 9, 0
>c1ed		fc c1 57 89 62 89		        .word nt_compile_only, xt_immediate, z_immediate
>c1f3		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c1fb		65
.c1fc						nt_compile_only:
>c1fc		0c 00				        .byte 12, 0
>c1fe		10 c2 de 83 e9 83		        .word nt_never_native, xt_compile_only, z_compile_only
>c204		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c20c		6f 6e 6c 79
.c210						nt_never_native:
>c210		0c 00				        .byte 12, 0
>c212		24 c2 7a 9c 87 9c		        .word nt_always_native, xt_never_native, z_never_native
>c218		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c220		74 69 76 65
.c224						nt_always_native:
>c224		0d 00				        .byte 13, 0
>c226		39 c2 2d 9a 3a 9a		        .word nt_allow_native, xt_always_native, z_always_native
>c22c		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c234		61 74 69 76 65
.c239						nt_allow_native:
>c239		0c 00				        .byte 12, 0
>c23b		4d c2 21 9a 2c 9a		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c241		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c249		74 69 76 65
.c24d						nt_nc_limit:
>c24d		08 08				        .byte 8, NN
>c24f		5d c2 75 9c 7a 9c		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c255		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c25d						nt_strip_underflow:
>c25d		0f 08				        .byte 15, NN
>c25f		74 c2 ca 9d cf 9d		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c265		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c26d		64 65 72 66 6c 6f 77
.c274						nt_abort:
>c274		05 00				        .byte 5, 0
>c276		81 c2 60 80 b1 80		        .word nt_abort_quote, xt_abort, z_abort
>c27c		61 62 6f 72 74			        .text "abort"
.c281						nt_abort_quote:
>c281		06 0d				        .byte 6, CO+IM+NN
>c283		8f c2 b1 80 bb 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c289		61 62 6f 72 74 22		        .text "abort", $22
.c28f						nt_do:
>c28f		02 0d				        .byte 2, CO+IM+NN
>c291		99 c2 8a 85 a3 85		        .word nt_question_do, xt_do, z_do
>c297		64 6f				        .text "do"
.c299						nt_question_do:
>c299		03 0d				        .byte 3, CO+IM+NN
>c29b		a4 c2 63 85 a3 85		        .word nt_i, xt_question_do, z_question_do
>c2a1		3f 64 6f			        .text "?do"
.c2a4						nt_i:
>c2a4		01 01				        .byte 1, CO
>c2a6		ad c2 3e 89 52 89		        .word nt_j, xt_i, z_i
>c2ac		69				        .text "i"
.c2ad						nt_j:
>c2ad		01 01				        .byte 1, CO
>c2af		b6 c2 8c 89 a5 89		        .word nt_loop, xt_j, z_j
>c2b5		6a				        .text "j"
.c2b6						nt_loop:
>c2b6		04 05				        .byte 4, CO+IM
>c2b8		c2 c2 58 8a ca 8a		        .word nt_plus_loop, xt_loop, z_loop
>c2be		6c 6f 6f 70			        .text "loop"
.c2c2						nt_plus_loop:
>c2c2		05 05				        .byte 5, CO+IM
>c2c4		cf c2 6c 8a ca 8a		        .word nt_exit, xt_plus_loop, z_plus_loop
>c2ca		2b 6c 6f 6f 70			        .text "+loop"
.c2cf						nt_exit:
>c2cf		04 03				        .byte 4, AN+CO
>c2d1		db c2 18 88 19 88		        .word nt_unloop, xt_exit, z_exit
>c2d7		65 78 69 74			        .text "exit"
.c2db						nt_unloop:
>c2db		06 01				        .byte 6, CO
>c2dd		e9 c2 d6 95 e5 95		        .word nt_leave, xt_unloop, z_unloop
>c2e3		75 6e 6c 6f 6f 70		        .text "unloop"
.c2e9						nt_leave:
>c2e9		05 05				        .byte 5, CO+IM
>c2eb		f6 c2 b3 89 c8 89		        .word nt_recurse, xt_leave, z_leave
>c2f1		6c 65 61 76 65			        .text "leave"
.c2f6						nt_recurse:
>c2f6		07 0d				        .byte 7, CO+IM+NN
>c2f8		05 c3 f7 8e 33 8f		        .word nt_quit, xt_recurse, z_recurse
>c2fe		72 65 63 75 72 73 65		        .text "recurse"
.c305						nt_quit:
>c305		04 00				        .byte 4, 0
>c307		11 c3 62 80 b1 80		        .word nt_begin, xt_quit, z_quit
>c30d		71 75 69 74			        .text "quit"
.c311						nt_begin:
>c311		05 05				        .byte 5, CO+IM
>c313		1e c3 1a 89 24 89		        .word nt_again, xt_begin, z_begin
>c319		62 65 67 69 6e			        .text "begin"
.c31e						nt_again:
>c31e		05 15				        .byte 5, CO+IM+UF
>c320		2b c3 21 82 27 82		        .word nt_state, xt_again, z_again
>c326		61 67 61 69 6e			        .text "again"
.c32b						nt_state:
>c32b		05 00				        .byte 5, 0
>c32d		38 c3 21 92 2b 92		        .word nt_evaluate, xt_state, z_state
>c333		73 74 61 74 65			        .text "state"
.c338						nt_evaluate:
>c338		08 10				        .byte 8, UF
>c33a		48 c3 b1 88 04 89		        .word nt_base, xt_evaluate, z_evaluate
>c340		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c348						nt_base:
>c348		04 00				        .byte 4, 0
>c34a		54 c3 fd 82 05 83		        .word nt_digit_question, xt_base, z_base
>c350		62 61 73 65			        .text "base"
.c354						nt_digit_question:
>c354		06 10				        .byte 6, UF
>c356		62 c3 a7 9a db 9a		        .word nt_number, xt_digit_question, z_digit_question
>c35c		64 69 67 69 74 3f		        .text "digit?"
.c362						nt_number:
>c362		06 10				        .byte 6, UF
>c364		70 c3 a4 9c 9d 9d		        .word nt_to_number, xt_number, z_number
>c36a		6e 75 6d 62 65 72		        .text "number"
.c370						nt_to_number:
>c370		07 10				        .byte 7, UF
>c372		7f c3 e0 92 7f 93		        .word nt_hex, xt_to_number, z_to_number
>c378		3e 6e 75 6d 62 65 72		        .text ">number"
.c37f						nt_hex:
>c37f		03 00				        .byte 3, 0
>c381		8a c3 25 89 2b 89		        .word nt_decimal, xt_hex, z_hex
>c387		68 65 78			        .text "hex"
.c38a						nt_decimal:
>c38a		07 00				        .byte 7, 0
>c38c		99 c3 0c 85 12 85		        .word nt_count, xt_decimal, z_decimal
>c392		64 65 63 69 6d 61 6c		        .text "decimal"
.c399						nt_count:
>c399		05 10				        .byte 5, UF
>c39b		a6 c3 28 84 3b 84		        .word nt_m_star, xt_count, z_count
>c3a1		63 6f 75 6e 74			        .text "count"
.c3a6						nt_m_star:
>c3a6		02 10				        .byte 2, UF
>c3a8		b0 c3 1a 8b 34 8b		        .word nt_um_star, xt_m_star, z_m_star
>c3ae		6d 2a				        .text "m*"
.c3b0						nt_um_star:
>c3b0		03 10				        .byte 3, UF
>c3b2		bb c3 90 95 d5 95		        .word nt_star, xt_um_star, z_um_star
>c3b8		75 6d 2a			        .text "um*"
.c3bb						nt_star:
>c3bb		01 10				        .byte 1, UF
>c3bd		c4 c3 ff 91 07 92		        .word nt_um_slash_mod, xt_star, z_star
>c3c3		2a				        .text "*"
.c3c4						nt_um_slash_mod:
>c3c4		06 10				        .byte 6, UF
>c3c6		d2 c3 4e 95 8f 95		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c3cc		75 6d 2f 6d 6f 64		        .text "um/mod"
.c3d2						nt_sm_slash_rem:
>c3d2		06 10				        .byte 6, UF
>c3d4		e0 c3 74 91 9c 91		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c3da		73 6d 2f 72 65 6d		        .text "sm/rem"
.c3e0						nt_fm_slash_mod:
>c3e0		06 10				        .byte 6, UF
>c3e2		ee c3 74 88 aa 88		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c3e8		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c3ee						nt_slash:
>c3ee		01 10				        .byte 1, UF
>c3f0		f7 c3 57 91 73 91		        .word nt_slash_mod, xt_slash, z_slash
>c3f6		2f				        .text "/"
.c3f7						nt_slash_mod:
>c3f7		04 10				        .byte 4, UF
>c3f9		03 c4 5c 91 73 91		        .word nt_mod, xt_slash_mod, z_slash_mod
>c3ff		2f 6d 6f 64			        .text "/mod"
.c403						nt_mod:
>c403		03 10				        .byte 3, UF
>c405		0e c4 ef 8b f7 8b		        .word nt_star_slash_mod, xt_mod, z_mod
>c40b		6d 6f 64			        .text "mod"
.c40e						nt_star_slash_mod:
>c40e		05 10				        .byte 5, UF
>c410		1b c4 11 92 20 92		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c416		2a 2f 6d 6f 64			        .text "*/mod"
.c41b						nt_star_slash:
>c41b		02 10				        .byte 2, UF
>c41d		25 c4 08 92 10 92		        .word nt_backslash, xt_star_slash, z_star_slash
>c423		2a 2f				        .text "*/"
.c425						nt_backslash:
>c425		01 04				        .byte 1, IM
>c427		2e c4 d2 82 fc 82		        .word nt_move, xt_backslash, z_backslash
>c42d		5c				        .byte '\'
.c42e						nt_move:
>c42e		04 18				        .byte 4, NN+UF
>c430		3a c4 f8 8b 16 8c		        .word nt_cmove_up, xt_move, z_move
>c436		6d 6f 76 65			        .text "move"
.c43a						nt_cmove_up:
>c43a		06 10				        .byte 6, UF
>c43c		48 c4 90 9f ca 9f		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c442		63 6d 6f 76 65 3e		        .text "cmove>"
.c448						nt_cmove:
>c448		05 10				        .byte 5, UF
>c44a		55 c4 55 9f 8f 9f		        .word nt_pad, xt_cmove, z_cmove
>c450		63 6d 6f 76 65			        .text "cmove"
.c455						nt_pad:
>c455		03 00				        .byte 3, 0
>c457		60 c4 0b 8d 1a 8d		        .word nt_cleave, xt_pad, z_pad
>c45d		70 61 64			        .text "pad"
.c460						nt_cleave:
>c460		06 10				        .byte 6, UF
>c462		6e c4 5a 9a a6 9a		        .word nt_hexstore, xt_cleave, z_cleave
>c468		63 6c 65 61 76 65		        .text "cleave"
.c46e						nt_hexstore:
>c46e		08 10				        .byte 8, UF
>c470		7e c4 47 9b 99 9b		        .word nt_within, xt_hexstore, z_hexstore
>c476		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c47e						nt_within:
>c47e		06 10				        .byte 6, UF
>c480		8c c4 1a 96 2f 96		        .word nt_to_in, xt_within, z_within
>c486		77 69 74 68 69 6e		        .text "within"
.c48c						nt_to_in:
>c48c		03 00				        .byte 3, 0
>c48e		97 c4 d5 92 df 92		        .word nt_less_number_sign, xt_to_in, z_to_in
>c494		3e 69 6e			        .text ">in"
.c497						nt_less_number_sign:
>c497		02 00				        .byte 2, 0
>c499		a1 c4 ce 89 db 89		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c49f		3c 23				        .text "<#"
.c4a1						nt_number_sign:
>c4a1		01 10				        .byte 1, UF
>c4a3		aa c4 54 8c 88 8c		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c4a9		23				        .text "#"
.c4aa						nt_number_sign_s:
>c4aa		02 10				        .byte 2, UF
>c4ac		b4 c4 ab 8c bb 8c		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c4b2		23 73				        .text "#s"
.c4b4						nt_number_sign_greater:
>c4b4		02 10				        .byte 2, UF
>c4b6		be c4 89 8c aa 8c		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c4bc		23 3e				        .text "#>"
.c4be						nt_hold:
>c4be		04 10				        .byte 4, UF
>c4c0		ca c4 2c 89 3d 89		        .word nt_sign, xt_hold, z_hold
>c4c6		68 6f 6c 64			        .text "hold"
.c4ca						nt_sign:
>c4ca		04 10				        .byte 4, UF
>c4cc		d6 c4 42 91 56 91		        .word nt_output, xt_sign, z_sign
>c4d2		73 69 67 6e			        .text "sign"
.c4d6						nt_output:
>c4d6		06 00				        .byte 6, 0
>c4d8		e4 c4 a7 9d b1 9d		        .word nt_input, xt_output, z_output
>c4de		6f 75 74 70 75 74		        .text "output"
.c4e4						nt_input:
>c4e4		05 00				        .byte 5, 0
>c4e6		f1 c4 9a 9b a4 9b		        .word nt_cr, xt_input, z_input
>c4ec		69 6e 70 75 74			        .text "input"
.c4f1						nt_cr:
>c4f1		02 00				        .byte 2, 0
>c4f3		fb c4 3c 84 41 84		        .word nt_page, xt_cr, z_cr
>c4f9		63 72				        .text "cr"
.c4fb						nt_page:
>c4fb		04 00				        .byte 4, 0
>c4fd		07 c5 1b 8d 38 8d		        .word nt_at_xy, xt_page, z_page
>c503		70 61 67 65			        .text "page"
.c507						nt_at_xy:
>c507		05 10				        .byte 5, UF
>c509		14 c5 a4 82 d1 82		        .word nt_marker, xt_at_xy, z_at_xy
>c50f		61 74 2d 78 79			        .text "at-xy"
.c514						nt_marker:
>c514		06 04				        .byte 6, IM
>c516		22 c5 35 8b 72 8b		        .word nt_words, xt_marker, z_marker
>c51c		6d 61 72 6b 65 72		        .text "marker"
.c522						nt_words:
>c522		05 00				        .byte 5, 0
>c524		2f c5 c4 99 20 9a		        .word nt_wordsize, xt_words, z_words
>c52a		77 6f 72 64 73			        .text "words"
.c52f						nt_wordsize:
>c52f		08 10				        .byte 8, UF
>c531		3f c5 e3 9d 03 9e		        .word nt_aligned, xt_wordsize, z_wordsize
>c537		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c53f						nt_aligned:
>c53f		07 00				        .byte 7, 0
>c541		4e c5 28 82 28 82		        .word nt_align, xt_aligned, z_aligned   ; same code as ALIGN
>c547		61 6c 69 67 6e 65 64		        .text "aligned"
.c54e						nt_align:
>c54e		05 00				        .byte 5, 0
>c550		5b c5 28 82 28 82		        .word nt_bell, xt_align, z_align
>c556		61 6c 69 67 6e			        .text "align"
.c55b						nt_bell:
>c55b		04 00				        .byte 4, 0
>c55d		67 c5 3b 9a 40 9a		        .word nt_dump, xt_bell, z_bell
>c563		62 65 6c 6c			        .text "bell"
.c567						nt_dump:
>c567		04 10				        .byte 4, UF
>c569		73 c5 b4 98 1a 99		        .word nt_dot_s, xt_dump, z_dump
>c56f		64 75 6d 70			        .text "dump"
.c573						nt_dot_s:
>c573		02 00				        .byte 2, 0
>c575		7d c5 70 98 b3 98		        .word +, xt_dot_s, z_dot_s
>c57b		2e 73				        .text ".s"
.c57d						+
.c57d						nt_disasm:
>c57d		06 10				        .byte 6, UF
>c57f		8b c5 b1 a1 b7 a1		        .word +, xt_disasm, z_disasm
>c585		64 69 73 61 73 6d		        .text "disasm"
.c58b						+
.c58b						nt_compare:
>c58b		07 10				        .byte 7, UF
>c58d		9a c5 cb 9f 2f a0		        .word nt_search, xt_compare, z_compare
>c593		63 6f 6d 70 61 72 65		        .text "compare"
.c59a						nt_search:
>c59a		06 18				        .byte 6, UF+NN
>c59c		a8 c5 86 a0 24 a1		        .word +, xt_search, z_search
>c5a2		73 65 61 72 63 68		        .text "search"
.c5a8						+
.c5a8						nt_environment_q:
>c5a8		0c 10				        .byte 12, UF
>c5aa		bc c5 dc 86 58 87		        .word +, xt_environment_q, z_environment_q
>c5b0		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c5b8		65 6e 74 3f
.c5bc						+
.c5bc						nt_find:
>c5bc		04 10				        .byte 4, UF
>c5be		c8 c5 2c 88 73 88		        .word nt_word, xt_find, z_find
>c5c4		66 69 6e 64			        .text "find"
.c5c8						nt_word:
>c5c8		04 10				        .byte 4, UF
>c5ca		d4 c5 30 96 73 96		        .word nt_paren, xt_word, z_word
>c5d0		77 6f 72 64			        .text "word"
.c5d4						nt_paren:
>c5d4		01 04				        .byte 1, IM
>c5d6		dd c5 39 8d 48 8d		        .word nt_dot_paren, xt_paren, z_paren
>c5dc		28				        .text "("
.c5dd						nt_dot_paren:
>c5dd		02 04				        .byte 2, IM
>c5df		e7 c5 51 86 5f 86		        .word nt_if, xt_dot_paren, z_dot_paren
>c5e5		2e 28				        .text ".("
.c5e7						nt_if:
>c5e7		02 0d				        .byte 2, IM+CO+NN
>c5e9		f1 c5 53 89 56 89		        .word nt_then, xt_if, z_if
>c5ef		69 66				        .text "if"
.c5f1						nt_then:
>c5f1		04 0d				        .byte 4, IM+CO+NN
>c5f3		fd c5 b3 86 bc 86		        .word nt_else, xt_then, z_then
>c5f9		74 68 65 6e			        .text "then"
.c5fd						nt_else:
>c5fd		04 0d				        .byte 4, IM+CO+NN
>c5ff		09 c6 ad 86 bc 86		        .word nt_repeat, xt_else, z_else
>c605		65 6c 73 65			        .text "else"
.c609						nt_repeat:
>c609		06 0d				        .byte 6, IM+CO+NN
>c60b		17 c6 76 8f 7c 8f		        .word nt_until, xt_repeat, z_repeat
>c611		72 65 70 65 61 74		        .text "repeat"
.c617						nt_until:
>c617		05 0d				        .byte 5, IM+CO+NN
>c619		24 c6 e6 95 e9 95		        .word nt_while, xt_until, z_until
>c61f		75 6e 74 69 6c			        .text "until"
.c624						nt_while:
>c624		05 0d				        .byte 5, IM+CO+NN
>c626		31 c6 13 96 19 96		        .word nt_case, xt_while, z_while
>c62c		77 68 69 6c 65			        .text "while"
.c631						nt_case:
>c631		04 0d				        .byte 4, IM+CO+NN
>c633		3d c6 04 9e 0a 9e		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c639		63 61 73 65			        .text "case"
.c63d						nt_of:
>c63d		02 0d				        .byte 2, IM+CO+NN
>c63f		47 c6 bc 8c d4 8c		        .word nt_endof, xt_of, z_of
>c645		6f 66				        .text "of"
.c647						nt_endof:
>c647		05 0d				        .byte 5, IM+CO+NN
>c649		54 c6 ad 86 bc 86		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c64f		65 6e 64 6f 66			        .text "endof"
.c654						nt_endcase:
>c654		07 0d				        .byte 7, IM+CO+NN
>c656		63 c6 c7 86 db 86		        .word nt_defer_fetch, xt_endcase, z_endcase
>c65c		65 6e 64 63 61 73 65		        .text "endcase"
.c663						nt_defer_fetch:
>c663		06 00				        .byte 6, 0
>c665		71 c6 46 85 4c 85		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c66b		64 65 66 65 72 40		        .text "defer@"
.c671						nt_defer_store:
>c671		06 00				        .byte 6, 0
>c673		7f c6 4d 85 53 85		        .word nt_is, xt_defer_store, z_defer_store
>c679		64 65 66 65 72 21		        .text "defer!"
.c67f						nt_is:
>c67f		02 04				        .byte 2, IM
>c681		89 c6 73 89 8b 89		        .word nt_action_of, xt_is, z_is
>c687		69 73				        .text "is"
.c689						nt_action_of:
>c689		09 04				        .byte 9, IM
>c68b		9a c6 08 82 20 82		        .word nt_useraddr, xt_action_of, z_action_of
>c691		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c699		66
.c69a						nt_useraddr:
>c69a		08 00				        .byte 8, 0
>c69c		aa c6 d8 9d e2 9d		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c6a2		75 73 65 72 61 64 64 72		        .text "useraddr"
.c6aa						nt_buffer_colon:
>c6aa		07 00				        .byte 7, 0
>c6ac		b9 c6 1d 83 23 83		        .word +, xt_buffer_colon, z_buffer_colon
>c6b2		62 75 66 66 65 72 3a		        .text "buffer:"
.c6b9						+
.c6b9						nt_buffstatus:
>c6b9		0a 00				        .byte 10, 0
>c6bb		cb c6 e0 af e5 af		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c6c1		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c6c9		75 73
.c6cb						nt_buffblocknum:
>c6cb		0c 00				        .byte 12, 0
>c6cd		df c6 aa af af af		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c6d3		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c6db		6b 6e 75 6d
.c6df						nt_blkbuffer:
>c6df		09 00				        .byte 9, 0
>c6e1		f0 c6 a0 ad ad ad		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c6e7		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c6ef		72
.c6f0						nt_scr:
>c6f0		03 08				        .byte 3, NN
>c6f2		fb c6 62 b0 67 b0		        .word nt_blk, xt_scr, z_scr
>c6f8		73 63 72			        .text "scr"
.c6fb						nt_blk:
>c6fb		03 08				        .byte 3, NN
>c6fd		06 c7 9b ad a0 ad		        .word nt_block_write, xt_blk, z_blk
>c703		62 6c 6b			        .text "blk"
.c706						nt_block_write:
>c706		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c708		19 c7 97 af a5 af		        .word nt_block_write_vector, xt_block_write, z_block_write
>c70e		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c716		69 74 65
.c719						nt_block_write_vector:
>c719		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c71b		33 c7 a5 af aa af		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c721		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c729		69 74 65 2d 76 65 63 74 6f 72
.c733						nt_block_read:
>c733		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c735		45 c7 7f af 8d af		        .word nt_block_read_vector, xt_block_read, z_block_read
>c73b		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c743		61 64
.c745						nt_block_read_vector:
>c745		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c747		5e c7 8d af 92 af		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c74d		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c755		61 64 2d 76 65 63 74 6f 72
.c75e						nt_save_buffers:
>c75e		0c 00				        .byte 12, 0
>c760		72 c7 47 b0 61 b0		        .word nt_block, xt_save_buffers, z_save_buffers
>c766		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c76e		66 65 72 73
.c772						nt_block:
>c772		05 00				        .byte 5, 0
>c774		7f c7 ae ad 00 ae		        .word nt_update, xt_block, z_block
>c77a		62 6c 6f 63 6b			        .text "block"
.c77f						nt_update:
>c77f		06 00				        .byte 6, 0
>c781		8d c7 ac b0 b4 b0		        .word nt_buffer, xt_update, z_update
>c787		75 70 64 61 74 65		        .text "update"
.c78d						nt_buffer:
>c78d		06 00				        .byte 6, 0
>c78f		9b c7 af af df af		        .word nt_empty_buffers, xt_buffer, z_buffer
>c795		62 75 66 66 65 72		        .text "buffer"
.c79b						nt_empty_buffers:
>c79b		0d 00				        .byte 13, 0
>c79d		b0 c7 e5 af eb af		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c7a3		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c7ab		66 66 65 72 73
.c7b0						nt_flush:
>c7b0		05 00				        .byte 5, 0
>c7b2		bd c7 ec af f5 af		        .word nt_load, xt_flush, z_flush
>c7b8		66 6c 75 73 68			        .text "flush"
.c7bd						nt_load:
>c7bd		04 10				        .byte 4, UF
>c7bf		c9 c7 03 b0 46 b0		        .word nt_thru, xt_load, z_load
>c7c5		6c 6f 61 64			        .text "load"
.c7c9						nt_thru:
>c7c9		04 10				        .byte 4, UF
>c7cb		d5 c7 67 b0 ab b0		        .word +, xt_thru, z_thru
>c7d1		74 68 72 75			        .text "thru"
.c7d5						+
.c7d5						nt_list:
>c7d5		04 10				        .byte 4, UF
>c7d7		e1 c7 f6 af 02 b0		        .word nt_block_c65_init, xt_list, z_list
>c7dd		6c 69 73 74			        .text "list"
.c7e1						nt_block_c65_init:
>c7e1		0e 00				        .byte 14, 0
>c7e3		f7 c7 01 ae 36 ae		        .word +, xt_block_c65_init, z_block_c65_init
>c7e9		62 6c 6f 63 6b 2d 63 36		        .text "block-c65-init"
>c7f1		35 2d 69 6e 69 74
.c7f7						+
.c7f7						nt_block_ramdrive_init:
>c7f7		13 10				        .byte 19, UF
>c7f9		12 c8 59 ae 66 ae		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c7ff		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c807		6d 64 72 69 76 65 2d 69 6e 69 74
.c812						+
.c812						nt_definitions:
>c812		0b 00				        .byte 11, 0
>c814		25 c8 ea b1 f2 b1		        .word nt_wordlist, xt_definitions, z_definitions
>c81a		64 65 66 69 6e 69 74 69		        .text "definitions"
>c822		6f 6e 73
.c825						nt_wordlist:
>c825		08 00				        .byte 8, 0
>c827		35 c8 55 b3 6b b3		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c82d		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c835						nt_search_wordlist:
>c835		0f 10				        .byte 15, UF
>c837		4c c8 8e b2 01 b3		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c83d		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c845		6f 72 64 6c 69 73 74
.c84c						nt_set_current:
>c84c		0b 10				        .byte 11, UF
>c84e		5f c8 02 b3 0d b3		        .word nt_get_current, xt_set_current, z_set_current
>c854		73 65 74 2d 63 75 72 72		        .text "set-current"
>c85c		65 6e 74
.c85f						nt_get_current:
>c85f		0b 00				        .byte 11, 0
>c861		72 c8 fa b1 04 b2		        .word nt_set_order, xt_get_current, z_get_current
>c867		67 65 74 2d 63 75 72 72		        .text "get-current"
>c86f		65 6e 74
.c872						nt_set_order:
>c872		09 00				        .byte 9, 0
>c874		83 c8 0e b3 41 b3		        .word nt_get_order, xt_set_order, z_set_order
>c87a		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c882		72
.c883						nt_get_order:
>c883		09 00				        .byte 9, 0
>c885		94 c8 05 b2 2d b2		        .word nt_root_wordlist, xt_get_order, z_get_order
>c88b		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c893		72
.c894						nt_root_wordlist:
>c894		0d 00				        .byte 13, 0
>c896		a9 c8 85 b2 8d b2		        .word +, xt_root_wordlist, z_root_wordlist
>c89c		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c8a4		64 6c 69 73 74
.c8a9						+
.c8a9						nt_assembler_wordlist:
>c8a9		12 00				        .byte 18, 0
>c8ab		c3 c8 cf 9d d7 9d		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c8b1		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c8b9		72 2d 77 6f 72 64 6c 69 73 74
.c8c3						+
.c8c3						nt_editor_wordlist:
>c8c3		0f 00				        .byte 15, 0
>c8c5		da c8 9e 9d a6 9d		        .word +, xt_editor_wordlist, z_editor_wordlist
>c8cb		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c8d3		6f 72 64 6c 69 73 74
.c8da						+
.c8da						nt_forth_wordlist:
>c8da		0e 00				        .byte 14, 0
>c8dc		f0 c8 04 9e 0a 9e		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c8e2		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c8ea		72 64 6c 69 73 74
.c8f0						nt_only:
>c8f0		04 00				        .byte 4, 0
>c8f2		fc c8 2e b2 34 b2		        .word nt_also, xt_only, z_only
>c8f8		6f 6e 6c 79			        .text "only"
.c8fc						nt_also:
>c8fc		04 00				        .byte 4, 0
>c8fe		08 c9 da b1 e9 b1		        .word nt_previous, xt_also, z_also
>c904		61 6c 73 6f			        .text "also"
.c908						nt_previous:
>c908		08 00				        .byte 8, 0
>c90a		18 c9 78 b2 84 b2		        .word nt_to_order, xt_previous, z_previous
>c910		70 72 65 76 69 6f 75 73		        .text "previous"
.c918						nt_to_order:
>c918		06 00				        .byte 6, 0
>c91a		26 c9 42 b3 54 b3		        .word nt_order, xt_to_order, z_to_order
>c920		3e 6f 72 64 65 72		        .text ">order"
.c926						nt_order:
>c926		05 00				        .byte 5, 0
>c928		33 c9 35 b2 5f b2		        .word nt_forth, xt_order, z_order
>c92e		6f 72 64 65 72			        .text "order"
.c933						nt_forth:
>c933		05 00				        .byte 5, 0
>c935		40 c9 f3 b1 f9 b1		        .word +, xt_forth, z_forth
>c93b		66 6f 72 74 68			        .text "forth"
.c940						+
>c940		03 08				nt_see: .byte 3, NN
>c942		4b c9 36 99 c3 99		        .word +, xt_see, z_see
>c948		73 65 65			        .text "see"
.c94b						+
.c94b						nt_ed:
>c94b		03 08				        .byte 3, NN
>c94d		56 c9 a8 a7 ab a7		        .word +, xt_ed, z_ed
>c953		65 64 3a			        .text "ed:"
.c956						+
.c956						nt_cold:
>c956		04 00				        .byte 4, 0
>c958		62 c9 00 80 b1 80		        .word nt_bye, xt_cold, z_cold
>c95e		63 6f 6c 64			        .text "cold"
.c962						nt_bye:
>c962		03				        .byte 3         ; length of word strings
>c963		00				        .byte 0         ; status byte
>c964		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>c966		6d 98				        .word xt_bye    ; start of code block (xt of this word)
>c968		70 98				        .word z_bye     ; end of code (RTS)
>c96a		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.c96d						root_dictionary_start:
.c96d						nt_root_set_order:
>c96d		09 00				        .byte 9, 0
>c96f		7e c9 0e b3 41 b3		        .word nt_root_forth, xt_set_order, z_set_order
>c975		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c97d		72
.c97e						nt_root_forth:
>c97e		05 00				        .byte 5, 0
>c980		8b c9 f3 b1 f9 b1		        .word nt_root_forth_wordlist, xt_forth, z_forth
>c986		66 6f 72 74 68			        .text "forth"
.c98b						nt_root_forth_wordlist:
>c98b		0e 00				        .byte 14, 0
>c98d		a1 c9 04 9e 0a 9e		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>c993		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c99b		72 64 6c 69 73 74
.c9a1						nt_root_words:
>c9a1		05 00				        .byte 5, 0
>c9a3		00 00 c4 99 20 9a		        .word 0000, xt_words, z_words
>c9a9		77 6f 72 64 73			        .text "words"
.c9ae						editor_dictionary_start:
.c9ae						nt_editor_o:
>c9ae		01 00				        .byte 1, 0
>c9b0		b7 c9 94 b1 d9 b1		        .word nt_editor_line, xt_editor_o, z_editor_o
>c9b6		6f				        .text "o"
.c9b7						nt_editor_line:
>c9b7		04 10				        .byte 4, UF
>c9b9		c3 c9 7b b1 93 b1		        .word nt_editor_l, xt_editor_line, z_editor_line
>c9bf		6c 69 6e 65			        .text "line"
.c9c3						nt_editor_l:
>c9c3		01 00				        .byte 1, 0
>c9c5		cc c9 01 b1 7a b1		        .word nt_editor_el, xt_editor_l, z_editor_l
>c9cb		6c				        .text "l"
.c9cc						nt_editor_el:
>c9cc		02 00				        .byte 2, 0
>c9ce		d6 c9 ef b0 00 b1		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>c9d4		65 6c				        .text "el"
.c9d6						nt_editor_erase_screen:
>c9d6		0c 00				        .byte 12, 0
>c9d8		ea c9 dd b0 ee b0		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>c9de		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>c9e6		72 65 65 6e
.c9ea						nt_editor_enter_screen:
>c9ea		0c 00				        .byte 12, 0
>c9ec		00 00 c1 b0 dc b0		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>c9f2		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>c9fa		72 65 65 6e
.c9fe						assembler_dictionary_start:
.c9fe						nt_asm_adc_h:
>c9fe		05 0c						.byte 5, IM+NN
>ca00		0b ca				                .word nt_asm_adc_x
>ca02		f2 a3 f7 a3					.word xt_asm_adc_h, z_asm_adc_h
>ca06		61 64 63 2e 23					.text "adc.#"
.ca0b						nt_asm_adc_x:
>ca0b		05 0c						.byte 5, IM+NN
>ca0d		18 ca				                .word nt_asm_adc_y
>ca0f		f7 a3 fc a3					.word xt_asm_adc_x, z_asm_adc_x
>ca13		61 64 63 2e 78					.text "adc.x"
.ca18						nt_asm_adc_y:
>ca18		05 0c						.byte 5, IM+NN
>ca1a		25 ca				                .word nt_asm_adc_z
>ca1c		fc a3 01 a4					.word xt_asm_adc_y, z_asm_adc_y
>ca20		61 64 63 2e 79					.text "adc.y"
.ca25						nt_asm_adc_z:
>ca25		05 0c						.byte 5, IM+NN
>ca27		32 ca				                .word nt_asm_adc_zi
>ca29		01 a4 06 a4					.word xt_asm_adc_z, z_asm_adc_z
>ca2d		61 64 63 2e 7a					.text "adc.z"
.ca32						nt_asm_adc_zi:
>ca32		06 0c						.byte 6, IM+NN
>ca34		40 ca				                .word nt_asm_adc_ziy
>ca36		06 a4 0b a4					.word xt_asm_adc_zi, z_asm_adc_zi
>ca3a		61 64 63 2e 7a 69				.text "adc.zi"
.ca40						nt_asm_adc_ziy:
>ca40		07 0c						.byte 7, IM+NN
>ca42		4f ca				                .word nt_asm_adc_zx
>ca44		0b a4 10 a4					.word xt_asm_adc_ziy, z_asm_adc_ziy
>ca48		61 64 63 2e 7a 69 79				.text "adc.ziy"
.ca4f						nt_asm_adc_zx:
>ca4f		06 0c						.byte 6, IM+NN
>ca51		5d ca				                .word nt_asm_adc_zxi
>ca53		10 a4 15 a4					.word xt_asm_adc_zx, z_asm_adc_zx
>ca57		61 64 63 2e 7a 78				.text "adc.zx"
.ca5d						nt_asm_adc_zxi:
>ca5d		07 0c						.byte 7, IM+NN
>ca5f		6c ca				                .word nt_asm_and
>ca61		15 a4 1a a4					.word xt_asm_adc_zxi, z_asm_adc_zxi
>ca65		61 64 63 2e 7a 78 69				.text "adc.zxi"
.ca6c						nt_asm_and:
>ca6c		04 0c						.byte 4, IM+NN
>ca6e		78 ca				                .word nt_asm_and_h
>ca70		1a a4 1f a4					.word xt_asm_and, z_asm_and
>ca74		61 6e 64 2e					.text "and."
.ca78						nt_asm_and_h:
>ca78		05 0c						.byte 5, IM+NN
>ca7a		85 ca				                .word nt_asm_and_x
>ca7c		1f a4 24 a4					.word xt_asm_and_h, z_asm_and_h
>ca80		61 6e 64 2e 23					.text "and.#"
.ca85						nt_asm_and_x:
>ca85		05 0c						.byte 5, IM+NN
>ca87		92 ca				                .word nt_asm_and_y
>ca89		24 a4 29 a4					.word xt_asm_and_x, z_asm_and_x
>ca8d		61 6e 64 2e 78					.text "and.x"
.ca92						nt_asm_and_y:
>ca92		05 0c						.byte 5, IM+NN
>ca94		9f ca				                .word nt_asm_and_z
>ca96		29 a4 2e a4					.word xt_asm_and_y, z_asm_and_y
>ca9a		61 6e 64 2e 79					.text "and.y"
.ca9f						nt_asm_and_z:
>ca9f		05 0c						.byte 5, IM+NN
>caa1		ac ca				                .word nt_asm_and_zi
>caa3		2e a4 33 a4					.word xt_asm_and_z, z_asm_and_z
>caa7		61 6e 64 2e 7a					.text "and.z"
.caac						nt_asm_and_zi:
>caac		06 0c						.byte 6, IM+NN
>caae		ba ca				                .word nt_asm_and_ziy
>cab0		33 a4 38 a4					.word xt_asm_and_zi, z_asm_and_zi
>cab4		61 6e 64 2e 7a 69				.text "and.zi"
.caba						nt_asm_and_ziy:
>caba		07 0c						.byte 7, IM+NN
>cabc		c9 ca				                .word nt_asm_and_zx
>cabe		38 a4 3d a4					.word xt_asm_and_ziy, z_asm_and_ziy
>cac2		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cac9						nt_asm_and_zx:
>cac9		06 0c						.byte 6, IM+NN
>cacb		d7 ca				                .word nt_asm_and_zxi
>cacd		3d a4 42 a4					.word xt_asm_and_zx, z_asm_and_zx
>cad1		61 6e 64 2e 7a 78				.text "and.zx"
.cad7						nt_asm_and_zxi:
>cad7		07 0c						.byte 7, IM+NN
>cad9		e6 ca				                .word nt_asm_asl
>cadb		42 a4 47 a4					.word xt_asm_and_zxi, z_asm_and_zxi
>cadf		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cae6						nt_asm_asl:
>cae6		03 0c						.byte 3, IM+NN
>cae8		f1 ca				                .word nt_asm_asl_a
>caea		47 a4 4c a4					.word xt_asm_asl, z_asm_asl
>caee		61 73 6c					.text "asl"
.caf1						nt_asm_asl_a:
>caf1		05 0c						.byte 5, IM+NN
>caf3		fe ca				                .word nt_asm_asl_x
>caf5		4c a4 51 a4					.word xt_asm_asl_a, z_asm_asl_a
>caf9		61 73 6c 2e 61					.text "asl.a"
.cafe						nt_asm_asl_x:
>cafe		05 0c						.byte 5, IM+NN
>cb00		0b cb				                .word nt_asm_asl_z
>cb02		51 a4 56 a4					.word xt_asm_asl_x, z_asm_asl_x
>cb06		61 73 6c 2e 78					.text "asl.x"
.cb0b						nt_asm_asl_z:
>cb0b		05 0c						.byte 5, IM+NN
>cb0d		18 cb				                .word nt_asm_asl_zx
>cb0f		56 a4 5b a4					.word xt_asm_asl_z, z_asm_asl_z
>cb13		61 73 6c 2e 7a					.text "asl.z"
.cb18						nt_asm_asl_zx:
>cb18		06 0c						.byte 6, IM+NN
>cb1a		26 cb				                .word nt_asm_bcc
>cb1c		5b a4 60 a4					.word xt_asm_asl_zx, z_asm_asl_zx
>cb20		61 73 6c 2e 7a 78				.text "asl.zx"
.cb26						nt_asm_bcc:
>cb26		03 0c						.byte 3, IM+NN
>cb28		31 cb				                .word nt_asm_bcs
>cb2a		60 a4 65 a4					.word xt_asm_bcc, z_asm_bcc
>cb2e		62 63 63					.text "bcc"
.cb31						nt_asm_bcs:
>cb31		03 0c						.byte 3, IM+NN
>cb33		3c cb				                .word nt_asm_beq
>cb35		65 a4 6c a4					.word xt_asm_bcs, z_asm_bcs
>cb39		62 63 73					.text "bcs"
.cb3c						nt_asm_beq:
>cb3c		03 0c						.byte 3, IM+NN
>cb3e		47 cb				                .word nt_asm_bit
>cb40		6c a4 71 a4					.word xt_asm_beq, z_asm_beq
>cb44		62 65 71					.text "beq"
.cb47						nt_asm_bit:
>cb47		03 0c						.byte 3, IM+NN
>cb49		52 cb				                .word nt_asm_bit_h
>cb4b		71 a4 76 a4					.word xt_asm_bit, z_asm_bit
>cb4f		62 69 74					.text "bit"
.cb52						nt_asm_bit_h:
>cb52		05 0c						.byte 5, IM+NN
>cb54		5f cb				                .word nt_asm_bit_x
>cb56		76 a4 7b a4					.word xt_asm_bit_h, z_asm_bit_h
>cb5a		62 69 74 2e 23					.text "bit.#"
.cb5f						nt_asm_bit_x:
>cb5f		05 0c						.byte 5, IM+NN
>cb61		6c cb				                .word nt_asm_bit_z
>cb63		7b a4 80 a4					.word xt_asm_bit_x, z_asm_bit_x
>cb67		62 69 74 2e 78					.text "bit.x"
.cb6c						nt_asm_bit_z:
>cb6c		05 0c						.byte 5, IM+NN
>cb6e		79 cb				                .word nt_asm_bit_zx
>cb70		80 a4 85 a4					.word xt_asm_bit_z, z_asm_bit_z
>cb74		62 69 74 2e 7a					.text "bit.z"
.cb79						nt_asm_bit_zx:
>cb79		06 0c						.byte 6, IM+NN
>cb7b		87 cb				                .word nt_asm_bmi
>cb7d		85 a4 8a a4					.word xt_asm_bit_zx, z_asm_bit_zx
>cb81		62 69 74 2e 7a 78				.text "bit.zx"
.cb87						nt_asm_bmi:
>cb87		03 0c						.byte 3, IM+NN
>cb89		92 cb				                .word nt_asm_bne
>cb8b		8a a4 8f a4					.word xt_asm_bmi, z_asm_bmi
>cb8f		62 6d 69					.text "bmi"
.cb92						nt_asm_bne:
>cb92		03 0c						.byte 3, IM+NN
>cb94		9d cb				                .word nt_asm_bpl
>cb96		8f a4 94 a4					.word xt_asm_bne, z_asm_bne
>cb9a		62 6e 65					.text "bne"
.cb9d						nt_asm_bpl:
>cb9d		03 0c						.byte 3, IM+NN
>cb9f		a8 cb				                .word nt_asm_bra
>cba1		94 a4 99 a4					.word xt_asm_bpl, z_asm_bpl
>cba5		62 70 6c					.text "bpl"
.cba8						nt_asm_bra:
>cba8		03 0c						.byte 3, IM+NN
>cbaa		b3 cb				                .word nt_asm_brk
>cbac		99 a4 9e a4					.word xt_asm_bra, z_asm_bra
>cbb0		62 72 61					.text "bra"
.cbb3						nt_asm_brk:
>cbb3		03 0c						.byte 3, IM+NN
>cbb5		be cb				                .word nt_asm_bvc
>cbb7		9e a4 a3 a4					.word xt_asm_brk, z_asm_brk
>cbbb		62 72 6b					.text "brk"
.cbbe						nt_asm_bvc:
>cbbe		03 0c						.byte 3, IM+NN
>cbc0		c9 cb				                .word nt_asm_bvs
>cbc2		a3 a4 a8 a4					.word xt_asm_bvc, z_asm_bvc
>cbc6		62 76 63					.text "bvc"
.cbc9						nt_asm_bvs:
>cbc9		03 0c						.byte 3, IM+NN
>cbcb		d4 cb				                .word nt_asm_clc
>cbcd		a8 a4 ad a4					.word xt_asm_bvs, z_asm_bvs
>cbd1		62 76 73					.text "bvs"
.cbd4						nt_asm_clc:
>cbd4		03 0c						.byte 3, IM+NN
>cbd6		df cb				                .word nt_asm_cld
>cbd8		ad a4 b2 a4					.word xt_asm_clc, z_asm_clc
>cbdc		63 6c 63					.text "clc"
.cbdf						nt_asm_cld:
>cbdf		03 0c						.byte 3, IM+NN
>cbe1		ea cb				                .word nt_asm_cli
>cbe3		b2 a4 b7 a4					.word xt_asm_cld, z_asm_cld
>cbe7		63 6c 64					.text "cld"
.cbea						nt_asm_cli:
>cbea		03 0c						.byte 3, IM+NN
>cbec		f5 cb				                .word nt_asm_clv
>cbee		b7 a4 bc a4					.word xt_asm_cli, z_asm_cli
>cbf2		63 6c 69					.text "cli"
.cbf5						nt_asm_clv:
>cbf5		03 0c						.byte 3, IM+NN
>cbf7		00 cc				                .word nt_asm_cmp
>cbf9		bc a4 c1 a4					.word xt_asm_clv, z_asm_clv
>cbfd		63 6c 76					.text "clv"
.cc00						nt_asm_cmp:
>cc00		03 0c						.byte 3, IM+NN
>cc02		0b cc				                .word nt_asm_cmp_h
>cc04		c1 a4 c6 a4					.word xt_asm_cmp, z_asm_cmp
>cc08		63 6d 70					.text "cmp"
.cc0b						nt_asm_cmp_h:
>cc0b		05 0c						.byte 5, IM+NN
>cc0d		18 cc				                .word nt_asm_cmp_x
>cc0f		c6 a4 cb a4					.word xt_asm_cmp_h, z_asm_cmp_h
>cc13		63 6d 70 2e 23					.text "cmp.#"
.cc18						nt_asm_cmp_x:
>cc18		05 0c						.byte 5, IM+NN
>cc1a		25 cc				                .word nt_asm_cmp_y
>cc1c		cb a4 d0 a4					.word xt_asm_cmp_x, z_asm_cmp_x
>cc20		63 6d 70 2e 78					.text "cmp.x"
.cc25						nt_asm_cmp_y:
>cc25		05 0c						.byte 5, IM+NN
>cc27		32 cc				                .word nt_asm_cmp_z
>cc29		d0 a4 d5 a4					.word xt_asm_cmp_y, z_asm_cmp_y
>cc2d		63 6d 70 2e 79					.text "cmp.y"
.cc32						nt_asm_cmp_z:
>cc32		05 0c						.byte 5, IM+NN
>cc34		3f cc				                .word nt_asm_cmp_zi
>cc36		d5 a4 da a4					.word xt_asm_cmp_z, z_asm_cmp_z
>cc3a		63 6d 70 2e 7a					.text "cmp.z"
.cc3f						nt_asm_cmp_zi:
>cc3f		06 0c						.byte 6, IM+NN
>cc41		4d cc				                .word nt_asm_cmp_ziy
>cc43		da a4 df a4					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cc47		63 6d 70 2e 7a 69				.text "cmp.zi"
.cc4d						nt_asm_cmp_ziy:
>cc4d		07 0c						.byte 7, IM+NN
>cc4f		5c cc				                .word nt_asm_cmp_zx
>cc51		df a4 e4 a4					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cc55		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cc5c						nt_asm_cmp_zx:
>cc5c		06 0c						.byte 6, IM+NN
>cc5e		6a cc				                .word nt_asm_cmp_zxi
>cc60		e4 a4 e9 a4					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cc64		63 6d 70 2e 7a 78				.text "cmp.zx"
.cc6a						nt_asm_cmp_zxi:
>cc6a		07 0c						.byte 7, IM+NN
>cc6c		79 cc				                .word nt_asm_cpx
>cc6e		e9 a4 ee a4					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cc72		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cc79						nt_asm_cpx:
>cc79		03 0c						.byte 3, IM+NN
>cc7b		84 cc				                .word nt_asm_cpx_h
>cc7d		ee a4 f3 a4					.word xt_asm_cpx, z_asm_cpx
>cc81		63 70 78					.text "cpx"
.cc84						nt_asm_cpx_h:
>cc84		05 0c						.byte 5, IM+NN
>cc86		91 cc				                .word nt_asm_cpx_z
>cc88		f3 a4 f8 a4					.word xt_asm_cpx_h, z_asm_cpx_h
>cc8c		63 70 78 2e 23					.text "cpx.#"
.cc91						nt_asm_cpx_z:
>cc91		05 0c						.byte 5, IM+NN
>cc93		9e cc				                .word nt_asm_cpy
>cc95		f8 a4 fd a4					.word xt_asm_cpx_z, z_asm_cpx_z
>cc99		63 70 78 2e 7a					.text "cpx.z"
.cc9e						nt_asm_cpy:
>cc9e		03 0c						.byte 3, IM+NN
>cca0		a9 cc				                .word nt_asm_cpy_h
>cca2		fd a4 04 a5					.word xt_asm_cpy, z_asm_cpy
>cca6		63 70 79					.text "cpy"
.cca9						nt_asm_cpy_h:
>cca9		05 0c						.byte 5, IM+NN
>ccab		b6 cc				                .word nt_asm_cpy_z
>ccad		04 a5 09 a5					.word xt_asm_cpy_h, z_asm_cpy_h
>ccb1		63 70 79 2e 23					.text "cpy.#"
.ccb6						nt_asm_cpy_z:
>ccb6		05 0c						.byte 5, IM+NN
>ccb8		c3 cc				                .word nt_asm_dec
>ccba		09 a5 0e a5					.word xt_asm_cpy_z, z_asm_cpy_z
>ccbe		63 70 79 2e 7a					.text "cpy.z"
.ccc3						nt_asm_dec:
>ccc3		03 0c						.byte 3, IM+NN
>ccc5		ce cc				                .word nt_asm_dec_a
>ccc7		0e a5 13 a5					.word xt_asm_dec, z_asm_dec
>cccb		64 65 63					.text "dec"
.ccce						nt_asm_dec_a:
>ccce		05 0c						.byte 5, IM+NN
>ccd0		db cc				                .word nt_asm_dec_x
>ccd2		13 a5 18 a5					.word xt_asm_dec_a, z_asm_dec_a
>ccd6		64 65 63 2e 61					.text "dec.a"
.ccdb						nt_asm_dec_x:
>ccdb		05 0c						.byte 5, IM+NN
>ccdd		e8 cc				                .word nt_asm_dec_z
>ccdf		18 a5 1d a5					.word xt_asm_dec_x, z_asm_dec_x
>cce3		64 65 63 2e 78					.text "dec.x"
.cce8						nt_asm_dec_z:
>cce8		05 0c						.byte 5, IM+NN
>ccea		f5 cc				                .word nt_asm_dec_zx
>ccec		1d a5 22 a5					.word xt_asm_dec_z, z_asm_dec_z
>ccf0		64 65 63 2e 7a					.text "dec.z"
.ccf5						nt_asm_dec_zx:
>ccf5		06 0c						.byte 6, IM+NN
>ccf7		03 cd				                .word nt_asm_dex
>ccf9		22 a5 27 a5					.word xt_asm_dec_zx, z_asm_dec_zx
>ccfd		64 65 63 2e 7a 78				.text "dec.zx"
.cd03						nt_asm_dex:
>cd03		03 0c						.byte 3, IM+NN
>cd05		0e cd				                .word nt_asm_dey
>cd07		27 a5 2c a5					.word xt_asm_dex, z_asm_dex
>cd0b		64 65 78					.text "dex"
.cd0e						nt_asm_dey:
>cd0e		03 0c						.byte 3, IM+NN
>cd10		19 cd				                .word nt_asm_eor
>cd12		2c a5 31 a5					.word xt_asm_dey, z_asm_dey
>cd16		64 65 79					.text "dey"
.cd19						nt_asm_eor:
>cd19		03 0c						.byte 3, IM+NN
>cd1b		24 cd				                .word nt_asm_eor_h
>cd1d		31 a5 36 a5					.word xt_asm_eor, z_asm_eor
>cd21		65 6f 72					.text "eor"
.cd24						nt_asm_eor_h:
>cd24		05 0c						.byte 5, IM+NN
>cd26		31 cd				                .word nt_asm_eor_x
>cd28		36 a5 3b a5					.word xt_asm_eor_h, z_asm_eor_h
>cd2c		65 6f 72 2e 23					.text "eor.#"
.cd31						nt_asm_eor_x:
>cd31		05 0c						.byte 5, IM+NN
>cd33		3e cd				                .word nt_asm_eor_y
>cd35		3b a5 40 a5					.word xt_asm_eor_x, z_asm_eor_x
>cd39		65 6f 72 2e 78					.text "eor.x"
.cd3e						nt_asm_eor_y:
>cd3e		05 0c						.byte 5, IM+NN
>cd40		4b cd				                .word nt_asm_eor_z
>cd42		40 a5 45 a5					.word xt_asm_eor_y, z_asm_eor_y
>cd46		65 6f 72 2e 79					.text "eor.y"
.cd4b						nt_asm_eor_z:
>cd4b		05 0c						.byte 5, IM+NN
>cd4d		58 cd				                .word nt_asm_eor_zi
>cd4f		45 a5 4a a5					.word xt_asm_eor_z, z_asm_eor_z
>cd53		65 6f 72 2e 7a					.text "eor.z"
.cd58						nt_asm_eor_zi:
>cd58		06 0c						.byte 6, IM+NN
>cd5a		66 cd				                .word nt_asm_eor_ziy
>cd5c		4a a5 4f a5					.word xt_asm_eor_zi, z_asm_eor_zi
>cd60		65 6f 72 2e 7a 69				.text "eor.zi"
.cd66						nt_asm_eor_ziy:
>cd66		07 0c						.byte 7, IM+NN
>cd68		75 cd				                .word nt_asm_eor_zx
>cd6a		4f a5 54 a5					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cd6e		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cd75						nt_asm_eor_zx:
>cd75		06 0c						.byte 6, IM+NN
>cd77		83 cd				                .word nt_asm_eor_zxi
>cd79		54 a5 59 a5					.word xt_asm_eor_zx, z_asm_eor_zx
>cd7d		65 6f 72 2e 7a 78				.text "eor.zx"
.cd83						nt_asm_eor_zxi:
>cd83		07 0c						.byte 7, IM+NN
>cd85		92 cd				                .word nt_asm_inc
>cd87		59 a5 5e a5					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cd8b		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cd92						nt_asm_inc:
>cd92		03 0c						.byte 3, IM+NN
>cd94		9d cd				                .word nt_asm_inc_a
>cd96		5e a5 63 a5					.word xt_asm_inc, z_asm_inc
>cd9a		69 6e 63					.text "inc"
.cd9d						nt_asm_inc_a:
>cd9d		05 0c						.byte 5, IM+NN
>cd9f		aa cd				                .word nt_asm_inc_x
>cda1		63 a5 68 a5					.word xt_asm_inc_a, z_asm_inc_a
>cda5		69 6e 63 2e 61					.text "inc.a"
.cdaa						nt_asm_inc_x:
>cdaa		05 0c						.byte 5, IM+NN
>cdac		b7 cd				                .word nt_asm_inc_z
>cdae		68 a5 6d a5					.word xt_asm_inc_x, z_asm_inc_x
>cdb2		69 6e 63 2e 78					.text "inc.x"
.cdb7						nt_asm_inc_z:
>cdb7		05 0c						.byte 5, IM+NN
>cdb9		c4 cd				                .word nt_asm_inc_zx
>cdbb		6d a5 72 a5					.word xt_asm_inc_z, z_asm_inc_z
>cdbf		69 6e 63 2e 7a					.text "inc.z"
.cdc4						nt_asm_inc_zx:
>cdc4		06 0c						.byte 6, IM+NN
>cdc6		d2 cd				                .word nt_asm_inx
>cdc8		72 a5 77 a5					.word xt_asm_inc_zx, z_asm_inc_zx
>cdcc		69 6e 63 2e 7a 78				.text "inc.zx"
.cdd2						nt_asm_inx:
>cdd2		03 0c						.byte 3, IM+NN
>cdd4		dd cd				                .word nt_asm_iny
>cdd6		77 a5 7c a5					.word xt_asm_inx, z_asm_inx
>cdda		69 6e 78					.text "inx"
.cddd						nt_asm_iny:
>cddd		03 0c						.byte 3, IM+NN
>cddf		e8 cd				                .word nt_asm_jmp
>cde1		7c a5 81 a5					.word xt_asm_iny, z_asm_iny
>cde5		69 6e 79					.text "iny"
.cde8						nt_asm_jmp:
>cde8		03 0c						.byte 3, IM+NN
>cdea		f3 cd				                .word nt_asm_jmp_i
>cdec		81 a5 86 a5					.word xt_asm_jmp, z_asm_jmp
>cdf0		6a 6d 70					.text "jmp"
.cdf3						nt_asm_jmp_i:
>cdf3		05 0c						.byte 5, IM+NN
>cdf5		00 ce				                .word nt_asm_jmp_xi
>cdf7		86 a5 8b a5					.word xt_asm_jmp_i, z_asm_jmp_i
>cdfb		6a 6d 70 2e 69					.text "jmp.i"
.ce00						nt_asm_jmp_xi:
>ce00		06 0c						.byte 6, IM+NN
>ce02		0e ce				                .word nt_asm_jsr
>ce04		8b a5 90 a5					.word xt_asm_jmp_xi, z_asm_jmp_xi
>ce08		6a 6d 70 2e 78 69				.text "jmp.xi"
.ce0e						nt_asm_jsr:
>ce0e		03 0c						.byte 3, IM+NN
>ce10		19 ce				                .word nt_asm_lda
>ce12		90 a5 95 a5					.word xt_asm_jsr, z_asm_jsr
>ce16		6a 73 72					.text "jsr"
.ce19						nt_asm_lda:
>ce19		03 0c						.byte 3, IM+NN
>ce1b		24 ce				                .word nt_asm_lda_h
>ce1d		95 a5 9a a5					.word xt_asm_lda, z_asm_lda
>ce21		6c 64 61					.text "lda"
.ce24						nt_asm_lda_h:
>ce24		05 0c						.byte 5, IM+NN
>ce26		31 ce				                .word nt_asm_lda_x
>ce28		9a a5 9f a5					.word xt_asm_lda_h, z_asm_lda_h
>ce2c		6c 64 61 2e 23					.text "lda.#"
.ce31						nt_asm_lda_x:
>ce31		05 0c						.byte 5, IM+NN
>ce33		3e ce				                .word nt_asm_lda_y
>ce35		9f a5 a4 a5					.word xt_asm_lda_x, z_asm_lda_x
>ce39		6c 64 61 2e 78					.text "lda.x"
.ce3e						nt_asm_lda_y:
>ce3e		05 0c						.byte 5, IM+NN
>ce40		4b ce				                .word nt_asm_lda_z
>ce42		a4 a5 a9 a5					.word xt_asm_lda_y, z_asm_lda_y
>ce46		6c 64 61 2e 79					.text "lda.y"
.ce4b						nt_asm_lda_z:
>ce4b		05 0c						.byte 5, IM+NN
>ce4d		58 ce				                .word nt_asm_lda_zi
>ce4f		a9 a5 ae a5					.word xt_asm_lda_z, z_asm_lda_z
>ce53		6c 64 61 2e 7a					.text "lda.z"
.ce58						nt_asm_lda_zi:
>ce58		06 0c						.byte 6, IM+NN
>ce5a		66 ce				                .word nt_asm_lda_ziy
>ce5c		ae a5 b3 a5					.word xt_asm_lda_zi, z_asm_lda_zi
>ce60		6c 64 61 2e 7a 69				.text "lda.zi"
.ce66						nt_asm_lda_ziy:
>ce66		07 0c						.byte 7, IM+NN
>ce68		75 ce				                .word nt_asm_lda_zx
>ce6a		b3 a5 b8 a5					.word xt_asm_lda_ziy, z_asm_lda_ziy
>ce6e		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.ce75						nt_asm_lda_zx:
>ce75		06 0c						.byte 6, IM+NN
>ce77		83 ce				                .word nt_asm_lda_zxi
>ce79		b8 a5 bd a5					.word xt_asm_lda_zx, z_asm_lda_zx
>ce7d		6c 64 61 2e 7a 78				.text "lda.zx"
.ce83						nt_asm_lda_zxi:
>ce83		07 0c						.byte 7, IM+NN
>ce85		92 ce				                .word nt_asm_ldx
>ce87		bd a5 c2 a5					.word xt_asm_lda_zxi, z_asm_lda_zxi
>ce8b		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.ce92						nt_asm_ldx:
>ce92		03 0c						.byte 3, IM+NN
>ce94		9d ce				                .word nt_asm_ldx_h
>ce96		c2 a5 c7 a5					.word xt_asm_ldx, z_asm_ldx
>ce9a		6c 64 78					.text "ldx"
.ce9d						nt_asm_ldx_h:
>ce9d		05 0c						.byte 5, IM+NN
>ce9f		aa ce				                .word nt_asm_ldx_y
>cea1		c7 a5 cc a5					.word xt_asm_ldx_h, z_asm_ldx_h
>cea5		6c 64 78 2e 23					.text "ldx.#"
.ceaa						nt_asm_ldx_y:
>ceaa		05 0c						.byte 5, IM+NN
>ceac		b7 ce				                .word nt_asm_ldx_z
>ceae		cc a5 d1 a5					.word xt_asm_ldx_y, z_asm_ldx_y
>ceb2		6c 64 78 2e 79					.text "ldx.y"
.ceb7						nt_asm_ldx_z:
>ceb7		05 0c						.byte 5, IM+NN
>ceb9		c4 ce				                .word nt_asm_ldx_zy
>cebb		d1 a5 d6 a5					.word xt_asm_ldx_z, z_asm_ldx_z
>cebf		6c 64 78 2e 7a					.text "ldx.z"
.cec4						nt_asm_ldx_zy:
>cec4		06 0c						.byte 6, IM+NN
>cec6		d2 ce				                .word nt_asm_ldy
>cec8		d6 a5 db a5					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cecc		6c 64 78 2e 7a 79				.text "ldx.zy"
.ced2						nt_asm_ldy:
>ced2		03 0c						.byte 3, IM+NN
>ced4		dd ce				                .word nt_asm_ldy_h
>ced6		db a5 e0 a5					.word xt_asm_ldy, z_asm_ldy
>ceda		6c 64 79					.text "ldy"
.cedd						nt_asm_ldy_h:
>cedd		05 0c						.byte 5, IM+NN
>cedf		ea ce				                .word nt_asm_ldy_x
>cee1		e0 a5 e5 a5					.word xt_asm_ldy_h, z_asm_ldy_h
>cee5		6c 64 79 2e 23					.text "ldy.#"
.ceea						nt_asm_ldy_x:
>ceea		05 0c						.byte 5, IM+NN
>ceec		f7 ce				                .word nt_asm_ldy_z
>ceee		e5 a5 ea a5					.word xt_asm_ldy_x, z_asm_ldy_x
>cef2		6c 64 79 2e 78					.text "ldy.x"
.cef7						nt_asm_ldy_z:
>cef7		05 0c						.byte 5, IM+NN
>cef9		04 cf				                .word nt_asm_ldy_zx
>cefb		ea a5 ef a5					.word xt_asm_ldy_z, z_asm_ldy_z
>ceff		6c 64 79 2e 7a					.text "ldy.z"
.cf04						nt_asm_ldy_zx:
>cf04		06 0c						.byte 6, IM+NN
>cf06		12 cf				                .word nt_asm_lsr
>cf08		ef a5 f4 a5					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cf0c		6c 64 79 2e 7a 78				.text "ldy.zx"
.cf12						nt_asm_lsr:
>cf12		03 0c						.byte 3, IM+NN
>cf14		1d cf				                .word nt_asm_lsr_a
>cf16		f4 a5 f9 a5					.word xt_asm_lsr, z_asm_lsr
>cf1a		6c 73 72					.text "lsr"
.cf1d						nt_asm_lsr_a:
>cf1d		05 0c						.byte 5, IM+NN
>cf1f		2a cf				                .word nt_asm_lsr_x
>cf21		f9 a5 fe a5					.word xt_asm_lsr_a, z_asm_lsr_a
>cf25		6c 73 72 2e 61					.text "lsr.a"
.cf2a						nt_asm_lsr_x:
>cf2a		05 0c						.byte 5, IM+NN
>cf2c		37 cf				                .word nt_asm_lsr_z
>cf2e		fe a5 03 a6					.word xt_asm_lsr_x, z_asm_lsr_x
>cf32		6c 73 72 2e 78					.text "lsr.x"
.cf37						nt_asm_lsr_z:
>cf37		05 0c						.byte 5, IM+NN
>cf39		44 cf				                .word nt_asm_lsr_zx
>cf3b		03 a6 08 a6					.word xt_asm_lsr_z, z_asm_lsr_z
>cf3f		6c 73 72 2e 7a					.text "lsr.z"
.cf44						nt_asm_lsr_zx:
>cf44		06 0c						.byte 6, IM+NN
>cf46		52 cf				                .word nt_asm_nop
>cf48		08 a6 0d a6					.word xt_asm_lsr_zx, z_asm_lsr_zx
>cf4c		6c 73 72 2e 7a 78				.text "lsr.zx"
.cf52						nt_asm_nop:
>cf52		03 0c						.byte 3, IM+NN
>cf54		5d cf				                .word nt_asm_ora
>cf56		0d a6 12 a6					.word xt_asm_nop, z_asm_nop
>cf5a		6e 6f 70					.text "nop"
.cf5d						nt_asm_ora:
>cf5d		03 0c						.byte 3, IM+NN
>cf5f		68 cf				                .word nt_asm_ora_h
>cf61		12 a6 17 a6					.word xt_asm_ora, z_asm_ora
>cf65		6f 72 61					.text "ora"
.cf68						nt_asm_ora_h:
>cf68		05 0c						.byte 5, IM+NN
>cf6a		75 cf				                .word nt_asm_ora_x
>cf6c		17 a6 1c a6					.word xt_asm_ora_h, z_asm_ora_h
>cf70		6f 72 61 2e 23					.text "ora.#"
.cf75						nt_asm_ora_x:
>cf75		05 0c						.byte 5, IM+NN
>cf77		82 cf				                .word nt_asm_ora_y
>cf79		1c a6 21 a6					.word xt_asm_ora_x, z_asm_ora_x
>cf7d		6f 72 61 2e 78					.text "ora.x"
.cf82						nt_asm_ora_y:
>cf82		05 0c						.byte 5, IM+NN
>cf84		8f cf				                .word nt_asm_ora_z
>cf86		21 a6 26 a6					.word xt_asm_ora_y, z_asm_ora_y
>cf8a		6f 72 61 2e 79					.text "ora.y"
.cf8f						nt_asm_ora_z:
>cf8f		05 0c						.byte 5, IM+NN
>cf91		9c cf				                .word nt_asm_ora_zi
>cf93		26 a6 2b a6					.word xt_asm_ora_z, z_asm_ora_z
>cf97		6f 72 61 2e 7a					.text "ora.z"
.cf9c						nt_asm_ora_zi:
>cf9c		06 0c						.byte 6, IM+NN
>cf9e		aa cf				                .word nt_asm_ora_ziy
>cfa0		2b a6 32 a6					.word xt_asm_ora_zi, z_asm_ora_zi
>cfa4		6f 72 61 2e 7a 69				.text "ora.zi"
.cfaa						nt_asm_ora_ziy:
>cfaa		07 0c						.byte 7, IM+NN
>cfac		b9 cf				                .word nt_asm_ora_zx
>cfae		32 a6 37 a6					.word xt_asm_ora_ziy, z_asm_ora_ziy
>cfb2		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.cfb9						nt_asm_ora_zx:
>cfb9		06 0c						.byte 6, IM+NN
>cfbb		c7 cf				                .word nt_asm_ora_zxi
>cfbd		37 a6 3c a6					.word xt_asm_ora_zx, z_asm_ora_zx
>cfc1		6f 72 61 2e 7a 78				.text "ora.zx"
.cfc7						nt_asm_ora_zxi:
>cfc7		07 0c						.byte 7, IM+NN
>cfc9		d6 cf				                .word nt_asm_pha
>cfcb		3c a6 41 a6					.word xt_asm_ora_zxi, z_asm_ora_zxi
>cfcf		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.cfd6						nt_asm_pha:
>cfd6		03 0c						.byte 3, IM+NN
>cfd8		e1 cf				                .word nt_asm_php
>cfda		41 a6 46 a6					.word xt_asm_pha, z_asm_pha
>cfde		70 68 61					.text "pha"
.cfe1						nt_asm_php:
>cfe1		03 0c						.byte 3, IM+NN
>cfe3		ec cf				                .word nt_asm_phx
>cfe5		46 a6 4b a6					.word xt_asm_php, z_asm_php
>cfe9		70 68 70					.text "php"
.cfec						nt_asm_phx:
>cfec		03 0c						.byte 3, IM+NN
>cfee		f7 cf				                .word nt_asm_phy
>cff0		4b a6 50 a6					.word xt_asm_phx, z_asm_phx
>cff4		70 68 78					.text "phx"
.cff7						nt_asm_phy:
>cff7		03 0c						.byte 3, IM+NN
>cff9		02 d0				                .word nt_asm_pla
>cffb		50 a6 55 a6					.word xt_asm_phy, z_asm_phy
>cfff		70 68 79					.text "phy"
.d002						nt_asm_pla:
>d002		03 0c						.byte 3, IM+NN
>d004		0d d0				                .word nt_asm_plp
>d006		55 a6 5a a6					.word xt_asm_pla, z_asm_pla
>d00a		70 6c 61					.text "pla"
.d00d						nt_asm_plp:
>d00d		03 0c						.byte 3, IM+NN
>d00f		18 d0				                .word nt_asm_plx
>d011		5a a6 5f a6					.word xt_asm_plp, z_asm_plp
>d015		70 6c 70					.text "plp"
.d018						nt_asm_plx:
>d018		03 0c						.byte 3, IM+NN
>d01a		23 d0				                .word nt_asm_ply
>d01c		5f a6 64 a6					.word xt_asm_plx, z_asm_plx
>d020		70 6c 78					.text "plx"
.d023						nt_asm_ply:
>d023		03 0c						.byte 3, IM+NN
>d025		2e d0				                .word nt_asm_rol
>d027		64 a6 69 a6					.word xt_asm_ply, z_asm_ply
>d02b		70 6c 79					.text "ply"
.d02e						nt_asm_rol:
>d02e		03 0c						.byte 3, IM+NN
>d030		39 d0				                .word nt_asm_rol_a
>d032		69 a6 6e a6					.word xt_asm_rol, z_asm_rol
>d036		72 6f 6c					.text "rol"
.d039						nt_asm_rol_a:
>d039		05 0c						.byte 5, IM+NN
>d03b		46 d0				                .word nt_asm_rol_x
>d03d		6e a6 73 a6					.word xt_asm_rol_a, z_asm_rol_a
>d041		72 6f 6c 2e 61					.text "rol.a"
.d046						nt_asm_rol_x:
>d046		05 0c						.byte 5, IM+NN
>d048		53 d0				                .word nt_asm_rol_z
>d04a		73 a6 78 a6					.word xt_asm_rol_x, z_asm_rol_x
>d04e		72 6f 6c 2e 78					.text "rol.x"
.d053						nt_asm_rol_z:
>d053		05 0c						.byte 5, IM+NN
>d055		60 d0				                .word nt_asm_rol_zx
>d057		78 a6 7d a6					.word xt_asm_rol_z, z_asm_rol_z
>d05b		72 6f 6c 2e 7a					.text "rol.z"
.d060						nt_asm_rol_zx:
>d060		06 0c						.byte 6, IM+NN
>d062		6e d0				                .word nt_asm_ror
>d064		7d a6 82 a6					.word xt_asm_rol_zx, z_asm_rol_zx
>d068		72 6f 6c 2e 7a 78				.text "rol.zx"
.d06e						nt_asm_ror:
>d06e		03 0c						.byte 3, IM+NN
>d070		79 d0				                .word nt_asm_ror_a
>d072		82 a6 87 a6					.word xt_asm_ror, z_asm_ror
>d076		72 6f 72					.text "ror"
.d079						nt_asm_ror_a:
>d079		05 0c						.byte 5, IM+NN
>d07b		86 d0				                .word nt_asm_ror_x
>d07d		87 a6 8c a6					.word xt_asm_ror_a, z_asm_ror_a
>d081		72 6f 72 2e 61					.text "ror.a"
.d086						nt_asm_ror_x:
>d086		05 0c						.byte 5, IM+NN
>d088		93 d0				                .word nt_asm_ror_z
>d08a		8c a6 91 a6					.word xt_asm_ror_x, z_asm_ror_x
>d08e		72 6f 72 2e 78					.text "ror.x"
.d093						nt_asm_ror_z:
>d093		05 0c						.byte 5, IM+NN
>d095		a0 d0				                .word nt_asm_ror_zx
>d097		91 a6 96 a6					.word xt_asm_ror_z, z_asm_ror_z
>d09b		72 6f 72 2e 7a					.text "ror.z"
.d0a0						nt_asm_ror_zx:
>d0a0		06 0c						.byte 6, IM+NN
>d0a2		ae d0				                .word nt_asm_rti
>d0a4		96 a6 9b a6					.word xt_asm_ror_zx, z_asm_ror_zx
>d0a8		72 6f 72 2e 7a 78				.text "ror.zx"
.d0ae						nt_asm_rti:
>d0ae		03 0c						.byte 3, IM+NN
>d0b0		b9 d0				                .word nt_asm_rts
>d0b2		9b a6 a0 a6					.word xt_asm_rti, z_asm_rti
>d0b6		72 74 69					.text "rti"
.d0b9						nt_asm_rts:
>d0b9		03 0c						.byte 3, IM+NN
>d0bb		c4 d0				                .word nt_asm_sbc
>d0bd		a0 a6 a5 a6					.word xt_asm_rts, z_asm_rts
>d0c1		72 74 73					.text "rts"
.d0c4						nt_asm_sbc:
>d0c4		03 0c						.byte 3, IM+NN
>d0c6		cf d0				                .word nt_asm_sbc_h
>d0c8		a5 a6 aa a6					.word xt_asm_sbc, z_asm_sbc
>d0cc		73 62 63					.text "sbc"
.d0cf						nt_asm_sbc_h:
>d0cf		05 0c						.byte 5, IM+NN
>d0d1		dc d0				                .word nt_asm_sbc_x
>d0d3		aa a6 af a6					.word xt_asm_sbc_h, z_asm_sbc_h
>d0d7		73 62 63 2e 23					.text "sbc.#"
.d0dc						nt_asm_sbc_x:
>d0dc		05 0c						.byte 5, IM+NN
>d0de		e9 d0				                .word nt_asm_sbc_y
>d0e0		af a6 b4 a6					.word xt_asm_sbc_x, z_asm_sbc_x
>d0e4		73 62 63 2e 78					.text "sbc.x"
.d0e9						nt_asm_sbc_y:
>d0e9		05 0c						.byte 5, IM+NN
>d0eb		f6 d0				                .word nt_asm_sbc_z
>d0ed		b4 a6 b9 a6					.word xt_asm_sbc_y, z_asm_sbc_y
>d0f1		73 62 63 2e 79					.text "sbc.y"
.d0f6						nt_asm_sbc_z:
>d0f6		05 0c						.byte 5, IM+NN
>d0f8		03 d1				                .word nt_asm_sbc_zi
>d0fa		b9 a6 be a6					.word xt_asm_sbc_z, z_asm_sbc_z
>d0fe		73 62 63 2e 7a					.text "sbc.z"
.d103						nt_asm_sbc_zi:
>d103		06 0c						.byte 6, IM+NN
>d105		11 d1				                .word nt_asm_sbc_ziy
>d107		be a6 c3 a6					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d10b		73 62 63 2e 7a 69				.text "sbc.zi"
.d111						nt_asm_sbc_ziy:
>d111		07 0c						.byte 7, IM+NN
>d113		20 d1				                .word nt_asm_sbc_zx
>d115		c3 a6 c8 a6					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d119		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d120						nt_asm_sbc_zx:
>d120		06 0c						.byte 6, IM+NN
>d122		2e d1				                .word nt_asm_sbc_zxi
>d124		c8 a6 cd a6					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d128		73 62 63 2e 7a 78				.text "sbc.zx"
.d12e						nt_asm_sbc_zxi:
>d12e		07 0c						.byte 7, IM+NN
>d130		3d d1				                .word nt_asm_sec
>d132		cd a6 d1 a6					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d136		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d13d						nt_asm_sec:
>d13d		03 0c						.byte 3, IM+NN
>d13f		48 d1				                .word nt_asm_sed
>d141		d1 a6 d5 a6					.word xt_asm_sec, z_asm_sec
>d145		73 65 63					.text "sec"
.d148						nt_asm_sed:
>d148		03 0c						.byte 3, IM+NN
>d14a		53 d1				                .word nt_asm_sei
>d14c		d5 a6 d9 a6					.word xt_asm_sed, z_asm_sed
>d150		73 65 64					.text "sed"
.d153						nt_asm_sei:
>d153		03 0c						.byte 3, IM+NN
>d155		5e d1				                .word nt_asm_sta
>d157		d9 a6 dd a6					.word xt_asm_sei, z_asm_sei
>d15b		73 65 69					.text "sei"
.d15e						nt_asm_sta:
>d15e		03 0c						.byte 3, IM+NN
>d160		69 d1				                .word nt_asm_sta_x
>d162		dd a6 e1 a6					.word xt_asm_sta, z_asm_sta
>d166		73 74 61					.text "sta"
.d169						nt_asm_sta_x:
>d169		05 0c						.byte 5, IM+NN
>d16b		76 d1				                .word nt_asm_sta_y
>d16d		e1 a6 e5 a6					.word xt_asm_sta_x, z_asm_sta_x
>d171		73 74 61 2e 78					.text "sta.x"
.d176						nt_asm_sta_y:
>d176		05 0c						.byte 5, IM+NN
>d178		83 d1				                .word nt_asm_sta_z
>d17a		e5 a6 e9 a6					.word xt_asm_sta_y, z_asm_sta_y
>d17e		73 74 61 2e 79					.text "sta.y"
.d183						nt_asm_sta_z:
>d183		05 0c						.byte 5, IM+NN
>d185		90 d1				                .word nt_asm_sta_zi
>d187		e9 a6 ed a6					.word xt_asm_sta_z, z_asm_sta_z
>d18b		73 74 61 2e 7a					.text "sta.z"
.d190						nt_asm_sta_zi:
>d190		06 0c						.byte 6, IM+NN
>d192		9e d1				                .word nt_asm_sta_ziy
>d194		ed a6 f1 a6					.word xt_asm_sta_zi, z_asm_sta_zi
>d198		73 74 61 2e 7a 69				.text "sta.zi"
.d19e						nt_asm_sta_ziy:
>d19e		07 0c						.byte 7, IM+NN
>d1a0		ad d1				                .word nt_asm_sta_zx
>d1a2		f1 a6 f5 a6					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d1a6		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d1ad						nt_asm_sta_zx:
>d1ad		06 0c						.byte 6, IM+NN
>d1af		bb d1				                .word nt_asm_sta_zxi
>d1b1		f5 a6 f9 a6					.word xt_asm_sta_zx, z_asm_sta_zx
>d1b5		73 74 61 2e 7a 78				.text "sta.zx"
.d1bb						nt_asm_sta_zxi:
>d1bb		07 0c						.byte 7, IM+NN
>d1bd		ca d1				                .word nt_asm_stx
>d1bf		f9 a6 fd a6					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d1c3		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d1ca						nt_asm_stx:
>d1ca		03 0c						.byte 3, IM+NN
>d1cc		d5 d1				                .word nt_asm_stx_z
>d1ce		fd a6 01 a7					.word xt_asm_stx, z_asm_stx
>d1d2		73 74 78					.text "stx"
.d1d5						nt_asm_stx_z:
>d1d5		05 0c						.byte 5, IM+NN
>d1d7		e2 d1				                .word nt_asm_stx_zy
>d1d9		01 a7 05 a7					.word xt_asm_stx_z, z_asm_stx_z
>d1dd		73 74 78 2e 7a					.text "stx.z"
.d1e2						nt_asm_stx_zy:
>d1e2		06 0c						.byte 6, IM+NN
>d1e4		f0 d1				                .word nt_asm_sty
>d1e6		05 a7 09 a7					.word xt_asm_stx_zy, z_asm_stx_zy
>d1ea		73 74 78 2e 7a 79				.text "stx.zy"
.d1f0						nt_asm_sty:
>d1f0		03 0c						.byte 3, IM+NN
>d1f2		fb d1				                .word nt_asm_sty_z
>d1f4		09 a7 0d a7					.word xt_asm_sty, z_asm_sty
>d1f8		73 74 79					.text "sty"
.d1fb						nt_asm_sty_z:
>d1fb		05 0c						.byte 5, IM+NN
>d1fd		08 d2				                .word nt_asm_sty_zx
>d1ff		0d a7 11 a7					.word xt_asm_sty_z, z_asm_sty_z
>d203		73 74 79 2e 7a					.text "sty.z"
.d208						nt_asm_sty_zx:
>d208		06 0c						.byte 6, IM+NN
>d20a		16 d2				                .word nt_asm_stz
>d20c		11 a7 15 a7					.word xt_asm_sty_zx, z_asm_sty_zx
>d210		73 74 79 2e 7a 78				.text "sty.zx"
.d216						nt_asm_stz:
>d216		03 0c						.byte 3, IM+NN
>d218		21 d2				                .word nt_asm_stz_x
>d21a		15 a7 19 a7					.word xt_asm_stz, z_asm_stz
>d21e		73 74 7a					.text "stz"
.d221						nt_asm_stz_x:
>d221		05 0c						.byte 5, IM+NN
>d223		2e d2				                .word nt_asm_stz_z
>d225		19 a7 1d a7					.word xt_asm_stz_x, z_asm_stz_x
>d229		73 74 7a 2e 78					.text "stz.x"
.d22e						nt_asm_stz_z:
>d22e		05 0c						.byte 5, IM+NN
>d230		3b d2				                .word nt_asm_stz_zx
>d232		1d a7 21 a7					.word xt_asm_stz_z, z_asm_stz_z
>d236		73 74 7a 2e 7a					.text "stz.z"
.d23b						nt_asm_stz_zx:
>d23b		06 0c						.byte 6, IM+NN
>d23d		49 d2				                .word nt_asm_tax
>d23f		21 a7 25 a7					.word xt_asm_stz_zx, z_asm_stz_zx
>d243		73 74 7a 2e 7a 78				.text "stz.zx"
.d249						nt_asm_tax:
>d249		03 0c						.byte 3, IM+NN
>d24b		54 d2				                .word nt_asm_tay
>d24d		25 a7 29 a7					.word xt_asm_tax, z_asm_tax
>d251		74 61 78					.text "tax"
.d254						nt_asm_tay:
>d254		03 0c						.byte 3, IM+NN
>d256		5f d2				                .word nt_asm_trb
>d258		29 a7 2d a7					.word xt_asm_tay, z_asm_tay
>d25c		74 61 79					.text "tay"
.d25f						nt_asm_trb:
>d25f		03 0c						.byte 3, IM+NN
>d261		6a d2				                .word nt_asm_trb_z
>d263		2d a7 31 a7					.word xt_asm_trb, z_asm_trb
>d267		74 72 62					.text "trb"
.d26a						nt_asm_trb_z:
>d26a		05 0c						.byte 5, IM+NN
>d26c		77 d2				                .word nt_asm_tsb
>d26e		31 a7 35 a7					.word xt_asm_trb_z, z_asm_trb_z
>d272		74 72 62 2e 7a					.text "trb.z"
.d277						nt_asm_tsb:
>d277		03 0c						.byte 3, IM+NN
>d279		82 d2				                .word nt_asm_tsb_z
>d27b		35 a7 39 a7					.word xt_asm_tsb, z_asm_tsb
>d27f		74 73 62					.text "tsb"
.d282						nt_asm_tsb_z:
>d282		05 0c						.byte 5, IM+NN
>d284		8f d2				                .word nt_asm_tsx
>d286		39 a7 3d a7					.word xt_asm_tsb_z, z_asm_tsb_z
>d28a		74 73 62 2e 7a					.text "tsb.z"
.d28f						nt_asm_tsx:
>d28f		03 0c						.byte 3, IM+NN
>d291		9a d2				                .word nt_asm_txa
>d293		3d a7 41 a7					.word xt_asm_tsx, z_asm_tsx
>d297		74 73 78					.text "tsx"
.d29a						nt_asm_txa:
>d29a		03 0c						.byte 3, IM+NN
>d29c		a5 d2				                .word nt_asm_txs
>d29e		41 a7 45 a7					.word xt_asm_txa, z_asm_txa
>d2a2		74 78 61					.text "txa"
.d2a5						nt_asm_txs:
>d2a5		03 0c						.byte 3, IM+NN
>d2a7		b0 d2				                .word nt_asm_tya
>d2a9		45 a7 49 a7					.word xt_asm_txs, z_asm_txs
>d2ad		74 78 73					.text "txs"
.d2b0						nt_asm_tya:
>d2b0		03 0c						.byte 3, IM+NN
>d2b2		bb d2				                .word nt_asm_arrow
>d2b4		49 a7 4d a7					.word xt_asm_tya, z_asm_tya
>d2b8		74 79 61					.text "tya"
.d2bb						nt_asm_arrow:
>d2bb		03 04				                .byte 3, IM
>d2bd		c6 d2				                .word nt_asm_back_jump
>d2bf		1a 89 24 89			                .word xt_asm_arrow, z_asm_arrow
>d2c3		2d 2d 3e			                .text "-->"
.d2c6						nt_asm_back_jump:
>d2c6		02 04				                .byte 2, IM
>d2c8		d0 d2				                .word nt_asm_back_branch
>d2ca		9e a7 9e a7			                .word xt_asm_back_jump, z_asm_back_jump
>d2ce		3c 6a				                .text "<j"
.d2d0						nt_asm_back_branch:
>d2d0		02 04				                .byte 2, IM
>d2d2		da d2				                .word nt_asm_push_a
>d2d4		9f a7 a7 a7			                .word xt_asm_back_branch, z_asm_back_branch
>d2d8		3c 62				                .text "<b"
.d2da						nt_asm_push_a:
>d2da		06 0c				                .byte 6, IM+NN
>d2dc		00 00				                .word 0000
>d2de		87 a7 96 a7			                .word xt_asm_push_a, z_asm_push_a
>d2e2		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix         ; unused?
=1						ix += 1
=1						str_compile        = ix         ; unused?
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix         ; unused?
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_sdc     = ix
=13						ix += 1
=13						str_disasm_lit     = ix
=14						ix += 1
=14						str_disasm_0bra    = ix
=15						ix += 1
=15						str_disasm_loop    = ix
=16						ix += 1
=16						str_disasm_do      = ix
=17						ix += 1
.d2e8						string_table:
>d2e8		0a d3 0e d3 18 d3 23 d3		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d2f0		5a d3 52 d3 47 d3 61 d3		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d2f8		67 d3 83 d3 88 d3 8d d3		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d300		9e d3 b1 d3 ba d3 c3 d3		        .word s_disasm_sdc, s_disasm_lit, s_disasm_0bra, s_disasm_loop, s_disasm_do ; 12-16
>d308		c9 d3
>d30a		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d30e		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d316		64 00
>d318		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d320		64 20 00
>d323		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d32b		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d33b		4f 50 51 52 53 54 55 56 57 58 59 5a
>d347		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d34f		72 20 00
>d352		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d35a		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d361		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d367		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d36f		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d37f		29 3a 20 00
>d383		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d388		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d38d		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d395		63 69 6d 61 6c 29 3a 20 00
>d39e		20 53 54 41 43 4b 20 44		s_disasm_sdc: .text " STACK DEPTH CHECK", 0
>d3a6		45 50 54 48 20 43 48 45 43 4b 00
>d3b1		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d3b9		00
>d3ba		30 42 52 41 4e 43 48 20		s_disasm_0bra: .text "0BRANCH ",0
>d3c2		00
>d3c3		4c 4f 4f 50 20 00		s_disasm_loop: .text "LOOP ",0
>d3c9		44 4f 20 00			s_disasm_do: .text "DO ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d3cd						error_table:
>d3cd		e9 d3 0a d4 2a d4 4b d4		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d3d5		68 d4 79 d4 89 d4 b7 d4		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d3dd		cf d4 f0 d4 05 d5 21 d5		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d3e5		38 d5 77 d5			        .word es_blockwords, es_returnstack                     ; 12-13
>d3e9		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d3f1		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d401		65 20 6d 65 6d 6f 72 79 00
>d40a		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d412		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d422		20 52 45 46 49 4c 4c 00
>d42a		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d432		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d442		6e 6c 79 20 77 6f 72 64 00
>d44b		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d453		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d463		20 79 65 74 00
>d468		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d470		20 62 79 20 7a 65 72 6f 00
>d479		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d481		66 61 69 6c 75 72 65 00
>d489		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d491		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d4a1		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d4b1		64 20 2d 31 29 00
>d4b7		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d4bf		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d4cf		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d4d7		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d4e7		64 20 6e 75 6d 62 65 72 00
>d4f0		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d4f8		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d505		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d50d		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d51d		4c 4f 54 00
>d521		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d529		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d538		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d540		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d550		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d560		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d570		56 45 43 54 4f 52 00
>d577		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d57f		74 61 63 6b 3a 00
>d585		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d58d		44 2d 53 54 52 49 4e 47
>d595		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d59b		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d5a0		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d5a8		2d 55 4e 49 54 2d 42 49 54 53
>d5b2		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d5ba		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d5c2		52
>d5c3		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d5c9		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d5cf		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d5d7		53 54 41 43 4b 2d 43 45 4c 4c 53
>d5e2		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d5ea		45 4c 4c 53
>d5ee		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d5f6		54 53
>d5f8		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d5fe		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d605						doconst:
.d605		ca		dex		                dex             ; make room for constant
.d606		ca		dex		                dex
.d607		68		pla		                pla             ; LSB of return address
.d608		85 25		sta $25		                sta tmp1
.d60a		68		pla		                pla             ; MSB of return address
.d60b		85 26		sta $26		                sta tmp1+1
.d60d		a0 01		ldy #$01	                ldy #1
.d60f		b1 25		lda ($25),y	                lda (tmp1),y
.d611		95 00		sta $00,x	                sta 0,x
.d613		c8		iny		                iny
.d614		b1 25		lda ($25),y	                lda (tmp1),y
.d616		95 01		sta $01,x	                sta 1,x
.d618		60		rts		                rts
.d619						dodefer:
.d619		68		pla		                pla             ; LSB
.d61a		85 25		sta $25		                sta tmp1
.d61c		68		pla		                pla             ; MSB
.d61d		85 26		sta $26		                sta tmp1+1
.d61f		a0 01		ldy #$01	                ldy #1
.d621		b1 25		lda ($25),y	                lda (tmp1),y
.d623		85 27		sta $27		                sta tmp2
.d625		c8		iny		                iny
.d626		b1 25		lda ($25),y	                lda (tmp1),y
.d628		85 28		sta $28		                sta tmp2+1
.d62a		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d62d						defer_error:
.d62d		a9 03		lda #$03	                lda #err_defer
.d62f		4c b3 d7	jmp $d7b3	                jmp error
.d632						dodoes:
.d632		7a		ply		                ply             ; LSB
.d633		68		pla		                pla             ; MSB
.d634		c8		iny		                iny
.d635		d0 01		bne $d638	                bne +
.d637		1a		inc a		                ina
.d638						+
.d638		84 27		sty $27		                sty tmp2
.d63a		85 28		sta $28		                sta tmp2+1
.d63c		ca		dex		                dex
.d63d		ca		dex		                dex
.d63e		7a		ply		                ply
.d63f		68		pla		                pla
.d640		c8		iny		                iny
.d641		d0 01		bne $d644	                bne +
.d643		1a		inc a		                ina
.d644						+
.d644		94 00		sty $00,x	                sty 0,x         ; LSB
.d646		95 01		sta $01,x	                sta 1,x         ; MSB
.d648		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d64b						dovar:
.d64b		7a		ply		                ply             ; LSB
.d64c		68		pla		                pla             ; MSB
.d64d		c8		iny		                iny
.d64e		d0 01		bne $d651	                bne +
.d650		1a		inc a		                ina
.d651						+
.d651		ca		dex		                dex
.d652		ca		dex		                dex
.d653		95 01		sta $01,x	                sta 1,x
.d655		98		tya		                tya
.d656		95 00		sta $00,x	                sta 0,x
.d658		60		rts		                rts
.d659						push_upvar_tos:
.d659		ca		dex		                dex
.d65a		ca		dex		                dex
.d65b		18		clc		                clc
.d65c		65 08		adc $08		                adc up
.d65e		95 00		sta $00,x	                sta 0,x
.d660		a5 09		lda $09		                lda up+1
.d662		90 01		bcc $d665	                bcc +
.d664		1a		inc a		                ina
.d665						+
.d665		95 01		sta $01,x	                sta 1,x
.d667		60		rts		                rts
.d668						byte_to_ascii:
.d668		48		pha		                pha
.d669		4a		lsr a		                lsr             ; convert high nibble first
.d66a		4a		lsr a		                lsr
.d66b		4a		lsr a		                lsr
.d66c		4a		lsr a		                lsr
.d66d		20 71 d6	jsr $d671	                jsr _nibble_to_ascii
.d670		68		pla		                pla
.d671						_nibble_to_ascii:
.d671		29 0f		and #$0f	                and #$F
.d673		09 30		ora #$30	                ora #'0'
.d675		c9 3a		cmp #$3a	                cmp #'9'+1
.d677		90 02		bcc $d67b	                bcc +
.d679		69 06		adc #$06	                adc #6
.d67b		4c c4 86	jmp $86c4	+               jmp emit_a
.d67e		60		rts		                rts
.d67f						find_header_name:
.d67f		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d681		85 27		sta $27		                sta tmp2
.d683		b5 03		lda $03,x	                lda 3,x
.d685		85 28		sta $28		                sta tmp2+1
.d687						_loop:
.d687		b2 25		lda ($25)	                lda (tmp1)
.d689		d5 00		cmp $00,x	                cmp 0,x
.d68b		d0 3a		bne $d6c7	                bne _next_entry
.d68d		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d68f		a0 08		ldy #$08	                ldy #8
.d691		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d693		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d695		d0 30		bne $d6c7	                bne _next_entry ; definitely not equal if any bits differ
.d697		a5 25		lda $25		                lda tmp1
.d699		48		pha		                pha             ; Save original address on the stack
.d69a		18		clc		                clc
.d69b		69 08		adc #$08	                adc #8
.d69d		85 25		sta $25		                sta tmp1
.d69f		a5 26		lda $26		                lda tmp1+1
.d6a1		48		pha		                pha
.d6a2		90 03		bcc $d6a7	                bcc +
.d6a4		1a		inc a		                ina
.d6a5		85 26		sta $26		                sta tmp1+1
.d6a7						+
.d6a7		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d6a9		88		dey		                dey
.d6aa						_next_char:
.d6aa		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d6ac		c9 5b		cmp #$5b	                cmp #'Z'+1
.d6ae		b0 06		bcs $d6b6	                bcs _check_char
.d6b0		c9 41		cmp #$41	                cmp #'A'
.d6b2		90 02		bcc $d6b6	                bcc _check_char
.d6b4		09 20		ora #$20	                ora #$20
.d6b6						_check_char:
.d6b6		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d6b8		d0 03		bne $d6bd	                bne _reset_tmp1
.d6ba		88		dey		                dey
.d6bb		10 ed		bpl $d6aa	                bpl _next_char
.d6bd						_reset_tmp1:
.d6bd		68		pla		                pla
.d6be		85 26		sta $26		                sta tmp1+1
.d6c0		68		pla		                pla
.d6c1		85 25		sta $25		                sta tmp1
.d6c3		98		tya		                tya             ; leave A = $FF on success
.d6c4		c8		iny		                iny             ; if Y was $FF, we succeeded
.d6c5		f0 11		beq $d6d8	                beq _done
.d6c7						_next_entry:
.d6c7		a0 02		ldy #$02	                ldy #2
.d6c9		b1 25		lda ($25),y	                lda (tmp1),y
.d6cb		48		pha		                pha
.d6cc		c8		iny		                iny
.d6cd		b1 25		lda ($25),y	                lda (tmp1),y
.d6cf		85 26		sta $26		                sta tmp1+1
.d6d1		68		pla		                pla
.d6d2		85 25		sta $25		                sta tmp1
.d6d4		05 26		ora $26		                ora tmp1+1
.d6d6		d0 af		bne $d687	                bne _loop
.d6d8		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d6da		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d6db						compare_16bit:
.d6db		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d6dd		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d6df		f0 08		beq $d6e9	                beq _equal
.d6e1		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6e3		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6e5		70 08		bvs $d6ef	                bvs _overflow
.d6e7		80 08		bra $d6f1	                bra _not_equal
.d6e9						_equal:
.d6e9		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6eb		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6ed		50 04		bvc $d6f3	                bvc _done
.d6ef						_overflow:
.d6ef		49 80		eor #$80	                eor #$80                ; complement negative flag
.d6f1						_not_equal:
.d6f1		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d6f3						_done:
.d6f3		60		rts		                rts
.d6f4						current_to_dp:
.d6f4		a0 08		ldy #$08	                ldy #current_offset
.d6f6		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6f8		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6f9		18		clc		                clc
.d6fa		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6fc		a8		tay		                tay
.d6fd		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d6ff		85 02		sta $02		                sta dp
.d701		c8		iny		                iny
.d702		b1 08		lda ($08),y	                lda (up),y
.d704		85 03		sta $03		                sta dp+1
.d706		60		rts		                rts
.d707						dp_to_current:
.d707		a0 08		ldy #$08	                ldy #current_offset
.d709		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d70b		0a		asl a		                asl             ; turn it into an offset (in cells)
.d70c		18		clc		                clc
.d70d		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d70f		a8		tay		                tay
.d710		a5 02		lda $02		                lda dp
.d712		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d714		c8		iny		                iny
.d715		a5 03		lda $03		                lda dp+1
.d717		91 08		sta ($08),y	                sta (up),y
.d719		60		rts		                rts
.d71a						interpret:
.d71a						_loop:
.d71a		20 49 8d	jsr $8d49	                jsr xt_parse_name       ; ( "string" -- addr u )
.d71d		b5 00		lda $00,x	                lda 0,x
.d71f		15 01		ora $01,x	                ora 1,x
.d721		f0 5b		beq $d77e	                beq _line_done
.d723		20 bf 93	jsr $93bf	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d726		20 03 9b	jsr $9b03	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d729		b5 00		lda $00,x	                lda 0,x
.d72b		15 01		ora $01,x	                ora 1,x
.d72d		d0 19		bne $d748	                bne _got_name_token
.d72f		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d730		e8		inx		                inx
.d731		20 a4 9c	jsr $9ca4	                jsr xt_number           ; ( addr u -- u|d )
.d734		a5 1a		lda $1a		                lda state
.d736		f0 e2		beq $d71a	                beq _loop
.d738		a9 20		lda #$20	                lda #%00100000
.d73a		24 1c		bit $1c		                bit status
.d73c		d0 05		bne $d743	                bne _double_number
.d73e		20 f1 89	jsr $89f1	                jsr xt_literal
.d741		80 d7		bra $d71a	                bra _loop
.d743						_double_number:
.d743		20 fc 9e	jsr $9efc	                jsr xt_two_literal
.d746		80 d2		bra $d71a	                bra _loop
.d748						_got_name_token:
.d748		b5 00		lda $00,x	                lda 0,x
.d74a		95 04		sta $04,x	                sta 4,x
.d74c		b5 01		lda $01,x	                lda 1,x
.d74e		95 05		sta $05,x	                sta 5,x
.d750		e8		inx		                inx
.d751		e8		inx		                inx
.d752		e8		inx		                inx
.d753		e8		inx		                inx                     ; ( nt )
.d754		20 e1 8c	jsr $8ce1	                jsr xt_one_plus
.d757		a1 00		lda ($00,x)	                lda (0,x)
.d759		48		pha		                pha
.d75a		20 d5 8c	jsr $8cd5	                jsr xt_one_minus
.d75d		20 41 9c	jsr $9c41	                jsr xt_name_to_int      ; ( nt - xt )
.d760		a5 1a		lda $1a		                lda state
.d762		d0 10		bne $d774	                bne _compile
.d764		68		pla		                pla
.d765		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d767		f0 05		beq $d76e	                beq _interpret
.d769		a9 02		lda #$02	                lda #err_compileonly
.d76b		4c b3 d7	jmp $d7b3	                jmp error
.d76e						_interpret:
.d76e		20 04 88	jsr $8804	                jsr xt_execute
.d771		4c 1a d7	jmp $d71a	                jmp _loop
.d774						_compile:
.d774		68		pla		                pla
.d775		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d777		d0 f5		bne $d76e	                bne _interpret          ; IMMEDIATE word, execute right now
.d779		20 cc 96	jsr $96cc	                jsr xt_compile_comma
.d77c		80 9c		bra $d71a	                bra _loop
.d77e						_line_done:
.d77e		e8		inx		                inx
.d77f		e8		inx		                inx
.d780		e8		inx		                inx
.d781		e8		inx		                inx
.d782		60		rts		                rts
.d783						is_printable:
.d783		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d785		90 08		bcc $d78f	                bcc _done
.d787		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d789		b0 03		bcs $d78e	                bcs _failed
.d78b		38		sec		                sec
.d78c		80 01		bra $d78f	                bra _done
.d78e						_failed:
.d78e		18		clc		                clc
.d78f						_done:
.d78f		60		rts		                rts
.d790						is_whitespace:
.d790		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d792		90 08		bcc $d79c	                bcc _done
.d794		c9 21		cmp #$21	                cmp #AscSP+1
.d796		b0 03		bcs $d79b	                bcs _failed
.d798		38		sec		                sec
.d799		80 01		bra $d79c	                bra _done
.d79b						_failed:
.d79b		18		clc		                clc
.d79c						_done:
.d79c		60		rts		                rts
.d79d						underflow_1:
.d79d		e0 77		cpx #$77	                cpx #dsp0-1
.d79f		10 10		bpl $d7b1	                bpl underflow_error
.d7a1		60		rts		                rts
.d7a2						underflow_2:
.d7a2		e0 75		cpx #$75	                cpx #dsp0-3
.d7a4		10 0b		bpl $d7b1	                bpl underflow_error
.d7a6		60		rts		                rts
.d7a7						underflow_3:
.d7a7		e0 73		cpx #$73	                cpx #dsp0-5
.d7a9		10 06		bpl $d7b1	                bpl underflow_error
.d7ab		60		rts		                rts
.d7ac						underflow_4:
.d7ac		e0 71		cpx #$71	                cpx #dsp0-7
.d7ae		10 01		bpl $d7b1	                bpl underflow_error
.d7b0		60		rts		                rts
.d7b1						underflow_error:
.d7b1		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d7b3						error:
.d7b3		48		pha		                pha                     ; save error
.d7b4		20 f3 d7	jsr $d7f3	                jsr print_error
.d7b7		20 3c 84	jsr $843c	                jsr xt_cr
.d7ba		68		pla		                pla
.d7bb		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d7bd		d0 17		bne $d7d6	                bne _no_underflow
.d7bf		a9 0d		lda #$0d	                lda #err_returnstack
.d7c1		20 f3 d7	jsr $d7f3	                jsr print_error
.d7c4		ba		tsx		                tsx
.d7c5						-
.d7c5		e8		inx		                inx
.d7c6		f0 0b		beq $d7d3	                beq +
.d7c8		20 bd 91	jsr $91bd	                jsr xt_space
.d7cb		bd 00 01	lda $0100,x	                lda $100,x
.d7ce		20 68 d6	jsr $d668	                jsr byte_to_ascii
.d7d1		80 f2		bra $d7c5	                bra -
.d7d3						+
.d7d3		20 3c 84	jsr $843c	                jsr xt_cr
.d7d6						_no_underflow:
.d7d6		4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d7d9						print_string_no_lf:
.d7d9		0a		asl a		                asl
.d7da		a8		tay		                tay
.d7db		b9 e8 d2	lda $d2e8,y	                lda string_table,y
.d7de		85 29		sta $29		                sta tmp3                ; LSB
.d7e0		c8		iny		                iny
.d7e1		b9 e8 d2	lda $d2e8,y	                lda string_table,y
.d7e4		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7e6						print_common:
.d7e6		a0 00		ldy #$00	                ldy #0
.d7e8						_loop:
.d7e8		b1 29		lda ($29),y	                lda (tmp3),y
.d7ea		f0 06		beq $d7f2	                beq _done               ; strings are zero-terminated
.d7ec		20 c4 86	jsr $86c4	                jsr emit_a              ; allows vectoring via output
.d7ef		c8		iny		                iny
.d7f0		80 f6		bra $d7e8	                bra _loop
.d7f2						_done:
.d7f2		60		rts		                rts
.d7f3						print_error:
.d7f3		0a		asl a		                asl
.d7f4		a8		tay		                tay
.d7f5		b9 cd d3	lda $d3cd,y	                lda error_table,y
.d7f8		85 29		sta $29		                sta tmp3                ; LSB
.d7fa		c8		iny		                iny
.d7fb		b9 cd d3	lda $d3cd,y	                lda error_table,y
.d7fe		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d800		20 e6 d7	jsr $d7e6	                jsr print_common
.d803		60		rts		                rts
.d804						print_string:
.d804		20 d9 d7	jsr $d7d9	                jsr print_string_no_lf
.d807		4c 3c 84	jmp $843c	                jmp xt_cr               ; JSR/RTS because never compiled
.d80a						print_u:
.d80a		20 04 9e	jsr $9e04	                jsr xt_zero                     ; 0
.d80d		20 ce 89	jsr $89ce	                jsr xt_less_number_sign         ; <#
.d810		20 ab 8c	jsr $8cab	                jsr xt_number_sign_s            ; #S
.d813		20 89 8c	jsr $8c89	                jsr xt_number_sign_greater      ; #>
.d816		4c c9 94	jmp $94c9	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm


;******  Processing file: platform/simulator.asm

=$f000						io_start = $f000
>f000						                .byte ?
>f001						io_putc:        .byte ?     ; $f001     write byte to stdout
>f002						                .word ?
>f004						io_getc:        .byte ?     ; $f004     read byte from stdin
>f005						io_peekc:       .byte ?     ; $f005     non-blocking input
>f006						io_clk_start:   .byte ?     ; $f006     *read* to start cycle counter
>f007						io_clk_stop:    .byte ?     ; $f007     *read* to stop the cycle counter
>f008						io_clk_cycles:  .word ?,?   ; $f008-b   32-bit cycle count in NUXI order
>f00c						                .word ?,?
>f010						io_blk_action:  .byte ?     ; $f010     Write to act (status=0 read=1 write=2)
>f011						io_blk_status:  .byte ?     ; $f011     Read action result (OK=0)
>f012						io_blk_number:  .word ?     ; $f012     Little endian block number 0-ffff
>f014						io_blk_buffer:  .word ?     ; $f014     Little endian memory address
.f016						io_end:
.f016						kernel_init:
.f016		78		sei		                sei             ; Disable interrupts
.f017		a2 00		ldx #$00	                ldx #0
.f019		bd 32 f0	lda $f032,x	-               lda s_kernel_id,x
.f01c		f0 06		beq $f024	                beq _done
.f01e		20 2d f0	jsr $f02d	                jsr kernel_putc
.f021		e8		inx		                inx
.f022		80 f5		bra $f019	                bra -
.f024						_done:
.f024		4c 00 80	jmp $8000	                jmp forth
.f027						kernel_getc:
.f027						_loop:
.f027		ad 04 f0	lda $f004	                lda io_getc
.f02a		f0 fb		beq $f027	                beq _loop
.f02c		60		rts		                rts
.f02d						kernel_putc:
.f02d		8d 01 f0	sta $f001	                sta io_putc
.f030		60		rts		                rts
.f031						kernel_bye:
.f031		00		brk #		                brk

;******  Return to file: platform/platform-py65mon.asm

.f032						s_kernel_id:
>f032		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f03a		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f04a		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f05a		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		16 f0				v_nmi   .word kernel_init
>fffc		16 f0				v_reset .word kernel_init
>fffe		16 f0				v_irq   .word kernel_init

;******  End of listing
