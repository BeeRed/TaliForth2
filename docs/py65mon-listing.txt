
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Thu Mar 14 21:15:31 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000					ram_start = $0000          ; start of installed 32 KiB of RAM
=32767					ram_end   = $8000-1        ; end of installed RAM
=$0000					zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f					zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100					stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744					hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000					user0     = zpage            ; TaliForth2 system variables
=$ff					rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff					bsize     = $ff              ; size of input/output buffers
=512					buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768					cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744					cp_end    = hist_buff        ; Last RAM byte available for code
=$ff					padoffset = $ff              ; offset from CP to PAD (holds number strings)
=					TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]
=["lf"]					TALI_OPTION_CR_EOL := [ "lf" ]

;******  Processing file: platform/../taliforth.asm

.8000					code0:

;******  Processing file: platform/../definitions.asm

=0					cp        = user0+0   ; Compiler Pointer
=2					dp        = user0+2   ; Dictionary Pointer
=4					workword  = user0+4   ; nt (not xt!) of word being compiled, except in
=6					insrc     = user0+6   ; input Source for SOURCE-ID
=8					cib       = user0+8   ; address of current input buffer
=10					ciblen    = user0+10  ; length of current input buffer
=12					toin      = user0+12  ; pointer to CIB (>IN in Forth)
=14					ip        = user0+14  ; Instruction Pointer (current xt)
=16					output    = user0+16  ; vector for EMIT
=18					input     = user0+18  ; vector for KEY
=20					havekey   = user0+20  ; vector for KEY?
=22					state     = user0+22  ; STATE: -1 compile, 0 interpret
=24					base      = user0+24  ; number radix, default decimal
=26					nc_limit  = user0+26  ; limit for Native Compile size
=28					uf_strip  = user0+28  ; flag to strip underflow detection code
=30					up        = user0+30  ; User Pointer (Address of user variables)
=32					status    = user0+32  ; internal status information
=34					tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
=36					tmp1      = user0+36  ; temporary storage
=38					tmp2      = user0+38  ; temporary storage
=40					tmp3      = user0+40  ; temporary storage (especially for print)
=42					tmpdsp    = user0+42  ; temporary DSP (X) storage (two bytes)
=44					tmptos    = user0+44  ; temporary TOS storage
=46					editor1   = user0+46  ; temporary for editors
=48					editor2   = user0+48  ; temporary for editors
=50					editor3   = user0+50  ; temporary for editors
=52					tohold    = user0+52  ; pointer for formatted output
=54					scratch   = user0+54  ; 8 byte scratchpad (see UM/MOD)
=120					dsp0      = zpage_end-7    ; initial Data Stack Pointer
=0					blk_offset = 0        ; BLK : UP + 0
=2					scr_offset = 2        ; SCR : UP + 2
=4					current_offset = 4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
=5					num_wordlists_offset = 5
=6					wordlists_offset = 6  ; WORDLISTS (cells) : UP + 6 to UP + 29
=30					num_order_offset = 30 ; #ORDER (byte) : UP + 30
=31					search_order_offset = 31
=12					max_wordlists = 12    ; Maximum number of wordlists supported
=40					blkbuffer_offset    = 40   ; Address of buffer
=42					buffblocknum_offset = 42   ; Block number current in buffer
=44					buffstatus_offset   = 44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
=46					blockread_offset    = 46   ; Vector to block reading routine
=48					blockwrite_offset   = 48   ; Vector to block writing routine
=$03					AscCC   = $03  ; break (CTRL-c)
=$07					AscBELL = $07  ; bell sound
=$08					AscBS   = $08  ; backspace
=$0a					AscLF   = $0a  ; line feed
=$0d					AscCR   = $0d  ; carriage return
=$1b					AscESC  = $1b  ; escape
=$20					AscSP   = $20  ; space
=$7f					AscDEL  = $7f  ; delete (CTRL-h)
=$10					AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e					AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1					CO = 1  ; Compile Only
=2					AN = 2  ; Always Native Compile
=4					IM = 4  ; Immediate Word
=8					NN = 8  ; Never Native Compile
=16					UF = 16 ; Includes Underflow Check (RESERVED)
=32					HC = 32 ; Word has Code Field Area (CFA)
=79					MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm

.8000					forth:

;******  Processing file: platform/../native_words.asm

.8000					xt_cold:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 10		sta $10		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 11		sta $11		                sta output+1
.8009	a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b					_load_zp_loop:
.800b	bd ad 80	lda $80ad,x	                lda cold_zp_table,x
.800e	95 00		sta $00,x	                sta zpage,x
.8010	ca		dex		                dex
.8011	d0 f8		bne $800b	                bne _load_zp_loop
.8013	ad ad 80	lda $80ad	                lda cold_zp_table
.8016	85 00		sta $00		                sta zpage
.8018	a2 ff		ldx #$ff	                ldx #rsp0
.801a	9a		txs		                txs
.801b	a2 78		ldx #$78	                ldx #dsp0
.801d	a0 33		ldy #$33	                ldy #cold_user_table_end-cold_user_table-1
.801f	a9 00		lda #$00	                lda #0
.8021					_load_user_vars_loop:
.8021	b9 cf 80	lda $80cf,y	                lda cold_user_table,y
.8024	91 1e		sta ($1e),y	                sta (up),y
.8026	88		dey		                dey
.8027	d0 f8		bne $8021	                bne _load_user_vars_loop
.8029	ad cf 80	lda $80cf	                lda cold_user_table
.802c	92 1e		sta ($1e)	                sta (up)
.802e	20 6f 89	jsr $896f	                jsr xt_cr
.8031	ca		dex		                dex
.8032	ca		dex		                dex
.8033	ca		dex		                dex
.8034	ca		dex		                dex
.8035	a9 7d		lda #$7d	                lda #<forth_words_start
.8037	95 02		sta $02,x	                sta 2,x
.8039	a9 bb		lda #$bb	                lda #>forth_words_start
.803b	95 03		sta $03,x	                sta 3,x
.803d	a9 d3		lda #$d3	                lda #<(user_words_end-forth_words_start)
.803f	95 00		sta $00,x	                sta 0,x
.8041	a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043	95 01		sta $01,x	                sta 1,x
.8045	20 e1 90	jsr $90e1	                jsr xt_evaluate
.8048	9c 00 7c	stz $7c00	                stz hist_buff
.804b	9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e	9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051	9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054	9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057	9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a	9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d	9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060					xt_abort:
.8060	a2 78		ldx #$78	                ldx #dsp0
.8062					xt_quit:
.8062	8a		txa		                txa             ; Save the DSP that we just defined
.8063	a2 ff		ldx #$ff	                ldx #rsp0
.8065	9a		txs		                txs
.8066	aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067	64 0e		stz $0e		                stz ip
.8069	64 0f		stz $0f		                stz ip+1
.806b	64 06		stz $06		                stz insrc
.806d	64 07		stz $07		                stz insrc+1
.806f	a9 00		lda #$00	                lda #0
.8071	a0 00		ldy #$00	                ldy #blk_offset
.8073	91 1e		sta ($1e),y	                sta (up),y
.8075	c8		iny		                iny
.8076	91 1e		sta ($1e),y	                sta (up),y
.8078	64 16		stz $16		                stz state
.807a	64 17		stz $17		                stz state+1
.807c					_get_line:
.807c	a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.807e	85 08		sta $08		                sta cib
.8080	a9 02		lda #$02	                lda #>buffer0
.8082	85 09		sta $09		                sta cib+1
.8084	64 0a		stz $0a		                stz ciblen
.8086	64 0b		stz $0b		                stz ciblen+1
.8088	20 04 9b	jsr $9b04	                jsr xt_refill           ; ( -- f )
.808b	b5 00		lda $00,x	                lda 0,x
.808d	d0 05		bne $8094	                bne _success
.808f	a9 06		lda #$06	                lda #err_refill
.8091	4c 66 d8	jmp $d866	                jmp error
.8094					_success:
.8094	e8		inx		                inx                     ; drop
.8095	e8		inx		                inx
.8096	20 b8 d7	jsr $d7b8	                jsr interpret
.8099	e0 78		cpx #$78	                cpx #dsp0
.809b	f0 05		beq $80a2	                beq _stack_ok
.809d	90 03		bcc $80a2	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.809f	4c 64 d8	jmp $d864	                jmp underflow_error
.80a2					_stack_ok:
.80a2	a5 16		lda $16		                lda state
.80a4	f0 02		beq $80a8	                beq _print
.80a6	a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80a8					_print:
.80a8	20 b7 d8	jsr $d8b7	                jsr print_string
.80ab	80 cf		bra $807c	                bra _get_line
.80ad					z_cold:
.80ad					z_abort:
.80ad					z_quit:
.80ad					cold_zp_table:
>80ad	00 08				        .word cp0+256+1024      ; cp moved to make room for user vars and
>80af	50 bc				        .word dictionary_start  ; dp
>80b1	00 00				        .word 0                 ; workword
>80b3	00 00				        .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
>80b5	00 02				        .word buffer0           ; cib
>80b7	00 00				        .word 0                 ; ciblen
>80b9	00 00				        .word 0                 ; toin
>80bb	00 00				        .word 0                 ; ip
>80bd	27 f0				        .word kernel_putc       ; output
>80bf	21 f0				        .word kernel_getc       ; input
>80c1	00 00				        .word 0                 ; havekey
>80c3	00 00				        .word 0                 ; state (0 = interpret)
>80c5	0a 00				        .word 10                ; base
>80c7	14 00				        .word 20                ; nc-limit
>80c9	00 00				        .word 0                 ; uf_strip (off by default)
>80cb	00 03				        .word cp0               ; up (user vars put right at beginning of
>80cd	00 00				        .word 0                 ; status
.80cf					cold_zp_table_end:
.80cf					cold_user_table:
>80cf	00 00				        .word 0                         ;  0 BLK
>80d1	00 00				        .word 0                         ;  2 SCR
>80d3	00				        .byte 0                         ;  4 CURRENT = FORTH-WORDLIST
>80d4	04				        .byte 4                         ;  5 #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>80d5	50 bc				        .word dictionary_start          ;  6 FORTH-WORDLIST
>80d7	98 ca				        .word editor_dictionary_start   ;  8 EDITOR-WORDLIST
>80d9	e8 ca				        .word assembler_dictionary_start ; a ASSEMBLER-WORDLIST
>80db	57 ca				        .word root_dictionary_start     ;  c ROOT-WORDLIST
>80dd	00 00 00 00 00 00 00 00		        .word 0,0,0,0,0,0,0,0           ;  e User wordlists
>80e5	00 00 00 00 00 00 00 00
>80ed	01				        .byte 1                         ; 1e #ORDER
>80ee	00 00 00 00 00 00 00 00		        .byte 0,0,0,0,0,0,0,0,0         ; 1f search-order
>80f6	00
>80f7	00 04				        .word cp0+256                   ; 28 Address of buffer (right after USER vars)
>80f9	00 00				        .word 0                         ; 2a block in buffer
>80fb	00 00				        .word 0                         ; 2c buffer status (not in use)
>80fd	67 85				        .word xt_block_word_error       ; 2e block-read vector
>80ff	67 85				        .word xt_block_word_error       ; 30 block-write vector
>8101	00 00				        .word 0                         ; 32 'COLD
.8103					cold_user_table_end:
.8103					xt_abort_quote:
.8103	20 5b 9d	jsr $9d5b	                jsr xt_s_quote          ; S"
.8106	a0 81		ldy #$81	                ldy #>abort_quote_runtime
.8108	a9 0e		lda #$0e	                lda #<abort_quote_runtime
.810a	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.810d	60		rts		z_abort_quote:  rts
.810e					abort_quote_runtime:
.810e	b5 04		lda $04,x	                lda 4,x
.8110	15 05		ora $05,x	                ora 5,x
.8112	f0 09		beq $811d	                beq _done       ; if FALSE, we're done
.8114	20 0f a5	jsr $a50f	                jsr xt_type
.8117	20 6f 89	jsr $896f	                jsr xt_cr
.811a	4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.811d					_done:
.811d	8a		txa		                txa
.811e	18		clc		                clc
.811f	69 06		adc #$06	                adc #6
.8121	aa		tax		                tax
.8122	60		rts		                rts
.8123					xt_abs:
.8123	20 50 d8	jsr $d850	                jsr underflow_1
.8126	b5 01		lda $01,x	                lda 1,x
.8128	10 0d		bpl $8137	                bpl _done       ; positive number, easy money!
.812a	38		sec		                sec
.812b	a9 00		lda #$00	                lda #0
.812d	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.812f	95 00		sta $00,x	                sta 0,x
.8131	a9 00		lda #$00	                lda #0          ; MSB
.8133	f5 01		sbc $01,x	                sbc 1,x
.8135	95 01		sta $01,x	                sta 1,x
.8137					_done:
.8137	60		rts		z_abs:          rts
.8138					xt_accept:
.8138	20 55 d8	jsr $d855	                jsr underflow_2
.813b	b5 00		lda $00,x	                lda 0,x
.813d	15 01		ora $01,x	                ora 1,x
.813f	d0 09		bne $814a	                bne _not_zero
.8141	e8		inx		                inx
.8142	e8		inx		                inx
.8143	74 00		stz $00,x	                stz 0,x
.8145	74 01		stz $01,x	                stz 1,x
.8147	4c 16 82	jmp $8216	                jmp accept_done
.814a					_not_zero:
.814a	b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.814c	85 26		sta $26		                sta tmp2
.814e	64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.8150	b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8152	85 24		sta $24		                sta tmp1
.8154	b5 03		lda $03,x	                lda 3,x
.8156	85 25		sta $25		                sta tmp1+1
.8158	e8		inx		                inx
.8159	e8		inx		                inx
.815a	a0 00		ldy #$00	                ldy #0
.815c	a5 20		lda $20		                lda status
.815e	29 f7		and #$f7	                and #$f7
.8160	1a		inc a		               ina
.8161	09 08		ora #$08	                ora #$08
.8163	85 20		sta $20		                sta status
.8165					accept_loop:
.8165	20 44 93	jsr $9344	                jsr key_a
.8168	c9 0a		cmp #$0a	                cmp #AscLF
.816a	f0 20		beq $818c	                beq _eol
.816c	c9 0d		cmp #$0d	                cmp #AscCR
.816e	f0 1c		beq $818c	                beq _eol
.8170	c9 08		cmp #$08	                cmp #AscBS
.8172	f0 22		beq $8196	                beq _backspace
.8174	c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8176	f0 1e		beq $8196	                beq _backspace
.8178	c9 10		cmp #$10	                cmp #AscCP
.817a	f0 36		beq $81b2	                beq _ctrl_p
.817c	c9 0e		cmp #$0e	                cmp #AscCN
.817e	f0 44		beq $81c4	                beq _ctrl_n
.8180	91 24		sta ($24),y	                sta (tmp1),y
.8182	c8		iny		                iny
.8183	20 02 8e	jsr $8e02	                jsr emit_a
.8186	c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.8188	d0 db		bne $8165	                bne accept_loop       ; fall through if buffer limit reached
.818a	80 03		bra $818f	                bra _buffer_full
.818c					_eol:
.818c	20 2a a1	jsr $a12a	                jsr xt_space    ; print final space
.818f					_buffer_full:
.818f	94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.8191	74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.8193	4c 16 82	jmp $8216	                jmp accept_done
.8196					_backspace:
.8196	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8198	d0 06		bne $81a0	                bne +
.819a	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.819c	20 02 8e	jsr $8e02	                jsr emit_a
.819f	c8		iny		                iny
.81a0					+
.81a0	88		dey		                dey
.81a1	a9 08		lda #$08	                lda #AscBS      ; move back one
.81a3	20 02 8e	jsr $8e02	                jsr emit_a
.81a6	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.81a8	20 02 8e	jsr $8e02	                jsr emit_a
.81ab	a9 08		lda #$08	                lda #AscBS      ; move back over space
.81ad	20 02 8e	jsr $8e02	                jsr emit_a
.81b0	80 b3		bra $8165	                bra accept_loop
.81b2					_ctrl_p:
.81b2	a5 20		lda $20		                lda status
.81b4	29 07		and #$07	                and #7
.81b6	d0 08		bne $81c0	                bne _ctrl_p_dec
.81b8	a5 20		lda $20		                lda status
.81ba	09 07		ora #$07	                ora #7
.81bc	85 20		sta $20		                sta status
.81be	80 11		bra $81d1	                bra _recall_history
.81c0					_ctrl_p_dec:
.81c0	c6 20		dec $20		                dec status
.81c2	80 0d		bra $81d1	                bra _recall_history
.81c4					_ctrl_n:
.81c4	a9 08		lda #$08	                lda #$8
.81c6	24 20		bit $20		                bit status
.81c8	d0 07		bne $81d1	                bne _recall_history
.81ca	a5 20		lda $20		                lda status
.81cc	29 f7		and #$f7	                and #$f7
.81ce	1a		inc a		               ina
.81cf	85 20		sta $20		                sta status
.81d1					_recall_history:
.81d1	a9 08		lda #$08	                lda #%00001000
.81d3	14 20		trb $20		                trb status
.81d5	20 31 82	jsr $8231	                jsr accept_total_recall
.81d8	a9 0d		lda #$0d	                lda #AscCR
.81da	20 02 8e	jsr $8e02	                jsr emit_a
.81dd					input_clear:
.81dd	c0 00		cpy #$00	                cpy #0
.81df	f0 08		beq $81e9	                beq input_cleared
.81e1	a9 20		lda #$20	                lda #AscSP
.81e3	20 02 8e	jsr $8e02	                jsr emit_a
.81e6	88		dey		                dey
.81e7	80 f4		bra $81dd	                bra input_clear
.81e9					input_cleared:
.81e9	a9 0d		lda #$0d	                lda #AscCR
.81eb	20 02 8e	jsr $8e02	                jsr emit_a
.81ee	b1 28		lda ($28),y	                lda (tmp3),y
.81f0	85 21		sta $21		                sta status+1
.81f2	e6 28		inc $28		                inc tmp3
.81f4	d0 02		bne $81f8	                bne +           ; Increment the upper byte on carry.
.81f6	e6 29		inc $29		                inc tmp3+1
.81f8					+
.81f8	a9 0d		lda #$0d	                lda #AscCR
.81fa	20 02 8e	jsr $8e02	                jsr emit_a
.81fd					_history_loop:
.81fd	c4 21		cpy $21		                cpy status+1
.81ff	d0 03		bne $8204	                bne +
.8201	4c 65 81	jmp $8165	                jmp accept_loop       ; Needs a long jump
.8204					+
.8204	c4 26		cpy $26		                cpy tmp2
.8206	f0 0a		beq $8212	                beq _hist_filled_buffer
.8208	b1 28		lda ($28),y	                lda (tmp3),y
.820a	91 24		sta ($24),y	                sta (tmp1),y
.820c	20 02 8e	jsr $8e02	                jsr emit_a
.820f	c8		iny		                iny
.8210	80 eb		bra $81fd	                bra _history_loop
.8212					_hist_filled_buffer:
.8212	88		dey		                dey
.8213	4c 65 81	jmp $8165	                jmp accept_loop
.8216					accept_done:
.8216	20 31 82	jsr $8231	                jsr accept_total_recall
.8219	85 21		sta $21		                sta status+1
.821b	a0 00		ldy #$00	                ldy #0
.821d	91 28		sta ($28),y	                sta (tmp3),y
.821f	e6 28		inc $28		                inc tmp3
.8221	d0 02		bne $8225	                bne +           ; Increment the upper byte on carry.
.8223	e6 29		inc $29		                inc tmp3+1
.8225					+
.8225					_save_history_loop:
.8225	c4 21		cpy $21		                cpy status+1
.8227	f0 07		beq $8230	                beq _save_history_done
.8229	b1 24		lda ($24),y	                lda (tmp1),y
.822b	91 28		sta ($28),y	                sta (tmp3),y
.822d	c8		iny		                iny
.822e	80 f5		bra $8225	                bra _save_history_loop
.8230					_save_history_done:
.8230					z_accept:
.8230	60		rts		                rts
.8231					accept_total_recall:
.8231	a9 00		lda #$00	                lda #<hist_buff
.8233	85 28		sta $28		                sta tmp3
.8235	a9 7c		lda #$7c	                lda #>hist_buff
.8237	85 29		sta $29		                sta tmp3+1
.8239	a5 20		lda $20		                lda status
.823b	6a		ror a		                ror
.823c	29 03		and #$03	                and #3
.823e	18		clc		                clc
.823f	65 29		adc $29		                adc tmp3+1
.8241	85 29		sta $29		                sta tmp3+1
.8243	a5 20		lda $20		                lda status
.8245	6a		ror a		                ror             ; Rotate through carry into msb.
.8246	6a		ror a		                ror
.8247	29 80		and #$80	                and #$80
.8249	18		clc		                clc
.824a	65 28		adc $28		                adc tmp3
.824c	85 28		sta $28		                sta tmp3
.824e	90 02		bcc $8252	                bcc +           ; Increment the upper byte on carry.
.8250	e6 29		inc $29		                inc tmp3+1
.8252					+
.8252	98		tya		                tya
.8253	c9 80		cmp #$80	                cmp #$80
.8255	90 02		bcc $8259	                bcc +
.8257	a9 7f		lda #$7f	                lda #$7F
.8259					+
.8259	60		rts		                rts
.825a					xt_action_of:
.825a	a5 16		lda $16		                lda state
.825c	05 17		ora $17		                ora state+1
.825e	f0 0c		beq $826c	                beq _interpreting
.8260					_compiling:
.8260	20 aa 85	jsr $85aa	                jsr xt_bracket_tick
.8263	a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.8265	a9 eb		lda #$eb	                lda #<xt_defer_fetch
.8267	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.826a	80 06		bra $8272	                bra _done
.826c					_interpreting:
.826c	20 1d a2	jsr $a21d	                jsr xt_tick
.826f	20 eb 8a	jsr $8aeb	                jsr xt_defer_fetch
.8272					_done:
.8272	60		rts		z_action_of:           rts
.8273					xt_again:
.8273	20 50 d8	jsr $d850	                jsr underflow_1
.8276	a0 00		ldy #$00	                ldy #0
.8278	a9 4c		lda #$4c	                lda #$4C        ; JMP
.827a	91 00		sta ($00),y	                sta (cp),y
.827c	c8		iny		                iny
.827d	b5 00		lda $00,x	                lda 0,x         ; LSB of address
.827f	91 00		sta ($00),y	                sta (cp),y
.8281	c8		iny		                iny
.8282	b5 01		lda $01,x	                lda 1,x         ; MSB of address
.8284	91 00		sta ($00),y	                sta (cp),y
.8286	c8		iny		                iny
.8287	98		tya		                tya
.8288	18		clc		                clc
.8289	65 00		adc $00		                adc cp
.828b	85 00		sta $00		                sta cp
.828d	90 02		bcc $8291	                bcc _done
.828f	e6 01		inc $01		                inc cp+1
.8291					_done:
.8291	e8		inx		                inx
.8292	e8		inx		                inx
.8293	60		rts		z_again:        rts
.8294					xt_align:
.8294					xt_aligned:
.8294					z_align:
.8294	60		rts		z_aligned:      rts             ; stripped out during native compile
.8295					xt_allot:
.8295	20 50 d8	jsr $d850	                jsr underflow_1
.8298	b5 01		lda $01,x	                lda 1,x
.829a	30 22		bmi $82be	                bmi _release
.829c	18		clc		                clc
.829d	a5 00		lda $00		                lda cp
.829f	75 00		adc $00,x	                adc 0,x
.82a1	85 00		sta $00		                sta cp
.82a3	a5 01		lda $01		                lda cp+1
.82a5	75 01		adc $01,x	                adc 1,x
.82a7	85 01		sta $01		                sta cp+1
.82a9	a0 00		ldy #$00	                ldy #<cp_end
.82ab	c4 00		cpy $00		                cpy cp
.82ad	a9 7c		lda #$7c	                lda #>cp_end
.82af	e5 01		sbc $01		                sbc cp+1
.82b1	b0 48		bcs $82fb	                bcs _done               ; we're fine.
.82b3	84 00		sty $00		                sty cp                  ; still #<cp_end
.82b5	a9 7c		lda #$7c	                lda #>cp_end
.82b7	85 01		sta $01		                sta cp+1
.82b9	a9 00		lda #$00	                lda #err_allot
.82bb	4c 66 d8	jmp $d866	                jmp error
.82be					_release:
.82be	ca		dex		                dex
.82bf	ca		dex		                dex
.82c0	a5 00		lda $00		                lda cp
.82c2	95 00		sta $00,x	                sta 0,x
.82c4	a5 01		lda $01		                lda cp+1
.82c6	95 01		sta $01,x	                sta 1,x
.82c8	20 ef 99	jsr $99ef	                jsr xt_plus                     ; new CP is now TOS
.82cb	ca		dex		                dex
.82cc	ca		dex		                dex                             ; new CP now NOS
.82cd	a9 00		lda #$00	                lda #<cp0
.82cf	95 00		sta $00,x	                sta 0,x
.82d1	a9 03		lda #$03	                lda #>cp0
.82d3	95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.82d5	20 77 d7	jsr $d777	                jsr compare_16bit               ; still ( CP CP0 )
.82d8	f0 17		beq $82f1	                beq _nega_done
.82da	30 15		bmi $82f1	                bmi _nega_done
.82dc	a9 00		lda #$00	                lda #<cp0
.82de	85 00		sta $00		                sta cp
.82e0	a9 03		lda #$03	                lda #>cp0
.82e2	85 01		sta $01		                sta cp+1
.82e4	a9 50		lda #$50	                lda #<dictionary_start
.82e6	85 02		sta $02		                sta dp
.82e8	a9 bc		lda #$bc	                lda #>dictionary_start
.82ea	85 03		sta $03		                sta dp+1
.82ec	a9 0a		lda #$0a	                lda #err_negallot
.82ee	4c 66 d8	jmp $d866	                jmp error
.82f1					_nega_done:
.82f1	b5 02		lda $02,x	                lda 2,x
.82f3	85 00		sta $00		                sta cp
.82f5	b5 03		lda $03,x	                lda 3,x
.82f7	85 01		sta $01		                sta cp+1
.82f9	e8		inx		                inx
.82fa	e8		inx		                inx                     ; drop through to _done
.82fb					_done:
.82fb	e8		inx		                inx
.82fc	e8		inx		                inx
.82fd					z_allot:
.82fd	60		rts		                rts
.82fe					xt_allow_native:
.82fe	20 92 d7	jsr $d792	                jsr current_to_dp
.8301	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8303	b1 02		lda ($02),y	                lda (dp),y
.8305	29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.8307	91 02		sta ($02),y	                sta (dp),y
.8309					z_allow_native:
.8309	60		rts		                rts
.830a					xt_also:
.830a	20 40 91	jsr $9140	                jsr xt_get_order
.830d	20 9f 98	jsr $989f	                jsr xt_over
.8310	20 ba a1	jsr $a1ba	                jsr xt_swap
.8313	20 29 98	jsr $9829	                jsr xt_one_plus
.8316	20 27 9d	jsr $9d27	                jsr xt_set_order
.8319	60		rts		z_also:         rts
.831a					xt_always_native:
.831a	20 92 d7	jsr $d792	                jsr current_to_dp
.831d	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.831f	b1 02		lda ($02),y	                lda (dp),y
.8321	09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.8323	29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.8325	91 02		sta ($02),y	                sta (dp),y
.8327					z_always_native:
.8327	60		rts		                rts
.8328					xt_and:
.8328	20 55 d8	jsr $d855	                jsr underflow_2
.832b	b5 00		lda $00,x	                lda 0,x
.832d	35 02		and $02,x	                and 2,x
.832f	95 02		sta $02,x	                sta 2,x
.8331	b5 01		lda $01,x	                lda 1,x
.8333	35 03		and $03,x	                and 3,x
.8335	95 03		sta $03,x	                sta 3,x
.8337	e8		inx		                inx
.8338	e8		inx		                inx
.8339	60		rts		z_and:          rts
.833a					xt_at_xy:
.833a	20 55 d8	jsr $d855	                jsr underflow_2
.833d	a5 18		lda $18		                lda base
.833f	48		pha		                pha
.8340	a9 0a		lda #$0a	                lda #10
.8342	85 18		sta $18		                sta base
.8344	a9 1b		lda #$1b	                lda #AscESC
.8346	20 02 8e	jsr $8e02	                jsr emit_a
.8349	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.834b	20 02 8e	jsr $8e02	                jsr emit_a
.834e	20 29 98	jsr $9829	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8351	20 bd d8	jsr $d8bd	                jsr print_u
.8354	a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8356	20 02 8e	jsr $8e02	                jsr emit_a
.8359	20 29 98	jsr $9829	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.835c	20 bd d8	jsr $d8bd	                jsr print_u
.835f	a9 48		lda #$48	                lda #'H'
.8361	20 02 8e	jsr $8e02	                jsr emit_a
.8364	68		pla		                pla
.8365	85 18		sta $18		                sta base
.8367	60		rts		z_at_xy:        rts
.8368					xt_backslash:
.8368	a0 00		ldy #$00	                ldy #blk_offset
.836a	b1 1e		lda ($1e),y	                lda (up),y
.836c	c8		iny		                iny
.836d	11 1e		ora ($1e),y	                ora (up),y
.836f	f0 19		beq $838a	                beq backslash_not_block
.8371	a5 0c		lda $0c		                lda toin
.8373	29 3f		and #$3f	                and #$3F
.8375	f0 1b		beq $8392	                beq z_backslash
.8377	c9 01		cmp #$01	                cmp #$01
.8379	f0 17		beq $8392	                beq z_backslash
.837b	a5 0c		lda $0c		                lda toin
.837d	29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.837f	18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.8380	69 40		adc #$40	                adc #$40
.8382	85 0c		sta $0c		                sta toin
.8384	90 0c		bcc $8392	                bcc z_backslash
.8386	e6 0d		inc $0d		                inc toin+1
.8388	80 08		bra $8392	                bra z_backslash
.838a					backslash_not_block:
.838a	a5 0a		lda $0a		                lda ciblen
.838c	85 0c		sta $0c		                sta toin
.838e	a5 0b		lda $0b		                lda ciblen+1
.8390	85 0d		sta $0d		                sta toin+1
.8392	60		rts		z_backslash:    rts
.8393					xt_base:
.8393	ca		dex		                dex
.8394	ca		dex		                dex
.8395	a9 18		lda #$18	                lda #<base
.8397	95 00		sta $00,x	                sta 0,x         ; LSB
.8399	74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.839b	60		rts		z_base:         rts
.839c					xt_begin:
.839c	20 7e 91	jsr $917e	                jsr xt_here
.839f	60		rts		z_begin:        rts
.83a0					xt_bell:
.83a0	a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.83a2	20 02 8e	jsr $8e02	                jsr emit_a
.83a5	60		rts		z_bell:         rts
.83a6					xt_bl:
.83a6	ca		dex		                dex
.83a7	ca		dex		                dex
.83a8	a9 20		lda #$20	                lda #AscSP
.83aa	95 00		sta $00,x	                sta 0,x
.83ac	74 01		stz $01,x	                stz 1,x
.83ae	60		rts		z_bl:           rts
.83af					xt_blk:
.83af	ca		dex		                dex
.83b0	ca		dex		                dex
.83b1	18		clc		                clc
.83b2	a5 1e		lda $1e		                lda up
.83b4	69 00		adc #$00	                adc #blk_offset ; Add offset
.83b6	95 00		sta $00,x	                sta 0,x
.83b8	a5 1f		lda $1f		                lda up+1
.83ba	69 00		adc #$00	                adc #0          ; Adding carry
.83bc	95 01		sta $01,x	                sta 1,x
.83be	60		rts		z_blk:          rts
.83bf					xt_blkbuffer:
.83bf	ca		dex		                dex
.83c0	ca		dex		                dex
.83c1	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83c3	b1 1e		lda ($1e),y	                lda (up),y
.83c5	95 00		sta $00,x	                sta 0,x
.83c7	c8		iny		                iny             ; Move along to the next byte
.83c8	b1 1e		lda ($1e),y	                lda (up),y
.83ca	95 01		sta $01,x	                sta 1,x
.83cc	60		rts		z_blkbuffer:    rts
.83cd					xt_block:
.83cd	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83cf	b1 1e		lda ($1e),y	                lda (up),y
.83d1	d5 00		cmp $00,x	                cmp 0,x
.83d3	d0 0f		bne $83e4	                bne _not_in_buffer
.83d5	c8		iny		                iny
.83d6	b1 1e		lda ($1e),y	                lda (up),y
.83d8	d5 01		cmp $01,x	                cmp 1,x
.83da	d0 08		bne $83e4	                bne _not_in_buffer
.83dc	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83de	b1 1e		lda ($1e),y	                lda (up),y
.83e0	29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.83e2	d0 30		bne $8414	                bne _done       ; It's already in the buffer and in use.
.83e4					_not_in_buffer:
.83e4	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83e6	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.83e8	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.83ea	d0 0c		bne $83f8	                bne _buffer_available ; Unused or not dirty = available
.83ec	20 bf 83	jsr $83bf	                jsr xt_blkbuffer
.83ef	20 b1 85	jsr $85b1	                jsr xt_buffblocknum
.83f2	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.83f5	20 6c 85	jsr $856c	                jsr xt_block_write
.83f8					_buffer_available:
.83f8	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83fa	b5 00		lda $00,x	                lda 0,x
.83fc	91 1e		sta ($1e),y	                sta (up),y
.83fe	c8		iny		                iny
.83ff	b5 01		lda $01,x	                lda 1,x
.8401	91 1e		sta ($1e),y	                sta (up),y
.8403	20 bf 83	jsr $83bf	                jsr xt_blkbuffer
.8406	20 ba a1	jsr $a1ba	                jsr xt_swap
.8409	20 49 85	jsr $8549	                jsr xt_block_read
.840c	a9 01		lda #$01	                lda #1
.840e	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8410	91 1e		sta ($1e),y	                sta (up),y
.8412	ca		dex		                dex
.8413	ca		dex		                dex
.8414					_done:
.8414	a0 28		ldy #$28	                ldy #blkbuffer_offset
.8416	b1 1e		lda ($1e),y	                lda (up),y
.8418	95 00		sta $00,x	                sta 0,x
.841a	c8		iny		                iny
.841b	b1 1e		lda ($1e),y	                lda (up),y
.841d	95 01		sta $01,x	                sta 1,x
.841f	60		rts		z_block:        rts
.8420					xt_block_ramdrive_init:
.8420	20 50 d8	jsr $d850	                jsr underflow_1
.8423	4c 3e 85	jmp $853e	                jmp _after_ramdrive_code
.8426					_ramdrive_code:
>8426	62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>842e	77 61 70 20 64 65 63 69 6d 61 6c
>8439	20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>8440	20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>8444	20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>844c	20 72 61 6d 64 72 69 76 65
>8455	20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>845d	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>846b	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8473	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8483	73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>8493	20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>849b	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>84aa	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>84b2	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>84c2	31 30 32 34 20 6d 6f 76 65 20 3b
>84cd	20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>84d5	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>84e5	6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>84f5	20 21
>84f7	20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84ff	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>850f	62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>851f	6f 72 20 21
>8523	20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>852b	65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>853b	65 20 21
.853e					_after_ramdrive_code:
.853e	20 b5 a0	jsr $a0b5	                jsr sliteral_runtime
>8541	26 84 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.8545	20 e1 90	jsr $90e1	                jsr xt_evaluate
.8548					z_block_ramdrive_init:
.8548	60		rts		                rts
.8549					xt_block_read:
.8549	a0 2e		ldy #$2e	                ldy #blockread_offset
.854b	b1 1e		lda ($1e),y	                lda (up),y
.854d	85 24		sta $24		                sta tmp1
.854f	c8		iny		                iny
.8550	b1 1e		lda ($1e),y	                lda (up),y
.8552	85 25		sta $25		                sta tmp1+1
.8554	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8557					z_block_read:
.8557					xt_block_read_vector:
.8557	ca		dex		                dex
.8558	ca		dex		                dex
.8559	18		clc		                clc
.855a	a5 1e		lda $1e		                lda up
.855c	69 2e		adc #$2e	                adc #blockread_offset
.855e	95 00		sta $00,x	                sta 0,x
.8560	a5 1f		lda $1f		                lda up+1
.8562	69 00		adc #$00	                adc #0          ; Add carry
.8564	95 01		sta $01,x	                sta 1,x
.8566					z_block_read_vector:
.8566	60		rts		                rts
.8567					xt_block_word_error:
.8567	a9 0c		lda #$0c	                lda #err_blockwords
.8569	4c 66 d8	jmp $d866	                jmp error       ; no RTS needed
.856c					z_block_word_error:
.856c					xt_block_write:
.856c	a0 30		ldy #$30	                ldy #blockwrite_offset
.856e	b1 1e		lda ($1e),y	                lda (up),y
.8570	85 24		sta $24		                sta tmp1
.8572	c8		iny		                iny
.8573	b1 1e		lda ($1e),y	                lda (up),y
.8575	85 25		sta $25		                sta tmp1+1
.8577	6c 24 00	jmp ($0024)	                jmp (tmp1)
.857a					z_block_write:
.857a					xt_block_write_vector:
.857a	ca		dex		                dex
.857b	ca		dex		                dex
.857c	18		clc		                clc
.857d	a5 1e		lda $1e		                lda up
.857f	69 30		adc #$30	                adc #blockwrite_offset
.8581	95 00		sta $00,x	                sta 0,x
.8583	a5 1f		lda $1f		                lda up+1
.8585	69 00		adc #$00	                adc #0          ; Add carry
.8587	95 01		sta $01,x	                sta 1,x
.8589					z_block_write_vector:
.8589	60		rts		                rts
.858a					xt_bounds:
.858a	20 55 d8	jsr $d855	                jsr underflow_2
.858d	18		clc		                clc
.858e	b5 00		lda $00,x	                lda 0,x                 ; LSB u
.8590	b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.8592	75 02		adc $02,x	                adc 2,x
.8594	95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.8596	94 00		sty $00,x	                sty 0,x
.8598	b5 01		lda $01,x	                lda 1,x                 ; MSB u
.859a	b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.859c	75 03		adc $03,x	                adc 3,x
.859e	95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.85a0	94 01		sty $01,x	                sty 1,x
.85a2	60		rts		z_bounds:       rts
.85a3					xt_bracket_char:
.85a3	20 3d 86	jsr $863d	                jsr xt_char
.85a6	20 96 93	jsr $9396	                jsr xt_literal
.85a9	60		rts		z_bracket_char: rts
.85aa					xt_bracket_tick:
.85aa	20 1d a2	jsr $a21d	                jsr xt_tick
.85ad	20 96 93	jsr $9396	                jsr xt_literal
.85b0	60		rts		z_bracket_tick: rts
.85b1					xt_buffblocknum:
.85b1	ca		dex		                dex
.85b2	ca		dex		                dex
.85b3	18		clc		                clc
.85b4	a5 1e		lda $1e		                lda up
.85b6	69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.85b8	95 00		sta $00,x	                sta 0,x
.85ba	a5 1f		lda $1f		                lda up+1
.85bc	69 00		adc #$00	                adc #0                          ; Adding carry
.85be	95 01		sta $01,x	                sta 1,x
.85c0	60		rts		z_buffblocknum: rts
.85c1					xt_buffer:
.85c1	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85c3	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.85c5	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.85c7	d0 0c		bne $85d5	                bne _buffer_available ; Unused or not dirty = available
.85c9	20 bf 83	jsr $83bf	                jsr xt_blkbuffer
.85cc	20 b1 85	jsr $85b1	                jsr xt_buffblocknum
.85cf	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.85d2	20 6c 85	jsr $856c	                jsr xt_block_write
.85d5					_buffer_available:
.85d5	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.85d7	b5 00		lda $00,x	                lda 0,x
.85d9	91 1e		sta ($1e),y	                sta (up),y
.85db	c8		iny		                iny
.85dc	b5 01		lda $01,x	                lda 1,x
.85de	91 1e		sta ($1e),y	                sta (up),y
.85e0	a9 01		lda #$01	                lda #1
.85e2	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85e4	91 1e		sta ($1e),y	                sta (up),y
.85e6					_done:
.85e6	a0 28		ldy #$28	                ldy #blkbuffer_offset
.85e8	b1 1e		lda ($1e),y	                lda (up),y
.85ea	95 00		sta $00,x	                sta 0,x
.85ec	c8		iny		                iny
.85ed	b1 1e		lda ($1e),y	                lda (up),y
.85ef	95 01		sta $01,x	                sta 1,x
.85f1	60		rts		z_buffer:       rts
.85f2					xt_buffer_colon:
.85f2	20 75 89	jsr $8975	                jsr xt_create
.85f5	20 95 82	jsr $8295	                jsr xt_allot
.85f8	60		rts		z_buffer_colon: rts
.85f9					xt_buffstatus:
.85f9	ca		dex		                dex
.85fa	ca		dex		                dex
.85fb	18		clc		                clc
.85fc	a5 1e		lda $1e		                lda up
.85fe	69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.8600	95 00		sta $00,x	                sta 0,x
.8602	a5 1f		lda $1f		                lda up+1
.8604	69 00		adc #$00	                adc #0                  ; Adding carry
.8606	95 01		sta $01,x	                sta 1,x
.8608	60		rts		z_buffstatus:   rts
.8609					xt_bye:
.8609	4c 2b f0	jmp $f02b	                jmp platform_bye
.860c					z_bye:
.860c					xt_c_comma:
.860c	20 50 d8	jsr $d850	                jsr underflow_1
.860f	b5 00		lda $00,x	                lda 0,x
.8611	20 03 d7	jsr $d703	                jsr cmpl_a
.8614	e8		inx		                inx
.8615	e8		inx		                inx
.8616	60		rts		z_c_comma:      rts
.8617					xt_c_fetch:
.8617	20 50 d8	jsr $d850	                jsr underflow_1
.861a	a1 00		lda ($00,x)	                lda (0,x)
.861c	95 00		sta $00,x	                sta 0,x
.861e	74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8620	60		rts		z_c_fetch:      rts
.8621					xt_c_store:
.8621	20 55 d8	jsr $d855	                jsr underflow_2
.8624	b5 02		lda $02,x	                lda 2,x
.8626	81 00		sta ($00,x)	                sta (0,x)
.8628	e8		inx		                inx
.8629	e8		inx		                inx
.862a	e8		inx		                inx
.862b	e8		inx		                inx
.862c	60		rts		z_c_store:      rts
.862d					xt_cell_plus:
.862d	20 50 d8	jsr $d850	                jsr underflow_1
.8630	f6 00		inc $00,x	                inc 0,x
.8632	d0 02		bne $8636	                bne +
.8634	f6 01		inc $01,x	                inc 1,x
.8636					+
.8636	f6 00		inc $00,x	                inc 0,x
.8638	d0 02		bne $863c	                bne _done
.863a	f6 01		inc $01,x	                inc 1,x
.863c					_done:
.863c	60		rts		z_cell_plus:    rts
.863d					xt_char:
.863d	20 eb 98	jsr $98eb	                jsr xt_parse_name
.8640	b5 00		lda $00,x	                lda 0,x
.8642	15 01		ora $01,x	                ora 1,x
.8644	d0 05		bne $864b	                bne _not_empty
.8646	a9 05		lda #$05	                lda #err_noname
.8648	4c 66 d8	jmp $d866	                jmp error
.864b					_not_empty:
.864b	e8		inx		                inx             ; drop number of characters, leave addr
.864c	e8		inx		                inx
.864d	a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.864f	95 00		sta $00,x	                sta 0,x
.8651	74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8653	60		rts		z_char:         rts
.8654					xt_chars:
.8654	20 50 d8	jsr $d850	                jsr underflow_1
.8657	60		rts		z_chars:        rts
.8658					xt_cleave:
.8658	20 55 d8	jsr $d855	                jsr underflow_2
.865b	20 6f 95	jsr $956f	                jsr xt_minus_leading    ; -LEADING ( addr u )
.865e	20 6e 92	jsr $926e	                jsr xt_input_to_r       ; save old imput state
.8661	b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.8663	85 0a		sta $0a		                sta ciblen
.8665	b5 01		lda $01,x	                lda 1,x
.8667	85 0b		sta $0b		                sta ciblen+1
.8669	b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.866b	85 08		sta $08		                sta cib
.866d	b5 03		lda $03,x	                lda 3,x
.866f	85 09		sta $09		                sta cib+1
.8671	64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.8673	64 0d		stz $0d		                stz toin+1
.8675	20 eb 98	jsr $98eb	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.8678	b5 00		lda $00,x	                lda 0,x
.867a	15 01		ora $01,x	                ora 1,x
.867c	f0 23		beq $86a1	                beq _done
.867e	b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.8680	38		sec		                sec
.8681	f5 00		sbc $00,x	                sbc 0,x
.8683	95 04		sta $04,x	                sta 4,x
.8685	b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.8687	f5 01		sbc $01,x	                sbc 1,x
.8689	95 05		sta $05,x	                sta 5,x
.868b	b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.868d	18		clc		                clc
.868e	75 00		adc $00,x	                adc 0,x
.8690	95 06		sta $06,x	                sta 6,x
.8692	b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.8694	75 01		adc $01,x	                adc 1,x
.8696	95 07		sta $07,x	                sta 7,x
.8698	20 8a a4	jsr $a48a	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.869b	20 6f 95	jsr $956f	                jsr xt_minus_leading
.869e	20 8a a4	jsr $a48a	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.86a1					_done:
.86a1	20 af 9a	jsr $9aaf	                jsr xt_r_to_input
.86a4	60		rts		z_cleave:       rts
.86a5					xt_cmove:
.86a5	20 5a d8	jsr $d85a	                jsr underflow_3
.86a8	b5 02		lda $02,x	                lda 2,x
.86aa	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86ac	b5 03		lda $03,x	                lda 3,x
.86ae	85 27		sta $27		                sta tmp2+1
.86b0	b5 04		lda $04,x	                lda 4,x
.86b2	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86b4	b5 05		lda $05,x	                lda 5,x
.86b6	85 25		sta $25		                sta tmp1+1
.86b8	a0 00		ldy #$00	                ldy #0
.86ba	b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.86bc	f0 0f		beq $86cd	                beq _dopartial
.86be					_page:
.86be	b1 24		lda ($24),y	                lda (tmp1),y
.86c0	91 26		sta ($26),y	                sta (tmp2),y
.86c2	c8		iny		                iny
.86c3	d0 f9		bne $86be	                bne _page
.86c5	e6 25		inc $25		                inc tmp1+1
.86c7	e6 27		inc $27		                inc tmp2+1
.86c9	d6 01		dec $01,x	                dec 1,x
.86cb	d0 f1		bne $86be	                bne _page
.86cd					_dopartial:
.86cd	b5 00		lda $00,x	                lda 0,x         ; length of last page
.86cf	f0 09		beq $86da	                beq _done
.86d1					_partial:
.86d1	b1 24		lda ($24),y	                lda (tmp1),y
.86d3	91 26		sta ($26),y	                sta (tmp2),y
.86d5	c8		iny		                iny
.86d6	d6 00		dec $00,x	                dec 0,x
.86d8	d0 f7		bne $86d1	                bne _partial
.86da					_done:
.86da	8a		txa		                txa
.86db	18		clc		                clc
.86dc	69 06		adc #$06	                adc #6
.86de	aa		tax		                tax
.86df	60		rts		z_cmove:        rts
.86e0					xt_cmove_up:
.86e0	20 5a d8	jsr $d85a	                jsr underflow_3
.86e3	b5 02		lda $02,x	                lda 2,x
.86e5	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86e7	b5 03		lda $03,x	                lda 3,x
.86e9	18		clc		                clc
.86ea	75 01		adc $01,x	                adc 1,x
.86ec	85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.86ee	b5 04		lda $04,x	                lda 4,x
.86f0	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86f2	b5 05		lda $05,x	                lda 5,x
.86f4	18		clc		                clc
.86f5	75 01		adc $01,x	                adc 1,x
.86f7	85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86f9	f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86fb	b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86fd	f0 0e		beq $870d	                beq _nopartial
.86ff					_outerloop:
.86ff	88		dey		                dey
.8700	f0 07		beq $8709	                beq _finishpage
.8702					_innerloop:
.8702	b1 24		lda ($24),y	                lda (tmp1),y
.8704	91 26		sta ($26),y	                sta (tmp2),y
.8706	88		dey		                dey
.8707	d0 f9		bne $8702	                bne _innerloop
.8709					_finishpage:
.8709	b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.870b	92 26		sta ($26)	                sta (tmp2)
.870d					_nopartial:
.870d	c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.870f	c6 27		dec $27		                dec tmp2+1
.8711	d6 01		dec $01,x	                dec 1,x
.8713	d0 ea		bne $86ff	                bne _outerloop
.8715					_done:
.8715	8a		txa		                txa
.8716	18		clc		                clc
.8717	69 06		adc #$06	                adc #6
.8719	aa		tax		                tax
.871a	60		rts		z_cmove_up:     rts
.871b					xt_colon:
.871b	a5 16		lda $16		                lda state
.871d	05 17		ora $17		                ora state+1
.871f	f0 05		beq $8726	                beq +
.8721	a9 07		lda #$07	                lda #err_state
.8723	4c 66 d8	jmp $d866	                jmp error
.8726					+
.8726	c6 16		dec $16		                dec state
.8728	c6 17		dec $17		                dec state+1
.872a	a9 40		lda #$40	                lda #%01000000
.872c	04 20		tsb $20		                tsb status
.872e	20 92 d7	jsr $d792	                jsr current_to_dp
.8731	a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8733	48		pha		                pha
.8734	a5 02		lda $02		                lda dp
.8736	48		pha		                pha
.8737	a9 80		lda #$80	                lda #%10000000
.8739	04 20		tsb $20		                tsb status
.873b	20 75 89	jsr $8975	                jsr xt_create
.873e	20 92 d7	jsr $d792	                jsr current_to_dp   ; This might be able to be omitted
.8741	a5 02		lda $02		                lda dp
.8743	85 04		sta $04		                sta workword
.8745	a5 03		lda $03		                lda dp+1
.8747	85 05		sta $05		                sta workword+1
.8749	68		pla		                pla
.874a	85 02		sta $02		                sta dp
.874c	68		pla		                pla
.874d	85 03		sta $03		                sta dp+1
.874f	20 a5 d7	jsr $d7a5	                jsr dp_to_current
.8752	a5 00		lda $00		                lda cp
.8754	38		sec		                sec
.8755	e9 03		sbc #$03	                sbc #3
.8757	85 00		sta $00		                sta cp
.8759	b0 02		bcs $875d	                bcs _done
.875b	c6 01		dec $01		                dec cp+1
.875d					_done:
.875d	60		rts		z_colon:        rts
.875e					xt_colon_noname:
.875e	a5 16		lda $16		                lda state
.8760	05 17		ora $17		                ora state+1
.8762	f0 05		beq $8769	                beq +
.8764	a9 07		lda #$07	                lda #err_state
.8766	4c 66 d8	jmp $d866	                jmp error
.8769					+
.8769	c6 16		dec $16		                dec state
.876b	c6 17		dec $17		                dec state+1
.876d	a9 40		lda #$40	                lda #%01000000
.876f	14 20		trb $20		                trb status
.8771	a5 00		lda $00		                lda cp
.8773	85 04		sta $04		                sta workword
.8775	a5 01		lda $01		                lda cp+1
.8777	85 05		sta $05		                sta workword+1
.8779					_done:
.8779	60		rts		z_colon_noname:        rts
.877a					xt_comma:
.877a	20 50 d8	jsr $d850	                jsr underflow_1
.877d	b5 00		lda $00,x	                lda 0,x
.877f	92 00		sta ($00)	                sta (cp)
.8781	e6 00		inc $00		                inc cp
.8783	d0 02		bne $8787	                bne +
.8785	e6 01		inc $01		                inc cp+1
.8787					+
.8787	b5 01		lda $01,x	                lda 1,x
.8789	92 00		sta ($00)	                sta (cp)
.878b	e6 00		inc $00		                inc cp
.878d	d0 02		bne $8791	                bne _done
.878f	e6 01		inc $01		                inc cp+1
.8791					_done:
.8791	e8		inx		                inx
.8792	e8		inx		                inx
.8793	60		rts		z_comma:        rts
.8794					xt_compare:
.8794	20 5f d8	jsr $d85f	                jsr underflow_4
.8797	b5 02		lda $02,x	                lda 2,x
.8799	85 26		sta $26		                sta tmp2
.879b	b5 03		lda $03,x	                lda 3,x
.879d	85 27		sta $27		                sta tmp2+1
.879f	b5 06		lda $06,x	                lda 6,x
.87a1	85 24		sta $24		                sta tmp1
.87a3	b5 07		lda $07,x	                lda 7,x
.87a5	85 25		sta $25		                sta tmp1+1
.87a7					_compare_loop:
.87a7	b5 04		lda $04,x	                lda 4,x
.87a9	15 05		ora $05,x	                ora 5,x
.87ab	f0 2c		beq $87d9	                beq _str1_done
.87ad	b5 00		lda $00,x	                lda 0,x
.87af	15 01		ora $01,x	                ora 1,x
.87b1	f0 3a		beq $87ed	                beq _greater    ; Str2 empty first
.87b3					_check_letter:
.87b3	b2 24		lda ($24)	                lda (tmp1)
.87b5	d2 26		cmp ($26)	                cmp (tmp2)
.87b7	90 26		bcc $87df	                bcc _less
.87b9	d0 32		bne $87ed	                bne _greater
.87bb					_next_letter:
.87bb	e6 24		inc $24		                inc tmp1
.87bd	d0 02		bne $87c1	                bne +
.87bf	e6 25		inc $25		                inc tmp1+1
.87c1					+
.87c1	e6 26		inc $26		                inc tmp2
.87c3	d0 02		bne $87c7	                bne +
.87c5	e6 27		inc $27		                inc tmp2+1
.87c7					+
.87c7	b5 04		lda $04,x	                lda 4,x
.87c9	d0 02		bne $87cd	                bne +
.87cb	d6 05		dec $05,x	                dec 5,x
.87cd					+
.87cd	d6 04		dec $04,x	                dec 4,x
.87cf	b5 00		lda $00,x	                lda 0,x
.87d1	d0 02		bne $87d5	                bne +
.87d3	d6 01		dec $01,x	                dec 1,x
.87d5					+
.87d5	d6 00		dec $00,x	                dec 0,x
.87d7	80 ce		bra $87a7	                bra _compare_loop
.87d9					_str1_done:
.87d9	b5 00		lda $00,x	                lda 0,x
.87db	15 01		ora $01,x	                ora 1,x
.87dd	f0 08		beq $87e7	                beq _equal      ; Both out of letters
.87df					_less:
.87df	a9 ff		lda #$ff	                lda #$FF
.87e1	95 06		sta $06,x	                sta 6,x
.87e3	95 07		sta $07,x	                sta 7,x
.87e5	80 0c		bra $87f3	                bra _done
.87e7					_equal:
.87e7	74 06		stz $06,x	                stz 6,x
.87e9	74 07		stz $07,x	                stz 7,x
.87eb	80 06		bra $87f3	                bra _done
.87ed					_greater:
.87ed	a9 01		lda #$01	                lda #1
.87ef	95 06		sta $06,x	                sta 6,x
.87f1	74 07		stz $07,x	                stz 7,x
.87f3					_done:
.87f3	8a		txa		                txa
.87f4	18		clc		                clc
.87f5	69 06		adc #$06	                adc #6
.87f7	aa		tax		                tax
.87f8	60		rts		z_compare:      rts
.87f9					xt_compile_comma:
.87f9	20 50 d8	jsr $d850	                jsr underflow_1
.87fc	b5 01		lda $01,x	                lda 1,x                 ; MSB
.87fe	48		pha		                pha
.87ff	b5 00		lda $00,x	                lda 0,x
.8801	48		pha		                pha                     ; LSB
.8802	20 84 92	jsr $9284	                jsr xt_int_to_name      ; ( xt -- nt )
.8805	b5 00		lda $00,x	                lda 0,x
.8807	15 01		ora $01,x	                ora 1,x
.8809	d0 03		bne $880e	                bne _check_nt
.880b	4c f6 88	jmp $88f6	                jmp _compile_as_jump
.880e					_check_nt:
.880e	b5 00		lda $00,x	                lda 0,x
.8810	85 2c		sta $2c		                sta tmptos
.8812	b5 01		lda $01,x	                lda 1,x
.8814	85 2d		sta $2d		                sta tmptos+1
.8816	f6 00		inc $00,x	                inc 0,x
.8818	d0 02		bne $881c	                bne +
.881a	f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.881c					+
.881c	a1 00		lda ($00,x)	                lda (0,x)
.881e	85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.8820	29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8822	f0 0d		beq $8831	                beq _compile_check
.8824	a5 2c		lda $2c		                lda tmptos
.8826	95 00		sta $00,x	                sta 0,x
.8828	a5 2d		lda $2d		                lda tmptos+1
.882a	95 01		sta $01,x	                sta 1,x
.882c	20 81 a7	jsr $a781	                jsr xt_wordsize         ; ( nt -- u )
.882f	80 27		bra $8858	                bra _compile_as_code
.8831					_compile_check:
.8831	a5 28		lda $28		                lda tmp3
.8833	29 08		and #$08	                and #NN
.8835	f0 03		beq $883a	                beq _check_size_limit
.8837	4c f6 88	jmp $88f6	                jmp _compile_as_jump    ; too far for BRA
.883a					_check_size_limit:
.883a	a5 2c		lda $2c		                lda tmptos
.883c	95 00		sta $00,x	                sta 0,x
.883e	a5 2d		lda $2d		                lda tmptos+1
.8840	95 01		sta $01,x	                sta 1,x
.8842	20 81 a7	jsr $a781	                jsr xt_wordsize         ; ( nt -- u )
.8845	b5 01		lda $01,x	                lda 1,x
.8847	c5 1b		cmp $1b		                cmp nc_limit+1
.8849	90 0d		bcc $8858	                bcc _compile_as_code    ; user-defined limit MSB
.884b	d0 08		bne $8855	                bne _jumpto_compile_as_jump
.884d	b5 00		lda $00,x	                lda 0,x
.884f	c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.8851	90 05		bcc $8858	                bcc _compile_as_code    ; Allow native compiling for less
.8853	f0 03		beq $8858	                beq _compile_as_code    ; than or equal to the limit.
.8855					_jumpto_compile_as_jump:
.8855	4c f6 88	jmp $88f6	                jmp _compile_as_jump    ; too far for BRA
.8858					_compile_as_code:
.8858	ca		dex		                dex
.8859	ca		dex		                dex                     ; ( -- u ? )
.885a	ca		dex		                dex
.885b	ca		dex		                dex                     ; ( -- u ? ? )
.885c	b5 04		lda $04,x	                lda 4,x
.885e	95 00		sta $00,x	                sta 0,x                 ; LSB of u
.8860	b5 05		lda $05,x	                lda 5,x
.8862	95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.8864	68		pla		                pla
.8865	95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8867	68		pla		                pla
.8868	95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.886a	a5 00		lda $00		                lda cp                  ; LSB of cp
.886c	95 02		sta $02,x	                sta 2,x
.886e	a5 01		lda $01		                lda cp+1
.8870	95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.8872	a0 00		ldy #$00	                ldy #0
.8874					_strip_loop:
.8874	b9 e4 88	lda $88e4,y	                lda _strip_table,y      ; LSB of first word
.8877	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8879	d0 07		bne $8882	                bne _next_entry
.887b	b9 e5 88	lda $88e5,y	                lda _strip_table+1,y
.887e	d5 05		cmp $05,x	                cmp 5,x
.8880	f0 0c		beq $888e	                beq _found_entry
.8882					_next_entry:
.8882	b9 e4 88	lda $88e4,y	                lda _strip_table,y      ; pointing to LSB
.8885	19 e5 88	ora $88e5,y	                ora _strip_table+1,y    ; get MSB
.8888	f0 22		beq $88ac	                beq _underflow_strip    ; table done, let's get out of here
.888a	c8		iny		                iny
.888b	c8		iny		                iny
.888c	80 e6		bra $8874	                bra _strip_loop
.888e					_found_entry:
.888e	98		tya		                tya
.888f	4a		lsr a		                lsr
.8890	a8		tay		                tay
.8891	b9 f0 88	lda $88f0,y	                lda _strip_size,y
.8894	85 2c		sta $2c		                sta tmptos              ; save a copy
.8896	18		clc		                clc
.8897	75 04		adc $04,x	                adc 4,x
.8899	95 04		sta $04,x	                sta 4,x
.889b	90 02		bcc $889f	                bcc+
.889d	f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.889f					+
.889f	06 2c		asl $2c		                asl tmptos
.88a1	38		sec		                sec
.88a2	b5 00		lda $00,x	                lda 0,x
.88a4	e5 2c		sbc $2c		                sbc tmptos
.88a6	95 00		sta $00,x	                sta 0,x
.88a8	b0 02		bcs $88ac	                bcs +
.88aa	d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.88ac					+
.88ac					_underflow_strip:
.88ac	a5 1c		lda $1c		                lda uf_strip
.88ae	05 1d		ora $1d		                ora uf_strip+1
.88b0	f0 1c		beq $88ce	                beq _specials_done
.88b2	a5 28		lda $28		                lda tmp3
.88b4	29 10		and #$10	                and #UF
.88b6	f0 16		beq $88ce	                beq _specials_done
.88b8	18		clc		                clc
.88b9	b5 04		lda $04,x	                lda 4,x
.88bb	69 03		adc #$03	                adc #3
.88bd	95 04		sta $04,x	                sta 4,x
.88bf	90 02		bcc $88c3	                bcc +
.88c1	f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.88c3					+
.88c3	38		sec		                sec
.88c4	b5 00		lda $00,x	                lda 0,x
.88c6	e9 03		sbc #$03	                sbc #3
.88c8	95 00		sta $00,x	                sta 0,x
.88ca	b0 02		bcs $88ce	                bcs +
.88cc	d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.88ce					+
.88ce					_specials_done:
.88ce	b5 01		lda $01,x	                lda 1,x                 ; MSB
.88d0	48		pha		                pha
.88d1	b5 00		lda $00,x	                lda 0,x                 ; LSB
.88d3	48		pha		                pha
.88d4	20 ce 95	jsr $95ce	                jsr xt_move
.88d7	18		clc		                clc
.88d8	68		pla		                pla                     ; LSB
.88d9	65 00		adc $00		                adc cp
.88db	85 00		sta $00		                sta cp
.88dd	68		pla		                pla                     ; MSB
.88de	65 01		adc $01		                adc cp+1
.88e0	85 01		sta $01		                sta cp+1
.88e2	80 2c		bra $8910	                bra _done
.88e4					_strip_table:
>88e4	9e 9a 89 9a 7c a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88ea	ae a4 34 a4 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88f0					_strip_size:
>88f0	04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88f6					_compile_as_jump:
.88f6	a9 20		lda #$20	                lda #$20
.88f8	92 00		sta ($00)	                sta (cp)
.88fa	a0 01		ldy #$01	                ldy #1
.88fc	68		pla		                pla             ; LSB
.88fd	91 00		sta ($00),y	                sta (cp),y
.88ff	c8		iny		                iny
.8900	68		pla		                pla             ; MSB
.8901	91 00		sta ($00),y	                sta (cp),y
.8903	a9 03		lda #$03	                lda #3
.8905	18		clc		                clc
.8906	65 00		adc $00		                adc cp
.8908	85 00		sta $00		                sta cp
.890a	90 02		bcc $890e	                bcc +
.890c	e6 01		inc $01		                inc cp+1
.890e					+
.890e	e8		inx		                inx             ; drop xt
.890f	e8		inx		                inx
.8910					_done:
.8910					z_compile_comma:
.8910	60		rts		                rts
.8911					xt_compile_only:
.8911	20 92 d7	jsr $d792	                jsr current_to_dp
.8914	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8916	b1 02		lda ($02),y	                lda (dp),y
.8918	09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.891a	91 02		sta ($02),y	                sta (dp),y
.891c	60		rts		z_compile_only: rts
.891d					xt_value:
.891d					xt_constant:
.891d	20 50 d8	jsr $d850	                jsr underflow_1
.8920	20 75 89	jsr $8975	                jsr xt_create
.8923	38		sec		                sec
.8924	a5 00		lda $00		                lda cp
.8926	e9 02		sbc #$02	                sbc #2
.8928	85 24		sta $24		                sta tmp1
.892a	a5 01		lda $01		                lda cp+1
.892c	e9 00		sbc #$00	                sbc #0
.892e	85 25		sta $25		                sta tmp1+1
.8930	a9 0c		lda #$0c	                lda #<doconst           ; LSB of DOCONST
.8932	92 24		sta ($24)	                sta (tmp1)
.8934	a0 01		ldy #$01	                ldy #1
.8936	a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.8938	91 24		sta ($24),y	                sta (tmp1),y
.893a	20 7a 87	jsr $877a	                jsr xt_comma            ; drop through to adjust_z
.893d					adjust_z:
.893d	20 47 93	jsr $9347	                jsr xt_latestnt         ; gives us ( -- nt )
.8940	b5 00		lda $00,x	                lda 0,x
.8942	85 24		sta $24		                sta tmp1
.8944	b5 01		lda $01,x	                lda 1,x
.8946	85 25		sta $25		                sta tmp1+1
.8948	a0 06		ldy #$06	                ldy #6
.894a	b1 24		lda ($24),y	                lda (tmp1),y
.894c	18		clc		                clc
.894d	69 02		adc #$02	                adc #2
.894f	91 24		sta ($24),y	                sta (tmp1),y
.8951	c8		iny		                iny
.8952	b1 24		lda ($24),y	                lda (tmp1),y
.8954	69 00		adc #$00	                adc #0                  ; only need carry
.8956	91 24		sta ($24),y	                sta (tmp1),y
.8958	e8		inx		                inx
.8959	e8		inx		                inx
.895a					z_value:
.895a	60		rts		z_constant:     rts
.895b					xt_count:
.895b	20 50 d8	jsr $d850	                jsr underflow_1
.895e	a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.8960	a8		tay		                tay
.8961	f6 00		inc $00,x	                inc 0,x         ; LSB
.8963	d0 02		bne $8967	                bne +
.8965	f6 01		inc $01,x	                inc 1,x         ; MSB
.8967	98		tya		+               tya
.8968	ca		dex		                dex
.8969	ca		dex		                dex
.896a	95 00		sta $00,x	                sta 0,x         ; LSB
.896c	74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.896e	60		rts		z_count:        rts
.896f					xt_cr:
.896f	a9 0a		lda #$0a	                lda #AscLF
.8971	20 02 8e	jsr $8e02	                jsr emit_a
.8974	60		rts		z_cr:           rts
.8975					xt_create:
.8975	20 eb 98	jsr $98eb	                jsr xt_parse_name       ; ( addr u )
.8978	b5 00		lda $00,x	                lda 0,x
.897a	15 01		ora $01,x	                ora 1,x
.897c	d0 05		bne $8983	                bne _got_name
.897e	a9 05		lda #$05	                lda #err_noname
.8980	4c 66 d8	jmp $d866	                jmp error
.8983					_got_name:
.8983	74 01		stz $01,x	                stz 1,x
.8985	20 c4 a3	jsr $a3c4	                jsr xt_two_dup          ; ( addr u addr u )
.8988	20 e7 8f	jsr $8fe7	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.898b	b5 00		lda $00,x	                lda 0,x
.898d	15 01		ora $01,x	                ora 1,x
.898f	f0 1e		beq $89af	                beq _new_name           ; We haven't seen this one before.
.8991	e8		inx		                inx                     ; Drop flag (nt) from find-name.
.8992	e8		inx		                inx
.8993	24 20		bit $20		                bit status
.8995	10 08		bpl $899f	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8997	a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8999	05 20		ora $20		                ora status
.899b	85 20		sta $20		                sta status
.899d	80 18		bra $89b7	                bra _process_name
.899f					_redefined_name:
.899f	a9 02		lda #$02	                lda #str_redefined
.89a1	20 8c d8	jsr $d88c	                jsr print_string_no_lf
.89a4	20 c4 a3	jsr $a3c4	                jsr xt_two_dup           ; ( addr u addr u )
.89a7	20 0f a5	jsr $a50f	                jsr xt_type
.89aa	20 2a a1	jsr $a12a	                jsr xt_space
.89ad	80 08		bra $89b7	                bra _process_name
.89af					_new_name:
.89af	e8		inx		                inx                     ; Drop flag (0) from find-name.
.89b0	e8		inx		                inx
.89b1	a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.89b3	25 20		and $20		                and status
.89b5	85 20		sta $20		                sta status
.89b7					_process_name:
.89b7	b5 00		lda $00,x	                lda 0,x
.89b9	85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.89bb	a5 00		lda $00		                lda cp
.89bd	85 24		sta $24		                sta tmp1
.89bf	a5 01		lda $01		                lda cp+1
.89c1	85 25		sta $25		                sta tmp1+1
.89c3	b5 00		lda $00,x	                lda 0,x
.89c5	18		clc		                clc
.89c6	69 08		adc #$08	                adc #8
.89c8	85 28		sta $28		                sta tmp3                ; total header length
.89ca	18		clc		                clc
.89cb	69 03		adc #$03	                adc #3
.89cd	95 00		sta $00,x	                sta 0,x
.89cf	74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.89d1	20 95 82	jsr $8295	                jsr xt_allot    ; ( addr )
.89d4	20 92 d7	jsr $d792	                jsr current_to_dp
.89d7	a0 00		ldy #$00	                ldy #0
.89d9	a5 26		lda $26		                lda tmp2
.89db	91 24		sta ($24),y	                sta (tmp1),y
.89dd	a9 08		lda #$08	                lda #NN
.89df	09 20		ora #$20	                ora #HC
.89e1	c8		iny		                iny
.89e2	91 24		sta ($24),y	                sta (tmp1),y
.89e4	c8		iny		                iny
.89e5	a5 02		lda $02		                lda dp
.89e7	91 24		sta ($24),y	                sta (tmp1),y
.89e9	c8		iny		                iny
.89ea	a5 03		lda $03		                lda dp+1
.89ec	91 24		sta ($24),y	                sta (tmp1),y
.89ee	c8		iny		                iny
.89ef	a5 25		lda $25		                lda tmp1+1
.89f1	85 03		sta $03		                sta dp+1
.89f3	a5 24		lda $24		                lda tmp1
.89f5	85 02		sta $02		                sta dp
.89f7	18		clc		                clc
.89f8	65 28		adc $28		                adc tmp3        ; add total header length
.89fa	91 24		sta ($24),y	                sta (tmp1),y
.89fc	48		pha		                pha             ; we need this in the next step
.89fd	c8		iny		                iny
.89fe	a5 25		lda $25		                lda tmp1+1
.8a00	69 00		adc #$00	                adc #0          ; only need the carry
.8a02	91 24		sta ($24),y	                sta (tmp1),y
.8a04	c8		iny		                iny
.8a05	68		pla		                pla             ; LSB of "z_" address
.8a06	18		clc		                clc
.8a07	69 03		adc #$03	                adc #3
.8a09	91 24		sta ($24),y	                sta (tmp1),y
.8a0b	88		dey		                dey             ; get the MSB of xt back
.8a0c	b1 24		lda ($24),y	                lda (tmp1),y
.8a0e	69 00		adc #$00	                adc #0          ; only need the carry
.8a10	c8		iny		                iny
.8a11	c8		iny		                iny
.8a12	91 24		sta ($24),y	                sta (tmp1),y
.8a14	c8		iny		                iny
.8a15	b5 00		lda $00,x	                lda 0,x
.8a17	38		sec		                sec
.8a18	e9 08		sbc #$08	                sbc #8
.8a1a	85 2c		sta $2c		                sta tmptos
.8a1c	b5 01		lda $01,x	                lda 1,x
.8a1e	e9 00		sbc #$00	                sbc #0          ; only need carry
.8a20	85 2d		sta $2d		                sta tmptos+1
.8a22					_name_loop:
.8a22	b1 2c		lda ($2c),y	                lda (tmptos),y
.8a24	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8a26	b0 07		bcs $8a2f	                bcs _store_name
.8a28	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8a2a	90 03		bcc $8a2f	                bcc _store_name
.8a2c	18		clc		                clc
.8a2d	69 20		adc #$20	                adc #$20
.8a2f					_store_name:
.8a2f	91 24		sta ($24),y	                sta (tmp1),y
.8a31	c8		iny		                iny
.8a32	c6 26		dec $26		                dec tmp2
.8a34	d0 ec		bne $8a22	                bne _name_loop
.8a36	a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a38	91 24		sta ($24),y	                sta (tmp1),y
.8a3a	c8		iny		                iny
.8a3b	a9 52		lda #$52	                lda #<dovar
.8a3d	91 24		sta ($24),y	                sta (tmp1),y
.8a3f	c8		iny		                iny
.8a40	a9 d7		lda #$d7	                lda #>dovar
.8a42	91 24		sta ($24),y	                sta (tmp1),y
.8a44	20 a5 d7	jsr $d7a5	                jsr dp_to_current
.8a47	e8		inx		                inx
.8a48	e8		inx		                inx
.8a49	60		rts		z_create:       rts
.8a4a					xt_d_minus:
.8a4a	20 5f d8	jsr $d85f	                jsr underflow_4 ; two double numbers
.8a4d	38		sec		                sec
.8a4e	b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a50	f5 02		sbc $02,x	                sbc 2,x
.8a52	95 06		sta $06,x	                sta 6,x
.8a54	b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a56	f5 03		sbc $03,x	                sbc 3,x
.8a58	95 07		sta $07,x	                sta 7,x
.8a5a	b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a5c	f5 00		sbc $00,x	                sbc 0,x
.8a5e	95 04		sta $04,x	                sta 4,x
.8a60	b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a62	f5 01		sbc $01,x	                sbc 1,x
.8a64	95 05		sta $05,x	                sta 5,x
.8a66	e8		inx		                inx
.8a67	e8		inx		                inx
.8a68	e8		inx		                inx
.8a69	e8		inx		                inx
.8a6a	60		rts		z_d_minus:      rts
.8a6b					xt_d_plus:
.8a6b	20 5f d8	jsr $d85f	                jsr underflow_4 ; two double numbers
.8a6e	18		clc		                clc
.8a6f	b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a71	75 06		adc $06,x	                adc 6,x
.8a73	95 06		sta $06,x	                sta 6,x
.8a75	b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a77	75 07		adc $07,x	                adc 7,x
.8a79	95 07		sta $07,x	                sta 7,x
.8a7b	b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a7d	75 04		adc $04,x	                adc 4,x
.8a7f	95 04		sta $04,x	                sta 4,x
.8a81	b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a83	75 05		adc $05,x	                adc 5,x
.8a85	95 05		sta $05,x	                sta 5,x
.8a87	e8		inx		                inx
.8a88	e8		inx		                inx
.8a89	e8		inx		                inx
.8a8a	e8		inx		                inx
.8a8b	60		rts		z_d_plus:       rts
.8a8c					xt_d_to_s:
.8a8c	20 55 d8	jsr $d855	                jsr underflow_2
.8a8f	e8		inx		                inx
.8a90	e8		inx		                inx
.8a91	60		rts		z_d_to_s:       rts
.8a92					xt_dabs:
.8a92	20 55 d8	jsr $d855	                jsr underflow_2 ; double number
.8a95	b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a97	10 17		bpl $8ab0	                bpl _done       ; positive, we get off light
.8a99	a0 00		ldy #$00	                ldy #0
.8a9b	38		sec		                sec
.8a9c	98		tya		                tya
.8a9d	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a9f	95 02		sta $02,x	                sta 2,x
.8aa1	98		tya		                tya
.8aa2	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8aa4	95 03		sta $03,x	                sta 3,x
.8aa6	98		tya		                tya
.8aa7	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8aa9	95 00		sta $00,x	                sta 0,x
.8aab	98		tya		                tya
.8aac	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8aae	95 01		sta $01,x	                sta 1,x
.8ab0					_done:
.8ab0	60		rts		z_dabs:         rts
.8ab1					xt_decimal:
.8ab1	a9 0a		lda #$0a	                lda #10
.8ab3	85 18		sta $18		                sta base
.8ab5	64 19		stz $19		                stz base+1              ; paranoid
.8ab7	60		rts		z_decimal:      rts
.8ab8					xt_defer:
.8ab8	20 75 89	jsr $8975	                jsr xt_create
.8abb	a5 00		lda $00		                lda cp          ; LSB
.8abd	38		sec		                sec
.8abe	e9 02		sbc #$02	                sbc #2
.8ac0	85 24		sta $24		                sta tmp1
.8ac2	a5 01		lda $01		                lda cp+1        ; MSB
.8ac4	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8ac6	85 25		sta $25		                sta tmp1+1
.8ac8	a0 00		ldy #$00	                ldy #0
.8aca	a9 20		lda #$20	                lda #<dodefer   ; LSB
.8acc	91 24		sta ($24),y	                sta (tmp1),y
.8ace	c8		iny		                iny
.8acf	a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8ad1	91 24		sta ($24),y	                sta (tmp1),y
.8ad3	a9 34		lda #$34	                lda #<defer_error
.8ad5	92 00		sta ($00)	                sta (cp)
.8ad7	e6 00		inc $00		                inc cp
.8ad9	d0 02		bne $8add	                bne +
.8adb	e6 01		inc $01		                inc cp+1
.8add					+
.8add	a9 d7		lda #$d7	                lda #>defer_error
.8adf	92 00		sta ($00)	                sta (cp)
.8ae1	e6 00		inc $00		                inc cp
.8ae3	d0 02		bne $8ae7	                bne +
.8ae5	e6 01		inc $01		                inc cp+1
.8ae7					+
.8ae7	20 3d 89	jsr $893d	                jsr adjust_z    ; adjust header to correct length
.8aea	60		rts		z_defer:        rts
.8aeb					xt_defer_fetch:
.8aeb	20 99 a2	jsr $a299	                jsr xt_to_body
.8aee	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.8af1	60		rts		z_defer_fetch:  rts
.8af2					xt_defer_store:
.8af2	20 99 a2	jsr $a299	                jsr xt_to_body
.8af5	20 99 a1	jsr $a199	                jsr xt_store
.8af8	60		rts		z_defer_store:  rts
.8af9					xt_definitions:
.8af9	a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8afb	b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8afd	a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8aff	91 1e		sta ($1e),y	                sta (up),y
.8b01	60		rts		z_definitions:  rts
.8b02					xt_depth:
.8b02	a9 78		lda #$78	                lda #dsp0
.8b04	86 2a		stx $2a		                stx tmpdsp
.8b06	38		sec		                sec
.8b07	e5 2a		sbc $2a		                sbc tmpdsp
.8b09	4a		lsr a		                lsr
.8b0a	ca		dex		                dex
.8b0b	ca		dex		                dex
.8b0c	95 00		sta $00,x	                sta 0,x
.8b0e	74 01		stz $01,x	                stz 1,x
.8b10	60		rts		z_depth:        rts
.8b11					xt_digit_question:
.8b11	20 50 d8	jsr $d850	                jsr underflow_1
.8b14	ca		dex		                dex
.8b15	ca		dex		                dex
.8b16	74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8b18	74 01		stz $01,x	                stz 1,x
.8b1a	74 03		stz $03,x	                stz 3,x                 ; paranoid
.8b1c	b5 02		lda $02,x	                lda 2,x
.8b1e	c9 30		cmp #$30	                cmp #'0'
.8b20	90 23		bcc $8b45	                bcc _done               ; failure flag already set
.8b22	c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8b24	90 12		bcc $8b38	                bcc _checkbase
.8b26	c9 41		cmp #$41	                cmp #'A'
.8b28	90 1b		bcc $8b45	                bcc _done               ; failure flag is already set
.8b2a	c9 61		cmp #$61	                cmp #'a'
.8b2c	90 07		bcc $8b35	                bcc _case_done          ; not lower case, too low
.8b2e	c9 7b		cmp #$7b	                cmp #'z'+1
.8b30	b0 03		bcs $8b35	                bcs _case_done          ; not lower case, too high
.8b32	18		clc		                clc                     ; just right
.8b33	69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b35					_case_done:
.8b35	38		sec		                sec
.8b36	e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b38					_checkbase:
.8b38	38		sec		                sec
.8b39	e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b3b	c5 18		cmp $18		                cmp base
.8b3d	b0 06		bcs $8b45	                bcs _done               ; already have false flag
.8b3f	95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b41	d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b43	d6 01		dec $01,x	                dec 1,x
.8b45					_done:
.8b45					z_digit_question:
.8b45	60		rts		                rts
.8b46					xt_disasm:
.8b46	20 55 d8	jsr $d855	                jsr underflow_2
.8b49	20 e3 ac	jsr $ace3	                jsr disassembler
.8b4c	60		rts		z_disasm:       rts
.8b4d					xt_dnegate:
.8b4d	20 55 d8	jsr $d855	                jsr underflow_2 ; double number
.8b50	a0 00		ldy #$00	     		ldy #0
.8b52	38		sec		                sec
.8b53	98		tya		                tya
.8b54	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b56	95 02		sta $02,x	                sta 2,x
.8b58	98		tya		                tya
.8b59	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b5b	95 03		sta $03,x	                sta 3,x
.8b5d	98		tya		                tya
.8b5e	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b60	95 00		sta $00,x	                sta 0,x
.8b62	98		tya		                tya
.8b63	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b65	95 01		sta $01,x	                sta 1,x
.8b67	60		rts		z_dnegate:      rts
.8b68					xt_question_do:
.8b68	a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b6a	85 24		sta $24		                sta tmp1
.8b6c	80 02		bra $8b70	                bra do_common           ; skip flag for DO
.8b6e					xt_do:
.8b6e	64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b70					do_common:
.8b70	ca		dex		                dex
.8b71	ca		dex		                dex
.8b72	a5 00		lda $00		                lda cp
.8b74	95 00		sta $00,x	                sta 0,x                 ; LSB
.8b76	a5 01		lda $01		                lda cp+1
.8b78	95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b7a	a9 05		lda #$05	                lda #5                  ; we don't really care about the value,
.8b7c	a8		tay		                tay                     ; so we use 5 to be tricky
.8b7d					_loop:
.8b7d	91 00		sta ($00),y	                sta (CP),y
.8b7f	88		dey		                dey
.8b80	10 fb		bpl $8b7d	                bpl _loop
.8b82	1a		inc a		                ina             ; we used 5 as a dummy value, this is why
.8b83	18		clc		                clc
.8b84	65 00		adc $00		                adc CP
.8b86	85 00		sta $00		                sta CP
.8b88	90 02		bcc $8b8c	                bcc +
.8b8a	e6 01		inc $01		                inc CP+1
.8b8c					+
.8b8c	a5 24		lda $24		                lda tmp1
.8b8e	f0 17		beq $8ba7	                beq _compile_do
.8b90	a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b92	5a		phy		                phy             ; save counter to calculate new CP
.8b93					-
.8b93	b9 ed 8b	lda $8bed,y	                lda question_do_runtime,y
.8b96	91 00		sta ($00),y	                sta (cp),y
.8b98	88		dey		                dey
.8b99	10 f8		bpl $8b93	                bpl -
.8b9b	68		pla		                pla             ; retrieve counter
.8b9c	18		clc		                clc
.8b9d	65 00		adc $00		                adc cp
.8b9f	85 00		sta $00		                sta cp
.8ba1	a5 01		lda $01		                lda cp+1
.8ba3	69 00		adc #$00	                adc #0          ; only care about carry
.8ba5	85 01		sta $01		                sta cp+1        ; fall through to _compile_do
.8ba7					_compile_do:
.8ba7	a0 24		ldy #$24	                ldy #do_runtime_end-do_runtime  ; counter
.8ba9	5a		phy		                phy             ; save counter to calculate new CP
.8baa					-
.8baa	b9 c9 8b	lda $8bc9,y	                lda do_runtime,y
.8bad	91 00		sta ($00),y	                sta (cp),y
.8baf	88		dey		                dey
.8bb0	10 f8		bpl $8baa	                bpl -
.8bb2	68		pla		                pla             ; retrieve counter
.8bb3	18		clc		                clc
.8bb4	65 00		adc $00		                adc cp
.8bb6	85 00		sta $00		                sta cp
.8bb8	a5 01		lda $01		                lda cp+1
.8bba	69 00		adc #$00	                adc #0          ; only care about carry
.8bbc	85 01		sta $01		                sta cp+1
.8bbe	ca		dex		                dex
.8bbf	ca		dex		                dex
.8bc0	a5 00		lda $00		                lda CP          ; LSB
.8bc2	95 00		sta $00,x	                sta 0,x
.8bc4	a5 01		lda $01		                lda CP+1        ; MSB
.8bc6	95 01		sta $01,x	                sta 1,x
.8bc8					z_question_do:
.8bc8	60		rts		z_do:           rts
.8bc9					do_runtime:
.8bc9	38		sec		                sec
.8bca	a9 00		lda #$00	                lda #0
.8bcc	f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8bce	95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8bd0	a9 80		lda #$80	                lda #$80
.8bd2	f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8bd4	95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8bd6	48		pha		                pha             ; FUFA replaces limit on R stack
.8bd7	b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8bd9	48		pha		                pha
.8bda	18		clc		                clc
.8bdb	b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8bdd	75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8bdf	95 00		sta $00,x	                sta 0,x
.8be1	b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8be3	75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8be5	48		pha		                pha
.8be6	b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8be8	48		pha		                pha
.8be9	e8		inx		                inx
.8bea	e8		inx		                inx
.8beb	e8		inx		                inx
.8bec	e8		inx		                inx             ; no RTS because this is copied into code
.8bed					do_runtime_end:
.8bed					question_do_runtime:
.8bed	20 c4 a3	jsr $a3c4	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8bf0	20 da 8e	jsr $8eda	                jsr xt_equal            ; ( -- n1 n2 f )
.8bf3	b5 00		lda $00,x	                lda 0,x
.8bf5	15 01		ora $01,x	                ora 1,x
.8bf7	f0 06		beq $8bff	                beq _do_do
.8bf9	8a		txa		                txa
.8bfa	18		clc		                clc
.8bfb	69 06		adc #$06	                adc #6
.8bfd	aa		tax		                tax
.8bfe	60		rts		                rts
.8bff					_do_do:
.8bff	e8		inx		                inx             ; clear flag from EQUAL off stack
.8c00	e8		inx		                inx             ; no RTS because this is copied into code
.8c01					question_do_runtime_end:
.8c01					xt_does:
.8c01	a0 8c		ldy #$8c	                ldy #>does_runtime
.8c03	a9 10		lda #$10	                lda #<does_runtime
.8c05	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.8c08	a0 d7		ldy #$d7	                ldy #>dodoes
.8c0a	a9 39		lda #$39	                lda #<dodoes
.8c0c	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.8c0f	60		rts		z_does:         rts
.8c10					does_runtime:
.8c10	7a		ply		                ply             ; LSB
.8c11	68		pla		                pla             ; MSB
.8c12	c8		iny		                iny
.8c13	d0 01		bne $8c16	                bne +
.8c15	1a		inc a		                ina
.8c16					+
.8c16	84 24		sty $24		                sty tmp1
.8c18	85 25		sta $25		                sta tmp1+1
.8c1a	20 92 d7	jsr $d792	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8c1d	a5 02		lda $02		                lda dp
.8c1f	18		clc		                clc
.8c20	69 04		adc #$04	                adc #4
.8c22	85 26		sta $26		                sta tmp2
.8c24	a5 03		lda $03		                lda dp+1
.8c26	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c28	85 27		sta $27		                sta tmp2+1
.8c2a	b2 26		lda ($26)	                lda (tmp2)
.8c2c	18		clc		                clc
.8c2d	69 01		adc #$01	                adc #1
.8c2f	85 28		sta $28		                sta tmp3
.8c31	a0 01		ldy #$01	                ldy #1
.8c33	b1 26		lda ($26),y	                lda (tmp2),y
.8c35	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c37	85 29		sta $29		                sta tmp3+1
.8c39	a5 24		lda $24		                lda tmp1        ; LSB
.8c3b	92 28		sta ($28)	                sta (tmp3)
.8c3d	a5 25		lda $25		                lda tmp1+1
.8c3f	91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8c41	60		rts		                rts
.8c42					xt_dot:
.8c42	20 50 d8	jsr $d850	                jsr underflow_1
.8c45	20 bb 8d	jsr $8dbb	                jsr xt_dup                      ; ( n n )
.8c48	20 23 81	jsr $8123	                jsr xt_abs                      ; ( n u )
.8c4b	20 b4 a7	jsr $a7b4	                jsr xt_zero                     ; ( n u 0 )
.8c4e	20 66 93	jsr $9366	                jsr xt_less_number_sign         ; ( n u 0 )
.8c51	20 ea 97	jsr $97ea	                jsr xt_number_sign_s            ; ( n ud )
.8c54	20 63 9b	jsr $9b63	                jsr xt_rot                      ; ( ud n )
.8c57	20 f3 9f	jsr $9ff3	                jsr xt_sign                     ; ( ud )
.8c5a	20 c8 97	jsr $97c8	                jsr xt_number_sign_greater      ; ( addr u )
.8c5d	20 0f a5	jsr $a50f	                jsr xt_type
.8c60	20 2a a1	jsr $a12a	                jsr xt_space
.8c63	60		rts		z_dot:          rts
.8c64					xt_dot_paren:
.8c64	ca		dex		                dex
.8c65	ca		dex		                dex
.8c66	a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c68	95 00		sta $00,x	                sta 0,x
.8c6a	74 01		stz $01,x	                stz 1,x
.8c6c	20 46 99	jsr $9946	                jsr xt_parse
.8c6f	20 0f a5	jsr $a50f	                jsr xt_type
.8c72	60		rts		z_dot_paren:    rts
.8c73					xt_dot_quote:
.8c73	20 5b 9d	jsr $9d5b	                jsr xt_s_quote
.8c76	a0 a5		ldy #$a5	                ldy #>xt_type
.8c78	a9 0f		lda #$0f	                lda #<xt_type
.8c7a	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.8c7d	60		rts		z_dot_quote:    rts
.8c7e					xt_dot_r:
.8c7e	20 55 d8	jsr $d855	                jsr underflow_2
.8c81	20 7c a3	jsr $a37c	                jsr xt_to_r
.8c84	20 bb 8d	jsr $8dbb	                jsr xt_dup
.8c87	20 23 81	jsr $8123	                jsr xt_abs
.8c8a	20 b4 a7	jsr $a7b4	                jsr xt_zero
.8c8d	20 66 93	jsr $9366	                jsr xt_less_number_sign
.8c90	20 ea 97	jsr $97ea	                jsr xt_number_sign_s
.8c93	20 63 9b	jsr $9b63	                jsr xt_rot
.8c96	20 f3 9f	jsr $9ff3	                jsr xt_sign
.8c99	20 c8 97	jsr $97c8	                jsr xt_number_sign_greater
.8c9c	20 9e 9a	jsr $9a9e	                jsr xt_r_from
.8c9f	20 9f 98	jsr $989f	                jsr xt_over
.8ca2	20 5c 95	jsr $955c	                jsr xt_minus
.8ca5	20 30 a1	jsr $a130	                jsr xt_spaces
.8ca8	20 0f a5	jsr $a50f	                jsr xt_type
.8cab	60		rts		z_dot_r:        rts
.8cac					xt_dot_s:
.8cac	20 02 8b	jsr $8b02	                jsr xt_depth    ; ( -- u )
.8caf	a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8cb1	20 02 8e	jsr $8e02	                jsr emit_a
.8cb4	b5 00		lda $00,x	                lda 0,x
.8cb6	48		pha		                pha
.8cb7	ca		dex		                dex             ; DUP
.8cb8	ca		dex		                dex
.8cb9	95 00		sta $00,x	                sta 0,x
.8cbb	74 01		stz $01,x	                stz 1,x
.8cbd	20 bd d8	jsr $d8bd	                jsr print_u
.8cc0	a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8cc2	20 02 8e	jsr $8e02	                jsr emit_a
.8cc5	a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8cc7	20 02 8e	jsr $8e02	                jsr emit_a
.8cca	e8		inx		                inx
.8ccb	e8		inx		                inx
.8ccc	e0 78		cpx #$78	                cpx #dsp0
.8cce	f0 1e		beq $8cee	                beq _done
.8cd0					_have_stack:
.8cd0	7a		ply		                ply
.8cd1	a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8cd3	85 28		sta $28		                sta tmp3
.8cd5	64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8cd7					_loop:
.8cd7	ca		dex		                dex
.8cd8	ca		dex		                dex
.8cd9	b2 28		lda ($28)	                lda (tmp3)
.8cdb	95 01		sta $01,x	                sta 1,x
.8cdd	c6 28		dec $28		                dec tmp3
.8cdf	b2 28		lda ($28)	                lda (tmp3)
.8ce1	95 00		sta $00,x	                sta 0,x
.8ce3	c6 28		dec $28		                dec tmp3
.8ce5	5a		phy		                phy
.8ce6	20 42 8c	jsr $8c42	                jsr xt_dot
.8ce9	7a		ply		                ply
.8cea	88		dey		                dey
.8ceb	d0 ea		bne $8cd7	                bne _loop
.8ced	48		pha		                pha             ; dummy to balance stack
.8cee					_done:
.8cee	68		pla		                pla
.8cef	60		rts		z_dot_s:        rts
.8cf0					xt_d_dot:
.8cf0	20 55 d8	jsr $d855	                jsr underflow_2
.8cf3	20 99 a3	jsr $a399	                jsr xt_tuck
.8cf6	20 92 8a	jsr $8a92	                jsr xt_dabs
.8cf9	20 66 93	jsr $9366	                jsr xt_less_number_sign
.8cfc	20 ea 97	jsr $97ea	                jsr xt_number_sign_s
.8cff	20 63 9b	jsr $9b63	                jsr xt_rot
.8d02	20 f3 9f	jsr $9ff3	                jsr xt_sign
.8d05	20 c8 97	jsr $97c8	                jsr xt_number_sign_greater
.8d08	20 0f a5	jsr $a50f	                jsr xt_type
.8d0b	20 2a a1	jsr $a12a	                jsr xt_space
.8d0e	60		rts		z_d_dot:        rts
.8d0f					xt_d_dot_r:
.8d0f	20 5a d8	jsr $d85a	                jsr underflow_3
.8d12	20 7c a3	jsr $a37c	                jsr xt_to_r
.8d15	20 99 a3	jsr $a399	                jsr xt_tuck
.8d18	20 92 8a	jsr $8a92	                jsr xt_dabs
.8d1b	20 66 93	jsr $9366	                jsr xt_less_number_sign
.8d1e	20 ea 97	jsr $97ea	                jsr xt_number_sign_s
.8d21	20 63 9b	jsr $9b63	                jsr xt_rot
.8d24	20 f3 9f	jsr $9ff3	                jsr xt_sign
.8d27	20 c8 97	jsr $97c8	                jsr xt_number_sign_greater
.8d2a	20 9e 9a	jsr $9a9e	                jsr xt_r_from
.8d2d	20 9f 98	jsr $989f	                jsr xt_over
.8d30	20 5c 95	jsr $955c	                jsr xt_minus
.8d33	20 30 a1	jsr $a130	                jsr xt_spaces
.8d36	20 0f a5	jsr $a50f	                jsr xt_type
.8d39	60		rts		z_d_dot_r:      rts
.8d3a					xt_drop:
.8d3a	20 50 d8	jsr $d850	                jsr underflow_1
.8d3d	e8		inx		                inx
.8d3e	e8		inx		                inx
.8d3f	60		rts		z_drop:         rts
.8d40					xt_dump:
.8d40	20 55 d8	jsr $d855	                jsr underflow_2
.8d43					_row:
.8d43	a0 10		ldy #$10	                ldy #16
.8d45	64 26		stz $26		                stz tmp2
.8d47	20 6f 89	jsr $896f	                jsr xt_cr
.8d4a	b5 03		lda $03,x	                lda 3,x
.8d4c	20 60 d7	jsr $d760	                jsr byte_to_ascii
.8d4f	b5 02		lda $02,x	                lda 2,x
.8d51	20 60 d7	jsr $d760	                jsr byte_to_ascii
.8d54	20 2a a1	jsr $a12a	                jsr xt_space
.8d57	20 2a a1	jsr $a12a	                jsr xt_space
.8d5a					_loop:
.8d5a	b5 00		lda $00,x	                lda 0,x
.8d5c	15 01		ora $01,x	                ora 1,x
.8d5e	f0 39		beq $8d99	                beq _all_printed
.8d60	a1 02		lda ($02,x)	                lda (2,x)
.8d62	48		pha		                pha                     ; byte_to_ascii destroys A
.8d63	20 60 d7	jsr $d760	                jsr byte_to_ascii
.8d66	20 2a a1	jsr $a12a	                jsr xt_space
.8d69	68		pla		                pla
.8d6a	20 36 d8	jsr $d836	                jsr is_printable
.8d6d	b0 02		bcs $8d71	                bcs _printable
.8d6f	a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d71					_printable:
.8d71	5a		phy		                phy                     ; save counter
.8d72	a4 26		ldy $26		                ldy tmp2
.8d74	91 00		sta ($00),y	                sta (cp),y
.8d76	e6 26		inc $26		                inc tmp2
.8d78	7a		ply		                ply
.8d79	c0 09		cpy #$09	                cpy #9
.8d7b	d0 03		bne $8d80	                bne _next_char
.8d7d	20 2a a1	jsr $a12a	                jsr xt_space
.8d80					_next_char:
.8d80	f6 02		inc $02,x	                inc 2,x
.8d82	d0 02		bne $8d86	                bne _counter
.8d84	f6 03		inc $03,x	                inc 3,x
.8d86					_counter:
.8d86	b5 00		lda $00,x	                lda 0,x
.8d88	d0 02		bne $8d8c	                bne +
.8d8a	d6 01		dec $01,x	                dec 1,x
.8d8c					+
.8d8c	d6 00		dec $00,x	                dec 0,x
.8d8e	88		dey		                dey
.8d8f	d0 c9		bne $8d5a	                bne _loop               ; next byte
.8d91	20 2a a1	jsr $a12a	                jsr xt_space
.8d94	20 a7 8d	jsr $8da7	                jsr dump_print_ascii
.8d97	80 aa		bra $8d43	                bra _row                ; new row
.8d99					_all_printed:
.8d99	a5 26		lda $26		                lda tmp2
.8d9b	f0 06		beq $8da3	                beq _done
.8d9d	20 2a a1	jsr $a12a	                jsr xt_space
.8da0	20 a7 8d	jsr $8da7	                jsr dump_print_ascii
.8da3					_done:
.8da3	20 bc a3	jsr $a3bc	                jsr xt_two_drop         ; one byte less than 4x INX
.8da6	60		rts		z_dump:         rts
.8da7					dump_print_ascii:
.8da7	a0 00		ldy #$00	                ldy #0
.8da9					_ascii_loop:
.8da9	b1 00		lda ($00),y	                lda (cp),y
.8dab	20 02 8e	jsr $8e02	                jsr emit_a
.8dae	c8		iny		                iny
.8daf	c0 08		cpy #$08	                cpy #8
.8db1	d0 03		bne $8db6	                bne +
.8db3	20 2a a1	jsr $a12a	                jsr xt_space
.8db6					+
.8db6	c6 26		dec $26		                dec tmp2
.8db8	d0 ef		bne $8da9	                bne _ascii_loop
.8dba	60		rts		                rts
.8dbb					xt_dup:
.8dbb	20 50 d8	jsr $d850	                jsr underflow_1
.8dbe	ca		dex		                dex
.8dbf	ca		dex		                dex
.8dc0	b5 02		lda $02,x	                lda 2,x         ; LSB
.8dc2	95 00		sta $00,x	                sta 0,x
.8dc4	b5 03		lda $03,x	                lda 3,x         ; MSB
.8dc6	95 01		sta $01,x	                sta 1,x
.8dc8	60		rts		z_dup:          rts
.8dc9					xt_ed:
.8dc9	20 8e b5	jsr $b58e	                jsr ed6502      ; kept in separate file
.8dcc	60		rts		z_ed:           rts
.8dcd					xt_else:
.8dcd					xt_endof:
.8dcd	a0 8d		ldy #$8d	                ldy #>branch_runtime
.8dcf	a9 e7		lda #$e7	                lda #<branch_runtime
.8dd1	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.8dd4	20 7e 91	jsr $917e	                jsr xt_here
.8dd7	20 b4 a7	jsr $a7b4	                jsr xt_zero
.8dda	20 7a 87	jsr $877a	                jsr xt_comma
.8ddd	20 7e 91	jsr $917e	                jsr xt_here
.8de0	20 63 9b	jsr $9b63	                jsr xt_rot
.8de3	20 99 a1	jsr $a199	                jsr xt_store
.8de6					z_else:
.8de6					z_endof:
.8de6	60		rts		                rts
.8de7					branch_runtime:
.8de7	68		pla		                pla
.8de8	85 22		sta $22		                sta tmpbranch
.8dea	68		pla		                pla
.8deb	85 23		sta $23		                sta tmpbranch+1
.8ded	a0 01		ldy #$01	                ldy #1
.8def	b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8df1	85 24		sta $24		                sta tmp1
.8df3	c8		iny		                iny
.8df4	b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8df6	85 25		sta $25		                sta tmp1+1
.8df8	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8dfb					xt_emit:
.8dfb	20 50 d8	jsr $d850	                jsr underflow_1
.8dfe	b5 00		lda $00,x	                lda 0,x
.8e00	e8		inx		                inx
.8e01	e8		inx		                inx
.8e02					emit_a:
.8e02	6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8e05					z_emit:
.8e05					xt_empty_buffers:
.8e05	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8e07	a9 00		lda #$00	                lda #0
.8e09	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8e0b					z_empty_buffers:
.8e0b	60		rts		                rts
.8e0c					xt_endcase:
.8e0c	a0 8d		ldy #$8d	                ldy #>xt_drop
.8e0e	a9 3a		lda #$3a	                lda #<xt_drop
.8e10	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.8e13					_endcase_loop:
.8e13	b5 00		lda $00,x	                lda 0,x
.8e15	15 01		ora $01,x	                ora 1,x
.8e17	f0 05		beq $8e1e	                beq _done
.8e19	20 ce a1	jsr $a1ce	                jsr xt_then
.8e1c	80 f5		bra $8e13	                bra _endcase_loop
.8e1e					_done:
.8e1e	e8		inx		                inx
.8e1f	e8		inx		                inx
.8e20	60		rts		z_endcase:      rts
.8e21					xt_environment_q:
.8e21	20 50 d8	jsr $d850	                jsr underflow_1
.8e24	a0 00		ldy #$00	                ldy #00                 ; counter for table
.8e26	5a		phy		                phy
.8e27					_table_loop:
.8e27	20 c4 a3	jsr $a3c4	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e2a	ca		dex		                dex
.8e2b	ca		dex		                dex                     ; ( addr u addr u ? )
.8e2c	b9 9e 8e	lda $8e9e,y	                lda env_table_single,y
.8e2f	95 00		sta $00,x	                sta 0,x
.8e31	c8		iny		                iny
.8e32	b9 9e 8e	lda $8e9e,y	                lda env_table_single,y
.8e35	95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e37	c8		iny		                iny
.8e38	15 00		ora $00,x	                ora 0,x
.8e3a	f0 4d		beq $8e89	                beq _table_done
.8e3c	5a		phy		                phy                     ; save Y, which is used by COUNT
.8e3d	20 5b 89	jsr $895b	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e40	20 94 87	jsr $8794	                jsr xt_compare          ; ( addr u f )
.8e43	7a		ply		                ply
.8e44	b5 00		lda $00,x	                lda 0,x
.8e46	15 01		ora $01,x	                ora 1,x
.8e48	f0 04		beq $8e4e	                beq _got_result
.8e4a	e8		inx		                inx                     ; DROP, now ( addr u )
.8e4b	e8		inx		                inx
.8e4c	80 d9		bra $8e27	                bra _table_loop
.8e4e					_got_result:
.8e4e	e8		inx		                inx                     ; drop flag, now ( addr u )
.8e4f	e8		inx		                inx
.8e50	88		dey		                dey                     ; go back to index we had
.8e51	88		dey		                dey
.8e52	68		pla		                pla
.8e53	d0 0d		bne $8e62	                bne _double_result
.8e55	b9 bc 8e	lda $8ebc,y	                lda env_results_single,y
.8e58	95 02		sta $02,x	                sta 2,x
.8e5a	c8		iny		                iny
.8e5b	b9 bc 8e	lda $8ebc,y	                lda env_results_single,y
.8e5e	95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e60	80 1f		bra $8e81	                bra _set_flag
.8e62					_double_result:
.8e62	ca		dex		                dex                     ; ( addr u ? )
.8e63	ca		dex		                dex
.8e64	98		tya		                tya
.8e65	38		sec		                sec
.8e66	e9 18		sbc #$18	                sbc #24
.8e68	0a		asl a		                asl
.8e69	a8		tay		                tay
.8e6a	b9 d2 8e	lda $8ed2,y	                lda env_results_double,y
.8e6d	95 02		sta $02,x	                sta 2,x
.8e6f	c8		iny		                iny
.8e70	b9 d2 8e	lda $8ed2,y	                lda env_results_double,y
.8e73	95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e75	c8		iny		                iny
.8e76	b9 d2 8e	lda $8ed2,y	                lda env_results_double,y
.8e79	95 04		sta $04,x	                sta 4,x
.8e7b	c8		iny		                iny
.8e7c	b9 d2 8e	lda $8ed2,y	                lda env_results_double,y
.8e7f	95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e81					_set_flag:
.8e81	a9 ff		lda #$ff	                lda #$ff
.8e83	95 00		sta $00,x	                sta 0,x
.8e85	95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e87	80 14		bra $8e9d	                bra _done
.8e89					_table_done:
.8e89	68		pla		                pla
.8e8a	d0 09		bne $8e95	                bne _no_match
.8e8c	1a		inc a		                ina
.8e8d	48		pha		                pha
.8e8e	8a		txa		                txa
.8e8f	18		clc		                clc
.8e90	69 06		adc #$06	                adc #6                  ; skip six bytes
.8e92	aa		tax		                tax                     ; ( addr u )
.8e93	80 92		bra $8e27	                bra _table_loop
.8e95					_no_match:
.8e95	8a		txa		                txa
.8e96	18		clc		                clc
.8e97	69 0a		adc #$0a	                adc #10
.8e99	aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e9a	20 85 8f	jsr $8f85	                jsr xt_false
.8e9d					_done:
.8e9d					z_environment_q:
.8e9d	60		rts		                rts
.8e9e					env_table_single:
>8e9e	73 d6 83 d6 89 d6 8e d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8ea6	a0 d6
>8ea8	a8 d6 b1 d6 b7 d6 bd d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8eb0	d0 d6 dc d6 00 00		        .word envs_sc, envs_wl, 0000
.8eb6					env_table_double:
>8eb6	e6 d6 ec d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8ebc					env_results_single:
>8ebc	ff 7f				        .word $7FFF     ; /COUNTED-STRING
>8ebe	ff 00				        .word $00FF     ; /HOLD
>8ec0	54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8ec2	08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8ec4	00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8ec6	ff 00				        .word $00FF     ; MAX-CHAR
>8ec8	ff 7f				        .word $7FFF     ; MAX-N
>8eca	ff ff				        .word $FFFF     ; MAX-U
>8ecc	80 00				        .word $0080     ; RETURN-STACK-CELLS
>8ece	20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8ed0	09 00				        .word $0009     ; WORDLISTS
.8ed2					env_results_double:
>8ed2	ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8ed6	ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8eda					xt_equal:
.8eda	20 55 d8	jsr $d855	                jsr underflow_2
.8edd	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8edf	d5 02		cmp $02,x	                cmp 2,x
.8ee1	d0 0a		bne $8eed	                bne _false
.8ee3	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8ee5	d5 03		cmp $03,x	                cmp 3,x
.8ee7	d0 04		bne $8eed	                bne _false
.8ee9	a9 ff		lda #$ff	                lda #$ff
.8eeb	80 02		bra $8eef	                bra _done
.8eed	a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8eef	95 02		sta $02,x	_done:          sta 2,x
.8ef1	95 03		sta $03,x	                sta 3,x
.8ef3	e8		inx		                inx
.8ef4	e8		inx		                inx
.8ef5	60		rts		z_equal:        rts
.8ef6					xt_blank:
.8ef6	ca		dex		                dex
.8ef7	ca		dex		                dex
.8ef8	a9 20		lda #$20	                lda #AscSP
.8efa	95 00		sta $00,x	                sta 0,x
.8efc	74 01		stz $01,x	                stz 1,x
.8efe	80 06		bra $8f06	                bra xt_fill     ; skip over code for ERASE
.8f00					xt_erase:
.8f00	ca		dex		                dex
.8f01	ca		dex		                dex
.8f02	74 00		stz $00,x	                stz 0,x
.8f04	74 01		stz $01,x	                stz 1,x
.8f06					xt_fill:
.8f06	20 5a d8	jsr $d85a	                jsr underflow_3
.8f09	b5 04		lda $04,x	                lda 4,x         ; LSB
.8f0b	85 24		sta $24		                sta tmp1
.8f0d	b5 05		lda $05,x	                lda 5,x
.8f0f	85 25		sta $25		                sta tmp1+1
.8f11	b5 02		lda $02,x	                lda 2,x
.8f13	85 26		sta $26		                sta tmp2
.8f15	b5 03		lda $03,x	                lda 3,x
.8f17	85 27		sta $27		                sta tmp2+1
.8f19	b5 00		lda $00,x	                lda 0,x
.8f1b	a8		tay		                tay
.8f1c					_loop:
.8f1c	a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8f1e	c5 25		cmp $25		                cmp tmp1+1
.8f20	90 21		bcc $8f43	                bcc _done               ; RAM_END < TMP1, so leave
.8f22	d0 06		bne $8f2a	                bne _check_counter      ; RAM_END is not smaller and not equal
.8f24	a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8f26	c5 24		cmp $24		                cmp tmp1
.8f28	90 19		bcc $8f43	                bcc _done               ; RAM_END < TMP1, so leave
.8f2a					_check_counter:
.8f2a	a5 26		lda $26		                lda tmp2
.8f2c	05 27		ora $27		                ora tmp2+1
.8f2e	f0 13		beq $8f43	                beq _done
.8f30	98		tya		                tya
.8f31	92 24		sta ($24)	                sta (tmp1)
.8f33	a5 26		lda $26		                lda tmp2
.8f35	d0 02		bne $8f39	                bne +
.8f37	c6 27		dec $27		                dec tmp2+1
.8f39	c6 26		dec $26		+               dec tmp2
.8f3b	e6 24		inc $24		                inc tmp1
.8f3d	d0 dd		bne $8f1c	                bne _loop
.8f3f	e6 25		inc $25		                inc tmp1+1
.8f41	80 d9		bra $8f1c	                bra _loop
.8f43					_done:
.8f43	8a		txa		                txa
.8f44	18		clc		                clc
.8f45	69 06		adc #$06	                adc #6
.8f47	aa		tax		                tax
.8f48					z_blank:
.8f48					z_erase:
.8f48	60		rts		z_fill:         rts
.8f49					xt_execute:
.8f49	20 50 d8	jsr $d850	                jsr underflow_1
.8f4c	20 50 8f	jsr $8f50	                jsr doexecute   ; do not combine to JMP (native coding)
.8f4f	60		rts		z_execute:      rts
.8f50					doexecute:
.8f50	b5 00		lda $00,x	                lda 0,x
.8f52	85 0e		sta $0e		                sta ip
.8f54	b5 01		lda $01,x	                lda 1,x
.8f56	85 0f		sta $0f		                sta ip+1
.8f58	e8		inx		                inx
.8f59	e8		inx		                inx
.8f5a	6c 0e 00	jmp ($000e)	                jmp (ip)
.8f5d					xt_execute_parsing:
.8f5d	20 5a d8	jsr $d85a	                jsr underflow_3
.8f60	20 6e 92	jsr $926e	                jsr xt_input_to_r       ; save normal input for later
.8f63	20 7a 96	jsr $967a	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f66	b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f68	85 0a		sta $0a		                sta ciblen
.8f6a	b5 01		lda $01,x	                lda 1,x
.8f6c	85 0b		sta $0b		                sta ciblen+1
.8f6e	b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f70	85 08		sta $08		                sta cib
.8f72	b5 03		lda $03,x	                lda 3,x
.8f74	85 09		sta $09		                sta cib+1
.8f76	64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f78	64 0d		stz $0d		                stz toin+1
.8f7a	20 bc a3	jsr $a3bc	                jsr xt_two_drop         ; 2DROP ( xt )
.8f7d	20 49 8f	jsr $8f49	                jsr xt_execute
.8f80	20 af 9a	jsr $9aaf	                jsr xt_r_to_input
.8f83					z_execute_parsing:
.8f83	60		rts		                rts
.8f84					xt_exit:
.8f84	60		rts		                rts             ; keep before z_exit
.8f85					z_exit:
.8f85					xt_false:
.8f85	ca		dex		                dex
.8f86	ca		dex		                dex
.8f87	74 00		stz $00,x	                stz 0,x
.8f89	74 01		stz $01,x	                stz 1,x
.8f8b	60		rts		z_false:        rts
.8f8c					xt_fetch:
.8f8c	20 50 d8	jsr $d850	                jsr underflow_1
.8f8f	a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f91	a8		tay		                tay
.8f92	f6 00		inc $00,x	                inc 0,x
.8f94	d0 02		bne $8f98	                bne +
.8f96	f6 01		inc $01,x	                inc 1,x
.8f98					+
.8f98	a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f9a	95 01		sta $01,x	                sta 1,x
.8f9c	94 00		sty $00,x	                sty 0,x
.8f9e	60		rts		z_fetch:        rts
.8f9f					xt_find:
.8f9f	20 50 d8	jsr $d850	                jsr underflow_1
.8fa2	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8fa4	48		pha		                pha
.8fa5	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8fa7	48		pha		                pha
.8fa8	20 5b 89	jsr $895b	                jsr xt_count            ; ( caddr -- addr u )
.8fab	20 e7 8f	jsr $8fe7	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8fae	b5 00		lda $00,x	                lda 0,x
.8fb0	15 01		ora $01,x	                ora 1,x
.8fb2	d0 0b		bne $8fbf	                bne _found_word
.8fb4	20 85 8f	jsr $8f85	                jsr xt_false            ; ( 0 0 )
.8fb7	68		pla		                pla                     ; LSB of address
.8fb8	95 02		sta $02,x	                sta 2,x
.8fba	68		pla		                pla
.8fbb	95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8fbd	80 27		bra $8fe6	                bra _done               ; ( addr 0 )
.8fbf					_found_word:
.8fbf	68		pla		                pla
.8fc0	68		pla		                pla
.8fc1	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( nt nt )
.8fc4	20 ed 95	jsr $95ed	                jsr xt_name_to_int      ; ( nt xt )
.8fc7	20 ba a1	jsr $a1ba	                jsr xt_swap             ; ( xt nt )
.8fca	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fcc	f6 00		inc $00,x	                inc 0,x
.8fce	d0 02		bne $8fd2	                bne +
.8fd0	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fd2					+
.8fd2	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fd4	29 04		and #$04	                and #IM
.8fd6	d0 08		bne $8fe0	                bne _immediate          ; bit set, we're immediate
.8fd8	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8fda	95 00		sta $00,x	                sta 0,x
.8fdc	95 01		sta $01,x	                sta 1,x
.8fde	80 06		bra $8fe6	                bra _done
.8fe0					_immediate:
.8fe0	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8fe2	95 00		sta $00,x	                sta 0,x
.8fe4	74 01		stz $01,x	                stz 1,x
.8fe6					_done:
.8fe6	60		rts		z_find:         rts
.8fe7					xt_find_name:
.8fe7	20 55 d8	jsr $d855	                jsr underflow_2
.8fea	b5 00		lda $00,x	                lda 0,x
.8fec	15 01		ora $01,x	                ora 1,x
.8fee	d0 03		bne $8ff3	                bne _nonempty
.8ff0	4c 8c 90	jmp $908c	                jmp _fail_done
.8ff3					_nonempty:
.8ff3	64 28		stz $28		                stz tmp3                ; Start at the beginning
.8ff5					_wordlist_loop:
.8ff5	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8ff7	a5 28		lda $28		                lda tmp3
.8ff9	d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8ffb	d0 03		bne $9000	                bne _have_string
.8ffd	4c 8c 90	jmp $908c	                jmp _fail_done
.9000					_have_string:
.9000	18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9001	69 1f		adc #$1f	                adc #search_order_offset
.9003	a8		tay		                tay
.9004	b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.9006	0a		asl a		                asl                     ; Turn offset into cells offset.
.9007	18		clc		                clc
.9008	69 06		adc #$06	                adc #wordlists_offset
.900a	a8		tay		                tay
.900b	b1 1e		lda ($1e),y	                lda (up),y
.900d	85 24		sta $24		                sta tmp1
.900f	c8		iny		                iny
.9010	b1 1e		lda ($1e),y	                lda (up),y
.9012	85 25		sta $25		                sta tmp1+1
.9014	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9016	85 26		sta $26		                sta tmp2
.9018	b5 03		lda $03,x	                lda 3,x
.901a	85 27		sta $27		                sta tmp2+1
.901c					_loop:
.901c	b2 24		lda ($24)	                lda (tmp1)
.901e	d5 00		cmp $00,x	                cmp 0,x
.9020	d0 54		bne $9076	                bne _next_entry
.9022					_compare_string:
.9022	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9024	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9026	b0 07		bcs $902f	                bcs _compare_first
.9028	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.902a	90 03		bcc $902f	                bcc _compare_first
.902c	18		clc		                clc
.902d	69 20		adc #$20	                adc #$20
.902f					_compare_first:
.902f	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9031	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9033	d0 41		bne $9076	                bne _next_entry
.9035	b5 00		lda $00,x	                lda 0,x
.9037	3a		dec a		                dea
.9038	f0 2c		beq $9066	                beq _success
.903a	a5 24		lda $24		                lda tmp1
.903c	48		pha		                pha             ; Preserve tmp1 on the return stack.
.903d	18		clc		                clc
.903e	69 08		adc #$08	                adc #8
.9040	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9042	a5 25		lda $25		                lda tmp1+1
.9044	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9045	69 00		adc #$00	                adc #0          ; we only need the carry
.9047	85 25		sta $25		                sta tmp1+1
.9049	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.904b	88		dey		                dey
.904c					_string_loop:
.904c	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.904e	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9050	b0 07		bcs $9059	                bcs _check_char
.9052	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9054	90 03		bcc $9059	                bcc _check_char
.9056	18		clc		                clc
.9057	69 20		adc #$20	                adc #$20
.9059					_check_char:
.9059	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.905b	d0 13		bne $9070	                bne _next_entry_tmp1
.905d	88		dey		                dey
.905e	d0 ec		bne $904c	                bne _string_loop
.9060					_success_tmp1:
.9060	68		pla		                pla             ; Restore tmp1 from the return stack.
.9061	85 25		sta $25		                sta tmp1+1
.9063	68		pla		                pla
.9064	85 24		sta $24		                sta tmp1
.9066					_success:
.9066	a5 24		lda $24		                lda tmp1
.9068	95 02		sta $02,x	                sta 2,x
.906a	a5 25		lda $25		                lda tmp1+1
.906c	95 03		sta $03,x	                sta 3,x
.906e	80 20		bra $9090	                bra _done
.9070					_next_entry_tmp1:
.9070	68		pla		                pla             ; Restore tmp1 from the return stack.
.9071	85 25		sta $25		                sta tmp1+1
.9073	68		pla		                pla
.9074	85 24		sta $24		                sta tmp1
.9076					_next_entry:
.9076	a0 02		ldy #$02	                ldy #2
.9078	b1 24		lda ($24),y	                lda (tmp1),y
.907a	48		pha		                pha
.907b	c8		iny		                iny
.907c	b1 24		lda ($24),y	                lda (tmp1),y
.907e	85 25		sta $25		                sta tmp1+1
.9080	68		pla		                pla
.9081	85 24		sta $24		                sta tmp1
.9083	05 25		ora $25		                ora tmp1+1
.9085	d0 95		bne $901c	                bne _loop
.9087	e6 28		inc $28		                inc tmp3
.9089	4c f5 8f	jmp $8ff5	                jmp _wordlist_loop
.908c					_fail_done:
.908c	74 02		stz $02,x	                stz 2,x         ; failure flag
.908e	74 03		stz $03,x	                stz 3,x
.9090					_done:
.9090	e8		inx		                inx
.9091	e8		inx		                inx
.9092	60		rts		z_find_name:    rts
.9093					xt_flush:
.9093	20 ca 9e	jsr $9eca	                jsr xt_save_buffers
.9096	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9098	a9 00		lda #$00	                lda #0
.909a	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.909c					z_flush:
.909c	60		rts		                rts
.909d					xt_fm_slash_mod:
.909d	20 5a d8	jsr $d85a	                jsr underflow_3
.90a0	64 26		stz $26		                stz tmp2        ; default: n is positive
.90a2	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90a4	10 0e		bpl $90b4	                bpl _check_d
.90a6	e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.90a8	20 2f 96	jsr $962f	                jsr xt_negate   ; NEGATE
.90ab	20 7c a3	jsr $a37c	                jsr xt_to_r     ; >R
.90ae	20 4d 8b	jsr $8b4d	                jsr xt_dnegate  ; DNEGATE
.90b1	20 9e 9a	jsr $9a9e	                jsr xt_r_from   ; R>
.90b4					_check_d:
.90b4	b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.90b6	10 0d		bpl $90c5	                bpl _multiply
.90b8	18		clc		                clc
.90b9	b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.90bb	75 02		adc $02,x	                adc 2,x         ; LSB of dh
.90bd	95 02		sta $02,x	                sta 2,x
.90bf	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90c1	75 03		adc $03,x	                adc 3,x         ; MSB of dh
.90c3	95 03		sta $03,x	                sta 3,x
.90c5					_multiply:
.90c5	20 c6 a5	jsr $a5c6	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90c8	a5 26		lda $26		                lda tmp2
.90ca	f0 07		beq $90d3	                beq _done
.90cc	e8		inx		                inx             ; pretend that we SWAP
.90cd	e8		inx		                inx
.90ce	20 2f 96	jsr $962f	                jsr xt_negate
.90d1	ca		dex		                dex
.90d2	ca		dex		                dex
.90d3					_done:
.90d3	60		rts		z_fm_slash_mod: rts
.90d4					xt_forth:
.90d4	a0 1f		ldy #$1f	                ldy #search_order_offset
.90d6	a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90d8	91 1e		sta ($1e),y	                sta (up),y
.90da					z_forth:
.90da	60		rts		                rts
.90db					load_evaluate:
.90db	a9 ff		lda #$ff	                lda #$FF
.90dd	85 24		sta $24		                sta tmp1
.90df	80 11		bra $90f2	                bra load_evaluate_start
.90e1					xt_evaluate:
.90e1	20 55 d8	jsr $d855	                jsr underflow_2
.90e4	64 24		stz $24		                stz tmp1
.90e6	b5 00		lda $00,x	                lda 0,x
.90e8	15 01		ora $01,x	                ora 1,x
.90ea	d0 06		bne $90f2	                bne evaluate_got_work
.90ec	e8		inx		                inx
.90ed	e8		inx		                inx
.90ee	e8		inx		                inx
.90ef	e8		inx		                inx
.90f0	80 42		bra $9134	                bra evaluate_done
.90f2					load_evaluate_start:
.90f2					evaluate_got_work:
.90f2	a0 01		ldy #$01	                ldy #blk_offset+1
.90f4	b1 1e		lda ($1e),y	                lda (up),y
.90f6	48		pha		                pha
.90f7	88		dey		                dey
.90f8	b1 1e		lda ($1e),y	                lda (up),y
.90fa	48		pha		                pha
.90fb	a5 24		lda $24		                lda tmp1
.90fd	d0 05		bne $9104	                bne _nozero
.90ff	91 1e		sta ($1e),y	                sta (up),y
.9101	c8		iny		                iny
.9102	91 1e		sta ($1e),y	                sta (up),y
.9104					_nozero:
.9104	20 6e 92	jsr $926e	                jsr xt_input_to_r
.9107	a9 ff		lda #$ff	                lda #$ff
.9109	85 06		sta $06		                sta insrc
.910b	85 07		sta $07		                sta insrc+1
.910d	64 0c		stz $0c		                stz toin
.910f	64 0d		stz $0d		                stz toin+1
.9111	b5 00		lda $00,x	                lda 0,x
.9113	85 0a		sta $0a		                sta ciblen
.9115	b5 01		lda $01,x	                lda 1,x
.9117	85 0b		sta $0b		                sta ciblen+1
.9119	b5 02		lda $02,x	                lda 2,x
.911b	85 08		sta $08		                sta cib
.911d	b5 03		lda $03,x	                lda 3,x
.911f	85 09		sta $09		                sta cib+1
.9121	e8		inx		                inx             ; A clean stack is a clean mind
.9122	e8		inx		                inx
.9123	e8		inx		                inx
.9124	e8		inx		                inx
.9125	20 b8 d7	jsr $d7b8	                jsr interpret   ; ( -- )
.9128	20 af 9a	jsr $9aaf	                jsr xt_r_to_input
.912b	a0 00		ldy #$00	                ldy #blk_offset
.912d	68		pla		                pla
.912e	91 1e		sta ($1e),y	                sta (up),y
.9130	c8		iny		                iny
.9131	68		pla		                pla
.9132	91 1e		sta ($1e),y	                sta (up),y
.9134					evaluate_done:
.9134	60		rts		z_evaluate:     rts
.9135					xt_get_current:
.9135	ca		dex		                dex
.9136	ca		dex		                dex
.9137	a0 04		ldy #$04	                ldy #current_offset
.9139	b1 1e		lda ($1e),y	                lda (up),y
.913b	95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.913d	74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.913f	60		rts		z_get_current:  rts
.9140					xt_get_order:
.9140	a0 1e		ldy #$1e	                ldy #num_order_offset
.9142	b1 1e		lda ($1e),y	                lda (up),y
.9144	85 24		sta $24		                sta tmp1
.9146	f0 16		beq $915e	                beq _done       ; If zero, there are no wordlists.
.9148					_loop:
.9148	c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.914a	a9 1f		lda #$1f	                lda #search_order_offset
.914c	18		clc		                clc
.914d	65 24		adc $24		                adc tmp1
.914f	a8		tay		                tay
.9150	ca		dex		                dex
.9151	ca		dex		                dex
.9152	b1 1e		lda ($1e),y	                lda (up),y
.9154	95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.9156	74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.9158	a9 00		lda #$00	                lda #0
.915a	c5 24		cmp $24		                cmp tmp1
.915c	d0 ea		bne $9148	                bne _loop
.915e					_done:
.915e	ca		dex		                dex
.915f	ca		dex		                dex
.9160	a0 1e		ldy #$1e	                ldy #num_order_offset
.9162	b1 1e		lda ($1e),y	                lda (up),y
.9164	95 00		sta $00,x	                sta 0,x
.9166	74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.9168	60		rts		z_get_order:    rts
.9169					xt_greater_than:
.9169	20 55 d8	jsr $d855	                jsr underflow_2
.916c	a0 00		ldy #$00	                ldy #0          ; default false
.916e	20 77 d7	jsr $d777	                jsr compare_16bit
.9171	f0 03		beq $9176	                beq _false
.9173	10 01		bpl $9176	                bpl _false
.9175	88		dey		                dey
.9176					_false:
.9176	98		tya		                tya
.9177	e8		inx		                inx
.9178	e8		inx		                inx
.9179	95 00		sta $00,x	                sta 0,x
.917b	95 01		sta $01,x	                sta 1,x
.917d	60		rts		z_greater_than: rts
.917e					xt_here:
.917e					xt_asm_arrow:
.917e	ca		dex		                dex
.917f	ca		dex		                dex
.9180	a5 00		lda $00		                lda cp
.9182	95 00		sta $00,x	                sta 0,x
.9184	a5 01		lda $01		                lda cp+1
.9186	95 01		sta $01,x	                sta 1,x
.9188					z_asm_arrow:
.9188	60		rts		z_here:         rts
.9189					xt_hex:
.9189	a9 10		lda #$10	                lda #16
.918b	85 18		sta $18		                sta base
.918d	64 19		stz $19		                stz base+1              ; paranoid
.918f	60		rts		z_hex:          rts
.9190					xt_hexstore:
.9190	20 5a d8	jsr $d85a	                jsr underflow_3
.9193	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; Save copy of original address
.9196	20 ae a4	jsr $a4ae	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9199					_loop:
.9199	b5 00		lda $00,x	                lda 0,x
.919b	15 01		ora $01,x	                ora 1,x
.919d	f0 36		beq $91d5	                beq _done
.919f	20 58 86	jsr $8658	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.91a2	20 ae a4	jsr $a4ae	                jsr xt_two_to_r
.91a5	20 b4 a7	jsr $a7b4	                jsr xt_zero
.91a8	20 b4 a7	jsr $a7b4	                jsr xt_zero
.91ab	20 34 a4	jsr $a434	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.91ae	20 c9 a2	jsr $a2c9	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.91b1	b5 00		lda $00,x	                lda 0,x
.91b3	15 01		ora $01,x	                ora 1,x
.91b5	d0 17		bne $91ce	                bne _have_chars_left
.91b7	20 bc a3	jsr $a3bc	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.91ba	20 8c 8a	jsr $8a8c	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.91bd	20 89 9a	jsr $9a89	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.91c0	20 21 86	jsr $8621	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.91c3	20 9e 9a	jsr $9a9e	                jsr xt_r_from           ; R>
.91c6	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+
.91c9	20 7c a3	jsr $a37c	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91cc	80 cb		bra $9199	                bra _loop
.91ce					_have_chars_left:
.91ce	8a		txa		                txa
.91cf	18		clc		                clc
.91d0	69 08		adc #$08	                adc #8
.91d2	aa		tax		                tax
.91d3	80 c4		bra $9199	                bra _loop
.91d5					_done:
.91d5	e8		inx		                inx
.91d6	e8		inx		                inx
.91d7	e8		inx		                inx
.91d8	e8		inx		                inx                     ; 2DROP
.91d9	20 34 a4	jsr $a434	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91dc	20 ba a1	jsr $a1ba	                jsr xt_swap
.91df	20 5c 95	jsr $955c	                jsr xt_minus            ; ( n )
.91e2	60		rts		z_hexstore:     rts
.91e3					xt_hold:
.91e3	20 50 d8	jsr $d850	                jsr underflow_1
.91e6	a5 34		lda $34		                lda tohold
.91e8	d0 02		bne $91ec	                bne +
.91ea	c6 35		dec $35		                dec tohold+1
.91ec					+
.91ec	c6 34		dec $34		                dec tohold
.91ee	b5 00		lda $00,x	                lda 0,x
.91f0	92 34		sta ($34)	                sta (tohold)
.91f2	e8		inx		                inx
.91f3	e8		inx		                inx
.91f4	60		rts		z_hold:         rts
.91f5					xt_i:
.91f5	ca		dex		                dex
.91f6	ca		dex		                dex
.91f7	86 2a		stx $2a		                stx tmpdsp
.91f9	ba		tsx		                tsx
.91fa	38		sec		                sec
.91fb	bd 01 01	lda $0101,x	                lda $0101,x     ; LSB
.91fe	fd 03 01	sbc $0103,x	                sbc $0103,x
.9201	a8		tay		                tay
.9202	bd 02 01	lda $0102,x	                lda $0102,x     ; MSB
.9205	fd 04 01	sbc $0104,x	                sbc $0104,x
.9208	a6 2a		ldx $2a		                ldx tmpdsp
.920a	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.920c	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.920e	60		rts		z_i:            rts
.920f					xt_if:
.920f	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.9211	a9 20		lda #$20	                lda #<zero_branch_runtime
.9213	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.9216	20 7e 91	jsr $917e	                jsr xt_here
.9219	20 b4 a7	jsr $a7b4	                jsr xt_zero
.921c	20 7a 87	jsr $877a	                jsr xt_comma
.921f	60		rts		z_if:           rts
.9220					zero_branch_runtime:
.9220	68		pla		                pla
.9221	85 22		sta $22		                sta tmpbranch
.9223	68		pla		                pla
.9224	85 23		sta $23		                sta tmpbranch+1
.9226	b5 00		lda $00,x	                lda 0,x
.9228	15 01		ora $01,x	                ora 1,x
.922a	f0 0f		beq $923b	                beq _zero
.922c	a5 22		lda $22		                lda tmpbranch   ; LSB
.922e	18		clc		                clc
.922f	69 02		adc #$02	                adc #2
.9231	85 24		sta $24		                sta tmp1
.9233	a5 23		lda $23		                lda tmpbranch+1 ; MSB
.9235	69 00		adc #$00	                adc #0          ; For carry
.9237	85 25		sta $25		                sta tmp1+1
.9239	80 13		bra $924e	                bra _done
.923b					_zero:
.923b	a0 01		ldy #$01	                ldy #1
.923d	b1 22		lda ($22),y	                lda (tmpbranch),y
.923f	85 24		sta $24		                sta tmp1
.9241	c8		iny		                iny
.9242	b1 22		lda ($22),y	                lda (tmpbranch),y
.9244	85 25		sta $25		                sta tmp1+1
.9246	a5 24		lda $24		                lda tmp1
.9248	d0 02		bne $924c	                bne +
.924a	c6 25		dec $25		                dec tmp1+1
.924c					+
.924c	c6 24		dec $24		                dec tmp1
.924e					_done:
.924e	a5 25		lda $25		                lda tmp1+1
.9250	48		pha		                pha             ; MSB first
.9251	a5 24		lda $24		                lda tmp1
.9253	48		pha		                pha
.9254	e8		inx		                inx
.9255	e8		inx		                inx
.9256	60		rts		                rts
.9257					xt_immediate:
.9257	20 92 d7	jsr $d792	                jsr current_to_dp
.925a	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.925c	b1 02		lda ($02),y	                lda (dp),y
.925e	09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9260	91 02		sta ($02),y	                sta (dp),y
.9262	60		rts		z_immediate:    rts
.9263					xt_input:
.9263	ca		dex		                dex
.9264	ca		dex		                dex
.9265	a9 12		lda #$12	                lda #<input
.9267	95 00		sta $00,x	                sta 0,x
.9269	a9 00		lda #$00	                lda #>input
.926b	95 01		sta $01,x	                sta 1,x
.926d	60		rts		z_input:        rts
.926e					xt_input_to_r:
.926e	68		pla		                pla
.926f	85 24		sta $24		                sta tmp1
.9271	68		pla		                pla
.9272	85 25		sta $25		                sta tmp1+1
.9274	a0 07		ldy #$07	                ldy #7
.9276					_loop:
.9276	b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.9279	48		pha		                pha
.927a	88		dey		                dey
.927b	10 f9		bpl $9276	                bpl _loop
.927d	a5 25		lda $25		                lda tmp1+1
.927f	48		pha		                pha
.9280	a5 24		lda $24		                lda tmp1
.9282	48		pha		                pha
.9283	60		rts		z_input_to_r: 	rts
.9284					xt_int_to_name:
.9284	20 50 d8	jsr $d850	                jsr underflow_1
.9287	ca		dex		                dex
.9288	ca		dex		                dex
.9289	74 00		stz $00,x	                stz 0,x
.928b	74 01		stz $01,x	                stz 1,x
.928d					_wordlist_loop:
.928d	b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.928f	0a		asl a		                asl                     ; Turn offset into cells offset.
.9290	18		clc		                clc
.9291	69 06		adc #$06	                adc #wordlists_offset
.9293	a8		tay		                tay
.9294	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.9296	85 26		sta $26		                sta tmp2                ; into tmp2
.9298	c8		iny		                iny
.9299	b1 1e		lda ($1e),y	                lda (up),y
.929b	85 27		sta $27		                sta tmp2+1
.929d	a5 26		lda $26		                lda tmp2
.929f	05 27		ora $27		                ora tmp2+1
.92a1	f0 38		beq $92db	                beq _next_wordlist
.92a3	b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.92a5	85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.92a7	b5 03		lda $03,x	                lda 3,x
.92a9	85 29		sta $29		                sta tmp3+1
.92ab					_loop:
.92ab	a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.92ad	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.92af	c5 28		cmp $28		                cmp tmp3
.92b1	d0 07		bne $92ba	                bne _no_match
.92b3	c8		iny		                iny
.92b4	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.92b6	c5 29		cmp $29		                cmp tmp3+1
.92b8	f0 32		beq $92ec	                beq _match
.92ba					_no_match:
.92ba	18		clc		                clc
.92bb	a5 26		lda $26		                lda tmp2
.92bd	69 02		adc #$02	                adc #2
.92bf	85 26		sta $26		                sta tmp2
.92c1	a5 27		lda $27		                lda tmp2+1
.92c3	69 00		adc #$00	                adc #0          ; only care about carry
.92c5	85 27		sta $27		                sta tmp2+1
.92c7	a0 00		ldy #$00	                ldy #0
.92c9	b1 26		lda ($26),y	                lda (tmp2),y
.92cb	48		pha		                pha
.92cc	c8		iny		                iny
.92cd	11 26		ora ($26),y	                ora (tmp2),y
.92cf	f0 09		beq $92da	                beq _zero
.92d1	b1 26		lda ($26),y	                lda (tmp2),y
.92d3	85 27		sta $27		                sta tmp2+1
.92d5	68		pla		                pla
.92d6	85 26		sta $26		                sta tmp2
.92d8	80 d1		bra $92ab	                bra _loop
.92da					_zero:
.92da	68		pla		                pla             ; Leftover from above loop
.92db					_next_wordlist:
.92db	b5 00		lda $00,x	                lda 0,x
.92dd	1a		inc a		                ina
.92de	95 00		sta $00,x	                sta 0,x
.92e0	c9 0c		cmp #$0c	                cmp #max_wordlists
.92e2	d0 a9		bne $928d	                bne _wordlist_loop
.92e4	e8		inx		                inx
.92e5	e8		inx		                inx
.92e6	74 00		stz $00,x	                stz 0,x
.92e8	74 01		stz $01,x	                stz 1,x
.92ea	80 0a		bra $92f6	                bra z_int_to_name
.92ec					_match:
.92ec	e8		inx		                inx
.92ed	e8		inx		                inx
.92ee	a5 26		lda $26		                lda tmp2
.92f0	95 00		sta $00,x	                sta 0,x
.92f2	a5 27		lda $27		                lda tmp2+1
.92f4	95 01		sta $01,x	                sta 1,x
.92f6	60		rts		z_int_to_name:  rts
.92f7					xt_invert:
.92f7	20 50 d8	jsr $d850	                jsr underflow_1
.92fa	a9 ff		lda #$ff	                lda #$FF
.92fc	55 00		eor $00,x	                eor 0,x         ; LSB
.92fe	95 00		sta $00,x	                sta 0,x
.9300	a9 ff		lda #$ff	                lda #$FF
.9302	55 01		eor $01,x	                eor 1,x         ; MSB
.9304	95 01		sta $01,x	                sta 1,x
.9306	60		rts		z_invert:       rts
.9307					xt_is:
.9307	a5 16		lda $16		                lda state
.9309	05 17		ora $17		                ora state+1
.930b	f0 0c		beq $9319	                beq _interpreting
.930d					_compiling:
.930d	20 aa 85	jsr $85aa	                jsr xt_bracket_tick
.9310	a0 8a		ldy #$8a	                ldy #>xt_defer_store
.9312	a9 f2		lda #$f2	                lda #<xt_defer_store
.9314	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.9317	80 06		bra $931f	                bra _done
.9319					_interpreting:
.9319	20 1d a2	jsr $a21d	                jsr xt_tick
.931c	20 f2 8a	jsr $8af2	                jsr xt_defer_store
.931f					_done:
.931f	60		rts		z_is:           rts
.9320					xt_j:
.9320	ca		dex		                dex
.9321	ca		dex		                dex
.9322	86 2a		stx $2a		                stx tmpdsp
.9324	ba		tsx		                tsx
.9325	38		sec		                sec
.9326	bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.9329	fd 09 01	sbc $0109,x	                sbc $0109,x
.932c	a8		tay		                tay
.932d	bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.9330	fd 0a 01	sbc $010a,x	                sbc $010A,x
.9333	a6 2a		ldx $2a		                ldx tmpdsp
.9335	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.9337	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.9339	60		rts		z_j:            rts
.933a					xt_key:
.933a	20 44 93	jsr $9344	                jsr key_a               ; returns char in A
.933d	ca		dex		                dex
.933e	ca		dex		                dex
.933f	95 00		sta $00,x	                sta 0,x
.9341	74 01		stz $01,x	                stz 1,x
.9343	60		rts		z_key:          rts
.9344					key_a:
.9344	6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.9347					xt_latestnt:
.9347	ca		dex		                dex
.9348	ca		dex		                dex
.9349	20 92 d7	jsr $d792	                jsr current_to_dp
.934c	a5 02		lda $02		                lda dp
.934e	95 00		sta $00,x	                sta 0,x
.9350	a5 03		lda $03		                lda dp+1
.9352	95 01		sta $01,x	                sta 1,x
.9354	60		rts		z_latestnt:     rts
.9355					xt_latestxt:
.9355	20 47 93	jsr $9347	                jsr xt_latestnt         ; ( nt )
.9358	20 ed 95	jsr $95ed	                jsr xt_name_to_int      ; ( xt )
.935b	60		rts		z_latestxt:     rts
.935c					xt_leave:
.935c	68		pla		                pla
.935d	68		pla		                pla
.935e	68		pla		                pla
.935f	68		pla		                pla
.9360	60		rts		                rts             ; this must be compiled, so keep before z_leave
.9361					z_leave:
.9361					xt_left_bracket:
.9361	64 16		stz $16		                stz state
.9363	64 17		stz $17		                stz state+1
.9365	60		rts		z_left_bracket: rts
.9366					xt_less_number_sign:
.9366	20 ad 98	jsr $98ad	                jsr xt_pad      ; ( addr )
.9369	b5 00		lda $00,x	                lda 0,x
.936b	85 34		sta $34		                sta tohold
.936d	b5 01		lda $01,x	                lda 1,x
.936f	85 35		sta $35		                sta tohold+1
.9371	e8		inx		                inx
.9372	e8		inx		                inx
.9373					z_less_number_sign:
.9373	60		rts		                rts
.9374					xt_less_than:
.9374	20 55 d8	jsr $d855	                jsr underflow_2
.9377	a0 00		ldy #$00	                ldy #0          ; default false
.9379	20 77 d7	jsr $d777	                jsr compare_16bit
.937c	f0 03		beq $9381	                beq _false
.937e	30 01		bmi $9381	                bmi _false
.9380	88		dey		                dey
.9381					_false:
.9381	98		tya		                tya
.9382	e8		inx		                inx
.9383	e8		inx		                inx
.9384	95 00		sta $00,x	                sta 0,x
.9386	95 01		sta $01,x	                sta 1,x
.9388	60		rts		z_less_than:    rts
.9389					xt_list:
.9389	20 50 d8	jsr $d850	                jsr underflow_1
.938c	20 e5 9e	jsr $9ee5	                jsr xt_scr
.938f	20 99 a1	jsr $a199	                jsr xt_store
.9392	20 52 a8	jsr $a852	                jsr xt_editor_l
.9395	60		rts		z_list:         rts
.9396					xt_literal:
.9396	20 50 d8	jsr $d850	                jsr underflow_1
.9399	a0 93		ldy #$93	                ldy #>literal_runtime
.939b	a9 a4		lda #$a4	                lda #<literal_runtime
.939d	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.93a0	20 7a 87	jsr $877a	                jsr xt_comma
.93a3	60		rts		z_literal:      rts
.93a4					literal_runtime:
.93a4	ca		dex		                dex
.93a5	ca		dex		                dex
.93a6	68		pla		                pla             ; LSB
.93a7	85 24		sta $24		                sta tmp1
.93a9	68		pla		                pla             ; MSB
.93aa	85 25		sta $25		                sta tmp1+1
.93ac	a0 01		ldy #$01	                ldy #1
.93ae	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.93b0	95 00		sta $00,x	                sta 0,x
.93b2	c8		iny		                iny
.93b3	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.93b5	95 01		sta $01,x	                sta 1,x
.93b7	98		tya		                tya
.93b8	18		clc		                clc
.93b9	65 24		adc $24		                adc tmp1
.93bb	a8		tay		                tay
.93bc	a5 25		lda $25		                lda tmp1+1
.93be	69 00		adc #$00	                adc #0
.93c0	48		pha		                pha
.93c1	5a		phy		                phy
.93c2	60		rts		                rts
.93c3					xt_load:
.93c3	20 50 d8	jsr $d850	                jsr underflow_1
.93c6	a0 01		ldy #$01	                ldy #blk_offset+1
.93c8	b1 1e		lda ($1e),y	                lda (up),y
.93ca	48		pha		                pha
.93cb	88		dey		                dey
.93cc	b1 1e		lda ($1e),y	                lda (up),y
.93ce	48		pha		                pha
.93cf	b5 00		lda $00,x	                lda 0,x
.93d1	91 1e		sta ($1e),y	                sta (up),y
.93d3	c8		iny		                iny
.93d4	b5 01		lda $01,x	                lda 1,x
.93d6	91 1e		sta ($1e),y	                sta (up),y
.93d8	20 cd 83	jsr $83cd	                jsr xt_block
.93db	ca		dex		                dex
.93dc	ca		dex		                dex
.93dd	a9 04		lda #$04	                lda #4
.93df	95 01		sta $01,x	                sta 1,x
.93e1	74 00		stz $00,x	                stz 0,x
.93e3	20 db 90	jsr $90db	                jsr load_evaluate
.93e6	a0 00		ldy #$00	                ldy #blk_offset
.93e8	68		pla		                pla
.93e9	91 1e		sta ($1e),y	                sta (up),y
.93eb	c8		iny		                iny
.93ec	68		pla		                pla
.93ed	91 1e		sta ($1e),y	                sta (up),y
.93ef	88		dey		                dey
.93f0	11 1e		ora ($1e),y	                ora (up),y
.93f2	f0 12		beq $9406	                beq _done
.93f4	ca		dex		                dex
.93f5	ca		dex		                dex
.93f6	a0 00		ldy #$00	                ldy #blk_offset
.93f8	b1 1e		lda ($1e),y	                lda (up),y
.93fa	95 00		sta $00,x	                sta 0,x
.93fc	c8		iny		                iny
.93fd	b1 1e		lda ($1e),y	                lda (up),y
.93ff	95 01		sta $01,x	                sta 1,x
.9401	20 cd 83	jsr $83cd	                jsr xt_block
.9404	e8		inx		                inx
.9405	e8		inx		                inx
.9406					_done:
.9406	60		rts		z_load:         rts
.9407					xt_loop:
.9407	a0 98		ldy #$98	                ldy #>xt_one
.9409	a9 14		lda #$14	                lda #<xt_one
.940b	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine     ; drop through to +LOOP
.940e					xt_plus_loop:
.940e	a0 11		ldy #$11	                ldy #plus_loop_runtime_end-plus_loop_runtime
.9410	5a		phy		                phy             ; save counter to adjust CP
.9411					-
.9411	b9 75 94	lda $9475,y	                lda plus_loop_runtime,y
.9414	91 00		sta ($00),y	                sta (cp),y
.9416	88		dey		                dey
.9417	10 f8		bpl $9411	                bpl -
.9419	68		pla		                pla
.941a	18		clc		                clc
.941b	65 00		adc $00		                adc cp
.941d	85 00		sta $00		                sta cp
.941f	a5 01		lda $01		                lda cp+1
.9421	69 00		adc #$00	                adc #0          ; only need carry
.9423	85 01		sta $01		                sta cp+1
.9425	20 7a 87	jsr $877a	                jsr xt_comma
.9428	a9 68		lda #$68	                lda #$68                ; opcode for PLA
.942a	a0 06		ldy #$06	                ldy #6
.942c					-
.942c	91 00		sta ($00),y	                sta (cp),y
.942e	88		dey		                dey
.942f	10 fb		bpl $942c	                bpl -
.9431	a9 06		lda #$06	                lda #6
.9433	18		clc		                clc
.9434	65 00		adc $00		                adc cp
.9436	85 00		sta $00		                sta cp
.9438	a5 01		lda $01		                lda cp+1
.943a	69 00		adc #$00	                adc #0                  ; only need carry
.943c	85 01		sta $01		                sta cp+1
.943e	b5 00		lda $00,x	                lda 0,x
.9440	85 24		sta $24		                sta tmp1
.9442	b5 01		lda $01,x	                lda 1,x
.9444	85 25		sta $25		                sta tmp1+1
.9446	e8		inx		                inx
.9447	e8		inx		                inx
.9448	a5 00		lda $00		                lda cp
.944a	38		sec		                sec
.944b	e9 01		sbc #$01	                sbc #1
.944d	85 26		sta $26		                sta tmp2
.944f	a5 01		lda $01		                lda cp+1
.9451	e9 00		sbc #$00	                sbc #0
.9453	85 27		sta $27		                sta tmp2+1
.9455	a0 00		ldy #$00	                ldy #0
.9457	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.9459	91 24		sta ($24),y	                sta (tmp1),y
.945b	c8		iny		                iny
.945c	a5 27		lda $27		                lda tmp2+1      ; MSB
.945e	91 24		sta ($24),y	                sta (tmp1),y
.9460	c8		iny		                iny
.9461	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9463	91 24		sta ($24),y	                sta (tmp1),y
.9465	c8		iny		                iny
.9466	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.9468	91 24		sta ($24),y	                sta (tmp1),y
.946a	c8		iny		                iny
.946b	a5 26		lda $26		                lda tmp2        ; LSB
.946d	91 24		sta ($24),y	                sta (tmp1),y
.946f	c8		iny		                iny
.9470	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9472	91 24		sta ($24),y	                sta (tmp1),y
.9474					z_loop:
.9474	60		rts		z_plus_loop:    rts
.9475					plus_loop_runtime:
.9475	18		clc		                clc
.9476	68		pla		                pla             ; LSB of index
.9477	75 00		adc $00,x	                adc 0,x         ; LSB of step
.9479	a8		tay		                tay             ; temporary storage of LSB
.947a	b8		clv		                clv
.947b	68		pla		                pla             ; MSB of index
.947c	75 01		adc $01,x	                adc 1,x         ; MSB of step
.947e	48		pha		                pha             ; put MSB of index back on stack
.947f	98		tya		                tya             ; put LSB of index back on stack
.9480	48		pha		                pha
.9481	e8		inx		                inx             ; dump step from TOS
.9482	e8		inx		                inx
.9483	70 03		bvs $9488	                bvs _hack+3     ; skip over JMP instruction
.9485					_hack:
>9485	4c				                .byte $4C
.9486					plus_loop_runtime_end:
.9486					xt_lshift:
.9486	20 55 d8	jsr $d855	                jsr underflow_2
.9489	b5 00		lda $00,x	                lda 0,x
.948b	29 0f		and #$0f	                and #%00001111
.948d	f0 08		beq $9497	                beq _done
.948f	a8		tay		                tay
.9490					_loop:
.9490	16 02		asl $02,x	                asl 2,x
.9492	36 03		rol $03,x	                rol 3,x
.9494	88		dey		                dey
.9495	d0 f9		bne $9490	                bne _loop
.9497					_done:
.9497	e8		inx		                inx
.9498	e8		inx		                inx
.9499	60		rts		z_lshift:       rts
.949a					xt_m_star:
.949a	20 55 d8	jsr $d855	                jsr underflow_2
.949d	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.949f	55 03		eor $03,x	                eor 3,x         ; MSB of n2
.94a1	48		pha		                pha
.94a2	20 23 81	jsr $8123	                jsr xt_abs
.94a5	20 ba a1	jsr $a1ba	                jsr xt_swap
.94a8	20 23 81	jsr $8123	                jsr xt_abs
.94ab	20 08 a6	jsr $a608	                jsr xt_um_star          ; ( d )
.94ae	68		pla		                pla
.94af	10 03		bpl $94b4	                bpl _done
.94b1	20 4d 8b	jsr $8b4d	                jsr xt_dnegate
.94b4					_done:
.94b4	60		rts		z_m_star:       rts
.94b5					xt_marker:
.94b5	20 92 d7	jsr $d792	                jsr current_to_dp
.94b8	a5 02		lda $02		                lda dp
.94ba	48		pha		                pha
.94bb	a5 03		lda $03		                lda dp+1
.94bd	48		pha		                pha
.94be	a5 00		lda $00		                lda cp
.94c0	48		pha		                pha
.94c1	a5 01		lda $01		                lda cp+1
.94c3	48		pha		                pha
.94c4	20 75 89	jsr $8975	                jsr xt_create
.94c7	a5 00		lda $00		                lda cp          ; LSB
.94c9	38		sec		                sec
.94ca	e9 02		sbc #$02	                sbc #2
.94cc	85 00		sta $00		                sta cp
.94ce	a5 01		lda $01		                lda cp+1        ; MSB
.94d0	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94d2	85 01		sta $01		                sta cp+1
.94d4	a0 94		ldy #$94	                ldy #>marker_runtime
.94d6	a9 f3		lda #$f3	                lda #<marker_runtime
.94d8	20 ff d6	jsr $d6ff	                jsr cmpl_word
.94db	7a		ply		                ply                     ; MSB
.94dc	68		pla		                pla                     ; LSB
.94dd	20 ff d6	jsr $d6ff	                jsr cmpl_word
.94e0	7a		ply		                ply                     ; MSB
.94e1	68		pla		                pla                     ; LSB
.94e2	20 ff d6	jsr $d6ff	                jsr cmpl_word
.94e5	a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94e7					_marker_loop:
.94e7	b1 1e		lda ($1e),y	                lda (up),y
.94e9	20 03 d7	jsr $d703	                jsr cmpl_a
.94ec	c8		iny		                iny
.94ed	98		tya		                tya
.94ee	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94f0	d0 f5		bne $94e7	                bne _marker_loop
.94f2	60		rts		z_marker:       rts
.94f3					marker_runtime:
.94f3	68		pla		                pla
.94f4	85 24		sta $24		                sta tmp1        ; LSB of address
.94f6	68		pla		                pla
.94f7	85 25		sta $25		                sta tmp1+1      ; MSB of address
.94f9	e6 24		inc $24		                inc tmp1
.94fb	d0 02		bne $94ff	                bne +
.94fd	e6 25		inc $25		                inc tmp1+1
.94ff					+
.94ff	a0 00		ldy #$00	                ldy #0
.9501	b1 24		lda ($24),y	                lda (tmp1),y
.9503	85 00		sta $00		                sta cp
.9505	c8		iny		                iny
.9506	b1 24		lda ($24),y	                lda (tmp1),y
.9508	85 01		sta $01		                sta cp+1
.950a	c8		iny		                iny
.950b	b1 24		lda ($24),y	                lda (tmp1),y
.950d	85 02		sta $02		                sta dp
.950f	c8		iny		                iny
.9510	b1 24		lda ($24),y	                lda (tmp1),y
.9512	85 03		sta $03		                sta dp+1
.9514	a0 04		ldy #$04	                ldy #4
.9516					_marker_restore_loop:
.9516	b1 24		lda ($24),y	                lda (tmp1), y
.9518	91 1e		sta ($1e),y	                sta (up), y
.951a	c8		iny		                iny
.951b	98		tya		                tya
.951c	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.951e	d0 f6		bne $9516	                bne _marker_restore_loop
.9520	20 a5 d7	jsr $d7a5	                jsr dp_to_current       ; Move the CURRENT DP back.
.9523	60		rts		                rts
.9524					xt_max:
.9524	20 55 d8	jsr $d855	                jsr underflow_2
.9527	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9529	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.952b	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.952d	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.952f	50 02		bvc $9533	                bvc _no_overflow
.9531	49 80		eor #$80	                eor #$80        ; complement negative flag
.9533					_no_overflow:
.9533	30 08		bmi $953d	                bmi _keep_nos
.9535	b5 00		lda $00,x	                lda 0,x
.9537	95 02		sta $02,x	                sta 2,x
.9539	b5 01		lda $01,x	                lda 1,x
.953b	95 03		sta $03,x	                sta 3,x
.953d					_keep_nos:
.953d	e8		inx		                inx
.953e	e8		inx		                inx
.953f	60		rts		z_max:          rts
.9540					xt_min:
.9540	20 55 d8	jsr $d855	                jsr underflow_2
.9543	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9545	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.9547	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9549	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.954b	50 02		bvc $954f	                bvc _no_overflow
.954d	49 80		eor #$80	                eor #$80
.954f					_no_overflow:
.954f	10 08		bpl $9559	                bpl _keep_nos
.9551	b5 00		lda $00,x	                lda 0,x
.9553	95 02		sta $02,x	                sta 2,x
.9555	b5 01		lda $01,x	                lda 1,x
.9557	95 03		sta $03,x	                sta 3,x
.9559					_keep_nos:
.9559	e8		inx		                inx
.955a	e8		inx		                inx
.955b	60		rts		z_min:          rts
.955c					xt_minus:
.955c	20 55 d8	jsr $d855	                jsr underflow_2
.955f	38		sec		                sec
.9560	b5 02		lda $02,x	                lda 2,x         ; LSB
.9562	f5 00		sbc $00,x	                sbc 0,x
.9564	95 02		sta $02,x	                sta 2,x
.9566	b5 03		lda $03,x	                lda 3,x         ; MSB
.9568	f5 01		sbc $01,x	                sbc 1,x
.956a	95 03		sta $03,x	                sta 3,x
.956c	e8		inx		                inx
.956d	e8		inx		                inx
.956e	60		rts		z_minus:        rts
.956f					xt_minus_leading:
.956f	20 55 d8	jsr $d855	                jsr underflow_2
.9572					_loop:
.9572	b5 00		lda $00,x	                lda 0,x
.9574	15 01		ora $01,x	                ora 1,x
.9576	f0 0f		beq $9587	                beq _done
.9578	a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.957a	20 43 d8	jsr $d843	                jsr is_whitespace
.957d	90 08		bcc $9587	                bcc _done
.957f	20 14 98	jsr $9814	                jsr xt_one              ; ( addr u 1 )
.9582	20 25 a0	jsr $a025	                jsr xt_slash_string     ; ( addr+ u-1 )
.9585	80 eb		bra $9572	                bra _loop
.9587					_done:
.9587					z_minus_leading:
.9587	60		rts		                rts
.9588					xt_minus_trailing:
.9588	20 55 d8	jsr $d855	                jsr underflow_2
.958b	b5 00		lda $00,x	                lda 0,x         ; LSB of n
.958d	15 01		ora $01,x	                ora 1,x         ; MSB of n
.958f	f0 33		beq $95c4	                beq _done
.9591	18		clc		                clc
.9592	b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.9594	75 00		adc $00,x	                adc 0,x
.9596	85 24		sta $24		                sta tmp1
.9598	b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.959a	75 01		adc $01,x	                adc 1,x
.959c	85 25		sta $25		                sta tmp1+1
.959e	a5 24		lda $24		                lda tmp1
.95a0	d0 02		bne $95a4	                bne +
.95a2	c6 25		dec $25		                dec tmp1+1
.95a4					+
.95a4	c6 24		dec $24		                dec tmp1
.95a6					_loop:
.95a6	b2 24		lda ($24)	                lda (tmp1)
.95a8	c9 20		cmp #$20	                cmp #AscSP
.95aa	d0 18		bne $95c4	                bne _done
.95ac	a5 24		lda $24		                lda tmp1
.95ae	d0 02		bne $95b2	                bne +
.95b0	c6 25		dec $25		                dec tmp1+1
.95b2					+
.95b2	c6 24		dec $24		                dec tmp1
.95b4	b5 00		lda $00,x	                lda 0,x
.95b6	d0 02		bne $95ba	                bne +
.95b8	d6 01		dec $01,x	                dec 1,x
.95ba					+
.95ba	d6 00		dec $00,x	                dec 0,x
.95bc	b5 00		lda $00,x	                lda 0,x
.95be	15 01		ora $01,x	                ora 1,x
.95c0	f0 02		beq $95c4	                beq _done       ; Count has reached zero - we're done!
.95c2	80 e2		bra $95a6	                bra _loop
.95c4					_done:
.95c4					z_minus_trailing:
.95c4	60		rts		                rts
.95c5					xt_mod:
.95c5	20 55 d8	jsr $d855	                jsr underflow_2
.95c8	20 0d a0	jsr $a00d	                jsr xt_slash_mod
.95cb	e8		inx		                inx             ; DROP
.95cc	e8		inx		                inx
.95cd					z_mod:
.95cd	60		rts		                rts
.95ce					xt_move:
.95ce	b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95d0	d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95d2	f0 05		beq $95d9	                beq _lsb                ; wasn't helpful, move to LSB
.95d4	b0 0e		bcs $95e4	                bcs _to_move_up         ; we want CMOVE>
.95d6	4c a5 86	jmp $86a5	                jmp xt_cmove            ; JSR/RTS
.95d9					_lsb:
.95d9	b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95db	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95dd	f0 08		beq $95e7	                beq _equal              ; LSB is equal as well
.95df	b0 03		bcs $95e4	                bcs _to_move_up         ; we want CMOVE>
.95e1	4c a5 86	jmp $86a5	                jmp xt_cmove            ; JSR/RTS
.95e4					_to_move_up:
.95e4	4c e0 86	jmp $86e0	                jmp xt_cmove_up         ; JSR/RTS
.95e7					_equal:
.95e7	8a		txa		                txa
.95e8	18		clc		                clc
.95e9	69 06		adc #$06	                adc #6
.95eb	aa		tax		                tax
.95ec	60		rts		z_move:         rts
.95ed					xt_name_to_int:
.95ed	20 50 d8	jsr $d850	                jsr underflow_1
.95f0	b5 00		lda $00,x	                lda 0,x
.95f2	18		clc		                clc
.95f3	69 04		adc #$04	                adc #4
.95f5	85 28		sta $28		                sta tmp3
.95f7	b5 01		lda $01,x	                lda 1,x
.95f9	90 01		bcc $95fc	                bcc _done
.95fb	1a		inc a		                ina
.95fc					_done:
.95fc	85 29		sta $29		                sta tmp3+1
.95fe	a0 00		ldy #$00	                ldy #0
.9600	b1 28		lda ($28),y	                lda (tmp3),y
.9602	95 00		sta $00,x	                sta 0,x
.9604	c8		iny		                iny
.9605	b1 28		lda ($28),y	                lda (tmp3),y
.9607	95 01		sta $01,x	                sta 1,x
.9609	60		rts		z_name_to_int:  rts
.960a					xt_name_to_string:
.960a	20 50 d8	jsr $d850	                jsr underflow_1
.960d	ca		dex		                dex
.960e	ca		dex		                dex
.960f	a1 02		lda ($02,x)	                lda (2,x)
.9611	95 00		sta $00,x	                sta 0,x
.9613	74 01		stz $01,x	                stz 1,x
.9615	b5 02		lda $02,x	                lda 2,x         ; LSB
.9617	18		clc		                clc
.9618	69 08		adc #$08	                adc #8
.961a	a8		tay		                tay
.961b	b5 03		lda $03,x	                lda 3,x         ; MSB
.961d	69 00		adc #$00	                adc #0          ; just need carry
.961f	95 03		sta $03,x	                sta 3,x
.9621	94 02		sty $02,x	                sty 2,x
.9623					z_name_to_string:
.9623	60		rts		                rts
.9624					xt_nc_limit:
.9624	ca		dex		                dex
.9625	ca		dex		                dex
.9626	a9 1a		lda #$1a	                lda #<nc_limit
.9628	95 00		sta $00,x	                sta 0,x
.962a	a9 00		lda #$00	                lda #>nc_limit
.962c	95 01		sta $01,x	                sta 1,x
.962e	60		rts		z_nc_limit:     rts
.962f					xt_negate:
.962f	20 50 d8	jsr $d850	                jsr underflow_1
.9632	a9 00		lda #$00	        	lda #0
.9634	38		sec		                sec
.9635	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.9637	95 00		sta $00,x	                sta 0,x
.9639	a9 00		lda #$00	                lda #0
.963b	f5 01		sbc $01,x	                sbc 1,x         ; MSB
.963d	95 01		sta $01,x	                sta 1,x
.963f	60		rts		z_negate:       rts
.9640					xt_never_native:
.9640	20 92 d7	jsr $d792	                jsr current_to_dp
.9643	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9645	b1 02		lda ($02),y	                lda (dp),y
.9647	09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9649	29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.964b	91 02		sta ($02),y	                sta (dp),y
.964d					z_never_native:
.964d	60		rts		                rts
.964e					xt_nip:
.964e	20 55 d8	jsr $d855	                jsr underflow_2
.9651	b5 00		lda $00,x	                lda 0,x         ; LSB
.9653	95 02		sta $02,x	                sta 2,x
.9655	b5 01		lda $01,x	                lda 1,x         ; MSB
.9657	95 03		sta $03,x	                sta 3,x
.9659	e8		inx		                inx
.965a	e8		inx		                inx
.965b	60		rts		z_nip:          rts
.965c					xt_not_equals:
.965c	20 55 d8	jsr $d855	                jsr underflow_2
.965f	a0 00		ldy #$00	                ldy #0                  ; default is true
.9661	b5 00		lda $00,x	                lda 0,x                 ; LSB
.9663	d5 02		cmp $02,x	                cmp 2,x
.9665	d0 0a		bne $9671	                bne _not_equal
.9667	b5 01		lda $01,x	                lda 1,x                 ; MSB
.9669	d5 03		cmp $03,x	                cmp 3,x
.966b	d0 04		bne $9671	                bne _not_equal
.966d	a9 ff		lda #$ff	                lda #$FF
.966f	80 01		bra $9672	                bra _done
.9671					_not_equal:
.9671	88		dey		                dey                     ; drop thru to done
.9672					_done:
.9672	98		tya		                tya
.9673	e8		inx		                inx
.9674	e8		inx		                inx
.9675	95 00		sta $00,x	                sta 0,x
.9677	95 01		sta $01,x	                sta 1,x
.9679	60		rts		z_not_equals:   rts
.967a					xt_not_rote:
.967a	20 5a d8	jsr $d85a	                jsr underflow_3
.967d	b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.967f	b5 03		lda $03,x	                lda 3,x
.9681	95 01		sta $01,x	                sta 1,x
.9683	b5 05		lda $05,x	                lda 5,x
.9685	95 03		sta $03,x	                sta 3,x
.9687	94 05		sty $05,x	                sty 5,x
.9689	b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.968b	b5 02		lda $02,x	                lda 2,x
.968d	95 00		sta $00,x	                sta 0,x
.968f	b5 04		lda $04,x	                lda 4,x
.9691	95 02		sta $02,x	                sta 2,x
.9693	94 04		sty $04,x	                sty 4,x
.9695	60		rts		z_not_rote:     rts
.9696					xt_number:
.9696	20 55 d8	jsr $d855	                jsr underflow_2
.9699	64 2a		stz $2a		                stz tmpdsp      ; flag for double
.969b	64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.969d	a5 18		lda $18		                lda base
.969f	48		pha		                pha
.96a0	20 c4 a3	jsr $a3c4	                jsr xt_two_dup
.96a3	a1 02		lda ($02,x)	                lda (2,x)
.96a5					_check_dec:
.96a5	c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.96a7	d0 04		bne $96ad	                bne _check_hex
.96a9	a9 0a		lda #$0a	                lda #$0A
.96ab	80 42		bra $96ef	                bra _base_changed
.96ad					_check_hex:
.96ad	c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.96af	d0 04		bne $96b5	                bne _check_binary
.96b1	a9 10		lda #$10	                lda #$10
.96b3	80 3a		bra $96ef	                bra _base_changed
.96b5					_check_binary:
.96b5	c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.96b7	d0 04		bne $96bd	                bne _check_char
.96b9	a9 02		lda #$02	                lda #$02
.96bb	80 32		bra $96ef	                bra _base_changed
.96bd					_check_char:
.96bd	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96bf	d0 3a		bne $96fb	                bne _check_minus
.96c1	b5 00		lda $00,x	                lda 0,x         ; Get the length
.96c3	c9 03		cmp #$03	                cmp #$03
.96c5	d0 26		bne $96ed	                bne _not_a_char
.96c7	b5 01		lda $01,x	                lda 1,x
.96c9	d0 22		bne $96ed	                bne _not_a_char ; No compare needed to check for non-zero.
.96cb	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96cd	18		clc		                clc
.96ce	69 02		adc #$02	                adc #2          ; length of string
.96d0	85 2c		sta $2c		                sta tmptos
.96d2	b5 03		lda $03,x	                lda 3,x
.96d4	69 00		adc #$00	                adc #0          ; only need carry
.96d6	85 2d		sta $2d		                sta tmptos+1
.96d8	b2 2c		lda ($2c)	                lda (tmptos)
.96da	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96dc	d0 0f		bne $96ed	                bne _not_a_char
.96de	f6 02		inc $02,x	                inc 2,x
.96e0	d0 02		bne $96e4	                bne +
.96e2	f6 03		inc $03,x	                inc 3,x
.96e4					+
.96e4	a1 02		lda ($02,x)	                lda (2,x)
.96e6	95 02		sta $02,x	                sta 2,x
.96e8	74 03		stz $03,x	                stz 3,x
.96ea	4c 6b 97	jmp $976b	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.96ed					_not_a_char:
.96ed	80 5a		bra $9749	                bra _number_error
.96ef					_base_changed:
.96ef	85 18		sta $18		                sta base        ; Switch to the new base
.96f1	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96f3	d0 02		bne $96f7	                bne +
.96f5	f6 03		inc $03,x	                inc 3,x
.96f7					+
.96f7	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96f9	a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96fb					_check_minus:
.96fb	c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96fd	d0 0a		bne $9709	                bne _check_dot
.96ff	c6 2b		dec $2b		                dec tmpdsp+1
.9701	f6 02		inc $02,x	                inc 2,x         ; start one character later
.9703	d0 02		bne $9707	                bne +
.9705	f6 03		inc $03,x	                inc 3,x
.9707					+
.9707	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9709					_check_dot:
.9709	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.970b	18		clc		                clc
.970c	75 00		adc $00,x	                adc 0,x         ; length of string
.970e	85 2c		sta $2c		                sta tmptos
.9710	b5 03		lda $03,x	                lda 3,x
.9712	69 00		adc #$00	                adc #0          ; only need carry
.9714	85 2d		sta $2d		                sta tmptos+1
.9716	a5 2c		lda $2c		                lda tmptos
.9718	d0 02		bne $971c	                bne +
.971a	c6 2d		dec $2d		                dec tmptos+1
.971c					+
.971c	c6 2c		dec $2c		                dec tmptos
.971e	b2 2c		lda ($2c)	                lda (tmptos)
.9720	c9 2e		cmp #$2e	                cmp #'.'
.9722	d0 04		bne $9728	                bne _main
.9724	c6 2a		dec $2a		                dec tmpdsp
.9726	d6 00		dec $00,x	                dec 0,x
.9728					_main:
.9728	ca		dex		                dex
.9729	ca		dex		                dex
.972a	ca		dex		                dex
.972b	ca		dex		                dex
.972c	b5 04		lda $04,x	                lda 4,x         ; LSB of length
.972e	95 00		sta $00,x	                sta 0,x
.9730	74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9732	b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9734	95 02		sta $02,x	                sta 2,x
.9736	b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9738	95 03		sta $03,x	                sta 3,x
.973a	74 04		stz $04,x	                stz 4,x         ; clear space for ud
.973c	74 05		stz $05,x	                stz 5,x
.973e	74 06		stz $06,x	                stz 6,x
.9740	74 07		stz $07,x	                stz 7,x
.9742	20 c9 a2	jsr $a2c9	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9745	b5 00		lda $00,x	                lda 0,x
.9747	f0 1e		beq $9767	                beq _all_converted
.9749					_number_error:
.9749	20 bc a3	jsr $a3bc	                jsr xt_two_drop ; >NUMBER modified addr u
.974c	20 bc a3	jsr $a3bc	                jsr xt_two_drop ; ud   (partially converted number)
.974f	a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9751	20 02 8e	jsr $8e02	                jsr emit_a
.9754	20 0f a5	jsr $a50f	                jsr xt_type
.9757	a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.9759	20 02 8e	jsr $8e02	                jsr emit_a
.975c	20 2a a1	jsr $a12a	                jsr xt_space
.975f	68		pla		                pla
.9760	85 18		sta $18		                sta base
.9762	a9 08		lda #$08	                lda #err_syntax
.9764	4c 66 d8	jmp $d866	                jmp error
.9767					_all_converted:
.9767	e8		inx		                inx ; Drop the current addr u
.9768	e8		inx		                inx
.9769	e8		inx		                inx
.976a	e8		inx		                inx
.976b					_drop_original_string:
.976b	20 8a a4	jsr $a48a	                jsr xt_two_swap  ; Drop the original addr u
.976e	20 bc a3	jsr $a3bc	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9771	a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9773	f0 0d		beq $9782	                beq _single
.9775	a9 20		lda #$20	                lda #%00100000
.9777	04 20		tsb $20		                tsb status
.9779	a5 2b		lda $2b		                lda tmpdsp+1
.977b	f0 12		beq $978f	                beq _done       ; no minus, all done
.977d	20 4d 8b	jsr $8b4d	                jsr xt_dnegate
.9780	80 0d		bra $978f	                bra _done
.9782					_single:
.9782	e8		inx		                inx
.9783	e8		inx		                inx
.9784	a9 20		lda #$20	                lda #%00100000
.9786	14 20		trb $20		                trb status
.9788	a5 2b		lda $2b		                lda tmpdsp+1
.978a	f0 03		beq $978f	                beq _done       ; no minus, all done
.978c	20 2f 96	jsr $962f	                jsr xt_negate
.978f					_done:
.978f	68		pla		                pla
.9790	85 18		sta $18		                sta base
.9792	60		rts		z_number:       rts
.9793					xt_number_sign:
.9793	20 55 d8	jsr $d855	                jsr underflow_2         ; double number
.9796	20 93 83	jsr $8393	                jsr xt_base
.9799	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; ( ud1 base )
.979c	20 7c a3	jsr $a37c	                jsr xt_to_r             ; >r
.979f	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; 0
.97a2	20 89 9a	jsr $9a89	                jsr xt_r_fetch          ; r@
.97a5	20 c6 a5	jsr $a5c6	                jsr xt_um_slash_mod     ; um/mod
.97a8	20 63 9b	jsr $9b63	                jsr xt_rot              ; rot
.97ab	20 63 9b	jsr $9b63	                jsr xt_rot              ; rot
.97ae	20 9e 9a	jsr $9a9e	                jsr xt_r_from           ; r>
.97b1	20 c6 a5	jsr $a5c6	                jsr xt_um_slash_mod     ; um/mod
.97b4	20 63 9b	jsr $9b63	                jsr xt_rot              ; rot
.97b7	20 63 9b	jsr $9b63	                jsr xt_rot              ; ( ud rem )
.97ba	b5 00		lda $00,x	                lda 0,x
.97bc	a8		tay		                tay
.97bd	b9 2f d4	lda $d42f,y	                lda s_abc_upper,y
.97c0	95 00		sta $00,x	                sta 0,x
.97c2	74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.97c4	20 e3 91	jsr $91e3	                jsr xt_hold
.97c7					z_number_sign:
.97c7	60		rts		                rts
.97c8					xt_number_sign_greater:
.97c8	20 55 d8	jsr $d855	                jsr underflow_2         ; double number
.97cb	a5 34		lda $34		                lda tohold
.97cd	95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97cf	95 02		sta $02,x	                sta 2,x
.97d1	a5 35		lda $35		                lda tohold+1
.97d3	95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97d5	95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97d7	20 ad 98	jsr $98ad	                jsr xt_pad      ; ( addr addr pad )
.97da	38		sec		                sec
.97db	b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97dd	f5 02		sbc $02,x	                sbc 2,x
.97df	95 02		sta $02,x	                sta 2,x
.97e1	b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97e3	f5 03		sbc $03,x	                sbc 3,x
.97e5	95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97e7	e8		inx		                inx
.97e8	e8		inx		                inx
.97e9					z_number_sign_greater:
.97e9	60		rts		                rts
.97ea					xt_number_sign_s:
.97ea	20 55 d8	jsr $d855	                jsr underflow_2
.97ed					_loop:
.97ed	20 93 97	jsr $9793	                jsr xt_number_sign
.97f0	b5 00		lda $00,x	                lda 0,x
.97f2	15 01		ora $01,x	                ora 1,x
.97f4	15 02		ora $02,x	                ora 2,x
.97f6	15 03		ora $03,x	                ora 3,x
.97f8	d0 f3		bne $97ed	                bne _loop
.97fa					z_number_sign_s:
.97fa	60		rts		                rts
.97fb					xt_of:
.97fb	a0 98		ldy #$98	                ldy #>xt_over
.97fd	a9 9f		lda #$9f	                lda #<xt_over
.97ff	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.9802	a0 8e		ldy #$8e	                ldy #>xt_equal
.9804	a9 da		lda #$da	                lda #<xt_equal
.9806	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.9809	20 0f 92	jsr $920f	                jsr xt_if
.980c	a0 8d		ldy #$8d	                ldy #>xt_drop
.980e	a9 3a		lda #$3a	                lda #<xt_drop
.9810	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.9813	60		rts		z_of:           rts
.9814					xt_editor_wordlist:
.9814					xt_one:
.9814	ca		dex		                dex
.9815	ca		dex		                dex
.9816	a9 01		lda #$01	                lda #1
.9818	95 00		sta $00,x	                sta 0,x
.981a	74 01		stz $01,x	                stz 1,x
.981c					z_editor_wordlist:
.981c					z_one:
.981c	60		rts		                rts
.981d					xt_one_minus:
.981d	20 50 d8	jsr $d850	                jsr underflow_1
.9820	b5 00		lda $00,x	                lda 0,x
.9822	d0 02		bne $9826	                bne +
.9824	d6 01		dec $01,x	                dec 1,x
.9826					+
.9826	d6 00		dec $00,x	                dec 0,x
.9828	60		rts		z_one_minus:    rts
.9829					xt_char_plus:
.9829					xt_one_plus:
.9829	20 50 d8	jsr $d850	                jsr underflow_1
.982c	f6 00		inc $00,x	                inc 0,x
.982e	d0 02		bne $9832	                bne _done
.9830	f6 01		inc $01,x	                inc 1,x
.9832					_done:
.9832					z_char_plus:
.9832	60		rts		z_one_plus:     rts
.9833					xt_only:
.9833	ca		dex		                dex
.9834	ca		dex		                dex
.9835	a9 ff		lda #$ff	                lda #$FF
.9837	95 00		sta $00,x	                sta 0,x
.9839	95 01		sta $01,x	                sta 1,x
.983b	20 27 9d	jsr $9d27	                jsr xt_set_order
.983e	60		rts		z_only:         rts
.983f					xt_or:
.983f	20 55 d8	jsr $d855	                jsr underflow_2
.9842	b5 00		lda $00,x	                lda 0,x
.9844	15 02		ora $02,x	                ora 2,x
.9846	95 02		sta $02,x	                sta 2,x
.9848	b5 01		lda $01,x	                lda 1,x
.984a	15 03		ora $03,x	                ora 3,x
.984c	95 03		sta $03,x	                sta 3,x
.984e	e8		inx		                inx
.984f	e8		inx		                inx
.9850	60		rts		z_or:           rts
.9851					xt_order:
.9851	20 6f 89	jsr $896f	                jsr xt_cr
.9854	20 40 91	jsr $9140	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.9857	b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9859	f0 1e		beq $9879	                beq _drop_done
.985b					_have_wordlists:
.985b	a8		tay		                tay
.985c					_loop:
.985c	e8		inx		                inx
.985d	e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.985e	b5 00		lda $00,x	                lda 0,x
.9860	5a		phy		                phy
.9861	20 7c 98	jsr $987c	                jsr order_print_wid_string   ; internal helper function
.9864	7a		ply		                ply
.9865	88		dey		                dey
.9866	d0 f4		bne $985c	                bne _loop
.9868	20 2a a1	jsr $a12a	                jsr xt_space
.986b	20 2a a1	jsr $a12a	                jsr xt_space
.986e	20 35 91	jsr $9135	                jsr xt_get_current      ; ( wid )
.9871	b5 00		lda $00,x	                lda 0,x
.9873	20 7c 98	jsr $987c	                jsr order_print_wid_string
.9876	20 6f 89	jsr $896f	                jsr xt_cr
.9879					_drop_done:
.9879	e8		inx		                inx
.987a	e8		inx		                inx
.987b					z_order:
.987b	60		rts		                rts
.987c					order_print_wid_string:
.987c	c9 04		cmp #$04	                cmp #4
.987e	90 09		bcc $9889	                bcc _output_string      ; less than 4, print a real string
.9880	ca		dex		                dex
.9881	ca		dex		                dex
.9882	95 00		sta $00,x	                sta 0,x
.9884	74 01		stz $01,x	                stz 1,x
.9886	4c 3a a5	jmp $a53a	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.9889					_output_string:
.9889	a8		tay		                tay
.988a	b9 90 98	lda $9890,y	                lda _wid_data,y
.988d	4c 8c d8	jmp $d88c	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.9890					_wid_data:
>9890	03				        .byte str_wid_forth            ; WID 0: "Forth"
>9891	06				        .byte str_wid_editor           ; WID 1: "Editor"
>9892	07				        .byte str_wid_assembler        ; WID 2: "Assembler"
>9893	08				        .byte str_wid_root             ; WID 3: "Root"
.9894					xt_output:
.9894	ca		dex		                dex
.9895	ca		dex		                dex
.9896	a9 10		lda #$10	                lda #<output
.9898	95 00		sta $00,x	                sta 0,x
.989a	a9 00		lda #$00	                lda #>output
.989c	95 01		sta $01,x	                sta 1,x
.989e	60		rts		z_output:       rts
.989f					xt_over:
.989f	20 55 d8	jsr $d855	                jsr underflow_2
.98a2	ca		dex		                dex
.98a3	ca		dex		                dex
.98a4	b5 04		lda $04,x	                lda 4,x         ; LSB
.98a6	95 00		sta $00,x	                sta 0,x
.98a8	b5 05		lda $05,x	                lda 5,x         ; MSB
.98aa	95 01		sta $01,x	                sta 1,x
.98ac	60		rts		z_over:         rts
.98ad					xt_pad:
.98ad	ca		dex		                dex
.98ae	ca		dex		                dex
.98af	a5 00		lda $00		                lda cp
.98b1	18		clc		                clc
.98b2	69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.98b4	95 00		sta $00,x	                sta 0,x
.98b6	a5 01		lda $01		                lda cp+1
.98b8	69 00		adc #$00	                adc #0          ; only need carry
.98ba	95 01		sta $01,x	                sta 1,x
.98bc	60		rts		z_pad:          rts
.98bd					xt_page:
.98bd	a9 1b		lda #$1b	                lda #AscESC
.98bf	20 02 8e	jsr $8e02	                jsr emit_a
.98c2	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.98c4	20 02 8e	jsr $8e02	                jsr emit_a
.98c7	a9 32		lda #$32	                lda #'2'
.98c9	20 02 8e	jsr $8e02	                jsr emit_a
.98cc	a9 4a		lda #$4a	                lda #'J'
.98ce	20 02 8e	jsr $8e02	                jsr emit_a
.98d1	20 b4 a7	jsr $a7b4	                jsr xt_zero
.98d4	20 b4 a7	jsr $a7b4	                jsr xt_zero
.98d7	20 3a 83	jsr $833a	                jsr xt_at_xy
.98da	60		rts		z_page:         rts
.98db					xt_paren:
.98db	ca		dex		                dex
.98dc	ca		dex		                dex
.98dd	a9 29		lda #$29	                lda #41     ; Right parenthesis
.98df	95 00		sta $00,x	                sta 0,x
.98e1	74 01		stz $01,x	                stz 1,x
.98e3	20 46 99	jsr $9946	                jsr xt_parse
.98e6	e8		inx		                inx
.98e7	e8		inx		                inx
.98e8	e8		inx		                inx
.98e9	e8		inx		                inx
.98ea	60		rts		z_paren:        rts
.98eb					xt_parse_name:
.98eb	a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98ed	38		sec		                sec
.98ee	e5 0c		sbc $0c		                sbc toin
.98f0	85 24		sta $24		                sta tmp1
.98f2	a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98f4	e5 0d		sbc $0d		                sbc toin+1
.98f6	85 25		sta $25		                sta tmp1+1
.98f8	a5 24		lda $24		                lda tmp1
.98fa	05 25		ora $25		                ora tmp1+1
.98fc	f0 28		beq $9926	                beq _empty_line
.98fe	a5 08		lda $08		                lda cib
.9900	18		clc		                clc
.9901	65 0c		adc $0c		                adc toin
.9903	85 26		sta $26		                sta tmp2                ; LSB of first character
.9905	a5 09		lda $09		                lda cib+1
.9907	65 0d		adc $0d		                adc toin+1
.9909	85 27		sta $27		                sta tmp2+1              ; MSB
.990b					_skip_loop:
.990b	b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.990d	20 43 d8	jsr $d843	                jsr is_whitespace
.9910	90 1f		bcc $9931	                bcc _char_found
.9912	e6 26		inc $26		                inc tmp2
.9914	d0 02		bne $9918	                bne +
.9916	e6 27		inc $27		                inc tmp2+1
.9918					+
.9918	a5 24		lda $24		                lda tmp1
.991a	d0 02		bne $991e	                bne +
.991c	c6 25		dec $25		                dec tmp1+1
.991e	c6 24		dec $24		+               dec tmp1
.9920	a5 24		lda $24		                lda tmp1
.9922	05 25		ora $25		                ora tmp1+1
.9924	d0 e5		bne $990b	                bne _skip_loop          ; fall through if empty line
.9926					_empty_line:
.9926	ca		dex		                dex
.9927	ca		dex		                dex
.9928	ca		dex		                dex
.9929	ca		dex		                dex
.992a	74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.992c	74 01		stz $01,x	                stz 1,x
.992e	4c dd 99	jmp $99dd	                jmp z_parse_name        ; skip over PARSE
.9931					_char_found:
.9931	a5 26		lda $26		                lda tmp2
.9933	38		sec		                sec
.9934	e5 08		sbc $08		                sbc cib
.9936	85 0c		sta $0c		                sta toin
.9938	a5 27		lda $27		                lda tmp2+1
.993a	e5 09		sbc $09		                sbc cib+1
.993c	85 0d		sta $0d		                sta toin+1
.993e	ca		dex		                dex
.993f	ca		dex		                dex
.9940	a9 20		lda #$20	                lda #AscSP
.9942	95 00		sta $00,x	                sta 0,x
.9944	74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.9946					xt_parse:
.9946	20 50 d8	jsr $d850	                jsr underflow_1
.9949	a5 0a		lda $0a		                lda ciblen
.994b	05 0b		ora $0b		                ora ciblen+1
.994d	f0 0c		beq $995b	                beq _abort_parse
.994f	a5 0d		lda $0d		                lda toin+1              ; MSB
.9951	c5 0b		cmp $0b		                cmp ciblen+1
.9953	90 0e		bcc $9963	                bcc _go_parse           ; unsigned comparison
.9955	a5 0c		lda $0c		                lda toin                ; LSB
.9957	c5 0a		cmp $0a		                cmp ciblen
.9959	90 08		bcc $9963	                bcc _go_parse
.995b					_abort_parse:
.995b	ca		dex		                dex
.995c	ca		dex		                dex
.995d	74 00		stz $00,x	                stz 0,x
.995f	74 01		stz $01,x	                stz 1,x
.9961	80 7a		bra $99dd	                bra _done
.9963					_go_parse:
.9963	b5 00		lda $00,x	                lda 0,x
.9965	85 2c		sta $2c		                sta tmptos
.9967	ca		dex		                dex
.9968	ca		dex		                dex
.9969	a5 08		lda $08		                lda cib
.996b	18		clc		                clc
.996c	65 0c		adc $0c		                adc toin        ; LSB
.996e	85 24		sta $24		                sta tmp1
.9970	85 26		sta $26		                sta tmp2
.9972	95 02		sta $02,x	                sta 2,x
.9974	a5 09		lda $09		                lda cib+1
.9976	65 0d		adc $0d		                adc toin+1      ; MSB
.9978	85 25		sta $25		                sta tmp1+1
.997a	85 27		sta $27		                sta tmp2+1
.997c	95 03		sta $03,x	                sta 3,x
.997e	a5 08		lda $08		                lda cib
.9980	18		clc		                clc
.9981	65 0a		adc $0a		                adc ciblen
.9983	85 28		sta $28		                sta tmp3
.9985	a5 09		lda $09		                lda cib+1
.9987	65 0b		adc $0b		                adc ciblen+1
.9989	85 29		sta $29		                sta tmp3+1
.998b	64 2d		stz $2d		                stz tmptos+1
.998d					_loop:
.998d	a5 26		lda $26		                lda tmp2
.998f	c5 28		cmp $28		                cmp tmp3
.9991	d0 06		bne $9999	                bne _not_empty
.9993	a5 27		lda $27		                lda tmp2+1
.9995	c5 29		cmp $29		                cmp tmp3+1
.9997	f0 1d		beq $99b6	                beq _eol
.9999					_not_empty:
.9999	b2 26		lda ($26)	                lda (tmp2)
.999b	a4 2c		ldy $2c		                ldy tmptos
.999d	c0 20		cpy #$20	                cpy #AscSP
.999f	d0 07		bne $99a8	                bne _not_whitespace
.99a1	20 43 d8	jsr $d843	                jsr is_whitespace
.99a4	90 02		bcc $99a8	                bcc _not_whitespace
.99a6	80 0c		bra $99b4	                bra _found_delimiter
.99a8					_not_whitespace:
.99a8	c5 2c		cmp $2c		                cmp tmptos
.99aa	f0 08		beq $99b4	                beq _found_delimiter
.99ac	e6 26		inc $26		                inc tmp2
.99ae	d0 dd		bne $998d	                bne _loop
.99b0	e6 27		inc $27		                inc tmp2+1
.99b2	80 d9		bra $998d	                bra _loop
.99b4					_found_delimiter:
.99b4	e6 2d		inc $2d		                inc tmptos+1
.99b6					_eol:
.99b6	a5 26		lda $26		                lda tmp2
.99b8	38		sec		                sec
.99b9	e5 24		sbc $24		                sbc tmp1
.99bb	95 00		sta $00,x	                sta 0,x
.99bd	a5 27		lda $27		                lda tmp2+1
.99bf	e5 25		sbc $25		                sbc tmp1+1
.99c1	95 01		sta $01,x	                sta 1,x
.99c3	a5 26		lda $26		                lda tmp2
.99c5	38		sec		                sec
.99c6	e5 08		sbc $08		                sbc cib
.99c8	85 0c		sta $0c		                sta toin
.99ca	a5 27		lda $27		                lda tmp2+1
.99cc	e5 09		sbc $09		                sbc cib+1
.99ce	85 0d		sta $0d		                sta toin+1
.99d0	a5 0c		lda $0c		                lda toin
.99d2	18		clc		                clc
.99d3	65 2d		adc $2d		                adc tmptos+1
.99d5	85 0c		sta $0c		                sta toin
.99d7	a5 0d		lda $0d		                lda toin+1
.99d9	69 00		adc #$00	                adc #0          ; we only need the carry
.99db	85 0d		sta $0d		                sta toin+1
.99dd					_done:
.99dd					z_parse_name:
.99dd	60		rts		z_parse:        rts
.99de					xt_pick:
.99de	16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99e0	8a		txa		                txa
.99e1	75 00		adc $00,x	                adc 0,x
.99e3	a8		tay		                tay
.99e4	b9 02 00	lda $0002,y	                lda 0002,y
.99e7	95 00		sta $00,x	                sta 0,x
.99e9	b9 03 00	lda $0003,y	                lda 0003,y
.99ec	95 01		sta $01,x	                sta 1,x
.99ee	60		rts		z_pick:         rts
.99ef					xt_plus:
.99ef	20 55 d8	jsr $d855	                jsr underflow_2
.99f2	18		clc		                clc
.99f3	b5 00		lda $00,x	                lda 0,x         ; LSB
.99f5	75 02		adc $02,x	                adc 2,x
.99f7	95 02		sta $02,x	                sta 2,x
.99f9	b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99fb	75 03		adc $03,x	                adc 3,x
.99fd	95 03		sta $03,x	                sta 3,x
.99ff	e8		inx		                inx
.9a00	e8		inx		                inx
.9a01	60		rts		z_plus:         rts
.9a02					xt_plus_store:
.9a02	20 55 d8	jsr $d855	                jsr underflow_2
.9a05	b5 00		lda $00,x	                lda 0,x
.9a07	85 24		sta $24		                sta tmp1
.9a09	b5 01		lda $01,x	                lda 1,x
.9a0b	85 25		sta $25		                sta tmp1+1
.9a0d	a0 00		ldy #$00	                ldy #0          ; LSB
.9a0f	b1 24		lda ($24),y	                lda (tmp1),y
.9a11	18		clc		                clc
.9a12	75 02		adc $02,x	                adc 2,x
.9a14	91 24		sta ($24),y	                sta (tmp1),y
.9a16	c8		iny		                iny             ; MSB
.9a17	b1 24		lda ($24),y	                lda (tmp1),y
.9a19	75 03		adc $03,x	                adc 3,x
.9a1b	91 24		sta ($24),y	                sta (tmp1),y
.9a1d	e8		inx		                inx
.9a1e	e8		inx		                inx
.9a1f	e8		inx		                inx
.9a20	e8		inx		                inx
.9a21	60		rts		z_plus_store:   rts
.9a22					xt_postpone:
.9a22	20 eb 98	jsr $98eb	                jsr xt_parse_name               ; ( -- addr n )
.9a25	b5 00		lda $00,x	                lda 0,x
.9a27	15 01		ora $01,x	                ora 1,x
.9a29	d0 05		bne $9a30	                bne +
.9a2b	a9 05		lda #$05	                lda #err_noname
.9a2d	4c 66 d8	jmp $d866	                jmp error
.9a30					+
.9a30	20 e7 8f	jsr $8fe7	                jsr xt_find_name                ; ( -- nt | 0 )
.9a33	d0 05		bne $9a3a	                bne +
.9a35	a9 05		lda #$05	                lda #err_noname
.9a37	4c 66 d8	jmp $d866	                jmp error
.9a3a					+
.9a3a	b5 00		lda $00,x	                lda 0,x
.9a3c	85 24		sta $24		                sta tmp1
.9a3e	b5 01		lda $01,x	                lda 1,x
.9a40	85 25		sta $25		                sta tmp1+1
.9a42	20 ed 95	jsr $95ed	                jsr xt_name_to_int              ; ( nt -- xt )
.9a45	e6 24		inc $24		                inc tmp1
.9a47	d0 02		bne $9a4b	                bne +
.9a49	e6 25		inc $25		                inc tmp1+1
.9a4b					+
.9a4b	b2 24		lda ($24)	                lda (tmp1)
.9a4d	29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a4f	f0 05		beq $9a56	                beq _not_immediate
.9a51	20 f9 87	jsr $87f9	                jsr xt_compile_comma
.9a54	80 0a		bra $9a60	                bra _done
.9a56					_not_immediate:
.9a56	20 96 93	jsr $9396	                jsr xt_literal
.9a59	a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a5b	a9 f9		lda #$f9	                lda #<xt_compile_comma
.9a5d	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.9a60					_done:
.9a60	60		rts		z_postpone:     rts
.9a61					xt_previous:
.9a61	20 40 91	jsr $9140	                jsr xt_get_order
.9a64	20 4e 96	jsr $964e	                jsr xt_nip
.9a67	20 1d 98	jsr $981d	                jsr xt_one_minus
.9a6a	20 27 9d	jsr $9d27	                jsr xt_set_order
.9a6d	60		rts		z_previous:     rts
.9a6e					xt_question:
.9a6e	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.9a71	20 42 8c	jsr $8c42	                jsr xt_dot
.9a74	60		rts		z_question:     rts
.9a75					xt_question_dup:
.9a75	20 50 d8	jsr $d850	                jsr underflow_1
.9a78	b5 00		lda $00,x	                lda 0,x
.9a7a	15 01		ora $01,x	                ora 1,x
.9a7c	f0 0a		beq $9a88	                beq _done
.9a7e	ca		dex		                dex
.9a7f	ca		dex		                dex
.9a80	b5 02		lda $02,x	                lda 2,x
.9a82	95 00		sta $00,x	                sta 0,x
.9a84	b5 03		lda $03,x	                lda 3,x
.9a86	95 01		sta $01,x	                sta 1,x
.9a88					_done:
.9a88	60		rts		z_question_dup: rts
.9a89					xt_r_fetch:
.9a89	7a		ply		                ply             ; LSB
.9a8a	84 24		sty $24		                sty tmp1
.9a8c	7a		ply		                ply             ; MSB
.9a8d	ca		dex		                dex
.9a8e	ca		dex		                dex
.9a8f	68		pla		                pla             ; LSB
.9a90	95 00		sta $00,x	                sta 0,x
.9a92	68		pla		                pla             ; MSB
.9a93	95 01		sta $01,x	                sta 1,x
.9a95	48		pha		                pha
.9a96	b5 00		lda $00,x	                lda 0,x
.9a98	48		pha		                pha
.9a99	5a		phy		                phy             ; MSB
.9a9a	a4 24		ldy $24		                ldy tmp1
.9a9c	5a		phy		                phy             ; LSB
.9a9d	60		rts		z_r_fetch:      rts
.9a9e					xt_r_from:
.9a9e	68		pla		                pla             ; LSB
.9a9f	85 2c		sta $2c		                sta tmptos
.9aa1	7a		ply		                ply             ; MSB
.9aa2	ca		dex		                dex
.9aa3	ca		dex		                dex
.9aa4	68		pla		                pla             ; LSB
.9aa5	95 00		sta $00,x	                sta 0,x
.9aa7	68		pla		                pla             ; MSB
.9aa8	95 01		sta $01,x	                sta 1,x
.9aaa	5a		phy		                phy             ; MSB
.9aab	a5 2c		lda $2c		                lda tmptos
.9aad	48		pha		                pha             ; LSB
.9aae	60		rts		z_r_from:       rts
.9aaf					xt_r_to_input:
.9aaf	68		pla		                pla
.9ab0	85 24		sta $24		                sta tmp1
.9ab2	68		pla		                pla
.9ab3	85 25		sta $25		                sta tmp1+1
.9ab5	a0 00		ldy #$00	                ldy #0
.9ab7					_loop:
.9ab7	68		pla		                pla
.9ab8	99 06 00	sta $0006,y	                sta insrc,y
.9abb	c8		iny		                iny
.9abc	c0 08		cpy #$08	                cpy #8
.9abe	d0 f7		bne $9ab7	                bne _loop
.9ac0	a5 25		lda $25		                lda tmp1+1
.9ac2	48		pha		                pha
.9ac3	a5 24		lda $24		                lda tmp1
.9ac5	48		pha		                pha
.9ac6	60		rts		z_r_to_input: 	rts
.9ac7					xt_recurse:
.9ac7	a0 00		ldy #$00	                ldy #0
.9ac9	a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9acb	91 00		sta ($00),y	                sta (cp),y
.9acd	c8		iny		                iny
.9ace	24 20		bit $20		                bit status
.9ad0	70 0c		bvs $9ade	                bvs _nt_in_workword
.9ad2	a5 04		lda $04		                lda workword
.9ad4	91 00		sta ($00),y	                sta (cp),y
.9ad6	c8		iny		                iny
.9ad7	a5 05		lda $05		                lda workword+1
.9ad9	91 00		sta ($00),y	                sta (cp),y
.9adb	c8		iny		                iny
.9adc	80 1b		bra $9af9	                bra _update_cp
.9ade					_nt_in_workword:
.9ade	a5 04		lda $04		                lda workword            ; LSB
.9ae0	18		clc		                clc
.9ae1	69 04		adc #$04	                adc #4
.9ae3	85 24		sta $24		                sta tmp1
.9ae5	a5 05		lda $05		                lda workword+1          ; MSB
.9ae7	69 00		adc #$00	                adc #0
.9ae9	85 25		sta $25		                sta tmp1+1
.9aeb	b2 24		lda ($24)	                lda (tmp1)
.9aed	91 00		sta ($00),y	                sta (cp),y
.9aef	5a		phy		                phy
.9af0	a0 01		ldy #$01	                ldy #1
.9af2	b1 24		lda ($24),y	                lda (tmp1),y
.9af4	7a		ply		                ply
.9af5	c8		iny		                iny
.9af6	91 00		sta ($00),y	                sta (cp),y
.9af8	c8		iny		                iny
.9af9					_update_cp:
.9af9	98		tya		                tya
.9afa	18		clc		                clc
.9afb	65 00		adc $00		                adc cp
.9afd	85 00		sta $00		                sta cp
.9aff	90 02		bcc $9b03	                bcc _done
.9b01	e6 01		inc $01		                inc cp+1
.9b03					_done:
.9b03	60		rts		z_recurse:      rts
.9b04					xt_refill:
.9b04	a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9b06	d0 2d		bne $9b35	                bne _src_not_kbd
.9b08	ca		dex		                dex
.9b09	ca		dex		                dex
.9b0a	ca		dex		                dex
.9b0b	ca		dex		                dex
.9b0c	a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9b0e	95 02		sta $02,x	                sta 2,x
.9b10	a5 09		lda $09		                lda cib+1
.9b12	95 03		sta $03,x	                sta 3,x
.9b14	64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9b16	64 0b		stz $0b		                stz ciblen+1
.9b18	a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9b1a	95 00		sta $00,x	                sta 0,x
.9b1c	74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9b1e	20 38 81	jsr $8138	                jsr xt_accept           ; ( addr n1 -- n2)
.9b21	b5 00		lda $00,x	                lda 0,x
.9b23	85 0a		sta $0a		                sta ciblen
.9b25	b5 01		lda $01,x	                lda 1,x
.9b27	85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9b29	64 0c		stz $0c		                stz toin
.9b2b	64 0d		stz $0d		                stz toin+1
.9b2d	a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b2f	95 00		sta $00,x	                sta 0,x
.9b31	95 01		sta $01,x	                sta 1,x
.9b33	80 10		bra $9b45	                bra _done
.9b35					_src_not_kbd:
.9b35	1a		inc a		                ina
.9b36	d0 08		bne $9b40	                bne _src_not_string
.9b38	ca		dex		                dex
.9b39	ca		dex		                dex
.9b3a	74 00		stz $00,x	                stz 0,x
.9b3c	74 01		stz $01,x	                stz 1,x
.9b3e	80 05		bra $9b45	                bra z_refill
.9b40					_src_not_string:
.9b40	a9 01		lda #$01	                lda #err_badsource
.9b42	4c 66 d8	jmp $d866	                jmp error
.9b45					_done:
.9b45	60		rts		z_refill:       rts
.9b46					xt_repeat:
.9b46	20 73 82	jsr $8273	                jsr xt_again
.9b49	20 7e 91	jsr $917e	                jsr xt_here
.9b4c	20 ba a1	jsr $a1ba	                jsr xt_swap
.9b4f	20 99 a1	jsr $a199	                jsr xt_store
.9b52	60		rts		z_repeat:       rts
.9b53					xt_right_bracket:
.9b53	a9 ff		lda #$ff	                lda #$FF
.9b55	85 16		sta $16		                sta state
.9b57	85 17		sta $17		                sta state+1
.9b59					z_right_bracket:
.9b59	60		rts		                rts
.9b5a					xt_root_wordlist:
.9b5a	ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b5b	ca		dex		                dex
.9b5c	a9 03		lda #$03	                lda #3
.9b5e	95 00		sta $00,x	                sta 0,x
.9b60	74 01		stz $01,x	                stz 1,x
.9b62					z_root_wordlist:
.9b62	60		rts		                rts
.9b63					xt_rot:
.9b63	20 5a d8	jsr $d85a	                jsr underflow_3
.9b66	b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b68	b5 03		lda $03,x	                lda 3,x
.9b6a	95 05		sta $05,x	                sta 5,x
.9b6c	b5 01		lda $01,x	                lda 1,x
.9b6e	95 03		sta $03,x	                sta 3,x
.9b70	94 01		sty $01,x	                sty 1,x
.9b72	b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b74	b5 02		lda $02,x	                lda 2,x
.9b76	95 04		sta $04,x	                sta 4,x
.9b78	b5 00		lda $00,x	                lda 0,x
.9b7a	95 02		sta $02,x	                sta 2,x
.9b7c	94 00		sty $00,x	                sty 0,x
.9b7e	60		rts		z_rot:          rts
.9b7f					xt_rshift:
.9b7f	20 55 d8	jsr $d855	                jsr underflow_2
.9b82	b5 00		lda $00,x	                lda 0,x
.9b84	29 0f		and #$0f	                and #%00001111
.9b86	f0 08		beq $9b90	                beq _done               ; if 0 shifts, quit
.9b88	a8		tay		                tay
.9b89					_loop:
.9b89	56 03		lsr $03,x	                lsr 3,x
.9b8b	76 02		ror $02,x	                ror 2,x
.9b8d	88		dey		                dey
.9b8e	d0 f9		bne $9b89	                bne _loop
.9b90					_done:
.9b90	e8		inx		                inx
.9b91	e8		inx		                inx
.9b92	60		rts		z_rshift:       rts
.9b93					xt_s_backslash_quote:
.9b93	a9 ff		lda #$ff	                lda #$FF
.9b95	85 26		sta $26		                sta tmp2
.9b97	64 27		stz $27		                stz tmp2+1
.9b99	20 5f 9d	jsr $9d5f	                jsr s_quote_start
.9b9c					_done:
.9b9c					z_s_backslash_quote:
.9b9c	60		rts		                rts
.9b9d					convert_hex_value:
.9b9d	c9 41		cmp #$41	        cmp #'A'
.9b9f	90 07		bcc $9ba8	        bcc _digit
.9ba1	29 df		and #$df	        and #$DF                ; Make it uppercase.
.9ba3	38		sec		        sec
.9ba4	e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9ba6	80 03		bra $9bab	        bra _done
.9ba8					_digit:
.9ba8	38		sec		        sec
.9ba9	e9 30		sbc #$30	        sbc #'0'
.9bab					_done:
.9bab	60		rts		        rts
.9bac					xt_search_wordlist:
.9bac	20 5a d8	jsr $d85a	                jsr underflow_3
.9baf	a5 1e		lda $1e		                lda up
.9bb1	18		clc		                clc
.9bb2	69 06		adc #$06	                adc #wordlists_offset
.9bb4	85 26		sta $26		                sta tmp2
.9bb6	a5 1f		lda $1f		                lda up+1
.9bb8	69 00		adc #$00	                adc #0          ; Adding carry
.9bba	85 27		sta $27		                sta tmp2+1
.9bbc	b5 00		lda $00,x	                lda 0,x
.9bbe	0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9bbf	65 26		adc $26		                adc tmp2
.9bc1	85 26		sta $26		                sta tmp2
.9bc3	90 02		bcc $9bc7	                bcc +
.9bc5	e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9bc7					+
.9bc7	e8		inx		                inx
.9bc8	e8		inx		                inx
.9bc9	b5 00		lda $00,x	                lda 0,x
.9bcb	15 01		ora $01,x	                ora 1,x
.9bcd	d0 03		bne $9bd2	                bne _check_wordlist
.9bcf	4c 8a 9c	jmp $9c8a	                jmp _done
.9bd2					_check_wordlist:
.9bd2	a5 26		lda $26		                lda tmp2
.9bd4	05 27		ora $27		                ora tmp2+1
.9bd6	d0 03		bne $9bdb	                bne _have_string
.9bd8	4c 8a 9c	jmp $9c8a	                jmp _done
.9bdb					_have_string:
.9bdb	b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9bdd	85 24		sta $24		                sta tmp1
.9bdf	e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9be1	d0 02		bne $9be5	                bne +
.9be3	e6 27		inc $27		                inc tmp2+1
.9be5					+
.9be5	b2 26		lda ($26)	                lda (tmp2)
.9be7	85 25		sta $25		                sta tmp1+1
.9be9	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9beb	85 26		sta $26		                sta tmp2
.9bed	b5 03		lda $03,x	                lda 3,x
.9bef	85 27		sta $27		                sta tmp2+1
.9bf1					_loop:
.9bf1	b2 24		lda ($24)	                lda (tmp1)
.9bf3	d5 00		cmp $00,x	                cmp 0,x
.9bf5	d0 7b		bne $9c72	                bne _next_entry
.9bf7					_compare_string:
.9bf7	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9bf9	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bfb	b0 07		bcs $9c04	                bcs _compare_first
.9bfd	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bff	90 03		bcc $9c04	                bcc _compare_first
.9c01	18		clc		                clc
.9c02	69 20		adc #$20	                adc #$20
.9c04					_compare_first:
.9c04	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9c06	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9c08	d0 68		bne $9c72	                bne _next_entry
.9c0a	b5 00		lda $00,x	                lda 0,x
.9c0c	3a		dec a		                dea
.9c0d	f0 2c		beq $9c3b	                beq _success
.9c0f	a5 24		lda $24		                lda tmp1
.9c11	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9c12	18		clc		                clc
.9c13	69 08		adc #$08	                adc #8
.9c15	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9c17	a5 25		lda $25		                lda tmp1+1
.9c19	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9c1a	69 00		adc #$00	                adc #0          ; we only need the carry
.9c1c	85 25		sta $25		                sta tmp1+1
.9c1e	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9c20	88		dey		                dey
.9c21					_string_loop:
.9c21	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9c23	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9c25	b0 07		bcs $9c2e	                bcs _check_char
.9c27	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9c29	90 03		bcc $9c2e	                bcc _check_char
.9c2b	18		clc		                clc
.9c2c	69 20		adc #$20	                adc #$20
.9c2e					_check_char:
.9c2e	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c30	d0 3a		bne $9c6c	                bne _next_entry_tmp1
.9c32	88		dey		                dey
.9c33	d0 ec		bne $9c21	                bne _string_loop
.9c35					_success_tmp1:
.9c35	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c36	85 25		sta $25		                sta tmp1+1
.9c38	68		pla		                pla
.9c39	85 24		sta $24		                sta tmp1
.9c3b					_success:
.9c3b	e8		inx		                inx
.9c3c	e8		inx		                inx
.9c3d	a5 24		lda $24		                lda tmp1
.9c3f	95 00		sta $00,x	                sta 0,x
.9c41	a5 25		lda $25		                lda tmp1+1
.9c43	95 01		sta $01,x	                sta 1,x
.9c45	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( nt nt )
.9c48	20 ed 95	jsr $95ed	                jsr xt_name_to_int      ; ( nt xt )
.9c4b	20 ba a1	jsr $a1ba	                jsr xt_swap             ; ( xt nt )
.9c4e	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c50	f6 00		inc $00,x	                inc 0,x
.9c52	d0 02		bne $9c56	                bne +
.9c54	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c56					+
.9c56	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c58	29 04		and #$04	                and #IM
.9c5a	d0 08		bne $9c64	                bne _immediate          ; bit set, we're immediate
.9c5c	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c5e	95 00		sta $00,x	                sta 0,x
.9c60	95 01		sta $01,x	                sta 1,x
.9c62	80 28		bra $9c8c	                bra _done_nodrop
.9c64					_immediate:
.9c64	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c66	95 00		sta $00,x	                sta 0,x
.9c68	74 01		stz $01,x	                stz 1,x
.9c6a	80 20		bra $9c8c	                bra _done_nodrop
.9c6c					_next_entry_tmp1:
.9c6c	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c6d	85 25		sta $25		                sta tmp1+1
.9c6f	68		pla		                pla
.9c70	85 24		sta $24		                sta tmp1
.9c72					_next_entry:
.9c72	a0 02		ldy #$02	                ldy #2
.9c74	b1 24		lda ($24),y	                lda (tmp1),y
.9c76	48		pha		                pha
.9c77	c8		iny		                iny
.9c78	b1 24		lda ($24),y	                lda (tmp1),y
.9c7a	85 25		sta $25		                sta tmp1+1
.9c7c	68		pla		                pla
.9c7d	85 24		sta $24		                sta tmp1
.9c7f	05 25		ora $25		                ora tmp1+1
.9c81	f0 03		beq $9c86	                beq _fail_done
.9c83	4c f1 9b	jmp $9bf1	                jmp _loop
.9c86					_fail_done:
.9c86	74 02		stz $02,x	                stz 2,x         ; failure flag
.9c88	74 03		stz $03,x	                stz 3,x
.9c8a					_done:
.9c8a	e8		inx		                inx
.9c8b	e8		inx		                inx
.9c8c					_done_nodrop:
.9c8c					z_search_wordlist:
.9c8c	60		rts		                rts
.9c8d					xt_see:
.9c8d	20 eb 98	jsr $98eb	                jsr xt_parse_name       ; ( addr u )
.9c90	20 e7 8f	jsr $8fe7	                jsr xt_find_name        ; ( nt | 0 )
.9c93	b5 00		lda $00,x	                lda 0,x
.9c95	15 01		ora $01,x	                ora 1,x
.9c97	d0 05		bne $9c9e	                bne +
.9c99	a9 05		lda #$05	                lda #err_noname
.9c9b	4c 66 d8	jmp $d866	                jmp error
.9c9e					+
.9c9e	20 6f 89	jsr $896f	                jsr xt_cr
.9ca1	a5 18		lda $18		                lda base
.9ca3	48		pha		                pha
.9ca4	20 89 91	jsr $9189	                jsr xt_hex
.9ca7	a9 0a		lda #$0a	                lda #str_see_nt
.9ca9	20 8c d8	jsr $d88c	                jsr print_string_no_lf
.9cac	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( nt nt )
.9caf	20 3a a5	jsr $a53a	                jsr xt_u_dot
.9cb2	20 2a a1	jsr $a12a	                jsr xt_space            ; ( nt )
.9cb5	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( nt nt )
.9cb8	20 ed 95	jsr $95ed	                jsr xt_name_to_int      ; ( nt xt )
.9cbb	a9 0b		lda #$0b	                lda #str_see_xt
.9cbd	20 8c d8	jsr $d88c	                jsr print_string_no_lf
.9cc0	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( nt xt xt )
.9cc3	20 3a a5	jsr $a53a	                jsr xt_u_dot
.9cc6	20 6f 89	jsr $896f	                jsr xt_cr               ; ( nt xt )
.9cc9	a9 09		lda #$09	                lda #str_see_flags
.9ccb	20 8c d8	jsr $d88c	                jsr print_string_no_lf
.9cce	20 9f 98	jsr $989f	                jsr xt_over             ; ( nt xt nt )
.9cd1	20 29 98	jsr $9829	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9cd4	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; ( nt xt flags )
.9cd7	b5 00		lda $00,x	                lda 0,x
.9cd9	a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9cdb					_flag_loop:
.9cdb	48		pha		                pha
.9cdc	29 01		and #$01	                and #%00000001
.9cde	18		clc		                clc
.9cdf	69 30		adc #$30	                adc #$30                ; ASCII "0"
.9ce1	20 02 8e	jsr $8e02	                jsr emit_a
.9ce4	20 2a a1	jsr $a12a	                jsr xt_space
.9ce7	68		pla		                pla
.9ce8	6a		ror a		                ror                     ; Next flag
.9ce9	88		dey		                dey
.9cea	d0 ef		bne $9cdb	                bne _flag_loop
.9cec	20 6f 89	jsr $896f	                jsr xt_cr
.9cef	e8		inx		                inx
.9cf0	e8		inx		                inx                     ; ( nt xt )
.9cf1	a9 0c		lda #$0c	                lda #str_see_size
.9cf3	20 8c d8	jsr $d88c	                jsr print_string_no_lf
.9cf6	20 ba a1	jsr $a1ba	                jsr xt_swap             ; ( xt nt )
.9cf9	20 81 a7	jsr $a781	                jsr xt_wordsize         ; ( xt u )
.9cfc	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9cff	20 b1 8a	jsr $8ab1	                jsr xt_decimal
.9d02	20 3a a5	jsr $a53a	                jsr xt_u_dot            ; ( xt u )
.9d05	20 89 91	jsr $9189	                jsr xt_hex
.9d08	20 6f 89	jsr $896f	                jsr xt_cr
.9d0b	20 c4 a3	jsr $a3c4	                jsr xt_two_dup          ; ( xt u xt u )
.9d0e	20 40 8d	jsr $8d40	                jsr xt_dump
.9d11	20 6f 89	jsr $896f	                jsr xt_cr
.9d14	20 46 8b	jsr $8b46	                jsr xt_disasm
.9d17	68		pla		                pla
.9d18	85 18		sta $18		                sta base
.9d1a	60		rts		z_see:          rts
.9d1b					xt_set_current:
.9d1b	20 50 d8	jsr $d850	                jsr underflow_1
.9d1e	a0 04		ldy #$04	                ldy #current_offset
.9d20	b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9d22	91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9d24	e8		inx		                inx
.9d25	e8		inx		                inx
.9d26	60		rts		z_set_current:  rts
.9d27					xt_set_order:
.9d27	a9 ff		lda #$ff	                lda #$FF
.9d29	d5 01		cmp $01,x	                cmp 1,x
.9d2b	d0 12		bne $9d3f	                bne _start
.9d2d	d5 00		cmp $00,x	                cmp 0,x
.9d2f	d0 0e		bne $9d3f	                bne _start
.9d31	ca		dex		                dex             ; Make room for the count.
.9d32	ca		dex		                dex
.9d33	74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d35	a9 03		lda #$03	                lda #3
.9d37	95 02		sta $02,x	                sta 2,x
.9d39	74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d3b	a9 01		lda #$01	                lda #1
.9d3d	95 00		sta $00,x	                sta 0,x
.9d3f					_start:
.9d3f	a0 1e		ldy #$1e	                ldy #num_order_offset
.9d41	b5 00		lda $00,x	                lda 0,x
.9d43	91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d45	85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d47	e8		inx		                inx             ; Drop the count off the data stack.
.9d48	e8		inx		                inx
.9d49	a5 24		lda $24		                lda tmp1
.9d4b	f0 0d		beq $9d5a	                beq _done       ; If zero, there are no wordlists.
.9d4d	a0 1f		ldy #$1f	                ldy #search_order_offset
.9d4f					_loop:
.9d4f	b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d51	91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d53	c8		iny		                iny
.9d54	e8		inx		                inx
.9d55	e8		inx		                inx
.9d56	c6 24		dec $24		                dec tmp1
.9d58	d0 f5		bne $9d4f	                bne _loop
.9d5a					_done:
.9d5a	60		rts		z_set_order:    rts
.9d5b					xt_s_quote:
.9d5b	64 26		stz $26		                stz tmp2
.9d5d	64 27		stz $27		                stz tmp2+1
.9d5f					s_quote_start:
.9d5f	ca		dex		                dex
.9d60	ca		dex		                dex
.9d61	ca		dex		                dex
.9d62	ca		dex		                dex
.9d63	a9 4c		lda #$4c	                lda #$4C
.9d65	20 03 d7	jsr $d703	                jsr cmpl_a
.9d68	20 03 d7	jsr $d703	                jsr cmpl_a
.9d6b	20 03 d7	jsr $d703	                jsr cmpl_a
.9d6e	a5 00		lda $00		                lda cp
.9d70	95 02		sta $02,x	                sta 2,x
.9d72	a5 01		lda $01		                lda cp+1
.9d74	95 03		sta $03,x	                sta 3,x
.9d76					_savechars_loop:
.9d76	a5 0d		lda $0d		                lda toin+1              ; MSB
.9d78	c5 0b		cmp $0b		                cmp ciblen+1
.9d7a	90 2a		bcc $9da6	                bcc _input_fine         ; unsigned comparison
.9d7c	a5 0c		lda $0c		                lda toin                ; LSB
.9d7e	c5 0a		cmp $0a		                cmp ciblen
.9d80	90 24		bcc $9da6	                bcc _input_fine
.9d82	a5 26		lda $26		                lda tmp2
.9d84	48		pha		                pha
.9d85	a5 27		lda $27		                lda tmp2+1
.9d87	48		pha		                pha
.9d88	a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d8a	48		pha		                pha
.9d8b	20 04 9b	jsr $9b04	                jsr xt_refill           ; ( -- f )
.9d8e	68		pla		                pla
.9d8f	85 28		sta $28		                sta tmp3
.9d91	68		pla		                pla
.9d92	85 27		sta $27		                sta tmp2+1
.9d94	68		pla		                pla
.9d95	85 26		sta $26		                sta tmp2
.9d97	b5 00		lda $00,x	                lda 0,x
.9d99	15 01		ora $01,x	                ora 1,x
.9d9b	d0 05		bne $9da2	                bne _refill_ok
.9d9d	a9 06		lda #$06	                lda #err_refill
.9d9f	4c 66 d8	jmp $d866	                jmp error
.9da2					_refill_ok:
.9da2	e8		inx		                inx
.9da3	e8		inx		                inx
.9da4	80 d0		bra $9d76	                bra _savechars_loop
.9da6					_input_fine:
.9da6	a5 08		lda $08		                lda cib
.9da8	18		clc		                clc
.9da9	65 0c		adc $0c		                adc toin        ; LSB
.9dab	85 24		sta $24		                sta tmp1
.9dad	a5 09		lda $09		                lda cib+1
.9daf	65 0d		adc $0d		                adc toin+1      ; MSB
.9db1	85 25		sta $25		                sta tmp1+1
.9db3	b2 24		lda ($24)	                lda (tmp1)
.9db5	24 26		bit $26		                bit tmp2
.9db7	30 03		bmi $9dbc	                bmi _handle_escapes    ; Only checking bit 7
.9db9	4c 74 9e	jmp $9e74	                jmp _regular_char
.9dbc					_handle_escapes:
.9dbc	24 27		bit $27		                bit tmp2+1
.9dbe	30 03		bmi $9dc3	                bmi _escaped
.9dc0	4c 6a 9e	jmp $9e6a	                jmp _not_escaped
.9dc3					_escaped:
.9dc3	70 22		bvs $9de7	                bvs _check_esc_chars
.9dc5	a9 01		lda #$01	                lda #1
.9dc7	24 27		bit $27		                bit tmp2+1
.9dc9	d0 10		bne $9ddb	                bne _esc_x_second_digit
.9dcb	e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9dcd	b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9dcf	20 9d 9b	jsr $9b9d	                jsr convert_hex_value
.9dd2	0a		asl a		                asl
.9dd3	0a		asl a		                asl
.9dd4	0a		asl a		                asl
.9dd5	0a		asl a		                asl
.9dd6	85 28		sta $28		                sta tmp3    ; Save it for later.
.9dd8	4c 7b 9e	jmp $9e7b	                jmp _next_character
.9ddb					_esc_x_second_digit:
.9ddb	64 27		stz $27		                stz tmp2+1
.9ddd	b2 24		lda ($24)	                lda (tmp1)
.9ddf	20 9d 9b	jsr $9b9d	                jsr convert_hex_value
.9de2	05 28		ora $28		                ora tmp3
.9de4	4c 78 9e	jmp $9e78	                jmp _save_character
.9de7					_check_esc_chars:
.9de7	64 27		stz $27		                stz tmp2+1
.9de9					_check_esc_a:
.9de9	c9 61		cmp #$61	                cmp #'a'
.9deb	d0 05		bne $9df2	                bne _check_esc_b
.9ded	a9 07		lda #$07	                lda #7
.9def	4c 78 9e	jmp $9e78	                jmp _save_character
.9df2					_check_esc_b:
.9df2	c9 62		cmp #$62	                cmp #'b'
.9df4	d0 05		bne $9dfb	                bne _check_esc_e
.9df6	a9 08		lda #$08	                lda #8
.9df8	4c 78 9e	jmp $9e78	                jmp _save_character
.9dfb					_check_esc_e:
.9dfb	c9 65		cmp #$65	                cmp #'e'
.9dfd	d0 04		bne $9e03	                bne _check_esc_f
.9dff	a9 1b		lda #$1b	                lda #27
.9e01	80 75		bra $9e78	                bra _save_character
.9e03					_check_esc_f:
.9e03	c9 66		cmp #$66	                cmp #'f'
.9e05	d0 04		bne $9e0b	                bne _check_esc_l
.9e07	a9 0c		lda #$0c	                lda #12
.9e09	80 6d		bra $9e78	                bra _save_character
.9e0b					_check_esc_l:
.9e0b	c9 6c		cmp #$6c	                cmp #'l'
.9e0d	d0 04		bne $9e13	                bne _check_esc_m
.9e0f	a9 0a		lda #$0a	                lda #10
.9e11	80 65		bra $9e78	                bra _save_character
.9e13					_check_esc_m:
.9e13	c9 6d		cmp #$6d	                cmp #'m'
.9e15	d0 09		bne $9e20	                bne _check_esc_n
.9e17	a9 0d		lda #$0d	                lda #13
.9e19	20 03 d7	jsr $d703	                jsr cmpl_a
.9e1c	a9 0a		lda #$0a	                lda #10
.9e1e	80 58		bra $9e78	                bra _save_character
.9e20					_check_esc_n:
.9e20	c9 6e		cmp #$6e	                cmp #'n'
.9e22	d0 04		bne $9e28	                bne _check_esc_q
.9e24	a9 0a		lda #$0a	                lda #10
.9e26	80 50		bra $9e78	                bra _save_character
.9e28					_check_esc_q:
.9e28	c9 71		cmp #$71	                cmp #'q'
.9e2a	d0 04		bne $9e30	                bne _check_esc_r
.9e2c	a9 22		lda #$22	                lda #34
.9e2e	80 48		bra $9e78	                bra _save_character
.9e30					_check_esc_r:
.9e30	c9 72		cmp #$72	                cmp #'r'
.9e32	d0 04		bne $9e38	                bne _check_esc_t
.9e34	a9 0d		lda #$0d	                lda #13
.9e36	80 40		bra $9e78	                bra _save_character
.9e38					_check_esc_t:
.9e38	c9 74		cmp #$74	                cmp #'t'
.9e3a	d0 04		bne $9e40	                bne _check_esc_v
.9e3c	a9 09		lda #$09	                lda #9
.9e3e	80 38		bra $9e78	                bra _save_character
.9e40					_check_esc_v:
.9e40	c9 76		cmp #$76	                cmp #'v'
.9e42	d0 04		bne $9e48	                bne _check_esc_z
.9e44	a9 0b		lda #$0b	                lda #11
.9e46	80 30		bra $9e78	                bra _save_character
.9e48					_check_esc_z:
.9e48	c9 7a		cmp #$7a	                cmp #'z'
.9e4a	d0 04		bne $9e50	                bne _check_esc_quote
.9e4c	a9 00		lda #$00	                lda #0
.9e4e	80 28		bra $9e78	                bra _save_character
.9e50					_check_esc_quote:
.9e50	c9 22		cmp #$22	                cmp #$22
.9e52	d0 04		bne $9e58	                bne _check_esc_x
.9e54	a9 22		lda #$22	                lda #34
.9e56	80 20		bra $9e78	                bra _save_character
.9e58					_check_esc_x:
.9e58	c9 78		cmp #$78	                cmp #'x'
.9e5a	d0 06		bne $9e62	                bne _check_esc_backslash
.9e5c	a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e5e	85 27		sta $27		                sta tmp2+1
.9e60	80 19		bra $9e7b	                bra _next_character
.9e62					_check_esc_backslash:
.9e62	c9 5c		cmp #$5c	                cmp #$5C
.9e64	d0 04		bne $9e6a	                bne _not_escaped
.9e66	a9 5c		lda #$5c	                lda #92
.9e68	80 0e		bra $9e78	                bra _save_character
.9e6a					_not_escaped:
.9e6a	c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e6c	d0 06		bne $9e74	                bne _regular_char
.9e6e	a9 ff		lda #$ff	                lda #$FF
.9e70	85 27		sta $27		                sta tmp2+1
.9e72	80 07		bra $9e7b	                bra _next_character
.9e74					_regular_char:
.9e74	c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e76	f0 0c		beq $9e84	                beq _found_string_end
.9e78					_save_character:
.9e78	20 03 d7	jsr $d703	                jsr cmpl_a
.9e7b					_next_character:
.9e7b	e6 0c		inc $0c		                inc toin
.9e7d	d0 02		bne $9e81	                bne _savechars_loop_longjump
.9e7f	e6 0d		inc $0d		                inc toin+1
.9e81					_savechars_loop_longjump:
.9e81	4c 76 9d	jmp $9d76	                jmp _savechars_loop
.9e84					_found_string_end:
.9e84	e6 0c		inc $0c		                inc toin
.9e86	d0 02		bne $9e8a	                bne +
.9e88	e6 0d		inc $0d		                inc toin+1
.9e8a					+
.9e8a	a5 00		lda $00		                lda cp
.9e8c	38		sec		                sec
.9e8d	f5 02		sbc $02,x	                sbc 2,x
.9e8f	95 00		sta $00,x	                sta 0,x         ; LSB
.9e91	a5 01		lda $01		                lda cp+1
.9e93	f5 03		sbc $03,x	                sbc 3,x
.9e95	95 01		sta $01,x	                sta 1,x         ; MSB
.9e97	b5 02		lda $02,x	                lda 2,x
.9e99	38		sec		                sec
.9e9a	e9 02		sbc #$02	                sbc #2
.9e9c	85 24		sta $24		                sta tmp1
.9e9e	b5 03		lda $03,x	                lda 3,x
.9ea0	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9ea2	85 25		sta $25		                sta tmp1+1
.9ea4	a5 00		lda $00		                lda cp
.9ea6	92 24		sta ($24)	                sta (tmp1)
.9ea8	a0 01		ldy #$01	                ldy #1
.9eaa	a5 01		lda $01		                lda cp+1
.9eac	91 24		sta ($24),y	                sta (tmp1),y
.9eae	a5 16		lda $16		                lda state
.9eb0	05 17		ora $17		                ora state+1             ; paranoid
.9eb2	f0 03		beq $9eb7	                beq _done
.9eb4	20 9b a0	jsr $a09b	                jsr sliteral_const_str         ; ( addr u -- )
.9eb7					_done:
.9eb7	60		rts		z_s_quote:      rts
.9eb8					xt_s_to_d:
.9eb8	20 50 d8	jsr $d850	                jsr underflow_1
.9ebb	ca		dex		                dex
.9ebc	ca		dex		                dex
.9ebd	74 00		stz $00,x	                stz 0,x
.9ebf	74 01		stz $01,x	                stz 1,x
.9ec1	b5 03		lda $03,x	                lda 3,x
.9ec3	10 04		bpl $9ec9	                bpl _done
.9ec5	d6 00		dec $00,x	                dec 0,x
.9ec7	d6 01		dec $01,x	                dec 1,x
.9ec9					_done:
.9ec9	60		rts		z_s_to_d:       rts
.9eca					xt_save_buffers:
.9eca	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9ecc	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9ece	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9ed0	d0 12		bne $9ee4	                bne _done       ; Either not used or not dirty = done!
.9ed2	20 bf 83	jsr $83bf	                jsr xt_blkbuffer
.9ed5	20 b1 85	jsr $85b1	                jsr xt_buffblocknum
.9ed8	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.9edb	20 6c 85	jsr $856c	                jsr xt_block_write
.9ede	a9 01		lda #$01	                lda #1
.9ee0	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9ee2	91 1e		sta ($1e),y	                sta (up),y
.9ee4					_done:
.9ee4	60		rts		z_save_buffers: rts
.9ee5					xt_scr:
.9ee5	ca		dex		                dex
.9ee6	ca		dex		                dex
.9ee7	18		clc		                clc
.9ee8	a5 1e		lda $1e		                lda up
.9eea	69 02		adc #$02	                adc #scr_offset ; Add offset
.9eec	95 00		sta $00,x	                sta 0,x
.9eee	a5 1f		lda $1f		                lda up+1
.9ef0	69 00		adc #$00	                adc #0          ; Adding carry
.9ef2	95 01		sta $01,x	                sta 1,x
.9ef4	60		rts		z_scr:          rts
.9ef5					xt_search:
.9ef5	20 5f d8	jsr $d85f	                jsr underflow_4
.9ef8	b5 00		lda $00,x	                lda 0,x
.9efa	15 01		ora $01,x	                ora 1,x
.9efc	d0 0b		bne $9f09	                bne _start_search
.9efe	e8		inx		                inx             ; Remove u2
.9eff	e8		inx		                inx
.9f00	a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9f02	95 00		sta $00,x	                sta 0,x
.9f04	95 01		sta $01,x	                sta 1,x
.9f06	4c 93 9f	jmp $9f93	                jmp z_search
.9f09					_start_search:
.9f09	20 b4 a7	jsr $a7b4	                jsr xt_zero
.9f0c					_search_loop:
.9f0c	18		clc		                clc
.9f0d	b5 00		lda $00,x	                lda 0,x
.9f0f	75 02		adc $02,x	                adc 2,x
.9f11	85 24		sta $24		                sta tmp1
.9f13	b5 01		lda $01,x	                lda 1,x
.9f15	75 03		adc $03,x	                adc 3,x
.9f17	d5 07		cmp $07,x	                cmp 7,x
.9f19	90 12		bcc $9f2d	                bcc _init_comparison ; Obviously less
.9f1b	d0 06		bne $9f23	                bne _not_found
.9f1d	b5 06		lda $06,x	                lda 6,x
.9f1f	c5 24		cmp $24		                cmp tmp1
.9f21	b0 0a		bcs $9f2d	                bcs _init_comparison
.9f23					_not_found:
.9f23	e8		inx		                inx             ; Remove offset
.9f24	e8		inx		                inx
.9f25	e8		inx		                inx             ; Remove u2
.9f26	e8		inx		                inx
.9f27	74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9f29	74 01		stz $01,x	                stz 1,x
.9f2b	80 66		bra $9f93	                bra z_search
.9f2d					_init_comparison:
.9f2d	18		clc		                clc
.9f2e	b5 08		lda $08,x	                lda 8,x
.9f30	75 00		adc $00,x	                adc 0,x
.9f32	85 24		sta $24		                sta tmp1
.9f34	b5 09		lda $09,x	                lda 9,x
.9f36	75 01		adc $01,x	                adc 1,x
.9f38	85 25		sta $25		                sta tmp1+1
.9f3a	b5 04		lda $04,x	                lda 4,x
.9f3c	85 26		sta $26		                sta tmp2
.9f3e	b5 05		lda $05,x	                lda 5,x
.9f40	85 27		sta $27		                sta tmp2+1
.9f42	b5 02		lda $02,x	                lda 2,x
.9f44	85 28		sta $28		                sta tmp3
.9f46	b5 03		lda $03,x	                lda 3,x
.9f48	85 29		sta $29		                sta tmp3+1
.9f4a					_comparison_loop:
.9f4a	b2 24		lda ($24)	                lda (tmp1)
.9f4c	d2 26		cmp ($26)	                cmp (tmp2)
.9f4e	f0 05		beq $9f55	                beq _letters_match
.9f50	20 29 98	jsr $9829	                jsr xt_one_plus
.9f53	80 b7		bra $9f0c	                bra _search_loop
.9f55					_letters_match:
.9f55	e6 24		inc $24		                inc tmp1
.9f57	d0 02		bne $9f5b	                bne +
.9f59	e6 25		inc $25		                inc tmp1+1
.9f5b					+
.9f5b	e6 26		inc $26		                inc tmp2
.9f5d	d0 02		bne $9f61	                bne +
.9f5f	e6 27		inc $27		                inc tmp2+1
.9f61					+
.9f61	a5 28		lda $28		                lda tmp3
.9f63	d0 02		bne $9f67	                bne +
.9f65	c6 29		dec $29		                dec tmp3+1
.9f67					+
.9f67	c6 28		dec $28		                dec tmp3
.9f69	a5 28		lda $28		                lda tmp3
.9f6b	05 29		ora $29		                ora tmp3+1
.9f6d	d0 db		bne $9f4a	                bne _comparison_loop ; Check the next letter
.9f6f	18		clc		                clc
.9f70	b5 00		lda $00,x	                lda 0,x
.9f72	75 08		adc $08,x	                adc 8,x
.9f74	95 08		sta $08,x	                sta 8,x
.9f76	b5 01		lda $01,x	                lda 1,x
.9f78	75 09		adc $09,x	                adc 9,x
.9f7a	95 09		sta $09,x	                sta 9,x
.9f7c	38		sec		                sec
.9f7d	b5 06		lda $06,x	                lda 6,x
.9f7f	f5 00		sbc $00,x	                sbc 0,x
.9f81	95 06		sta $06,x	                sta 6,x
.9f83	b5 07		lda $07,x	                lda 7,x
.9f85	f5 01		sbc $01,x	                sbc 1,x
.9f87	95 07		sta $07,x	                sta 7,x
.9f89	e8		inx		                inx             ; drop offset
.9f8a	e8		inx		                inx
.9f8b	e8		inx		                inx             ; drop u2
.9f8c	e8		inx		                inx
.9f8d	a9 ff		lda #$ff	                lda #$FF
.9f8f	95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f91	95 01		sta $01,x	                sta 1,x
.9f93	60		rts		z_search:       rts
.9f94					xt_semicolon:
.9f94	24 20		bit $20		                bit status
.9f96	70 11		bvs $9fa9	                bvs _colonword
.9f98	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f9a	20 03 d7	jsr $d703	                jsr cmpl_a
.9f9d	ca		dex		                dex
.9f9e	ca		dex		                dex
.9f9f	a5 04		lda $04		                lda workword
.9fa1	95 00		sta $00,x	                sta 0,x
.9fa3	a5 05		lda $05		                lda workword+1
.9fa5	95 01		sta $01,x	                sta 1,x
.9fa7	80 45		bra $9fee	                bra _semicolon_done
.9fa9					_colonword:
.9fa9	a0 06		ldy #$06	                ldy #6
.9fab	a5 00		lda $00		                lda cp
.9fad	91 04		sta ($04),y	                sta (workword),y
.9faf	c8		iny		                iny
.9fb0	a5 01		lda $01		                lda cp+1
.9fb2	91 04		sta ($04),y	                sta (workword),y
.9fb4	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9fb6	20 03 d7	jsr $d703	                jsr cmpl_a
.9fb9	24 20		bit $20		                bit status
.9fbb	10 26		bpl $9fe3	                bpl _new_word   ; Bit 7 is clear = new word
.9fbd	ca		dex		                dex
.9fbe	ca		dex		                dex
.9fbf	ca		dex		                dex
.9fc0	ca		dex		                dex
.9fc1	b2 04		lda ($04)	                lda (workword)
.9fc3	95 00		sta $00,x	                sta 0,x
.9fc5	74 01		stz $01,x	                stz 1,x
.9fc7	a5 04		lda $04		                lda workword
.9fc9	18		clc		                clc
.9fca	69 08		adc #$08	                adc #8
.9fcc	95 02		sta $02,x	                sta 2,x
.9fce	a5 05		lda $05		                lda workword+1
.9fd0	69 00		adc #$00	                adc #0                  ; only want carry
.9fd2	95 03		sta $03,x	                sta 3,x
.9fd4	a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9fd6	20 8c d8	jsr $d88c	                jsr print_string_no_lf
.9fd9	20 0f a5	jsr $a50f	                jsr xt_type
.9fdc	20 2a a1	jsr $a12a	                jsr xt_space
.9fdf	a9 80		lda #$80	                lda #%10000000
.9fe1	14 20		trb $20		                trb status
.9fe3					_new_word:
.9fe3	a5 04		lda $04		                lda workword
.9fe5	85 02		sta $02		                sta dp
.9fe7	a5 05		lda $05		                lda workword+1
.9fe9	85 03		sta $03		                sta dp+1
.9feb	20 a5 d7	jsr $d7a5	                jsr dp_to_current       ; Save the updated DP to the
.9fee					_semicolon_done:
.9fee	64 16		stz $16		                stz state
.9ff0	64 17		stz $17		                stz state+1
.9ff2	60		rts		z_semicolon:    rts
.9ff3					xt_sign:
.9ff3	20 50 d8	jsr $d850	                jsr underflow_1
.9ff6	b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9ff8	30 04		bmi $9ffe	                bmi _minus
.9ffa	e8		inx		                inx
.9ffb	e8		inx		                inx
.9ffc	80 09		bra $a007	                bra _done
.9ffe					_minus:
.9ffe	a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.a000	95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.a002	74 01		stz $01,x	                stz 1,x         ; paranoid
.a004	20 e3 91	jsr $91e3	                jsr xt_hold
.a007					_done:
.a007	60		rts		z_sign:         rts
.a008					xt_slash:
.a008	a9 00		lda #$00	                lda #0
.a00a	48		pha		                pha
.a00b	80 03		bra $a010	                bra slashmod_common
.a00d					xt_slash_mod:
.a00d	a9 ff		lda #$ff	                lda #$FF
.a00f	48		pha		                pha             ; falls through to _common
.a010					slashmod_common:
.a010	20 7c a3	jsr $a37c	                jsr xt_to_r             ; >R
.a013	20 b8 9e	jsr $9eb8	                jsr xt_s_to_d           ; S>D
.a016	20 9e 9a	jsr $9a9e	                jsr xt_r_from           ; R>
.a019	20 e1 a0	jsr $a0e1	                jsr xt_sm_slash_rem     ; SM/REM
.a01c	68		pla		                pla
.a01d	d0 05		bne $a024	                bne _done
.a01f	20 ba a1	jsr $a1ba	                jsr xt_swap
.a022	e8		inx		                inx             ; DROP
.a023	e8		inx		                inx
.a024					_done:
.a024					z_slash_mod:
.a024	60		rts		z_slash:        rts
.a025					xt_slash_string:
.a025	20 5a d8	jsr $d85a	                jsr underflow_3
.a028	18		clc		                clc             ; 3OS+TOS
.a029	b5 00		lda $00,x	                lda 0,x
.a02b	75 04		adc $04,x	                adc 4,x
.a02d	95 04		sta $04,x	                sta 4,x
.a02f	b5 01		lda $01,x	                lda 1,x
.a031	75 05		adc $05,x	                adc 5,x
.a033	95 05		sta $05,x	                sta 5,x
.a035	38		sec		                sec             ; NOS-TOS
.a036	b5 02		lda $02,x	                lda 2,x
.a038	f5 00		sbc $00,x	                sbc 0,x
.a03a	95 02		sta $02,x	                sta 2,x
.a03c	b5 03		lda $03,x	                lda 3,x
.a03e	f5 01		sbc $01,x	                sbc 1,x
.a040	95 03		sta $03,x	                sta 3,x
.a042	e8		inx		                inx
.a043	e8		inx		                inx
.a044	60		rts		z_slash_string: rts
.a045					xt_sliteral:
.a045	20 55 d8	jsr $d855	                jsr underflow_2
.a048	a9 4c		lda #$4c	                lda #$4C
.a04a	20 03 d7	jsr $d703	                jsr cmpl_a
.a04d	20 03 d7	jsr $d703	                jsr cmpl_a
.a050	20 03 d7	jsr $d703	                jsr cmpl_a
.a053	8a		txa		                txa
.a054	38		sec		                sec
.a055	e9 06		sbc #$06	                sbc #6
.a057	aa		tax		                tax
.a058	b5 08		lda $08,x	                lda 8,x
.a05a	95 04		sta $04,x	                sta 4,x
.a05c	b5 09		lda $09,x	                lda 9,x
.a05e	95 05		sta $05,x	                sta 5,x
.a060	b5 06		lda $06,x	                lda 6,x
.a062	95 00		sta $00,x	                sta 0,x
.a064	b5 07		lda $07,x	                lda 7,x
.a066	95 01		sta $01,x	                sta 1,x
.a068	a5 00		lda $00		                lda cp
.a06a	95 08		sta $08,x	                sta 8,x
.a06c	95 02		sta $02,x	                sta 2,x
.a06e	a5 01		lda $01		                lda cp+1
.a070	95 09		sta $09,x	                sta 9,x
.a072	95 03		sta $03,x	                sta 3,x
.a074	20 ce 95	jsr $95ce	                jsr xt_move
.a077	18		clc		                clc
.a078	a5 00		lda $00		                lda cp
.a07a	75 00		adc $00,x	                adc 0,x
.a07c	85 00		sta $00		                sta cp
.a07e	a5 01		lda $01		                lda cp+1
.a080	75 01		adc $01,x	                adc 1,x
.a082	85 01		sta $01		                sta cp+1
.a084	b5 02		lda $02,x	                lda 2,x
.a086	38		sec		                sec
.a087	e9 02		sbc #$02	                sbc #2
.a089	85 24		sta $24		                sta tmp1
.a08b	b5 03		lda $03,x	                lda 3,x
.a08d	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a08f	85 25		sta $25		                sta tmp1+1
.a091	a5 00		lda $00		                lda cp
.a093	92 24		sta ($24)	                sta (tmp1)
.a095	a0 01		ldy #$01	                ldy #1
.a097	a5 01		lda $01		                lda cp+1
.a099	91 24		sta ($24),y	                sta (tmp1),y
.a09b					sliteral_const_str:
.a09b	a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a09d	a9 b5		lda #$b5	                lda #<sliteral_runtime
.a09f	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.a0a2	b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a0a4	b5 02		lda $02,x	                lda 2,x                ; address LSB
.a0a6	20 ff d6	jsr $d6ff	                jsr cmpl_word
.a0a9	b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a0ab	b5 00		lda $00,x	                lda 0,x                ; length LSB
.a0ad	20 ff d6	jsr $d6ff	                jsr cmpl_word
.a0b0	e8		inx		                inx
.a0b1	e8		inx		                inx
.a0b2	e8		inx		                inx
.a0b3	e8		inx		                inx
.a0b4	60		rts		z_sliteral:     rts
.a0b5					sliteral_runtime:
.a0b5	ca		dex		                dex
.a0b6	ca		dex		                dex
.a0b7	ca		dex		                dex
.a0b8	ca		dex		                dex
.a0b9	68		pla		                pla
.a0ba	85 24		sta $24		                sta tmp1        ; LSB of address
.a0bc	68		pla		                pla
.a0bd	85 25		sta $25		                sta tmp1+1      ; MSB of address
.a0bf	a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a0c1	b1 24		lda ($24),y	                lda (tmp1),y
.a0c3	95 02		sta $02,x	                sta 2,x         ; LSB of address
.a0c5	c8		iny		                iny
.a0c6	b1 24		lda ($24),y	                lda (tmp1),y
.a0c8	95 03		sta $03,x	                sta 3,x         ; MSB of address
.a0ca	c8		iny		                iny
.a0cb	b1 24		lda ($24),y	                lda (tmp1),y
.a0cd	95 00		sta $00,x	                sta 0,x         ; LSB of length
.a0cf	c8		iny		                iny
.a0d0	b1 24		lda ($24),y	                lda (tmp1),y
.a0d2	95 01		sta $01,x	                sta 1,x         ; MSB of length
.a0d4	18		clc		                clc
.a0d5	a5 24		lda $24		                lda tmp1
.a0d7	69 04		adc #$04	                adc #4
.a0d9	a8		tay		                tay             ; LSB
.a0da	a5 25		lda $25		                lda tmp1+1
.a0dc	69 00		adc #$00	                adc #0          ; we only need carry
.a0de	48		pha		                pha             ; MSB
.a0df	5a		phy		                phy
.a0e0	60		rts		                rts
.a0e1					xt_sm_slash_rem:
.a0e1	20 5a d8	jsr $d85a	                jsr underflow_3 ; contains double number
.a0e4	b5 03		lda $03,x	                lda 3,x
.a0e6	48		pha		                pha
.a0e7	b5 01		lda $01,x	                lda 1,x
.a0e9	55 03		eor $03,x	                eor 3,x
.a0eb	48		pha		                pha
.a0ec	20 23 81	jsr $8123	                jsr xt_abs
.a0ef	e8		inx		                inx             ; pretend we pushed n1 to R
.a0f0	e8		inx		                inx
.a0f1	20 92 8a	jsr $8a92	                jsr xt_dabs
.a0f4	ca		dex		                dex
.a0f5	ca		dex		                dex
.a0f6	20 c6 a5	jsr $a5c6	                jsr xt_um_slash_mod     ; UM/MOD
.a0f9	68		pla		                pla
.a0fa	10 03		bpl $a0ff	                bpl +
.a0fc	20 2f 96	jsr $962f	                jsr xt_negate
.a0ff					+
.a0ff	68		pla		                pla
.a100	10 07		bpl $a109	                bpl _done
.a102	e8		inx		                inx             ; pretend we pushed quotient to R
.a103	e8		inx		                inx
.a104	20 2f 96	jsr $962f	                jsr xt_negate
.a107	ca		dex		                dex
.a108	ca		dex		                dex
.a109					_done:
.a109	60		rts		z_sm_slash_rem: rts
.a10a					xt_source:
.a10a	ca		dex		                dex
.a10b	ca		dex		                dex
.a10c	a5 08		lda $08		                lda cib
.a10e	95 00		sta $00,x	                sta 0,x
.a110	a5 09		lda $09		                lda cib+1
.a112	95 01		sta $01,x	                sta 1,x
.a114	ca		dex		                dex
.a115	ca		dex		                dex
.a116	a5 0a		lda $0a		                lda ciblen
.a118	95 00		sta $00,x	                sta 0,x
.a11a	a5 0b		lda $0b		                lda ciblen+1
.a11c	95 01		sta $01,x	                sta 1,x
.a11e	60		rts		z_source:       rts
.a11f					xt_source_id:
.a11f	ca		dex		                dex
.a120	ca		dex		                dex
.a121	a5 06		lda $06		                lda insrc
.a123	95 00		sta $00,x	                sta 0,x
.a125	a5 07		lda $07		                lda insrc+1
.a127	95 01		sta $01,x	                sta 1,x
.a129	60		rts		z_source_id:    rts
.a12a					xt_space:
.a12a	a9 20		lda #$20	                lda #AscSP
.a12c	20 02 8e	jsr $8e02	                jsr emit_a
.a12f	60		rts		z_space:        rts
.a130					xt_spaces:
.a130	20 50 d8	jsr $d850	                jsr underflow_1
.a133	20 b4 a7	jsr $a7b4	                jsr xt_zero
.a136	20 24 95	jsr $9524	                jsr xt_max
.a139	b5 00		lda $00,x	                lda 0,x
.a13b	15 01		ora $01,x	                ora 1,x
.a13d	f0 2a		beq $a169	                beq _done
.a13f	b4 01		ldy $01,x	                ldy 1,x
.a141	d0 0c		bne $a14f	                bne _lots_of_spaces
.a143	b4 00		ldy $00,x	                ldy 0,x
.a145					_quick_loop:
.a145	a9 20		lda #$20	                lda #AscSP
.a147	20 02 8e	jsr $8e02	                jsr emit_a
.a14a	88		dey		                dey
.a14b	f0 1c		beq $a169	                beq _done
.a14d	80 f6		bra $a145	                bra _quick_loop
.a14f					_lots_of_spaces:
.a14f	b4 00		ldy $00,x	                ldy 0,x
.a151					_first_slow_loop:
.a151	f0 08		beq $a15b	                beq _slow_outer_loop
.a153	a9 20		lda #$20	                lda #AscSP
.a155	20 02 8e	jsr $8e02	                jsr emit_a
.a158	88		dey		                dey
.a159	80 f6		bra $a151	                bra _first_slow_loop
.a15b					_slow_outer_loop:
.a15b	a0 00		ldy #$00	                ldy #00
.a15d					_slow_inner_loop:
.a15d	a9 20		lda #$20	                lda #AscSP
.a15f	20 02 8e	jsr $8e02	                jsr emit_a
.a162	88		dey		                dey
.a163	d0 f8		bne $a15d	                bne _slow_inner_loop
.a165	d6 01		dec $01,x	                dec 1,x
.a167	d0 f2		bne $a15b	                bne _slow_outer_loop
.a169					_done:
.a169	e8		inx		                inx             ; drop
.a16a	e8		inx		                inx
.a16b	60		rts		z_spaces:       rts
.a16c					xt_star:
.a16c	20 55 d8	jsr $d855	                jsr underflow_2
.a16f	20 08 a6	jsr $a608	                jsr xt_um_star
.a172	e8		inx		                inx
.a173	e8		inx		                inx
.a174	60		rts		z_star:         rts
.a175					xt_star_slash:
.a175	20 7e a1	jsr $a17e	                jsr xt_star_slash_mod
.a178	20 ba a1	jsr $a1ba	                jsr xt_swap
.a17b	e8		inx		                inx
.a17c	e8		inx		                inx
.a17d					z_star_slash:
.a17d	60		rts		                rts
.a17e					xt_star_slash_mod:
.a17e	20 5a d8	jsr $d85a	                jsr underflow_3
.a181	20 7c a3	jsr $a37c	                jsr xt_to_r
.a184	20 9a 94	jsr $949a	                jsr xt_m_star
.a187	20 9e 9a	jsr $9a9e	                jsr xt_r_from
.a18a	20 e1 a0	jsr $a0e1	                jsr xt_sm_slash_rem
.a18d					z_star_slash_mod:
.a18d	60		rts		                rts
.a18e					xt_state:
.a18e	ca		dex		                dex
.a18f	ca		dex		                dex
.a190	a9 16		lda #$16	                lda #<state
.a192	95 00		sta $00,x	                sta 0,x
.a194	a9 00		lda #$00	                lda #>state
.a196	95 01		sta $01,x	                sta 1,x
.a198	60		rts		z_state:        rts
.a199					xt_store:
.a199	20 55 d8	jsr $d855	                jsr underflow_2
.a19c	b5 02		lda $02,x	                lda 2,x         ; LSB
.a19e	81 00		sta ($00,x)	                sta (0,x)
.a1a0	f6 00		inc $00,x	                inc 0,x
.a1a2	d0 02		bne $a1a6	                bne +
.a1a4	f6 01		inc $01,x	                inc 1,x
.a1a6					+
.a1a6	b5 03		lda $03,x	                lda 3,x         ; MSB
.a1a8	81 00		sta ($00,x)	                sta (0,x)
.a1aa	e8		inx		                inx             ; 2DROP
.a1ab	e8		inx		                inx
.a1ac	e8		inx		                inx
.a1ad	e8		inx		                inx
.a1ae	60		rts		z_store:        rts
.a1af					xt_strip_underflow:
.a1af	ca		dex		                dex
.a1b0	ca		dex		                dex
.a1b1	a9 1c		lda #$1c	                lda #<uf_strip
.a1b3	95 00		sta $00,x	                sta 0,x
.a1b5	a9 00		lda #$00	                lda #>uf_strip
.a1b7	95 01		sta $01,x	                sta 1,x
.a1b9					z_strip_underflow:
.a1b9	60		rts		                rts
.a1ba					xt_swap:
.a1ba	20 55 d8	jsr $d855	                jsr underflow_2
.a1bd	b5 00		lda $00,x	                lda 0,x         ; LSB
.a1bf	b4 02		ldy $02,x	                ldy 2,x
.a1c1	95 02		sta $02,x	                sta 2,x
.a1c3	94 00		sty $00,x	                sty 0,x
.a1c5	b5 01		lda $01,x	                lda 1,x         ; MSB
.a1c7	b4 03		ldy $03,x	                ldy 3,x
.a1c9	95 03		sta $03,x	                sta 3,x
.a1cb	94 01		sty $01,x	                sty 1,x
.a1cd	60		rts		z_swap:         rts
.a1ce					xt_then:
.a1ce	20 7e 91	jsr $917e	                jsr xt_here
.a1d1	20 ba a1	jsr $a1ba	                jsr xt_swap
.a1d4	20 99 a1	jsr $a199	                jsr xt_store
.a1d7	60		rts		z_then:         rts
.a1d8					xt_thru:
.a1d8	20 55 d8	jsr $d855	                jsr underflow_2
.a1db	b5 01		lda $01,x	                lda 1,x
.a1dd	48		pha		                pha
.a1de	b5 00		lda $00,x	                lda 0,x
.a1e0	48		pha		                pha
.a1e1	e8		inx		                inx
.a1e2	e8		inx		                inx
.a1e3					_thru_loop:
.a1e3	b5 01		lda $01,x	                lda 1,x
.a1e5	48		pha		                pha
.a1e6	b5 00		lda $00,x	                lda 0,x
.a1e8	48		pha		                pha
.a1e9	20 c3 93	jsr $93c3	                jsr xt_load
.a1ec	68		pla		                pla
.a1ed	85 24		sta $24		                sta tmp1
.a1ef	68		pla		                pla
.a1f0	85 25		sta $25		                sta tmp1+1
.a1f2	68		pla		                pla
.a1f3	85 26		sta $26		                sta tmp2
.a1f5	68		pla		                pla
.a1f6	85 27		sta $27		                sta tmp2+1
.a1f8	c5 25		cmp $25		                cmp tmp1+1
.a1fa	d0 08		bne $a204	                bne _next_screen
.a1fc	a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a1fe	c5 24		cmp $24		                cmp tmp1
.a200	d0 02		bne $a204	                bne _next_screen
.a202	80 18		bra $a21c	                bra _done       ; We just did the last screen.
.a204					_next_screen:
.a204	a5 27		lda $27		                lda tmp2+1
.a206	48		pha		                pha
.a207	a5 26		lda $26		                lda tmp2
.a209	48		pha		                pha
.a20a	e6 24		inc $24		                inc tmp1
.a20c	d0 02		bne $a210	                bne +
.a20e	e6 25		inc $25		                inc tmp1+1
.a210					+
.a210	ca		dex		                dex
.a211	ca		dex		                dex
.a212	a5 24		lda $24		                lda tmp1
.a214	95 00		sta $00,x	                sta 0,x
.a216	a5 25		lda $25		                lda tmp1+1
.a218	95 01		sta $01,x	                sta 1,x
.a21a	80 c7		bra $a1e3	                bra _thru_loop
.a21c					_done:
.a21c	60		rts		z_thru:         rts
.a21d					xt_tick:
.a21d	20 eb 98	jsr $98eb	                jsr xt_parse_name       ; ( -- addr u )
.a220	b5 00		lda $00,x	                lda 0,x
.a222	15 01		ora $01,x	                ora 1,x
.a224	d0 05		bne $a22b	                bne +
.a226	a9 05		lda #$05	                lda #err_noname
.a228	4c 66 d8	jmp $d866	                jmp error
.a22b					+
.a22b	20 e7 8f	jsr $8fe7	                jsr xt_find_name        ; ( addr u -- nt )
.a22e	b5 00		lda $00,x	                lda 0,x
.a230	15 01		ora $01,x	                ora 1,x
.a232	d0 05		bne $a239	                bne +
.a234	a9 08		lda #$08	                lda #err_syntax
.a236	4c 66 d8	jmp $d866	                jmp error
.a239					+
.a239	20 ed 95	jsr $95ed	                jsr xt_name_to_int      ; ( nt -- xt )
.a23c	60		rts		z_tick:         rts
.a23d					xt_to:
.a23d	20 1d a2	jsr $a21d	                jsr xt_tick             ; ( [n] xt )
.a240	b5 00		lda $00,x	                lda 0,x                 ; LSB
.a242	18		clc		                clc
.a243	69 03		adc #$03	                adc #3
.a245	85 24		sta $24		                sta tmp1
.a247	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a249	69 00		adc #$00	                adc #0                  ; we just want the carry
.a24b	85 25		sta $25		                sta tmp1+1
.a24d	e8		inx		                inx
.a24e	e8		inx		                inx                     ; ( [n] )
.a24f	a5 16		lda $16		                lda state
.a251	05 17		ora $17		                ora state+1
.a253	f0 34		beq $a289	                beq _interpret
.a255	a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a257	a9 b5		lda #$b5	                lda #$B5
.a259	20 ff d6	jsr $d6ff	                jsr cmpl_word
.a25c	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a25e	20 03 d7	jsr $d703	                jsr cmpl_a
.a261	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a263	a5 24		lda $24		                lda tmp1
.a265	20 ff d6	jsr $d6ff	                jsr cmpl_word
.a268	a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a26a	a9 b5		lda #$b5	                lda #$B5
.a26c	20 ff d6	jsr $d6ff	                jsr cmpl_word
.a26f	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a271	20 03 d7	jsr $d703	                jsr cmpl_a
.a274	e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a276	d0 02		bne $a27a	                bne +
.a278	e6 25		inc $25		                inc tmp1+1
.a27a					+
.a27a	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a27c	a5 24		lda $24		                lda tmp1
.a27e	20 ff d6	jsr $d6ff	                jsr cmpl_word
.a281	a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a283	98		tya		                tya
.a284	20 ff d6	jsr $d6ff	                jsr cmpl_word
.a287	80 0f		bra $a298	                bra _done
.a289					_interpret:
.a289	20 50 d8	jsr $d850	                jsr underflow_1
.a28c	b5 00		lda $00,x	                lda 0,x
.a28e	92 24		sta ($24)	                sta (tmp1)              ; LSB
.a290	a0 01		ldy #$01	                ldy #1
.a292	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a294	91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a296	e8		inx		                inx                     ; DROP
.a297	e8		inx		                inx
.a298					_done:
.a298	60		rts		z_to:           rts
.a299					xt_to_body:
.a299	20 50 d8	jsr $d850	                jsr underflow_1
.a29c	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( xt xt )
.a29f	20 84 92	jsr $9284	                jsr xt_int_to_name      ; ( xt nt )
.a2a2	f6 00		inc $00,x	                inc 0,x
.a2a4	d0 02		bne $a2a8	                bne +
.a2a6	f6 01		inc $01,x	                inc 1,x
.a2a8					+
.a2a8	a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a2aa	29 20		and #$20	                and #HC
.a2ac	f0 0d		beq $a2bb	                beq _no_cfa
.a2ae	18		clc		                clc
.a2af	b5 02		lda $02,x	                lda 2,x         ; LSB
.a2b1	69 03		adc #$03	                adc #3
.a2b3	95 02		sta $02,x	                sta 2,x
.a2b5	b5 03		lda $03,x	                lda 3,x         ; MSB
.a2b7	69 00		adc #$00	                adc #0          ; we conly care about the carry
.a2b9	95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a2bb					_no_cfa:
.a2bb	e8		inx		                inx             ; get rid of the nt
.a2bc	e8		inx		                inx
.a2bd					_done:
.a2bd	60		rts		z_to_body:      rts
.a2be					xt_to_in:
.a2be	ca		dex		                dex
.a2bf	ca		dex		                dex
.a2c0	a9 0c		lda #$0c	                lda #<toin
.a2c2	95 00		sta $00,x	                sta 0,x
.a2c4	a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a2c6	95 01		sta $01,x	                sta 1,x
.a2c8	60		rts		z_to_in:        rts
.a2c9					xt_to_number:
.a2c9	20 5f d8	jsr $d85f	                jsr underflow_4
.a2cc	b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a2ce	85 36		sta $36		                sta scratch
.a2d0	b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a2d2	85 37		sta $37		                sta scratch+1
.a2d4	b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a2d6	85 38		sta $38		                sta scratch+2
.a2d8	b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a2da	85 39		sta $39		                sta scratch+3
.a2dc	ca		dex		                dex
.a2dd	ca		dex		                dex
.a2de					_loop:
.a2de	a1 04		lda ($04,x)	                lda (4,x)
.a2e0	95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a2e2	74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2e4	20 11 8b	jsr $8b11	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a2e7	b5 00		lda $00,x	                lda 0,x
.a2e9	d0 04		bne $a2ef	                bne _digit_ok
.a2eb	e8		inx		                inx
.a2ec	e8		inx		                inx
.a2ed	80 67		bra $a356	                bra _done       ; ( ud-lo ud-hi addr u char )
.a2ef					_digit_ok:
.a2ef	b5 02		lda $02,x	                lda 2,x
.a2f1	85 3a		sta $3a		                sta scratch+4
.a2f3	b5 03		lda $03,x	                lda 3,x
.a2f5	85 3b		sta $3b		                sta scratch+5
.a2f7	a5 38		lda $38		                lda scratch+2
.a2f9	95 02		sta $02,x	                sta 2,x         ; NOS
.a2fb	a5 39		lda $39		                lda scratch+3
.a2fd	95 03		sta $03,x	                sta 3,x
.a2ff	a5 18		lda $18		                lda base
.a301	95 00		sta $00,x	                sta 0,x         ; TOS
.a303	74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a305	20 08 a6	jsr $a608	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a308	b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a30a	85 3c		sta $3c		                sta scratch+6
.a30c	b5 03		lda $03,x	                lda 3,x
.a30e	85 3d		sta $3d		                sta scratch+7
.a310	a5 36		lda $36		                lda scratch
.a312	95 02		sta $02,x	                sta 2,x
.a314	a5 37		lda $37		                lda scratch+1
.a316	95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a318	a5 18		lda $18		                lda base
.a31a	95 00		sta $00,x	                sta 0,x
.a31c	74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a31e	20 08 a6	jsr $a608	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a321	b5 00		lda $00,x	                lda 0,x
.a323	85 38		sta $38		                sta scratch+2
.a325	b5 01		lda $01,x	                lda 1,x
.a327	85 39		sta $39		                sta scratch+3
.a329	b5 02		lda $02,x	                lda 2,x
.a32b	85 36		sta $36		                sta scratch
.a32d	b5 03		lda $03,x	                lda 3,x
.a32f	85 37		sta $37		                sta scratch+1
.a331	18		clc		                clc
.a332	a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a334	65 3a		adc $3a		                adc scratch+4   ; n LSB
.a336	85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a338	a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a33a	65 3b		adc $3b		                adc scratch+5   ; n MSB
.a33c	85 37		sta $37		                sta scratch+1
.a33e	a5 38		lda $38		                lda scratch+2   ; LSB
.a340	65 3c		adc $3c		                adc scratch+6
.a342	85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a344	a5 39		lda $39		                lda scratch+3   ; MSB
.a346	65 3d		adc $3d		                adc scratch+7
.a348	85 39		sta $39		                sta scratch+3
.a34a	e8		inx		                inx
.a34b	e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a34c	f6 04		inc $04,x	                inc 4,x
.a34e	d0 02		bne $a352	                bne +
.a350	f6 05		inc $05,x	                inc 5,x
.a352					+
.a352	d6 02		dec $02,x	                dec 2,x
.a354	d0 88		bne $a2de	                bne _loop
.a356					_done:
.a356	e8		inx		                inx
.a357	e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a358	a5 36		lda $36		                lda scratch     ; new ud-lo
.a35a	95 06		sta $06,x	                sta 6,x
.a35c	a5 37		lda $37		                lda scratch+1
.a35e	95 07		sta $07,x	                sta 7,x
.a360	a5 38		lda $38		                lda scratch+2
.a362	95 04		sta $04,x	                sta 4,x
.a364	a5 39		lda $39		                lda scratch+3
.a366	95 05		sta $05,x	                sta 5,x
.a368	60		rts		z_to_number:    rts
.a369					xt_to_order:
.a369	20 7c a3	jsr $a37c	                jsr xt_to_r
.a36c	20 40 91	jsr $9140	                jsr xt_get_order
.a36f	20 9e 9a	jsr $9a9e	                jsr xt_r_from
.a372	20 ba a1	jsr $a1ba	                jsr xt_swap
.a375	20 29 98	jsr $9829	                jsr xt_one_plus
.a378	20 27 9d	jsr $9d27	                jsr xt_set_order
.a37b	60		rts		z_to_order:     rts
.a37c					xt_to_r:
.a37c	68		pla		                pla             ; LSB
.a37d	85 2c		sta $2c		                sta tmptos
.a37f	7a		ply		                ply             ; MSB
.a380	20 50 d8	jsr $d850	                jsr underflow_1
.a383	b5 01		lda $01,x	                lda 1,x         ; MSB
.a385	48		pha		                pha
.a386	b5 00		lda $00,x	                lda 0,x         ; LSB
.a388	48		pha		                pha
.a389	e8		inx		                inx
.a38a	e8		inx		                inx
.a38b	5a		phy		                phy             ; MSB
.a38c	a5 2c		lda $2c		                lda tmptos
.a38e	48		pha		                pha             ; LSB
.a38f	60		rts		z_to_r:         rts
.a390					xt_true:
.a390	ca		dex		                dex
.a391	ca		dex		                dex
.a392	a9 ff		lda #$ff	                lda #$FF
.a394	95 00		sta $00,x	                sta 0,x
.a396	95 01		sta $01,x	                sta 1,x
.a398	60		rts		z_true:         rts
.a399					xt_tuck:
.a399	20 55 d8	jsr $d855	                jsr underflow_2
.a39c	ca		dex		                dex
.a39d	ca		dex		                dex
.a39e	b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a3a0	b5 02		lda $02,x	                lda 2,x
.a3a2	95 04		sta $04,x	                sta 4,x
.a3a4	94 02		sty $02,x	                sty 2,x
.a3a6	95 00		sta $00,x	                sta 0,x
.a3a8	b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a3aa	b5 03		lda $03,x	                lda 3,x
.a3ac	95 05		sta $05,x	                sta 5,x
.a3ae	94 03		sty $03,x	                sty 3,x         ; bba
.a3b0	95 01		sta $01,x	                sta 1,x         ; baa
.a3b2	60		rts		z_tuck:         rts
.a3b3					xt_assembler_wordlist:
.a3b3					xt_two:
.a3b3	ca		dex		                dex
.a3b4	ca		dex		                dex
.a3b5	a9 02		lda #$02	                lda #2
.a3b7	95 00		sta $00,x	                sta 0,x
.a3b9	74 01		stz $01,x	                stz 1,x
.a3bb					z_assembler_wordlist:
.a3bb	60		rts		z_two:          rts
.a3bc					xt_two_drop:
.a3bc	20 55 d8	jsr $d855	                jsr underflow_2
.a3bf	e8		inx		                inx
.a3c0	e8		inx		                inx
.a3c1	e8		inx		                inx
.a3c2	e8		inx		                inx
.a3c3	60		rts		z_two_drop:     rts
.a3c4					xt_two_dup:
.a3c4	20 55 d8	jsr $d855	                jsr underflow_2
.a3c7	ca		dex		                dex
.a3c8	ca		dex		                dex
.a3c9	ca		dex		                dex
.a3ca	ca		dex		                dex
.a3cb	b5 04		lda $04,x	                lda 4,x         ; TOS
.a3cd	95 00		sta $00,x	                sta 0,x
.a3cf	b5 05		lda $05,x	                lda 5,x
.a3d1	95 01		sta $01,x	                sta 1,x
.a3d3	b5 06		lda $06,x	                lda 6,x         ; NOS
.a3d5	95 02		sta $02,x	                sta 2,x
.a3d7	b5 07		lda $07,x	                lda 7,x
.a3d9	95 03		sta $03,x	                sta 3,x
.a3db	60		rts		z_two_dup:      rts
.a3dc					xt_two_fetch:
.a3dc	20 50 d8	jsr $d850	                jsr underflow_1
.a3df	b5 00		lda $00,x	                lda 0,x
.a3e1	85 24		sta $24		                sta tmp1
.a3e3	b4 01		ldy $01,x	                ldy 1,x
.a3e5	84 25		sty $25		                sty tmp1+1
.a3e7	ca		dex		                dex             ; reuse one stack element
.a3e8	ca		dex		                dex
.a3e9	b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a3eb	95 00		sta $00,x	                sta 0,x
.a3ed	a0 01		ldy #$01	                ldy #1          ; copy next
.a3ef	b1 24		lda ($24),y	                lda (tmp1),y
.a3f1	95 01		sta $01,x	                sta 1,x
.a3f3	c8		iny		                iny             ; copy next
.a3f4	b1 24		lda ($24),y	                lda (tmp1),y
.a3f6	95 02		sta $02,x	                sta 2,x
.a3f8	c8		iny		                iny             ; copy next
.a3f9	b1 24		lda ($24),y	                lda (tmp1),y
.a3fb	95 03		sta $03,x	                sta 3,x
.a3fd	60		rts		z_two_fetch:    rts
.a3fe					xt_two_over:
.a3fe	20 5f d8	jsr $d85f	                jsr underflow_4
.a401	ca		dex		                dex
.a402	ca		dex		                dex
.a403	ca		dex		                dex
.a404	ca		dex		                dex
.a405	b5 08		lda $08,x	                lda 8,x
.a407	95 00		sta $00,x	                sta 0,x
.a409	b5 09		lda $09,x	                lda 9,x
.a40b	95 01		sta $01,x	                sta 1,x
.a40d	b5 0a		lda $0a,x	                lda 10,x
.a40f	95 02		sta $02,x	                sta 2,x
.a411	b5 0b		lda $0b,x	                lda 11,x
.a413	95 03		sta $03,x	                sta 3,x
.a415	60		rts		z_two_over:     rts
.a416					xt_two_r_fetch:
.a416	ca		dex		                dex
.a417	ca		dex		                dex
.a418	ca		dex		                dex
.a419	ca		dex		                dex
.a41a	8a		txa		                txa
.a41b	ba		tsx		                tsx
.a41c	da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a41d	7a		ply		                ply
.a41e	aa		tax		                tax
.a41f	b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a422	95 00		sta $00,x	                sta 0,x
.a424	b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a427	95 01		sta $01,x	                sta 1,x
.a429	b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a42c	95 02		sta $02,x	                sta 2,x
.a42e	b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a431	95 03		sta $03,x	                sta 3,x
.a433	60		rts		z_two_r_fetch:  rts
.a434					xt_two_r_from:
.a434	68		pla		                pla                     ; LSB
.a435	85 24		sta $24		                sta tmp1
.a437	68		pla		                pla                     ; MSB
.a438	85 25		sta $25		                sta tmp1+1
.a43a	ca		dex		                dex
.a43b	ca		dex		                dex
.a43c	ca		dex		                dex
.a43d	ca		dex		                dex
.a43e	68		pla		                pla                     ; LSB
.a43f	95 00		sta $00,x	                sta 0,x
.a441	68		pla		                pla                     ; MSB
.a442	95 01		sta $01,x	                sta 1,x
.a444	68		pla		                pla                     ; LSB
.a445	95 02		sta $02,x	                sta 2,x
.a447	68		pla		                pla                     ; MSB
.a448	95 03		sta $03,x	                sta 3,x
.a44a	a5 25		lda $25		                lda tmp1+1              ; MSB
.a44c	48		pha		                pha
.a44d	a5 24		lda $24		                lda tmp1                ; LSB
.a44f	48		pha		                pha
.a450	60		rts		z_two_r_from:   rts
.a451					xt_two_slash:
.a451	20 50 d8	jsr $d850	                jsr underflow_1
.a454	b5 01		lda $01,x	                lda 1,x
.a456	0a		asl a		                asl                     ; save the sign
.a457	76 01		ror $01,x	                ror 1,x
.a459	76 00		ror $00,x	                ror 0,x
.a45b	60		rts		z_two_slash:    rts
.a45c					xt_two_star:
.a45c					xt_cells:
.a45c	20 50 d8	jsr $d850	                jsr underflow_1
.a45f	16 00		asl $00,x	                asl 0,x
.a461	36 01		rol $01,x	                rol 1,x
.a463					z_cells:
.a463	60		rts		z_two_star:     rts
.a464					xt_two_store:
.a464	20 5a d8	jsr $d85a	                jsr underflow_3
.a467	b5 00		lda $00,x	                lda 0,x
.a469	85 24		sta $24		                sta tmp1
.a46b	b4 01		ldy $01,x	                ldy 1,x
.a46d	84 25		sty $25		                sty tmp1+1
.a46f	e8		inx		                inx
.a470	e8		inx		                inx
.a471	b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a473	92 24		sta ($24)	                sta (tmp1)
.a475	b5 01		lda $01,x	                lda 1,x         ; copy next
.a477	a0 01		ldy #$01	                ldy #1
.a479	91 24		sta ($24),y	                sta (tmp1),y
.a47b	b5 02		lda $02,x	                lda 2,x         ; copy next
.a47d	c8		iny		                iny
.a47e	91 24		sta ($24),y	                sta (tmp1),y
.a480	b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a482	c8		iny		                iny
.a483	91 24		sta ($24),y	                sta (tmp1),y
.a485	e8		inx		                inx             ; 2DROP
.a486	e8		inx		                inx
.a487	e8		inx		                inx
.a488	e8		inx		                inx
.a489	60		rts		z_two_store:    rts
.a48a					xt_two_swap:
.a48a	20 5f d8	jsr $d85f	                jsr underflow_4
.a48d	b5 00		lda $00,x	                lda 0,x
.a48f	b4 04		ldy $04,x	                ldy 4,x
.a491	95 04		sta $04,x	                sta 4,x
.a493	94 00		sty $00,x	                sty 0,x
.a495	b5 01		lda $01,x	                lda 1,x
.a497	b4 05		ldy $05,x	                ldy 5,x
.a499	95 05		sta $05,x	                sta 5,x
.a49b	94 01		sty $01,x	                sty 1,x
.a49d	b5 02		lda $02,x	                lda 2,x
.a49f	b4 06		ldy $06,x	                ldy 6,x
.a4a1	95 06		sta $06,x	                sta 6,x
.a4a3	94 02		sty $02,x	                sty 2,x
.a4a5	b5 03		lda $03,x	                lda 3,x
.a4a7	b4 07		ldy $07,x	                ldy 7,x
.a4a9	95 07		sta $07,x	                sta 7,x
.a4ab	94 03		sty $03,x	                sty 3,x
.a4ad	60		rts		z_two_swap:     rts
.a4ae					xt_two_to_r:
.a4ae	68		pla		                pla             ; LSB
.a4af	85 24		sta $24		                sta tmp1
.a4b1	68		pla		                pla             ; MSB
.a4b2	85 25		sta $25		                sta tmp1+1
.a4b4	20 55 d8	jsr $d855	                jsr underflow_2
.a4b7	b5 03		lda $03,x	                lda 3,x         ; MSB
.a4b9	48		pha		                pha
.a4ba	b5 02		lda $02,x	                lda 2,x         ; LSB
.a4bc	48		pha		                pha
.a4bd	b5 01		lda $01,x	                lda 1,x         ; MSB
.a4bf	48		pha		                pha
.a4c0	b5 00		lda $00,x	                lda 0,x         ; LSB
.a4c2	48		pha		                pha
.a4c3	e8		inx		                inx
.a4c4	e8		inx		                inx
.a4c5	e8		inx		                inx
.a4c6	e8		inx		                inx
.a4c7	a5 25		lda $25		                lda tmp1+1      ; MSB
.a4c9	48		pha		                pha
.a4ca	a5 24		lda $24		                lda tmp1        ; LSB
.a4cc	48		pha		                pha
.a4cd	60		rts		z_two_to_r:     rts
.a4ce					xt_two_constant:
.a4ce	20 55 d8	jsr $d855	                jsr underflow_2
.a4d1	20 75 89	jsr $8975	                jsr xt_create
.a4d4	20 ba a1	jsr $a1ba	                jsr xt_swap
.a4d7	20 7a 87	jsr $877a	                jsr xt_comma
.a4da	20 7a 87	jsr $877a	                jsr xt_comma
.a4dd	20 10 8c	jsr $8c10	                jsr does_runtime    ; does> turns into these two routines.
.a4e0	20 39 d7	jsr $d739	                jsr dodoes
.a4e3	20 bb 8d	jsr $8dbb	                jsr xt_dup
.a4e6	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.a4e9	20 ba a1	jsr $a1ba	                jsr xt_swap
.a4ec	20 2d 86	jsr $862d	                jsr xt_cell_plus
.a4ef	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.a4f2	60		rts		z_two_constant: rts
.a4f3					xt_two_literal:
.a4f3	20 55 d8	jsr $d855	                jsr underflow_2 ; double number
.a4f6	20 ba a1	jsr $a1ba	                jsr xt_swap
.a4f9	20 96 93	jsr $9396	                jsr xt_literal
.a4fc	20 96 93	jsr $9396	                jsr xt_literal
.a4ff	60		rts		z_two_literal:  rts
.a500					xt_two_variable:
.a500	20 75 89	jsr $8975	                jsr xt_create
.a503	ca		dex		                dex
.a504	ca		dex		                dex
.a505	a9 04		lda #$04	                lda #4
.a507	95 00		sta $00,x	                sta 0,x
.a509	74 01		stz $01,x	                stz 1,x
.a50b	20 95 82	jsr $8295	                jsr xt_allot
.a50e	60		rts		z_two_variable: rts
.a50f					xt_type:
.a50f	20 55 d8	jsr $d855	                jsr underflow_2
.a512	b5 02		lda $02,x	                lda 2,x
.a514	85 24		sta $24		                sta tmp1
.a516	b5 03		lda $03,x	                lda 3,x
.a518	85 25		sta $25		                sta tmp1+1
.a51a					_loop:
.a51a	b5 00		lda $00,x	                lda 0,x
.a51c	15 01		ora $01,x	                ora 1,x
.a51e	f0 15		beq $a535	                beq _done
.a520	b2 24		lda ($24)	                lda (tmp1)
.a522	20 02 8e	jsr $8e02	                jsr emit_a      ; avoids stack foolery
.a525	e6 24		inc $24		                inc tmp1
.a527	d0 02		bne $a52b	                bne +
.a529	e6 25		inc $25		                inc tmp1+1
.a52b					+
.a52b	b5 00		lda $00,x	                lda 0,x
.a52d	d0 02		bne $a531	                bne +
.a52f	d6 01		dec $01,x	                dec 1,x
.a531					+
.a531	d6 00		dec $00,x	                dec 0,x
.a533	80 e5		bra $a51a	                bra _loop
.a535					_done:
.a535	e8		inx		                inx
.a536	e8		inx		                inx
.a537	e8		inx		                inx
.a538	e8		inx		                inx
.a539	60		rts		z_type:         rts
.a53a					xt_u_dot:
.a53a	20 50 d8	jsr $d850	                jsr underflow_1
.a53d	20 bd d8	jsr $d8bd	                jsr print_u
.a540	a9 20		lda #$20	                lda #AscSP
.a542	20 02 8e	jsr $8e02	                jsr emit_a
.a545	60		rts		z_u_dot:        rts
.a546					xt_u_dot_r:
.a546	20 55 d8	jsr $d855	                jsr underflow_2
.a549	20 7c a3	jsr $a37c	                jsr xt_to_r
.a54c	20 b4 a7	jsr $a7b4	                jsr xt_zero
.a54f	20 66 93	jsr $9366	                jsr xt_less_number_sign
.a552	20 ea 97	jsr $97ea	                jsr xt_number_sign_s
.a555	20 c8 97	jsr $97c8	                jsr xt_number_sign_greater
.a558	20 9e 9a	jsr $9a9e	                jsr xt_r_from
.a55b	20 9f 98	jsr $989f	                jsr xt_over
.a55e	20 5c 95	jsr $955c	                jsr xt_minus
.a561	20 30 a1	jsr $a130	                jsr xt_spaces
.a564	20 0f a5	jsr $a50f	                jsr xt_type
.a567	60		rts		z_u_dot_r:      rts
.a568					xt_u_greater_than:
.a568	20 55 d8	jsr $d855	                jsr underflow_2
.a56b	b5 00		lda $00,x	                lda 0,x
.a56d	d5 02		cmp $02,x	                cmp 2,x
.a56f	b5 01		lda $01,x	                lda 1,x
.a571	f5 03		sbc $03,x	                sbc 3,x
.a573	e8		inx		                inx
.a574	e8		inx		                inx
.a575	a9 00		lda #$00	                lda #0
.a577	69 ff		adc #$ff	                adc #$ff
.a579	95 00		sta $00,x	                sta 0,x         ; store flag
.a57b	95 01		sta $01,x	                sta 1,x
.a57d	60		rts		z_u_greater_than:    rts
.a57e					xt_u_less_than:
.a57e	20 55 d8	jsr $d855	                jsr underflow_2
.a581	b5 02		lda $02,x	                lda 2,x
.a583	d5 00		cmp $00,x	                cmp 0,x
.a585	b5 03		lda $03,x	                lda 3,x
.a587	f5 01		sbc $01,x	                sbc 1,x
.a589	e8		inx		                inx
.a58a	e8		inx		                inx
.a58b	a9 00		lda #$00	                lda #0
.a58d	69 ff		adc #$ff	                adc #$ff
.a58f	95 00		sta $00,x	                sta 0,x         ; store flag
.a591	95 01		sta $01,x	                sta 1,x
.a593	60		rts		z_u_less_than:    rts
.a594					xt_ud_dot:
.a594	20 55 d8	jsr $d855	                jsr underflow_2 ; double number
.a597	20 66 93	jsr $9366	                jsr xt_less_number_sign
.a59a	20 ea 97	jsr $97ea	                jsr xt_number_sign_s
.a59d	20 c8 97	jsr $97c8	                jsr xt_number_sign_greater
.a5a0	20 0f a5	jsr $a50f	                jsr xt_type
.a5a3	20 2a a1	jsr $a12a	                jsr xt_space
.a5a6	60		rts		z_ud_dot:        rts
.a5a7					xt_ud_dot_r:
.a5a7	20 5a d8	jsr $d85a	                jsr underflow_3
.a5aa	20 7c a3	jsr $a37c	                jsr xt_to_r
.a5ad	20 66 93	jsr $9366	                jsr xt_less_number_sign
.a5b0	20 ea 97	jsr $97ea	                jsr xt_number_sign_s
.a5b3	20 c8 97	jsr $97c8	                jsr xt_number_sign_greater
.a5b6	20 9e 9a	jsr $9a9e	                jsr xt_r_from
.a5b9	20 9f 98	jsr $989f	                jsr xt_over
.a5bc	20 5c 95	jsr $955c	                jsr xt_minus
.a5bf	20 30 a1	jsr $a130	                jsr xt_spaces
.a5c2	20 0f a5	jsr $a50f	                jsr xt_type
.a5c5	60		rts		z_ud_dot_r:      rts
.a5c6					xt_um_slash_mod:
.a5c6	20 5a d8	jsr $d85a	                jsr underflow_3
.a5c9	b5 00		lda $00,x	                lda 0,x
.a5cb	15 01		ora $01,x	                ora 1,x
.a5cd	d0 05		bne $a5d4	                bne _not_zero
.a5cf	a9 04		lda #$04	                lda #err_divzero
.a5d1	4c 66 d8	jmp $d866	                jmp error
.a5d4					_not_zero:
.a5d4	a9 11		lda #$11	                lda #17
.a5d6	85 2c		sta $2c		                sta tmptos
.a5d8					_loop:
.a5d8	36 04		rol $04,x	                rol 4,x
.a5da	36 05		rol $05,x	                rol 5,x
.a5dc	c6 2c		dec $2c		                dec tmptos
.a5de	f0 22		beq $a602	                beq _done
.a5e0	36 02		rol $02,x	                rol 2,x
.a5e2	36 03		rol $03,x	                rol 3,x
.a5e4	64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a5e6	26 24		rol $24		                rol tmp1
.a5e8	38		sec		                sec
.a5e9	b5 02		lda $02,x	                lda 2,x
.a5eb	f5 00		sbc $00,x	                sbc 0,x
.a5ed	85 25		sta $25		                sta tmp1+1
.a5ef	b5 03		lda $03,x	                lda 3,x
.a5f1	f5 01		sbc $01,x	                sbc 1,x
.a5f3	a8		tay		                tay
.a5f4	a5 24		lda $24		                lda tmp1
.a5f6	e9 00		sbc #$00	                sbc #0
.a5f8	90 de		bcc $a5d8	                bcc _loop
.a5fa	a5 25		lda $25		                lda tmp1+1
.a5fc	95 02		sta $02,x	                sta 2,x
.a5fe	94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a600	80 d6		bra $a5d8	                bra _loop
.a602					_done:
.a602	e8		inx		                inx
.a603	e8		inx		                inx
.a604	20 ba a1	jsr $a1ba	                jsr xt_swap
.a607	60		rts		z_um_slash_mod: rts
.a608					xt_um_star:
.a608	20 55 d8	jsr $d855	                jsr underflow_2
.a60b	18		clc		                clc
.a60c	b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a60e	e9 00		sbc #$00	                sbc #0
.a610	85 26		sta $26		                sta tmp2
.a612	b5 01		lda $01,x	                lda 1,x
.a614	e9 00		sbc #$00	                sbc #0
.a616	90 31		bcc $a649	                bcc _zero       ; is TOS zero?
.a618	85 27		sta $27		                sta tmp2+1
.a61a	a9 00		lda #$00	                lda #0
.a61c	85 24		sta $24		                sta tmp1
.a61e	86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a620	ca		dex		                dex
.a621	ca		dex		                dex
.a622					_outer_loop:
.a622	a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a624	56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a626					_inner_loop:
.a626	90 0c		bcc $a634	                bcc _no_add
.a628	85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a62a	a5 24		lda $24		                lda tmp1
.a62c	65 26		adc $26		                adc tmp2
.a62e	85 24		sta $24		                sta tmp1
.a630	a5 25		lda $25		                lda tmp1+1
.a632	65 27		adc $27		                adc tmp2+1
.a634					_no_add:
.a634	6a		ror a		                ror
.a635	66 24		ror $24		                ror tmp1
.a637	76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a639	88		dey		                dey
.a63a	d0 ea		bne $a626	                bne _inner_loop ; go back for one more shift?
.a63c	e8		inx		                inx
.a63d	e4 28		cpx $28		                cpx tmp3
.a63f	d0 e1		bne $a622	                bne _outer_loop ; go back for eight more shifts?
.a641	95 01		sta $01,x	                sta 1,x
.a643	a5 24		lda $24		                lda tmp1
.a645	95 00		sta $00,x	                sta 0,x
.a647	80 04		bra $a64d	                bra _done
.a649					_zero:
.a649	74 02		stz $02,x	                stz 2,x
.a64b	74 03		stz $03,x	                stz 3,x
.a64d					_done:
.a64d	60		rts		z_um_star:      rts
.a64e					xt_unloop:
.a64e	68		pla		                pla
.a64f	68		pla		                pla
.a650	68		pla		                pla
.a651	68		pla		                pla
.a652	68		pla		                pla
.a653	68		pla		                pla
.a654	60		rts		z_unloop:       rts
.a655					xt_until:
.a655	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a657	a9 20		lda #$20	                lda #<zero_branch_runtime
.a659	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.a65c	20 7a 87	jsr $877a	                jsr xt_comma
.a65f	60		rts		z_until:        rts
.a660					xt_unused:
.a660	ca		dex		                dex
.a661	ca		dex		                dex
.a662	a9 00		lda #$00	                lda #<cp_end
.a664	38		sec		                sec
.a665	e5 00		sbc $00		                sbc cp
.a667	95 00		sta $00,x	                sta 0,x
.a669	a9 7c		lda #$7c	                lda #>cp_end
.a66b	e5 01		sbc $01		                sbc cp+1
.a66d	95 01		sta $01,x	                sta 1,x
.a66f	60		rts		z_unused:       rts
.a670					xt_update:
.a670	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a672	b1 1e		lda ($1e),y	                lda (up),y
.a674	09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a676	91 1e		sta ($1e),y	                sta (up),y
.a678	60		rts		z_update:       rts
.a679					xt_useraddr:
.a679	ca		dex		                dex
.a67a	ca		dex		                dex
.a67b	a9 1e		lda #$1e	                lda #<up
.a67d	95 00		sta $00,x	                sta 0,x
.a67f	a9 00		lda #$00	                lda #>up
.a681	95 01		sta $01,x	                sta 1,x
.a683	60		rts		z_useraddr:     rts
.a684					xt_variable:
.a684	20 75 89	jsr $8975	                jsr xt_create
.a687	a9 00		lda #$00	                lda #0
.a689	92 00		sta ($00)	                sta (cp)
.a68b	e6 00		inc $00		                inc cp
.a68d	d0 02		bne $a691	                bne +
.a68f	e6 01		inc $01		                inc cp+1
.a691					+
.a691	92 00		sta ($00)	                sta (cp)
.a693	e6 00		inc $00		                inc cp
.a695	d0 02		bne $a699	                bne +
.a697	e6 01		inc $01		                inc cp+1
.a699					+
.a699	20 3d 89	jsr $893d	                jsr adjust_z
.a69c	60		rts		z_variable:     rts
.a69d					xt_while:
.a69d	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a69f	a9 20		lda #$20	                lda #<zero_branch_runtime
.a6a1	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.a6a4	20 7e 91	jsr $917e	                jsr xt_here
.a6a7	20 b4 a7	jsr $a7b4	                jsr xt_zero
.a6aa	20 7a 87	jsr $877a	                jsr xt_comma
.a6ad	20 ba a1	jsr $a1ba	                jsr xt_swap
.a6b0	60		rts		z_while:        rts
.a6b1					xt_within:
.a6b1	20 5a d8	jsr $d85a	                jsr underflow_3
.a6b4	20 9f 98	jsr $989f	                jsr xt_over
.a6b7	20 5c 95	jsr $955c	                jsr xt_minus
.a6ba	20 7c a3	jsr $a37c	                jsr xt_to_r
.a6bd	20 5c 95	jsr $955c	                jsr xt_minus
.a6c0	20 9e 9a	jsr $9a9e	                jsr xt_r_from
.a6c3	20 7e a5	jsr $a57e	                jsr xt_u_less_than
.a6c6	60		rts		z_within:       rts
.a6c7					xt_word:
.a6c7	20 50 d8	jsr $d850	                jsr underflow_1
.a6ca	a4 0c		ldy $0c		                ldy toin                ; >IN
.a6cc					_loop:
.a6cc	c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a6ce	f0 09		beq $a6d9	                beq _found_char
.a6d0	b1 08		lda ($08),y	                lda (cib),y
.a6d2	d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a6d4	d0 03		bne $a6d9	                bne _found_char
.a6d6	c8		iny		                iny
.a6d7	80 f3		bra $a6cc	                bra _loop
.a6d9					_found_char:
.a6d9	84 0c		sty $0c		                sty toin
.a6db	20 46 99	jsr $9946	                jsr xt_parse            ; Returns ( addr u )
.a6de	b5 00		lda $00,x	                lda 0,x
.a6e0	92 00		sta ($00)	                sta (cp)                ; Save length of string
.a6e2	48		pha		                pha                     ; Keep copy of length for later
.a6e3	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( addr u u )
.a6e6	a5 00		lda $00		                lda cp
.a6e8	18		clc		                clc
.a6e9	69 01		adc #$01	                adc #1
.a6eb	95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a6ed	a5 01		lda $01		                lda cp+1
.a6ef	69 00		adc #$00	                adc #0
.a6f1	95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a6f3	20 ce 95	jsr $95ce	                jsr xt_move
.a6f6	ca		dex		                dex
.a6f7	ca		dex		                dex
.a6f8	a5 00		lda $00		                lda cp
.a6fa	95 00		sta $00,x	                sta 0,x
.a6fc	a5 01		lda $01		                lda cp+1
.a6fe	95 01		sta $01,x	                sta 1,x
.a700	68		pla		                pla                     ; length of string
.a701	18		clc		                clc
.a702	65 00		adc $00		                adc cp
.a704	85 00		sta $00		                sta cp
.a706	a5 01		lda $01		                lda cp+1
.a708	69 00		adc #$00	                adc #0                  ; we only need the carry
.a70a	85 01		sta $01		                sta cp+1
.a70c	60		rts		z_word:         rts
.a70d					xt_wordlist:
.a70d	a0 05		ldy #$05	                ldy #num_wordlists_offset
.a70f	b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a711	c9 0c		cmp #$0c	                cmp #max_wordlists
.a713	d0 05		bne $a71a	                bne _ok
.a715	a9 0b		lda #$0b	                lda #err_wordlist
.a717	4c 66 d8	jmp $d866	                jmp error
.a71a					_ok:
.a71a	1a		inc a		                ina             ; Increment the wordlist#
.a71b	91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a71d	ca		dex		                dex             ; and put it on the stack.
.a71e	ca		dex		                dex
.a71f	95 00		sta $00,x	                sta 0,x
.a721	74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a723	60		rts		z_wordlist:     rts
.a724					xt_words:
.a724	20 6f 89	jsr $896f	                jsr xt_cr
.a727	a9 00		lda #$00	                lda #0
.a729	48		pha		                pha
.a72a	ca		dex		                dex                     ; Make room on the stack for
.a72b	ca		dex		                dex                     ; a dictionary pointer.
.a72c	64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a72e					_wordlist_loop:
.a72e	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a730	a5 28		lda $28		                lda tmp3
.a732	d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a734	d0 02		bne $a738	                bne _have_wordlist
.a736	80 45		bra $a77d	                bra _words_done
.a738					_have_wordlist:
.a738	18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a739	69 1f		adc #$1f	                adc #search_order_offset
.a73b	a8		tay		                tay
.a73c	b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a73e	0a		asl a		                asl                     ; Turn offset into cells offset.
.a73f	18		clc		                clc
.a740	69 06		adc #$06	                adc #wordlists_offset
.a742	a8		tay		                tay
.a743	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a745	95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a747	c8		iny		                iny
.a748	b1 1e		lda ($1e),y	                lda (up),y
.a74a	95 01		sta $01,x	                sta 1,x
.a74c					_loop:
.a74c	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( nt nt )
.a74f	20 0a 96	jsr $960a	                jsr xt_name_to_string   ; ( nt addr u )
.a752	68		pla		                pla
.a753	18		clc		                clc
.a754	75 00		adc $00,x	                adc 0,x
.a756	1a		inc a		                ina                     ; don't forget the space between words
.a757	c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a759	90 06		bcc $a761	                bcc +
.a75b	20 6f 89	jsr $896f	                jsr xt_cr
.a75e	b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a760	1a		inc a		                ina                     ; with length of this word.
.a761					+
.a761	48		pha		                pha
.a762	20 0f a5	jsr $a50f	                jsr xt_type             ; ( nt )
.a765	a9 20		lda #$20	                lda #AscSP
.a767	20 02 8e	jsr $8e02	                jsr emit_a
.a76a	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+
.a76d	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+
.a770	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; @ ( nt+1 )
.a773	b5 00		lda $00,x	                lda 0,x
.a775	15 01		ora $01,x	                ora 1,x
.a777	d0 d3		bne $a74c	                bne _loop
.a779	e6 28		inc $28		                inc tmp3
.a77b	80 b1		bra $a72e	                bra _wordlist_loop
.a77d					_words_done:
.a77d	68		pla		                pla                     ; dump counter
.a77e	e8		inx		                inx
.a77f	e8		inx		                inx
.a780	60		rts		z_words:        rts
.a781					xt_wordsize:
.a781	20 50 d8	jsr $d850	                jsr underflow_1
.a784	b5 00		lda $00,x	                lda 0,x
.a786	85 24		sta $24		                sta tmp1
.a788	b5 01		lda $01,x	                lda 1,x
.a78a	85 25		sta $25		                sta tmp1+1
.a78c	a0 06		ldy #$06	                ldy #6
.a78e	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a790	88		dey		                dey
.a791	88		dey		                dey
.a792	38		sec		                sec
.a793	f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a795	95 00		sta $00,x	                sta 0,x
.a797	a0 07		ldy #$07	                ldy #7
.a799	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a79b	88		dey		                dey
.a79c	88		dey		                dey
.a79d	f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a79f	95 01		sta $01,x	                sta 1,x
.a7a1	60		rts		z_wordsize:     rts
.a7a2					xt_xor:
.a7a2	20 55 d8	jsr $d855	                jsr underflow_2
.a7a5	b5 00		lda $00,x	                lda 0,x
.a7a7	55 02		eor $02,x	                eor 2,x
.a7a9	95 02		sta $02,x	                sta 2,x
.a7ab	b5 01		lda $01,x	                lda 1,x
.a7ad	55 03		eor $03,x	                eor 3,x
.a7af	95 03		sta $03,x	                sta 3,x
.a7b1	e8		inx		                inx
.a7b2	e8		inx		                inx
.a7b3	60		rts		z_xor:          rts
.a7b4					xt_case:
.a7b4					xt_forth_wordlist:
.a7b4					xt_zero:
.a7b4	ca		dex		                dex             ; push
.a7b5	ca		dex		                dex
.a7b6	74 00		stz $00,x	                stz 0,x
.a7b8	74 01		stz $01,x	                stz 1,x
.a7ba					z_case:
.a7ba					z_forth_wordlist:
.a7ba					z_zero:
.a7ba	60		rts		                rts
.a7bb					xt_zero_equal:
.a7bb	20 50 d8	jsr $d850	                jsr underflow_1
.a7be	b5 00		lda $00,x	                lda 0,x
.a7c0	15 01		ora $01,x	                ora 1,x
.a7c2	f0 04		beq $a7c8	                beq _zero
.a7c4	a9 00		lda #$00	                lda #0
.a7c6	80 02		bra $a7ca	                bra _store
.a7c8					_zero:
.a7c8	a9 ff		lda #$ff	                lda #$ff
.a7ca					_store:
.a7ca	95 00		sta $00,x	                sta 0,x
.a7cc	95 01		sta $01,x	                sta 1,x
.a7ce	60		rts		z_zero_equal:   rts
.a7cf					xt_zero_greater:
.a7cf	20 50 d8	jsr $d850	                jsr underflow_1
.a7d2	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a7d4	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7d6	30 05		bmi $a7dd	                bmi _done       ; TOS is negative, keep FLASE
.a7d8	15 00		ora $00,x	                ora 0,x
.a7da	f0 01		beq $a7dd	                beq _done       ; TOS is zero, keep FALSE
.a7dc	88		dey		                dey             ; TOS is postive, make true
.a7dd					_done:
.a7dd	98		tya		                tya
.a7de	95 00		sta $00,x	                sta 0,x
.a7e0	95 01		sta $01,x	                sta 1,x
.a7e2	60		rts		z_zero_greater: rts
.a7e3					xt_zero_less:
.a7e3	20 50 d8	jsr $d850	                jsr underflow_1
.a7e6	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a7e8	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7ea	10 01		bpl $a7ed	                bpl _done       ; TOS is positive, so keep FALSE
.a7ec	88		dey		                dey             ; TOS is negative, make TRUE
.a7ed					_done:
.a7ed	98		tya		                tya
.a7ee	95 00		sta $00,x	                sta 0,x
.a7f0	95 01		sta $01,x	                sta 1,x
.a7f2	60		rts		z_zero_less:    rts
.a7f3					xt_zero_unequal:
.a7f3	20 50 d8	jsr $d850	                jsr underflow_1
.a7f6	a0 00		ldy #$00	                ldy #0          ; default false
.a7f8	b5 00		lda $00,x	                lda 0,x
.a7fa	15 01		ora $01,x	                ora 1,x
.a7fc	f0 01		beq $a7ff	                beq _got_zero
.a7fe	88		dey		                dey
.a7ff					_got_zero:
.a7ff	98		tya		                tya
.a800	95 00		sta $00,x	                sta 0,x
.a802	95 01		sta $01,x	                sta 1,x
.a804	60		rts		z_zero_unequal: rts
.a805					xt_editor_screen_helper:
.a805	20 bb 8d	jsr $8dbb	                jsr xt_dup
.a808	20 e5 9e	jsr $9ee5	                jsr xt_scr
.a80b	20 99 a1	jsr $a199	                jsr xt_store
.a80e	20 c1 85	jsr $85c1	                jsr xt_buffer
.a811					z_editor_screen_helper:
.a811	60		rts		                rts
.a812					xt_editor_enter_screen:
.a812	20 05 a8	jsr $a805	                jsr xt_editor_screen_helper
.a815	20 3a 8d	jsr $8d3a	                jsr xt_drop
.a818	64 2e		stz $2e		                stz editor1
.a81a					_prompt_loop:
.a81a	ca		dex		                dex
.a81b	ca		dex		                dex
.a81c	a5 2e		lda $2e		                lda editor1
.a81e	95 00		sta $00,x	                sta 0,x
.a820	74 01		stz $01,x	                stz 1,x
.a822	20 e7 a8	jsr $a8e7	                jsr xt_editor_o
.a825	e6 2e		inc $2e		                inc editor1
.a827	a9 10		lda #$10	                lda #16
.a829	c5 2e		cmp $2e		                cmp editor1
.a82b	d0 ed		bne $a81a	                bne _prompt_loop
.a82d					z_editor_enter_screen:
.a82d	60		rts		                rts
.a82e					xt_editor_erase_screen:
.a82e	20 05 a8	jsr $a805	                jsr xt_editor_screen_helper
.a831	ca		dex		                dex
.a832	ca		dex		                dex
.a833	74 00		stz $00,x	                stz 0,x
.a835	a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a837	95 01		sta $01,x	                sta 1,x
.a839	20 f6 8e	jsr $8ef6	                jsr xt_blank
.a83c	20 70 a6	jsr $a670	                jsr xt_update
.a83f					z_editor_erase_screen:
.a83f	60		rts		                rts
.a840					xt_editor_el:
.a840	20 ce a8	jsr $a8ce	                jsr xt_editor_line
.a843	ca		dex		                dex
.a844	ca		dex		                dex
.a845	a9 40		lda #$40	                lda #64
.a847	95 00		sta $00,x	                sta 0,x
.a849	74 01		stz $01,x	                stz 1,x
.a84b	20 f6 8e	jsr $8ef6	                jsr xt_blank
.a84e	20 70 a6	jsr $a670	                jsr xt_update
.a851	60		rts		z_editor_el:    rts
.a852					xt_editor_l:
.a852	ca		dex		                dex             ; Put SCR on the stack.
.a853	ca		dex		                dex
.a854	a0 02		ldy #$02	                ldy #scr_offset
.a856	b1 1e		lda ($1e),y	                lda (up),y
.a858	95 00		sta $00,x	                sta 0,x
.a85a	c8		iny		                iny
.a85b	b1 1e		lda ($1e),y	                lda (up),y
.a85d	95 01		sta $01,x	                sta 1,x
.a85f	20 cd 83	jsr $83cd	                jsr xt_block    ; Get the current screen.
.a862	20 6f 89	jsr $896f	                jsr xt_cr
.a865	80 08		bra $a86f	                bra _after_screen_msg
.a867					_screen_msg:
>a867	53 63 72 65 65 6e 20 23		                .text "Screen #"
.a86f					_after_screen_msg:
.a86f	20 b5 a0	jsr $a0b5	                jsr sliteral_runtime
>a872	67 a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a876	20 0f a5	jsr $a50f	                jsr xt_type
.a879	20 e5 9e	jsr $9ee5	                jsr xt_scr
.a87c	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.a87f	ca		dex		                dex
.a880	ca		dex		                dex
.a881	a9 04		lda #$04	                lda #4          ; four spaces
.a883	95 00		sta $00,x	                sta 0,x
.a885	74 01		stz $01,x	                stz 1,x
.a887	20 46 a5	jsr $a546	                jsr xt_u_dot_r
.a88a	64 28		stz $28		                stz tmp3
.a88c					_line_loop:
.a88c	20 6f 89	jsr $896f	                jsr xt_cr
.a88f	ca		dex		                dex
.a890	ca		dex		                dex
.a891	ca		dex		                dex
.a892	ca		dex		                dex
.a893	74 03		stz $03,x	                stz 3,x
.a895	a5 28		lda $28		                lda tmp3
.a897	95 02		sta $02,x	                sta 2,x
.a899	74 01		stz $01,x	                stz 1,x
.a89b	a9 02		lda #$02	                lda #2
.a89d	95 00		sta $00,x	                sta 0,x
.a89f	20 46 a5	jsr $a546	                jsr xt_u_dot_r
.a8a2	20 2a a1	jsr $a12a	                jsr xt_space
.a8a5	20 bb 8d	jsr $8dbb	                jsr xt_dup
.a8a8	ca		dex		                dex
.a8a9	ca		dex		                dex
.a8aa	a9 40		lda #$40	                lda #64
.a8ac	95 00		sta $00,x	                sta 0,x
.a8ae	74 01		stz $01,x	                stz 1,x
.a8b0	20 0f a5	jsr $a50f	                jsr xt_type
.a8b3	18		clc		                clc
.a8b4	a9 40		lda #$40	                lda #64
.a8b6	75 00		adc $00,x	                adc 0,x
.a8b8	95 00		sta $00,x	                sta 0,x
.a8ba	b5 01		lda $01,x	                lda 1,x
.a8bc	69 00		adc #$00	                adc #0      ; Add carry
.a8be	95 01		sta $01,x	                sta 1,x
.a8c0	e6 28		inc $28		                inc tmp3
.a8c2	a5 28		lda $28		                lda tmp3
.a8c4	c9 10		cmp #$10	                cmp #16
.a8c6	d0 c4		bne $a88c	                bne _line_loop
.a8c8	20 6f 89	jsr $896f	                jsr xt_cr
.a8cb	e8		inx		                inx
.a8cc	e8		inx		                inx
.a8cd	60		rts		z_editor_l:            rts
.a8ce					xt_editor_line:
.a8ce	20 50 d8	jsr $d850	                jsr underflow_1
.a8d1	a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a8d3					_shift_tos_left:
.a8d3	16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a8d5	36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a8d7	88		dey		                dey
.a8d8	d0 f9		bne $a8d3	                bne _shift_tos_left
.a8da	20 e5 9e	jsr $9ee5	                jsr xt_scr
.a8dd	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.a8e0	20 cd 83	jsr $83cd	                jsr xt_block
.a8e3	20 ef 99	jsr $99ef	                jsr xt_plus
.a8e6	60		rts		z_editor_line:  rts
.a8e7					xt_editor_o:
.a8e7	20 6f 89	jsr $896f	                jsr xt_cr
.a8ea	20 bb 8d	jsr $8dbb	                jsr xt_dup
.a8ed	20 b3 a3	jsr $a3b3	                jsr xt_two
.a8f0	20 46 a5	jsr $a546	                jsr xt_u_dot_r
.a8f3	20 2a a1	jsr $a12a	                jsr xt_space
.a8f6	a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a8f8	20 02 8e	jsr $8e02	                jsr emit_a
.a8fb	20 2a a1	jsr $a12a	                jsr xt_space
.a8fe	20 ce a8	jsr $a8ce	                jsr xt_editor_line
.a901	20 bb 8d	jsr $8dbb	                jsr xt_dup      ; Save a copy of the line address for later.
.a904	ca		dex		                dex
.a905	ca		dex		                dex
.a906	a9 40		lda #$40	                lda #64         ; chars/line
.a908	95 00		sta $00,x	                sta 0,x
.a90a	74 01		stz $01,x	                stz 1,x
.a90c	20 38 81	jsr $8138	                jsr xt_accept
.a90f	20 bb 8d	jsr $8dbb	                jsr xt_dup
.a912	20 7a 96	jsr $967a	                jsr xt_not_rote ; -rot
.a915	20 ef 99	jsr $99ef	                jsr xt_plus
.a918	ca		dex		                dex
.a919	ca		dex		                dex
.a91a	a9 40		lda #$40	                lda #64         ; chars/line
.a91c	95 00		sta $00,x	                sta 0,x
.a91e	74 01		stz $01,x	                stz 1,x
.a920	20 63 9b	jsr $9b63	                jsr xt_rot
.a923	20 5c 95	jsr $955c	                jsr xt_minus
.a926	20 f6 8e	jsr $8ef6	                jsr xt_blank
.a929	20 70 a6	jsr $a670	                jsr xt_update
.a92c	60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a92d					assembler:
.a92d					xt_asm_adc_h:
.a92d	a9 69		lda #$69	                lda #$69
.a92f	4c 88 ac	jmp $ac88	                jmp asm_common
.a932					z_asm_adc_h:
.a932					xt_asm_adc_x:
.a932	a9 7d		lda #$7d	                lda #$7D
.a934	4c 88 ac	jmp $ac88	                jmp asm_common
.a937					z_asm_adc_x:
.a937					xt_asm_adc_y:
.a937	a9 79		lda #$79	                lda #$79
.a939	4c 88 ac	jmp $ac88	                jmp asm_common
.a93c					z_asm_adc_y:
.a93c					xt_asm_adc_z:
.a93c	a9 65		lda #$65	                lda #$65
.a93e	4c 88 ac	jmp $ac88	                jmp asm_common
.a941					z_asm_adc_z:
.a941					xt_asm_adc_zi:
.a941	a9 72		lda #$72	                lda #$72
.a943	4c 88 ac	jmp $ac88	                jmp asm_common
.a946					z_asm_adc_zi:
.a946					xt_asm_adc_ziy:
.a946	a9 71		lda #$71	                lda #$71
.a948	4c 88 ac	jmp $ac88	                jmp asm_common
.a94b					z_asm_adc_ziy:
.a94b					xt_asm_adc_zx:
.a94b	a9 75		lda #$75	                lda #$75
.a94d	4c 88 ac	jmp $ac88	                jmp asm_common
.a950					z_asm_adc_zx:
.a950					xt_asm_adc_zxi:
.a950	a9 61		lda #$61	                lda #$61
.a952	4c 88 ac	jmp $ac88	                jmp asm_common
.a955					z_asm_adc_zxi:
.a955					xt_asm_and:
.a955	a9 2d		lda #$2d	                lda #$2D
.a957	4c 88 ac	jmp $ac88	                jmp asm_common
.a95a					z_asm_and:
.a95a					xt_asm_and_h:
.a95a	a9 29		lda #$29	                lda #$29
.a95c	4c 88 ac	jmp $ac88	                jmp asm_common
.a95f					z_asm_and_h:
.a95f					xt_asm_and_x:
.a95f	a9 3d		lda #$3d	                lda #$3D
.a961	4c 88 ac	jmp $ac88	                jmp asm_common
.a964					z_asm_and_x:
.a964					xt_asm_and_y:
.a964	a9 39		lda #$39	                lda #$39
.a966	4c 88 ac	jmp $ac88	                jmp asm_common
.a969					z_asm_and_y:
.a969					xt_asm_and_z:
.a969	a9 25		lda #$25	                lda #$25
.a96b	4c 88 ac	jmp $ac88	                jmp asm_common
.a96e					z_asm_and_z:
.a96e					xt_asm_and_zi:
.a96e	a9 32		lda #$32	                lda #$32
.a970	4c 88 ac	jmp $ac88	                jmp asm_common
.a973					z_asm_and_zi:
.a973					xt_asm_and_ziy:
.a973	a9 31		lda #$31	                lda #$31
.a975	4c 88 ac	jmp $ac88	                jmp asm_common
.a978					z_asm_and_ziy:
.a978					xt_asm_and_zx:
.a978	a9 35		lda #$35	                lda #$35
.a97a	4c 88 ac	jmp $ac88	                jmp asm_common
.a97d					z_asm_and_zx:
.a97d					xt_asm_and_zxi:
.a97d	a9 21		lda #$21	                lda #$21
.a97f	4c 88 ac	jmp $ac88	                jmp asm_common
.a982					z_asm_and_zxi:
.a982					xt_asm_asl:
.a982	a9 0e		lda #$0e	                lda #$0E
.a984	4c 88 ac	jmp $ac88	                jmp asm_common
.a987					z_asm_asl:
.a987					xt_asm_asl_a:
.a987	a9 0a		lda #$0a	                lda #$0A
.a989	4c 88 ac	jmp $ac88	                jmp asm_common
.a98c					z_asm_asl_a:
.a98c					xt_asm_asl_x:
.a98c	a9 1e		lda #$1e	                lda #$1E
.a98e	4c 88 ac	jmp $ac88	                jmp asm_common
.a991					z_asm_asl_x:
.a991					xt_asm_asl_z:
.a991	a9 06		lda #$06	                lda #$06
.a993	4c 88 ac	jmp $ac88	                jmp asm_common
.a996					z_asm_asl_z:
.a996					xt_asm_asl_zx:
.a996	a9 16		lda #$16	                lda #$16
.a998	4c 88 ac	jmp $ac88	                jmp asm_common
.a99b					z_asm_asl_zx:
.a99b					xt_asm_bcc:
.a99b	a9 90		lda #$90	                lda #$90
.a99d	4c 88 ac	jmp $ac88	                jmp asm_common
.a9a0					z_asm_bcc:
.a9a0					xt_asm_bcs:
.a9a0	a9 b0		lda #$b0	                lda #$B0
.a9a2	a0 02		ldy #$02	                ldy #2
.a9a4	4c 88 ac	jmp $ac88	                jmp asm_common
.a9a7					z_asm_bcs:
.a9a7					xt_asm_beq:
.a9a7	a9 f0		lda #$f0	                lda #$F0
.a9a9	4c 88 ac	jmp $ac88	                jmp asm_common
.a9ac					z_asm_beq:
.a9ac					xt_asm_bit:
.a9ac	a9 2c		lda #$2c	                lda #$2C
.a9ae	4c 88 ac	jmp $ac88	                jmp asm_common
.a9b1					z_asm_bit:
.a9b1					xt_asm_bit_h:
.a9b1	a9 89		lda #$89	                lda #$89
.a9b3	4c 88 ac	jmp $ac88	                jmp asm_common
.a9b6					z_asm_bit_h:
.a9b6					xt_asm_bit_x:
.a9b6	a9 3c		lda #$3c	                lda #$3C
.a9b8	4c 88 ac	jmp $ac88	                jmp asm_common
.a9bb					z_asm_bit_x:
.a9bb					xt_asm_bit_z:
.a9bb	a9 24		lda #$24	                lda #$24
.a9bd	4c 88 ac	jmp $ac88	                jmp asm_common
.a9c0					z_asm_bit_z:
.a9c0					xt_asm_bit_zx:
.a9c0	a9 34		lda #$34	                lda #$34
.a9c2	4c 88 ac	jmp $ac88	                jmp asm_common
.a9c5					z_asm_bit_zx:
.a9c5					xt_asm_bmi:
.a9c5	a9 30		lda #$30	                lda #$30
.a9c7	4c 88 ac	jmp $ac88	                jmp asm_common
.a9ca					z_asm_bmi:
.a9ca					xt_asm_bne:
.a9ca	a9 d0		lda #$d0	                lda #$D0
.a9cc	4c 88 ac	jmp $ac88	                jmp asm_common
.a9cf					z_asm_bne:
.a9cf					xt_asm_bpl:
.a9cf	a9 10		lda #$10	                lda #$10
.a9d1	4c 88 ac	jmp $ac88	                jmp asm_common
.a9d4					z_asm_bpl:
.a9d4					xt_asm_bra:
.a9d4	a9 80		lda #$80	                lda #$80
.a9d6	4c 88 ac	jmp $ac88	                jmp asm_common
.a9d9					z_asm_bra:
.a9d9					xt_asm_brk:
.a9d9	a9 00		lda #$00	                lda #$00
.a9db	4c 88 ac	jmp $ac88	                jmp asm_common
.a9de					z_asm_brk:
.a9de					xt_asm_bvc:
.a9de	a9 50		lda #$50	                lda #$50
.a9e0	4c 88 ac	jmp $ac88	                jmp asm_common
.a9e3					z_asm_bvc:
.a9e3					xt_asm_bvs:
.a9e3	a9 70		lda #$70	                lda #$70
.a9e5	4c 88 ac	jmp $ac88	                jmp asm_common
.a9e8					z_asm_bvs:
.a9e8					xt_asm_clc:
.a9e8	a9 18		lda #$18	                lda #$18
.a9ea	4c 88 ac	jmp $ac88	                jmp asm_common
.a9ed					z_asm_clc:
.a9ed					xt_asm_cld:
.a9ed	a9 d8		lda #$d8	                lda #$D8
.a9ef	4c 88 ac	jmp $ac88	                jmp asm_common
.a9f2					z_asm_cld:
.a9f2					xt_asm_cli:
.a9f2	a9 58		lda #$58	                lda #$58
.a9f4	4c 88 ac	jmp $ac88	                jmp asm_common
.a9f7					z_asm_cli:
.a9f7					xt_asm_clv:
.a9f7	a9 b8		lda #$b8	                lda #$B8
.a9f9	4c 88 ac	jmp $ac88	                jmp asm_common
.a9fc					z_asm_clv:
.a9fc					xt_asm_cmp:
.a9fc	a9 cd		lda #$cd	                lda #$CD
.a9fe	4c 88 ac	jmp $ac88	                jmp asm_common
.aa01					z_asm_cmp:
.aa01					xt_asm_cmp_h:
.aa01	a9 c9		lda #$c9	                lda #$C9
.aa03	4c 88 ac	jmp $ac88	                jmp asm_common
.aa06					z_asm_cmp_h:
.aa06					xt_asm_cmp_x:
.aa06	a9 dd		lda #$dd	                lda #$DD
.aa08	4c 88 ac	jmp $ac88	                jmp asm_common
.aa0b					z_asm_cmp_x:
.aa0b					xt_asm_cmp_y:
.aa0b	a9 d9		lda #$d9	                lda #$D9
.aa0d	4c 88 ac	jmp $ac88	                jmp asm_common
.aa10					z_asm_cmp_y:
.aa10					xt_asm_cmp_z:
.aa10	a9 c5		lda #$c5	                lda #$C5
.aa12	4c 88 ac	jmp $ac88	                jmp asm_common
.aa15					z_asm_cmp_z:
.aa15					xt_asm_cmp_zi:
.aa15	a9 d2		lda #$d2	                lda #$D2
.aa17	4c 88 ac	jmp $ac88	                jmp asm_common
.aa1a					z_asm_cmp_zi:
.aa1a					xt_asm_cmp_ziy:
.aa1a	a9 d1		lda #$d1	                lda #$D1
.aa1c	4c 88 ac	jmp $ac88	                jmp asm_common
.aa1f					z_asm_cmp_ziy:
.aa1f					xt_asm_cmp_zx:
.aa1f	a9 d5		lda #$d5	                lda #$D5
.aa21	4c 88 ac	jmp $ac88	                jmp asm_common
.aa24					z_asm_cmp_zx:
.aa24					xt_asm_cmp_zxi:
.aa24	a9 c1		lda #$c1	                lda #$C1
.aa26	4c 88 ac	jmp $ac88	                jmp asm_common
.aa29					z_asm_cmp_zxi:
.aa29					xt_asm_cpx:
.aa29	a9 ec		lda #$ec	                lda #$EC
.aa2b	4c 88 ac	jmp $ac88	                jmp asm_common
.aa2e					z_asm_cpx:
.aa2e					xt_asm_cpx_h:
.aa2e	a9 e0		lda #$e0	                lda #$E0
.aa30	4c 88 ac	jmp $ac88	                jmp asm_common
.aa33					z_asm_cpx_h:
.aa33					xt_asm_cpx_z:
.aa33	a9 e4		lda #$e4	                lda #$E4
.aa35	4c 88 ac	jmp $ac88	                jmp asm_common
.aa38					z_asm_cpx_z:
.aa38					xt_asm_cpy:
.aa38	a9 cc		lda #$cc	                lda #$CC
.aa3a	a0 03		ldy #$03	                ldy #3
.aa3c	4c 88 ac	jmp $ac88	                jmp asm_common
.aa3f					z_asm_cpy:
.aa3f					xt_asm_cpy_h:
.aa3f	a9 c0		lda #$c0	                lda #$C0
.aa41	4c 88 ac	jmp $ac88	                jmp asm_common
.aa44					z_asm_cpy_h:
.aa44					xt_asm_cpy_z:
.aa44	a9 c4		lda #$c4	                lda #$C4
.aa46	4c 88 ac	jmp $ac88	                jmp asm_common
.aa49					z_asm_cpy_z:
.aa49					xt_asm_dec:
.aa49	a9 ce		lda #$ce	                lda #$CE
.aa4b	4c 88 ac	jmp $ac88	                jmp asm_common
.aa4e					z_asm_dec:
.aa4e					xt_asm_dec_a:
.aa4e	a9 3a		lda #$3a	                lda #$3A
.aa50	4c 88 ac	jmp $ac88	                jmp asm_common
.aa53					z_asm_dec_a:
.aa53					xt_asm_dec_x:
.aa53	a9 de		lda #$de	                lda #$DE
.aa55	4c 88 ac	jmp $ac88	                jmp asm_common
.aa58					z_asm_dec_x:
.aa58					xt_asm_dec_z:
.aa58	a9 c6		lda #$c6	                lda #$C6
.aa5a	4c 88 ac	jmp $ac88	                jmp asm_common
.aa5d					z_asm_dec_z:
.aa5d					xt_asm_dec_zx:
.aa5d	a9 d6		lda #$d6	                lda #$D6
.aa5f	4c 88 ac	jmp $ac88	                jmp asm_common
.aa62					z_asm_dec_zx:
.aa62					xt_asm_dex:
.aa62	a9 ca		lda #$ca	                lda #$CA
.aa64	4c 88 ac	jmp $ac88	                jmp asm_common
.aa67					z_asm_dex:
.aa67					xt_asm_dey:
.aa67	a9 88		lda #$88	                lda #$88
.aa69	4c 88 ac	jmp $ac88	                jmp asm_common
.aa6c					z_asm_dey:
.aa6c					xt_asm_eor:
.aa6c	a9 4d		lda #$4d	                lda #$4D
.aa6e	4c 88 ac	jmp $ac88	                jmp asm_common
.aa71					z_asm_eor:
.aa71					xt_asm_eor_h:
.aa71	a9 49		lda #$49	                lda #$49
.aa73	4c 88 ac	jmp $ac88	                jmp asm_common
.aa76					z_asm_eor_h:
.aa76					xt_asm_eor_x:
.aa76	a9 5d		lda #$5d	                lda #$5D
.aa78	4c 88 ac	jmp $ac88	                jmp asm_common
.aa7b					z_asm_eor_x:
.aa7b					xt_asm_eor_y:
.aa7b	a9 59		lda #$59	                lda #$59
.aa7d	4c 88 ac	jmp $ac88	                jmp asm_common
.aa80					z_asm_eor_y:
.aa80					xt_asm_eor_z:
.aa80	a9 45		lda #$45	                lda #$45
.aa82	4c 88 ac	jmp $ac88	                jmp asm_common
.aa85					z_asm_eor_z:
.aa85					xt_asm_eor_zi:
.aa85	a9 52		lda #$52	                lda #$52
.aa87	4c 88 ac	jmp $ac88	                jmp asm_common
.aa8a					z_asm_eor_zi:
.aa8a					xt_asm_eor_ziy:
.aa8a	a9 51		lda #$51	                lda #$51
.aa8c	4c 88 ac	jmp $ac88	                jmp asm_common
.aa8f					z_asm_eor_ziy:
.aa8f					xt_asm_eor_zx:
.aa8f	a9 55		lda #$55	                lda #$55
.aa91	4c 88 ac	jmp $ac88	                jmp asm_common
.aa94					z_asm_eor_zx:
.aa94					xt_asm_eor_zxi:
.aa94	a9 41		lda #$41	                lda #$41
.aa96	4c 88 ac	jmp $ac88	                jmp asm_common
.aa99					z_asm_eor_zxi:
.aa99					xt_asm_inc:
.aa99	a9 ee		lda #$ee	                lda #$EE
.aa9b	4c 88 ac	jmp $ac88	                jmp asm_common
.aa9e					z_asm_inc:
.aa9e					xt_asm_inc_a:
.aa9e	a9 1a		lda #$1a	                lda #$1A
.aaa0	4c 88 ac	jmp $ac88	                jmp asm_common
.aaa3					z_asm_inc_a:
.aaa3					xt_asm_inc_x:
.aaa3	a9 fe		lda #$fe	                lda #$FE
.aaa5	4c 88 ac	jmp $ac88	                jmp asm_common
.aaa8					z_asm_inc_x:
.aaa8					xt_asm_inc_z:
.aaa8	a9 e6		lda #$e6	                lda #$E6
.aaaa	4c 88 ac	jmp $ac88	                jmp asm_common
.aaad					z_asm_inc_z:
.aaad					xt_asm_inc_zx:
.aaad	a9 f6		lda #$f6	                lda #$F6
.aaaf	4c 88 ac	jmp $ac88	                jmp asm_common
.aab2					z_asm_inc_zx:
.aab2					xt_asm_inx:
.aab2	a9 e8		lda #$e8	                lda #$E8
.aab4	4c 88 ac	jmp $ac88	                jmp asm_common
.aab7					z_asm_inx:
.aab7					xt_asm_iny:
.aab7	a9 c8		lda #$c8	                lda #$C8
.aab9	4c 88 ac	jmp $ac88	                jmp asm_common
.aabc					z_asm_iny:
.aabc					xt_asm_jmp:
.aabc	a9 4c		lda #$4c	                lda #$4C
.aabe	4c 88 ac	jmp $ac88	                jmp asm_common
.aac1					z_asm_jmp:
.aac1					xt_asm_jmp_i:
.aac1	a9 6c		lda #$6c	                lda #$6C
.aac3	4c 88 ac	jmp $ac88	                jmp asm_common
.aac6					z_asm_jmp_i:
.aac6					xt_asm_jmp_xi:
.aac6	a9 7c		lda #$7c	                lda #$7C
.aac8	4c 88 ac	jmp $ac88	                jmp asm_common
.aacb					z_asm_jmp_xi:
.aacb					xt_asm_jsr:
.aacb	a9 20		lda #$20	                lda #$20
.aacd	4c 88 ac	jmp $ac88	                jmp asm_common
.aad0					z_asm_jsr:
.aad0					xt_asm_lda:
.aad0	a9 ad		lda #$ad	                lda #$AD
.aad2	4c 88 ac	jmp $ac88	                jmp asm_common
.aad5					z_asm_lda:
.aad5					xt_asm_lda_h:
.aad5	a9 a9		lda #$a9	                lda #$A9
.aad7	4c 88 ac	jmp $ac88	                jmp asm_common
.aada					z_asm_lda_h:
.aada					xt_asm_lda_x:
.aada	a9 bd		lda #$bd	                lda #$BD
.aadc	4c 88 ac	jmp $ac88	                jmp asm_common
.aadf					z_asm_lda_x:
.aadf					xt_asm_lda_y:
.aadf	a9 b9		lda #$b9	                lda #$B9
.aae1	4c 88 ac	jmp $ac88	                jmp asm_common
.aae4					z_asm_lda_y:
.aae4					xt_asm_lda_z:
.aae4	a9 a5		lda #$a5	                lda #$A5
.aae6	4c 88 ac	jmp $ac88	                jmp asm_common
.aae9					z_asm_lda_z:
.aae9					xt_asm_lda_zi:
.aae9	a9 b2		lda #$b2	                lda #$B2
.aaeb	4c 88 ac	jmp $ac88	                jmp asm_common
.aaee					z_asm_lda_zi:
.aaee					xt_asm_lda_ziy:
.aaee	a9 b1		lda #$b1	                lda #$B1
.aaf0	4c 88 ac	jmp $ac88	                jmp asm_common
.aaf3					z_asm_lda_ziy:
.aaf3					xt_asm_lda_zx:
.aaf3	a9 b5		lda #$b5	                lda #$B5
.aaf5	4c 88 ac	jmp $ac88	                jmp asm_common
.aaf8					z_asm_lda_zx:
.aaf8					xt_asm_lda_zxi:
.aaf8	a9 a1		lda #$a1	                lda #$A1
.aafa	4c 88 ac	jmp $ac88	                jmp asm_common
.aafd					z_asm_lda_zxi:
.aafd					xt_asm_ldx:
.aafd	a9 ae		lda #$ae	                lda #$AE
.aaff	4c 88 ac	jmp $ac88	                jmp asm_common
.ab02					z_asm_ldx:
.ab02					xt_asm_ldx_h:
.ab02	a9 a2		lda #$a2	                lda #$A2
.ab04	4c 88 ac	jmp $ac88	                jmp asm_common
.ab07					z_asm_ldx_h:
.ab07					xt_asm_ldx_y:
.ab07	a9 be		lda #$be	                lda #$BE
.ab09	4c 88 ac	jmp $ac88	                jmp asm_common
.ab0c					z_asm_ldx_y:
.ab0c					xt_asm_ldx_z:
.ab0c	a9 a6		lda #$a6	                lda #$A6
.ab0e	4c 88 ac	jmp $ac88	                jmp asm_common
.ab11					z_asm_ldx_z:
.ab11					xt_asm_ldx_zy:
.ab11	a9 b6		lda #$b6	                lda #$B6
.ab13	4c 88 ac	jmp $ac88	                jmp asm_common
.ab16					z_asm_ldx_zy:
.ab16					xt_asm_ldy:
.ab16	a9 ac		lda #$ac	                lda #$AC
.ab18	4c 88 ac	jmp $ac88	                jmp asm_common
.ab1b					z_asm_ldy:
.ab1b					xt_asm_ldy_h:
.ab1b	a9 a0		lda #$a0	                lda #$A0
.ab1d	4c 88 ac	jmp $ac88	                jmp asm_common
.ab20					z_asm_ldy_h:
.ab20					xt_asm_ldy_x:
.ab20	a9 bc		lda #$bc	                lda #$BC
.ab22	4c 88 ac	jmp $ac88	                jmp asm_common
.ab25					z_asm_ldy_x:
.ab25					xt_asm_ldy_z:
.ab25	a9 a4		lda #$a4	                lda #$A4
.ab27	4c 88 ac	jmp $ac88	                jmp asm_common
.ab2a					z_asm_ldy_z:
.ab2a					xt_asm_ldy_zx:
.ab2a	a9 b4		lda #$b4	                lda #$B4
.ab2c	4c 88 ac	jmp $ac88	                jmp asm_common
.ab2f					z_asm_ldy_zx:
.ab2f					xt_asm_lsr:
.ab2f	a9 4e		lda #$4e	                lda #$4E
.ab31	4c 88 ac	jmp $ac88	                jmp asm_common
.ab34					z_asm_lsr:
.ab34					xt_asm_lsr_a:
.ab34	a9 4a		lda #$4a	                lda #$4A
.ab36	4c 88 ac	jmp $ac88	                jmp asm_common
.ab39					z_asm_lsr_a:
.ab39					xt_asm_lsr_x:
.ab39	a9 5e		lda #$5e	                lda #$5E
.ab3b	4c 88 ac	jmp $ac88	                jmp asm_common
.ab3e					z_asm_lsr_x:
.ab3e					xt_asm_lsr_z:
.ab3e	a9 46		lda #$46	                lda #$46
.ab40	4c 88 ac	jmp $ac88	                jmp asm_common
.ab43					z_asm_lsr_z:
.ab43					xt_asm_lsr_zx:
.ab43	a9 56		lda #$56	                lda #$56
.ab45	4c 88 ac	jmp $ac88	                jmp asm_common
.ab48					z_asm_lsr_zx:
.ab48					xt_asm_nop:
.ab48	a9 ea		lda #$ea	                lda #$EA
.ab4a	4c 88 ac	jmp $ac88	                jmp asm_common
.ab4d					z_asm_nop:
.ab4d					xt_asm_ora:
.ab4d	a9 0d		lda #$0d	                lda #$0D
.ab4f	4c 88 ac	jmp $ac88	                jmp asm_common
.ab52					z_asm_ora:
.ab52					xt_asm_ora_h:
.ab52	a9 09		lda #$09	                lda #$09
.ab54	4c 88 ac	jmp $ac88	                jmp asm_common
.ab57					z_asm_ora_h:
.ab57					xt_asm_ora_x:
.ab57	a9 1d		lda #$1d	                lda #$1D
.ab59	4c 88 ac	jmp $ac88	                jmp asm_common
.ab5c					z_asm_ora_x:
.ab5c					xt_asm_ora_y:
.ab5c	a9 19		lda #$19	                lda #$19
.ab5e	4c 88 ac	jmp $ac88	                jmp asm_common
.ab61					z_asm_ora_y:
.ab61					xt_asm_ora_z:
.ab61	a9 05		lda #$05	                lda #$05
.ab63	4c 88 ac	jmp $ac88	                jmp asm_common
.ab66					z_asm_ora_z:
.ab66					xt_asm_ora_zi:
.ab66	a9 12		lda #$12	                lda #$12
.ab68	a0 02		ldy #$02	                ldy #2
.ab6a	4c 88 ac	jmp $ac88	                jmp asm_common
.ab6d					z_asm_ora_zi:
.ab6d					xt_asm_ora_ziy:
.ab6d	a9 11		lda #$11	                lda #$11
.ab6f	4c 88 ac	jmp $ac88	                jmp asm_common
.ab72					z_asm_ora_ziy:
.ab72					xt_asm_ora_zx:
.ab72	a9 15		lda #$15	                lda #$15
.ab74	4c 88 ac	jmp $ac88	                jmp asm_common
.ab77					z_asm_ora_zx:
.ab77					xt_asm_ora_zxi:
.ab77	a9 01		lda #$01	                lda #$01
.ab79	4c 88 ac	jmp $ac88	                jmp asm_common
.ab7c					z_asm_ora_zxi:
.ab7c					xt_asm_pha:
.ab7c	a9 48		lda #$48	                lda #$48
.ab7e	4c 88 ac	jmp $ac88	                jmp asm_common
.ab81					z_asm_pha:
.ab81					xt_asm_php:
.ab81	a9 08		lda #$08	                lda #$08
.ab83	4c 88 ac	jmp $ac88	                jmp asm_common
.ab86					z_asm_php:
.ab86					xt_asm_phx:
.ab86	a9 da		lda #$da	                lda #$DA
.ab88	4c 88 ac	jmp $ac88	                jmp asm_common
.ab8b					z_asm_phx:
.ab8b					xt_asm_phy:
.ab8b	a9 5a		lda #$5a	                lda #$5A
.ab8d	4c 88 ac	jmp $ac88	                jmp asm_common
.ab90					z_asm_phy:
.ab90					xt_asm_pla:
.ab90	a9 68		lda #$68	                lda #$68
.ab92	4c 88 ac	jmp $ac88	                jmp asm_common
.ab95					z_asm_pla:
.ab95					xt_asm_plp:
.ab95	a9 28		lda #$28	                lda #$28
.ab97	4c 88 ac	jmp $ac88	                jmp asm_common
.ab9a					z_asm_plp:
.ab9a					xt_asm_plx:
.ab9a	a9 fa		lda #$fa	                lda #$FA
.ab9c	4c 88 ac	jmp $ac88	                jmp asm_common
.ab9f					z_asm_plx:
.ab9f					xt_asm_ply:
.ab9f	a9 7a		lda #$7a	                lda #$7A
.aba1	4c 88 ac	jmp $ac88	                jmp asm_common
.aba4					z_asm_ply:
.aba4					xt_asm_rol:
.aba4	a9 2e		lda #$2e	                lda #$2E
.aba6	4c 88 ac	jmp $ac88	                jmp asm_common
.aba9					z_asm_rol:
.aba9					xt_asm_rol_a:
.aba9	a9 2a		lda #$2a	                lda #$2A
.abab	4c 88 ac	jmp $ac88	                jmp asm_common
.abae					z_asm_rol_a:
.abae					xt_asm_rol_x:
.abae	a9 3e		lda #$3e	                lda #$3E
.abb0	4c 88 ac	jmp $ac88	                jmp asm_common
.abb3					z_asm_rol_x:
.abb3					xt_asm_rol_z:
.abb3	a9 26		lda #$26	                lda #$26
.abb5	4c 88 ac	jmp $ac88	                jmp asm_common
.abb8					z_asm_rol_z:
.abb8					xt_asm_rol_zx:
.abb8	a9 36		lda #$36	                lda #$36
.abba	4c 88 ac	jmp $ac88	                jmp asm_common
.abbd					z_asm_rol_zx:
.abbd					xt_asm_ror:
.abbd	a9 6e		lda #$6e	                lda #$6E
.abbf	4c 88 ac	jmp $ac88	                jmp asm_common
.abc2					z_asm_ror:
.abc2					xt_asm_ror_a:
.abc2	a9 6a		lda #$6a	                lda #$6A
.abc4	4c 88 ac	jmp $ac88	                jmp asm_common
.abc7					z_asm_ror_a:
.abc7					xt_asm_ror_x:
.abc7	a9 7e		lda #$7e	                lda #$7E
.abc9	4c 88 ac	jmp $ac88	                jmp asm_common
.abcc					z_asm_ror_x:
.abcc					xt_asm_ror_z:
.abcc	a9 66		lda #$66	                lda #$66
.abce	4c 88 ac	jmp $ac88	                jmp asm_common
.abd1					z_asm_ror_z:
.abd1					xt_asm_ror_zx:
.abd1	a9 76		lda #$76	                lda #$76
.abd3	4c 88 ac	jmp $ac88	                jmp asm_common
.abd6					z_asm_ror_zx:
.abd6					xt_asm_rti:
.abd6	a9 40		lda #$40	                lda #$40
.abd8	4c 88 ac	jmp $ac88	                jmp asm_common
.abdb					z_asm_rti:
.abdb					xt_asm_rts:
.abdb	a9 60		lda #$60	                lda #$60
.abdd	4c 88 ac	jmp $ac88	                jmp asm_common
.abe0					z_asm_rts:
.abe0					xt_asm_sbc:
.abe0	a9 ed		lda #$ed	                lda #$ED
.abe2	4c 88 ac	jmp $ac88	                jmp asm_common
.abe5					z_asm_sbc:
.abe5					xt_asm_sbc_h:
.abe5	a9 e9		lda #$e9	                lda #$E9
.abe7	4c 88 ac	jmp $ac88	                jmp asm_common
.abea					z_asm_sbc_h:
.abea					xt_asm_sbc_x:
.abea	a9 fd		lda #$fd	                lda #$FD
.abec	4c 88 ac	jmp $ac88	                jmp asm_common
.abef					z_asm_sbc_x:
.abef					xt_asm_sbc_y:
.abef	a9 f9		lda #$f9	                lda #$F9
.abf1	4c 88 ac	jmp $ac88	                jmp asm_common
.abf4					z_asm_sbc_y:
.abf4					xt_asm_sbc_z:
.abf4	a9 e5		lda #$e5	                lda #$E5
.abf6	4c 88 ac	jmp $ac88	                jmp asm_common
.abf9					z_asm_sbc_z:
.abf9					xt_asm_sbc_zi:
.abf9	a9 f2		lda #$f2	                lda #$F2
.abfb	4c 88 ac	jmp $ac88	                jmp asm_common
.abfe					z_asm_sbc_zi:
.abfe					xt_asm_sbc_ziy:
.abfe	a9 f1		lda #$f1	                lda #$F1
.ac00	4c 88 ac	jmp $ac88	                jmp asm_common
.ac03					z_asm_sbc_ziy:
.ac03					xt_asm_sbc_zx:
.ac03	a9 f5		lda #$f5	                lda #$F5
.ac05	4c 88 ac	jmp $ac88	                jmp asm_common
.ac08					z_asm_sbc_zx:
.ac08					xt_asm_sbc_zxi:
.ac08	a9 e1		lda #$e1	                lda #$E1
.ac0a	80 7c		bra $ac88	                bra asm_common  ; <-- limit for BRA instead of JMP
.ac0c					z_asm_sbc_zxi:
.ac0c					xt_asm_sec:
.ac0c	a9 38		lda #$38	                lda #$38
.ac0e	80 78		bra $ac88	                bra asm_common
.ac10					z_asm_sec:
.ac10					xt_asm_sed:
.ac10	a9 f8		lda #$f8	                lda #$F8
.ac12	80 74		bra $ac88	                bra asm_common
.ac14					z_asm_sed:
.ac14					xt_asm_sei:
.ac14	a9 78		lda #$78	                lda #$78
.ac16	80 70		bra $ac88	                bra asm_common
.ac18					z_asm_sei:
.ac18					xt_asm_sta:
.ac18	a9 8d		lda #$8d	                lda #$8D
.ac1a	80 6c		bra $ac88	                bra asm_common
.ac1c					z_asm_sta:
.ac1c					xt_asm_sta_x:
.ac1c	a9 9d		lda #$9d	                lda #$9D
.ac1e	80 68		bra $ac88	                bra asm_common
.ac20					z_asm_sta_x:
.ac20					xt_asm_sta_y:
.ac20	a9 99		lda #$99	                lda #$99
.ac22	80 64		bra $ac88	                bra asm_common
.ac24					z_asm_sta_y:
.ac24					xt_asm_sta_z:
.ac24	a9 85		lda #$85	                lda #$85
.ac26	80 60		bra $ac88	                bra asm_common
.ac28					z_asm_sta_z:
.ac28					xt_asm_sta_zi:
.ac28	a9 92		lda #$92	                lda #$92
.ac2a	80 5c		bra $ac88	                bra asm_common
.ac2c					z_asm_sta_zi:
.ac2c					xt_asm_sta_ziy:
.ac2c	a9 91		lda #$91	                lda #$91
.ac2e	80 58		bra $ac88	                bra asm_common
.ac30					z_asm_sta_ziy:
.ac30					xt_asm_sta_zx:
.ac30	a9 95		lda #$95	                lda #$95
.ac32	80 54		bra $ac88	                bra asm_common
.ac34					z_asm_sta_zx:
.ac34					xt_asm_sta_zxi:
.ac34	a9 81		lda #$81	                lda #$81
.ac36	80 50		bra $ac88	                bra asm_common
.ac38					z_asm_sta_zxi:
.ac38					xt_asm_stx:
.ac38	a9 8e		lda #$8e	                lda #$8E
.ac3a	80 4c		bra $ac88	                bra asm_common
.ac3c					z_asm_stx:
.ac3c					xt_asm_stx_z:
.ac3c	a9 86		lda #$86	                lda #$86
.ac3e	80 48		bra $ac88	                bra asm_common
.ac40					z_asm_stx_z:
.ac40					xt_asm_stx_zy:
.ac40	a9 96		lda #$96	                lda #$96
.ac42	80 44		bra $ac88	                bra asm_common
.ac44					z_asm_stx_zy:
.ac44					xt_asm_sty:
.ac44	a9 8c		lda #$8c	                lda #$8C
.ac46	80 40		bra $ac88	                bra asm_common
.ac48					z_asm_sty:
.ac48					xt_asm_sty_z:
.ac48	a9 84		lda #$84	                lda #$84
.ac4a	80 3c		bra $ac88	                bra asm_common
.ac4c					z_asm_sty_z:
.ac4c					xt_asm_sty_zx:
.ac4c	a9 94		lda #$94	                lda #$94
.ac4e	80 38		bra $ac88	                bra asm_common
.ac50					z_asm_sty_zx:
.ac50					xt_asm_stz:
.ac50	a9 9c		lda #$9c	                lda #$9C
.ac52	80 34		bra $ac88	                bra asm_common
.ac54					z_asm_stz:
.ac54					xt_asm_stz_x:
.ac54	a9 9e		lda #$9e	                lda #$9E
.ac56	80 30		bra $ac88	                bra asm_common
.ac58					z_asm_stz_x:
.ac58					xt_asm_stz_z:
.ac58	a9 64		lda #$64	                lda #$64
.ac5a	80 2c		bra $ac88	                bra asm_common
.ac5c					z_asm_stz_z:
.ac5c					xt_asm_stz_zx:
.ac5c	a9 74		lda #$74	                lda #$74
.ac5e	80 28		bra $ac88	                bra asm_common
.ac60					z_asm_stz_zx:
.ac60					xt_asm_tax:
.ac60	a9 aa		lda #$aa	                lda #$AA
.ac62	80 24		bra $ac88	                bra asm_common
.ac64					z_asm_tax:
.ac64					xt_asm_tay:
.ac64	a9 a8		lda #$a8	                lda #$A8
.ac66	80 20		bra $ac88	                bra asm_common
.ac68					z_asm_tay:
.ac68					xt_asm_trb:
.ac68	a9 1c		lda #$1c	                lda #$1C
.ac6a	80 1c		bra $ac88	                bra asm_common
.ac6c					z_asm_trb:
.ac6c					xt_asm_trb_z:
.ac6c	a9 14		lda #$14	                lda #$14
.ac6e	80 18		bra $ac88	                bra asm_common
.ac70					z_asm_trb_z:
.ac70					xt_asm_tsb:
.ac70	a9 0c		lda #$0c	                lda #$0C
.ac72	80 14		bra $ac88	                bra asm_common
.ac74					z_asm_tsb:
.ac74					xt_asm_tsb_z:
.ac74	a9 04		lda #$04	                lda #$04
.ac76	80 10		bra $ac88	                bra asm_common
.ac78					z_asm_tsb_z:
.ac78					xt_asm_tsx:
.ac78	a9 ba		lda #$ba	                lda #$BA
.ac7a	80 0c		bra $ac88	                bra asm_common
.ac7c					z_asm_tsx:
.ac7c					xt_asm_txa:
.ac7c	a9 8a		lda #$8a	                lda #$8A
.ac7e	80 08		bra $ac88	                bra asm_common
.ac80					z_asm_txa:
.ac80					xt_asm_txs:
.ac80	a9 9a		lda #$9a	                lda #$9A
.ac82	80 04		bra $ac88	                bra asm_common
.ac84					z_asm_txs:
.ac84					xt_asm_tya:
.ac84	a9 98		lda #$98	                lda #$98
.ac86	80 00		bra $ac88	                bra asm_common
.ac88					z_asm_tya:
.ac88					asm_common:
.ac88	a8		tay		                tay
.ac89	20 03 d7	jsr $d703	                jsr cmpl_a
.ac8c	a9 f4		lda #$f4	                lda #<oc_index_table
.ac8e	85 26		sta $26		                sta tmp2
.ac90	a9 ae		lda #$ae	                lda #>oc_index_table
.ac92	85 27		sta $27		                sta tmp2+1
.ac94	98		tya		                tya             ; retrieve opcode
.ac95	0a		asl a		                asl             ; times two for offset
.ac96	90 02		bcc $ac9a	                bcc +
.ac98	e6 27		inc $27		                inc tmp2+1
.ac9a					+
.ac9a	a8		tay		                tay             ; use Y as the index
.ac9b	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac9d	85 28		sta $28		                sta tmp3
.ac9f	c8		iny		                iny
.aca0	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.aca2	85 29		sta $29		                sta tmp3+1
.aca4	b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.aca6	2a		rol a		                rol
.aca7	2a		rol a		                rol
.aca8	2a		rol a		                rol             ; Three times because we go through Carry
.aca9	29 03		and #$03	                and #%00000011
.acab	a8		tay		                tay
.acac	88		dey		                dey
.acad	f0 12		beq $acc1	                beq _done
.acaf	20 50 d8	jsr $d850	                jsr underflow_1
.acb2	b5 00		lda $00,x	                lda 0,x
.acb4	20 03 d7	jsr $d703	                jsr cmpl_a      ; does not use Y
.acb7	88		dey		                dey
.acb8	f0 05		beq $acbf	                beq _done_drop
.acba	b5 01		lda $01,x	                lda 1,x
.acbc	20 03 d7	jsr $d703	                jsr cmpl_a      ; Fall through to _done_drop
.acbf					_done_drop:
.acbf	e8		inx		                inx
.acc0	e8		inx		                inx             ; Fall through to _done
.acc1					_done:
.acc1	60		rts		                rts             ; Returns to original caller
.acc2					xt_asm_push_a:
.acc2	a0 00		ldy #$00	                ldy #0
.acc4					_loop:
.acc4	b9 d2 ac	lda $acd2,y	                lda asm_push_a_data,y
.acc7	c9 ff		cmp #$ff	                cmp #$FF
.acc9	f0 06		beq $acd1	                beq _done
.accb	20 03 d7	jsr $d703	                jsr cmpl_a      ; does not change Y
.acce	c8		iny		                iny
.accf	80 f3		bra $acc4	                bra _loop
.acd1					_done:
.acd1					z_asm_push_a:
.acd1	60		rts		                rts
.acd2					asm_push_a_data:
>acd2	ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>acd8	ff				        .byte $FF               ; terminator
.acd9					xt_asm_back_jump:
.acd9					z_asm_back_jump:
.acd9	60		rts		                rts
.acda					xt_asm_back_branch:
.acda	20 7e 91	jsr $917e	                jsr xt_here             ; ( addr-l addr-h )
.acdd	20 5c 95	jsr $955c	                jsr xt_minus            ; ( offset )
.ace0	3a		dec a		                dea
.ace1	3a		dec a		                dea
.ace2					z_asm_back_branch:
.ace2	60		rts		                rts
.ace3					assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.ace3					disassembler:
.ace3	20 6f 89	jsr $896f	                jsr xt_cr       ; ( addr u )
.ace6					_byte_loop:
.ace6	20 9f 98	jsr $989f	                jsr xt_over     ; ( addr u addr )
.ace9	20 3a a5	jsr $a53a	                jsr xt_u_dot    ; ( addr u )
.acec	20 2a a1	jsr $a12a	                jsr xt_space
.acef	a9 f4		lda #$f4	                lda #<oc_index_table
.acf1	85 26		sta $26		                sta tmp2
.acf3	a9 ae		lda #$ae	                lda #>oc_index_table
.acf5	85 27		sta $27		                sta tmp2+1
.acf7	a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.acf9	85 36		sta $36		                sta scratch     ; Save opcode
.acfb	0a		asl a		                asl             ; multiply by two for offset
.acfc	90 02		bcc $ad00	                bcc +
.acfe	e6 27		inc $27		                inc tmp2+1      ; we're on second page
.ad00					+
.ad00	a8		tay		                tay             ; use Y as the index
.ad01	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ad03	85 28		sta $28		                sta tmp3
.ad05	48		pha		                pha
.ad06	c8		iny		                iny
.ad07	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ad09	85 29		sta $29		                sta tmp3+1
.ad0b	48		pha		                pha
.ad0c	b2 28		lda ($28)	                lda (tmp3)
.ad0e	a8		tay		                tay                     ; save copy of lengths byte
.ad0f	10 3c		bpl $ad4d	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.ad11	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ad14	f6 04		inc $04,x	                inc 4,x
.ad16	d0 02		bne $ad1a	                bne +
.ad18	f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ad1a					+
.ad1a	b5 02		lda $02,x	                lda 2,x
.ad1c	d0 02		bne $ad20	                bne +
.ad1e	d6 03		dec $03,x	                dec 3,x
.ad20					+
.ad20	d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.ad22	a1 04		lda ($04,x)	                lda (4,x)
.ad24	95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.ad26	85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.ad28	98		tya		                tya                     ; retrieve copy of lengths byte
.ad29	2a		rol a		                rol                     ; shift bit 6 to bit 7
.ad2a	10 14		bpl $ad40	                bpl _print_operand
.ad2c	f6 04		inc $04,x	                inc 4,x
.ad2e	d0 02		bne $ad32	                bne +
.ad30	f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad32					+
.ad32	b5 02		lda $02,x	                lda 2,x
.ad34	d0 02		bne $ad38	                bne +
.ad36	d6 03		dec $03,x	                dec 3,x
.ad38					+
.ad38	d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad3a	a1 04		lda ($04,x)	                lda (4,x)
.ad3c	95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad3e	85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad40					_print_operand:
.ad40	ca		dex		                dex
.ad41	ca		dex		                dex
.ad42	a9 05		lda #$05	                lda #5
.ad44	95 00		sta $00,x	                sta 0,x
.ad46	74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad48	20 46 a5	jsr $a546	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad4b	80 0b		bra $ad58	                bra _print_mnemonic
.ad4d					_no_operand:
.ad4d	ca		dex		                dex
.ad4e	ca		dex		                dex
.ad4f	a9 05		lda #$05	                lda #5
.ad51	95 00		sta $00,x	                sta 0,x
.ad53	74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad55	20 30 a1	jsr $a130	                jsr xt_spaces           ; ( addr u )
.ad58					_print_mnemonic:
.ad58	20 2a a1	jsr $a12a	                jsr xt_space
.ad5b	ca		dex		                dex
.ad5c	ca		dex		                dex                     ; ( addr u ? )
.ad5d	68		pla		                pla                     ; MSB
.ad5e	95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad60	68		pla		                pla                     ; LSB
.ad61	95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad63	20 5b 89	jsr $895b	                jsr xt_count            ; ( addr u addr-o u-o )
.ad66	74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad68	b5 00		lda $00,x	                lda 0,x
.ad6a	29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad6c	95 00		sta $00,x	                sta 0,x
.ad6e	20 0f a5	jsr $a50f	                jsr xt_type             ; ( addr u )
.ad71	a5 36		lda $36		                lda scratch
.ad73	c9 20		cmp #$20	                cmp #$20
.ad75	d0 59		bne $add0	                bne _not_jsr
.ad77	ca		dex		                dex
.ad78	ca		dex		                dex
.ad79	a9 05		lda #$05	                lda #5
.ad7b	95 00		sta $00,x	                sta 0,x
.ad7d	74 01		stz $01,x	                stz 1,x
.ad7f	20 30 a1	jsr $a130	                jsr xt_spaces
.ad82	a9 a4		lda #$a4	                lda #<literal_runtime
.ad84	c5 37		cmp $37		                cmp scratch+1
.ad86	d0 0c		bne $ad94	                bne _not_literal
.ad88	a9 93		lda #$93	                lda #>literal_runtime
.ad8a	c5 38		cmp $38		                cmp scratch+2
.ad8c	d0 06		bne $ad94	                bne _not_literal
.ad8e	20 86 ae	jsr $ae86	                jsr disasm_literal
.ad91	4c fd ad	jmp $adfd	                jmp _printing_done
.ad94					_not_literal:
.ad94	a9 b5		lda #$b5	                lda #<sliteral_runtime
.ad96	c5 37		cmp $37		                cmp scratch+1
.ad98	d0 0c		bne $ada6	                bne _not_sliteral
.ad9a	a9 a0		lda #$a0	                lda #>sliteral_runtime
.ad9c	c5 38		cmp $38		                cmp scratch+2
.ad9e	d0 06		bne $ada6	                bne _not_sliteral
.ada0	20 43 ae	jsr $ae43	                jsr disasm_sliteral
.ada3	4c fd ad	jmp $adfd	                jmp _printing_done
.ada6					_not_sliteral:
.ada6	a9 20		lda #$20	                lda #<zero_branch_runtime
.ada8	c5 37		cmp $37		                cmp scratch+1
.adaa	d0 0c		bne $adb8	                bne _not_0branch
.adac	a9 92		lda #$92	                lda #>zero_branch_runtime
.adae	c5 38		cmp $38		                cmp scratch+2
.adb0	d0 06		bne $adb8	                bne _not_0branch
.adb2	20 7a ae	jsr $ae7a	                jsr disasm_0branch
.adb5	4c fd ad	jmp $adfd	                jmp _printing_done
.adb8					_not_0branch
.adb8	a9 e7		lda #$e7	                lda #<branch_runtime
.adba	c5 37		cmp $37		                cmp scratch+1
.adbc	d0 0c		bne $adca	                bne _not_branch
.adbe	a9 8d		lda #$8d	                lda #>branch_runtime
.adc0	c5 38		cmp $38		                cmp scratch+2
.adc2	d0 06		bne $adca	                bne _not_branch
.adc4	20 7f ae	jsr $ae7f	                jsr disasm_branch
.adc7	4c fd ad	jmp $adfd	                jmp _printing_done
.adca					_not_branch
.adca	20 a4 ae	jsr $aea4	                jsr disasm_jsr
.adcd	4c fd ad	jmp $adfd	                jmp _printing_done
.add0					_not_jsr:
.add0	c9 4c		cmp #$4c	                cmp #$4C
.add2	d0 29		bne $adfd	                bne _printing_done
.add4	a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.add6	85 39		sta $39		                sta scratch+3
.add8	a5 38		lda $38		                lda scratch+2
.adda	85 3a		sta $3a		                sta scratch+4
.addc	b2 39		lda ($39)	                lda (scratch+3)
.adde	c9 20		cmp #$20	                cmp #$20 ; check for JSR
.ade0	d0 1b		bne $adfd	                bne _printing_done
.ade2	e6 39		inc $39		                inc scratch+3
.ade4	d0 02		bne $ade8	                bne +
.ade6	e6 3a		inc $3a		                inc scratch+4
.ade8					+
.ade8	b2 39		lda ($39)	                lda (scratch+3)
.adea	c9 b5		cmp #$b5	                cmp #<sliteral_runtime
.adec	d0 0f		bne $adfd	                bne _printing_done
.adee	e6 39		inc $39		                inc scratch+3
.adf0	d0 02		bne $adf4	                bne +
.adf2	e6 3a		inc $3a		                inc scratch+4
.adf4					+
.adf4	b2 39		lda ($39)	                lda (scratch+3)
.adf6	c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.adf8	d0 03		bne $adfd	                bne _printing_done
.adfa	20 19 ae	jsr $ae19	                jsr disasm_sliteral_jump
.adfd					_printing_done:
.adfd	20 6f 89	jsr $896f	                jsr xt_cr
.ae00	f6 02		inc $02,x	                inc 2,x
.ae02	d0 02		bne $ae06	                bne +
.ae04	f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ae06					+
.ae06	20 1d 98	jsr $981d	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ae09	b5 00		lda $00,x	                lda 0,x                 ; All done?
.ae0b	15 01		ora $01,x	                ora 1,x
.ae0d	f0 07		beq $ae16	                beq _done
.ae0f	b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae11	30 03		bmi $ae16	                bmi _done
.ae13	4c e6 ac	jmp $ace6	                jmp _byte_loop          ; out of range for BRA
.ae16					_done:
.ae16	4c bc a3	jmp $a3bc	                jmp xt_two_drop         ; JSR/RTS
.ae19					disasm_sliteral_jump:
.ae19	20 ba a1	jsr $a1ba	                jsr xt_swap
.ae1c	ca		dex		                dex
.ae1d	ca		dex		                dex
.ae1e	a5 37		lda $37		                lda scratch+1
.ae20	95 00		sta $00,x	                sta 0,x
.ae22	a5 38		lda $38		                lda scratch+2
.ae24	95 01		sta $01,x	                sta 1,x
.ae26	20 ba a1	jsr $a1ba	                jsr xt_swap
.ae29	20 5c 95	jsr $955c	                jsr xt_minus
.ae2c	20 1d 98	jsr $981d	                jsr xt_one_minus
.ae2f	20 5c 95	jsr $955c	                jsr xt_minus
.ae32	ca		dex		                dex
.ae33	ca		dex		                dex
.ae34	a5 37		lda $37		                lda scratch+1
.ae36	95 00		sta $00,x	                sta 0,x
.ae38	a5 38		lda $38		                lda scratch+2
.ae3a	95 01		sta $01,x	                sta 1,x
.ae3c	20 1d 98	jsr $981d	                jsr xt_one_minus
.ae3f	20 ba a1	jsr $a1ba	                jsr xt_swap ; ( new_addr new_n )
.ae42	60		rts		                rts
.ae43					disasm_sliteral:
.ae43	a9 53		lda #$53	                lda #'S'
.ae45	20 02 8e	jsr $8e02	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae48	a9 0d		lda #$0d	                lda #str_disasm_lit     ; "LITERAL "
.ae4a	20 8c d8	jsr $d88c	                jsr print_string_no_lf
.ae4d	20 ba a1	jsr $a1ba	                jsr xt_swap             ; switch to (u addr)
.ae50	20 29 98	jsr $9829	                jsr xt_one_plus
.ae53	20 bb 8d	jsr $8dbb	                jsr xt_dup
.ae56	20 8c 8f	jsr $8f8c	                jsr xt_fetch
.ae59	20 3a a5	jsr $a53a	                jsr xt_u_dot            ; Print the address of the string
.ae5c	20 b3 a3	jsr $a3b3	                jsr xt_two
.ae5f	20 ef 99	jsr $99ef	                jsr xt_plus
.ae62	20 bb 8d	jsr $8dbb	                jsr xt_dup
.ae65	20 6e 9a	jsr $9a6e	                jsr xt_question         ; Print the length of the string
.ae68	20 29 98	jsr $9829	                jsr xt_one_plus
.ae6b	20 ba a1	jsr $a1ba	                jsr xt_swap            ; ( addr+4 u )
.ae6e	ca		dex		                dex
.ae6f	ca		dex		                dex
.ae70	a9 04		lda #$04	                lda #4
.ae72	95 00		sta $00,x	                sta 0,x
.ae74	74 01		stz $01,x	                stz 1,x
.ae76	20 5c 95	jsr $955c	                jsr xt_minus            ; ( addr+4 u-4 )
.ae79	60		rts		                rts
.ae7a					disasm_0branch:
.ae7a	a9 30		lda #$30	                lda #'0'
.ae7c	20 02 8e	jsr $8e02	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ae7f					disasm_branch:
.ae7f	a9 0f		lda #$0f	                lda #str_disasm_bra
.ae81	20 8c d8	jsr $d88c	                jsr print_string_no_lf ; "BRANCH "
.ae84	80 05		bra $ae8b	                bra disasm_print_literal
.ae86					disasm_literal:
.ae86	a9 0d		lda #$0d	                lda #str_disasm_lit
.ae88	20 8c d8	jsr $d88c	                jsr print_string_no_lf ; "LITERAL "
.ae8b					disasm_print_literal:
.ae8b	20 ba a1	jsr $a1ba	                jsr xt_swap ; switch to (u addr)
.ae8e	20 29 98	jsr $9829	                jsr xt_one_plus
.ae91	20 bb 8d	jsr $8dbb	                jsr xt_dup
.ae94	20 6e 9a	jsr $9a6e	                jsr xt_question ; Print the value at the adress
.ae97	20 29 98	jsr $9829	                jsr xt_one_plus
.ae9a	20 ba a1	jsr $a1ba	                jsr xt_swap ; (addr+2 u)
.ae9d	20 1d 98	jsr $981d	                jsr xt_one_minus
.aea0	20 1d 98	jsr $981d	                jsr xt_one_minus ; (addr+2 u-2)
.aea3	60		rts		                rts
.aea4					disasm_jsr:
.aea4	ca		dex		                dex
.aea5	ca		dex		                dex
.aea6	a5 37		lda $37		                lda scratch+1
.aea8	95 00		sta $00,x	                sta 0,x
.aeaa	a5 38		lda $38		                lda scratch+2
.aeac	95 01		sta $01,x	                sta 1,x
.aeae	20 84 92	jsr $9284	                jsr xt_int_to_name
.aeb1	b5 00		lda $00,x	                lda 0,x
.aeb3	15 01		ora $01,x	                ora 1,x
.aeb5	f0 07		beq $aebe	                beq _disasm_no_nt
.aeb7	20 0a 96	jsr $960a	                jsr xt_name_to_string
.aeba	20 0f a5	jsr $a50f	                jsr xt_type
.aebd	60		rts		                rts
.aebe					_disasm_no_nt:
.aebe	20 3a 8d	jsr $8d3a	                jsr xt_drop ; the 0 indicating no name token
.aec1	ca		dex		                dex
.aec2	ca		dex		                dex
.aec3	a5 37		lda $37		                lda scratch+1
.aec5	95 00		sta $00,x	                sta 0,x
.aec7	a5 38		lda $38		                lda scratch+2
.aec9	95 01		sta $01,x	                sta 1,x
.aecb	ca		dex		                dex
.aecc	ca		dex		                dex
.aecd	a9 50		lda #$50	                lda #<underflow_1
.aecf	95 00		sta $00,x	                sta 0,x
.aed1	a9 d8		lda #$d8	                lda #>underflow_1
.aed3	95 01		sta $01,x	                sta 1,x
.aed5	20 77 d7	jsr $d777	                jsr compare_16bit
.aed8	f0 02		beq $aedc	                beq _disasm_jsr_uflow_check_upper
.aeda	b0 14		bcs $aef0	                bcs _disasm_jsr_unknown
.aedc					_disasm_jsr_uflow_check_upper:
.aedc	a9 5f		lda #$5f	                lda #<underflow_4
.aede	95 00		sta $00,x	                sta 0,x
.aee0	a9 d8		lda #$d8	                lda #>underflow_4
.aee2	95 01		sta $01,x	                sta 1,x
.aee4	20 77 d7	jsr $d777	                jsr compare_16bit
.aee7	f0 02		beq $aeeb	                beq _disasm_jsr_soc
.aee9	90 05		bcc $aef0	                bcc _disasm_jsr_unknown
.aeeb					_disasm_jsr_soc:
.aeeb	a9 0e		lda #$0e	                lda #str_disasm_sdc
.aeed	20 8c d8	jsr $d88c	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.aef0					_disasm_jsr_unknown:
.aef0	20 bc a3	jsr $a3bc	                jsr xt_two_drop
.aef3	60		rts		                rts
.aef4					oc_index_table:
>aef4	f4 b0 f8 b0 8c b5 8c b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>aefc	00 b1 06 b1 0c b1 8c b5
>af04	12 b1 16 b1 1c b1 8c b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af0c	22 b1 26 b1 2a b1 2e b1
>af14	33 b1 37 b1 3f b1 8c b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af1c	46 b1 4c b1 53 b1 5a b1
>af24	61 b1 65 b1 6b b1 8c b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af2c	71 b1 75 b1 8c b5 7b b1
>af34	81 b1 85 b1 8c b5 8c b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af3c	8d b1 93 b1 99 b1 9f b1
>af44	a6 b1 aa b1 b0 b1 8c b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af4c	b6 b1 ba b1 bf b1 c3 b1
>af54	c8 b1 cc b1 d4 b1 8c b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af5c	db b1 e3 b1 ea b1 f1 b1
>af64	f8 b1 fc b1 02 b2 8c b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af6c	08 b2 0e b2 14 b2 2e b1
>af74	1f b2 23 b2 8c b5 8c b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>af7c	8c b5 2b b2 31 b2 37 b2
>af84	3e b2 42 b2 48 b2 8c b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>af8c	4e b2 52 b2 56 b2 5a b2
>af94	5f b2 63 b2 6b b2 8c b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>af9c	8c b5 72 b2 79 b2 80 b2
>afa4	87 b2 8b b2 91 b2 8c b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>afac	8c b5 8c b5 9b b2 a1 b2
>afb4	a6 b2 aa b2 8c b5 8c b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>afbc	b2 b2 b8 b2 be b2 c4 b2
>afc4	cb b2 cf b2 d5 b2 8c b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>afcc	db b2 e1 b2 e5 b2 e9 b2
>afd4	ee b2 f2 b2 fa b2 8c b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>afdc	01 b3 08 b3 0f b3 16 b3
>afe4	1d b3 21 b3 27 b3 8c b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>afec	2b b3 32 b3 38 b3 3e b3
>aff4	43 b3 47 b3 8c b5 8c b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>affc	4f b3 55 b3 5b b3 8c b5
>b004	61 b3 65 b3 6b b3 8c b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b00c	6f b3 73 b3 77 b3 7b b3
>b014	80 b3 84 b3 8c b3 8c b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b01c	93 b3 9a b3 a1 b3 a8 b3
>b024	af b3 b3 b3 b9 b3 8c b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b02c	bd b3 c1 b3 c7 b3 cd b3
>b034	d2 b3 d8 b3 e0 b3 8c b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b03c	e6 b3 ec b3 f2 b3 f8 b3
>b044	ff b3 03 b4 09 b4 8c b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b04c	0d b4 11 b4 15 b4 19 b4
>b054	1e b4 22 b4 2a b4 8c b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b05c	31 b4 38 b4 3f b4 46 b4
>b064	4d b4 51 b4 57 b4 8c b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b06c	5b b4 61 b4 67 b4 6d b4
>b074	72 b4 78 b4 8c b5 8c b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b07c	80 b4 86 b4 8c b4 92 b4
>b084	99 b4 9d b4 a3 b4 8c b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b08c	a7 b4 ab b4 af b4 b3 b4
>b094	b8 b4 bc b4 c4 b4 8c b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b09c	8c b5 cb b4 d2 b4 d9 b4
>b0a4	e0 b4 e4 b4 ea b4 8c b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0ac	8c b5 ee b4 f4 b4 fa b4
>b0b4	ff b4 05 b5 8c b5 8c b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b0bc	0d b5 13 b5 19 b5 1f b5
>b0c4	26 b5 2a b5 30 b5 8c b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b0cc	34 b5 38 b5 3c b5 40 b5
>b0d4	45 b5 49 b5 51 b5 8c b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b0dc	8c b5 58 b5 5f b5 66 b5
>b0e4	6d b5 71 b5 77 b5 8c b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b0ec	8c b5 7b b5 81 b5 87 b5
.b0f4					oc_table:
>b0f4	83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b0f8	87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b100	85 74 73 62 2e 7a		        oc04:   .text 2*64+5, "tsb.z"
>b106	85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b10c	85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b112	43 70 68 70				oc08:	.text 1*64+3, "php"
>b116	85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b11c	45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b122	c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b126	c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b12a	c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b12e	c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b133	83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b137	87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b13f	86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b146	85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b14c	86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b153	86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b15a	86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b161	43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b165	c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b16b	45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b171	c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b175	c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b17b	c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b181	c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b185	87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b18d	85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b193	85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b199	85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b19f	86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b1a6	43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b1aa	85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1b0	45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b1b6	c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b1ba	c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b1bf	c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b1c3	c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1c8	83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b1cc	87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b1d4	86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b1db	87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b1e3	86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b1ea	86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b1f1	86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b1f8	43 73 65 63				oc38:	.text 1*64+3, "sec"
>b1fc	c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b202	45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b208	c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b20e	c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b214	c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b21a	c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b21f	43 72 74 69				oc40:	.text 1*64+3, "rti"
>b223	87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b22b	85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b231	85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b237	86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b23e	43 70 68 61				oc48:	.text 1*64+3, "pha"
>b242	85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b248	45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b24e	c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b252	c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b256	c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b25a	c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b25f	83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b263	87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b26b	86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b272	86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b279	86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b280	86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b287	43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b28b	c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b291	43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b295	c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b29b	c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b2a1	c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b2a6	43 72 74 73				oc60:	.text 1*64+3, "rts"
>b2aa	87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b2b2	85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b2b8	85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b2be	85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b2c4	86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b2cb	43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b2cf	85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b2d5	45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b2db	c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b2e1	c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b2e5	c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b2e9	c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b2ee	83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b2f2	87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b2fa	86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b301	86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b308	86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b30f	86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b316	86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b31d	43 73 65 69				oc78:	.text 1*64+3, "sei"
>b321	c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b327	43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b32b	c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b332	c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b338	c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b33e	c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b343	83 62 72 61				oc80:	.text 2*64+3, "bra"
>b347	87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b34f	85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b355	85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b35b	85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b361	43 64 65 79				oc88:	.text 1*64+3, "dey"
>b365	85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b36b	43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b36f	c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b373	c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b377	c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b37b	c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b380	83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b384	87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b38c	86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b393	86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b39a	86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b3a1	86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b3a8	86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3af	43 74 79 61				oc98:	.text 1*64+3, "tya"
>b3b3	c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b3b9	43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b3bd	c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b3c1	c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3c7	c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b3cd	c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b3d2	85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b3d8	87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b3e0	85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b3e6	85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b3ec	85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b3f2	85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b3f8	86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b3ff	43 74 61 79				oca8:	.text 1*64+3, "tay"
>b403	85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b409	43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b40d	c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b411	c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b415	c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b419	c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b41e	83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b422	87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b42a	86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b431	86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b438	86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b43f	86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b446	86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b44d	43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b451	c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b457	43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b45b	c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b461	c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b467	c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b46d	c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b472	85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b478	87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b480	85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b486	85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b48c	85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b492	86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b499	43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b49d	85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b4a3	43 64 65 78				occa:	.text 1*64+3, "dex"
>b4a7	c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b4ab	c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4af	c3 64 65 63				occe:	.text 3*64+3, "dec"
>b4b3	c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b4b8	83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b4bc	87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b4c4	86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b4cb	86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b4d2	86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b4d9	86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b4e0	43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b4e4	c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b4ea	43 70 68 78				ocda:	.text 1*64+3, "phx"
>b4ee	c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b4f4	c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b4fa	c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b4ff	85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b505	87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b50d	85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b513	85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b519	85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b51f	86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b526	43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b52a	85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b530	43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b534	c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b538	c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b53c	c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b540	c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b545	83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b549	87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b551	86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b558	86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b55f	86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b566	86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b56d	43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b571	c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b577	43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b57b	c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b581	c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b587	c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b58c	01 3f					oc__:	.text 1, "?"
.b58e					disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=46					ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=48					ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=50					ed_flags = editor3  ; Flags used by ed, where
.b58e					ed6502:
.b58e	a5 18		lda $18		                lda base
.b590	85 33		sta $33		                sta editor3+1
.b592	a9 0a		lda #$0a	                lda #10
.b594	85 18		sta $18		                sta base
.b596	64 2e		stz $2e		                stz ed_head
.b598	64 2f		stz $2f		                stz ed_head+1
.b59a	64 30		stz $30		                stz ed_cur
.b59c	64 31		stz $31		                stz ed_cur+1
.b59e	64 32		stz $32		                stz ed_flags
.b5a0	20 b4 a7	jsr $a7b4	                jsr xt_zero
.b5a3	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; ( addr-t u-t )
.b5a6	20 6f 89	jsr $896f	                jsr xt_cr
.b5a9					ed_input_loop:
.b5a9	a9 81		lda #$81	                lda #%10000001
.b5ab	14 32		trb $32		                trb ed_flags
.b5ad	20 88 ba	jsr $ba88	                jsr ed_get_input
.b5b0	a5 0a		lda $0a		                lda ciblen
.b5b2	d0 1f		bne $b5d3	                bne _command_mode
.b5b4	ca		dex		                dex
.b5b5	ca		dex		                dex                     ; ( addr-t u-t ? )
.b5b6	a5 30		lda $30		                lda ed_cur
.b5b8	95 00		sta $00,x	                sta 0,x
.b5ba	a5 31		lda $31		                lda ed_cur+1
.b5bc	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b5be	a9 80		lda #$80	                lda #%10000000
.b5c0	04 32		tsb $32		                tsb ed_flags
.b5c2	20 29 98	jsr $9829	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b5c5	20 a4 ba	jsr $baa4	                jsr ed_is_valid_line
.b5c8	b0 03		bcs $b5cd	                bcs +
.b5ca	4c 78 ba	jmp $ba78	                jmp ed_error_1drop
.b5cd					+
.b5cd	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b5d0	4c 9e b6	jmp $b69e	                jmp _line_number_only_from_external
.b5d3					_command_mode:
.b5d3	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b5d6	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b5d9					_prefix_dot:
.b5d9	b2 08		lda ($08)	                lda (cib)
.b5db	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b5dd	d0 3a		bne $b619	                bne _prefix_dollar
.b5df	20 99 ba	jsr $ba99	                jsr ed_have_text
.b5e2	a5 30		lda $30		                lda ed_cur
.b5e4	95 02		sta $02,x	                sta 2,x
.b5e6	a5 31		lda $31		                lda ed_cur+1
.b5e8	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b5ea	a9 80		lda #$80	                lda #%10000000
.b5ec	04 32		tsb $32		                tsb ed_flags
.b5ee	a5 0a		lda $0a		                lda ciblen
.b5f0	3a		dec a		                dea                     ; sets Z if A was 1
.b5f1	d0 03		bne $b5f6	                bne +
.b5f3	4c 9e b6	jmp $b69e	                jmp _line_number_only_from_external
.b5f6					+
.b5f6	ca		dex		                dex
.b5f7	ca		dex		                dex
.b5f8	ca		dex		                dex
.b5f9	ca		dex		                dex
.b5fa	a5 08		lda $08		                lda cib
.b5fc	95 02		sta $02,x	                sta 2,x
.b5fe	a5 09		lda $09		                lda cib+1
.b600	95 03		sta $03,x	                sta 3,x
.b602	a5 0a		lda $0a		                lda ciblen
.b604	95 00		sta $00,x	                sta 0,x
.b606	a5 0b		lda $0b		                lda ciblen+1
.b608	95 01		sta $01,x	                sta 1,x
.b60a	20 1d 98	jsr $981d	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b60d	20 ba a1	jsr $a1ba	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b610	20 29 98	jsr $9829	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b613	20 ba a1	jsr $a1ba	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b616	4c f6 b6	jmp $b6f6	                jmp _check_for_para2
.b619					_prefix_dollar:
.b619	b2 08		lda ($08)	                lda (cib)
.b61b	c9 24		cmp #$24	                cmp #'$'
.b61d	d0 1c		bne $b63b	                bne _prefix_percent
.b61f	20 99 ba	jsr $ba99	                jsr ed_have_text
.b622	e8		inx		                inx
.b623	e8		inx		                inx                     ; ( addr-t u-t 0 )
.b624	20 c6 ba	jsr $bac6	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b627	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b62a	a9 80		lda #$80	                lda #%10000000
.b62c	04 32		tsb $32		                tsb ed_flags
.b62e	a5 0a		lda $0a		                lda ciblen
.b630	3a		dec a		                dea                     ; sets Z if A was 1
.b631	d0 03		bne $b636	                bne +
.b633	4c 9e b6	jmp $b69e	                jmp _line_number_only_from_external
.b636					+
.b636	a0 01		ldy #$01	                ldy #01
.b638	4c 72 b7	jmp $b772	                jmp _check_command
.b63b					_prefix_percent:
.b63b	b2 08		lda ($08)	                lda (cib)
.b63d	c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b63f	f0 04		beq $b645	                beq _whole_text
.b641	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b643	d0 17		bne $b65c	                bne _prefix_semicolon
.b645					_whole_text:
.b645	20 99 ba	jsr $ba99	                jsr ed_have_text
.b648	a9 01		lda #$01	                lda #01
.b64a	95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b64c	74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b64e					_semicolon_entry:
.b64e	e8		inx		                inx
.b64f	e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b650	20 c6 ba	jsr $bac6	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b653	a9 80		lda #$80	                lda #%10000000
.b655	04 32		tsb $32		                tsb ed_flags
.b657	a0 01		ldy #$01	                ldy #01
.b659	4c 72 b7	jmp $b772	                jmp _check_command
.b65c					_prefix_semicolon:
.b65c	b2 08		lda ($08)	                lda (cib)
.b65e	c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b660	d0 0d		bne $b66f	                bne _prefix_number
.b662	20 99 ba	jsr $ba99	                jsr ed_have_text
.b665	a5 30		lda $30		                lda ed_cur
.b667	95 02		sta $02,x	                sta 2,x
.b669	a5 31		lda $31		                lda ed_cur+1
.b66b	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b66d	80 df		bra $b64e	                bra _semicolon_entry
.b66f					_prefix_number:
.b66f	20 b4 a7	jsr $a7b4	                jsr xt_zero
.b672	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b675	ca		dex		                dex
.b676	ca		dex		                dex
.b677	ca		dex		                dex
.b678	ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b679	a5 08		lda $08		                lda cib
.b67b	95 02		sta $02,x	                sta 2,x
.b67d	a5 09		lda $09		                lda cib+1
.b67f	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b681	a5 0a		lda $0a		                lda ciblen
.b683	95 00		sta $00,x	                sta 0,x
.b685	a5 0b		lda $0b		                lda ciblen+1
.b687	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b689	20 c9 a2	jsr $a2c9	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b68c	b5 00		lda $00,x	                lda 0,x
.b68e	15 01		ora $01,x	                ora 1,x
.b690	d0 24		bne $b6b6	                bne _have_unconverted_chars
.b692	e8		inx		                inx
.b693	e8		inx		                inx
.b694	e8		inx		                inx
.b695	e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b696	20 8c 8a	jsr $8a8c	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b699	20 7a 96	jsr $967a	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b69c	e8		inx		                inx
.b69d	e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b69e					_line_number_only_from_external:
.b69e	20 ba a1	jsr $a1ba	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b6a1	20 a4 ba	jsr $baa4	                jsr ed_is_valid_line
.b6a4	b0 03		bcs $b6a9	                bcs +
.b6a6	4c 76 ba	jmp $ba76	                jmp ed_error_2drop
.b6a9					+
.b6a9	20 ba a1	jsr $a1ba	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6ac	20 33 bb	jsr $bb33	                jsr ed_para1_to_cur
.b6af	a9 80		lda #$80	                lda #%10000000
.b6b1	04 32		tsb $32		                tsb ed_flags
.b6b3	4c 51 b9	jmp $b951	                jmp ed_cmd_p_from_external
.b6b6					_have_unconverted_chars:
.b6b6	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b6b9	ca		dex		                dex
.b6ba	ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b6bb	a5 0a		lda $0a		                lda ciblen
.b6bd	95 00		sta $00,x	                sta 0,x
.b6bf	a5 0b		lda $0b		                lda ciblen+1
.b6c1	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b6c3	20 da 8e	jsr $8eda	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b6c6	b5 00		lda $00,x	                lda 0,x
.b6c8	15 01		ora $01,x	                ora 1,x
.b6ca	f0 0e		beq $b6da	                beq _no_command_yet
.b6cc	8a		txa		                txa
.b6cd	18		clc		                clc
.b6ce	69 0a		adc #$0a	                adc #10
.b6d0	aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b6d1	a9 80		lda #$80	                lda #%10000000
.b6d3	14 32		trb $32		                trb ed_flags
.b6d5	a0 00		ldy #$00	                ldy #00
.b6d7	4c 72 b7	jmp $b772	                jmp _check_command
.b6da					_no_command_yet:
.b6da	e8		inx		                inx
.b6db	e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b6dc	20 7c a3	jsr $a37c	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b6df	20 7a 96	jsr $967a	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b6e2	20 8c 8a	jsr $8a8c	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b6e5	b5 00		lda $00,x	                lda 0,x                 ; LSB
.b6e7	95 06		sta $06,x	                sta 6,x
.b6e9	b5 01		lda $01,x	                lda 1,x                 ; MSB
.b6eb	95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b6ed	e8		inx		                inx
.b6ee	e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b6ef	20 9e 9a	jsr $9a9e	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b6f2	a9 80		lda #$80	                lda #%10000000
.b6f4	04 32		tsb $32		                tsb ed_flags
.b6f6					_check_for_para2:
.b6f6	a1 02		lda ($02,x)	                lda (2,x)
.b6f8	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b6fa	f0 0d		beq $b709	                beq _got_comma
.b6fc	38		sec		                sec
.b6fd	a5 0a		lda $0a		                lda ciblen
.b6ff	f5 00		sbc $00,x	                sbc 0,x
.b701	a8		tay		                tay
.b702	e8		inx		                inx
.b703	e8		inx		                inx
.b704	e8		inx		                inx
.b705	e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b706	4c 72 b7	jmp $b772	                jmp _check_command
.b709					_got_comma:
.b709	f6 02		inc $02,x	                inc 2,x
.b70b	d0 02		bne $b70f	                bne +
.b70d	f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b70f					+
.b70f	b5 01		lda $01,x	                lda 1,x
.b711	f0 02		beq $b715	                beq +
.b713	d6 01		dec $01,x	                dec 1,x
.b715					+
.b715	d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b717	a1 02		lda ($02,x)	                lda (2,x)
.b719	c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b71b	d0 14		bne $b731	                bne _para2_not_dollar
.b71d	38		sec		                sec
.b71e	a5 0a		lda $0a		                lda ciblen
.b720	f5 02		sbc $02,x	                sbc 2,x
.b722	a8		tay		                tay
.b723	c8		iny		                iny
.b724	5a		phy		                phy
.b725	8a		txa		                txa
.b726	18		clc		                clc
.b727	69 06		adc #$06	                adc #06
.b729	aa		tax		                tax                     ; ( addr-t u-t para1 )
.b72a	20 c6 ba	jsr $bac6	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b72d	7a		ply		                ply
.b72e	4c 72 b7	jmp $b772	                jmp _check_command
.b731					_para2_not_dollar:
.b731	20 7c a3	jsr $a37c	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b734	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b737	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b73a	20 63 9b	jsr $9b63	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b73d	20 9e 9a	jsr $9a9e	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b740	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b743	20 7c a3	jsr $a37c	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b746	20 c9 a2	jsr $a2c9	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b749	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b74c	20 9e 9a	jsr $9a9e	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b74f	20 da 8e	jsr $8eda	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b752	b5 00		lda $00,x	                lda 0,x
.b754	15 01		ora $01,x	                ora 1,x
.b756	f0 08		beq $b760	                beq _second_number
.b758	8a		txa		                txa
.b759	18		clc		                clc
.b75a	69 0c		adc #$0c	                adc #12
.b75c	aa		tax		                tax                     ; back to ( addr-t u-t )
.b75d	4c 7a ba	jmp $ba7a	                jmp ed_error
.b760					_second_number:
.b760	e8		inx		                inx
.b761	e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b762	38		sec		                sec
.b763	a5 0a		lda $0a		                lda ciblen
.b765	f5 00		sbc $00,x	                sbc 0,x
.b767	48		pha		                pha
.b768	20 bc a3	jsr $a3bc	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b76b	20 8c 8a	jsr $8a8c	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b76e	20 4e 96	jsr $964e	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b771	7a		ply		                ply
.b772					_check_command:
.b772	24 32		bit $32		                bit ed_flags
.b774	30 08		bmi $b77e	                bmi _check_command_have_arg
.b776	a5 30		lda $30		                lda ed_cur
.b778	95 02		sta $02,x	                sta 2,x
.b77a	a5 31		lda $31		                lda ed_cur+1
.b77c	95 03		sta $03,x	                sta 3,x
.b77e					_check_command_have_arg:
.b77e	b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b780	85 24		sta $24		                sta tmp1
.b782	da		phx		                phx
.b783	a2 00		ldx #$00	                ldx #00
.b785					_cmd_loop:
.b785	bd 5e bb	lda $bb5e,x	                lda ed_cmd_list,x
.b788	f0 07		beq $b791	                beq _illegal_command    ; zero marks end of list
.b78a	c5 24		cmp $24		                cmp tmp1
.b78c	f0 07		beq $b795	                beq _found_cmd
.b78e	e8		inx		                inx
.b78f	80 f4		bra $b785	                bra _cmd_loop
.b791					_illegal_command:
.b791	fa		plx		                plx
.b792	4c 76 ba	jmp $ba76	                jmp ed_error_2drop
.b795					_found_cmd:
.b795	8a		txa		                txa
.b796	0a		asl a		                asl
.b797	aa		tax		                tax                     ; X * 2 for table
.b798	7c 69 bb	jmp ($bb69,x)	                jmp (ed_cmd_table,x)
.b79b					ed_next_command:
.b79b	e8		inx		                inx
.b79c	e8		inx		                inx
.b79d	e8		inx		                inx
.b79e	e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b79f					_next_command_empty:
.b79f	4c a9 b5	jmp $b5a9	                jmp ed_input_loop
.b7a2					ed_all_done:
.b7a2	64 0a		stz $0a		                stz ciblen
.b7a4	64 0b		stz $0b		                stz ciblen+1
.b7a6	20 bc a3	jsr $a3bc	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b7a9	a5 33		lda $33		                lda editor3+1
.b7ab	85 18		sta $18		                sta base
.b7ad	60		rts		                rts
.b7ae					ed_cmd_a:
.b7ae	fa		plx		                plx
.b7af	e8		inx		                inx
.b7b0	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7b1					ed_entry_cmd_i:
.b7b1					ed_cmd_a_have_para:
.b7b1	20 fc ba	jsr $bafc	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b7b4	20 6f 89	jsr $896f	                jsr xt_cr
.b7b7					_next_string_loop:
.b7b7	20 88 ba	jsr $ba88	                jsr ed_get_input
.b7ba	b2 08		lda ($08)	                lda (cib)
.b7bc	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b7be	d0 16		bne $b7d6	                bne _add_line
.b7c0	a4 0a		ldy $0a		                ldy ciblen
.b7c2	c0 01		cpy #$01	                cpy #01
.b7c4	d0 10		bne $b7d6	                bne _add_line
.b7c6	a4 0b		ldy $0b		                ldy ciblen+1
.b7c8	d0 0c		bne $b7d6	                bne _add_line
.b7ca	e8		inx		                inx
.b7cb	e8		inx		                inx
.b7cc	a9 40		lda #$40	                lda #%01000000
.b7ce	04 32		tsb $32		                tsb ed_flags
.b7d0	20 6f 89	jsr $896f	                jsr xt_cr
.b7d3	4c a9 b5	jmp $b5a9	                jmp ed_input_loop
.b7d6					_add_line:
.b7d6	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b7d9	20 7e 91	jsr $917e	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b7dc	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b7df	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b7e2	20 7a 87	jsr $877a	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b7e5	20 99 a3	jsr $a399	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b7e8	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b7eb	20 99 a1	jsr $a199	                jsr xt_store            ; ! ( addr-t u-t here )
.b7ee	20 7e 91	jsr $917e	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b7f1	a5 00		lda $00		                lda cp
.b7f3	18		clc		                clc
.b7f4	69 04		adc #$04	                adc #04
.b7f6	85 00		sta $00		                sta cp
.b7f8	90 02		bcc $b7fc	                bcc +
.b7fa	e6 01		inc $01		                inc cp+1
.b7fc					+
.b7fc	e6 30		inc $30		                inc ed_cur
.b7fe	d0 02		bne $b802	                bne +
.b800	e6 31		inc $31		                inc ed_cur+1
.b802					+
.b802	20 7e 91	jsr $917e	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b805	20 bb 8d	jsr $8dbb	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b808	ca		dex		                dex
.b809	ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b80a	a5 08		lda $08		                lda cib
.b80c	95 00		sta $00,x	                sta 0,x
.b80e	a5 09		lda $09		                lda cib+1
.b810	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b812	20 ba a1	jsr $a1ba	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b815	ca		dex		                dex
.b816	ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b817	a5 0a		lda $0a		                lda ciblen
.b819	95 00		sta $00,x	                sta 0,x
.b81b	a5 0b		lda $0b		                lda ciblen+1
.b81d	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b81f	20 ce 95	jsr $95ce	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b822	18		clc		                clc
.b823	a5 00		lda $00		                lda cp
.b825	65 0a		adc $0a		                adc ciblen
.b827	85 00		sta $00		                sta cp
.b829	90 06		bcc $b831	                bcc +
.b82b	a5 01		lda $01		                lda cp+1
.b82d	65 0b		adc $0b		                adc ciblen+1
.b82f	85 01		sta $01		                sta cp+1
.b831					+
.b831	20 9f 98	jsr $989f	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b834	20 99 a1	jsr $a199	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b837	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+
.b83a	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b83d	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b840	a5 0a		lda $0a		                lda ciblen
.b842	95 02		sta $02,x	                sta 2,x
.b844	a5 0b		lda $0b		                lda ciblen+1
.b846	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b848	20 99 a1	jsr $a199	                jsr xt_store            ; ! ( addr-t u-t here )
.b84b	20 6f 89	jsr $896f	                jsr xt_cr
.b84e	4c b7 b7	jmp $b7b7	                jmp _next_string_loop
.b851					ed_cmd_d:
.b851	fa		plx		                plx
.b852	20 99 ba	jsr $ba99	                jsr ed_have_text
.b855	20 ee ba	jsr $baee	                jsr ed_no_line_zero
.b858	b5 00		lda $00,x	                lda 0,x
.b85a	15 01		ora $01,x	                ora 1,x
.b85c	d0 08		bne $b866	                bne +
.b85e	20 9f 98	jsr $989f	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b861	20 a3 b8	jsr $b8a3	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b864	80 33		bra $b899	                bra _cmd_d_done
.b866					+
.b866	20 a4 ba	jsr $baa4	                jsr ed_is_valid_line      ; result is in C flag
.b869	b0 03		bcs $b86e	                bcs _cmd_d_loop
.b86b	4c 76 ba	jmp $ba76	                jmp ed_error_2drop
.b86e					_cmd_d_loop:
.b86e	20 c4 a3	jsr $a3c4	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b871	20 69 91	jsr $9169	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b874	b5 00		lda $00,x	                lda 0,x
.b876	15 01		ora $01,x	                ora 1,x
.b878	d0 0d		bne $b887	                bne _cmd_d_done_with_flag
.b87a	e8		inx		                inx
.b87b	e8		inx		                inx                     ; Get rid of the flag from >
.b87c	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b87f	20 a3 b8	jsr $b8a3	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b882	20 1d 98	jsr $981d	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b885	80 e7		bra $b86e	                bra _cmd_d_loop
.b887					_cmd_d_done_with_flag:
.b887	e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b888	e8		inx		                inx
.b889	b5 02		lda $02,x	                lda 2,x
.b88b	d0 02		bne $b88f	                bne +
.b88d	d6 03		dec $03,x	                dec 3,x
.b88f					+
.b88f	d6 02		dec $02,x	                dec 2,x
.b891	b5 02		lda $02,x	                lda 2,x
.b893	85 30		sta $30		                sta ed_cur
.b895	b5 03		lda $03,x	                lda 3,x
.b897	85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b899					_cmd_d_done:
.b899	a9 40		lda #$40	                lda #%01000000
.b89b	04 32		tsb $32		                tsb ed_flags
.b89d	20 6f 89	jsr $896f	                jsr xt_cr
.b8a0	4c 9b b7	jmp $b79b	                jmp ed_next_command
.b8a3					_cmd_d_common:
.b8a3	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b8a6	20 fc ba	jsr $bafc	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b8a9	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8ac	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8af	20 1d 98	jsr $981d	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b8b2	20 fc ba	jsr $bafc	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b8b5	20 99 a1	jsr $a199	                jsr xt_store            ; ! ( addr-t u-t )
.b8b8	60		rts		                rts
.b8b9					ed_cmd_equ:
.b8b9	fa		plx		                plx
.b8ba	a5 2e		lda $2e		                lda ed_head
.b8bc	05 2f		ora $2f		                ora ed_head+1
.b8be	d0 08		bne $b8c8	                bne _cmd_equ_have_text
.b8c0	ca		dex		                dex
.b8c1	ca		dex		                dex
.b8c2	74 00		stz $00,x	                stz 0,x
.b8c4	74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b8c6	80 21		bra $b8e9	                bra _cmd_equ_done
.b8c8					_cmd_equ_have_text:
.b8c8	20 ee ba	jsr $baee	                jsr ed_no_line_zero
.b8cb	24 32		bit $32		                bit ed_flags
.b8cd	30 0c		bmi $b8db	                bmi _cmd_equ_have_para
.b8cf	ca		dex		                dex
.b8d0	ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b8d1	a5 30		lda $30		                lda ed_cur
.b8d3	95 00		sta $00,x	                sta 0,x
.b8d5	a5 31		lda $31		                lda ed_cur+1
.b8d7	95 01		sta $01,x	                sta 1,x
.b8d9	80 0e		bra $b8e9	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b8db					_cmd_equ_have_para:
.b8db	b5 00		lda $00,x	                lda 0,x
.b8dd	15 01		ora $01,x	                ora 1,x
.b8df	d0 05		bne $b8e6	                bne _cmd_equ_two_paras
.b8e1	20 9f 98	jsr $989f	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b8e4	80 03		bra $b8e9	                bra _cmd_equ_done
.b8e6					_cmd_equ_two_paras:
.b8e6	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b8e9					_cmd_equ_done:
.b8e9	20 6f 89	jsr $896f	                jsr xt_cr               ; number goes on new line
.b8ec	20 3a a5	jsr $a53a	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b8ef	20 6f 89	jsr $896f	                jsr xt_cr
.b8f2	4c 9b b7	jmp $b79b	                jmp ed_next_command
.b8f5					ed_cmd_f:
.b8f5	fa		plx		                plx
.b8f6	24 32		bit $32		                bit ed_flags
.b8f8	30 17		bmi $b911	                bmi _cmd_f_have_para
.b8fa	20 6f 89	jsr $896f	                jsr xt_cr
.b8fd	20 7c a3	jsr $a37c	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b900	20 63 9b	jsr $9b63	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b903	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b906	20 3a a5	jsr $a53a	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b909	20 7a 96	jsr $967a	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b90c	20 9e 9a	jsr $9a9e	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b90f	80 11		bra $b922	                bra _cmd_f_done
.b911					_cmd_f_have_para:
.b911	20 9f 98	jsr $989f	                jsr xt_over
.b914	20 6f 89	jsr $896f	                jsr xt_cr
.b917	20 3a a5	jsr $a53a	                jsr xt_u_dot
.b91a	b5 02		lda $02,x	                lda 2,x
.b91c	95 06		sta $06,x	                sta 6,x
.b91e	b5 03		lda $03,x	                lda 3,x
.b920	95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b922					_cmd_f_done:
.b922	20 6f 89	jsr $896f	                jsr xt_cr
.b925	4c 9b b7	jmp $b79b	                jmp ed_next_command
.b928					ed_cmd_i:
.b928	fa		plx		                plx
.b929	e8		inx		                inx
.b92a	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b92b	24 32		bit $32		                bit ed_flags
.b92d	30 08		bmi $b937	                bmi _cmd_i_have_para
.b92f	a5 30		lda $30		                lda ed_cur
.b931	95 00		sta $00,x	                sta 0,x
.b933	a5 31		lda $31		                lda ed_cur+1
.b935	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b937					_cmd_i_have_para:
.b937	b5 00		lda $00,x	                lda 0,x
.b939	15 01		ora $01,x	                ora 1,x
.b93b	f0 09		beq $b946	                beq _cmd_i_done
.b93d	20 1d 98	jsr $981d	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b940	20 b4 a7	jsr $a7b4	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b943	20 24 95	jsr $9524	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b946					_cmd_i_done:
.b946	4c b1 b7	jmp $b7b1	                jmp ed_entry_cmd_i
.b949					ed_cmd_n:
.b949	fa		plx		                plx
.b94a	a9 01		lda #$01	                lda #%00000001
.b94c	04 32		tsb $32		                tsb ed_flags
.b94e	80 05		bra $b955	                bra ed_cmd_p_entry_for_cmd_n
.b950					ed_cmd_p:
.b950	fa		plx		                plx
.b951					ed_cmd_p_from_external:
.b951	a9 01		lda #$01	                lda #%00000001
.b953	14 32		trb $32		                trb ed_flags
.b955					ed_cmd_p_entry_for_cmd_n:
.b955	20 99 ba	jsr $ba99	                jsr ed_have_text
.b958	20 ee ba	jsr $baee	                jsr ed_no_line_zero
.b95b	20 6f 89	jsr $896f	                jsr xt_cr
.b95e	b5 00		lda $00,x	                lda 0,x
.b960	15 01		ora $01,x	                ora 1,x
.b962	d0 10		bne $b974	                bne _cmd_p_loop
.b964	b5 02		lda $02,x	                lda 2,x
.b966	85 30		sta $30		                sta ed_cur
.b968	b5 03		lda $03,x	                lda 3,x
.b96a	85 31		sta $31		                sta ed_cur+1
.b96c	20 9f 98	jsr $989f	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b96f	20 9d b9	jsr $b99d	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b972	80 26		bra $b99a	                bra _cmd_p_all_done
.b974					_cmd_p_loop:
.b974	20 c4 a3	jsr $a3c4	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b977	20 69 91	jsr $9169	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b97a	b5 00		lda $00,x	                lda 0,x
.b97c	15 01		ora $01,x	                ora 1,x
.b97e	d0 10		bne $b990	                bne _cmd_p_done
.b980	e8		inx		                inx
.b981	e8		inx		                inx                     ; Get rid of the flag from >
.b982	20 9f 98	jsr $989f	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b985	20 9d b9	jsr $b99d	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b988	f6 02		inc $02,x	                inc 2,x
.b98a	d0 02		bne $b98e	                bne +
.b98c	f6 03		inc $03,x	                inc 3,x
.b98e					+
.b98e	80 e4		bra $b974	                bra _cmd_p_loop
.b990					_cmd_p_done:
.b990	e8		inx		                inx
.b991	e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b992	b5 00		lda $00,x	                lda 0,x
.b994	85 30		sta $30		                sta ed_cur
.b996	b5 01		lda $01,x	                lda 1,x
.b998	85 31		sta $31		                sta ed_cur+1
.b99a					_cmd_p_all_done:
.b99a	4c 9b b7	jmp $b79b	                jmp ed_next_command
.b99d					_cmd_p_common:
.b99d	a5 32		lda $32		                lda ed_flags
.b99f	4a		lsr a		                lsr                     ; bit 0 now in carry
.b9a0	90 0b		bcc $b9ad	                bcc _cmd_p_common_no_num
.b9a2	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b9a5	20 3a a5	jsr $a53a	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b9a8	a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b9aa	20 02 8e	jsr $8e02	                jsr emit_a
.b9ad					_cmd_p_common_no_num:
.b9ad	20 fc ba	jsr $bafc	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9b0	20 3c bb	jsr $bb3c	                jsr ed_print_addr
.b9b3	60		rts		                rts
.b9b4					ed_cmd_q:
.b9b4	fa		plx		                plx
.b9b5	24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b9b7	50 03		bvc $b9bc	                bvc +
.b9b9	4c 76 ba	jmp $ba76	                jmp ed_error_2drop
.b9bc					+
.b9bc	4c a2 b7	jmp $b7a2	                jmp ed_all_done            ; can't fall thru because of PLX
.b9bf					ed_cmd_qq:
.b9bf	fa		plx		                plx
.b9c0	4c a2 b7	jmp $b7a2	                jmp ed_all_done
.b9c3					ed_cmd_w:
.b9c3	fa		plx		                plx
.b9c4	20 99 ba	jsr $ba99	                jsr ed_have_text
.b9c7	24 32		bit $32		                bit ed_flags
.b9c9	30 13		bmi $b9de	                bmi _cmd_w_have_para
.b9cb	b5 06		lda $06,x	                lda 6,x
.b9cd	15 07		ora $07,x	                ora 7,x
.b9cf	d0 03		bne $b9d4	                bne +
.b9d1	4c 76 ba	jmp $ba76	                jmp ed_error_2drop
.b9d4					+
.b9d4	b5 06		lda $06,x	                lda 6,x
.b9d6	95 02		sta $02,x	                sta 2,x
.b9d8	b5 07		lda $07,x	                lda 7,x
.b9da	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b9dc	80 08		bra $b9e6	                bra _cmd_w_para_ready
.b9de					_cmd_w_have_para:
.b9de	b5 02		lda $02,x	                lda 2,x
.b9e0	95 06		sta $06,x	                sta 6,x
.b9e2	b5 03		lda $03,x	                lda 3,x
.b9e4	95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b9e6					_cmd_w_para_ready:
.b9e6	a9 2e		lda #$2e	                lda #<ed_head
.b9e8	95 00		sta $00,x	                sta 0,x
.b9ea	a9 00		lda #$00	                lda #>ed_head
.b9ec	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.b9ee	20 9f 98	jsr $989f	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.b9f1	20 7c a3	jsr $a37c	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.b9f4					_cmd_w_loop:
.b9f4	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.b9f7	b5 00		lda $00,x	                lda 0,x
.b9f9	15 01		ora $01,x	                ora 1,x
.b9fb	f0 55		beq $ba52	                beq _cmd_w_eol
.b9fd	20 c4 a3	jsr $a3c4	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ba00	20 ae a4	jsr $a4ae	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ba03	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ba06	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ba09	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba0c	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba0f	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba12	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba15	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba18	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba1b	20 7a 96	jsr $967a	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba1e	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba21	20 63 9b	jsr $9b63	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba24	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba27	20 7c a3	jsr $a37c	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba2a	20 ce 95	jsr $95ce	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba2d	20 9e 9a	jsr $9a9e	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba30	20 34 a4	jsr $a434	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba33	20 7a 96	jsr $967a	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba36	20 ef 99	jsr $99ef	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba39	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba3c	ca		dex		                dex
.ba3d	ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba3e	a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba40	95 00		sta $00,x	                sta 0,x
.ba42	74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba44	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba47	20 99 a1	jsr $a199	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba4a	20 29 98	jsr $9829	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba4d	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba50	80 a2		bra $b9f4	                bra _cmd_w_loop
.ba52					_cmd_w_eol:
.ba52	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba55	20 9e 9a	jsr $9a9e	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba58	20 5c 95	jsr $955c	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba5b	b5 00		lda $00,x	                lda 0,x
.ba5d	95 04		sta $04,x	                sta 4,x
.ba5f	b5 01		lda $01,x	                lda 1,x
.ba61	95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba63	20 6f 89	jsr $896f	                jsr xt_cr
.ba66	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba69	20 3a a5	jsr $a53a	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba6c	20 6f 89	jsr $896f	                jsr xt_cr
.ba6f	a9 40		lda #$40	                lda #%01000000
.ba71	14 32		trb $32		                trb ed_flags
.ba73	4c 9b b7	jmp $b79b	                jmp ed_next_command
.ba76					ed_error_2drop:
.ba76	e8		inx		                inx
.ba77	e8		inx		                inx                     ; drop through to _error_1drop
.ba78					ed_error_1drop:
.ba78	e8		inx		                inx
.ba79	e8		inx		                inx                     ; drop through to _error
.ba7a					ed_error:
.ba7a	20 6f 89	jsr $896f	                jsr xt_cr
.ba7d	a9 3f		lda #$3f	                lda #'?'
.ba7f	20 02 8e	jsr $8e02	                jsr emit_a
.ba82	20 6f 89	jsr $896f	                jsr xt_cr
.ba85	4c a9 b5	jmp $b5a9	                jmp ed_input_loop
.ba88					ed_get_input:
.ba88	20 04 9b	jsr $9b04	                jsr xt_refill           ;  ( addr-t u-t f )
.ba8b	b5 00		lda $00,x	                lda 0,x
.ba8d	15 01		ora $01,x	                ora 1,x
.ba8f	d0 05		bne $ba96	                bne +
.ba91	7a		ply		                ply
.ba92	7a		ply		                ply
.ba93	4c 78 ba	jmp $ba78	                jmp ed_error_1drop
.ba96					+
.ba96	e8		inx		                inx
.ba97	e8		inx		                inx
.ba98	60		rts		                rts
.ba99					ed_have_text:
.ba99	a5 2e		lda $2e		                lda ed_head
.ba9b	05 2f		ora $2f		                ora ed_head+1
.ba9d	d0 04		bne $baa3	                bne +
.ba9f	7a		ply		                ply
.baa0	7a		ply		                ply
.baa1	80 d7		bra $ba7a	                bra ed_error
.baa3					+
.baa3	60		rts		                rts
.baa4					ed_is_valid_line:
.baa4	38		sec		                sec                             ; default is legal line number
.baa5	b5 00		lda $00,x	                lda 0,x
.baa7	15 01		ora $01,x	                ora 1,x
.baa9	f0 19		beq $bac4	                beq _is_valid_line_nope_zero    ; ( n )
.baab	20 bb 8d	jsr $8dbb	                jsr xt_dup                      ; DUP ( n n )
.baae	20 c6 ba	jsr $bac6	                jsr ed_last_line                  ; ( n n last )
.bab1	20 ba a1	jsr $a1ba	                jsr xt_swap                     ; SWAP ( n last n )
.bab4	20 74 93	jsr $9374	                jsr xt_less_than                ; < ( n f )
.bab7	b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.bab9	15 01		ora $01,x	                ora 1,x
.babb	d0 05		bne $bac2	                bne _is_valid_line_too_small
.babd	e8		inx		                inx
.babe	e8		inx		                inx                     ; DROP flag ( n )
.babf	38		sec		                sec                     ; Who knows what's happened to C by now
.bac0	80 03		bra $bac5	                bra _is_valid_line_done ; only one exit from this routine
.bac2					_is_valid_line_too_small:
.bac2	e8		inx		                inx
.bac3	e8		inx		                inx                     ; drop through to _is_valid_line_zero
.bac4					_is_valid_line_nope_zero:
.bac4	18		clc		                clc                     ; drop through to _is_valid_line_done
.bac5					_is_valid_line_done:
.bac5	60		rts		                rts
.bac6					ed_last_line:
.bac6	64 24		stz $24		                stz tmp1
.bac8	64 25		stz $25		                stz tmp1+1
.baca	ca		dex		                dex
.bacb	ca		dex		                dex                     ; ( ? )
.bacc	a9 2e		lda #$2e	                lda #<ed_head
.bace	95 00		sta $00,x	                sta 0,x
.bad0	a9 00		lda #$00	                lda #>ed_head
.bad2	95 01		sta $01,x	                sta 1,x                 ; ( addr )
.bad4					_last_line_loop:
.bad4	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; ( addr | 0 )
.bad7	b5 00		lda $00,x	                lda 0,x
.bad9	15 01		ora $01,x	                ora 1,x
.badb	f0 08		beq $bae5	                beq _last_line_done
.badd	e6 24		inc $24		                inc tmp1
.badf	d0 02		bne $bae3	                bne +
.bae1	e6 25		inc $25		                inc tmp1+1
.bae3					+
.bae3	80 ef		bra $bad4	                bra _last_line_loop
.bae5					_last_line_done:
.bae5	a5 24		lda $24		                lda tmp1
.bae7	95 00		sta $00,x	                sta 0,x
.bae9	a5 25		lda $25		                lda tmp1+1
.baeb	95 01		sta $01,x	                sta 1,x                 ; ( u )
.baed	60		rts		                rts
.baee					ed_no_line_zero:
.baee	b5 02		lda $02,x	                lda 2,x
.baf0	15 03		ora $03,x	                ora 3,x
.baf2	d0 07		bne $bafb	                bne _no_line_zero_done
.baf4	24 32		bit $32		                bit ed_flags
.baf6	10 03		bpl $bafb	                bpl _no_line_zero_done
.baf8	4c 76 ba	jmp $ba76	                jmp ed_error_2drop
.bafb					_no_line_zero_done:
.bafb	60		rts		                rts
.bafc					ed_num_to_addr:
.bafc	ca		dex		                dex
.bafd	ca		dex		                dex                     ; ( u ? )
.bafe	a9 2e		lda #$2e	                lda #<ed_head
.bb00	95 00		sta $00,x	                sta 0,x
.bb02	a9 00		lda #$00	                lda #>ed_head
.bb04	95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bb06	b5 02		lda $02,x	                lda 2,x
.bb08	15 03		ora $03,x	                ora 3,x
.bb0a	d0 05		bne $bb11	                bne _num_to_addr_loop
.bb0c	20 4e 96	jsr $964e	                jsr xt_nip              ; ( addr-h )
.bb0f	80 21		bra $bb32	                bra _num_to_addr_done
.bb11					_num_to_addr_loop:
.bb11	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; @ ( u addr1 )
.bb14	b5 00		lda $00,x	                lda 0,x
.bb16	15 01		ora $01,x	                ora 1,x
.bb18	d0 05		bne $bb1f	                bne +
.bb1a	20 4e 96	jsr $964e	                jsr xt_nip              ; NIP ( addr1 )
.bb1d	80 13		bra $bb32	                bra _num_to_addr_done
.bb1f					+
.bb1f	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( addr1 u )
.bb22	20 1d 98	jsr $981d	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb25	b5 00		lda $00,x	                lda 0,x
.bb27	15 01		ora $01,x	                ora 1,x
.bb29	f0 05		beq $bb30	                beq _num_to_addr_finished
.bb2b	20 ba a1	jsr $a1ba	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb2e	80 e1		bra $bb11	                bra _num_to_addr_loop
.bb30					_num_to_addr_finished:
.bb30	e8		inx		                inx
.bb31	e8		inx		                inx                     ; ( addr )
.bb32					_num_to_addr_done:
.bb32	60		rts		                rts
.bb33					ed_para1_to_cur:
.bb33	b5 02		lda $02,x	                lda 2,x
.bb35	85 30		sta $30		                sta ed_cur
.bb37	b5 03		lda $03,x	                lda 3,x
.bb39	85 31		sta $31		                sta ed_cur+1
.bb3b	60		rts		                rts
.bb3c					ed_print_addr:
.bb3c	20 29 98	jsr $9829	                jsr xt_one_plus
.bb3f	20 29 98	jsr $9829	                jsr xt_one_plus         ; ( addr+2 )
.bb42	20 bb 8d	jsr $8dbb	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb45	20 29 98	jsr $9829	                jsr xt_one_plus
.bb48	20 29 98	jsr $9829	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb4b	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; ( addr+2 u-s )
.bb4e	20 ba a1	jsr $a1ba	                jsr xt_swap             ; ( u-s addr+2 )
.bb51	20 8c 8f	jsr $8f8c	                jsr xt_fetch            ; ( u-s addr-s )
.bb54	20 ba a1	jsr $a1ba	                jsr xt_swap             ; ( addr-s u-s )
.bb57	20 0f a5	jsr $a50f	                jsr xt_type
.bb5a	20 6f 89	jsr $896f	                jsr xt_cr
.bb5d	60		rts		                rts
>bb5e	61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb66	71 51 00
.bb69					ed_cmd_table:
>bb69	ae b7 f5 b8 28 b9 51 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bb71	50 b9 49 b9
>bb75	b9 b8 c3 b9 b4 b9 bf b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bb7d					ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bb7d					forth_words_start:
>bb7d	20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb85	61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb95	74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bba5	20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bbb5	20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bbc5	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bbd5	2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bbe5	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bbf5	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bc05	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bc15	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc25	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc35	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc45	65 78 69 74 29 20 63 72 20
.bc4e					forth_words_end:
.bc4e					user_words_start:
>bc4e	20 20				.binary "user_words.asc"
.bc50					user_words_end:

;******  Processing file: platform/../headers.asm

.bc50					dictionary_start:
.bc50					nt_drop:
>bc50	04 10				        .byte 4, UF
>bc52	5c bc 3a 8d 3f 8d		        .word nt_dup, xt_drop, z_drop
>bc58	64 72 6f 70			        .text "drop"
.bc5c					nt_dup:
>bc5c	03 10				        .byte 3, UF
>bc5e	67 bc bb 8d c8 8d		        .word nt_swap, xt_dup, z_dup
>bc64	64 75 70			        .text "dup"
.bc67					nt_swap:
>bc67	04 10				        .byte 4, UF
>bc69	73 bc ba a1 cd a1		        .word nt_store, xt_swap, z_swap
>bc6f	73 77 61 70			        .text "swap"
.bc73					nt_store:
>bc73	01 10				        .byte 1, UF
>bc75	7c bc 99 a1 ae a1		        .word nt_fetch, xt_store, z_store
>bc7b	21				        .text "!"
.bc7c					nt_fetch:
>bc7c	01 10				        .byte 1, UF
>bc7e	85 bc 8c 8f 9e 8f		        .word nt_over, xt_fetch, z_fetch
>bc84	40				        .text "@"
.bc85					nt_over:
>bc85	04 10				        .byte 4, UF
>bc87	91 bc 9f 98 ac 98		        .word nt_to_r, xt_over, z_over
>bc8d	6f 76 65 72			        .text "over"
.bc91					nt_to_r:
>bc91	02 11				        .byte 2, CO+UF ; native is special case
>bc93	9b bc 7c a3 8f a3		        .word nt_r_from, xt_to_r, z_to_r
>bc99	3e 72				        .text ">r"
.bc9b					nt_r_from:
>bc9b	02 01				        .byte 2, CO    ; native is special case
>bc9d	a5 bc 9e 9a ae 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bca3	72 3e				        .text "r>"
.bca5					nt_r_fetch:
>bca5	02 01				        .byte 2, CO    ; native is special case
>bca7	af bc 89 9a 9d 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bcad	72 40				        .text "r@"
.bcaf					nt_nip:
>bcaf	03 10				        .byte 3, UF
>bcb1	ba bc 4e 96 5b 96		        .word nt_rot, xt_nip, z_nip
>bcb7	6e 69 70			        .text "nip"
.bcba					nt_rot:
>bcba	03 10				        .byte 3, UF
>bcbc	c5 bc 63 9b 7e 9b		        .word nt_not_rote, xt_rot, z_rot
>bcc2	72 6f 74			        .text "rot"
.bcc5					nt_not_rote:
>bcc5	04 10				        .byte 4, UF
>bcc7	d1 bc 7a 96 95 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bccd	2d 72 6f 74			        .text "-rot"
.bcd1					nt_tuck:
>bcd1	04 10				        .byte 4, UF
>bcd3	dd bc 99 a3 b2 a3		        .word nt_comma, xt_tuck, z_tuck
>bcd9	74 75 63 6b			        .text "tuck"
.bcdd					nt_comma:
>bcdd	01 10				        .byte 1, UF
>bcdf	e6 bc 7a 87 93 87		        .word nt_c_fetch, xt_comma, z_comma
>bce5	2c				        .text ","
.bce6					nt_c_fetch:
>bce6	02 10				        .byte 2, UF
>bce8	f0 bc 17 86 20 86		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bcee	63 40				        .text "c@"
.bcf0					nt_c_store:
>bcf0	02 10				        .byte 2, UF
>bcf2	fa bc 21 86 2c 86		        .word nt_plus_store, xt_c_store, z_c_store
>bcf8	63 21				        .text "c!"
.bcfa					nt_plus_store:
>bcfa	02 10				        .byte 2, UF
>bcfc	04 bd 02 9a 21 9a		        .word nt_execute, xt_plus_store, z_plus_store
>bd02	2b 21				        .text "+!"
.bd04					nt_execute:
>bd04	07 10				        .byte 7, UF
>bd06	13 bd 49 8f 4f 8f		        .word nt_emit, xt_execute, z_execute
>bd0c	65 78 65 63 75 74 65		        .text "execute"
.bd13					nt_emit:
>bd13	04 18				        .byte 4, NN+UF
>bd15	1f bd fb 8d 05 8e		        .word nt_type, xt_emit, z_emit
>bd1b	65 6d 69 74			        .text "emit"
.bd1f					nt_type:
>bd1f	04 10				        .byte 4, UF
>bd21	2b bd 0f a5 39 a5		        .word nt_dot, xt_type, z_type
>bd27	74 79 70 65			        .text "type"
.bd2b					nt_dot:
>bd2b	01 10				        .byte 1, UF
>bd2d	34 bd 42 8c 63 8c		        .word nt_u_dot, xt_dot, z_dot
>bd33	2e				        .text "."
.bd34					nt_u_dot:
>bd34	02 10				        .byte 2, UF
>bd36	3e bd 3a a5 45 a5		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd3c	75 2e				        .text "u."
.bd3e					nt_u_dot_r:
>bd3e	03 10				        .byte 3, UF
>bd40	49 bd 46 a5 67 a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd46	75 2e 72			        .text "u.r"
.bd49					nt_dot_r:
>bd49	02 10				        .byte 2, UF
>bd4b	53 bd 7e 8c ab 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd51	2e 72				        .text ".r"
.bd53					nt_d_dot:
>bd53	02 10				        .byte 2, UF
>bd55	5d bd f0 8c 0e 8d		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd5b	64 2e				        .text "d."
.bd5d					nt_d_dot_r:
>bd5d	03 10				        .byte 3, UF
>bd5f	68 bd 0f 8d 39 8d		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd65	64 2e 72			        .text "d.r"
.bd68					nt_ud_dot:
>bd68	03 10				        .byte 3, UF
>bd6a	73 bd 94 a5 a6 a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd70	75 64 2e			        .text "ud."
.bd73					nt_ud_dot_r:
>bd73	04 10				        .byte 4, UF
>bd75	7f bd a7 a5 c5 a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd7b	75 64 2e 72			        .text "ud.r"
.bd7f					nt_question:
>bd7f	01 00				        .byte 1, 0
>bd81	88 bd 6e 9a 74 9a		        .word nt_false, xt_question, z_question
>bd87	3f				        .text "?"
.bd88					nt_false:
>bd88	05 00				        .byte 5, 0
>bd8a	95 bd 85 8f 8b 8f		        .word nt_true, xt_false, z_false
>bd90	66 61 6c 73 65			        .text "false"
.bd95					nt_true:
>bd95	04 00				        .byte 4, 0
>bd97	a1 bd 90 a3 98 a3		        .word nt_space, xt_true, z_true
>bd9d	74 72 75 65			        .text "true"
.bda1					nt_space:
>bda1	05 00				        .byte 5, 0
>bda3	ae bd 2a a1 2f a1		        .word nt_zero, xt_space, z_space
>bda9	73 70 61 63 65			        .text "space"
.bdae					nt_zero:
>bdae	01 00				        .byte 1, 0
>bdb0	b7 bd b4 a7 ba a7		        .word nt_one, xt_zero, z_zero
>bdb6	30				        .text "0"
.bdb7					nt_one:
>bdb7	01 00				        .byte 1, 0
>bdb9	c0 bd 14 98 1c 98		        .word nt_two, xt_one, z_one
>bdbf	31				        .text "1"
.bdc0					nt_two:
>bdc0	01 00				        .byte 1, 0
>bdc2	c9 bd b3 a3 bb a3		        .word nt_two_dup, xt_two, z_two
>bdc8	32				        .text "2"
.bdc9					nt_two_dup:
>bdc9	04 10				        .byte 4, UF
>bdcb	d5 bd c4 a3 db a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bdd1	32 64 75 70			        .text "2dup"
.bdd5					nt_question_dup:
>bdd5	04 10				        .byte 4, UF
>bdd7	e1 bd 75 9a 88 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bddd	3f 64 75 70			        .text "?dup"
.bde1					nt_plus:
>bde1	01 10				        .byte 1, UF
>bde3	ea bd ef 99 01 9a		        .word nt_minus, xt_plus, z_plus
>bde9	2b				        .text "+"
.bdea					nt_minus:
>bdea	01 10				        .byte 1, UF
>bdec	f3 bd 5c 95 6e 95		        .word nt_one_minus, xt_minus, z_minus
>bdf2	2d				        .text "-"
.bdf3					nt_one_minus:
>bdf3	02 10				        .byte 2, UF
>bdf5	fd bd 1d 98 28 98		        .word nt_one_plus, xt_one_minus, z_one_minus
>bdfb	31 2d				        .text "1-"
.bdfd					nt_one_plus:
>bdfd	02 10				        .byte 2, UF
>bdff	07 be 29 98 32 98		        .word nt_two_star, xt_one_plus, z_one_plus
>be05	31 2b				        .text "1+"
.be07					nt_two_star:
>be07	02 10				        .byte 2, UF
>be09	11 be 5c a4 63 a4		        .word nt_two_slash, xt_two_star, z_two_star
>be0f	32 2a				        .text "2*"
.be11					nt_two_slash:
>be11	02 10				        .byte 2, UF
>be13	1b be 51 a4 5b a4		        .word nt_abs, xt_two_slash, z_two_slash
>be19	32 2f				        .text "2/"
.be1b					nt_abs:
>be1b	03 10				        .byte 3, UF
>be1d	26 be 23 81 37 81		        .word nt_dabs, xt_abs, z_abs
>be23	61 62 73			        .text "abs"
.be26					nt_dabs:
>be26	04 10				        .byte 4, UF
>be28	32 be 92 8a b0 8a		        .word nt_and, xt_dabs, z_dabs
>be2e	64 61 62 73			        .text "dabs"
.be32					nt_and:
>be32	03 10				        .byte 3, UF
>be34	3d be 28 83 39 83		        .word nt_or, xt_and, z_and
>be3a	61 6e 64			        .text "and"
.be3d					nt_or:
>be3d	02 10				        .byte 2, UF
>be3f	47 be 3f 98 50 98		        .word nt_xor, xt_or, z_or
>be45	6f 72				        .text "or"
.be47					nt_xor:
>be47	03 10				        .byte 3, UF
>be49	52 be a2 a7 b3 a7		        .word nt_rshift, xt_xor, z_xor
>be4f	78 6f 72			        .text "xor"
.be52					nt_rshift:
>be52	06 10				        .byte 6, UF
>be54	60 be 7f 9b 92 9b		        .word nt_lshift, xt_rshift, z_rshift
>be5a	72 73 68 69 66 74		        .text "rshift"
.be60					nt_lshift:
>be60	06 10				        .byte 6, UF
>be62	6e be 86 94 99 94		        .word nt_pick, xt_lshift, z_lshift
>be68	6c 73 68 69 66 74		        .text "lshift"
.be6e					nt_pick:
>be6e	04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be70	7a be de 99 ee 99		        .word nt_char, xt_pick, z_pick
>be76	70 69 63 6b			        .text "pick"
.be7a					nt_char:
>be7a	04 00				        .byte 4, 0
>be7c	86 be 3d 86 53 86		        .word nt_bracket_char, xt_char, z_char
>be82	63 68 61 72			        .text "char"
.be86					nt_bracket_char:
>be86	06 05				        .byte 6, CO+IM
>be88	94 be a3 85 a9 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>be8e	5b 63 68 61 72 5d		        .text "[char]"
.be94					nt_char_plus:
>be94	05 00				        .byte 5, 0
>be96	a1 be 29 98 32 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>be9c	63 68 61 72 2b			        .text "char+"
.bea1					nt_chars:
>bea1	05 12				        .byte 5, AN+UF   ; deleted during compile
>bea3	ae be 54 86 57 86		        .word nt_cells, xt_chars, z_chars
>bea9	63 68 61 72 73			        .text "chars"
.beae					nt_cells:
>beae	05 00				        .byte 5, 0
>beb0	bb be 5c a4 63 a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>beb6	63 65 6c 6c 73			        .text "cells"
.bebb					nt_cell_plus:
>bebb	05 10				        .byte 5, UF
>bebd	c8 be 2d 86 3c 86		        .word nt_here, xt_cell_plus, z_cell_plus
>bec3	63 65 6c 6c 2b			        .text "cell+"
.bec8					nt_here:
>bec8	04 00				        .byte 4, 0
>beca	d4 be 7e 91 88 91		        .word nt_equal, xt_here, z_here
>bed0	68 65 72 65			        .text "here"
.bed4					nt_equal:
>bed4	01 10				        .byte 1, UF
>bed6	dd be da 8e f5 8e		        .word nt_not_equals, xt_equal, z_equal
>bedc	3d				        .text "="
.bedd					nt_not_equals:
>bedd	02 10				        .byte 2, UF
>bedf	e7 be 5c 96 79 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bee5	3c 3e				        .text "<>"
.bee7					nt_less_than:
>bee7	01 10				        .byte 1, UF
>bee9	f0 be 74 93 88 93		        .word nt_u_less_than, xt_less_than, z_less_than
>beef	3c				        .text "<"
.bef0					nt_u_less_than:
>bef0	02 10				        .byte 2, UF
>bef2	fa be 7e a5 93 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bef8	75 3c				        .text "u<"
.befa					nt_u_greater_than:
>befa	02 10				        .byte 2, UF
>befc	04 bf 68 a5 7d a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bf02	75 3e				        .text "u>"
.bf04					nt_greater_than:
>bf04	01 10				        .byte 1, UF
>bf06	0d bf 69 91 7d 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bf0c	3e				        .text ">"
.bf0d					nt_zero_equal:
>bf0d	02 10				        .byte 2, UF
>bf0f	17 bf bb a7 ce a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bf15	30 3d				        .text "0="
.bf17					nt_zero_unequal:
>bf17	03 10				        .byte 3, UF
>bf19	22 bf f3 a7 04 a8		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bf1f	30 3c 3e			        .text "0<>"
.bf22					nt_zero_greater:
>bf22	02 10				        .byte 2, UF
>bf24	2c bf cf a7 e2 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bf2a	30 3e				        .text "0>"
.bf2c					nt_zero_less:
>bf2c	02 10				        .byte 2, UF
>bf2e	36 bf e3 a7 f2 a7		        .word nt_min, xt_zero_less, z_zero_less
>bf34	30 3c				        .text "0<"
.bf36					nt_min:
>bf36	03 10				        .byte 3, UF
>bf38	41 bf 40 95 5b 95		        .word nt_max, xt_min, z_min
>bf3e	6d 69 6e			        .text "min"
.bf41					nt_max:
>bf41	03 10				        .byte 3, UF
>bf43	4c bf 24 95 3f 95		        .word nt_two_drop, xt_max, z_max
>bf49	6d 61 78			        .text "max"
.bf4c					nt_two_drop:
>bf4c	05 10				        .byte 5, UF
>bf4e	59 bf bc a3 c3 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf54	32 64 72 6f 70			        .text "2drop"
.bf59					nt_two_swap:
>bf59	05 10				        .byte 5, UF
>bf5b	66 bf 8a a4 ad a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf61	32 73 77 61 70			        .text "2swap"
.bf66					nt_two_over:
>bf66	05 10				        .byte 5, UF
>bf68	73 bf fe a3 15 a4		        .word nt_two_store, xt_two_over, z_two_over
>bf6e	32 6f 76 65 72			        .text "2over"
.bf73					nt_two_store:
>bf73	02 10				        .byte 2, UF
>bf75	7d bf 64 a4 89 a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bf7b	32 21				        .text "2!"
.bf7d					nt_two_fetch:
>bf7d	02 10				        .byte 2, UF
>bf7f	87 bf dc a3 fd a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bf85	32 40				        .text "2@"
.bf87					nt_two_variable:
>bf87	09 00				        .byte 9, 0
>bf89	98 bf 00 a5 0e a5		        .word nt_two_constant, xt_two_variable, z_two_variable
>bf8f	32 76 61 72 69 61 62 6c		        .text "2variable"
>bf97	65
.bf98					nt_two_constant:
>bf98	09 10				        .byte 9, UF
>bf9a	a9 bf ce a4 f2 a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bfa0	32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bfa8	74
.bfa9					nt_two_literal:
>bfa9	08 14				        .byte 8, UF+IM
>bfab	b9 bf f3 a4 ff a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bfb1	32 6c 69 74 65 72 61 6c		        .text "2literal"
.bfb9					nt_two_r_fetch:
>bfb9	03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bfbb	c4 bf 16 a4 33 a4		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bfc1	32 72 40			        .text "2r@"
.bfc4					nt_two_r_from:
>bfc4	03 01				        .byte 3, CO             ; native is special case
>bfc6	cf bf 34 a4 50 a4		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bfcc	32 72 3e			        .text "2r>"
.bfcf					nt_two_to_r:
>bfcf	03 11				        .byte 3, CO+UF          ; native is special case
>bfd1	da bf ae a4 cd a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>bfd7	32 3e 72			        .text "2>r"
.bfda					nt_invert:
>bfda	06 10				        .byte 6, UF
>bfdc	e8 bf f7 92 06 93		        .word nt_negate, xt_invert, z_invert
>bfe2	69 6e 76 65 72 74		        .text "invert"
.bfe8					nt_negate:
>bfe8	06 10				        .byte 6, UF
>bfea	f6 bf 2f 96 3f 96		        .word nt_dnegate, xt_negate, z_negate
>bff0	6e 65 67 61 74 65		        .text "negate"
.bff6					nt_dnegate:
>bff6	07 10				        .byte 7, UF
>bff8	05 c0 4d 8b 67 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>bffe	64 6e 65 67 61 74 65		        .text "dnegate"
.c005					nt_c_comma:
>c005	02 10				        .byte 2, UF
>c007	0f c0 0c 86 16 86		        .word nt_bounds, xt_c_comma, z_c_comma
>c00d	63 2c				        .text "c,"
.c00f					nt_bounds:
>c00f	06 10				        .byte 6, UF
>c011	1d c0 8a 85 a2 85		        .word nt_spaces, xt_bounds, z_bounds
>c017	62 6f 75 6e 64 73		        .text "bounds"
.c01d					nt_spaces:
>c01d	06 10				        .byte 6, UF
>c01f	2b c0 30 a1 6b a1		        .word nt_bl, xt_spaces, z_spaces
>c025	73 70 61 63 65 73		        .text "spaces"
.c02b					nt_bl:
>c02b	02 00				        .byte 2, 0
>c02d	35 c0 a6 83 ae 83		        .word nt_minus_trailing, xt_bl, z_bl
>c033	62 6c				        .text "bl"
.c035					nt_minus_trailing:
>c035	09 10				        .byte 9, UF
>c037	46 c0 88 95 c4 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c03d	2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c045	67
.c046					nt_minus_leading:
>c046	08 10				        .byte 8, UF
>c048	56 c0 6f 95 87 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c04e	2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c056					nt_slash_string:
>c056	07 10				        .byte 7, UF
>c058	65 c0 25 a0 44 a0		        .word nt_refill, xt_slash_string, z_slash_string
>c05e	2f 73 74 72 69 6e 67		        .text "/string"
.c065					nt_refill:
>c065	06 00				        .byte 6, 0
>c067	73 c0 04 9b 45 9b		        .word nt_accept, xt_refill, z_refill
>c06d	72 65 66 69 6c 6c		        .text "refill"
.c073					nt_accept:
>c073	06 18				        .byte 6, UF+NN
>c075	81 c0 38 81 30 82		        .word nt_input_to_r, xt_accept, z_accept
>c07b	61 63 63 65 70 74		        .text "accept"
.c081					nt_input_to_r:
>c081	07 08				        .byte 7, NN
>c083	90 c0 6e 92 83 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c089	69 6e 70 75 74 3e 72		        .text "input>r"
.c090					nt_r_to_input:
>c090	07 08				        .byte 7, NN
>c092	9f c0 af 9a c6 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c098	72 3e 69 6e 70 75 74		        .text "r>input"
.c09f					nt_unused:
>c09f	06 00				        .byte 6, 0
>c0a1	ad c0 60 a6 6f a6		        .word nt_depth, xt_unused, z_unused
>c0a7	75 6e 75 73 65 64		        .text "unused"
.c0ad					nt_depth:
>c0ad	05 00				        .byte 5, 0
>c0af	ba c0 02 8b 10 8b		        .word nt_key, xt_depth, z_depth
>c0b5	64 65 70 74 68			        .text "depth"
.c0ba					nt_key:
>c0ba	03 00				        .byte 3, 0
>c0bc	c5 c0 3a 93 43 93		        .word nt_allot, xt_key, z_key
>c0c2	6b 65 79			        .text "key"
.c0c5					nt_allot:
>c0c5	05 10				        .byte 5, UF
>c0c7	d2 c0 95 82 fd 82		        .word nt_create, xt_allot, z_allot
>c0cd	61 6c 6c 6f 74			        .text "allot"
.c0d2					nt_create:
>c0d2	06 00				        .byte 6, 0
>c0d4	e0 c0 75 89 49 8a		        .word nt_does, xt_create, z_create
>c0da	63 72 65 61 74 65		        .text "create"
.c0e0					nt_does:
>c0e0	05 05				        .byte 5, CO+IM
>c0e2	ed c0 01 8c 0f 8c		        .word nt_variable, xt_does, z_does
>c0e8	64 6f 65 73 3e			        .text "does>"
.c0ed					nt_variable:
>c0ed	08 00				        .byte 8, 0
>c0ef	fd c0 84 a6 9c a6		        .word nt_constant, xt_variable, z_variable
>c0f5	76 61 72 69 61 62 6c 65		        .text "variable"
.c0fd					nt_constant:
>c0fd	08 10				        .byte 8, UF
>c0ff	0d c1 1d 89 5a 89		        .word nt_value, xt_constant, z_constant
>c105	63 6f 6e 73 74 61 6e 74		        .text "constant"
.c10d					nt_value:
>c10d	05 10				        .byte 5, UF
>c10f	1a c1 1d 89 5a 89		        .word nt_to, xt_constant, z_constant
>c115	76 61 6c 75 65			        .text "value"
.c11a					nt_to:
>c11a	02 0c				        .byte 2, NN+IM
>c11c	24 c1 3d a2 98 a2		        .word nt_s_to_d, xt_to, z_to
>c122	74 6f				        .text "to"
.c124					nt_s_to_d:
>c124	03 10				        .byte 3, UF
>c126	2f c1 b8 9e c9 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c12c	73 3e 64			        .text "s>d"
.c12f					nt_d_to_s:
>c12f	03 10				        .byte 3, UF
>c131	3a c1 8c 8a 91 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c137	64 3e 73			        .text "d>s"
.c13a					nt_d_minus:
>c13a	02 10				        .byte 2, UF
>c13c	44 c1 4a 8a 6a 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c142	64 2d				        .text "d-"
.c144					nt_d_plus:
>c144	02 10				        .byte 2, UF
>c146	4e c1 6b 8a 8b 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c14c	64 2b				        .text "d+"
.c14e					nt_erase:
>c14e	05 00				        .byte 5, 0      ; underflow checked by FILL
>c150	5b c1 00 8f 48 8f		        .word nt_blank, xt_erase, z_erase
>c156	65 72 61 73 65			        .text "erase"
.c15b					nt_blank:
>c15b	05 00				        .byte 5, 0     ; underflow checked by FILL
>c15d	68 c1 f6 8e 48 8f		        .word nt_fill, xt_blank, z_blank
>c163	62 6c 61 6e 6b			        .text "blank"
.c168					nt_fill:
>c168	04 10				        .byte 4, UF
>c16a	74 c1 06 8f 48 8f		        .word nt_find_name, xt_fill, z_fill
>c170	66 69 6c 6c			        .text "fill"
.c174					nt_find_name:
>c174	09 10				        .byte 9, UF
>c176	85 c1 e7 8f 92 90		        .word nt_tick, xt_find_name, z_find_name
>c17c	66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c184	65
.c185					nt_tick:
>c185	01 00				        .byte 1, 0
>c187	8e c1 1d a2 3c a2		        .word nt_bracket_tick, xt_tick, z_tick
>c18d	27				        .text "'"
.c18e					nt_bracket_tick:
>c18e	03 05				        .byte 3, CO+IM
>c190	99 c1 aa 85 b0 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c196	5b 27 5d			        .text "[']"
.c199					nt_name_to_int:
>c199	08 10				        .byte 8, UF
>c19b	a9 c1 ed 95 09 96		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c1a1	6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c1a9					nt_int_to_name:
>c1a9	08 10				        .byte 8, UF
>c1ab	b9 c1 84 92 f6 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c1b1	69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c1b9					nt_name_to_string:
>c1b9	0b 10				        .byte 11, UF
>c1bb	cc c1 0a 96 23 96		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c1c1	6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1c9	69 6e 67
.c1cc					nt_to_body:
>c1cc	05 10				        .byte 5, UF
>c1ce	d9 c1 99 a2 bd a2		        .word nt_defer, xt_to_body, z_to_body
>c1d4	3e 62 6f 64 79			        .text ">body"
.c1d9					nt_defer:
>c1d9	05 00				        .byte 5, 0
>c1db	e6 c1 b8 8a ea 8a		        .word nt_latestxt, xt_defer, z_defer
>c1e1	64 65 66 65 72			        .text "defer"
.c1e6					nt_latestxt:
>c1e6	08 00				        .byte 8, 0
>c1e8	f6 c1 55 93 5b 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c1ee	6c 61 74 65 73 74 78 74		        .text "latestxt"
.c1f6					nt_latestnt:
>c1f6	08 00				        .byte 8, 0
>c1f8	06 c2 47 93 54 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c1fe	6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c206					nt_parse_name:
>c206	0a 08				        .byte 10, NN
>c208	18 c2 eb 98 dd 99		        .word nt_parse, xt_parse_name, z_parse_name
>c20e	70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c216	6d 65
.c218					nt_parse:
>c218	05 10				        .byte 5, UF
>c21a	25 c2 46 99 dd 99		        .word nt_execute_parsing, xt_parse, z_parse
>c220	70 61 72 73 65			        .text "parse"
.c225					nt_execute_parsing:
>c225	0f 10				        .byte 15, UF
>c227	3c c2 5d 8f 83 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c22d	65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c235	70 61 72 73 69 6e 67
.c23c					nt_source:
>c23c	06 00				        .byte 6, 0
>c23e	4a c2 0a a1 1e a1		        .word nt_source_id, xt_source, z_source
>c244	73 6f 75 72 63 65		        .text "source"
.c24a					nt_source_id:
>c24a	09 00				        .byte 9, 0
>c24c	5b c2 1f a1 29 a1		        .word nt_colon, xt_source_id, z_source_id
>c252	73 6f 75 72 63 65 2d 69		        .text "source-id"
>c25a	64
.c25b					nt_colon:
>c25b	01 00				        .byte 1, 0
>c25d	64 c2 1b 87 5d 87		        .word nt_semicolon, xt_colon, z_colon
>c263	3a				        .text ":"
.c264					nt_semicolon:
>c264	01 05				        .byte 1, CO+IM
>c266	6d c2 94 9f f2 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c26c	3b				        .text ";"
.c26d					nt_colon_noname:
>c26d	07 00				        .byte 7, 0
>c26f	7c c2 5e 87 79 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c275	3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c27c					nt_compile_comma:
>c27c	08 18				        .byte 8, UF+NN
>c27e	8c c2 f9 87 10 89		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c284	63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c28c					nt_left_bracket:
>c28c	01 05				        .byte 1, IM+CO
>c28e	95 c2 61 93 65 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c294	5b				        .text "["
.c295					nt_right_bracket:
>c295	01 04				        .byte 1, IM
>c297	9e c2 53 9b 59 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c29d	5d				        .text "]"
.c29e					nt_literal:
>c29e	07 15				        .byte 7, IM+CO+UF
>c2a0	ad c2 96 93 a3 93		        .word nt_sliteral, xt_literal, z_literal
>c2a6	6c 69 74 65 72 61 6c		        .text "literal"
.c2ad					nt_sliteral:
>c2ad	08 15				        .byte 8, CO+IM+UF
>c2af	bd c2 45 a0 b4 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c2b5	73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c2bd					nt_dot_quote:
>c2bd	02 05				        .byte 2, CO+IM
>c2bf	c7 c2 73 8c 7d 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c2c5	2e 22				        .text ".", $22
.c2c7					nt_s_quote:
>c2c7	02 0c				        .byte 2, IM+NN
>c2c9	d1 c2 5b 9d b7 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c2cf	73 22				        .text "s", $22
.c2d1					nt_s_backslash_quote:
>c2d1	03 04				        .byte 3, IM
>c2d3	dc c2 93 9b 9c 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c2d9	73 5c 22			        .text "s", $5C, $22
.c2dc					nt_postpone:
>c2dc	08 05				        .byte 8, IM+CO
>c2de	ec c2 22 9a 60 9a		        .word nt_immediate, xt_postpone, z_postpone
>c2e4	70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c2ec					nt_immediate:
>c2ec	09 00				        .byte 9, 0
>c2ee	fd c2 57 92 62 92		        .word nt_compile_only, xt_immediate, z_immediate
>c2f4	69 6d 6d 65 64 69 61 74		        .text "immediate"
>c2fc	65
.c2fd					nt_compile_only:
>c2fd	0c 00				        .byte 12, 0
>c2ff	11 c3 11 89 1c 89		        .word nt_never_native, xt_compile_only, z_compile_only
>c305	63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c30d	6f 6e 6c 79
.c311					nt_never_native:
>c311	0c 00				        .byte 12, 0
>c313	25 c3 40 96 4d 96		        .word nt_always_native, xt_never_native, z_never_native
>c319	6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c321	74 69 76 65
.c325					nt_always_native:
>c325	0d 00				        .byte 13, 0
>c327	3a c3 1a 83 27 83		        .word nt_allow_native, xt_always_native, z_always_native
>c32d	61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c335	61 74 69 76 65
.c33a					nt_allow_native:
>c33a	0c 00				        .byte 12, 0
>c33c	4e c3 fe 82 09 83		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c342	61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c34a	74 69 76 65
.c34e					nt_nc_limit:
>c34e	08 00				        .byte 8, 0
>c350	5e c3 24 96 2e 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c356	6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c35e					nt_strip_underflow:
>c35e	0f 00				        .byte 15, 0
>c360	75 c3 af a1 b9 a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c366	73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c36e	64 65 72 66 6c 6f 77
.c375					nt_abort:
>c375	05 00				        .byte 5, 0
>c377	82 c3 60 80 ad 80		        .word nt_abort_quote, xt_abort, z_abort
>c37d	61 62 6f 72 74			        .text "abort"
.c382					nt_abort_quote:
>c382	06 0d				        .byte 6, CO+IM+NN
>c384	90 c3 03 81 0d 81		        .word nt_do, xt_abort_quote, z_abort_quote
>c38a	61 62 6f 72 74 22		        .text "abort", $22
.c390					nt_do:
>c390	02 0d				        .byte 2, CO+IM+NN
>c392	9a c3 6e 8b c8 8b		        .word nt_question_do, xt_do, z_do
>c398	64 6f				        .text "do"
.c39a					nt_question_do:
>c39a	03 0d				        .byte 3, CO+IM+NN
>c39c	a5 c3 68 8b c8 8b		        .word nt_i, xt_question_do, z_question_do
>c3a2	3f 64 6f			        .text "?do"
.c3a5					nt_i:
>c3a5	01 03				        .byte 1, AN+CO
>c3a7	ae c3 f5 91 0e 92		        .word nt_j, xt_i, z_i
>c3ad	69				        .text "i"
.c3ae					nt_j:
>c3ae	01 03				        .byte 1, AN+CO
>c3b0	b7 c3 20 93 39 93		        .word nt_loop, xt_j, z_j
>c3b6	6a				        .text "j"
.c3b7					nt_loop:
>c3b7	04 05				        .byte 4, CO+IM
>c3b9	c3 c3 07 94 74 94		        .word nt_plus_loop, xt_loop, z_loop
>c3bf	6c 6f 6f 70			        .text "loop"
.c3c3					nt_plus_loop:
>c3c3	05 05				        .byte 5, CO+IM
>c3c5	d0 c3 0e 94 74 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3cb	2b 6c 6f 6f 70			        .text "+loop"
.c3d0					nt_exit:
>c3d0	04 03				        .byte 4, AN+CO
>c3d2	dc c3 84 8f 85 8f		        .word nt_unloop, xt_exit, z_exit
>c3d8	65 78 69 74			        .text "exit"
.c3dc					nt_unloop:
>c3dc	06 03				        .byte 6, AN+CO
>c3de	ea c3 4e a6 54 a6		        .word nt_leave, xt_unloop, z_unloop
>c3e4	75 6e 6c 6f 6f 70		        .text "unloop"
.c3ea					nt_leave:
>c3ea	05 03				        .byte 5, AN+CO
>c3ec	f7 c3 5c 93 61 93		        .word nt_recurse, xt_leave, z_leave
>c3f2	6c 65 61 76 65			        .text "leave"
.c3f7					nt_recurse:
>c3f7	07 0d				        .byte 7, CO+IM+NN
>c3f9	06 c4 c7 9a 03 9b		        .word nt_quit, xt_recurse, z_recurse
>c3ff	72 65 63 75 72 73 65		        .text "recurse"
.c406					nt_quit:
>c406	04 00				        .byte 4, 0
>c408	12 c4 62 80 ad 80		        .word nt_begin, xt_quit, z_quit
>c40e	71 75 69 74			        .text "quit"
.c412					nt_begin:
>c412	05 07				        .byte 5, AN+CO+IM
>c414	1f c4 9c 83 9f 83		        .word nt_again, xt_begin, z_begin
>c41a	62 65 67 69 6e			        .text "begin"
.c41f					nt_again:
>c41f	05 17				        .byte 5, AN+CO+IM+UF
>c421	2c c4 73 82 93 82		        .word nt_state, xt_again, z_again
>c427	61 67 61 69 6e			        .text "again"
.c42c					nt_state:
>c42c	05 00				        .byte 5, 0
>c42e	39 c4 8e a1 98 a1		        .word nt_evaluate, xt_state, z_state
>c434	73 74 61 74 65			        .text "state"
.c439					nt_evaluate:
>c439	08 10				        .byte 8, UF
>c43b	49 c4 e1 90 34 91		        .word nt_base, xt_evaluate, z_evaluate
>c441	65 76 61 6c 75 61 74 65		        .text "evaluate"
.c449					nt_base:
>c449	04 00				        .byte 4, 0
>c44b	55 c4 93 83 9b 83		        .word nt_digit_question, xt_base, z_base
>c451	62 61 73 65			        .text "base"
.c455					nt_digit_question:
>c455	06 10				        .byte 6, UF
>c457	63 c4 11 8b 45 8b		        .word nt_number, xt_digit_question, z_digit_question
>c45d	64 69 67 69 74 3f		        .text "digit?"
.c463					nt_number:
>c463	06 10				        .byte 6, UF
>c465	71 c4 96 96 92 97		        .word nt_to_number, xt_number, z_number
>c46b	6e 75 6d 62 65 72		        .text "number"
.c471					nt_to_number:
>c471	07 10				        .byte 7, UF
>c473	80 c4 c9 a2 68 a3		        .word nt_hex, xt_to_number, z_to_number
>c479	3e 6e 75 6d 62 65 72		        .text ">number"
.c480					nt_hex:
>c480	03 00				        .byte 3, 0
>c482	8b c4 89 91 8f 91		        .word nt_decimal, xt_hex, z_hex
>c488	68 65 78			        .text "hex"
.c48b					nt_decimal:
>c48b	07 00				        .byte 7, 0
>c48d	9a c4 b1 8a b7 8a		        .word nt_count, xt_decimal, z_decimal
>c493	64 65 63 69 6d 61 6c		        .text "decimal"
.c49a					nt_count:
>c49a	05 10				        .byte 5, UF
>c49c	a7 c4 5b 89 6e 89		        .word nt_m_star, xt_count, z_count
>c4a2	63 6f 75 6e 74			        .text "count"
.c4a7					nt_m_star:
>c4a7	02 10				        .byte 2, UF
>c4a9	b1 c4 9a 94 b4 94		        .word nt_um_star, xt_m_star, z_m_star
>c4af	6d 2a				        .text "m*"
.c4b1					nt_um_star:
>c4b1	03 10				        .byte 3, UF
>c4b3	bc c4 08 a6 4d a6		        .word nt_star, xt_um_star, z_um_star
>c4b9	75 6d 2a			        .text "um*"
.c4bc					nt_star:
>c4bc	01 10				        .byte 1, UF
>c4be	c5 c4 6c a1 74 a1		        .word nt_um_slash_mod, xt_star, z_star
>c4c4	2a				        .text "*"
.c4c5					nt_um_slash_mod:
>c4c5	06 10				        .byte 6, UF
>c4c7	d3 c4 c6 a5 07 a6		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c4cd	75 6d 2f 6d 6f 64		        .text "um/mod"
.c4d3					nt_sm_slash_rem:
>c4d3	06 10				        .byte 6, UF
>c4d5	e1 c4 e1 a0 09 a1		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c4db	73 6d 2f 72 65 6d		        .text "sm/rem"
.c4e1					nt_fm_slash_mod:
>c4e1	06 10				        .byte 6, UF
>c4e3	ef c4 9d 90 d3 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c4e9	66 6d 2f 6d 6f 64		        .text "fm/mod"
.c4ef					nt_slash:
>c4ef	01 10				        .byte 1, UF
>c4f1	f8 c4 08 a0 24 a0		        .word nt_slash_mod, xt_slash, z_slash
>c4f7	2f				        .text "/"
.c4f8					nt_slash_mod:
>c4f8	04 10				        .byte 4, UF
>c4fa	04 c5 0d a0 24 a0		        .word nt_mod, xt_slash_mod, z_slash_mod
>c500	2f 6d 6f 64			        .text "/mod"
.c504					nt_mod:
>c504	03 10				        .byte 3, UF
>c506	0f c5 c5 95 cd 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c50c	6d 6f 64			        .text "mod"
.c50f					nt_star_slash_mod:
>c50f	05 10				        .byte 5, UF
>c511	1c c5 7e a1 8d a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c517	2a 2f 6d 6f 64			        .text "*/mod"
.c51c					nt_star_slash:
>c51c	02 10				        .byte 2, UF
>c51e	26 c5 75 a1 7d a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c524	2a 2f				        .text "*/"
.c526					nt_backslash:
>c526	01 04				        .byte 1, IM
>c528	2f c5 68 83 92 83		        .word nt_move, xt_backslash, z_backslash
>c52e	5c				        .byte $5c
.c52f					nt_move:
>c52f	04 18				        .byte 4, NN+UF
>c531	3b c5 ce 95 ec 95		        .word nt_cmove_up, xt_move, z_move
>c537	6d 6f 76 65			        .text "move"
.c53b					nt_cmove_up:
>c53b	06 10				        .byte 6, UF
>c53d	49 c5 e0 86 1a 87		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c543	63 6d 6f 76 65 3e		        .text "cmove>"
.c549					nt_cmove:
>c549	05 10				        .byte 5, UF
>c54b	56 c5 a5 86 df 86		        .word nt_pad, xt_cmove, z_cmove
>c551	63 6d 6f 76 65			        .text "cmove"
.c556					nt_pad:
>c556	03 00				        .byte 3, 0
>c558	61 c5 ad 98 bc 98		        .word nt_cleave, xt_pad, z_pad
>c55e	70 61 64			        .text "pad"
.c561					nt_cleave:
>c561	06 10				        .byte 6, UF
>c563	6f c5 58 86 a4 86		        .word nt_hexstore, xt_cleave, z_cleave
>c569	63 6c 65 61 76 65		        .text "cleave"
.c56f					nt_hexstore:
>c56f	08 10				        .byte 8, UF
>c571	7f c5 90 91 e2 91		        .word nt_within, xt_hexstore, z_hexstore
>c577	68 65 78 73 74 6f 72 65		        .text "hexstore"
.c57f					nt_within:
>c57f	06 10				        .byte 6, UF
>c581	8d c5 b1 a6 c6 a6		        .word nt_to_in, xt_within, z_within
>c587	77 69 74 68 69 6e		        .text "within"
.c58d					nt_to_in:
>c58d	03 00				        .byte 3, 0
>c58f	98 c5 be a2 c8 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c595	3e 69 6e			        .text ">in"
.c598					nt_less_number_sign:
>c598	02 00				        .byte 2, 0
>c59a	a2 c5 66 93 73 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c5a0	3c 23				        .text "<#"
.c5a2					nt_number_sign:
>c5a2	01 10				        .byte 1, UF
>c5a4	ab c5 93 97 c7 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c5aa	23				        .text "#"
.c5ab					nt_number_sign_s:
>c5ab	02 10				        .byte 2, UF
>c5ad	b5 c5 ea 97 fa 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c5b3	23 73				        .text "#s"
.c5b5					nt_number_sign_greater:
>c5b5	02 10				        .byte 2, UF
>c5b7	bf c5 c8 97 e9 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c5bd	23 3e				        .text "#>"
.c5bf					nt_hold:
>c5bf	04 10				        .byte 4, UF
>c5c1	cb c5 e3 91 f4 91		        .word nt_sign, xt_hold, z_hold
>c5c7	68 6f 6c 64			        .text "hold"
.c5cb					nt_sign:
>c5cb	04 10				        .byte 4, UF
>c5cd	d7 c5 f3 9f 07 a0		        .word nt_output, xt_sign, z_sign
>c5d3	73 69 67 6e			        .text "sign"
.c5d7					nt_output:
>c5d7	06 00				        .byte 6, 0
>c5d9	e5 c5 94 98 9e 98		        .word nt_input, xt_output, z_output
>c5df	6f 75 74 70 75 74		        .text "output"
.c5e5					nt_input:
>c5e5	05 00				        .byte 5, 0
>c5e7	f2 c5 63 92 6d 92		        .word nt_cr, xt_input, z_input
>c5ed	69 6e 70 75 74			        .text "input"
.c5f2					nt_cr:
>c5f2	02 00				        .byte 2, 0
>c5f4	fc c5 6f 89 74 89		        .word nt_page, xt_cr, z_cr
>c5fa	63 72				        .text "cr"
.c5fc					nt_page:
>c5fc	04 00				        .byte 4, 0
>c5fe	08 c6 bd 98 da 98		        .word nt_at_xy, xt_page, z_page
>c604	70 61 67 65			        .text "page"
.c608					nt_at_xy:
>c608	05 10				        .byte 5, UF
>c60a	15 c6 3a 83 67 83		        .word nt_marker, xt_at_xy, z_at_xy
>c610	61 74 2d 78 79			        .text "at-xy"
.c615					nt_marker:
>c615	06 04				        .byte 6, IM
>c617	23 c6 b5 94 f2 94		        .word nt_words, xt_marker, z_marker
>c61d	6d 61 72 6b 65 72		        .text "marker"
.c623					nt_words:
>c623	05 00				        .byte 5, 0
>c625	30 c6 24 a7 80 a7		        .word nt_wordsize, xt_words, z_words
>c62b	77 6f 72 64 73			        .text "words"
.c630					nt_wordsize:
>c630	08 10				        .byte 8, UF
>c632	40 c6 81 a7 a1 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c638	77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c640					nt_aligned:
>c640	07 00				        .byte 7, 0
>c642	4f c6 94 82 94 82		        .word nt_align, xt_align, z_align
>c648	61 6c 69 67 6e 65 64		        .text "aligned"
.c64f					nt_align:
>c64f	05 00				        .byte 5, 0
>c651	5c c6 94 82 94 82		        .word nt_bell, xt_align, z_align
>c657	61 6c 69 67 6e			        .text "align"
.c65c					nt_bell:
>c65c	04 00				        .byte 4, 0
>c65e	68 c6 a0 83 a5 83		        .word nt_dump, xt_bell, z_bell
>c664	62 65 6c 6c			        .text "bell"
.c668					nt_dump:
>c668	04 10				        .byte 4, UF
>c66a	74 c6 40 8d a6 8d		        .word nt_dot_s, xt_dump, z_dump
>c670	64 75 6d 70			        .text "dump"
.c674					nt_dot_s:
>c674	02 00				        .byte 2, 0
>c676	7e c6 ac 8c ef 8c		        .word nt_disasm, xt_dot_s, z_dot_s
>c67c	2e 73				        .text ".s"
.c67e					nt_disasm:
>c67e	06 10				        .byte 6, UF
>c680	8c c6 46 8b 4c 8b		        .word nt_compare, xt_disasm, z_disasm
>c686	64 69 73 61 73 6d		        .text "disasm"
.c68c					nt_compare:
>c68c	07 10				        .byte 7, UF
>c68e	9b c6 94 87 f8 87		        .word nt_search, xt_compare, z_compare
>c694	63 6f 6d 70 61 72 65		        .text "compare"
.c69b					nt_search:
>c69b	06 18				        .byte 6, UF+NN
>c69d	a9 c6 f5 9e 93 9f		        .word +, xt_search, z_search
>c6a3	73 65 61 72 63 68		        .text "search"
.c6a9					+
.c6a9					nt_environment_q:
>c6a9	0c 10				        .byte 12, UF
>c6ab	bd c6 21 8e 9d 8e		        .word +, xt_environment_q, z_environment_q
>c6b1	65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c6b9	65 6e 74 3f
.c6bd					+
.c6bd					nt_find:
>c6bd	04 10				        .byte 4, UF
>c6bf	c9 c6 9f 8f e6 8f		        .word nt_word, xt_find, z_find
>c6c5	66 69 6e 64			        .text "find"
.c6c9					nt_word:
>c6c9	04 10				        .byte 4, UF
>c6cb	d5 c6 c7 a6 0c a7		        .word nt_paren, xt_word, z_word
>c6d1	77 6f 72 64			        .text "word"
.c6d5					nt_paren:
>c6d5	01 04				        .byte 1, IM
>c6d7	de c6 db 98 ea 98		        .word nt_dot_paren, xt_paren, z_paren
>c6dd	28				        .text "("
.c6de					nt_dot_paren:
>c6de	02 04				        .byte 2, IM
>c6e0	e8 c6 64 8c 72 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c6e6	2e 28				        .text ".("
.c6e8					nt_if:
>c6e8	02 0d				        .byte 2, IM+CO+NN
>c6ea	f2 c6 0f 92 1f 92		        .word nt_then, xt_if, z_if
>c6f0	69 66				        .text "if"
.c6f2					nt_then:
>c6f2	04 0d				        .byte 4, IM+CO+NN
>c6f4	fe c6 ce a1 d7 a1		        .word nt_else, xt_then, z_then
>c6fa	74 68 65 6e			        .text "then"
.c6fe					nt_else:
>c6fe	04 0d				        .byte 4, IM+CO+NN
>c700	0a c7 cd 8d e6 8d		        .word nt_repeat, xt_else, z_else
>c706	65 6c 73 65			        .text "else"
.c70a					nt_repeat:
>c70a	06 0d				        .byte 6, IM+CO+NN
>c70c	18 c7 46 9b 52 9b		        .word nt_until, xt_repeat, z_repeat
>c712	72 65 70 65 61 74		        .text "repeat"
.c718					nt_until:
>c718	05 0d				        .byte 5, IM+CO+NN
>c71a	25 c7 55 a6 5f a6		        .word nt_while, xt_until, z_until
>c720	75 6e 74 69 6c			        .text "until"
.c725					nt_while:
>c725	05 0d				        .byte 5, IM+CO+NN
>c727	32 c7 9d a6 b0 a6		        .word nt_case, xt_while, z_while
>c72d	77 68 69 6c 65			        .text "while"
.c732					nt_case:
>c732	04 0d				        .byte 4, IM+CO+NN
>c734	3e c7 b4 a7 ba a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c73a	63 61 73 65			        .text "case"
.c73e					nt_of:
>c73e	02 0d				        .byte 2, IM+CO+NN
>c740	48 c7 fb 97 13 98		        .word nt_endof, xt_of, z_of
>c746	6f 66				        .text "of"
.c748					nt_endof:
>c748	05 0d				        .byte 5, IM+CO+NN
>c74a	55 c7 cd 8d e6 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c750	65 6e 64 6f 66			        .text "endof"
.c755					nt_endcase:
>c755	07 0d				        .byte 7, IM+CO+NN
>c757	64 c7 0c 8e 20 8e		        .word nt_defer_fetch, xt_endcase, z_endcase
>c75d	65 6e 64 63 61 73 65		        .text "endcase"
.c764					nt_defer_fetch:
>c764	06 00				        .byte 6, 0
>c766	72 c7 eb 8a f1 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c76c	64 65 66 65 72 40		        .text "defer@"
.c772					nt_defer_store:
>c772	06 00				        .byte 6, 0
>c774	80 c7 f2 8a f8 8a		        .word nt_is, xt_defer_store, z_defer_store
>c77a	64 65 66 65 72 21		        .text "defer!"
.c780					nt_is:
>c780	02 04				        .byte 2, IM
>c782	8a c7 07 93 1f 93		        .word nt_action_of, xt_is, z_is
>c788	69 73				        .text "is"
.c78a					nt_action_of:
>c78a	09 04				        .byte 9, IM
>c78c	9b c7 5a 82 72 82		        .word nt_useraddr, xt_action_of, z_action_of
>c792	61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c79a	66
.c79b					nt_useraddr:
>c79b	08 00				        .byte 8, 0
>c79d	ab c7 79 a6 83 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c7a3	75 73 65 72 61 64 64 72		        .text "useraddr"
.c7ab					nt_buffer_colon:
>c7ab	07 00				        .byte 7, 0
>c7ad	ba c7 f2 85 f8 85		        .word +, xt_buffer_colon, z_buffer_colon
>c7b3	62 75 66 66 65 72 3a		        .text "buffer:"
.c7ba					+
.c7ba					nt_buffstatus:
>c7ba	0a 00				        .byte 10, 0
>c7bc	cc c7 f9 85 08 86		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7c2	62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7ca	75 73
.c7cc					nt_buffblocknum:
>c7cc	0c 00				        .byte 12, 0
>c7ce	e0 c7 b1 85 c0 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c7d4	62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c7dc	6b 6e 75 6d
.c7e0					nt_blkbuffer:
>c7e0	09 00				        .byte 9, 0
>c7e2	f1 c7 bf 83 cc 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c7e8	62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c7f0	72
.c7f1					nt_scr:
>c7f1	03 00				        .byte 3, 0
>c7f3	fc c7 e5 9e f4 9e		        .word nt_blk, xt_scr, z_scr
>c7f9	73 63 72			        .text "scr"
.c7fc					nt_blk:
>c7fc	03 00				        .byte 3, 0
>c7fe	07 c8 af 83 be 83		        .word nt_block_write, xt_blk, z_blk
>c804	62 6c 6b			        .text "blk"
.c807					nt_block_write:
>c807	0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c809	1a c8 6c 85 7a 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c80f	62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c817	69 74 65
.c81a					nt_block_write_vector:
>c81a	12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c81c	34 c8 7a 85 89 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c822	62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c82a	69 74 65 2d 76 65 63 74 6f 72
.c834					nt_block_read:
>c834	0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c836	46 c8 49 85 57 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c83c	62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c844	61 64
.c846					nt_block_read_vector:
>c846	11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c848	5f c8 57 85 66 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c84e	62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c856	61 64 2d 76 65 63 74 6f 72
.c85f					nt_save_buffers:
>c85f	0c 00				        .byte 12, 0
>c861	73 c8 ca 9e e4 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c867	73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c86f	66 65 72 73
.c873					nt_block:
>c873	05 00				        .byte 5, 0
>c875	80 c8 cd 83 1f 84		        .word nt_update, xt_block, z_block
>c87b	62 6c 6f 63 6b			        .text "block"
.c880					nt_update:
>c880	06 00				        .byte 6, 0
>c882	8e c8 70 a6 78 a6		        .word nt_buffer, xt_update, z_update
>c888	75 70 64 61 74 65		        .text "update"
.c88e					nt_buffer:
>c88e	06 00				        .byte 6, 0
>c890	9c c8 c1 85 f1 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c896	62 75 66 66 65 72		        .text "buffer"
.c89c					nt_empty_buffers:
>c89c	0d 00				        .byte 13, 0
>c89e	b1 c8 05 8e 0b 8e		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c8a4	65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c8ac	66 66 65 72 73
.c8b1					nt_flush:
>c8b1	05 00				        .byte 5, 0
>c8b3	be c8 93 90 9c 90		        .word nt_load, xt_flush, z_flush
>c8b9	66 6c 75 73 68			        .text "flush"
.c8be					nt_load:
>c8be	04 10				        .byte 4, UF
>c8c0	ca c8 c3 93 06 94		        .word nt_thru, xt_load, z_load
>c8c6	6c 6f 61 64			        .text "load"
.c8ca					nt_thru:
>c8ca	04 10				        .byte 4, UF
>c8cc	d6 c8 d8 a1 1c a2		        .word nt_list, xt_thru, z_thru
>c8d2	74 68 72 75			        .text "thru"
.c8d6					nt_list:
>c8d6	04 10				        .byte 4, UF
>c8d8	e2 c8 89 93 95 93		        .word +, xt_list, z_list
>c8de	6c 69 73 74			        .text "list"
.c8e2					+
.c8e2					nt_block_ramdrive_init:
>c8e2	13 10				        .byte 19, UF
>c8e4	fd c8 20 84 48 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c8ea	62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c8f2	6d 64 72 69 76 65 2d 69 6e 69 74
.c8fd					+
.c8fd					nt_definitions:
>c8fd	0b 00				        .byte 11, 0
>c8ff	10 c9 f9 8a 01 8b		        .word nt_wordlist, xt_definitions, z_definitions
>c905	64 65 66 69 6e 69 74 69		        .text "definitions"
>c90d	6f 6e 73
.c910					nt_wordlist:
>c910	08 00				        .byte 8, 0
>c912	20 c9 0d a7 23 a7		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c918	77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c920					nt_search_wordlist:
>c920	0f 10				        .byte 15, UF
>c922	37 c9 ac 9b 8c 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c928	73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c930	6f 72 64 6c 69 73 74
.c937					nt_set_current:
>c937	0b 10				        .byte 11, UF
>c939	4a c9 1b 9d 26 9d		        .word nt_get_current, xt_set_current, z_set_current
>c93f	73 65 74 2d 63 75 72 72		        .text "set-current"
>c947	65 6e 74
.c94a					nt_get_current:
>c94a	0b 00				        .byte 11, 0
>c94c	5d c9 35 91 3f 91		        .word nt_set_order, xt_get_current, z_get_current
>c952	67 65 74 2d 63 75 72 72		        .text "get-current"
>c95a	65 6e 74
.c95d					nt_set_order:
>c95d	09 00				        .byte 9, 0
>c95f	6e c9 27 9d 5a 9d		        .word nt_get_order, xt_set_order, z_set_order
>c965	73 65 74 2d 6f 72 64 65		        .text "set-order"
>c96d	72
.c96e					nt_get_order:
>c96e	09 00				        .byte 9, 0
>c970	7f c9 40 91 68 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c976	67 65 74 2d 6f 72 64 65		        .text "get-order"
>c97e	72
.c97f					nt_root_wordlist:
>c97f	0d 00				        .byte 13, 0
>c981	94 c9 5a 9b 62 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c987	72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c98f	64 6c 69 73 74
.c994					+
.c994					nt_assembler_wordlist:
>c994	12 00				        .byte 18, 0
>c996	ae c9 b3 a3 bb a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c99c	61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c9a4	72 2d 77 6f 72 64 6c 69 73 74
.c9ae					+
.c9ae					nt_editor_wordlist:
>c9ae	0f 00				        .byte 15, 0
>c9b0	c5 c9 14 98 1c 98		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9b6	65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9be	6f 72 64 6c 69 73 74
.c9c5					+
.c9c5					nt_forth_wordlist:
>c9c5	0e 00				        .byte 14, 0
>c9c7	db c9 b4 a7 ba a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c9cd	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9d5	72 64 6c 69 73 74
.c9db					nt_only:
>c9db	04 00				        .byte 4, 0
>c9dd	e7 c9 33 98 3e 98		        .word nt_also, xt_only, z_only
>c9e3	6f 6e 6c 79			        .text "only"
.c9e7					nt_also:
>c9e7	04 00				        .byte 4, 0
>c9e9	f3 c9 0a 83 19 83		        .word nt_previous, xt_also, z_also
>c9ef	61 6c 73 6f			        .text "also"
.c9f3					nt_previous:
>c9f3	08 00				        .byte 8, 0
>c9f5	03 ca 61 9a 6d 9a		        .word nt_to_order, xt_previous, z_previous
>c9fb	70 72 65 76 69 6f 75 73		        .text "previous"
.ca03					nt_to_order:
>ca03	06 00				        .byte 6, 0
>ca05	11 ca 69 a3 7b a3		        .word nt_order, xt_to_order, z_to_order
>ca0b	3e 6f 72 64 65 72		        .text ">order"
.ca11					nt_order:
>ca11	05 00				        .byte 5, 0
>ca13	1e ca 51 98 7b 98		        .word nt_forth, xt_order, z_order
>ca19	6f 72 64 65 72			        .text "order"
.ca1e					nt_forth:
>ca1e	05 00				        .byte 5, 0
>ca20	2b ca d4 90 da 90		        .word +, xt_forth, z_forth
>ca26	66 6f 72 74 68			        .text "forth"
.ca2b					+
>ca2b	03 08				nt_see: .byte 3, NN
>ca2d	36 ca 8d 9c 1a 9d		        .word +, xt_see, z_see
>ca33	73 65 65			        .text "see"
.ca36					+
.ca36					nt_ed:
>ca36	02 08				        .byte 2, NN
>ca38	40 ca c9 8d cc 8d		        .word +, xt_ed, z_ed
>ca3e	65 64				        .text "ed"
.ca40					+
.ca40					nt_cold:
>ca40	04 00				        .byte 4, 0
>ca42	4c ca 00 80 ad 80		        .word nt_bye, xt_cold, z_cold
>ca48	63 6f 6c 64			        .text "cold"
.ca4c					nt_bye:
>ca4c	03				        .byte 3         ; length of word strings
>ca4d	00				        .byte 0         ; status byte
>ca4e	00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca50	09 86				        .word xt_bye    ; start of code block (xt of this word)
>ca52	0c 86				        .word z_bye     ; end of code (RTS)
>ca54	62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca57					root_dictionary_start:
.ca57					nt_root_set_order:
>ca57	09 00				        .byte 9, 0
>ca59	68 ca 27 9d 5a 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca5f	73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca67	72
.ca68					nt_root_forth:
>ca68	05 00				        .byte 5, 0
>ca6a	75 ca d4 90 da 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca70	66 6f 72 74 68			        .text "forth"
.ca75					nt_root_forth_wordlist:
>ca75	0e 00				        .byte 14, 0
>ca77	8b ca b4 a7 ba a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca7d	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca85	72 64 6c 69 73 74
.ca8b					nt_root_words:
>ca8b	05 00				        .byte 5, 0
>ca8d	00 00 24 a7 80 a7		        .word 0000, xt_words, z_words
>ca93	77 6f 72 64 73			        .text "words"
.ca98					editor_dictionary_start:
.ca98					nt_editor_o:
>ca98	01 00				        .byte 1, 0
>ca9a	a1 ca e7 a8 2c a9		        .word nt_editor_line, xt_editor_o, z_editor_o
>caa0	6f				        .text "o"
.caa1					nt_editor_line:
>caa1	04 10				        .byte 4, UF
>caa3	ad ca ce a8 e6 a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>caa9	6c 69 6e 65			        .text "line"
.caad					nt_editor_l:
>caad	01 00				        .byte 1, 0
>caaf	b6 ca 52 a8 cd a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>cab5	6c				        .text "l"
.cab6					nt_editor_el:
>cab6	02 00				        .byte 2, 0
>cab8	c0 ca 40 a8 51 a8		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cabe	65 6c				        .text "el"
.cac0					nt_editor_erase_screen:
>cac0	0c 00				        .byte 12, 0
>cac2	d4 ca 2e a8 3f a8		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cac8	65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cad0	72 65 65 6e
.cad4					nt_editor_enter_screen:
>cad4	0c 00				        .byte 12, 0
>cad6	00 00 12 a8 2d a8		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cadc	65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cae4	72 65 65 6e
.cae8					assembler_dictionary_start:
.cae8					nt_asm_adc_h:
>cae8	05 0c						.byte 5, IM+NN
>caea	f5 ca				                .word nt_asm_adc_x
>caec	2d a9 32 a9					.word xt_asm_adc_h, z_asm_adc_h
>caf0	61 64 63 2e 23					.text "adc.#"
.caf5					nt_asm_adc_x:
>caf5	05 0c						.byte 5, IM+NN
>caf7	02 cb				                .word nt_asm_adc_y
>caf9	32 a9 37 a9					.word xt_asm_adc_x, z_asm_adc_x
>cafd	61 64 63 2e 78					.text "adc.x"
.cb02					nt_asm_adc_y:
>cb02	05 0c						.byte 5, IM+NN
>cb04	0f cb				                .word nt_asm_adc_z
>cb06	37 a9 3c a9					.word xt_asm_adc_y, z_asm_adc_y
>cb0a	61 64 63 2e 79					.text "adc.y"
.cb0f					nt_asm_adc_z:
>cb0f	05 0c						.byte 5, IM+NN
>cb11	1c cb				                .word nt_asm_adc_zi
>cb13	3c a9 41 a9					.word xt_asm_adc_z, z_asm_adc_z
>cb17	61 64 63 2e 7a					.text "adc.z"
.cb1c					nt_asm_adc_zi:
>cb1c	06 0c						.byte 6, IM+NN
>cb1e	2a cb				                .word nt_asm_adc_ziy
>cb20	41 a9 46 a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cb24	61 64 63 2e 7a 69				.text "adc.zi"
.cb2a					nt_asm_adc_ziy:
>cb2a	07 0c						.byte 7, IM+NN
>cb2c	39 cb				                .word nt_asm_adc_zx
>cb2e	46 a9 4b a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb32	61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb39					nt_asm_adc_zx:
>cb39	06 0c						.byte 6, IM+NN
>cb3b	47 cb				                .word nt_asm_adc_zxi
>cb3d	4b a9 50 a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cb41	61 64 63 2e 7a 78				.text "adc.zx"
.cb47					nt_asm_adc_zxi:
>cb47	07 0c						.byte 7, IM+NN
>cb49	56 cb				                .word nt_asm_and
>cb4b	50 a9 55 a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb4f	61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb56					nt_asm_and:
>cb56	04 0c						.byte 4, IM+NN
>cb58	62 cb				                .word nt_asm_and_h
>cb5a	55 a9 5a a9					.word xt_asm_and, z_asm_and
>cb5e	61 6e 64 2e					.text "and."
.cb62					nt_asm_and_h:
>cb62	05 0c						.byte 5, IM+NN
>cb64	6f cb				                .word nt_asm_and_x
>cb66	5a a9 5f a9					.word xt_asm_and_h, z_asm_and_h
>cb6a	61 6e 64 2e 23					.text "and.#"
.cb6f					nt_asm_and_x:
>cb6f	05 0c						.byte 5, IM+NN
>cb71	7c cb				                .word nt_asm_and_y
>cb73	5f a9 64 a9					.word xt_asm_and_x, z_asm_and_x
>cb77	61 6e 64 2e 78					.text "and.x"
.cb7c					nt_asm_and_y:
>cb7c	05 0c						.byte 5, IM+NN
>cb7e	89 cb				                .word nt_asm_and_z
>cb80	64 a9 69 a9					.word xt_asm_and_y, z_asm_and_y
>cb84	61 6e 64 2e 79					.text "and.y"
.cb89					nt_asm_and_z:
>cb89	05 0c						.byte 5, IM+NN
>cb8b	96 cb				                .word nt_asm_and_zi
>cb8d	69 a9 6e a9					.word xt_asm_and_z, z_asm_and_z
>cb91	61 6e 64 2e 7a					.text "and.z"
.cb96					nt_asm_and_zi:
>cb96	06 0c						.byte 6, IM+NN
>cb98	a4 cb				                .word nt_asm_and_ziy
>cb9a	6e a9 73 a9					.word xt_asm_and_zi, z_asm_and_zi
>cb9e	61 6e 64 2e 7a 69				.text "and.zi"
.cba4					nt_asm_and_ziy:
>cba4	07 0c						.byte 7, IM+NN
>cba6	b3 cb				                .word nt_asm_and_zx
>cba8	73 a9 78 a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cbac	61 6e 64 2e 7a 69 79				.text "and.ziy"
.cbb3					nt_asm_and_zx:
>cbb3	06 0c						.byte 6, IM+NN
>cbb5	c1 cb				                .word nt_asm_and_zxi
>cbb7	78 a9 7d a9					.word xt_asm_and_zx, z_asm_and_zx
>cbbb	61 6e 64 2e 7a 78				.text "and.zx"
.cbc1					nt_asm_and_zxi:
>cbc1	07 0c						.byte 7, IM+NN
>cbc3	d0 cb				                .word nt_asm_asl
>cbc5	7d a9 82 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cbc9	61 6e 64 2e 7a 78 69				.text "and.zxi"
.cbd0					nt_asm_asl:
>cbd0	03 0c						.byte 3, IM+NN
>cbd2	db cb				                .word nt_asm_asl_a
>cbd4	82 a9 87 a9					.word xt_asm_asl, z_asm_asl
>cbd8	61 73 6c					.text "asl"
.cbdb					nt_asm_asl_a:
>cbdb	05 0c						.byte 5, IM+NN
>cbdd	e8 cb				                .word nt_asm_asl_x
>cbdf	87 a9 8c a9					.word xt_asm_asl_a, z_asm_asl_a
>cbe3	61 73 6c 2e 61					.text "asl.a"
.cbe8					nt_asm_asl_x:
>cbe8	05 0c						.byte 5, IM+NN
>cbea	f5 cb				                .word nt_asm_asl_z
>cbec	8c a9 91 a9					.word xt_asm_asl_x, z_asm_asl_x
>cbf0	61 73 6c 2e 78					.text "asl.x"
.cbf5					nt_asm_asl_z:
>cbf5	05 0c						.byte 5, IM+NN
>cbf7	02 cc				                .word nt_asm_asl_zx
>cbf9	91 a9 96 a9					.word xt_asm_asl_z, z_asm_asl_z
>cbfd	61 73 6c 2e 7a					.text "asl.z"
.cc02					nt_asm_asl_zx:
>cc02	06 0c						.byte 6, IM+NN
>cc04	10 cc				                .word nt_asm_bcc
>cc06	96 a9 9b a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cc0a	61 73 6c 2e 7a 78				.text "asl.zx"
.cc10					nt_asm_bcc:
>cc10	03 0c						.byte 3, IM+NN
>cc12	1b cc				                .word nt_asm_bcs
>cc14	9b a9 a0 a9					.word xt_asm_bcc, z_asm_bcc
>cc18	62 63 63					.text "bcc"
.cc1b					nt_asm_bcs:
>cc1b	03 0c						.byte 3, IM+NN
>cc1d	26 cc				                .word nt_asm_beq
>cc1f	a0 a9 a7 a9					.word xt_asm_bcs, z_asm_bcs
>cc23	62 63 73					.text "bcs"
.cc26					nt_asm_beq:
>cc26	03 0c						.byte 3, IM+NN
>cc28	31 cc				                .word nt_asm_bit
>cc2a	a7 a9 ac a9					.word xt_asm_beq, z_asm_beq
>cc2e	62 65 71					.text "beq"
.cc31					nt_asm_bit:
>cc31	03 0c						.byte 3, IM+NN
>cc33	3c cc				                .word nt_asm_bit_h
>cc35	ac a9 b1 a9					.word xt_asm_bit, z_asm_bit
>cc39	62 69 74					.text "bit"
.cc3c					nt_asm_bit_h:
>cc3c	05 0c						.byte 5, IM+NN
>cc3e	49 cc				                .word nt_asm_bit_x
>cc40	b1 a9 b6 a9					.word xt_asm_bit_h, z_asm_bit_h
>cc44	62 69 74 2e 23					.text "bit.#"
.cc49					nt_asm_bit_x:
>cc49	05 0c						.byte 5, IM+NN
>cc4b	56 cc				                .word nt_asm_bit_z
>cc4d	b6 a9 bb a9					.word xt_asm_bit_x, z_asm_bit_x
>cc51	62 69 74 2e 78					.text "bit.x"
.cc56					nt_asm_bit_z:
>cc56	05 0c						.byte 5, IM+NN
>cc58	63 cc				                .word nt_asm_bit_zx
>cc5a	bb a9 c0 a9					.word xt_asm_bit_z, z_asm_bit_z
>cc5e	62 69 74 2e 7a					.text "bit.z"
.cc63					nt_asm_bit_zx:
>cc63	06 0c						.byte 6, IM+NN
>cc65	71 cc				                .word nt_asm_bmi
>cc67	c0 a9 c5 a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cc6b	62 69 74 2e 7a 78				.text "bit.zx"
.cc71					nt_asm_bmi:
>cc71	03 0c						.byte 3, IM+NN
>cc73	7c cc				                .word nt_asm_bne
>cc75	c5 a9 ca a9					.word xt_asm_bmi, z_asm_bmi
>cc79	62 6d 69					.text "bmi"
.cc7c					nt_asm_bne:
>cc7c	03 0c						.byte 3, IM+NN
>cc7e	87 cc				                .word nt_asm_bpl
>cc80	ca a9 cf a9					.word xt_asm_bne, z_asm_bne
>cc84	62 6e 65					.text "bne"
.cc87					nt_asm_bpl:
>cc87	03 0c						.byte 3, IM+NN
>cc89	92 cc				                .word nt_asm_bra
>cc8b	cf a9 d4 a9					.word xt_asm_bpl, z_asm_bpl
>cc8f	62 70 6c					.text "bpl"
.cc92					nt_asm_bra:
>cc92	03 0c						.byte 3, IM+NN
>cc94	9d cc				                .word nt_asm_brk
>cc96	d4 a9 d9 a9					.word xt_asm_bra, z_asm_bra
>cc9a	62 72 61					.text "bra"
.cc9d					nt_asm_brk:
>cc9d	03 0c						.byte 3, IM+NN
>cc9f	a8 cc				                .word nt_asm_bvc
>cca1	d9 a9 de a9					.word xt_asm_brk, z_asm_brk
>cca5	62 72 6b					.text "brk"
.cca8					nt_asm_bvc:
>cca8	03 0c						.byte 3, IM+NN
>ccaa	b3 cc				                .word nt_asm_bvs
>ccac	de a9 e3 a9					.word xt_asm_bvc, z_asm_bvc
>ccb0	62 76 63					.text "bvc"
.ccb3					nt_asm_bvs:
>ccb3	03 0c						.byte 3, IM+NN
>ccb5	be cc				                .word nt_asm_clc
>ccb7	e3 a9 e8 a9					.word xt_asm_bvs, z_asm_bvs
>ccbb	62 76 73					.text "bvs"
.ccbe					nt_asm_clc:
>ccbe	03 0c						.byte 3, IM+NN
>ccc0	c9 cc				                .word nt_asm_cld
>ccc2	e8 a9 ed a9					.word xt_asm_clc, z_asm_clc
>ccc6	63 6c 63					.text "clc"
.ccc9					nt_asm_cld:
>ccc9	03 0c						.byte 3, IM+NN
>cccb	d4 cc				                .word nt_asm_cli
>cccd	ed a9 f2 a9					.word xt_asm_cld, z_asm_cld
>ccd1	63 6c 64					.text "cld"
.ccd4					nt_asm_cli:
>ccd4	03 0c						.byte 3, IM+NN
>ccd6	df cc				                .word nt_asm_clv
>ccd8	f2 a9 f7 a9					.word xt_asm_cli, z_asm_cli
>ccdc	63 6c 69					.text "cli"
.ccdf					nt_asm_clv:
>ccdf	03 0c						.byte 3, IM+NN
>cce1	ea cc				                .word nt_asm_cmp
>cce3	f7 a9 fc a9					.word xt_asm_clv, z_asm_clv
>cce7	63 6c 76					.text "clv"
.ccea					nt_asm_cmp:
>ccea	03 0c						.byte 3, IM+NN
>ccec	f5 cc				                .word nt_asm_cmp_h
>ccee	fc a9 01 aa					.word xt_asm_cmp, z_asm_cmp
>ccf2	63 6d 70					.text "cmp"
.ccf5					nt_asm_cmp_h:
>ccf5	05 0c						.byte 5, IM+NN
>ccf7	02 cd				                .word nt_asm_cmp_x
>ccf9	01 aa 06 aa					.word xt_asm_cmp_h, z_asm_cmp_h
>ccfd	63 6d 70 2e 23					.text "cmp.#"
.cd02					nt_asm_cmp_x:
>cd02	05 0c						.byte 5, IM+NN
>cd04	0f cd				                .word nt_asm_cmp_y
>cd06	06 aa 0b aa					.word xt_asm_cmp_x, z_asm_cmp_x
>cd0a	63 6d 70 2e 78					.text "cmp.x"
.cd0f					nt_asm_cmp_y:
>cd0f	05 0c						.byte 5, IM+NN
>cd11	1c cd				                .word nt_asm_cmp_z
>cd13	0b aa 10 aa					.word xt_asm_cmp_y, z_asm_cmp_y
>cd17	63 6d 70 2e 79					.text "cmp.y"
.cd1c					nt_asm_cmp_z:
>cd1c	05 0c						.byte 5, IM+NN
>cd1e	29 cd				                .word nt_asm_cmp_zi
>cd20	10 aa 15 aa					.word xt_asm_cmp_z, z_asm_cmp_z
>cd24	63 6d 70 2e 7a					.text "cmp.z"
.cd29					nt_asm_cmp_zi:
>cd29	06 0c						.byte 6, IM+NN
>cd2b	37 cd				                .word nt_asm_cmp_ziy
>cd2d	15 aa 1a aa					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd31	63 6d 70 2e 7a 69				.text "cmp.zi"
.cd37					nt_asm_cmp_ziy:
>cd37	07 0c						.byte 7, IM+NN
>cd39	46 cd				                .word nt_asm_cmp_zx
>cd3b	1a aa 1f aa					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd3f	63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd46					nt_asm_cmp_zx:
>cd46	06 0c						.byte 6, IM+NN
>cd48	54 cd				                .word nt_asm_cmp_zxi
>cd4a	1f aa 24 aa					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd4e	63 6d 70 2e 7a 78				.text "cmp.zx"
.cd54					nt_asm_cmp_zxi:
>cd54	07 0c						.byte 7, IM+NN
>cd56	63 cd				                .word nt_asm_cpx
>cd58	24 aa 29 aa					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd5c	63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd63					nt_asm_cpx:
>cd63	03 0c						.byte 3, IM+NN
>cd65	6e cd				                .word nt_asm_cpx_h
>cd67	29 aa 2e aa					.word xt_asm_cpx, z_asm_cpx
>cd6b	63 70 78					.text "cpx"
.cd6e					nt_asm_cpx_h:
>cd6e	05 0c						.byte 5, IM+NN
>cd70	7b cd				                .word nt_asm_cpx_z
>cd72	2e aa 33 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>cd76	63 70 78 2e 23					.text "cpx.#"
.cd7b					nt_asm_cpx_z:
>cd7b	05 0c						.byte 5, IM+NN
>cd7d	88 cd				                .word nt_asm_cpy
>cd7f	33 aa 38 aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cd83	63 70 78 2e 7a					.text "cpx.z"
.cd88					nt_asm_cpy:
>cd88	03 0c						.byte 3, IM+NN
>cd8a	93 cd				                .word nt_asm_cpy_h
>cd8c	38 aa 3f aa					.word xt_asm_cpy, z_asm_cpy
>cd90	63 70 79					.text "cpy"
.cd93					nt_asm_cpy_h:
>cd93	05 0c						.byte 5, IM+NN
>cd95	a0 cd				                .word nt_asm_cpy_z
>cd97	3f aa 44 aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cd9b	63 70 79 2e 23					.text "cpy.#"
.cda0					nt_asm_cpy_z:
>cda0	05 0c						.byte 5, IM+NN
>cda2	ad cd				                .word nt_asm_dec
>cda4	44 aa 49 aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cda8	63 70 79 2e 7a					.text "cpy.z"
.cdad					nt_asm_dec:
>cdad	03 0c						.byte 3, IM+NN
>cdaf	b8 cd				                .word nt_asm_dec_a
>cdb1	49 aa 4e aa					.word xt_asm_dec, z_asm_dec
>cdb5	64 65 63					.text "dec"
.cdb8					nt_asm_dec_a:
>cdb8	05 0c						.byte 5, IM+NN
>cdba	c5 cd				                .word nt_asm_dec_x
>cdbc	4e aa 53 aa					.word xt_asm_dec_a, z_asm_dec_a
>cdc0	64 65 63 2e 61					.text "dec.a"
.cdc5					nt_asm_dec_x:
>cdc5	05 0c						.byte 5, IM+NN
>cdc7	d2 cd				                .word nt_asm_dec_z
>cdc9	53 aa 58 aa					.word xt_asm_dec_x, z_asm_dec_x
>cdcd	64 65 63 2e 78					.text "dec.x"
.cdd2					nt_asm_dec_z:
>cdd2	05 0c						.byte 5, IM+NN
>cdd4	df cd				                .word nt_asm_dec_zx
>cdd6	58 aa 5d aa					.word xt_asm_dec_z, z_asm_dec_z
>cdda	64 65 63 2e 7a					.text "dec.z"
.cddf					nt_asm_dec_zx:
>cddf	06 0c						.byte 6, IM+NN
>cde1	ed cd				                .word nt_asm_dex
>cde3	5d aa 62 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cde7	64 65 63 2e 7a 78				.text "dec.zx"
.cded					nt_asm_dex:
>cded	03 0c						.byte 3, IM+NN
>cdef	f8 cd				                .word nt_asm_dey
>cdf1	62 aa 67 aa					.word xt_asm_dex, z_asm_dex
>cdf5	64 65 78					.text "dex"
.cdf8					nt_asm_dey:
>cdf8	03 0c						.byte 3, IM+NN
>cdfa	03 ce				                .word nt_asm_eor
>cdfc	67 aa 6c aa					.word xt_asm_dey, z_asm_dey
>ce00	64 65 79					.text "dey"
.ce03					nt_asm_eor:
>ce03	03 0c						.byte 3, IM+NN
>ce05	0e ce				                .word nt_asm_eor_h
>ce07	6c aa 71 aa					.word xt_asm_eor, z_asm_eor
>ce0b	65 6f 72					.text "eor"
.ce0e					nt_asm_eor_h:
>ce0e	05 0c						.byte 5, IM+NN
>ce10	1b ce				                .word nt_asm_eor_x
>ce12	71 aa 76 aa					.word xt_asm_eor_h, z_asm_eor_h
>ce16	65 6f 72 2e 23					.text "eor.#"
.ce1b					nt_asm_eor_x:
>ce1b	05 0c						.byte 5, IM+NN
>ce1d	28 ce				                .word nt_asm_eor_y
>ce1f	76 aa 7b aa					.word xt_asm_eor_x, z_asm_eor_x
>ce23	65 6f 72 2e 78					.text "eor.x"
.ce28					nt_asm_eor_y:
>ce28	05 0c						.byte 5, IM+NN
>ce2a	35 ce				                .word nt_asm_eor_z
>ce2c	7b aa 80 aa					.word xt_asm_eor_y, z_asm_eor_y
>ce30	65 6f 72 2e 79					.text "eor.y"
.ce35					nt_asm_eor_z:
>ce35	05 0c						.byte 5, IM+NN
>ce37	42 ce				                .word nt_asm_eor_zi
>ce39	80 aa 85 aa					.word xt_asm_eor_z, z_asm_eor_z
>ce3d	65 6f 72 2e 7a					.text "eor.z"
.ce42					nt_asm_eor_zi:
>ce42	06 0c						.byte 6, IM+NN
>ce44	50 ce				                .word nt_asm_eor_ziy
>ce46	85 aa 8a aa					.word xt_asm_eor_zi, z_asm_eor_zi
>ce4a	65 6f 72 2e 7a 69				.text "eor.zi"
.ce50					nt_asm_eor_ziy:
>ce50	07 0c						.byte 7, IM+NN
>ce52	5f ce				                .word nt_asm_eor_zx
>ce54	8a aa 8f aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce58	65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce5f					nt_asm_eor_zx:
>ce5f	06 0c						.byte 6, IM+NN
>ce61	6d ce				                .word nt_asm_eor_zxi
>ce63	8f aa 94 aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce67	65 6f 72 2e 7a 78				.text "eor.zx"
.ce6d					nt_asm_eor_zxi:
>ce6d	07 0c						.byte 7, IM+NN
>ce6f	7c ce				                .word nt_asm_inc
>ce71	94 aa 99 aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce75	65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce7c					nt_asm_inc:
>ce7c	03 0c						.byte 3, IM+NN
>ce7e	87 ce				                .word nt_asm_inc_a
>ce80	99 aa 9e aa					.word xt_asm_inc, z_asm_inc
>ce84	69 6e 63					.text "inc"
.ce87					nt_asm_inc_a:
>ce87	05 0c						.byte 5, IM+NN
>ce89	94 ce				                .word nt_asm_inc_x
>ce8b	9e aa a3 aa					.word xt_asm_inc_a, z_asm_inc_a
>ce8f	69 6e 63 2e 61					.text "inc.a"
.ce94					nt_asm_inc_x:
>ce94	05 0c						.byte 5, IM+NN
>ce96	a1 ce				                .word nt_asm_inc_z
>ce98	a3 aa a8 aa					.word xt_asm_inc_x, z_asm_inc_x
>ce9c	69 6e 63 2e 78					.text "inc.x"
.cea1					nt_asm_inc_z:
>cea1	05 0c						.byte 5, IM+NN
>cea3	ae ce				                .word nt_asm_inc_zx
>cea5	a8 aa ad aa					.word xt_asm_inc_z, z_asm_inc_z
>cea9	69 6e 63 2e 7a					.text "inc.z"
.ceae					nt_asm_inc_zx:
>ceae	06 0c						.byte 6, IM+NN
>ceb0	bc ce				                .word nt_asm_inx
>ceb2	ad aa b2 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>ceb6	69 6e 63 2e 7a 78				.text "inc.zx"
.cebc					nt_asm_inx:
>cebc	03 0c						.byte 3, IM+NN
>cebe	c7 ce				                .word nt_asm_iny
>cec0	b2 aa b7 aa					.word xt_asm_inx, z_asm_inx
>cec4	69 6e 78					.text "inx"
.cec7					nt_asm_iny:
>cec7	03 0c						.byte 3, IM+NN
>cec9	d2 ce				                .word nt_asm_jmp
>cecb	b7 aa bc aa					.word xt_asm_iny, z_asm_iny
>cecf	69 6e 79					.text "iny"
.ced2					nt_asm_jmp:
>ced2	03 0c						.byte 3, IM+NN
>ced4	dd ce				                .word nt_asm_jmp_i
>ced6	bc aa c1 aa					.word xt_asm_jmp, z_asm_jmp
>ceda	6a 6d 70					.text "jmp"
.cedd					nt_asm_jmp_i:
>cedd	05 0c						.byte 5, IM+NN
>cedf	ea ce				                .word nt_asm_jmp_xi
>cee1	c1 aa c6 aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cee5	6a 6d 70 2e 69					.text "jmp.i"
.ceea					nt_asm_jmp_xi:
>ceea	06 0c						.byte 6, IM+NN
>ceec	f8 ce				                .word nt_asm_jsr
>ceee	c6 aa cb aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cef2	6a 6d 70 2e 78 69				.text "jmp.xi"
.cef8					nt_asm_jsr:
>cef8	03 0c						.byte 3, IM+NN
>cefa	03 cf				                .word nt_asm_lda
>cefc	cb aa d0 aa					.word xt_asm_jsr, z_asm_jsr
>cf00	6a 73 72					.text "jsr"
.cf03					nt_asm_lda:
>cf03	03 0c						.byte 3, IM+NN
>cf05	0e cf				                .word nt_asm_lda_h
>cf07	d0 aa d5 aa					.word xt_asm_lda, z_asm_lda
>cf0b	6c 64 61					.text "lda"
.cf0e					nt_asm_lda_h:
>cf0e	05 0c						.byte 5, IM+NN
>cf10	1b cf				                .word nt_asm_lda_x
>cf12	d5 aa da aa					.word xt_asm_lda_h, z_asm_lda_h
>cf16	6c 64 61 2e 23					.text "lda.#"
.cf1b					nt_asm_lda_x:
>cf1b	05 0c						.byte 5, IM+NN
>cf1d	28 cf				                .word nt_asm_lda_y
>cf1f	da aa df aa					.word xt_asm_lda_x, z_asm_lda_x
>cf23	6c 64 61 2e 78					.text "lda.x"
.cf28					nt_asm_lda_y:
>cf28	05 0c						.byte 5, IM+NN
>cf2a	35 cf				                .word nt_asm_lda_z
>cf2c	df aa e4 aa					.word xt_asm_lda_y, z_asm_lda_y
>cf30	6c 64 61 2e 79					.text "lda.y"
.cf35					nt_asm_lda_z:
>cf35	05 0c						.byte 5, IM+NN
>cf37	42 cf				                .word nt_asm_lda_zi
>cf39	e4 aa e9 aa					.word xt_asm_lda_z, z_asm_lda_z
>cf3d	6c 64 61 2e 7a					.text "lda.z"
.cf42					nt_asm_lda_zi:
>cf42	06 0c						.byte 6, IM+NN
>cf44	50 cf				                .word nt_asm_lda_ziy
>cf46	e9 aa ee aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cf4a	6c 64 61 2e 7a 69				.text "lda.zi"
.cf50					nt_asm_lda_ziy:
>cf50	07 0c						.byte 7, IM+NN
>cf52	5f cf				                .word nt_asm_lda_zx
>cf54	ee aa f3 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf58	6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf5f					nt_asm_lda_zx:
>cf5f	06 0c						.byte 6, IM+NN
>cf61	6d cf				                .word nt_asm_lda_zxi
>cf63	f3 aa f8 aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cf67	6c 64 61 2e 7a 78				.text "lda.zx"
.cf6d					nt_asm_lda_zxi:
>cf6d	07 0c						.byte 7, IM+NN
>cf6f	7c cf				                .word nt_asm_ldx
>cf71	f8 aa fd aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf75	6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf7c					nt_asm_ldx:
>cf7c	03 0c						.byte 3, IM+NN
>cf7e	87 cf				                .word nt_asm_ldx_h
>cf80	fd aa 02 ab					.word xt_asm_ldx, z_asm_ldx
>cf84	6c 64 78					.text "ldx"
.cf87					nt_asm_ldx_h:
>cf87	05 0c						.byte 5, IM+NN
>cf89	94 cf				                .word nt_asm_ldx_y
>cf8b	02 ab 07 ab					.word xt_asm_ldx_h, z_asm_ldx_h
>cf8f	6c 64 78 2e 23					.text "ldx.#"
.cf94					nt_asm_ldx_y:
>cf94	05 0c						.byte 5, IM+NN
>cf96	a1 cf				                .word nt_asm_ldx_z
>cf98	07 ab 0c ab					.word xt_asm_ldx_y, z_asm_ldx_y
>cf9c	6c 64 78 2e 79					.text "ldx.y"
.cfa1					nt_asm_ldx_z:
>cfa1	05 0c						.byte 5, IM+NN
>cfa3	ae cf				                .word nt_asm_ldx_zy
>cfa5	0c ab 11 ab					.word xt_asm_ldx_z, z_asm_ldx_z
>cfa9	6c 64 78 2e 7a					.text "ldx.z"
.cfae					nt_asm_ldx_zy:
>cfae	06 0c						.byte 6, IM+NN
>cfb0	bc cf				                .word nt_asm_ldy
>cfb2	11 ab 16 ab					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfb6	6c 64 78 2e 7a 79				.text "ldx.zy"
.cfbc					nt_asm_ldy:
>cfbc	03 0c						.byte 3, IM+NN
>cfbe	c7 cf				                .word nt_asm_ldy_h
>cfc0	16 ab 1b ab					.word xt_asm_ldy, z_asm_ldy
>cfc4	6c 64 79					.text "ldy"
.cfc7					nt_asm_ldy_h:
>cfc7	05 0c						.byte 5, IM+NN
>cfc9	d4 cf				                .word nt_asm_ldy_x
>cfcb	1b ab 20 ab					.word xt_asm_ldy_h, z_asm_ldy_h
>cfcf	6c 64 79 2e 23					.text "ldy.#"
.cfd4					nt_asm_ldy_x:
>cfd4	05 0c						.byte 5, IM+NN
>cfd6	e1 cf				                .word nt_asm_ldy_z
>cfd8	20 ab 25 ab					.word xt_asm_ldy_x, z_asm_ldy_x
>cfdc	6c 64 79 2e 78					.text "ldy.x"
.cfe1					nt_asm_ldy_z:
>cfe1	05 0c						.byte 5, IM+NN
>cfe3	ee cf				                .word nt_asm_ldy_zx
>cfe5	25 ab 2a ab					.word xt_asm_ldy_z, z_asm_ldy_z
>cfe9	6c 64 79 2e 7a					.text "ldy.z"
.cfee					nt_asm_ldy_zx:
>cfee	06 0c						.byte 6, IM+NN
>cff0	fc cf				                .word nt_asm_lsr
>cff2	2a ab 2f ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cff6	6c 64 79 2e 7a 78				.text "ldy.zx"
.cffc					nt_asm_lsr:
>cffc	03 0c						.byte 3, IM+NN
>cffe	07 d0				                .word nt_asm_lsr_a
>d000	2f ab 34 ab					.word xt_asm_lsr, z_asm_lsr
>d004	6c 73 72					.text "lsr"
.d007					nt_asm_lsr_a:
>d007	05 0c						.byte 5, IM+NN
>d009	14 d0				                .word nt_asm_lsr_x
>d00b	34 ab 39 ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d00f	6c 73 72 2e 61					.text "lsr.a"
.d014					nt_asm_lsr_x:
>d014	05 0c						.byte 5, IM+NN
>d016	21 d0				                .word nt_asm_lsr_z
>d018	39 ab 3e ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d01c	6c 73 72 2e 78					.text "lsr.x"
.d021					nt_asm_lsr_z:
>d021	05 0c						.byte 5, IM+NN
>d023	2e d0				                .word nt_asm_lsr_zx
>d025	3e ab 43 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d029	6c 73 72 2e 7a					.text "lsr.z"
.d02e					nt_asm_lsr_zx:
>d02e	06 0c						.byte 6, IM+NN
>d030	3c d0				                .word nt_asm_nop
>d032	43 ab 48 ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d036	6c 73 72 2e 7a 78				.text "lsr.zx"
.d03c					nt_asm_nop:
>d03c	03 0c						.byte 3, IM+NN
>d03e	47 d0				                .word nt_asm_ora
>d040	48 ab 4d ab					.word xt_asm_nop, z_asm_nop
>d044	6e 6f 70					.text "nop"
.d047					nt_asm_ora:
>d047	03 0c						.byte 3, IM+NN
>d049	52 d0				                .word nt_asm_ora_h
>d04b	4d ab 52 ab					.word xt_asm_ora, z_asm_ora
>d04f	6f 72 61					.text "ora"
.d052					nt_asm_ora_h:
>d052	05 0c						.byte 5, IM+NN
>d054	5f d0				                .word nt_asm_ora_x
>d056	52 ab 57 ab					.word xt_asm_ora_h, z_asm_ora_h
>d05a	6f 72 61 2e 23					.text "ora.#"
.d05f					nt_asm_ora_x:
>d05f	05 0c						.byte 5, IM+NN
>d061	6c d0				                .word nt_asm_ora_y
>d063	57 ab 5c ab					.word xt_asm_ora_x, z_asm_ora_x
>d067	6f 72 61 2e 78					.text "ora.x"
.d06c					nt_asm_ora_y:
>d06c	05 0c						.byte 5, IM+NN
>d06e	79 d0				                .word nt_asm_ora_z
>d070	5c ab 61 ab					.word xt_asm_ora_y, z_asm_ora_y
>d074	6f 72 61 2e 79					.text "ora.y"
.d079					nt_asm_ora_z:
>d079	05 0c						.byte 5, IM+NN
>d07b	86 d0				                .word nt_asm_ora_zi
>d07d	61 ab 66 ab					.word xt_asm_ora_z, z_asm_ora_z
>d081	6f 72 61 2e 7a					.text "ora.z"
.d086					nt_asm_ora_zi:
>d086	06 0c						.byte 6, IM+NN
>d088	94 d0				                .word nt_asm_ora_ziy
>d08a	66 ab 6d ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d08e	6f 72 61 2e 7a 69				.text "ora.zi"
.d094					nt_asm_ora_ziy:
>d094	07 0c						.byte 7, IM+NN
>d096	a3 d0				                .word nt_asm_ora_zx
>d098	6d ab 72 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d09c	6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d0a3					nt_asm_ora_zx:
>d0a3	06 0c						.byte 6, IM+NN
>d0a5	b1 d0				                .word nt_asm_ora_zxi
>d0a7	72 ab 77 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d0ab	6f 72 61 2e 7a 78				.text "ora.zx"
.d0b1					nt_asm_ora_zxi:
>d0b1	07 0c						.byte 7, IM+NN
>d0b3	c0 d0				                .word nt_asm_pha
>d0b5	77 ab 7c ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0b9	6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0c0					nt_asm_pha:
>d0c0	03 0c						.byte 3, IM+NN
>d0c2	cb d0				                .word nt_asm_php
>d0c4	7c ab 81 ab					.word xt_asm_pha, z_asm_pha
>d0c8	70 68 61					.text "pha"
.d0cb					nt_asm_php:
>d0cb	03 0c						.byte 3, IM+NN
>d0cd	d6 d0				                .word nt_asm_phx
>d0cf	81 ab 86 ab					.word xt_asm_php, z_asm_php
>d0d3	70 68 70					.text "php"
.d0d6					nt_asm_phx:
>d0d6	03 0c						.byte 3, IM+NN
>d0d8	e1 d0				                .word nt_asm_phy
>d0da	86 ab 8b ab					.word xt_asm_phx, z_asm_phx
>d0de	70 68 78					.text "phx"
.d0e1					nt_asm_phy:
>d0e1	03 0c						.byte 3, IM+NN
>d0e3	ec d0				                .word nt_asm_pla
>d0e5	8b ab 90 ab					.word xt_asm_phy, z_asm_phy
>d0e9	70 68 79					.text "phy"
.d0ec					nt_asm_pla:
>d0ec	03 0c						.byte 3, IM+NN
>d0ee	f7 d0				                .word nt_asm_plp
>d0f0	90 ab 95 ab					.word xt_asm_pla, z_asm_pla
>d0f4	70 6c 61					.text "pla"
.d0f7					nt_asm_plp:
>d0f7	03 0c						.byte 3, IM+NN
>d0f9	02 d1				                .word nt_asm_plx
>d0fb	95 ab 9a ab					.word xt_asm_plp, z_asm_plp
>d0ff	70 6c 70					.text "plp"
.d102					nt_asm_plx:
>d102	03 0c						.byte 3, IM+NN
>d104	0d d1				                .word nt_asm_ply
>d106	9a ab 9f ab					.word xt_asm_plx, z_asm_plx
>d10a	70 6c 78					.text "plx"
.d10d					nt_asm_ply:
>d10d	03 0c						.byte 3, IM+NN
>d10f	18 d1				                .word nt_asm_rol
>d111	9f ab a4 ab					.word xt_asm_ply, z_asm_ply
>d115	70 6c 79					.text "ply"
.d118					nt_asm_rol:
>d118	03 0c						.byte 3, IM+NN
>d11a	23 d1				                .word nt_asm_rol_a
>d11c	a4 ab a9 ab					.word xt_asm_rol, z_asm_rol
>d120	72 6f 6c					.text "rol"
.d123					nt_asm_rol_a:
>d123	05 0c						.byte 5, IM+NN
>d125	30 d1				                .word nt_asm_rol_x
>d127	a9 ab ae ab					.word xt_asm_rol_a, z_asm_rol_a
>d12b	72 6f 6c 2e 61					.text "rol.a"
.d130					nt_asm_rol_x:
>d130	05 0c						.byte 5, IM+NN
>d132	3d d1				                .word nt_asm_rol_z
>d134	ae ab b3 ab					.word xt_asm_rol_x, z_asm_rol_x
>d138	72 6f 6c 2e 78					.text "rol.x"
.d13d					nt_asm_rol_z:
>d13d	05 0c						.byte 5, IM+NN
>d13f	4a d1				                .word nt_asm_rol_zx
>d141	b3 ab b8 ab					.word xt_asm_rol_z, z_asm_rol_z
>d145	72 6f 6c 2e 7a					.text "rol.z"
.d14a					nt_asm_rol_zx:
>d14a	06 0c						.byte 6, IM+NN
>d14c	58 d1				                .word nt_asm_ror
>d14e	b8 ab bd ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d152	72 6f 6c 2e 7a 78				.text "rol.zx"
.d158					nt_asm_ror:
>d158	03 0c						.byte 3, IM+NN
>d15a	63 d1				                .word nt_asm_ror_a
>d15c	bd ab c2 ab					.word xt_asm_ror, z_asm_ror
>d160	72 6f 72					.text "ror"
.d163					nt_asm_ror_a:
>d163	05 0c						.byte 5, IM+NN
>d165	70 d1				                .word nt_asm_ror_x
>d167	c2 ab c7 ab					.word xt_asm_ror_a, z_asm_ror_a
>d16b	72 6f 72 2e 61					.text "ror.a"
.d170					nt_asm_ror_x:
>d170	05 0c						.byte 5, IM+NN
>d172	7d d1				                .word nt_asm_ror_z
>d174	c7 ab cc ab					.word xt_asm_ror_x, z_asm_ror_x
>d178	72 6f 72 2e 78					.text "ror.x"
.d17d					nt_asm_ror_z:
>d17d	05 0c						.byte 5, IM+NN
>d17f	8a d1				                .word nt_asm_ror_zx
>d181	cc ab d1 ab					.word xt_asm_ror_z, z_asm_ror_z
>d185	72 6f 72 2e 7a					.text "ror.z"
.d18a					nt_asm_ror_zx:
>d18a	06 0c						.byte 6, IM+NN
>d18c	98 d1				                .word nt_asm_rti
>d18e	d1 ab d6 ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d192	72 6f 72 2e 7a 78				.text "ror.zx"
.d198					nt_asm_rti:
>d198	03 0c						.byte 3, IM+NN
>d19a	a3 d1				                .word nt_asm_rts
>d19c	d6 ab db ab					.word xt_asm_rti, z_asm_rti
>d1a0	72 74 69					.text "rti"
.d1a3					nt_asm_rts:
>d1a3	03 0c						.byte 3, IM+NN
>d1a5	ae d1				                .word nt_asm_sbc
>d1a7	db ab e0 ab					.word xt_asm_rts, z_asm_rts
>d1ab	72 74 73					.text "rts"
.d1ae					nt_asm_sbc:
>d1ae	03 0c						.byte 3, IM+NN
>d1b0	b9 d1				                .word nt_asm_sbc_h
>d1b2	e0 ab e5 ab					.word xt_asm_sbc, z_asm_sbc
>d1b6	73 62 63					.text "sbc"
.d1b9					nt_asm_sbc_h:
>d1b9	05 0c						.byte 5, IM+NN
>d1bb	c6 d1				                .word nt_asm_sbc_x
>d1bd	e5 ab ea ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d1c1	73 62 63 2e 23					.text "sbc.#"
.d1c6					nt_asm_sbc_x:
>d1c6	05 0c						.byte 5, IM+NN
>d1c8	d3 d1				                .word nt_asm_sbc_y
>d1ca	ea ab ef ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d1ce	73 62 63 2e 78					.text "sbc.x"
.d1d3					nt_asm_sbc_y:
>d1d3	05 0c						.byte 5, IM+NN
>d1d5	e0 d1				                .word nt_asm_sbc_z
>d1d7	ef ab f4 ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d1db	73 62 63 2e 79					.text "sbc.y"
.d1e0					nt_asm_sbc_z:
>d1e0	05 0c						.byte 5, IM+NN
>d1e2	ed d1				                .word nt_asm_sbc_zi
>d1e4	f4 ab f9 ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d1e8	73 62 63 2e 7a					.text "sbc.z"
.d1ed					nt_asm_sbc_zi:
>d1ed	06 0c						.byte 6, IM+NN
>d1ef	fb d1				                .word nt_asm_sbc_ziy
>d1f1	f9 ab fe ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d1f5	73 62 63 2e 7a 69				.text "sbc.zi"
.d1fb					nt_asm_sbc_ziy:
>d1fb	07 0c						.byte 7, IM+NN
>d1fd	0a d2				                .word nt_asm_sbc_zx
>d1ff	fe ab 03 ac					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d203	73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d20a					nt_asm_sbc_zx:
>d20a	06 0c						.byte 6, IM+NN
>d20c	18 d2				                .word nt_asm_sbc_zxi
>d20e	03 ac 08 ac					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d212	73 62 63 2e 7a 78				.text "sbc.zx"
.d218					nt_asm_sbc_zxi:
>d218	07 0c						.byte 7, IM+NN
>d21a	27 d2				                .word nt_asm_sec
>d21c	08 ac 0c ac					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d220	73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d227					nt_asm_sec:
>d227	03 0c						.byte 3, IM+NN
>d229	32 d2				                .word nt_asm_sed
>d22b	0c ac 10 ac					.word xt_asm_sec, z_asm_sec
>d22f	73 65 63					.text "sec"
.d232					nt_asm_sed:
>d232	03 0c						.byte 3, IM+NN
>d234	3d d2				                .word nt_asm_sei
>d236	10 ac 14 ac					.word xt_asm_sed, z_asm_sed
>d23a	73 65 64					.text "sed"
.d23d					nt_asm_sei:
>d23d	03 0c						.byte 3, IM+NN
>d23f	48 d2				                .word nt_asm_sta
>d241	14 ac 18 ac					.word xt_asm_sei, z_asm_sei
>d245	73 65 69					.text "sei"
.d248					nt_asm_sta:
>d248	03 0c						.byte 3, IM+NN
>d24a	53 d2				                .word nt_asm_sta_x
>d24c	18 ac 1c ac					.word xt_asm_sta, z_asm_sta
>d250	73 74 61					.text "sta"
.d253					nt_asm_sta_x:
>d253	05 0c						.byte 5, IM+NN
>d255	60 d2				                .word nt_asm_sta_y
>d257	1c ac 20 ac					.word xt_asm_sta_x, z_asm_sta_x
>d25b	73 74 61 2e 78					.text "sta.x"
.d260					nt_asm_sta_y:
>d260	05 0c						.byte 5, IM+NN
>d262	6d d2				                .word nt_asm_sta_z
>d264	20 ac 24 ac					.word xt_asm_sta_y, z_asm_sta_y
>d268	73 74 61 2e 79					.text "sta.y"
.d26d					nt_asm_sta_z:
>d26d	05 0c						.byte 5, IM+NN
>d26f	7a d2				                .word nt_asm_sta_zi
>d271	24 ac 28 ac					.word xt_asm_sta_z, z_asm_sta_z
>d275	73 74 61 2e 7a					.text "sta.z"
.d27a					nt_asm_sta_zi:
>d27a	06 0c						.byte 6, IM+NN
>d27c	88 d2				                .word nt_asm_sta_ziy
>d27e	28 ac 2c ac					.word xt_asm_sta_zi, z_asm_sta_zi
>d282	73 74 61 2e 7a 69				.text "sta.zi"
.d288					nt_asm_sta_ziy:
>d288	07 0c						.byte 7, IM+NN
>d28a	97 d2				                .word nt_asm_sta_zx
>d28c	2c ac 30 ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d290	73 74 61 2e 7a 69 79				.text "sta.ziy"
.d297					nt_asm_sta_zx:
>d297	06 0c						.byte 6, IM+NN
>d299	a5 d2				                .word nt_asm_sta_zxi
>d29b	30 ac 34 ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d29f	73 74 61 2e 7a 78				.text "sta.zx"
.d2a5					nt_asm_sta_zxi:
>d2a5	07 0c						.byte 7, IM+NN
>d2a7	b4 d2				                .word nt_asm_stx
>d2a9	34 ac 38 ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2ad	73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2b4					nt_asm_stx:
>d2b4	03 0c						.byte 3, IM+NN
>d2b6	bf d2				                .word nt_asm_stx_z
>d2b8	38 ac 3c ac					.word xt_asm_stx, z_asm_stx
>d2bc	73 74 78					.text "stx"
.d2bf					nt_asm_stx_z:
>d2bf	05 0c						.byte 5, IM+NN
>d2c1	cc d2				                .word nt_asm_stx_zy
>d2c3	3c ac 40 ac					.word xt_asm_stx_z, z_asm_stx_z
>d2c7	73 74 78 2e 7a					.text "stx.z"
.d2cc					nt_asm_stx_zy:
>d2cc	06 0c						.byte 6, IM+NN
>d2ce	da d2				                .word nt_asm_sty
>d2d0	40 ac 44 ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d2d4	73 74 78 2e 7a 79				.text "stx.zy"
.d2da					nt_asm_sty:
>d2da	03 0c						.byte 3, IM+NN
>d2dc	e5 d2				                .word nt_asm_sty_z
>d2de	44 ac 48 ac					.word xt_asm_sty, z_asm_sty
>d2e2	73 74 79					.text "sty"
.d2e5					nt_asm_sty_z:
>d2e5	05 0c						.byte 5, IM+NN
>d2e7	f2 d2				                .word nt_asm_sty_zx
>d2e9	48 ac 4c ac					.word xt_asm_sty_z, z_asm_sty_z
>d2ed	73 74 79 2e 7a					.text "sty.z"
.d2f2					nt_asm_sty_zx:
>d2f2	06 0c						.byte 6, IM+NN
>d2f4	00 d3				                .word nt_asm_stz
>d2f6	4c ac 50 ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d2fa	73 74 79 2e 7a 78				.text "sty.zx"
.d300					nt_asm_stz:
>d300	03 0c						.byte 3, IM+NN
>d302	0b d3				                .word nt_asm_stz_x
>d304	50 ac 54 ac					.word xt_asm_stz, z_asm_stz
>d308	73 74 7a					.text "stz"
.d30b					nt_asm_stz_x:
>d30b	05 0c						.byte 5, IM+NN
>d30d	18 d3				                .word nt_asm_stz_z
>d30f	54 ac 58 ac					.word xt_asm_stz_x, z_asm_stz_x
>d313	73 74 7a 2e 78					.text "stz.x"
.d318					nt_asm_stz_z:
>d318	05 0c						.byte 5, IM+NN
>d31a	25 d3				                .word nt_asm_stz_zx
>d31c	58 ac 5c ac					.word xt_asm_stz_z, z_asm_stz_z
>d320	73 74 7a 2e 7a					.text "stz.z"
.d325					nt_asm_stz_zx:
>d325	06 0c						.byte 6, IM+NN
>d327	33 d3				                .word nt_asm_tax
>d329	5c ac 60 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d32d	73 74 7a 2e 7a 78				.text "stz.zx"
.d333					nt_asm_tax:
>d333	03 0c						.byte 3, IM+NN
>d335	3e d3				                .word nt_asm_tay
>d337	60 ac 64 ac					.word xt_asm_tax, z_asm_tax
>d33b	74 61 78					.text "tax"
.d33e					nt_asm_tay:
>d33e	03 0c						.byte 3, IM+NN
>d340	49 d3				                .word nt_asm_trb
>d342	64 ac 68 ac					.word xt_asm_tay, z_asm_tay
>d346	74 61 79					.text "tay"
.d349					nt_asm_trb:
>d349	03 0c						.byte 3, IM+NN
>d34b	54 d3				                .word nt_asm_trb_z
>d34d	68 ac 6c ac					.word xt_asm_trb, z_asm_trb
>d351	74 72 62					.text "trb"
.d354					nt_asm_trb_z:
>d354	05 0c						.byte 5, IM+NN
>d356	61 d3				                .word nt_asm_tsb
>d358	6c ac 70 ac					.word xt_asm_trb_z, z_asm_trb_z
>d35c	74 72 62 2e 7a					.text "trb.z"
.d361					nt_asm_tsb:
>d361	03 0c						.byte 3, IM+NN
>d363	6c d3				                .word nt_asm_tsb_z
>d365	70 ac 74 ac					.word xt_asm_tsb, z_asm_tsb
>d369	74 73 62					.text "tsb"
.d36c					nt_asm_tsb_z:
>d36c	05 0c						.byte 5, IM+NN
>d36e	79 d3				                .word nt_asm_tsx
>d370	74 ac 78 ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d374	74 73 62 2e 7a					.text "tsb.z"
.d379					nt_asm_tsx:
>d379	03 0c						.byte 3, IM+NN
>d37b	84 d3				                .word nt_asm_txa
>d37d	78 ac 7c ac					.word xt_asm_tsx, z_asm_tsx
>d381	74 73 78					.text "tsx"
.d384					nt_asm_txa:
>d384	03 0c						.byte 3, IM+NN
>d386	8f d3				                .word nt_asm_txs
>d388	7c ac 80 ac					.word xt_asm_txa, z_asm_txa
>d38c	74 78 61					.text "txa"
.d38f					nt_asm_txs:
>d38f	03 0c						.byte 3, IM+NN
>d391	9a d3				                .word nt_asm_tya
>d393	80 ac 84 ac					.word xt_asm_txs, z_asm_txs
>d397	74 78 73					.text "txs"
.d39a					nt_asm_tya:
>d39a	03 0c						.byte 3, IM+NN
>d39c	a5 d3				                .word nt_asm_arrow
>d39e	84 ac 88 ac					.word xt_asm_tya, z_asm_tya
>d3a2	74 79 61					.text "tya"
.d3a5					nt_asm_arrow:
>d3a5	03 04				                .byte 3, IM
>d3a7	b0 d3				                .word nt_asm_back_jump
>d3a9	7e 91 88 91			                .word xt_asm_arrow, z_asm_arrow
>d3ad	2d 2d 3e			                .text "-->"
.d3b0					nt_asm_back_jump:
>d3b0	02 04				                .byte 2, IM
>d3b2	ba d3				                .word nt_asm_back_branch
>d3b4	d9 ac d9 ac			                .word xt_asm_back_jump, z_asm_back_jump
>d3b8	3c 6a				                .text "<j"
.d3ba					nt_asm_back_branch:
>d3ba	02 04				                .byte 2, IM
>d3bc	c4 d3				                .word nt_asm_push_a
>d3be	da ac e2 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d3c2	3c 62				                .text "<b"
.d3c4					nt_asm_push_a:
>d3c4	06 0c				                .byte 6, IM+NN
>d3c6	00 00				                .word 0000
>d3c8	c2 ac d1 ac			                .word xt_asm_push_a, z_asm_push_a
>d3cc	70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0					str_ok             =  0
=1					str_compile        =  1
=2					str_redefined      =  2
=3					str_wid_forth      =  3
=4					str_abc_lower      =  4
=5					str_abc_upper      =  5
=6					str_wid_editor     =  6
=7					str_wid_assembler  =  7
=8					str_wid_root       =  8
=9					str_see_flags      =  9
=10					str_see_nt         = 10
=11					str_see_xt         = 11
=12					str_see_size       = 12
=13					str_disasm_lit     = 13
=14					str_disasm_sdc     = 14
=15					str_disasm_bra     = 15
.d3d2					string_table:
>d3d2	f2 d3 f6 d3 00 d4 66 d4		        .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
>d3da	0b d4
>d3dc	2f d4 5e d4 53 d4 6d d4		        .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
>d3e4	73 d4 8f d4 94 d4 99 d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
>d3ec	aa d4 b3 d4 c5 d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 13-15
>d3f2	20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d3f6	20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d3fe	64 00
>d400	72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d408	64 20 00
>d40b	30 31 32 33 34 35 36 37		s_abc_lower:  .text "0123456789abcdefghijklmnopqrstuvwxyz"
>d413	38 39 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e
>d423	6f 70 71 72 73 74 75 76 77 78 79 7a
>d42f	30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d437	38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d447	4f 50 51 52 53 54 55 56 57 58 59 5a
>d453	41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d45b	72 20 00
>d45e	45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d466	46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d46d	52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d473	66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d47b	4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d48b	29 3a 20 00
>d48f	6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d494	78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d499	73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d4a1	63 69 6d 61 6c 29 3a 20 00
>d4aa	4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d4b2	00
>d4b3	53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d4bb	50 54 48 20 43 48 45 43 4b 00
>d4c5	42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0					err_allot        = 0
=1					err_badsource    = 1
=2					err_compileonly  = 2
=3					err_defer        = 3
=4					err_divzero      = 4
=5					err_noname       = 5
=6					err_refill       = 6
=7					err_state        = 7
=8					err_syntax       = 8
=9					err_underflow    = 9
=10					err_negallot     = 10
=11					err_wordlist     = 11
=12					err_blockwords   = 12
=13					err_returnstack  = 13
.d4cd					error_table:
>d4cd	e9 d4 0a d5 2a d5 4b d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4d5	68 d5 79 d5 89 d5 b7 d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4dd	cf d5 de d5 f3 d5 0f d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4e5	26 d6 65 d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d4e9	41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d4f1	69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d501	65 20 6d 65 6d 6f 72 79 00
>d50a	49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d512	53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d522	20 52 45 46 49 4c 4c 00
>d52a	49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d532	74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d542	6e 6c 79 20 77 6f 72 64 00
>d54b	44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d553	77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d563	20 79 65 74 00
>d568	44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d570	20 62 79 20 7a 65 72 6f 00
>d579	50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d581	66 61 69 6c 75 72 65 00
>d589	51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d591	6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d5a1	20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d5b1	64 20 2d 31 29 00
>d5b7	41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d5bf	69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5cf	55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word", 0
>d5d7	64 20 77 6f 72 64 00
>d5de	44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d5e6	63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d5f3	4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d5fb	72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d60b	4c 4f 54 00
>d60f	4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d617	69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d626	50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d62e	73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d63e	4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d64e	61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d65e	56 45 43 54 4f 52 00
>d665	52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d66d	74 61 63 6b 3a 00
>d673	0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d67b	44 2d 53 54 52 49 4e 47
>d683	05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d689	04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d68e	11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d696	2d 55 4e 49 54 2d 42 49 54 53
>d6a0	07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d6a8	08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6b0	52
>d6b1	05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6b7	05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6bd	12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6c5	53 54 41 43 4b 2d 43 45 4c 4c 53
>d6d0	0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d6d8	45 4c 4c 53
>d6dc	09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d6e4	54 53
>d6e6	05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d6ec	06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d6f3					cmpl_subroutine:
.d6f3	48		pha		                pha             ; save LSB of address
.d6f4	a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d6f6	80 03		bra $d6fb	                bra cmpl_common
.d6f8					cmpl_jump:
.d6f8	48		pha		                pha             ; save LSB of address
.d6f9	a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d6fb					cmpl_common:
.d6fb	20 03 d7	jsr $d703	                jsr cmpl_a      ; compile opcode
.d6fe	68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d6ff					cmpl_word:
.d6ff	20 03 d7	jsr $d703	                jsr cmpl_a      ; compile LSB of address
.d702	98		tya		                tya             ; fall thru for MSB
.d703					cmpl_a:
.d703	92 00		sta ($00)	                sta (cp)
.d705	e6 00		inc $00		                inc cp
.d707	d0 02		bne $d70b	                bne _done
.d709	e6 01		inc $01		                inc cp+1
.d70b					_done:
.d70b	60		rts		                rts
.d70c					doconst:
.d70c	ca		dex		                dex             ; make room for constant
.d70d	ca		dex		                dex
.d70e	68		pla		                pla             ; LSB of return address
.d70f	85 24		sta $24		                sta tmp1
.d711	68		pla		                pla             ; MSB of return address
.d712	85 25		sta $25		                sta tmp1+1
.d714	a0 01		ldy #$01	                ldy #1
.d716	b1 24		lda ($24),y	                lda (tmp1),y
.d718	95 00		sta $00,x	                sta 0,x
.d71a	c8		iny		                iny
.d71b	b1 24		lda ($24),y	                lda (tmp1),y
.d71d	95 01		sta $01,x	                sta 1,x
.d71f	60		rts		                rts
.d720					dodefer:
.d720	68		pla		                pla             ; LSB
.d721	85 24		sta $24		                sta tmp1
.d723	68		pla		                pla             ; MSB
.d724	85 25		sta $25		                sta tmp1+1
.d726	a0 01		ldy #$01	                ldy #1
.d728	b1 24		lda ($24),y	                lda (tmp1),y
.d72a	85 26		sta $26		                sta tmp2
.d72c	c8		iny		                iny
.d72d	b1 24		lda ($24),y	                lda (tmp1),y
.d72f	85 27		sta $27		                sta tmp2+1
.d731	6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d734					defer_error:
.d734	a9 03		lda #$03	                lda #err_defer
.d736	4c 66 d8	jmp $d866	                jmp error
.d739					dodoes:
.d739	7a		ply		                ply             ; LSB
.d73a	68		pla		                pla             ; MSB
.d73b	c8		iny		                iny
.d73c	d0 01		bne $d73f	                bne +
.d73e	1a		inc a		                ina
.d73f					+
.d73f	84 26		sty $26		                sty tmp2
.d741	85 27		sta $27		                sta tmp2+1
.d743	ca		dex		                dex
.d744	ca		dex		                dex
.d745	7a		ply		                ply
.d746	68		pla		                pla
.d747	c8		iny		                iny
.d748	d0 01		bne $d74b	                bne +
.d74a	1a		inc a		                ina
.d74b					+
.d74b	94 00		sty $00,x	                sty 0,x         ; LSB
.d74d	95 01		sta $01,x	                sta 1,x         ; MSB
.d74f	6c 26 00	jmp ($0026)	                jmp (tmp2)
.d752					dovar:
.d752	7a		ply		                ply             ; LSB
.d753	68		pla		                pla             ; MSB
.d754	c8		iny		                iny
.d755	d0 01		bne $d758	                bne +
.d757	1a		inc a		                ina
.d758					+
.d758	ca		dex		                dex
.d759	ca		dex		                dex
.d75a	95 01		sta $01,x	                sta 1,x
.d75c	98		tya		                tya
.d75d	95 00		sta $00,x	                sta 0,x
.d75f	60		rts		                rts
.d760					byte_to_ascii:
.d760	48		pha		                pha
.d761	4a		lsr a		                lsr             ; convert high nibble first
.d762	4a		lsr a		                lsr
.d763	4a		lsr a		                lsr
.d764	4a		lsr a		                lsr
.d765	20 69 d7	jsr $d769	                jsr _nibble_to_ascii
.d768	68		pla		                pla
.d769					_nibble_to_ascii:
.d769	29 0f		and #$0f	                and #$0F
.d76b	09 30		ora #$30	                ora #'0'
.d76d	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d76f	90 02		bcc $d773	                bcc +
.d771	69 06		adc #$06	                adc #$06
.d773	4c 02 8e	jmp $8e02	+               jmp emit_a
.d776	60		rts		                rts
.d777					compare_16bit:
.d777	b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d779	d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d77b	f0 0a		beq $d787	                beq _equal
.d77d	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d77f	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d781	09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d783	70 08		bvs $d78d	                bvs _overflow
.d785	80 08		bra $d78f	                bra _not_equal
.d787					_equal:
.d787	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d789	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d78b	50 04		bvc $d791	                bvc _done
.d78d					_overflow:
.d78d	49 80		eor #$80	                eor #$80                ; complement negative flag
.d78f					_not_equal:
.d78f	09 01		ora #$01	                ora #1                  ; if overflow, we can't be eqal
.d791					_done:
.d791	60		rts		                rts
.d792					current_to_dp:
.d792	a0 04		ldy #$04	                ldy #current_offset
.d794	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d796	0a		asl a		                asl             ; turn it into an offset (in cells)
.d797	18		clc		                clc
.d798	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d79a	a8		tay		                tay
.d79b	b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d79d	85 02		sta $02		                sta dp
.d79f	c8		iny		                iny
.d7a0	b1 1e		lda ($1e),y	                lda (up),y
.d7a2	85 03		sta $03		                sta dp+1
.d7a4	60		rts		                rts
.d7a5					dp_to_current:
.d7a5	a0 04		ldy #$04	                ldy #current_offset
.d7a7	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d7a9	0a		asl a		                asl             ; turn it into an offset (in cells)
.d7aa	18		clc		                clc
.d7ab	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d7ad	a8		tay		                tay
.d7ae	a5 02		lda $02		                lda dp
.d7b0	91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d7b2	c8		iny		                iny
.d7b3	a5 03		lda $03		                lda dp+1
.d7b5	91 1e		sta ($1e),y	                sta (up),y
.d7b7	60		rts		                rts
.d7b8					interpret:
.d7b8					_loop:
.d7b8	20 eb 98	jsr $98eb	                jsr xt_parse_name       ; ( "string" -- addr u )
.d7bb	b5 00		lda $00,x	                lda 0,x
.d7bd	15 01		ora $01,x	                ora 1,x
.d7bf	f0 70		beq $d831	                beq _line_done
.d7c1	20 c4 a3	jsr $a3c4	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d7c4	20 e7 8f	jsr $8fe7	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d7c7	b5 00		lda $00,x	                lda 0,x
.d7c9	15 01		ora $01,x	                ora 1,x
.d7cb	d0 28		bne $d7f5	                bne _got_name_token
.d7cd	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d7ce	e8		inx		                inx
.d7cf	20 96 96	jsr $9696	                jsr xt_number           ; ( addr u -- u|d )
.d7d2	a5 16		lda $16		                lda state
.d7d4	f0 e2		beq $d7b8	                beq _loop
.d7d6	a9 20		lda #$20	                lda #$20
.d7d8	24 20		bit $20		                bit status
.d7da	f0 0d		beq $d7e9	                beq _single_number
.d7dc	20 ba a1	jsr $a1ba	                jsr xt_swap
.d7df	a0 93		ldy #$93	                ldy #>literal_runtime
.d7e1	a9 a4		lda #$a4	                lda #<literal_runtime
.d7e3	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.d7e6	20 7a 87	jsr $877a	                jsr xt_comma
.d7e9					_single_number:
.d7e9	a0 93		ldy #$93	                ldy #>literal_runtime
.d7eb	a9 a4		lda #$a4	                lda #<literal_runtime
.d7ed	20 f3 d6	jsr $d6f3	                jsr cmpl_subroutine
.d7f0	20 7a 87	jsr $877a	                jsr xt_comma
.d7f3	80 c3		bra $d7b8	                bra _loop
.d7f5					_got_name_token:
.d7f5	b5 00		lda $00,x	                lda 0,x
.d7f7	95 04		sta $04,x	                sta 4,x
.d7f9	b5 01		lda $01,x	                lda 1,x
.d7fb	95 05		sta $05,x	                sta 5,x
.d7fd	e8		inx		                inx
.d7fe	e8		inx		                inx
.d7ff	e8		inx		                inx
.d800	e8		inx		                inx                     ; ( nt )
.d801	b5 00		lda $00,x	                lda 0,x
.d803	85 22		sta $22		                sta tmpbranch
.d805	b5 01		lda $01,x	                lda 1,x
.d807	85 23		sta $23		                sta tmpbranch+1
.d809	20 ed 95	jsr $95ed	                jsr xt_name_to_int      ; ( nt - xt )
.d80c	a5 16		lda $16		                lda state
.d80e	d0 13		bne $d823	                bne _compile
.d810	a0 01		ldy #$01	                ldy #1
.d812	b1 22		lda ($22),y	                lda (tmpbranch),y
.d814	29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d816	f0 05		beq $d81d	                beq _interpret
.d818	a9 02		lda #$02	                lda #err_compileonly
.d81a	4c 66 d8	jmp $d866	                jmp error
.d81d					_interpret:
.d81d	20 49 8f	jsr $8f49	                jsr xt_execute
.d820	4c b8 d7	jmp $d7b8	                jmp _loop
.d823					_compile:
.d823	a0 01		ldy #$01	                ldy #1
.d825	b1 22		lda ($22),y	                lda (tmpbranch),y
.d827	29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d829	d0 f2		bne $d81d	                bne _interpret          ; IMMEDIATE word, execute right now
.d82b	20 f9 87	jsr $87f9	                jsr xt_compile_comma
.d82e	4c b8 d7	jmp $d7b8	                jmp _loop
.d831					_line_done:
.d831	e8		inx		                inx
.d832	e8		inx		                inx
.d833	e8		inx		                inx
.d834	e8		inx		                inx
.d835	60		rts		                rts
.d836					is_printable:
.d836	c9 20		cmp #$20	                cmp #AscSP              ; $20
.d838	90 08		bcc $d842	                bcc _done
.d83a	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d83c	b0 03		bcs $d841	                bcs _failed
.d83e	38		sec		                sec
.d83f	80 01		bra $d842	                bra _done
.d841					_failed:
.d841	18		clc		                clc
.d842					_done:
.d842	60		rts		                rts
.d843					is_whitespace:
.d843	c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d845	90 08		bcc $d84f	                bcc _done
.d847	c9 21		cmp #$21	                cmp #AscSP+1
.d849	b0 03		bcs $d84e	                bcs _failed
.d84b	38		sec		                sec
.d84c	80 01		bra $d84f	                bra _done
.d84e					_failed:
.d84e	18		clc		                clc
.d84f					_done:
.d84f	60		rts		                rts
.d850					underflow_1:
.d850	e0 77		cpx #$77	                cpx #dsp0-1
.d852	10 10		bpl $d864	                bpl underflow_error
.d854	60		rts		                rts
.d855					underflow_2:
.d855	e0 75		cpx #$75	                cpx #dsp0-3
.d857	10 0b		bpl $d864	                bpl underflow_error
.d859	60		rts		                rts
.d85a					underflow_3:
.d85a	e0 73		cpx #$73	                cpx #dsp0-5
.d85c	10 06		bpl $d864	                bpl underflow_error
.d85e	60		rts		                rts
.d85f					underflow_4:
.d85f	e0 71		cpx #$71	                cpx #dsp0-7
.d861	10 01		bpl $d864	                bpl underflow_error
.d863	60		rts		                rts
.d864					underflow_error:
.d864	a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d866					error:
.d866	48		pha		                pha                     ; save error
.d867	20 a6 d8	jsr $d8a6	                jsr print_error
.d86a	20 6f 89	jsr $896f	                jsr xt_cr
.d86d	68		pla		                pla
.d86e	c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d870	d0 17		bne $d889	                bne _no_underflow
.d872	a9 0d		lda #$0d	                lda #err_returnstack
.d874	20 a6 d8	jsr $d8a6	                jsr print_error
.d877	ba		tsx		                tsx
.d878					-
.d878	e8		inx		                inx
.d879	f0 0b		beq $d886	                beq +
.d87b	20 2a a1	jsr $a12a	                jsr xt_space
.d87e	bd 00 01	lda $0100,x	                lda $100,x
.d881	20 60 d7	jsr $d760	                jsr byte_to_ascii
.d884	80 f2		bra $d878	                bra -
.d886					+
.d886	20 6f 89	jsr $896f	                jsr xt_cr
.d889					_no_underflow:
.d889	4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d88c					print_string_no_lf:
.d88c	0a		asl a		                asl
.d88d	a8		tay		                tay
.d88e	b9 d2 d3	lda $d3d2,y	                lda string_table,y
.d891	85 28		sta $28		                sta tmp3                ; LSB
.d893	c8		iny		                iny
.d894	b9 d2 d3	lda $d3d2,y	                lda string_table,y
.d897	85 29		sta $29		                sta tmp3+1              ; MSB
.d899					print_common:
.d899	a0 00		ldy #$00	                ldy #0
.d89b					_loop:
.d89b	b1 28		lda ($28),y	                lda (tmp3),y
.d89d	f0 06		beq $d8a5	                beq _done               ; strings are zero-terminated
.d89f	20 02 8e	jsr $8e02	                jsr emit_a              ; allows vectoring via output
.d8a2	c8		iny		                iny
.d8a3	80 f6		bra $d89b	                bra _loop
.d8a5					_done:
.d8a5	60		rts		                rts
.d8a6					print_error:
.d8a6	0a		asl a		                asl
.d8a7	a8		tay		                tay
.d8a8	b9 cd d4	lda $d4cd,y	                lda error_table,y
.d8ab	85 28		sta $28		                sta tmp3                ; LSB
.d8ad	c8		iny		                iny
.d8ae	b9 cd d4	lda $d4cd,y	                lda error_table,y
.d8b1	85 29		sta $29		                sta tmp3+1              ; MSB
.d8b3	20 99 d8	jsr $d899	                jsr print_common
.d8b6	60		rts		                rts
.d8b7					print_string:
.d8b7	20 8c d8	jsr $d88c	                jsr print_string_no_lf
.d8ba	4c 6f 89	jmp $896f	                jmp xt_cr               ; JSR/RTS because never compiled
.d8bd					print_u:
.d8bd	20 b4 a7	jsr $a7b4	                jsr xt_zero                     ; 0
.d8c0	20 66 93	jsr $9366	                jsr xt_less_number_sign         ; <#
.d8c3	20 ea 97	jsr $97ea	                jsr xt_number_sign_s            ; #S
.d8c6	20 c8 97	jsr $97c8	                jsr xt_number_sign_greater      ; #>
.d8c9	4c 0f a5	jmp $a50f	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp forth
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034	74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044	6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054	28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
