
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Fri May 10 21:03:56 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 2d		lda #$2d	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd 10 b3	lda $b310,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad 10 b3	lda $b310	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f		a9 00		lda #$00	                lda #0
.8021						_load_user_vars_loop:
.8021		b9 2e b3	lda $b32e,y	                lda cold_user_table,y
.8024		91 08		sta ($08),y	                sta (up),y
.8026		88		dey		                dey
.8027		d0 f8		bne $8021	                bne _load_user_vars_loop
.8029		ad 2e b3	lda $b32e	                lda cold_user_table
.802c		92 08		sta ($08)	                sta (up)
.802e		20 fa 84	jsr $84fa	                jsr xt_cr
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		ca		dex		                dex
.8034		ca		dex		                dex
.8035		a9 fe		lda #$fe	                lda #<forth_words_start
.8037		95 02		sta $02,x	                sta 2,x
.8039		a9 b9		lda #$b9	                lda #>forth_words_start
.803b		95 03		sta $03,x	                sta 3,x
.803d		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803f		95 00		sta $00,x	                sta 0,x
.8041		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043		95 01		sta $01,x	                sta 1,x
.8045		20 99 89	jsr $8999	                jsr xt_evaluate
.8048		9c 00 7c	stz $7c00	                stz hist_buff
.804b		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e		9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057		9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d		9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060						xt_abort:
.8060		a2 78		ldx #$78	                ldx #dsp0
.8062						xt_quit:
.8062		8a		txa		                txa             ; Save the DSP that we just defined
.8063		a2 ff		ldx #$ff	                ldx #rsp0
.8065		9a		txs		                txs
.8066		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067		64 04		stz $04		                stz ip
.8069		64 05		stz $05		                stz ip+1
.806b		64 0a		stz $0a		                stz insrc
.806d		64 0b		stz $0b		                stz insrc+1
.806f		a9 00		lda #$00	                lda #0
.8071		a0 04		ldy #$04	                ldy #blk_offset
.8073		91 08		sta ($08),y	                sta (up),y
.8075		c8		iny		                iny
.8076		91 08		sta ($08),y	                sta (up),y
.8078		a9 fc		lda #$fc	                lda #(256-4)
.807a		85 1f		sta $1f		                sta loopctrl
.807c		64 1a		stz $1a		                stz state
.807e		64 1b		stz $1b		                stz state+1
.8080						_get_line:
.8080		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8082		85 0c		sta $0c		                sta cib
.8084		a9 02		lda #$02	                lda #>buffer0
.8086		85 0d		sta $0d		                sta cib+1
.8088		64 0e		stz $0e		                stz ciblen
.808a		64 0f		stz $0f		                stz ciblen+1
.808c		20 3f 90	jsr $903f	                jsr xt_refill           ; ( -- f )
.808f		b5 00		lda $00,x	                lda 0,x
.8091		d0 05		bne $8098	                bne _success
.8093		a9 06		lda #$06	                lda #err_refill
.8095		4c 7a d7	jmp $d77a	                jmp error
.8098						_success:
.8098		e8		inx		                inx                     ; drop
.8099		e8		inx		                inx
.809a		20 e1 d6	jsr $d6e1	                jsr interpret
.809d		e0 78		cpx #$78	                cpx #dsp0
.809f		f0 05		beq $80a6	                beq _stack_ok
.80a1		90 03		bcc $80a6	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a3		4c 78 d7	jmp $d778	                jmp underflow_error
.80a6						_stack_ok:
.80a6		a5 1a		lda $1a		                lda state
.80a8		f0 02		beq $80ac	                beq _print
.80aa		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80ac						_print:
.80ac		20 cb d7	jsr $d7cb	                jsr print_string
.80af		80 cf		bra $8080	                bra _get_line
.80b1						z_cold:
.80b1						z_abort:
.80b1						z_quit:

;******  Processing file: platform/../words/core.asm

.80b1						xt_abort_quote:
.80b1		20 d7 90	jsr $90d7	                jsr xt_s_quote          ; S"
.80b4		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b6		a9 bc		lda #$bc	                lda #<abort_quote_runtime
.80b8		20 8e d5	jsr $d58e	                jsr cmpl_call_ya     ; may not be JMP as JSR/RTS
.80bb		60		rts		z_abort_quote:  rts
.80bc						abort_quote_runtime:
.80bc		b5 04		lda $04,x	                lda 4,x
.80be		15 05		ora $05,x	                ora 5,x
.80c0		f0 09		beq $80cb	                beq _done       ; if FALSE, we're done
.80c2		20 d4 95	jsr $95d4	                jsr xt_type
.80c5		20 fa 84	jsr $84fa	                jsr xt_cr
.80c8		4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.80cb						_done:
.80cb		8a		txa		                txa
.80cc		18		clc		                clc
.80cd		69 06		adc #$06	                adc #6
.80cf		aa		tax		                tax
.80d0		60		rts		                rts
.80d1						xt_abs:
.80d1		20 64 d7	jsr $d764	                jsr underflow_1
.80d4		b5 01		lda $01,x	                lda 1,x
.80d6		10 0d		bpl $80e5	                bpl _done       ; positive number, easy money!
.80d8		38		sec		                sec
.80d9		a9 00		lda #$00	                lda #0
.80db		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80dd		95 00		sta $00,x	                sta 0,x
.80df		a9 00		lda #$00	                lda #0          ; MSB
.80e1		f5 01		sbc $01,x	                sbc 1,x
.80e3		95 01		sta $01,x	                sta 1,x
.80e5						_done:
.80e5		60		rts		z_abs:          rts
.80e6						xt_accept:
.80e6		20 69 d7	jsr $d769	                jsr underflow_2
.80e9		b5 00		lda $00,x	                lda 0,x
.80eb		15 01		ora $01,x	                ora 1,x
.80ed		d0 09		bne $80f8	                bne _not_zero
.80ef		e8		inx		                inx
.80f0		e8		inx		                inx
.80f1		74 00		stz $00,x	                stz 0,x
.80f3		74 01		stz $01,x	                stz 1,x
.80f5		4c c4 81	jmp $81c4	                jmp accept_done
.80f8						_not_zero:
.80f8		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80fa		85 27		sta $27		                sta tmp2
.80fc		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fe		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8100		85 25		sta $25		                sta tmp1
.8102		b5 03		lda $03,x	                lda 3,x
.8104		85 26		sta $26		                sta tmp1+1
.8106		e8		inx		                inx
.8107		e8		inx		                inx
.8108		a0 00		ldy #$00	                ldy #0
.810a		a5 1c		lda $1c		                lda status
.810c		29 f7		and #$f7	                and #$F7
.810e		1a		inc a		               ina
.810f		09 08		ora #$08	                ora #%00001000
.8111		85 1c		sta $1c		                sta status
.8113						accept_loop:
.8113		20 da 8a	jsr $8ada	                jsr key_a
.8116		c9 0a		cmp #$0a	                cmp #AscLF
.8118		f0 20		beq $813a	                beq _eol
.811a		c9 0d		cmp #$0d	                cmp #AscCR
.811c		f0 1c		beq $813a	                beq _eol
.811e		c9 08		cmp #$08	                cmp #AscBS
.8120		f0 22		beq $8144	                beq _backspace
.8122		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8124		f0 1e		beq $8144	                beq _backspace
.8126		c9 10		cmp #$10	                cmp #AscCP
.8128		f0 36		beq $8160	                beq _ctrl_p
.812a		c9 0e		cmp #$0e	                cmp #AscCN
.812c		f0 44		beq $8172	                beq _ctrl_n
.812e		91 25		sta ($25),y	                sta (tmp1),y
.8130		c8		iny		                iny
.8131		20 ac 87	jsr $87ac	                jsr emit_a
.8134		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8136		d0 db		bne $8113	                bne accept_loop       ; fall through if buffer limit reached
.8138		80 03		bra $813d	                bra _buffer_full
.813a						_eol:
.813a		20 c8 92	jsr $92c8	                jsr xt_space    ; print final space
.813d						_buffer_full:
.813d		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813f		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.8141		4c c4 81	jmp $81c4	                jmp accept_done
.8144						_backspace:
.8144		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8146		d0 06		bne $814e	                bne +
.8148		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.814a		20 ac 87	jsr $87ac	                jsr emit_a
.814d		c8		iny		                iny
.814e						+
.814e		88		dey		                dey
.814f		a9 08		lda #$08	                lda #AscBS      ; move back one
.8151		20 ac 87	jsr $87ac	                jsr emit_a
.8154		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8156		20 ac 87	jsr $87ac	                jsr emit_a
.8159		a9 08		lda #$08	                lda #AscBS      ; move back over space
.815b		20 ac 87	jsr $87ac	                jsr emit_a
.815e		80 b3		bra $8113	                bra accept_loop
.8160						_ctrl_p:
.8160		a5 1c		lda $1c		                lda status
.8162		29 07		and #$07	                and #7
.8164		d0 08		bne $816e	                bne _ctrl_p_dec
.8166		a5 1c		lda $1c		                lda status
.8168		09 07		ora #$07	                ora #7
.816a		85 1c		sta $1c		                sta status
.816c		80 11		bra $817f	                bra _recall_history
.816e						_ctrl_p_dec:
.816e		c6 1c		dec $1c		                dec status
.8170		80 0d		bra $817f	                bra _recall_history
.8172						_ctrl_n:
.8172		a9 08		lda #$08	                lda #$8
.8174		24 1c		bit $1c		                bit status
.8176		d0 07		bne $817f	                bne _recall_history
.8178		a5 1c		lda $1c		                lda status
.817a		29 f7		and #$f7	                and #$F7
.817c		1a		inc a		               ina
.817d		85 1c		sta $1c		                sta status
.817f						_recall_history:
.817f		a9 08		lda #$08	                lda #%00001000
.8181		14 1c		trb $1c		                trb status
.8183		20 df 81	jsr $81df	                jsr accept_total_recall
.8186		a9 0d		lda #$0d	                lda #AscCR
.8188		20 ac 87	jsr $87ac	                jsr emit_a
.818b						input_clear:
.818b		c0 00		cpy #$00	                cpy #0
.818d		f0 08		beq $8197	                beq input_cleared
.818f		a9 20		lda #$20	                lda #AscSP
.8191		20 ac 87	jsr $87ac	                jsr emit_a
.8194		88		dey		                dey
.8195		80 f4		bra $818b	                bra input_clear
.8197						input_cleared:
.8197		a9 0d		lda #$0d	                lda #AscCR
.8199		20 ac 87	jsr $87ac	                jsr emit_a
.819c		b1 29		lda ($29),y	                lda (tmp3),y
.819e		85 1d		sta $1d		                sta status+1
.81a0		e6 29		inc $29		                inc tmp3
.81a2		d0 02		bne $81a6	                bne +           ; Increment the upper byte on carry.
.81a4		e6 2a		inc $2a		                inc tmp3+1
.81a6						+
.81a6		a9 0d		lda #$0d	                lda #AscCR
.81a8		20 ac 87	jsr $87ac	                jsr emit_a
.81ab						_history_loop:
.81ab		c4 1d		cpy $1d		                cpy status+1
.81ad		d0 03		bne $81b2	                bne +
.81af		4c 13 81	jmp $8113	                jmp accept_loop       ; Needs a long jump
.81b2						+
.81b2		c4 27		cpy $27		                cpy tmp2
.81b4		f0 0a		beq $81c0	                beq _hist_filled_buffer
.81b6		b1 29		lda ($29),y	                lda (tmp3),y
.81b8		91 25		sta ($25),y	                sta (tmp1),y
.81ba		20 ac 87	jsr $87ac	                jsr emit_a
.81bd		c8		iny		                iny
.81be		80 eb		bra $81ab	                bra _history_loop
.81c0						_hist_filled_buffer:
.81c0		88		dey		                dey
.81c1		4c 13 81	jmp $8113	                jmp accept_loop
.81c4						accept_done:
.81c4		20 df 81	jsr $81df	                jsr accept_total_recall
.81c7		85 1d		sta $1d		                sta status+1
.81c9		a0 00		ldy #$00	                ldy #0
.81cb		91 29		sta ($29),y	                sta (tmp3),y
.81cd		e6 29		inc $29		                inc tmp3
.81cf		d0 02		bne $81d3	                bne +           ; Increment the upper byte on carry.
.81d1		e6 2a		inc $2a		                inc tmp3+1
.81d3						+
.81d3						_save_history_loop:
.81d3		c4 1d		cpy $1d		                cpy status+1
.81d5		f0 07		beq $81de	                beq _save_history_done
.81d7		b1 25		lda ($25),y	                lda (tmp1),y
.81d9		91 29		sta ($29),y	                sta (tmp3),y
.81db		c8		iny		                iny
.81dc		80 f5		bra $81d3	                bra _save_history_loop
.81de						_save_history_done:
.81de						z_accept:
.81de		60		rts		                rts
.81df						accept_total_recall:
.81df		a9 00		lda #$00	                lda #<hist_buff
.81e1		85 29		sta $29		                sta tmp3
.81e3		a9 7c		lda #$7c	                lda #>hist_buff
.81e5		85 2a		sta $2a		                sta tmp3+1
.81e7		a5 1c		lda $1c		                lda status
.81e9		6a		ror a		                ror
.81ea		29 03		and #$03	                and #3
.81ec		18		clc		                clc
.81ed		65 2a		adc $2a		                adc tmp3+1
.81ef		85 2a		sta $2a		                sta tmp3+1
.81f1		a5 1c		lda $1c		                lda status
.81f3		6a		ror a		                ror             ; Rotate through carry into msb.
.81f4		6a		ror a		                ror
.81f5		29 80		and #$80	                and #$80
.81f7		18		clc		                clc
.81f8		65 29		adc $29		                adc tmp3
.81fa		85 29		sta $29		                sta tmp3
.81fc		90 02		bcc $8200	                bcc +           ; Increment the upper byte on carry.
.81fe		e6 2a		inc $2a		                inc tmp3+1
.8200						+
.8200		98		tya		                tya
.8201		c9 80		cmp #$80	                cmp #$80
.8203		90 02		bcc $8207	                bcc +
.8205		a9 7f		lda #$7f	                lda #$7F
.8207						+
.8207		60		rts		                rts
.8208						xt_action_of:
.8208		a5 1a		lda $1a		                lda state
.820a		05 1b		ora $1b		                ora state+1
.820c		f0 0c		beq $821a	                beq _interpreting
.820e						_compiling:
.820e		20 16 83	jsr $8316	                jsr xt_bracket_tick
.8211		a0 86		ldy #$86	                ldy #>xt_defer_fetch
.8213		a9 04		lda #$04	                lda #<xt_defer_fetch
.8215		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.8218		80 06		bra $8220	                bra _done
.821a						_interpreting:
.821a		20 61 93	jsr $9361	                jsr xt_tick
.821d		20 04 86	jsr $8604	                jsr xt_defer_fetch
.8220						_done:
.8220		60		rts		z_action_of:           rts
.8221						xt_again:
.8221		20 64 d7	jsr $d764	                jsr underflow_1
.8224		20 ab d5	jsr $d5ab	                jsr cmpl_jump_tos
.8227		60		rts		z_again:        rts
.8228						xt_align:
.8228						xt_aligned:
.8228						z_align:
.8228						z_aligned:
.8228		60		rts		                rts             ; stripped out during native compile
.8229						xt_allot:
.8229		20 64 d7	jsr $d764	                jsr underflow_1
.822c		b5 01		lda $01,x	                lda 1,x
.822e		30 22		bmi $8252	                bmi _release
.8230		18		clc		                clc
.8231		a5 00		lda $00		                lda cp
.8233		75 00		adc $00,x	                adc 0,x
.8235		85 00		sta $00		                sta cp
.8237		a5 01		lda $01		                lda cp+1
.8239		75 01		adc $01,x	                adc 1,x
.823b		85 01		sta $01		                sta cp+1
.823d		a0 00		ldy #$00	                ldy #<cp_end
.823f		c4 00		cpy $00		                cpy cp
.8241		a9 7c		lda #$7c	                lda #>cp_end
.8243		e5 01		sbc $01		                sbc cp+1
.8245		b0 48		bcs $828f	                bcs _done               ; we're fine.
.8247		84 00		sty $00		                sty cp                  ; still #<cp_end
.8249		a9 7c		lda #$7c	                lda #>cp_end
.824b		85 01		sta $01		                sta cp+1
.824d		a9 00		lda #$00	                lda #err_allot
.824f		4c 7a d7	jmp $d77a	                jmp error
.8252						_release:
.8252		ca		dex		                dex
.8253		ca		dex		                dex
.8254		a5 00		lda $00		                lda cp
.8256		95 00		sta $00,x	                sta 0,x
.8258		a5 01		lda $01		                lda cp+1
.825a		95 01		sta $01,x	                sta 1,x
.825c		20 56 8f	jsr $8f56	                jsr xt_plus                     ; new CP is now TOS
.825f		ca		dex		                dex
.8260		ca		dex		                dex                             ; new CP now NOS
.8261		a9 00		lda #$00	                lda #<cp0
.8263		95 00		sta $00,x	                sta 0,x
.8265		a9 03		lda #$03	                lda #>cp0
.8267		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8269		20 a2 d6	jsr $d6a2	                jsr compare_16bit               ; still ( CP CP0 )
.826c		f0 17		beq $8285	                beq _nega_done
.826e		30 15		bmi $8285	                bmi _nega_done
.8270		a9 00		lda #$00	                lda #<cp0
.8272		85 00		sta $00		                sta cp
.8274		a9 03		lda #$03	                lda #>cp0
.8276		85 01		sta $01		                sta cp+1
.8278		a9 e0		lda #$e0	                lda #<dictionary_start
.827a		85 02		sta $02		                sta dp
.827c		a9 ba		lda #$ba	                lda #>dictionary_start
.827e		85 03		sta $03		                sta dp+1
.8280		a9 0a		lda #$0a	                lda #err_negallot
.8282		4c 7a d7	jmp $d77a	                jmp error
.8285						_nega_done:
.8285		b5 02		lda $02,x	                lda 2,x
.8287		85 00		sta $00		                sta cp
.8289		b5 03		lda $03,x	                lda 3,x
.828b		85 01		sta $01		                sta cp+1
.828d		e8		inx		                inx
.828e		e8		inx		                inx                     ; drop through to _done
.828f						_done:
.828f		e8		inx		                inx
.8290		e8		inx		                inx
.8291						z_allot:
.8291		60		rts		                rts
.8292						xt_and:
.8292		20 69 d7	jsr $d769	                jsr underflow_2
.8295		b5 00		lda $00,x	                lda 0,x
.8297		35 02		and $02,x	                and 2,x
.8299		95 02		sta $02,x	                sta 2,x
.829b		b5 01		lda $01,x	                lda 1,x
.829d		35 03		and $03,x	                and 3,x
.829f		95 03		sta $03,x	                sta 3,x
.82a1		e8		inx		                inx
.82a2		e8		inx		                inx
.82a3		60		rts		z_and:          rts
.82a4						xt_at_xy:
.82a4		20 69 d7	jsr $d769	                jsr underflow_2
.82a7		a5 18		lda $18		                lda base
.82a9		48		pha		                pha
.82aa		a9 0a		lda #$0a	                lda #10
.82ac		85 18		sta $18		                sta base
.82ae		a9 1b		lda #$1b	                lda #AscESC
.82b0		20 ac 87	jsr $87ac	                jsr emit_a
.82b3		a9 5b		lda #$5b	                lda #'['
.82b5		20 ac 87	jsr $87ac	                jsr emit_a
.82b8		20 ec 8d	jsr $8dec	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82bb		20 d1 d7	jsr $d7d1	                jsr print_u
.82be		a9 3b		lda #$3b	                lda #';'
.82c0		20 ac 87	jsr $87ac	                jsr emit_a
.82c3		20 ec 8d	jsr $8dec	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c6		20 d1 d7	jsr $d7d1	                jsr print_u
.82c9		a9 48		lda #$48	                lda #'H'
.82cb		20 ac 87	jsr $87ac	                jsr emit_a
.82ce		68		pla		                pla
.82cf		85 18		sta $18		                sta base
.82d1		60		rts		z_at_xy:        rts
.82d2						xt_backslash:
.82d2		a0 04		ldy #$04	                ldy #blk_offset
.82d4		b1 08		lda ($08),y	                lda (up),y
.82d6		c8		iny		                iny
.82d7		11 08		ora ($08),y	                ora (up),y
.82d9		f0 19		beq $82f4	                beq backslash_not_block
.82db		a5 10		lda $10		                lda toin
.82dd		29 3f		and #$3f	                and #$3F
.82df		f0 1b		beq $82fc	                beq z_backslash
.82e1		c9 01		cmp #$01	                cmp #$1
.82e3		f0 17		beq $82fc	                beq z_backslash
.82e5		a5 10		lda $10		                lda toin
.82e7		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82e9		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82ea		69 40		adc #$40	                adc #$40
.82ec		85 10		sta $10		                sta toin
.82ee		90 0c		bcc $82fc	                bcc z_backslash
.82f0		e6 11		inc $11		                inc toin+1
.82f2		80 08		bra $82fc	                bra z_backslash
.82f4						backslash_not_block:
.82f4		a5 0e		lda $0e		                lda ciblen
.82f6		85 10		sta $10		                sta toin
.82f8		a5 0f		lda $0f		                lda ciblen+1
.82fa		85 11		sta $11		                sta toin+1
.82fc		60		rts		z_backslash:    rts
.82fd						xt_base:
.82fd		ca		dex		                dex
.82fe		ca		dex		                dex
.82ff		a9 18		lda #$18	                lda #<base
.8301		95 00		sta $00,x	                sta 0,x         ; LSB
.8303		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8305		60		rts		z_base:         rts
.8306						xt_bl:
.8306		ca		dex		                dex
.8307		ca		dex		                dex
.8308		a9 20		lda #$20	                lda #AscSP
.830a		95 00		sta $00,x	                sta 0,x
.830c		74 01		stz $01,x	                stz 1,x
.830e		60		rts		z_bl:           rts
.830f						xt_bracket_char:
.830f		20 55 83	jsr $8355	                jsr xt_char
.8312		20 1b 8b	jsr $8b1b	                jsr xt_literal
.8315		60		rts		z_bracket_char: rts
.8316						xt_bracket_tick:
.8316		20 61 93	jsr $9361	                jsr xt_tick
.8319		20 1b 8b	jsr $8b1b	                jsr xt_literal
.831c		60		rts		z_bracket_tick: rts
.831d						xt_buffer_colon:
.831d		20 00 85	jsr $8500	                jsr xt_create
.8320		20 29 82	jsr $8229	                jsr xt_allot
.8323		60		rts		z_buffer_colon: rts
.8324						xt_c_comma:
.8324		20 64 d7	jsr $d764	                jsr underflow_1
.8327		b5 00		lda $00,x	                lda 0,x
.8329		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.832c		e8		inx		                inx
.832d		e8		inx		                inx
.832e		60		rts		z_c_comma:      rts
.832f						xt_c_fetch:
.832f		20 64 d7	jsr $d764	                jsr underflow_1
.8332		a1 00		lda ($00,x)	                lda (0,x)
.8334		95 00		sta $00,x	                sta 0,x
.8336		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8338		60		rts		z_c_fetch:      rts
.8339						xt_c_store:
.8339		20 69 d7	jsr $d769	                jsr underflow_2
.833c		b5 02		lda $02,x	                lda 2,x
.833e		81 00		sta ($00,x)	                sta (0,x)
.8340		e8		inx		                inx
.8341		e8		inx		                inx
.8342		e8		inx		                inx
.8343		e8		inx		                inx
.8344		60		rts		z_c_store:      rts
.8345						xt_cell_plus:
.8345		20 64 d7	jsr $d764	                jsr underflow_1
.8348		f6 00		inc $00,x	                inc 0,x
.834a		d0 02		bne $834e	                bne +
.834c		f6 01		inc $01,x	                inc 1,x
.834e						+
.834e		f6 00		inc $00,x	                inc 0,x
.8350		d0 02		bne $8354	                bne _done
.8352		f6 01		inc $01,x	                inc 1,x
.8354						_done:
.8354		60		rts		z_cell_plus:    rts
.8355						xt_char:
.8355		20 54 8e	jsr $8e54	                jsr xt_parse_name
.8358		b5 00		lda $00,x	                lda 0,x
.835a		15 01		ora $01,x	                ora 1,x
.835c		d0 05		bne $8363	                bne _not_empty
.835e		a9 05		lda #$05	                lda #err_noname
.8360		4c 7a d7	jmp $d77a	                jmp error
.8363						_not_empty:
.8363		e8		inx		                inx             ; drop number of characters, leave addr
.8364		e8		inx		                inx
.8365		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8367		95 00		sta $00,x	                sta 0,x
.8369		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.836b		60		rts		z_char:         rts
.836c						xt_chars:
.836c		20 64 d7	jsr $d764	                jsr underflow_1
.836f		60		rts		z_chars:        rts
.8370						xt_colon:
.8370		a5 1a		lda $1a		                lda state
.8372		05 1b		ora $1b		                ora state+1
.8374		f0 05		beq $837b	                beq +
.8376		a9 07		lda #$07	                lda #err_state
.8378		4c 7a d7	jmp $d77a	                jmp error
.837b						+
.837b		c6 1a		dec $1a		                dec state
.837d		c6 1b		dec $1b		                dec state+1
.837f		a9 40		lda #$40	                lda #%01000000
.8381		04 1c		tsb $1c		                tsb status
.8383		20 bb d6	jsr $d6bb	                jsr current_to_dp
.8386		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8388		48		pha		                pha
.8389		a5 02		lda $02		                lda dp
.838b		48		pha		                pha
.838c		a9 80		lda #$80	                lda #%10000000
.838e		04 1c		tsb $1c		                tsb status
.8390		20 00 85	jsr $8500	                jsr xt_create
.8393		20 bb d6	jsr $d6bb	                jsr current_to_dp   ; This might be able to be omitted
.8396		a5 02		lda $02		                lda dp
.8398		85 06		sta $06		                sta workword
.839a		a5 03		lda $03		                lda dp+1
.839c		85 07		sta $07		                sta workword+1
.839e		68		pla		                pla
.839f		85 02		sta $02		                sta dp
.83a1		68		pla		                pla
.83a2		85 03		sta $03		                sta dp+1
.83a4		20 ce d6	jsr $d6ce	                jsr dp_to_current
.83a7		a5 00		lda $00		                lda cp
.83a9		38		sec		                sec
.83aa		e9 03		sbc #$03	                sbc #3
.83ac		85 00		sta $00		                sta cp
.83ae		b0 02		bcs $83b2	                bcs _done
.83b0		c6 01		dec $01		                dec cp+1
.83b2						_done:
.83b2		60		rts		z_colon:        rts
.83b3						xt_colon_noname:
.83b3		a5 1a		lda $1a		                lda state
.83b5		05 1b		ora $1b		                ora state+1
.83b7		f0 05		beq $83be	                beq +
.83b9		a9 07		lda #$07	                lda #err_state
.83bb		4c 7a d7	jmp $d77a	                jmp error
.83be						+
.83be		c6 1a		dec $1a		                dec state
.83c0		c6 1b		dec $1b		                dec state+1
.83c2		a9 40		lda #$40	                lda #%01000000
.83c4		14 1c		trb $1c		                trb status
.83c6		a5 00		lda $00		                lda cp
.83c8		85 06		sta $06		                sta workword
.83ca		a5 01		lda $01		                lda cp+1
.83cc		85 07		sta $07		                sta workword+1
.83ce						_done:
.83ce		60		rts		z_colon_noname:        rts
.83cf						xt_comma:
.83cf		20 64 d7	jsr $d764	                jsr underflow_1
.83d2		a0 02		ldy #$02	                ldy #2
.83d4		b5 00		lda $00,x	_twice:         lda 0,x
.83d6		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.83d9		e8		inx		                inx
.83da		88		dey		                dey
.83db		d0 f7		bne $83d4	                bne _twice
.83dd		60		rts		z_comma:        rts
.83de						xt_compile_comma:
.83de		20 64 d7	jsr $d764	                jsr underflow_1
.83e1		20 42 87	jsr $8742	                jsr xt_dup
.83e4		20 43 9b	jsr $9b43	                jsr xt_int_to_name
.83e7		b5 00		lda $00,x	                lda 0,x
.83e9		15 01		ora $01,x	                ora 1,x
.83eb		f0 2b		beq $8418	                beq _compile_as_jsr      ; No nt so unknown size; must compile as a JSR
.83ed						_check_nt:
.83ed		20 42 87	jsr $8742	                jsr xt_dup
.83f0		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; status is at nt+1
.83f3		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.83f5		e8		inx		                inx                     ; drop pointer
.83f6		e8		inx		                inx
.83f7		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.83f9		29 08		and #$08	                and #NN
.83fb		d0 1b		bne $8418	                bne _compile_as_jsr     ; never native
.83fd						_maybe_native:
.83fd		20 6b 9d	jsr $9d6b	                jsr xt_wordsize
.8400		a0 00		ldy #$00	                ldy #0
.8402						_strip_loop:
.8402		b9 8d 84	lda $848d,y	                lda strip_table,y       ; LSB of first word
.8405		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of xt
.8407		d0 07		bne $8410	                bne _next_entry
.8409		b9 8e 84	lda $848e,y	                lda strip_table+1,y
.840c		d5 03		cmp $03,x	                cmp 3,x
.840e		f0 0d		beq $841d	                beq _found_entry
.8410						_next_entry:
.8410		c8		iny		                iny
.8411		c8		iny		                iny
.8412		c0 0a		cpy #$0a	                cpy #strip_table_size
.8414		d0 ec		bne $8402	                bne _strip_loop
.8416		f0 21		beq $8439	                beq _underflow_strip
.8418						_compile_as_jsr:
.8418		e8		inx		                inx             ; either way drop TOS
.8419		e8		inx		                inx
.841a		4c a7 d5	jmp $d5a7	                jmp cmpl_call_tos
.841d						_found_entry:
.841d		98		tya		                tya
.841e		4a		lsr a		                lsr
.841f		a8		tay		                tay
.8420		b9 97 84	lda $8497,y	                lda strip_size,y
.8423		48		pha		                pha                     ; save a copy
.8424		18		clc		                clc
.8425		75 02		adc $02,x	                adc 2,x
.8427		95 02		sta $02,x	                sta 2,x
.8429		90 02		bcc $842d	                bcc +
.842b		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.842d						+
.842d		68		pla		                pla
.842e		0a		asl a		                asl a                   ; Double to cut off both top and bottom.
.842f		f5 00		sbc $00,x	                sbc 0,x
.8431		49 ff		eor #$ff	                eor #$ff
.8433		95 00		sta $00,x	                sta 0,x
.8435		90 02		bcc $8439	                bcc +                   ; note inverted carry check
.8437		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8439						+
.8439						_underflow_strip:
.8439		a5 29		lda $29		                lda tmp3
.843b		29 10		and #$10	                and #UF
.843d		f0 1f		beq $845e	                beq _check_limit
.843f		a0 02		ldy #$02	                ldy #uf_strip_offset
.8441		b1 08		lda ($08),y	                lda (up),y
.8443		c8		iny		                iny
.8444		11 08		ora ($08),y	                ora (up),y
.8446		f0 16		beq $845e	                beq _check_limit
.8448		18		clc		                clc
.8449		b5 02		lda $02,x	                lda 2,x
.844b		69 03		adc #$03	                adc #3
.844d		95 02		sta $02,x	                sta 2,x
.844f		90 02		bcc $8453	                bcc +
.8451		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.8453						+
.8453		38		sec		                sec
.8454		b5 00		lda $00,x	                lda 0,x
.8456		e9 03		sbc #$03	                sbc #3
.8458		95 00		sta $00,x	                sta 0,x
.845a		b0 02		bcs $845e	                bcs +
.845c		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.845e						+
.845e						_check_limit:
.845e		a5 29		lda $29		                lda tmp3
.8460		29 02		and #$02	                and #AN                 ; check Always Native (AN) bit
.8462		d0 11		bne $8475	                bne cmpl_inline         ; always natively compile
.8464		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.8466		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.8468		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.846a		90 09		bcc $8475	                bcc cmpl_inline         ; borrow (C=1) means size < limit
.846c		d0 aa		bne $8418	                bne _compile_as_jsr     ; else non-zero means size > limit
.846e		88		dey		                dey
.846f		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.8471		d5 00		cmp $00,x	                cmp 0,x
.8473		30 a3		bmi $8418	                bmi _compile_as_jsr     ; size is too big
.8475						cmpl_inline:
.8475		20 02 8a	jsr $8a02	                jsr xt_here
.8478		20 4d 93	jsr $934d	                jsr xt_swap
.847b		20 42 87	jsr $8742	                jsr xt_dup
.847e		20 29 82	jsr $8229	                jsr xt_allot            ; allocate space for the word
.8481		20 03 8d	jsr $8d03	                jsr xt_move
.8484		60		rts		                rts
.8485						cmpl_inline_y:
.8485		ca		dex		                dex                 ; push Y TOS
.8486		ca		dex		                dex
.8487		94 00		sty $00,x	                sty 0,x
.8489		74 01		stz $01,x	                stz 1,x
.848b		80 e8		bra $8475	                bra cmpl_inline
.848d						strip_table:
>848d		f1 8f dc 8f 8b 94		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>8493		b4 95 3a 95			                .word xt_two_to_r, xt_two_r_from        ; 2>R, 2R>
=10						strip_table_size = * - strip_table
.8497						strip_size:
>8497		04 04 04			                .byte 4, 4, 4                           ; R>, R@, >R
>849a		06 06				                .byte 6, 6                              ; 2>R, 2R>
.849c						z_compile_comma:
.849c						xt_compile_only:
.849c		20 bb d6	jsr $d6bb	                jsr current_to_dp
.849f		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.84a1		b1 02		lda ($02),y	                lda (dp),y
.84a3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.84a5		91 02		sta ($02),y	                sta (dp),y
.84a7		60		rts		z_compile_only: rts
.84a8						xt_value:
.84a8						xt_constant:
.84a8		20 64 d7	jsr $d764	                jsr underflow_1
.84ab		20 00 85	jsr $8500	                jsr xt_create
.84ae		38		sec		                sec
.84af		a5 00		lda $00		                lda cp
.84b1		e9 02		sbc #$02	                sbc #2
.84b3		85 25		sta $25		                sta tmp1
.84b5		a5 01		lda $01		                lda cp+1
.84b7		e9 00		sbc #$00	                sbc #0
.84b9		85 26		sta $26		                sta tmp1+1
.84bb		a9 cc		lda #$cc	                lda #<doconst           ; LSB of DOCONST
.84bd		92 25		sta ($25)	                sta (tmp1)
.84bf		a0 01		ldy #$01	                ldy #1
.84c1		a9 d5		lda #$d5	                lda #>doconst           ; MSB of DOCONST
.84c3		91 25		sta ($25),y	                sta (tmp1),y
.84c5		20 cf 83	jsr $83cf	                jsr xt_comma            ; drop through to adjust_z
.84c8						adjust_z:
.84c8		20 b4 9b	jsr $9bb4	                jsr xt_latestnt         ; gives us ( -- nt )
.84cb		b5 00		lda $00,x	                lda 0,x
.84cd		85 25		sta $25		                sta tmp1
.84cf		b5 01		lda $01,x	                lda 1,x
.84d1		85 26		sta $26		                sta tmp1+1
.84d3		a0 06		ldy #$06	                ldy #6
.84d5		b1 25		lda ($25),y	                lda (tmp1),y
.84d7		18		clc		                clc
.84d8		69 02		adc #$02	                adc #2
.84da		91 25		sta ($25),y	                sta (tmp1),y
.84dc		c8		iny		                iny
.84dd		b1 25		lda ($25),y	                lda (tmp1),y
.84df		69 00		adc #$00	                adc #0                  ; only need carry
.84e1		91 25		sta ($25),y	                sta (tmp1),y
.84e3		e8		inx		                inx
.84e4		e8		inx		                inx
.84e5						z_value:
.84e5		60		rts		z_constant:     rts
.84e6						xt_count:
.84e6		20 64 d7	jsr $d764	                jsr underflow_1
.84e9		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.84eb		a8		tay		                tay
.84ec		f6 00		inc $00,x	                inc 0,x         ; LSB
.84ee		d0 02		bne $84f2	                bne +
.84f0		f6 01		inc $01,x	                inc 1,x         ; MSB
.84f2		98		tya		+               tya
.84f3		ca		dex		                dex
.84f4		ca		dex		                dex
.84f5		95 00		sta $00,x	                sta 0,x         ; LSB
.84f7		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.84f9		60		rts		z_count:        rts
.84fa						xt_cr:
.84fa		a9 0a		lda #$0a	                lda #AscLF
.84fc		20 ac 87	jsr $87ac	                jsr emit_a
.84ff		60		rts		z_cr:           rts
.8500						xt_create:
.8500		20 54 8e	jsr $8e54	                jsr xt_parse_name       ; ( addr u )
.8503		b5 00		lda $00,x	                lda 0,x
.8505		15 01		ora $01,x	                ora 1,x
.8507		d0 05		bne $850e	                bne _got_name
.8509		a9 05		lda #$05	                lda #err_noname
.850b		4c 7a d7	jmp $d77a	                jmp error
.850e						_got_name:
.850e		74 01		stz $01,x	                stz 1,x
.8510		20 ca 94	jsr $94ca	                jsr xt_two_dup          ; ( addr u addr u )
.8513		20 8b 9a	jsr $9a8b	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8516		b5 00		lda $00,x	                lda 0,x
.8518		15 01		ora $01,x	                ora 1,x
.851a		f0 1e		beq $853a	                beq _new_name           ; We haven't seen this one before.
.851c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.851d		e8		inx		                inx
.851e		24 1c		bit $1c		                bit status
.8520		10 08		bpl $852a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8522		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8524		05 1c		ora $1c		                ora status
.8526		85 1c		sta $1c		                sta status
.8528		80 18		bra $8542	                bra _process_name
.852a						_redefined_name:
.852a		a9 02		lda #$02	                lda #str_redefined
.852c		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf
.852f		20 ca 94	jsr $94ca	                jsr xt_two_dup           ; ( addr u addr u )
.8532		20 d4 95	jsr $95d4	                jsr xt_type
.8535		20 c8 92	jsr $92c8	                jsr xt_space
.8538		80 08		bra $8542	                bra _process_name
.853a						_new_name:
.853a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.853b		e8		inx		                inx
.853c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.853e		25 1c		and $1c		                and status
.8540		85 1c		sta $1c		                sta status
.8542						_process_name:
.8542		b5 00		lda $00,x	                lda 0,x
.8544		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8546		a5 00		lda $00		                lda cp
.8548		85 25		sta $25		                sta tmp1
.854a		a5 01		lda $01		                lda cp+1
.854c		85 26		sta $26		                sta tmp1+1
.854e		b5 00		lda $00,x	                lda 0,x
.8550		18		clc		                clc
.8551		69 08		adc #$08	                adc #8
.8553		85 29		sta $29		                sta tmp3                ; total header length
.8555		95 00		sta $00,x	                sta 0,x
.8557		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.8559		20 29 82	jsr $8229	                jsr xt_allot    ; ( addr )
.855c		20 bb d6	jsr $d6bb	                jsr current_to_dp
.855f		a0 00		ldy #$00	                ldy #0
.8561		a5 27		lda $27		                lda tmp2
.8563		91 25		sta ($25),y	                sta (tmp1),y
.8565		a9 08		lda #$08	                lda #NN
.8567		09 20		ora #$20	                ora #HC
.8569		c8		iny		                iny
.856a		91 25		sta ($25),y	                sta (tmp1),y
.856c		c8		iny		                iny
.856d		a5 02		lda $02		                lda dp
.856f		91 25		sta ($25),y	                sta (tmp1),y
.8571		c8		iny		                iny
.8572		a5 03		lda $03		                lda dp+1
.8574		91 25		sta ($25),y	                sta (tmp1),y
.8576		c8		iny		                iny
.8577		a5 26		lda $26		                lda tmp1+1
.8579		85 03		sta $03		                sta dp+1
.857b		a5 25		lda $25		                lda tmp1
.857d		85 02		sta $02		                sta dp
.857f		18		clc		                clc
.8580		65 29		adc $29		                adc tmp3        ; add total header length
.8582		91 25		sta ($25),y	                sta (tmp1),y
.8584		48		pha		                pha             ; we need this in the next step
.8585		c8		iny		                iny
.8586		a5 26		lda $26		                lda tmp1+1
.8588		69 00		adc #$00	                adc #0          ; only need the carry
.858a		91 25		sta ($25),y	                sta (tmp1),y
.858c		c8		iny		                iny
.858d		68		pla		                pla             ; LSB of "z_" address
.858e		18		clc		                clc
.858f		69 03		adc #$03	                adc #3
.8591		91 25		sta ($25),y	                sta (tmp1),y
.8593		88		dey		                dey             ; get the MSB of xt back
.8594		b1 25		lda ($25),y	                lda (tmp1),y
.8596		69 00		adc #$00	                adc #0          ; only need the carry
.8598		c8		iny		                iny
.8599		c8		iny		                iny
.859a		91 25		sta ($25),y	                sta (tmp1),y
.859c		c8		iny		                iny
.859d		b5 00		lda $00,x	                lda 0,x
.859f		38		sec		                sec
.85a0		e9 08		sbc #$08	                sbc #8
.85a2		85 23		sta $23		                sta tmptos
.85a4		b5 01		lda $01,x	                lda 1,x
.85a6		e9 00		sbc #$00	                sbc #0          ; only need carry
.85a8		85 24		sta $24		                sta tmptos+1
.85aa						_name_loop:
.85aa		b1 23		lda ($23),y	                lda (tmptos),y
.85ac		c9 5b		cmp #$5b	                cmp #'Z'+1
.85ae		b0 06		bcs $85b6	                bcs _store_name
.85b0		c9 41		cmp #$41	                cmp #'A'
.85b2		90 02		bcc $85b6	                bcc _store_name
.85b4		09 20		ora #$20	                ora #$20
.85b6						_store_name:
.85b6		91 25		sta ($25),y	                sta (tmp1),y
.85b8		c8		iny		                iny
.85b9		c6 27		dec $27		                dec tmp2
.85bb		d0 ed		bne $85aa	                bne _name_loop
.85bd		a0 d6		ldy #$d6	                ldy #>dovar
.85bf		a9 12		lda #$12	                lda #<dovar
.85c1		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.85c4		20 ce d6	jsr $d6ce	                jsr dp_to_current
.85c7		e8		inx		                inx
.85c8		e8		inx		                inx
.85c9		60		rts		z_create:       rts
.85ca						xt_decimal:
.85ca		a9 0a		lda #$0a	                lda #10
.85cc		85 18		sta $18		                sta base
.85ce		64 19		stz $19		                stz base+1              ; paranoid
.85d0		60		rts		z_decimal:      rts
.85d1						xt_defer:
.85d1		20 00 85	jsr $8500	                jsr xt_create
.85d4		a5 00		lda $00		                lda cp          ; LSB
.85d6		38		sec		                sec
.85d7		e9 02		sbc #$02	                sbc #2
.85d9		85 25		sta $25		                sta tmp1
.85db		a5 01		lda $01		                lda cp+1        ; MSB
.85dd		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.85df		85 26		sta $26		                sta tmp1+1
.85e1		a0 00		ldy #$00	                ldy #0
.85e3		a9 e0		lda #$e0	                lda #<dodefer   ; LSB
.85e5		91 25		sta ($25),y	                sta (tmp1),y
.85e7		c8		iny		                iny
.85e8		a9 d5		lda #$d5	                lda #>dodefer   ; MSB
.85ea		91 25		sta ($25),y	                sta (tmp1),y
.85ec		a9 f4		lda #$f4	                lda #<defer_error
.85ee		92 00		sta ($00)	                sta (cp)
.85f0		e6 00		inc $00		                inc cp
.85f2		d0 02		bne $85f6	                bne +
.85f4		e6 01		inc $01		                inc cp+1
.85f6						+
.85f6		a9 d5		lda #$d5	                lda #>defer_error
.85f8		92 00		sta ($00)	                sta (cp)
.85fa		e6 00		inc $00		                inc cp
.85fc		d0 02		bne $8600	                bne +
.85fe		e6 01		inc $01		                inc cp+1
.8600						+
.8600		20 c8 84	jsr $84c8	                jsr adjust_z    ; adjust header to correct length
.8603		60		rts		z_defer:        rts
.8604						xt_defer_fetch:
.8604		20 bd 93	jsr $93bd	                jsr xt_to_body
.8607		20 01 89	jsr $8901	                jsr xt_fetch
.860a		60		rts		z_defer_fetch:  rts
.860b						xt_defer_store:
.860b		20 bd 93	jsr $93bd	                jsr xt_to_body
.860e		20 37 93	jsr $9337	                jsr xt_store
.8611		60		rts		z_defer_store:  rts
.8612						xt_depth:
.8612		a9 78		lda #$78	                lda #dsp0
.8614		86 1e		stx $1e		                stx tmpdsp
.8616		38		sec		                sec
.8617		e5 1e		sbc $1e		                sbc tmpdsp
.8619		4a		lsr a		                lsr
.861a		ca		dex		                dex
.861b		ca		dex		                dex
.861c		95 00		sta $00,x	                sta 0,x
.861e		74 01		stz $01,x	                stz 1,x
.8620		60		rts		z_depth:        rts
.8621						xt_question_do:
.8621		ca		dex		                dex
.8622		ca		dex		                dex
.8623		a9 4e		lda #$4e	                lda #<question_do_runtime
.8625		95 00		sta $00,x	                sta 0,x
.8627		a9 86		lda #$86	                lda #>question_do_runtime
.8629		95 01		sta $01,x	                sta 1,x
.862b		a0 10		ldy #$10	                ldy #question_do_runtime_end-question_do_runtime
.862d		20 85 84	jsr $8485	                jsr cmpl_inline_y
.8630		20 b3 d5	jsr $d5b3	                jsr cmpl_jump_later
.8633		80 03		bra $8638	                bra do_common
.8635						xt_do:
.8635		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; push 0 TOS
.8638						do_common:
.8638		ca		dex		                dex
.8639		ca		dex		                dex
.863a		a5 21		lda $21		                lda loopleave
.863c		95 00		sta $00,x	                sta 0,x
.863e		a5 22		lda $22		                lda loopleave+1
.8640		95 01		sta $01,x	                sta 1,x
.8642		64 22		stz $22		                stz loopleave+1
.8644		a0 86		ldy #$86	                ldy #>do_runtime
.8646		a9 5e		lda #$5e	                lda #<do_runtime
.8648		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.864b		4c 02 8a	jmp $8a02	                jmp xt_here
.864e						z_question_do:
.864e						z_do:
.864e						question_do_runtime:
.864e		b5 00		lda $00,x	                lda 0,x
.8650		d5 02		cmp $02,x	                cmp 2,x
.8652		d0 0d		bne $8661	                bne question_do_begin
.8654		b5 01		lda $01,x	                lda 1,x
.8656		d5 03		cmp $03,x	                cmp 3,x
.8658		d0 07		bne $8661	                bne question_do_begin
.865a		e8		inx		                inx                     ; drop loop limits
.865b		e8		inx		                inx
.865c		e8		inx		                inx
.865d		e8		inx		                inx
.865e						question_do_runtime_end:
=$8661						question_do_begin = * + 3
.865e						do_runtime:
.865e		a4 1f		ldy $1f		                ldy loopctrl
.8660		30 05		bmi $8667	                bmi +                   ; is this the first LCB?
.8662		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.8664		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.8667						+
.8667		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.8668		c8		iny		                iny
.8669		c8		iny		                iny
.866a		c8		iny		                iny
.866b		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.866d		38		sec		                sec
.866e		a9 00		lda #$00	                lda #0
.8670		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.8672		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.8675		a9 80		lda #$80	                lda #$80
.8677		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.8679		99 03 01	sta $0103,y	                sta loopfufa+1,y
.867c		18		clc		                clc
.867d		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.867f		79 02 01	adc $0102,y	                adc loopfufa,y
.8682		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.8684		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.8686		79 03 01	adc $0103,y	                adc loopfufa+1,y
.8689		99 01 01	sta $0101,y	                sta loopindex+1,y
.868c		e8		inx		                inx                 ; clean up the stack
.868d		e8		inx		                inx
.868e		e8		inx		                inx
.868f		e8		inx		                inx
.8690		60		rts		                rts
.8691						xt_does:
.8691		a0 86		ldy #$86	                ldy #>does_runtime
.8693		a9 a0		lda #$a0	                lda #<does_runtime
.8695		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.8698		a0 d5		ldy #$d5	                ldy #>dodoes
.869a		a9 f9		lda #$f9	                lda #<dodoes
.869c		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.869f		60		rts		z_does:         rts
.86a0						does_runtime:
.86a0		7a		ply		                ply             ; LSB
.86a1		68		pla		                pla             ; MSB
.86a2		c8		iny		                iny
.86a3		d0 01		bne $86a6	                bne +
.86a5		1a		inc a		                ina
.86a6						+
.86a6		84 25		sty $25		                sty tmp1
.86a8		85 26		sta $26		                sta tmp1+1
.86aa		20 bb d6	jsr $d6bb	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.86ad		a5 02		lda $02		                lda dp
.86af		18		clc		                clc
.86b0		69 04		adc #$04	                adc #4
.86b2		85 27		sta $27		                sta tmp2
.86b4		a5 03		lda $03		                lda dp+1
.86b6		69 00		adc #$00	                adc #0          ; we only care about the carry
.86b8		85 28		sta $28		                sta tmp2+1
.86ba		b2 27		lda ($27)	                lda (tmp2)
.86bc		18		clc		                clc
.86bd		69 01		adc #$01	                adc #1
.86bf		85 29		sta $29		                sta tmp3
.86c1		a0 01		ldy #$01	                ldy #1
.86c3		b1 27		lda ($27),y	                lda (tmp2),y
.86c5		69 00		adc #$00	                adc #0          ; we only care about the carry
.86c7		85 2a		sta $2a		                sta tmp3+1
.86c9		a5 25		lda $25		                lda tmp1        ; LSB
.86cb		92 29		sta ($29)	                sta (tmp3)
.86cd		a5 26		lda $26		                lda tmp1+1
.86cf		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.86d1		60		rts		                rts
.86d2						xt_dot:
.86d2		20 64 d7	jsr $d764	                jsr underflow_1
.86d5		20 42 87	jsr $8742	                jsr xt_dup                      ; ( n n )
.86d8		20 d1 80	jsr $80d1	                jsr xt_abs                      ; ( n u )
.86db		20 8c 9d	jsr $9d8c	                jsr xt_zero                     ; ( n u 0 )
.86de		20 f8 8a	jsr $8af8	                jsr xt_less_number_sign         ; ( n u 0 )
.86e1		20 b6 8d	jsr $8db6	                jsr xt_number_sign_s            ; ( n ud )
.86e4		20 8e 90	jsr $908e	                jsr xt_rot                      ; ( ud n )
.86e7		20 4d 92	jsr $924d	                jsr xt_sign                     ; ( ud )
.86ea		20 94 8d	jsr $8d94	                jsr xt_number_sign_greater      ; ( addr u )
.86ed		20 d4 95	jsr $95d4	                jsr xt_type
.86f0		20 c8 92	jsr $92c8	                jsr xt_space
.86f3		60		rts		z_dot:          rts
.86f4						xt_dot_paren:
.86f4		ca		dex		                dex
.86f5		ca		dex		                dex
.86f6		a9 29		lda #$29	                lda #41     ; Right parenthesis
.86f8		95 00		sta $00,x	                sta 0,x
.86fa		74 01		stz $01,x	                stz 1,x
.86fc		20 af 8e	jsr $8eaf	                jsr xt_parse
.86ff		20 d4 95	jsr $95d4	                jsr xt_type
.8702		60		rts		z_dot_paren:    rts
.8703						xt_dot_quote:
.8703		20 d7 90	jsr $90d7	                jsr xt_s_quote
.8706		a0 95		ldy #$95	                ldy #>xt_type
.8708		a9 d4		lda #$d4	                lda #<xt_type
.870a		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.870d		60		rts		z_dot_quote:    rts
.870e						xt_dot_r:
.870e		20 69 d7	jsr $d769	                jsr underflow_2
.8711		20 8b 94	jsr $948b	                jsr xt_to_r
.8714		20 42 87	jsr $8742	                jsr xt_dup
.8717		20 d1 80	jsr $80d1	                jsr xt_abs
.871a		20 8c 9d	jsr $9d8c	                jsr xt_zero
.871d		20 f8 8a	jsr $8af8	                jsr xt_less_number_sign
.8720		20 b6 8d	jsr $8db6	                jsr xt_number_sign_s
.8723		20 8e 90	jsr $908e	                jsr xt_rot
.8726		20 4d 92	jsr $924d	                jsr xt_sign
.8729		20 94 8d	jsr $8d94	                jsr xt_number_sign_greater
.872c		20 f1 8f	jsr $8ff1	                jsr xt_r_from
.872f		20 08 8e	jsr $8e08	                jsr xt_over
.8732		20 e7 8c	jsr $8ce7	                jsr xt_minus
.8735		20 ce 92	jsr $92ce	                jsr xt_spaces
.8738		20 d4 95	jsr $95d4	                jsr xt_type
.873b		60		rts		z_dot_r:        rts
.873c						xt_drop:
.873c		20 64 d7	jsr $d764	                jsr underflow_1
.873f		e8		inx		                inx
.8740		e8		inx		                inx
.8741		60		rts		z_drop:         rts
.8742						xt_dup:
.8742		20 64 d7	jsr $d764	                jsr underflow_1
.8745		ca		dex		                dex
.8746		ca		dex		                dex
.8747		b5 02		lda $02,x	                lda 2,x         ; LSB
.8749		95 00		sta $00,x	                sta 0,x
.874b		b5 03		lda $03,x	                lda 3,x         ; MSB
.874d		95 01		sta $01,x	                sta 1,x
.874f		60		rts		z_dup:          rts
.8750						xt_else:
.8750						xt_endof:
.8750		20 b3 d5	jsr $d5b3	                jsr cmpl_jump_later
.8753		20 4d 93	jsr $934d	                jsr xt_swap         ; ( target orig )
.8756						xt_then:
.8756		20 02 8a	jsr $8a02	                jsr xt_here
.8759		a1 02		lda ($02,x)	                lda (2,x)           ; get LSB at orig
.875b		1a		inc a		                ina                 ; was LSB $FF?  (only check for $XXFF)
.875c		d0 3b		bne $8799	                bne _no_opt
.875e		20 ca 94	jsr $94ca	                jsr xt_two_dup
.8761		20 4d 93	jsr $934d	                jsr xt_swap
.8764		20 e7 8c	jsr $8ce7	                jsr xt_minus        ; ( C: orig here offset )
.8767		b5 01		lda $01,x	                lda 1,x
.8769		d0 2c		bne $8797	                bne _too_far        ; MSB must be zero
.876b		b5 00		lda $00,x	                lda 0,x
.876d		3a		dec a		                dea                 ; we want here - orig - 2
.876e		3a		dec a		                dea                 ; don't care about carry
.876f		30 26		bmi $8797	                bmi _too_far        ; up to 127 is ok
.8771		95 00		sta $00,x	                sta 0,x             ; stash offset - 2
.8773		38		sec		                sec                 ; put orig - 2 in tmp1
.8774		b5 04		lda $04,x	                lda 4,x
.8776		e9 02		sbc #$02	                sbc #2
.8778		85 25		sta $25		                sta tmp1
.877a		b5 05		lda $05,x	                lda 5,x
.877c		e9 00		sbc #$00	                sbc #0
.877e		85 26		sta $26		                sta tmp1+1
.8780		a0 00		ldy #$00	                ldy #0
.8782						-
.8782		b9 a1 87	lda $87a1,y	                lda beq_opt+1,y               ; skip the jsr
.8785		91 25		sta ($25),y	                sta (tmp1),y
.8787		c8		iny		                iny
.8788		c0 03		cpy #$03	                cpy #(beq_opt_end-beq_opt-2)  ; three bytes, skip jsr and offset
.878a		d0 f6		bne $8782	                bne -
.878c		b5 00		lda $00,x	                lda 0,x             ; write the offset
.878e		91 25		sta ($25),y	                sta (tmp1),y
.8790		e8		inx		                inx                 ; clear the stack
.8791		e8		inx		                inx
.8792		e8		inx		                inx
.8793		e8		inx		                inx
.8794		e8		inx		                inx
.8795		e8		inx		                inx
.8796		60		rts		                rts                 ; all done
.8797						_too_far:
.8797		e8		inx		                inx                 ; discard the offset we calculated
.8798		e8		inx		                inx
.8799						_no_opt:
.8799		20 4d 93	jsr $934d	                jsr xt_swap
.879c		20 37 93	jsr $9337	                jsr xt_store
.879f						z_else:
.879f						z_endof:
.879f		60		rts		z_then:         rts
.87a0						beq_opt:
.87a0		20 4c 8a	jsr $8a4c	                jsr zero_test_runtime       ; replaces jsr zero_branch_runtime
.87a3		f0 00		beq $87a5	                beq beq_opt_end             ; the beq overwrites the placeholder
.87a5						beq_opt_end:
.87a5						xt_emit:
.87a5		20 64 d7	jsr $d764	                jsr underflow_1
.87a8		b5 00		lda $00,x	                lda 0,x
.87aa		e8		inx		                inx
.87ab		e8		inx		                inx
.87ac						emit_a:
.87ac		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.87af						z_emit:
.87af						xt_endcase:
.87af		a0 87		ldy #$87	                ldy #>xt_drop
.87b1		a9 3c		lda #$3c	                lda #<xt_drop
.87b3		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.87b6						_endcase_loop:
.87b6		b5 00		lda $00,x	                lda 0,x
.87b8		15 01		ora $01,x	                ora 1,x
.87ba		f0 05		beq $87c1	                beq _done
.87bc		20 56 87	jsr $8756	                jsr xt_then
.87bf		80 f5		bra $87b6	                bra _endcase_loop
.87c1						_done:
.87c1		e8		inx		                inx
.87c2		e8		inx		                inx
.87c3		60		rts		z_endcase:      rts
.87c4						xt_environment_q:
.87c4		20 64 d7	jsr $d764	                jsr underflow_1
.87c7		a0 00		ldy #$00	                ldy #00                 ; counter for table
.87c9		5a		phy		                phy
.87ca						_table_loop:
.87ca		20 ca 94	jsr $94ca	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.87cd		ca		dex		                dex
.87ce		ca		dex		                dex                     ; ( addr u addr u ? )
.87cf		b9 41 88	lda $8841,y	                lda env_table_single,y
.87d2		95 00		sta $00,x	                sta 0,x
.87d4		c8		iny		                iny
.87d5		b9 41 88	lda $8841,y	                lda env_table_single,y
.87d8		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.87da		c8		iny		                iny
.87db		15 00		ora $00,x	                ora 0,x
.87dd		f0 4d		beq $882c	                beq _table_done
.87df		5a		phy		                phy                     ; save Y, which is used by COUNT
.87e0		20 e6 84	jsr $84e6	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.87e3		20 53 9f	jsr $9f53	                jsr xt_compare          ; ( addr u f )
.87e6		7a		ply		                ply
.87e7		b5 00		lda $00,x	                lda 0,x
.87e9		15 01		ora $01,x	                ora 1,x
.87eb		f0 04		beq $87f1	                beq _got_result
.87ed		e8		inx		                inx                     ; DROP, now ( addr u )
.87ee		e8		inx		                inx
.87ef		80 d9		bra $87ca	                bra _table_loop
.87f1						_got_result:
.87f1		e8		inx		                inx                     ; drop flag, now ( addr u )
.87f2		e8		inx		                inx
.87f3		88		dey		                dey                     ; go back to index we had
.87f4		88		dey		                dey
.87f5		68		pla		                pla
.87f6		d0 0d		bne $8805	                bne _double_result
.87f8		b9 5f 88	lda $885f,y	                lda env_results_single,y
.87fb		95 02		sta $02,x	                sta 2,x
.87fd		c8		iny		                iny
.87fe		b9 5f 88	lda $885f,y	                lda env_results_single,y
.8801		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8803		80 1f		bra $8824	                bra _set_flag
.8805						_double_result:
.8805		ca		dex		                dex                     ; ( addr u ? )
.8806		ca		dex		                dex
.8807		98		tya		                tya
.8808		38		sec		                sec
.8809		e9 18		sbc #$18	                sbc #24
.880b		0a		asl a		                asl
.880c		a8		tay		                tay
.880d		b9 75 88	lda $8875,y	                lda env_results_double,y
.8810		95 02		sta $02,x	                sta 2,x
.8812		c8		iny		                iny
.8813		b9 75 88	lda $8875,y	                lda env_results_double,y
.8816		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8818		c8		iny		                iny
.8819		b9 75 88	lda $8875,y	                lda env_results_double,y
.881c		95 04		sta $04,x	                sta 4,x
.881e		c8		iny		                iny
.881f		b9 75 88	lda $8875,y	                lda env_results_double,y
.8822		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8824						_set_flag:
.8824		a9 ff		lda #$ff	                lda #$FF
.8826		95 00		sta $00,x	                sta 0,x
.8828		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.882a		80 14		bra $8840	                bra _done
.882c						_table_done:
.882c		68		pla		                pla
.882d		d0 09		bne $8838	                bne _no_match
.882f		1a		inc a		                ina
.8830		48		pha		                pha
.8831		8a		txa		                txa
.8832		18		clc		                clc
.8833		69 06		adc #$06	                adc #6                  ; skip six bytes
.8835		aa		tax		                tax                     ; ( addr u )
.8836		80 92		bra $87ca	                bra _table_loop
.8838						_no_match:
.8838		8a		txa		                txa
.8839		18		clc		                clc
.883a		69 0a		adc #$0a	                adc #10
.883c		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.883d		20 8c 9d	jsr $9d8c	                jsr xt_false
.8840						_done:
.8840						z_environment_q:
.8840		60		rts		                rts
.8841						env_table_single:
>8841		0e d5 1e d5 24 d5 29 d5		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8849		3b d5
>884b		43 d5 4c d5 52 d5 58 d5		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8853		6b d5 77 d5 00 00		        .word envs_sc, envs_wl, 0000
.8859						env_table_double:
>8859		81 d5 87 d5 00 00		        .word envs_max_d, envs_max_ud, 0000
.885f						env_results_single:
>885f		ff 00				        .word $00FF     ; /COUNTED-STRING
>8861		ff 00				        .word $00FF     ; /HOLD
>8863		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8865		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8867		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8869		ff 00				        .word $00FF     ; MAX-CHAR
>886b		ff 7f				        .word $7FFF     ; MAX-N
>886d		ff ff				        .word $FFFF     ; MAX-U
>886f		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8871		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8873		09 00				        .word $0009     ; WORDLISTS
.8875						env_results_double:
>8875		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8879		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.887d						xt_equal:
.887d		20 69 d7	jsr $d769	                jsr underflow_2
.8880		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8882		d5 02		cmp $02,x	                cmp 2,x
.8884		d0 0a		bne $8890	                bne _false
.8886		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8888		d5 03		cmp $03,x	                cmp 3,x
.888a		d0 04		bne $8890	                bne _false
.888c		a9 ff		lda #$ff	                lda #$FF
.888e		80 02		bra $8892	                bra _done
.8890		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8892		95 02		sta $02,x	_done:          sta 2,x
.8894		95 03		sta $03,x	                sta 3,x
.8896		e8		inx		                inx
.8897		e8		inx		                inx
.8898		60		rts		z_equal:        rts
.8899						xt_blank:
.8899		ca		dex		                dex
.889a		ca		dex		                dex
.889b		a9 20		lda #$20	                lda #AscSP
.889d		95 00		sta $00,x	                sta 0,x
.889f		74 01		stz $01,x	                stz 1,x
.88a1		80 06		bra $88a9	                bra xt_fill     ; skip over code for ERASE
.88a3						xt_erase:
.88a3		ca		dex		                dex
.88a4		ca		dex		                dex
.88a5		74 00		stz $00,x	                stz 0,x
.88a7		74 01		stz $01,x	                stz 1,x
.88a9						xt_fill:
.88a9		20 6e d7	jsr $d76e	                jsr underflow_3
.88ac		b5 04		lda $04,x	                lda 4,x         ; LSB
.88ae		85 25		sta $25		                sta tmp1
.88b0		b5 05		lda $05,x	                lda 5,x
.88b2		85 26		sta $26		                sta tmp1+1
.88b4		b5 02		lda $02,x	                lda 2,x
.88b6		85 27		sta $27		                sta tmp2
.88b8		b5 03		lda $03,x	                lda 3,x
.88ba		85 28		sta $28		                sta tmp2+1
.88bc		b5 00		lda $00,x	                lda 0,x
.88be		a8		tay		                tay
.88bf						_loop:
.88bf		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.88c1		c5 26		cmp $26		                cmp tmp1+1
.88c3		90 21		bcc $88e6	                bcc _done               ; RAM_END < TMP1, so leave
.88c5		d0 06		bne $88cd	                bne _check_counter      ; RAM_END is not smaller and not equal
.88c7		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.88c9		c5 25		cmp $25		                cmp tmp1
.88cb		90 19		bcc $88e6	                bcc _done               ; RAM_END < TMP1, so leave
.88cd						_check_counter:
.88cd		a5 27		lda $27		                lda tmp2
.88cf		05 28		ora $28		                ora tmp2+1
.88d1		f0 13		beq $88e6	                beq _done
.88d3		98		tya		                tya
.88d4		92 25		sta ($25)	                sta (tmp1)
.88d6		a5 27		lda $27		                lda tmp2
.88d8		d0 02		bne $88dc	                bne +
.88da		c6 28		dec $28		                dec tmp2+1
.88dc		c6 27		dec $27		+               dec tmp2
.88de		e6 25		inc $25		                inc tmp1
.88e0		d0 dd		bne $88bf	                bne _loop
.88e2		e6 26		inc $26		                inc tmp1+1
.88e4		80 d9		bra $88bf	                bra _loop
.88e6						_done:
.88e6		8a		txa		                txa
.88e7		18		clc		                clc
.88e8		69 06		adc #$06	                adc #6
.88ea		aa		tax		                tax
.88eb						z_blank:
.88eb						z_erase:
.88eb		60		rts		z_fill:         rts
.88ec						xt_execute:
.88ec		20 64 d7	jsr $d764	                jsr underflow_1
.88ef		20 f3 88	jsr $88f3	                jsr doexecute   ; do not combine to JMP (native coding)
.88f2		60		rts		z_execute:      rts
.88f3						doexecute:
.88f3		b5 00		lda $00,x	                lda 0,x
.88f5		85 04		sta $04		                sta ip
.88f7		b5 01		lda $01,x	                lda 1,x
.88f9		85 05		sta $05		                sta ip+1
.88fb		e8		inx		                inx
.88fc		e8		inx		                inx
.88fd		6c 04 00	jmp ($0004)	                jmp (ip)
.8900						xt_exit:
.8900		60		rts		                rts             ; keep before z_exit
.8901						z_exit:
.8901						xt_fetch:
.8901		20 64 d7	jsr $d764	                jsr underflow_1
.8904		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8906		a8		tay		                tay
.8907		f6 00		inc $00,x	                inc 0,x
.8909		d0 02		bne $890d	                bne +
.890b		f6 01		inc $01,x	                inc 1,x
.890d						+
.890d		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.890f		95 01		sta $01,x	                sta 1,x
.8911		94 00		sty $00,x	                sty 0,x
.8913		60		rts		z_fetch:        rts
.8914						xt_find:
.8914		20 64 d7	jsr $d764	                jsr underflow_1
.8917		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8919		48		pha		                pha
.891a		b5 00		lda $00,x	                lda 0,x                 ; LSB
.891c		48		pha		                pha
.891d		20 e6 84	jsr $84e6	                jsr xt_count            ; ( caddr -- addr u )
.8920		20 8b 9a	jsr $9a8b	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8923		b5 00		lda $00,x	                lda 0,x
.8925		15 01		ora $01,x	                ora 1,x
.8927		d0 0b		bne $8934	                bne _found_word
.8929		20 8c 9d	jsr $9d8c	                jsr xt_false            ; ( 0 0 )
.892c		68		pla		                pla                     ; LSB of address
.892d		95 02		sta $02,x	                sta 2,x
.892f		68		pla		                pla
.8930		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8932		80 27		bra $895b	                bra _done               ; ( addr 0 )
.8934						_found_word:
.8934		68		pla		                pla
.8935		68		pla		                pla
.8936		20 42 87	jsr $8742	                jsr xt_dup              ; ( nt nt )
.8939		20 c9 9b	jsr $9bc9	                jsr xt_name_to_int      ; ( nt xt )
.893c		20 4d 93	jsr $934d	                jsr xt_swap             ; ( xt nt )
.893f		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8941		f6 00		inc $00,x	                inc 0,x
.8943		d0 02		bne $8947	                bne +
.8945		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8947						+
.8947		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8949		29 04		and #$04	                and #IM
.894b		d0 08		bne $8955	                bne _immediate          ; bit set, we're immediate
.894d		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.894f		95 00		sta $00,x	                sta 0,x
.8951		95 01		sta $01,x	                sta 1,x
.8953		80 06		bra $895b	                bra _done
.8955						_immediate:
.8955		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8957		95 00		sta $00,x	                sta 0,x
.8959		74 01		stz $01,x	                stz 1,x
.895b						_done:
.895b		60		rts		z_find:         rts
.895c						xt_fm_slash_mod:
.895c		20 6e d7	jsr $d76e	                jsr underflow_3
.895f		64 27		stz $27		                stz tmp2        ; default: n is positive
.8961		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8963		10 0e		bpl $8973	                bpl _check_d
.8965		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.8967		20 22 8d	jsr $8d22	                jsr xt_negate   ; NEGATE
.896a		20 8b 94	jsr $948b	                jsr xt_to_r     ; >R
.896d		20 fa 9d	jsr $9dfa	                jsr xt_dnegate  ; DNEGATE
.8970		20 f1 8f	jsr $8ff1	                jsr xt_r_from   ; R>
.8973						_check_d:
.8973		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.8975		10 0d		bpl $8984	                bpl _multiply
.8977		18		clc		                clc
.8978		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.897a		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.897c		95 02		sta $02,x	                sta 2,x
.897e		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8980		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.8982		95 03		sta $03,x	                sta 3,x
.8984						_multiply:
.8984		20 59 96	jsr $9659	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.8987		a5 27		lda $27		                lda tmp2
.8989		f0 07		beq $8992	                beq _done
.898b		e8		inx		                inx             ; pretend that we SWAP
.898c		e8		inx		                inx
.898d		20 22 8d	jsr $8d22	                jsr xt_negate
.8990		ca		dex		                dex
.8991		ca		dex		                dex
.8992						_done:
.8992		60		rts		z_fm_slash_mod: rts
.8993						load_evaluate:
.8993		a9 ff		lda #$ff	                lda #$FF
.8995		85 25		sta $25		                sta tmp1
.8997		80 11		bra $89aa	                bra load_evaluate_start
.8999						xt_evaluate:
.8999		20 69 d7	jsr $d769	                jsr underflow_2
.899c		64 25		stz $25		                stz tmp1
.899e		b5 00		lda $00,x	                lda 0,x
.89a0		15 01		ora $01,x	                ora 1,x
.89a2		d0 06		bne $89aa	                bne evaluate_got_work
.89a4		e8		inx		                inx
.89a5		e8		inx		                inx
.89a6		e8		inx		                inx
.89a7		e8		inx		                inx
.89a8		80 42		bra $89ec	                bra evaluate_done
.89aa						load_evaluate_start:
.89aa						evaluate_got_work:
.89aa		a0 05		ldy #$05	                ldy #blk_offset+1
.89ac		b1 08		lda ($08),y	                lda (up),y
.89ae		48		pha		                pha
.89af		88		dey		                dey
.89b0		b1 08		lda ($08),y	                lda (up),y
.89b2		48		pha		                pha
.89b3		a5 25		lda $25		                lda tmp1
.89b5		d0 05		bne $89bc	                bne _nozero
.89b7		91 08		sta ($08),y	                sta (up),y
.89b9		c8		iny		                iny
.89ba		91 08		sta ($08),y	                sta (up),y
.89bc						_nozero:
.89bc		20 2d 9b	jsr $9b2d	                jsr xt_input_to_r
.89bf		a9 ff		lda #$ff	                lda #$FF
.89c1		85 0a		sta $0a		                sta insrc
.89c3		85 0b		sta $0b		                sta insrc+1
.89c5		64 10		stz $10		                stz toin
.89c7		64 11		stz $11		                stz toin+1
.89c9		b5 00		lda $00,x	                lda 0,x
.89cb		85 0e		sta $0e		                sta ciblen
.89cd		b5 01		lda $01,x	                lda 1,x
.89cf		85 0f		sta $0f		                sta ciblen+1
.89d1		b5 02		lda $02,x	                lda 2,x
.89d3		85 0c		sta $0c		                sta cib
.89d5		b5 03		lda $03,x	                lda 3,x
.89d7		85 0d		sta $0d		                sta cib+1
.89d9		e8		inx		                inx             ; A clean stack is a clean mind
.89da		e8		inx		                inx
.89db		e8		inx		                inx
.89dc		e8		inx		                inx
.89dd		20 e1 d6	jsr $d6e1	                jsr interpret   ; ( -- )
.89e0		20 3a 9d	jsr $9d3a	                jsr xt_r_to_input
.89e3		a0 04		ldy #$04	                ldy #blk_offset
.89e5		68		pla		                pla
.89e6		91 08		sta ($08),y	                sta (up),y
.89e8		c8		iny		                iny
.89e9		68		pla		                pla
.89ea		91 08		sta ($08),y	                sta (up),y
.89ec						evaluate_done:
.89ec		60		rts		z_evaluate:     rts
.89ed						xt_greater_than:
.89ed		20 69 d7	jsr $d769	                jsr underflow_2
.89f0		a0 00		ldy #$00	                ldy #0          ; default false
.89f2		20 a2 d6	jsr $d6a2	                jsr compare_16bit
.89f5		f0 03		beq $89fa	                beq _false
.89f7		10 01		bpl $89fa	                bpl _false
.89f9		88		dey		                dey
.89fa						_false:
.89fa		98		tya		                tya
.89fb		e8		inx		                inx
.89fc		e8		inx		                inx
.89fd		95 00		sta $00,x	                sta 0,x
.89ff		95 01		sta $01,x	                sta 1,x
.8a01		60		rts		z_greater_than: rts
.8a02						xt_here:
.8a02						xt_begin:
.8a02						xt_asm_arrow:
.8a02		ca		dex		                dex
.8a03		ca		dex		                dex
.8a04		a5 00		lda $00		                lda cp
.8a06		95 00		sta $00,x	                sta 0,x
.8a08		a5 01		lda $01		                lda cp+1
.8a0a		95 01		sta $01,x	                sta 1,x
.8a0c						z_here:
.8a0c						z_begin:
.8a0c						z_asm_arrow:
.8a0c		60		rts		                rts
.8a0d						xt_hex:
.8a0d		a9 10		lda #$10	                lda #16
.8a0f		85 18		sta $18		                sta base
.8a11		64 19		stz $19		                stz base+1              ; paranoid
.8a13		60		rts		z_hex:          rts
.8a14						xt_hold:
.8a14		20 64 d7	jsr $d764	                jsr underflow_1
.8a17		a5 2b		lda $2b		                lda tohold
.8a19		d0 02		bne $8a1d	                bne +
.8a1b		c6 2c		dec $2c		                dec tohold+1
.8a1d						+
.8a1d		c6 2b		dec $2b		                dec tohold
.8a1f		b5 00		lda $00,x	                lda 0,x
.8a21		92 2b		sta ($2b)	                sta (tohold)
.8a23		e8		inx		                inx
.8a24		e8		inx		                inx
.8a25		60		rts		z_hold:         rts
.8a26						xt_i:
.8a26		ca		dex		                dex
.8a27		ca		dex		                dex
.8a28		a4 1f		ldy $1f		                ldy loopctrl
.8a2a		38		sec		                sec
.8a2b		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.8a2d		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8a30		95 00		sta $00,x	                sta 0,x
.8a32		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8a35		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8a38		95 01		sta $01,x	                sta 1,x
.8a3a		60		rts		z_i:            rts
.8a3b						xt_if:
.8a3b		a0 8a		ldy #$8a	                ldy #>zero_branch_runtime
.8a3d		a9 56		lda #$56	                lda #<zero_branch_runtime
.8a3f		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.8a42		20 02 8a	jsr $8a02	                jsr xt_here
.8a45		a9 ff		lda #$ff	                lda #$FF
.8a47		a8		tay		                tay
.8a48		20 9a d5	jsr $d59a	                jsr cmpl_word_ya
.8a4b		60		rts		z_if:           rts
.8a4c						zero_test_runtime:
.8a4c		e8		inx		                inx
.8a4d		e8		inx		                inx
.8a4e		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.8a50		15 ff		ora $ff,x	                ora $FF,x
.8a52		60		rts		                rts
.8a53		d0 03		bne $8a58	                bne zero_test_footer_end+2  ; branch fwd if non-zero
>8a55		4c				                .byte OpJMP                 ; else JMP back
.8a56						zero_test_footer_end:
.8a56						zero_branch_runtime:
.8a56		68		pla		                pla
.8a57		85 25		sta $25		                sta tmp1
.8a59		68		pla		                pla
.8a5a		85 26		sta $26		                sta tmp1+1
.8a5c		b5 00		lda $00,x	                lda 0,x
.8a5e		15 01		ora $01,x	                ora 1,x
.8a60		f0 0d		beq $8a6f	                beq _zero
.8a62		a5 25		lda $25		                lda tmp1        ; LSB
.8a64		18		clc		                clc
.8a65		69 03		adc #$03	                adc #3          ; add one to RTS address plus two address bytes
.8a67		85 25		sta $25		                sta tmp1
.8a69		90 11		bcc $8a7c	                bcc _jump
.8a6b		e6 26		inc $26		                inc tmp1+1      ; MSB
.8a6d		80 0d		bra $8a7c	                bra _jump
.8a6f						_zero:
.8a6f		a0 01		ldy #$01	                ldy #1
.8a71		b1 25		lda ($25),y	                lda (tmp1),y
.8a73		48		pha		                pha
.8a74		c8		iny		                iny
.8a75		b1 25		lda ($25),y	                lda (tmp1),y
.8a77		85 26		sta $26		                sta tmp1+1
.8a79		68		pla		                pla
.8a7a		85 25		sta $25		                sta tmp1
.8a7c						_jump:
.8a7c		e8		inx		                inx
.8a7d		e8		inx		                inx
.8a7e		6c 25 00	jmp ($0025)	                jmp (tmp1)
.8a81						xt_immediate:
.8a81		20 bb d6	jsr $d6bb	                jsr current_to_dp
.8a84		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8a86		b1 02		lda ($02),y	                lda (dp),y
.8a88		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.8a8a		91 02		sta ($02),y	                sta (dp),y
.8a8c		60		rts		z_immediate:    rts
.8a8d						xt_invert:
.8a8d		20 64 d7	jsr $d764	                jsr underflow_1
.8a90		a9 ff		lda #$ff	                lda #$FF
.8a92		55 00		eor $00,x	                eor 0,x         ; LSB
.8a94		95 00		sta $00,x	                sta 0,x
.8a96		a9 ff		lda #$ff	                lda #$FF
.8a98		55 01		eor $01,x	                eor 1,x         ; MSB
.8a9a		95 01		sta $01,x	                sta 1,x
.8a9c		60		rts		z_invert:       rts
.8a9d						xt_is:
.8a9d		a5 1a		lda $1a		                lda state
.8a9f		05 1b		ora $1b		                ora state+1
.8aa1		f0 0c		beq $8aaf	                beq _interpreting
.8aa3						_compiling:
.8aa3		20 16 83	jsr $8316	                jsr xt_bracket_tick
.8aa6		a0 86		ldy #$86	                ldy #>xt_defer_store
.8aa8		a9 0b		lda #$0b	                lda #<xt_defer_store
.8aaa		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.8aad		80 06		bra $8ab5	                bra _done
.8aaf						_interpreting:
.8aaf		20 61 93	jsr $9361	                jsr xt_tick
.8ab2		20 0b 86	jsr $860b	                jsr xt_defer_store
.8ab5						_done:
.8ab5		60		rts		z_is:           rts
.8ab6						xt_j:
.8ab6		ca		dex		                dex                 ; make space on the stack
.8ab7		ca		dex		                dex
.8ab8		a5 1f		lda $1f		                lda loopctrl
.8aba		38		sec		                sec
.8abb		e9 04		sbc #$04	                sbc #4
.8abd		a8		tay		                tay
.8abe		38		sec		                sec
.8abf		b9 00 01	lda $0100,y	                lda loopindex,y
.8ac2		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8ac5		95 00		sta $00,x	                sta 0,x
.8ac7		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8aca		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8acd		95 01		sta $01,x	                sta 1,x
.8acf		60		rts		z_j:            rts
.8ad0						xt_key:
.8ad0		20 da 8a	jsr $8ada	                jsr key_a               ; returns char in A
.8ad3		ca		dex		                dex
.8ad4		ca		dex		                dex
.8ad5		95 00		sta $00,x	                sta 0,x
.8ad7		74 01		stz $01,x	                stz 1,x
.8ad9		60		rts		z_key:          rts
.8ada						key_a:
.8ada		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.8add						xt_leave:
.8add		a5 21		lda $21		                lda loopleave
.8adf		a4 22		ldy $22		                ldy loopleave+1
.8ae1		20 93 d5	jsr $d593	                jsr cmpl_jump_ya   ; emit the JMP chaining prior leave address
.8ae4		38		sec		                sec
.8ae5		a5 00		lda $00		                lda cp
.8ae7		e9 02		sbc #$02	                sbc #2
.8ae9		85 21		sta $21		                sta loopleave
.8aeb		a5 01		lda $01		                lda cp+1
.8aed		b0 01		bcs $8af0	                bcs +
.8aef		3a		dec a		                dea
.8af0		85 22		sta $22		+               sta loopleave+1
.8af2						z_leave:
.8af2		60		rts		                rts
.8af3						xt_left_bracket:
.8af3		64 1a		stz $1a		                stz state
.8af5		64 1b		stz $1b		                stz state+1
.8af7		60		rts		z_left_bracket: rts
.8af8						xt_less_number_sign:
.8af8		20 16 8e	jsr $8e16	                jsr xt_pad      ; ( addr )
.8afb		b5 00		lda $00,x	                lda 0,x
.8afd		85 2b		sta $2b		                sta tohold
.8aff		b5 01		lda $01,x	                lda 1,x
.8b01		85 2c		sta $2c		                sta tohold+1
.8b03		e8		inx		                inx
.8b04		e8		inx		                inx
.8b05						z_less_number_sign:
.8b05		60		rts		                rts
.8b06						xt_less_than:
.8b06		20 69 d7	jsr $d769	                jsr underflow_2
.8b09		a0 00		ldy #$00	                ldy #0          ; default false
.8b0b		20 a2 d6	jsr $d6a2	                jsr compare_16bit
.8b0e		f0 03		beq $8b13	                beq _false
.8b10		30 01		bmi $8b13	                bmi _false
.8b12		88		dey		                dey
.8b13						_false:
.8b13		98		tya		                tya
.8b14		e8		inx		                inx
.8b15		e8		inx		                inx
.8b16		95 00		sta $00,x	                sta 0,x
.8b18		95 01		sta $01,x	                sta 1,x
.8b1a		60		rts		z_less_than:    rts
.8b1b						xt_literal:
.8b1b		20 64 d7	jsr $d764	                jsr underflow_1
.8b1e		a9 0a		lda #$0a	                lda # z_template_push_tos - template_push_tos
.8b20		20 bd d5	jsr $d5bd	                jsr check_nc_limit
.8b23		90 0c		bcc $8b31	                bcc _inline
.8b25		a0 8b		ldy #$8b	                ldy #>literal_runtime
.8b27		a9 63		lda #$63	                lda #<literal_runtime
.8b29		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.8b2c		20 cf 83	jsr $83cf	                jsr xt_comma
.8b2f		80 27		bra $8b58	                bra z_literal
.8b31						_inline:
.8b31		a9 94		lda #$94	                lda #$94        ; sty zp,x
.8b33		b4 01		ldy $01,x	                ldy 1,x
.8b35		d0 02		bne $8b39	                bne +
.8b37		a9 74		lda #$74	                lda #$74        ; stz zp,x
.8b39						+
.8b39		48		pha		                pha
.8b3a		b5 00		lda $00,x	                lda 0,x
.8b3c		48		pha		                pha
.8b3d		98		tya		                tya             ; Y has the MSB
.8b3e		f0 03		beq $8b43	                beq +
.8b40		48		pha		                pha
.8b41		a9 02		lda #$02	                lda #2
.8b43						+
.8b43		49 02		eor #$02	                eor #2          ; invert A=0/2 to Y=2/0
.8b45		a8		tay		                tay
.8b46		b9 59 8b	lda $8b59,y	_copy:          lda template_push_tos,y
.8b49		c9 ff		cmp #$ff	                cmp #$ff
.8b4b		d0 01		bne $8b4e	                bne +
.8b4d		68		pla		                pla
.8b4e		20 9e d5	jsr $d59e	+               jsr cmpl_byte_a
.8b51		c8		iny		                iny
.8b52		c0 0a		cpy #$0a	                cpy #z_template_push_tos - template_push_tos
.8b54		d0 f0		bne $8b46	                bne _copy
.8b56		e8		inx		                inx             ; drop the literal
.8b57		e8		inx		                inx
.8b58		60		rts		z_literal:      rts
.8b59						template_push_tos:
.8b59		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8b5b		a9 ff		lda #$ff	                lda #$ff
.8b5d		ca		dex		                dex
.8b5e		ca		dex		                dex
.8b5f		95 00		sta $00,x	                sta 0,x
>8b61		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
.8b63						z_template_push_tos:
.8b63						literal_runtime:
.8b63		ca		dex		                dex
.8b64		ca		dex		                dex
.8b65		68		pla		                pla             ; LSB
.8b66		85 25		sta $25		                sta tmp1
.8b68		68		pla		                pla             ; MSB
.8b69		85 26		sta $26		                sta tmp1+1
.8b6b		a0 01		ldy #$01	                ldy #1
.8b6d		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8b6f		95 00		sta $00,x	                sta 0,x
.8b71		c8		iny		                iny
.8b72		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8b74		95 01		sta $01,x	                sta 1,x
.8b76		98		tya		                tya
.8b77		18		clc		                clc
.8b78		65 25		adc $25		                adc tmp1
.8b7a		a8		tay		                tay
.8b7b		a5 26		lda $26		                lda tmp1+1
.8b7d		69 00		adc #$00	                adc #0
.8b7f		48		pha		                pha
.8b80		5a		phy		                phy
.8b81		60		rts		                rts
.8b82						xt_loop:
.8b82		ca		dex		                dex
.8b83		ca		dex		                dex
.8b84		a9 e5		lda #$e5	                lda #<loop_runtime
.8b86		95 00		sta $00,x	                sta 0,x
.8b88		a9 8b		lda #$8b	                lda #>loop_runtime
.8b8a		95 01		sta $01,x	                sta 1,x
.8b8c		a0 11		ldy #$11	                ldy #loop_runtime_end-loop_runtime
.8b8e		20 85 84	jsr $8485	                jsr cmpl_inline_y
.8b91		80 0f		bra $8ba2	                bra xt_loop_common
.8b93						xt_plus_loop:
.8b93		ca		dex		                dex
.8b94		ca		dex		                dex
.8b95		a9 f6		lda #$f6	                lda #<plus_loop_runtime
.8b97		95 00		sta $00,x	                sta 0,x
.8b99		a9 8b		lda #$8b	                lda #>plus_loop_runtime
.8b9b		95 01		sta $01,x	                sta 1,x
.8b9d		a0 1a		ldy #$1a	                ldy #plus_loop_runtime_end-plus_loop_runtime
.8b9f		20 85 84	jsr $8485	                jsr cmpl_inline_y
.8ba2						xt_loop_common:
.8ba2		20 ab d5	jsr $d5ab	                jsr cmpl_jump_tos
.8ba5		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8ba7		f0 19		beq $8bc2	                beq _noleave
.8ba9						_next:
.8ba9		a0 01		ldy #$01	                ldy #1
.8bab		b1 21		lda ($21),y	                lda (loopleave),y
.8bad		48		pha		                pha
.8bae		a5 01		lda $01		                lda cp+1
.8bb0		91 21		sta ($21),y	                sta (loopleave),y
.8bb2		88		dey		                dey
.8bb3		b1 21		lda ($21),y	                lda (loopleave),y
.8bb5		48		pha		                pha
.8bb6		a5 00		lda $00		                lda cp
.8bb8		91 21		sta ($21),y	                sta (loopleave),y
.8bba		68		pla		                pla
.8bbb		85 21		sta $21		                sta loopleave
.8bbd		68		pla		                pla
.8bbe		85 22		sta $22		                sta loopleave+1
.8bc0		d0 e7		bne $8ba9	                bne _next
.8bc2						_noleave:
.8bc2		b5 00		lda $00,x	                lda 0,x
.8bc4		85 21		sta $21		                sta loopleave
.8bc6		b5 01		lda $01,x	                lda 1,x
.8bc8		85 22		sta $22		                sta loopleave+1
.8bca		a9 e1		lda #$e1	                lda #<xt_unloop
.8bcc		95 00		sta $00,x	                sta 0,x
.8bce		a9 96		lda #$96	                lda #>xt_unloop
.8bd0		95 01		sta $01,x	                sta 1,x
.8bd2		20 de 83	jsr $83de	                jsr xt_compile_comma
.8bd5		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8bd7		f0 09		beq $8be2	                beq +
.8bd9		20 02 8a	jsr $8a02	                jsr xt_here
.8bdc		20 4d 93	jsr $934d	                jsr xt_swap
.8bdf		4c 37 93	jmp $9337	                jmp xt_store            ; write here as ?DO jmp target and return
.8be2		e8		inx		+               inx                     ; drop the ignored word for DO
.8be3		e8		inx		                inx
.8be4						z_loop:
.8be4		60		rts		z_plus_loop:    rts
.8be5						loop_runtime:
.8be5		e6 20		inc $20		                inc loopidx0        ; increment the LSB of loopindex
.8be7		d0 0d		bne $8bf6	                bne _repeat         ; avoid expensive test most of the time
.8be9		a4 1f		ldy $1f		                ldy loopctrl
.8beb		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8bee		1a		inc a		                ina
.8bef		c9 80		cmp #$80	                cmp #$80
.8bf1		f0 06		beq $8bf9	                beq _repeat+3       ; done?  skip jmp back
.8bf3		99 01 01	sta $0101,y	                sta loopindex+1,y
.8bf6						_repeat:
.8bf6						loop_runtime_end:
.8bf6						plus_loop_runtime:
.8bf6		18		clc		                clc
.8bf7		b5 00		lda $00,x	                lda 0,x             ; LSB of step
.8bf9		65 20		adc $20		                adc loopidx0
.8bfb		85 20		sta $20		                sta loopidx0
.8bfd		e8		inx		                inx                 ; dump step from TOS before MSB test
.8bfe		e8		inx		                inx                 ; since we might skip it
.8bff		b5 ff		lda $ff,x	                lda $FF,x           ; MSB of step since 1,x == -1,x+2
.8c01		d0 02		bne $8c05	                bne _chkv           ; if it's non-zero we have to check
.8c03		90 0b		bcc $8c10	                bcc _repeat         ; but if 0 and no carry, we're good
.8c05		b8		clv		_chkv:          clv
.8c06		a4 1f		ldy $1f		                ldy loopctrl        ; get LCB offset
.8c08		79 01 01	adc $0101,y	                adc loopindex+1,y   ; MSB of index
.8c0b		99 01 01	sta $0101,y	                sta loopindex+1,y   ; put MSB of index back on stack
.8c0e		70 03		bvs $8c13	                bvs _repeat+3     ; skip over JMP instruction
.8c10						_repeat:
.8c10						plus_loop_runtime_end:
.8c10						xt_lshift:
.8c10		20 69 d7	jsr $d769	                jsr underflow_2
.8c13		b5 00		lda $00,x	                lda 0,x
.8c15		29 0f		and #$0f	                and #%00001111
.8c17		f0 08		beq $8c21	                beq _done
.8c19		a8		tay		                tay
.8c1a						_loop:
.8c1a		16 02		asl $02,x	                asl 2,x
.8c1c		36 03		rol $03,x	                rol 3,x
.8c1e		88		dey		                dey
.8c1f		d0 f9		bne $8c1a	                bne _loop
.8c21						_done:
.8c21		e8		inx		                inx
.8c22		e8		inx		                inx
.8c23		60		rts		z_lshift:       rts
.8c24						xt_m_star:
.8c24		20 69 d7	jsr $d769	                jsr underflow_2
.8c27		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8c29		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8c2b		48		pha		                pha
.8c2c		20 d1 80	jsr $80d1	                jsr xt_abs
.8c2f		20 4d 93	jsr $934d	                jsr xt_swap
.8c32		20 d1 80	jsr $80d1	                jsr xt_abs
.8c35		20 9b 96	jsr $969b	                jsr xt_um_star          ; ( d )
.8c38		68		pla		                pla
.8c39		10 03		bpl $8c3e	                bpl _done
.8c3b		20 fa 9d	jsr $9dfa	                jsr xt_dnegate
.8c3e						_done:
.8c3e		60		rts		z_m_star:       rts
.8c3f						xt_marker:
.8c3f		20 bb d6	jsr $d6bb	                jsr current_to_dp
.8c42		a5 02		lda $02		                lda dp
.8c44		48		pha		                pha
.8c45		a5 03		lda $03		                lda dp+1
.8c47		48		pha		                pha
.8c48		a5 00		lda $00		                lda cp
.8c4a		48		pha		                pha
.8c4b		a5 01		lda $01		                lda cp+1
.8c4d		48		pha		                pha
.8c4e		20 00 85	jsr $8500	                jsr xt_create
.8c51		a5 00		lda $00		                lda cp          ; LSB
.8c53		38		sec		                sec
.8c54		e9 02		sbc #$02	                sbc #2
.8c56		85 00		sta $00		                sta cp
.8c58		b0 02		bcs $8c5c	                bcs +
.8c5a		c6 01		dec $01		                dec cp+1        ; we only care about the borrow
.8c5c						+
.8c5c		a0 8c		ldy #$8c	                ldy #>marker_runtime
.8c5e		a9 7a		lda #$7a	                lda #<marker_runtime
.8c60		20 9a d5	jsr $d59a	                jsr cmpl_word_ya
.8c63		7a		ply		                ply                     ; MSB
.8c64		68		pla		                pla                     ; LSB
.8c65		20 9a d5	jsr $d59a	                jsr cmpl_word_ya
.8c68		7a		ply		                ply                     ; MSB
.8c69		68		pla		                pla                     ; LSB
.8c6a		20 9a d5	jsr $d59a	                jsr cmpl_word_ya
.8c6d		a0 08		ldy #$08	                ldy #marker_start_offset
.8c6f						-
.8c6f		b1 08		lda ($08),y	                lda (up),y
.8c71		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.8c74		c8		iny		                iny
.8c75		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8c77		d0 f6		bne $8c6f	                bne -
.8c79		60		rts		z_marker:       rts
.8c7a						marker_runtime:
.8c7a		68		pla		                pla
.8c7b		85 25		sta $25		                sta tmp1        ; LSB of address
.8c7d		68		pla		                pla
.8c7e		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8c80		a0 01		ldy #$01	                ldy #1          ; start at 1 due to RTS mechanics
.8c82		b1 25		lda ($25),y	                lda (tmp1),y
.8c84		85 00		sta $00		                sta cp
.8c86		c8		iny		                iny
.8c87		b1 25		lda ($25),y	                lda (tmp1),y
.8c89		85 01		sta $01		                sta cp+1
.8c8b		c8		iny		                iny
.8c8c		b1 25		lda ($25),y	                lda (tmp1),y
.8c8e		85 02		sta $02		                sta dp
.8c90		c8		iny		                iny
.8c91		b1 25		lda ($25),y	                lda (tmp1),y
.8c93		85 03		sta $03		                sta dp+1
.8c95		38		sec		                sec
.8c96		a5 25		lda $25		                lda tmp1
.8c98		e9 03		sbc #$03	                sbc #marker_start_offset - 5
.8c9a		85 25		sta $25		                sta tmp1
.8c9c		b0 02		bcs $8ca0	                bcs +
.8c9e		c6 26		dec $26		                dec tmp1+1
.8ca0						+
.8ca0		a0 08		ldy #$08	                ldy #marker_start_offset
.8ca2						-
.8ca2		b1 25		lda ($25),y	                lda (tmp1),y
.8ca4		91 08		sta ($08),y	                sta (up),y
.8ca6		c8		iny		                iny
.8ca7		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8ca9		d0 f7		bne $8ca2	                bne -
.8cab		20 ce d6	jsr $d6ce	                jsr dp_to_current       ; Move the CURRENT DP back.
.8cae		60		rts		                rts
.8caf						xt_max:
.8caf		20 69 d7	jsr $d769	                jsr underflow_2
.8cb2		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8cb4		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8cb6		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8cb8		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8cba		50 02		bvc $8cbe	                bvc _no_overflow
.8cbc		49 80		eor #$80	                eor #$80        ; complement negative flag
.8cbe						_no_overflow:
.8cbe		30 08		bmi $8cc8	                bmi _keep_nos
.8cc0		b5 00		lda $00,x	                lda 0,x
.8cc2		95 02		sta $02,x	                sta 2,x
.8cc4		b5 01		lda $01,x	                lda 1,x
.8cc6		95 03		sta $03,x	                sta 3,x
.8cc8						_keep_nos:
.8cc8		e8		inx		                inx
.8cc9		e8		inx		                inx
.8cca		60		rts		z_max:          rts
.8ccb						xt_min:
.8ccb		20 69 d7	jsr $d769	                jsr underflow_2
.8cce		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8cd0		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8cd2		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8cd4		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8cd6		50 02		bvc $8cda	                bvc _no_overflow
.8cd8		49 80		eor #$80	                eor #$80
.8cda						_no_overflow:
.8cda		10 08		bpl $8ce4	                bpl _keep_nos
.8cdc		b5 00		lda $00,x	                lda 0,x
.8cde		95 02		sta $02,x	                sta 2,x
.8ce0		b5 01		lda $01,x	                lda 1,x
.8ce2		95 03		sta $03,x	                sta 3,x
.8ce4						_keep_nos:
.8ce4		e8		inx		                inx
.8ce5		e8		inx		                inx
.8ce6		60		rts		z_min:          rts
.8ce7						xt_minus:
.8ce7		20 69 d7	jsr $d769	                jsr underflow_2
.8cea		38		sec		                sec
.8ceb		b5 02		lda $02,x	                lda 2,x         ; LSB
.8ced		f5 00		sbc $00,x	                sbc 0,x
.8cef		95 02		sta $02,x	                sta 2,x
.8cf1		b5 03		lda $03,x	                lda 3,x         ; MSB
.8cf3		f5 01		sbc $01,x	                sbc 1,x
.8cf5		95 03		sta $03,x	                sta 3,x
.8cf7		e8		inx		                inx
.8cf8		e8		inx		                inx
.8cf9		60		rts		z_minus:        rts
.8cfa						xt_mod:
.8cfa		20 69 d7	jsr $d769	                jsr underflow_2
.8cfd		20 67 92	jsr $9267	                jsr xt_slash_mod
.8d00		e8		inx		                inx             ; DROP
.8d01		e8		inx		                inx
.8d02						z_mod:
.8d02		60		rts		                rts
.8d03						xt_move:
.8d03		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8d05		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8d07		f0 05		beq $8d0e	                beq _lsb                ; wasn't helpful, move to LSB
.8d09		b0 0e		bcs $8d19	                bcs _to_move_up         ; we want CMOVE>
.8d0b		4c dd 9e	jmp $9edd	                jmp xt_cmove            ; JSR/RTS
.8d0e						_lsb:
.8d0e		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8d10		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8d12		f0 08		beq $8d1c	                beq _equal              ; LSB is equal as well
.8d14		b0 03		bcs $8d19	                bcs _to_move_up         ; we want CMOVE>
.8d16		4c dd 9e	jmp $9edd	                jmp xt_cmove            ; JSR/RTS
.8d19						_to_move_up:
.8d19		4c 18 9f	jmp $9f18	                jmp xt_cmove_up         ; JSR/RTS
.8d1c						_equal:
.8d1c		8a		txa		                txa
.8d1d		18		clc		                clc
.8d1e		69 06		adc #$06	                adc #6
.8d20		aa		tax		                tax
.8d21		60		rts		z_move:         rts
.8d22						xt_negate:
.8d22		20 64 d7	jsr $d764	                jsr underflow_1
.8d25		a9 00		lda #$00	        	lda #0
.8d27		38		sec		                sec
.8d28		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8d2a		95 00		sta $00,x	                sta 0,x
.8d2c		a9 00		lda #$00	                lda #0
.8d2e		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8d30		95 01		sta $01,x	                sta 1,x
.8d32		60		rts		z_negate:       rts
.8d33						xt_nip:
.8d33		20 69 d7	jsr $d769	                jsr underflow_2
.8d36		b5 00		lda $00,x	                lda 0,x         ; LSB
.8d38		95 02		sta $02,x	                sta 2,x
.8d3a		b5 01		lda $01,x	                lda 1,x         ; MSB
.8d3c		95 03		sta $03,x	                sta 3,x
.8d3e		e8		inx		                inx
.8d3f		e8		inx		                inx
.8d40		60		rts		z_nip:          rts
.8d41						xt_not_equals:
.8d41		20 69 d7	jsr $d769	                jsr underflow_2
.8d44		a0 00		ldy #$00	                ldy #0                  ; default is true
.8d46		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8d48		d5 02		cmp $02,x	                cmp 2,x
.8d4a		d0 0a		bne $8d56	                bne _not_equal
.8d4c		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8d4e		d5 03		cmp $03,x	                cmp 3,x
.8d50		d0 04		bne $8d56	                bne _not_equal
.8d52		a9 ff		lda #$ff	                lda #$FF
.8d54		80 01		bra $8d57	                bra _done
.8d56						_not_equal:
.8d56		88		dey		                dey                     ; drop thru to done
.8d57						_done:
.8d57		98		tya		                tya
.8d58		e8		inx		                inx
.8d59		e8		inx		                inx
.8d5a		95 00		sta $00,x	                sta 0,x
.8d5c		95 01		sta $01,x	                sta 1,x
.8d5e		60		rts		z_not_equals:   rts
.8d5f						xt_number_sign:
.8d5f		20 69 d7	jsr $d769	                jsr underflow_2         ; double number
.8d62		20 fd 82	jsr $82fd	                jsr xt_base
.8d65		20 01 89	jsr $8901	                jsr xt_fetch            ; ( ud1 base )
.8d68		20 8b 94	jsr $948b	                jsr xt_to_r             ; >r
.8d6b		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; 0
.8d6e		20 dc 8f	jsr $8fdc	                jsr xt_r_fetch          ; r@
.8d71		20 59 96	jsr $9659	                jsr xt_um_slash_mod     ; um/mod
.8d74		20 8e 90	jsr $908e	                jsr xt_rot              ; rot
.8d77		20 8e 90	jsr $908e	                jsr xt_rot              ; rot
.8d7a		20 f1 8f	jsr $8ff1	                jsr xt_r_from           ; r>
.8d7d		20 59 96	jsr $9659	                jsr xt_um_slash_mod     ; um/mod
.8d80		20 8e 90	jsr $908e	                jsr xt_rot              ; rot
.8d83		20 8e 90	jsr $908e	                jsr xt_rot              ; ( ud rem )
.8d86		b5 00		lda $00,x	                lda 0,x
.8d88		a8		tay		                tay
.8d89		b9 b2 d2	lda $d2b2,y	                lda s_abc_upper,y
.8d8c		95 00		sta $00,x	                sta 0,x
.8d8e		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8d90		20 14 8a	jsr $8a14	                jsr xt_hold
.8d93						z_number_sign:
.8d93		60		rts		                rts
.8d94						xt_number_sign_greater:
.8d94		20 69 d7	jsr $d769	                jsr underflow_2         ; double number
.8d97		a5 2b		lda $2b		                lda tohold
.8d99		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8d9b		95 02		sta $02,x	                sta 2,x
.8d9d		a5 2c		lda $2c		                lda tohold+1
.8d9f		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8da1		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8da3		20 16 8e	jsr $8e16	                jsr xt_pad      ; ( addr addr pad )
.8da6		38		sec		                sec
.8da7		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8da9		f5 02		sbc $02,x	                sbc 2,x
.8dab		95 02		sta $02,x	                sta 2,x
.8dad		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8daf		f5 03		sbc $03,x	                sbc 3,x
.8db1		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8db3		e8		inx		                inx
.8db4		e8		inx		                inx
.8db5						z_number_sign_greater:
.8db5		60		rts		                rts
.8db6						xt_number_sign_s:
.8db6		20 69 d7	jsr $d769	                jsr underflow_2
.8db9						_loop:
.8db9		20 5f 8d	jsr $8d5f	                jsr xt_number_sign
.8dbc		b5 00		lda $00,x	                lda 0,x
.8dbe		15 01		ora $01,x	                ora 1,x
.8dc0		15 02		ora $02,x	                ora 2,x
.8dc2		15 03		ora $03,x	                ora 3,x
.8dc4		d0 f3		bne $8db9	                bne _loop
.8dc6						z_number_sign_s:
.8dc6		60		rts		                rts
.8dc7						xt_of:
.8dc7		a0 8e		ldy #$8e	                ldy #>xt_over
.8dc9		a9 08		lda #$08	                lda #<xt_over
.8dcb		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.8dce		a0 88		ldy #$88	                ldy #>xt_equal
.8dd0		a9 7d		lda #$7d	                lda #<xt_equal
.8dd2		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.8dd5		20 3b 8a	jsr $8a3b	                jsr xt_if
.8dd8		a0 87		ldy #$87	                ldy #>xt_drop
.8dda		a9 3c		lda #$3c	                lda #<xt_drop
.8ddc		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.8ddf		60		rts		z_of:           rts
.8de0						xt_one_minus:
.8de0		20 64 d7	jsr $d764	                jsr underflow_1
.8de3		b5 00		lda $00,x	                lda 0,x
.8de5		d0 02		bne $8de9	                bne +
.8de7		d6 01		dec $01,x	                dec 1,x
.8de9						+
.8de9		d6 00		dec $00,x	                dec 0,x
.8deb		60		rts		z_one_minus:    rts
.8dec						xt_char_plus:
.8dec						xt_one_plus:
.8dec		20 64 d7	jsr $d764	                jsr underflow_1
.8def		f6 00		inc $00,x	                inc 0,x
.8df1		d0 02		bne $8df5	                bne _done
.8df3		f6 01		inc $01,x	                inc 1,x
.8df5						_done:
.8df5						z_char_plus:
.8df5		60		rts		z_one_plus:     rts
.8df6						xt_or:
.8df6		20 69 d7	jsr $d769	                jsr underflow_2
.8df9		b5 00		lda $00,x	                lda 0,x
.8dfb		15 02		ora $02,x	                ora 2,x
.8dfd		95 02		sta $02,x	                sta 2,x
.8dff		b5 01		lda $01,x	                lda 1,x
.8e01		15 03		ora $03,x	                ora 3,x
.8e03		95 03		sta $03,x	                sta 3,x
.8e05		e8		inx		                inx
.8e06		e8		inx		                inx
.8e07		60		rts		z_or:           rts
.8e08						xt_over:
.8e08		20 69 d7	jsr $d769	                jsr underflow_2
.8e0b		ca		dex		                dex
.8e0c		ca		dex		                dex
.8e0d		b5 04		lda $04,x	                lda 4,x         ; LSB
.8e0f		95 00		sta $00,x	                sta 0,x
.8e11		b5 05		lda $05,x	                lda 5,x         ; MSB
.8e13		95 01		sta $01,x	                sta 1,x
.8e15		60		rts		z_over:         rts
.8e16						xt_pad:
.8e16		ca		dex		                dex
.8e17		ca		dex		                dex
.8e18		a5 00		lda $00		                lda cp
.8e1a		18		clc		                clc
.8e1b		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8e1d		95 00		sta $00,x	                sta 0,x
.8e1f		a5 01		lda $01		                lda cp+1
.8e21		69 00		adc #$00	                adc #0          ; only need carry
.8e23		95 01		sta $01,x	                sta 1,x
.8e25		60		rts		z_pad:          rts
.8e26						xt_page:
.8e26		a9 1b		lda #$1b	                lda #AscESC
.8e28		20 ac 87	jsr $87ac	                jsr emit_a
.8e2b		a9 5b		lda #$5b	                lda #'['
.8e2d		20 ac 87	jsr $87ac	                jsr emit_a
.8e30		a9 32		lda #$32	                lda #'2'
.8e32		20 ac 87	jsr $87ac	                jsr emit_a
.8e35		a9 4a		lda #$4a	                lda #'J'
.8e37		20 ac 87	jsr $87ac	                jsr emit_a
.8e3a		20 8c 9d	jsr $9d8c	                jsr xt_zero
.8e3d		20 8c 9d	jsr $9d8c	                jsr xt_zero
.8e40		20 a4 82	jsr $82a4	                jsr xt_at_xy
.8e43		60		rts		z_page:         rts
.8e44						xt_paren:
.8e44		ca		dex		                dex
.8e45		ca		dex		                dex
.8e46		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8e48		95 00		sta $00,x	                sta 0,x
.8e4a		74 01		stz $01,x	                stz 1,x
.8e4c		20 af 8e	jsr $8eaf	                jsr xt_parse
.8e4f		e8		inx		                inx
.8e50		e8		inx		                inx
.8e51		e8		inx		                inx
.8e52		e8		inx		                inx
.8e53		60		rts		z_paren:        rts
.8e54						xt_parse_name:
.8e54		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8e56		38		sec		                sec
.8e57		e5 10		sbc $10		                sbc toin
.8e59		85 25		sta $25		                sta tmp1
.8e5b		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8e5d		e5 11		sbc $11		                sbc toin+1
.8e5f		85 26		sta $26		                sta tmp1+1
.8e61		a5 25		lda $25		                lda tmp1
.8e63		05 26		ora $26		                ora tmp1+1
.8e65		f0 28		beq $8e8f	                beq _empty_line
.8e67		a5 0c		lda $0c		                lda cib
.8e69		18		clc		                clc
.8e6a		65 10		adc $10		                adc toin
.8e6c		85 27		sta $27		                sta tmp2                ; LSB of first character
.8e6e		a5 0d		lda $0d		                lda cib+1
.8e70		65 11		adc $11		                adc toin+1
.8e72		85 28		sta $28		                sta tmp2+1              ; MSB
.8e74						_skip_loop:
.8e74		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8e76		20 57 d7	jsr $d757	                jsr is_whitespace
.8e79		90 1f		bcc $8e9a	                bcc _char_found
.8e7b		e6 27		inc $27		                inc tmp2
.8e7d		d0 02		bne $8e81	                bne +
.8e7f		e6 28		inc $28		                inc tmp2+1
.8e81						+
.8e81		a5 25		lda $25		                lda tmp1
.8e83		d0 02		bne $8e87	                bne +
.8e85		c6 26		dec $26		                dec tmp1+1
.8e87		c6 25		dec $25		+               dec tmp1
.8e89		a5 25		lda $25		                lda tmp1
.8e8b		05 26		ora $26		                ora tmp1+1
.8e8d		d0 e5		bne $8e74	                bne _skip_loop          ; fall through if empty line
.8e8f						_empty_line:
.8e8f		ca		dex		                dex
.8e90		ca		dex		                dex
.8e91		ca		dex		                dex
.8e92		ca		dex		                dex
.8e93		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8e95		74 01		stz $01,x	                stz 1,x
.8e97		4c 44 8f	jmp $8f44	                jmp z_parse_name        ; skip over PARSE
.8e9a						_char_found:
.8e9a		a5 27		lda $27		                lda tmp2
.8e9c		38		sec		                sec
.8e9d		e5 0c		sbc $0c		                sbc cib
.8e9f		85 10		sta $10		                sta toin
.8ea1		a5 28		lda $28		                lda tmp2+1
.8ea3		e5 0d		sbc $0d		                sbc cib+1
.8ea5		85 11		sta $11		                sta toin+1
.8ea7		ca		dex		                dex
.8ea8		ca		dex		                dex
.8ea9		a9 20		lda #$20	                lda #AscSP
.8eab		95 00		sta $00,x	                sta 0,x
.8ead		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8eaf						xt_parse:
.8eaf		20 64 d7	jsr $d764	                jsr underflow_1
.8eb2		a5 0e		lda $0e		                lda ciblen
.8eb4		05 0f		ora $0f		                ora ciblen+1
.8eb6		f0 0c		beq $8ec4	                beq _abort_parse
.8eb8		a5 11		lda $11		                lda toin+1              ; MSB
.8eba		c5 0f		cmp $0f		                cmp ciblen+1
.8ebc		90 0e		bcc $8ecc	                bcc _go_parse           ; unsigned comparison
.8ebe		a5 10		lda $10		                lda toin                ; LSB
.8ec0		c5 0e		cmp $0e		                cmp ciblen
.8ec2		90 08		bcc $8ecc	                bcc _go_parse
.8ec4						_abort_parse:
.8ec4		ca		dex		                dex
.8ec5		ca		dex		                dex
.8ec6		74 00		stz $00,x	                stz 0,x
.8ec8		74 01		stz $01,x	                stz 1,x
.8eca		80 78		bra $8f44	                bra _done
.8ecc						_go_parse:
.8ecc		b5 00		lda $00,x	                lda 0,x
.8ece		85 23		sta $23		                sta tmptos
.8ed0		ca		dex		                dex
.8ed1		ca		dex		                dex
.8ed2		a5 0c		lda $0c		                lda cib
.8ed4		18		clc		                clc
.8ed5		65 10		adc $10		                adc toin        ; LSB
.8ed7		85 25		sta $25		                sta tmp1
.8ed9		85 27		sta $27		                sta tmp2
.8edb		95 02		sta $02,x	                sta 2,x
.8edd		a5 0d		lda $0d		                lda cib+1
.8edf		65 11		adc $11		                adc toin+1      ; MSB
.8ee1		85 26		sta $26		                sta tmp1+1
.8ee3		85 28		sta $28		                sta tmp2+1
.8ee5		95 03		sta $03,x	                sta 3,x
.8ee7		a5 0c		lda $0c		                lda cib
.8ee9		18		clc		                clc
.8eea		65 0e		adc $0e		                adc ciblen
.8eec		85 29		sta $29		                sta tmp3
.8eee		a5 0d		lda $0d		                lda cib+1
.8ef0		65 0f		adc $0f		                adc ciblen+1
.8ef2		85 2a		sta $2a		                sta tmp3+1
.8ef4		64 24		stz $24		                stz tmptos+1
.8ef6						_loop:
.8ef6		a5 27		lda $27		                lda tmp2
.8ef8		c5 29		cmp $29		                cmp tmp3
.8efa		d0 06		bne $8f02	                bne _not_empty
.8efc		a5 28		lda $28		                lda tmp2+1
.8efe		c5 2a		cmp $2a		                cmp tmp3+1
.8f00		f0 1d		beq $8f1f	                beq _eol
.8f02						_not_empty:
.8f02		b2 27		lda ($27)	                lda (tmp2)
.8f04		a4 23		ldy $23		                ldy tmptos
.8f06		c0 20		cpy #$20	                cpy #AscSP
.8f08		d0 07		bne $8f11	                bne _not_whitespace
.8f0a		20 57 d7	jsr $d757	                jsr is_whitespace
.8f0d		90 02		bcc $8f11	                bcc _not_whitespace
.8f0f		80 0c		bra $8f1d	                bra _found_delimiter
.8f11						_not_whitespace:
.8f11		c5 23		cmp $23		                cmp tmptos
.8f13		f0 08		beq $8f1d	                beq _found_delimiter
.8f15		e6 27		inc $27		                inc tmp2
.8f17		d0 dd		bne $8ef6	                bne _loop
.8f19		e6 28		inc $28		                inc tmp2+1
.8f1b		80 d9		bra $8ef6	                bra _loop
.8f1d						_found_delimiter:
.8f1d		e6 24		inc $24		                inc tmptos+1
.8f1f						_eol:
.8f1f		a5 27		lda $27		                lda tmp2
.8f21		38		sec		                sec
.8f22		e5 25		sbc $25		                sbc tmp1
.8f24		95 00		sta $00,x	                sta 0,x
.8f26		a5 28		lda $28		                lda tmp2+1
.8f28		e5 26		sbc $26		                sbc tmp1+1
.8f2a		95 01		sta $01,x	                sta 1,x
.8f2c		a5 27		lda $27		                lda tmp2
.8f2e		38		sec		                sec
.8f2f		e5 0c		sbc $0c		                sbc cib
.8f31		85 10		sta $10		                sta toin
.8f33		a5 28		lda $28		                lda tmp2+1
.8f35		e5 0d		sbc $0d		                sbc cib+1
.8f37		85 11		sta $11		                sta toin+1
.8f39		a5 10		lda $10		                lda toin
.8f3b		18		clc		                clc
.8f3c		65 24		adc $24		                adc tmptos+1
.8f3e		85 10		sta $10		                sta toin
.8f40		90 02		bcc $8f44	                bcc +
.8f42		e6 11		inc $11		                inc toin+1
.8f44						+
.8f44						_done:
.8f44						z_parse_name:
.8f44		60		rts		z_parse:        rts
.8f45						xt_pick:
.8f45		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8f47		8a		txa		                txa
.8f48		75 00		adc $00,x	                adc 0,x
.8f4a		a8		tay		                tay
.8f4b		b9 02 00	lda $0002,y	                lda 0002,y
.8f4e		95 00		sta $00,x	                sta 0,x
.8f50		b9 03 00	lda $0003,y	                lda 0003,y
.8f53		95 01		sta $01,x	                sta 1,x
.8f55		60		rts		z_pick:         rts
.8f56						xt_plus:
.8f56		20 69 d7	jsr $d769	                jsr underflow_2
.8f59		18		clc		                clc
.8f5a		b5 00		lda $00,x	                lda 0,x         ; LSB
.8f5c		75 02		adc $02,x	                adc 2,x
.8f5e		95 02		sta $02,x	                sta 2,x
.8f60		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8f62		75 03		adc $03,x	                adc 3,x
.8f64		95 03		sta $03,x	                sta 3,x
.8f66		e8		inx		                inx
.8f67		e8		inx		                inx
.8f68		60		rts		z_plus:         rts
.8f69						xt_plus_store:
.8f69		20 69 d7	jsr $d769	                jsr underflow_2
.8f6c		b5 00		lda $00,x	                lda 0,x
.8f6e		85 25		sta $25		                sta tmp1
.8f70		b5 01		lda $01,x	                lda 1,x
.8f72		85 26		sta $26		                sta tmp1+1
.8f74		a0 00		ldy #$00	                ldy #0          ; LSB
.8f76		b1 25		lda ($25),y	                lda (tmp1),y
.8f78		18		clc		                clc
.8f79		75 02		adc $02,x	                adc 2,x
.8f7b		91 25		sta ($25),y	                sta (tmp1),y
.8f7d		c8		iny		                iny             ; MSB
.8f7e		b1 25		lda ($25),y	                lda (tmp1),y
.8f80		75 03		adc $03,x	                adc 3,x
.8f82		91 25		sta ($25),y	                sta (tmp1),y
.8f84		e8		inx		                inx
.8f85		e8		inx		                inx
.8f86		e8		inx		                inx
.8f87		e8		inx		                inx
.8f88		60		rts		z_plus_store:   rts
.8f89						xt_postpone:
.8f89		20 54 8e	jsr $8e54	                jsr xt_parse_name               ; ( -- addr n )
.8f8c		b5 00		lda $00,x	                lda 0,x
.8f8e		15 01		ora $01,x	                ora 1,x
.8f90		d0 05		bne $8f97	                bne +
.8f92		a9 05		lda #$05	                lda #err_noname
.8f94		4c 7a d7	jmp $d77a	                jmp error
.8f97						+
.8f97		20 8b 9a	jsr $9a8b	                jsr xt_find_name                ; ( -- nt | 0 )
.8f9a		d0 05		bne $8fa1	                bne +
.8f9c		a9 05		lda #$05	                lda #err_noname
.8f9e		4c 7a d7	jmp $d77a	                jmp error
.8fa1						+
.8fa1		b5 00		lda $00,x	                lda 0,x
.8fa3		85 25		sta $25		                sta tmp1
.8fa5		b5 01		lda $01,x	                lda 1,x
.8fa7		85 26		sta $26		                sta tmp1+1
.8fa9		20 c9 9b	jsr $9bc9	                jsr xt_name_to_int              ; ( nt -- xt )
.8fac		e6 25		inc $25		                inc tmp1
.8fae		d0 02		bne $8fb2	                bne +
.8fb0		e6 26		inc $26		                inc tmp1+1
.8fb2						+
.8fb2		b2 25		lda ($25)	                lda (tmp1)
.8fb4		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.8fb6		f0 05		beq $8fbd	                beq _not_immediate
.8fb8		20 de 83	jsr $83de	                jsr xt_compile_comma
.8fbb		80 0a		bra $8fc7	                bra _done
.8fbd						_not_immediate:
.8fbd		20 1b 8b	jsr $8b1b	                jsr xt_literal
.8fc0		a0 83		ldy #$83	                ldy #>xt_compile_comma
.8fc2		a9 de		lda #$de	                lda #<xt_compile_comma
.8fc4		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.8fc7						_done:
.8fc7		60		rts		z_postpone:     rts
.8fc8						xt_question_dup:
.8fc8		20 64 d7	jsr $d764	                jsr underflow_1
.8fcb		b5 00		lda $00,x	                lda 0,x
.8fcd		15 01		ora $01,x	                ora 1,x
.8fcf		f0 0a		beq $8fdb	                beq _done
.8fd1		ca		dex		                dex
.8fd2		ca		dex		                dex
.8fd3		b5 02		lda $02,x	                lda 2,x
.8fd5		95 00		sta $00,x	                sta 0,x
.8fd7		b5 03		lda $03,x	                lda 3,x
.8fd9		95 01		sta $01,x	                sta 1,x
.8fdb						_done:
.8fdb		60		rts		z_question_dup: rts
.8fdc						xt_r_fetch:
.8fdc		7a		ply		                ply             ; LSB
.8fdd		84 25		sty $25		                sty tmp1
.8fdf		7a		ply		                ply             ; MSB
.8fe0		ca		dex		                dex
.8fe1		ca		dex		                dex
.8fe2		68		pla		                pla             ; LSB
.8fe3		95 00		sta $00,x	                sta 0,x
.8fe5		68		pla		                pla             ; MSB
.8fe6		95 01		sta $01,x	                sta 1,x
.8fe8		48		pha		                pha
.8fe9		b5 00		lda $00,x	                lda 0,x
.8feb		48		pha		                pha
.8fec		5a		phy		                phy             ; MSB
.8fed		a4 25		ldy $25		                ldy tmp1
.8fef		5a		phy		                phy             ; LSB
.8ff0		60		rts		z_r_fetch:      rts
.8ff1						xt_r_from:
.8ff1		68		pla		                pla             ; LSB
.8ff2		85 23		sta $23		                sta tmptos
.8ff4		7a		ply		                ply             ; MSB
.8ff5		ca		dex		                dex
.8ff6		ca		dex		                dex
.8ff7		68		pla		                pla             ; LSB
.8ff8		95 00		sta $00,x	                sta 0,x
.8ffa		68		pla		                pla             ; MSB
.8ffb		95 01		sta $01,x	                sta 1,x
.8ffd		5a		phy		                phy             ; MSB
.8ffe		a5 23		lda $23		                lda tmptos
.9000		48		pha		                pha             ; LSB
.9001		60		rts		z_r_from:       rts
.9002						xt_recurse:
.9002		a0 00		ldy #$00	                ldy #0
.9004		a9 20		lda #$20	                lda #OpJSR
.9006		91 00		sta ($00),y	                sta (cp),y
.9008		c8		iny		                iny
.9009		24 1c		bit $1c		                bit status
.900b		70 0c		bvs $9019	                bvs _nt_in_workword
.900d		a5 06		lda $06		                lda workword
.900f		91 00		sta ($00),y	                sta (cp),y
.9011		c8		iny		                iny
.9012		a5 07		lda $07		                lda workword+1
.9014		91 00		sta ($00),y	                sta (cp),y
.9016		c8		iny		                iny
.9017		80 1b		bra $9034	                bra _update_cp
.9019						_nt_in_workword:
.9019		a5 06		lda $06		                lda workword            ; LSB
.901b		18		clc		                clc
.901c		69 04		adc #$04	                adc #4
.901e		85 25		sta $25		                sta tmp1
.9020		a5 07		lda $07		                lda workword+1          ; MSB
.9022		69 00		adc #$00	                adc #0
.9024		85 26		sta $26		                sta tmp1+1
.9026		b2 25		lda ($25)	                lda (tmp1)
.9028		91 00		sta ($00),y	                sta (cp),y
.902a		5a		phy		                phy
.902b		a0 01		ldy #$01	                ldy #1
.902d		b1 25		lda ($25),y	                lda (tmp1),y
.902f		7a		ply		                ply
.9030		c8		iny		                iny
.9031		91 00		sta ($00),y	                sta (cp),y
.9033		c8		iny		                iny
.9034						_update_cp:
.9034		98		tya		                tya
.9035		18		clc		                clc
.9036		65 00		adc $00		                adc cp
.9038		85 00		sta $00		                sta cp
.903a		90 02		bcc $903e	                bcc _done
.903c		e6 01		inc $01		                inc cp+1
.903e						_done:
.903e		60		rts		z_recurse:      rts
.903f						xt_refill:
.903f		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.9041		d0 2d		bne $9070	                bne _src_not_kbd
.9043		ca		dex		                dex
.9044		ca		dex		                dex
.9045		ca		dex		                dex
.9046		ca		dex		                dex
.9047		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.9049		95 02		sta $02,x	                sta 2,x
.904b		a5 0d		lda $0d		                lda cib+1
.904d		95 03		sta $03,x	                sta 3,x
.904f		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.9051		64 0f		stz $0f		                stz ciblen+1
.9053		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9055		95 00		sta $00,x	                sta 0,x
.9057		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9059		20 e6 80	jsr $80e6	                jsr xt_accept           ; ( addr n1 -- n2)
.905c		b5 00		lda $00,x	                lda 0,x
.905e		85 0e		sta $0e		                sta ciblen
.9060		b5 01		lda $01,x	                lda 1,x
.9062		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.9064		64 10		stz $10		                stz toin
.9066		64 11		stz $11		                stz toin+1
.9068		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.906a		95 00		sta $00,x	                sta 0,x
.906c		95 01		sta $01,x	                sta 1,x
.906e		80 10		bra $9080	                bra _done
.9070						_src_not_kbd:
.9070		1a		inc a		                ina
.9071		d0 08		bne $907b	                bne _src_not_string
.9073		ca		dex		                dex
.9074		ca		dex		                dex
.9075		74 00		stz $00,x	                stz 0,x
.9077		74 01		stz $01,x	                stz 1,x
.9079		80 05		bra $9080	                bra z_refill
.907b						_src_not_string:
.907b		a9 01		lda #$01	                lda #err_badsource
.907d		4c 7a d7	jmp $d77a	                jmp error
.9080						_done:
.9080		60		rts		z_refill:       rts
.9081						xt_repeat:
.9081		20 21 82	jsr $8221	                jsr xt_again
.9084		4c 56 87	jmp $8756	                jmp xt_then
.9087						z_repeat:
.9087						xt_right_bracket:
.9087		a9 ff		lda #$ff	                lda #$FF
.9089		85 1a		sta $1a		                sta state
.908b		85 1b		sta $1b		                sta state+1
.908d						z_right_bracket:
.908d		60		rts		                rts
.908e						xt_rot:
.908e		20 6e d7	jsr $d76e	                jsr underflow_3
.9091		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9093		b5 03		lda $03,x	                lda 3,x
.9095		95 05		sta $05,x	                sta 5,x
.9097		b5 01		lda $01,x	                lda 1,x
.9099		95 03		sta $03,x	                sta 3,x
.909b		94 01		sty $01,x	                sty 1,x
.909d		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.909f		b5 02		lda $02,x	                lda 2,x
.90a1		95 04		sta $04,x	                sta 4,x
.90a3		b5 00		lda $00,x	                lda 0,x
.90a5		95 02		sta $02,x	                sta 2,x
.90a7		94 00		sty $00,x	                sty 0,x
.90a9		60		rts		z_rot:          rts
.90aa						xt_rshift:
.90aa		20 69 d7	jsr $d769	                jsr underflow_2
.90ad		b5 00		lda $00,x	                lda 0,x
.90af		29 0f		and #$0f	                and #%00001111
.90b1		f0 08		beq $90bb	                beq _done               ; if 0 shifts, quit
.90b3		a8		tay		                tay
.90b4						_loop:
.90b4		56 03		lsr $03,x	                lsr 3,x
.90b6		76 02		ror $02,x	                ror 2,x
.90b8		88		dey		                dey
.90b9		d0 f9		bne $90b4	                bne _loop
.90bb						_done:
.90bb		e8		inx		                inx
.90bc		e8		inx		                inx
.90bd		60		rts		z_rshift:       rts
.90be						xt_s_backslash_quote:
.90be		a9 ff		lda #$ff	                lda #$FF
.90c0		85 27		sta $27		                sta tmp2
.90c2		64 28		stz $28		                stz tmp2+1
.90c4		20 db 90	jsr $90db	                jsr s_quote_start
.90c7						_done:
.90c7						z_s_backslash_quote:
.90c7		60		rts		                rts
.90c8						convert_hex_value:
.90c8		c9 41		cmp #$41	        cmp #'A'
.90ca		90 07		bcc $90d3	        bcc _digit
.90cc		29 df		and #$df	        and #$DF                ; Make it uppercase.
.90ce		38		sec		        sec
.90cf		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.90d1		80 03		bra $90d6	        bra _done
.90d3						_digit:
.90d3		38		sec		        sec
.90d4		e9 30		sbc #$30	        sbc #'0'
.90d6						_done:
.90d6		60		rts		        rts
.90d7						xt_s_quote:
.90d7		64 27		stz $27		                stz tmp2
.90d9		64 28		stz $28		                stz tmp2+1
.90db						s_quote_start:
.90db		20 b3 d5	jsr $d5b3	                jsr cmpl_jump_later
.90de		20 02 8a	jsr $8a02	                jsr xt_here             ; the start of the string
.90e1						_savechars_loop:
.90e1		a5 11		lda $11		                lda toin+1              ; MSB
.90e3		c5 0f		cmp $0f		                cmp ciblen+1
.90e5		90 2a		bcc $9111	                bcc _input_fine         ; unsigned comparison
.90e7		a5 10		lda $10		                lda toin                ; LSB
.90e9		c5 0e		cmp $0e		                cmp ciblen
.90eb		90 24		bcc $9111	                bcc _input_fine
.90ed		a5 27		lda $27		                lda tmp2
.90ef		48		pha		                pha
.90f0		a5 28		lda $28		                lda tmp2+1
.90f2		48		pha		                pha
.90f3		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.90f5		48		pha		                pha
.90f6		20 3f 90	jsr $903f	                jsr xt_refill           ; ( -- f )
.90f9		68		pla		                pla
.90fa		85 29		sta $29		                sta tmp3
.90fc		68		pla		                pla
.90fd		85 28		sta $28		                sta tmp2+1
.90ff		68		pla		                pla
.9100		85 27		sta $27		                sta tmp2
.9102		b5 00		lda $00,x	                lda 0,x
.9104		15 01		ora $01,x	                ora 1,x
.9106		d0 05		bne $910d	                bne _refill_ok
.9108		a9 06		lda #$06	                lda #err_refill
.910a		4c 7a d7	jmp $d77a	                jmp error
.910d						_refill_ok:
.910d		e8		inx		                inx
.910e		e8		inx		                inx
.910f		80 d0		bra $90e1	                bra _savechars_loop
.9111						_input_fine:
.9111		a5 0c		lda $0c		                lda cib
.9113		18		clc		                clc
.9114		65 10		adc $10		                adc toin        ; LSB
.9116		85 25		sta $25		                sta tmp1
.9118		a5 0d		lda $0d		                lda cib+1
.911a		65 11		adc $11		                adc toin+1      ; MSB
.911c		85 26		sta $26		                sta tmp1+1
.911e		b2 25		lda ($25)	                lda (tmp1)
.9120		24 27		bit $27		                bit tmp2
.9122		30 03		bmi $9127	                bmi _handle_escapes    ; Only checking bit 7
.9124		4c aa 91	jmp $91aa	                jmp _regular_char
.9127						_handle_escapes:
.9127		24 28		bit $28		                bit tmp2+1
.9129		30 03		bmi $912e	                bmi _escaped
.912b		4c a0 91	jmp $91a0	                jmp _not_escaped
.912e						_escaped:
.912e		70 3c		bvs $916c	                bvs _check_esc_chars
.9130		a9 01		lda #$01	                lda #1
.9132		24 28		bit $28		                bit tmp2+1
.9134		d0 10		bne $9146	                bne _esc_x_second_digit
.9136		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.9138		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.913a		20 c8 90	jsr $90c8	                jsr convert_hex_value
.913d		0a		asl a		                asl
.913e		0a		asl a		                asl
.913f		0a		asl a		                asl
.9140		0a		asl a		                asl
.9141		85 29		sta $29		                sta tmp3    ; Save it for later.
.9143		4c b1 91	jmp $91b1	                jmp _next_character
.9146						_esc_x_second_digit:
.9146		64 28		stz $28		                stz tmp2+1
.9148		b2 25		lda ($25)	                lda (tmp1)
.914a		20 c8 90	jsr $90c8	                jsr convert_hex_value
.914d		05 29		ora $29		                ora tmp3
.914f		4c ae 91	jmp $91ae	                jmp _save_character
.9152						_esc_tr_table:
>9152		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9153		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9154		00 00				    .byte   0,0             ; c, d no escape
>9156		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9157		0c				    .byte   12              ; f -> FF (ASCII value 12)
>9158		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>915d		0a				    .byte   10              ; l -> LF (ASCII value 10)
>915e		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>915f		0a				    .byte   10              ; n behaves like l --> lf
>9160		00 00				    .byte   0,0             ; o,p
>9162		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9163		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9164		00				    .byte   0               ; s
>9165		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9166		00				    .byte   0               ; u
>9167		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9168		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>916b		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.916c						_check_esc_chars:
.916c		64 28		stz $28		                stz tmp2+1
.916e		c9 61		cmp #$61	                cmp #'a'
.9170		30 1a		bmi $918c	                bmi _check_esc_quote
.9172		c9 7b		cmp #$7b	                cmp #'z'+1
.9174		10 16		bpl $918c	                bpl _check_esc_quote
.9176		a8		tay		                tay
.9177		b9 f1 90	lda $90f1,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.917a		d0 03		bne $917f	                bne _esc_replace
.917c		98		tya		                tya                     ; revert if no translation
.917d		80 0d		bra $918c	                bra _check_esc_quote
.917f		10 2d		bpl $91ae	_esc_replace:   bpl _save_character     ; simple replacement
.9181		29 7f		and #$7f	                and #$7F                ; clear hi bit
.9183		f0 29		beq $91ae	                beq _save_character     ; NUL we can just output
.9185		20 9e d5	jsr $d59e	                jsr cmpl_byte_a              ; else output first char (CR)
.9188		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.918a		80 22		bra $91ae	                bra _save_character
.918c						_check_esc_quote:
.918c		c9 22		cmp #$22	                cmp #'"'
.918e		f0 1e		beq $91ae	                beq _save_character
.9190						_check_esc_x:
.9190		c9 78		cmp #$78	                cmp #'x'
.9192		d0 06		bne $919a	                bne _check_esc_backslash
.9194		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.9196		85 28		sta $28		                sta tmp2+1
.9198		80 17		bra $91b1	                bra _next_character
.919a						_check_esc_backslash:
.919a		c9 5c		cmp #$5c	                cmp #'\'
.919c		d0 0c		bne $91aa	                bne _regular_char
.919e		80 0e		bra $91ae	                bra _save_character
.91a0						_not_escaped:
.91a0		c9 5c		cmp #$5c	                cmp #'\'
.91a2		d0 06		bne $91aa	                bne _regular_char
.91a4		a9 ff		lda #$ff	                lda #$FF
.91a6		85 28		sta $28		                sta tmp2+1
.91a8		80 07		bra $91b1	                bra _next_character
.91aa						_regular_char:
.91aa		c9 22		cmp #$22	                cmp #'"'
.91ac		f0 0c		beq $91ba	                beq _found_string_end
.91ae						_save_character:
.91ae		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.91b1						_next_character:
.91b1		e6 10		inc $10		                inc toin
.91b3		d0 02		bne $91b7	                bne _savechars_loop_longjump
.91b5		e6 11		inc $11		                inc toin+1
.91b7						_savechars_loop_longjump:
.91b7		4c e1 90	jmp $90e1	                jmp _savechars_loop
.91ba						_found_string_end:
.91ba		e6 10		inc $10		                inc toin
.91bc		d0 02		bne $91c0	                bne +
.91be		e6 11		inc $11		                inc toin+1
.91c0						+
.91c0		20 02 8a	jsr $8a02	                jsr xt_here
.91c3		20 8e 90	jsr $908e	                jsr xt_rot
.91c6		20 37 93	jsr $9337	                jsr xt_store    ; Update the jmp target
.91c9		20 02 8a	jsr $8a02	                jsr xt_here
.91cc		20 08 8e	jsr $8e08	                jsr xt_over
.91cf		20 e7 8c	jsr $8ce7	                jsr xt_minus    ; HERE - addr gives string length
.91d2		a5 1a		lda $1a		                lda state
.91d4		05 1b		ora $1b		                ora state+1             ; paranoid
.91d6		f0 03		beq $91db	                beq _done
.91d8		20 f7 a0	jsr $a0f7	                jsr cmpl_sliteral         ; ( addr u -- )
.91db						_done:
.91db		60		rts		z_s_quote:      rts
.91dc						xt_s_to_d:
.91dc		20 64 d7	jsr $d764	                jsr underflow_1
.91df		ca		dex		                dex
.91e0		ca		dex		                dex
.91e1		74 00		stz $00,x	                stz 0,x
.91e3		74 01		stz $01,x	                stz 1,x
.91e5		b5 03		lda $03,x	                lda 3,x
.91e7		10 04		bpl $91ed	                bpl _done
.91e9		d6 00		dec $00,x	                dec 0,x
.91eb		d6 01		dec $01,x	                dec 1,x
.91ed						_done:
.91ed		60		rts		z_s_to_d:       rts
.91ee						xt_semicolon:
.91ee		24 1c		bit $1c		                bit status
.91f0		70 11		bvs $9203	                bvs _colonword
.91f2		a9 60		lda #$60	                lda #OpRTS
.91f4		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.91f7		ca		dex		                dex
.91f8		ca		dex		                dex
.91f9		a5 06		lda $06		                lda workword
.91fb		95 00		sta $00,x	                sta 0,x
.91fd		a5 07		lda $07		                lda workword+1
.91ff		95 01		sta $01,x	                sta 1,x
.9201		80 45		bra $9248	                bra _semicolon_done
.9203						_colonword:
.9203		a0 06		ldy #$06	                ldy #6
.9205		a5 00		lda $00		                lda cp
.9207		91 06		sta ($06),y	                sta (workword),y
.9209		c8		iny		                iny
.920a		a5 01		lda $01		                lda cp+1
.920c		91 06		sta ($06),y	                sta (workword),y
.920e		a9 60		lda #$60	                lda #OpRTS
.9210		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.9213		24 1c		bit $1c		                bit status
.9215		10 26		bpl $923d	                bpl _new_word   ; Bit 7 is clear = new word
.9217		ca		dex		                dex
.9218		ca		dex		                dex
.9219		ca		dex		                dex
.921a		ca		dex		                dex
.921b		b2 06		lda ($06)	                lda (workword)
.921d		95 00		sta $00,x	                sta 0,x
.921f		74 01		stz $01,x	                stz 1,x
.9221		a5 06		lda $06		                lda workword
.9223		18		clc		                clc
.9224		69 08		adc #$08	                adc #8
.9226		95 02		sta $02,x	                sta 2,x
.9228		a5 07		lda $07		                lda workword+1
.922a		69 00		adc #$00	                adc #0                  ; only want carry
.922c		95 03		sta $03,x	                sta 3,x
.922e		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9230		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf
.9233		20 d4 95	jsr $95d4	                jsr xt_type
.9236		20 c8 92	jsr $92c8	                jsr xt_space
.9239		a9 80		lda #$80	                lda #%10000000
.923b		14 1c		trb $1c		                trb status
.923d						_new_word:
.923d		a5 06		lda $06		                lda workword
.923f		85 02		sta $02		                sta dp
.9241		a5 07		lda $07		                lda workword+1
.9243		85 03		sta $03		                sta dp+1
.9245		20 ce d6	jsr $d6ce	                jsr dp_to_current       ; Save the updated DP to the
.9248						_semicolon_done:
.9248		64 1a		stz $1a		                stz state
.924a		64 1b		stz $1b		                stz state+1
.924c		60		rts		z_semicolon:    rts
.924d						xt_sign:
.924d		20 64 d7	jsr $d764	                jsr underflow_1
.9250		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9252		30 04		bmi $9258	                bmi _minus
.9254		e8		inx		                inx
.9255		e8		inx		                inx
.9256		80 09		bra $9261	                bra _done
.9258						_minus:
.9258		a9 2d		lda #$2d	                lda #'-'
.925a		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.925c		74 01		stz $01,x	                stz 1,x         ; paranoid
.925e		20 14 8a	jsr $8a14	                jsr xt_hold
.9261						_done:
.9261		60		rts		z_sign:         rts
.9262						xt_slash:
.9262		a9 00		lda #$00	                lda #0
.9264		48		pha		                pha
.9265		80 03		bra $926a	                bra slashmod_common
.9267						xt_slash_mod:
.9267		a9 ff		lda #$ff	                lda #$FF
.9269		48		pha		                pha             ; falls through to _common
.926a						slashmod_common:
.926a		20 8b 94	jsr $948b	                jsr xt_to_r             ; >R
.926d		20 dc 91	jsr $91dc	                jsr xt_s_to_d           ; S>D
.9270		20 f1 8f	jsr $8ff1	                jsr xt_r_from           ; R>
.9273		20 7f 92	jsr $927f	                jsr xt_sm_slash_rem     ; SM/REM
.9276		68		pla		                pla
.9277		d0 05		bne $927e	                bne _done
.9279		20 4d 93	jsr $934d	                jsr xt_swap
.927c		e8		inx		                inx             ; DROP
.927d		e8		inx		                inx
.927e						_done:
.927e						z_slash_mod:
.927e		60		rts		z_slash:        rts
.927f						xt_sm_slash_rem:
.927f		20 6e d7	jsr $d76e	                jsr underflow_3 ; contains double number
.9282		b5 03		lda $03,x	                lda 3,x
.9284		48		pha		                pha
.9285		b5 01		lda $01,x	                lda 1,x
.9287		55 03		eor $03,x	                eor 3,x
.9289		48		pha		                pha
.928a		20 d1 80	jsr $80d1	                jsr xt_abs
.928d		e8		inx		                inx             ; pretend we pushed n1 to R
.928e		e8		inx		                inx
.928f		20 db 9d	jsr $9ddb	                jsr xt_dabs
.9292		ca		dex		                dex
.9293		ca		dex		                dex
.9294		20 59 96	jsr $9659	                jsr xt_um_slash_mod     ; UM/MOD
.9297		68		pla		                pla
.9298		10 03		bpl $929d	                bpl +
.929a		20 22 8d	jsr $8d22	                jsr xt_negate
.929d						+
.929d		68		pla		                pla
.929e		10 07		bpl $92a7	                bpl _done
.92a0		e8		inx		                inx             ; pretend we pushed quotient to R
.92a1		e8		inx		                inx
.92a2		20 22 8d	jsr $8d22	                jsr xt_negate
.92a5		ca		dex		                dex
.92a6		ca		dex		                dex
.92a7						_done:
.92a7		60		rts		z_sm_slash_rem: rts
.92a8						xt_source:
.92a8		ca		dex		                dex
.92a9		ca		dex		                dex
.92aa		a5 0c		lda $0c		                lda cib
.92ac		95 00		sta $00,x	                sta 0,x
.92ae		a5 0d		lda $0d		                lda cib+1
.92b0		95 01		sta $01,x	                sta 1,x
.92b2		ca		dex		                dex
.92b3		ca		dex		                dex
.92b4		a5 0e		lda $0e		                lda ciblen
.92b6		95 00		sta $00,x	                sta 0,x
.92b8		a5 0f		lda $0f		                lda ciblen+1
.92ba		95 01		sta $01,x	                sta 1,x
.92bc		60		rts		z_source:       rts
.92bd						xt_source_id:
.92bd		ca		dex		                dex
.92be		ca		dex		                dex
.92bf		a5 0a		lda $0a		                lda insrc
.92c1		95 00		sta $00,x	                sta 0,x
.92c3		a5 0b		lda $0b		                lda insrc+1
.92c5		95 01		sta $01,x	                sta 1,x
.92c7		60		rts		z_source_id:    rts
.92c8						xt_space:
.92c8		a9 20		lda #$20	                lda #AscSP
.92ca		20 ac 87	jsr $87ac	                jsr emit_a
.92cd		60		rts		z_space:        rts
.92ce						xt_spaces:
.92ce		20 64 d7	jsr $d764	                jsr underflow_1
.92d1		20 8c 9d	jsr $9d8c	                jsr xt_zero
.92d4		20 af 8c	jsr $8caf	                jsr xt_max
.92d7		b5 00		lda $00,x	                lda 0,x
.92d9		15 01		ora $01,x	                ora 1,x
.92db		f0 2a		beq $9307	                beq _done
.92dd		b4 01		ldy $01,x	                ldy 1,x
.92df		d0 0c		bne $92ed	                bne _lots_of_spaces
.92e1		b4 00		ldy $00,x	                ldy 0,x
.92e3						_quick_loop:
.92e3		a9 20		lda #$20	                lda #AscSP
.92e5		20 ac 87	jsr $87ac	                jsr emit_a
.92e8		88		dey		                dey
.92e9		f0 1c		beq $9307	                beq _done
.92eb		80 f6		bra $92e3	                bra _quick_loop
.92ed						_lots_of_spaces:
.92ed		b4 00		ldy $00,x	                ldy 0,x
.92ef						_first_slow_loop:
.92ef		f0 08		beq $92f9	                beq _slow_outer_loop
.92f1		a9 20		lda #$20	                lda #AscSP
.92f3		20 ac 87	jsr $87ac	                jsr emit_a
.92f6		88		dey		                dey
.92f7		80 f6		bra $92ef	                bra _first_slow_loop
.92f9						_slow_outer_loop:
.92f9		a0 00		ldy #$00	                ldy #00
.92fb						_slow_inner_loop:
.92fb		a9 20		lda #$20	                lda #AscSP
.92fd		20 ac 87	jsr $87ac	                jsr emit_a
.9300		88		dey		                dey
.9301		d0 f8		bne $92fb	                bne _slow_inner_loop
.9303		d6 01		dec $01,x	                dec 1,x
.9305		d0 f2		bne $92f9	                bne _slow_outer_loop
.9307						_done:
.9307		e8		inx		                inx             ; drop
.9308		e8		inx		                inx
.9309		60		rts		z_spaces:       rts
.930a						xt_star:
.930a		20 69 d7	jsr $d769	                jsr underflow_2
.930d		20 9b 96	jsr $969b	                jsr xt_um_star
.9310		e8		inx		                inx
.9311		e8		inx		                inx
.9312		60		rts		z_star:         rts
.9313						xt_star_slash:
.9313		20 1c 93	jsr $931c	                jsr xt_star_slash_mod
.9316		20 4d 93	jsr $934d	                jsr xt_swap
.9319		e8		inx		                inx
.931a		e8		inx		                inx
.931b						z_star_slash:
.931b		60		rts		                rts
.931c						xt_star_slash_mod:
.931c		20 6e d7	jsr $d76e	                jsr underflow_3
.931f		20 8b 94	jsr $948b	                jsr xt_to_r
.9322		20 24 8c	jsr $8c24	                jsr xt_m_star
.9325		20 f1 8f	jsr $8ff1	                jsr xt_r_from
.9328		20 7f 92	jsr $927f	                jsr xt_sm_slash_rem
.932b						z_star_slash_mod:
.932b		60		rts		                rts
.932c						xt_state:
.932c		ca		dex		                dex
.932d		ca		dex		                dex
.932e		a9 1a		lda #$1a	                lda #<state
.9330		95 00		sta $00,x	                sta 0,x
.9332		a9 00		lda #$00	                lda #>state
.9334		95 01		sta $01,x	                sta 1,x
.9336		60		rts		z_state:        rts
.9337						xt_store:
.9337		20 69 d7	jsr $d769	                jsr underflow_2
.933a		b5 02		lda $02,x	                lda 2,x         ; LSB
.933c		81 00		sta ($00,x)	                sta (0,x)
.933e		f6 00		inc $00,x	                inc 0,x
.9340		d0 02		bne $9344	                bne +
.9342		f6 01		inc $01,x	                inc 1,x
.9344						+
.9344		b5 03		lda $03,x	                lda 3,x         ; MSB
.9346		81 00		sta ($00,x)	                sta (0,x)
.9348		e8		inx		                inx             ; 2DROP
.9349		e8		inx		                inx
.934a		e8		inx		                inx
.934b		e8		inx		                inx
.934c		60		rts		z_store:        rts
.934d						xt_swap:
.934d		20 69 d7	jsr $d769	                jsr underflow_2
.9350		b5 00		lda $00,x	                lda 0,x         ; LSB
.9352		b4 02		ldy $02,x	                ldy 2,x
.9354		95 02		sta $02,x	                sta 2,x
.9356		94 00		sty $00,x	                sty 0,x
.9358		b5 01		lda $01,x	                lda 1,x         ; MSB
.935a		b4 03		ldy $03,x	                ldy 3,x
.935c		95 03		sta $03,x	                sta 3,x
.935e		94 01		sty $01,x	                sty 1,x
.9360		60		rts		z_swap:         rts
.9361						xt_tick:
.9361		20 54 8e	jsr $8e54	                jsr xt_parse_name       ; ( -- addr u )
.9364		b5 00		lda $00,x	                lda 0,x
.9366		15 01		ora $01,x	                ora 1,x
.9368		d0 05		bne $936f	                bne +
.936a		a9 05		lda #$05	                lda #err_noname
.936c		4c 7a d7	jmp $d77a	                jmp error
.936f						+
.936f		20 8b 9a	jsr $9a8b	                jsr xt_find_name        ; ( addr u -- nt )
.9372		b5 00		lda $00,x	                lda 0,x
.9374		15 01		ora $01,x	                ora 1,x
.9376		d0 05		bne $937d	                bne +
.9378		a9 08		lda #$08	                lda #err_syntax
.937a		4c 7a d7	jmp $d77a	                jmp error
.937d						+
.937d		20 c9 9b	jsr $9bc9	                jsr xt_name_to_int      ; ( nt -- xt )
.9380		60		rts		z_tick:         rts
.9381						xt_to:
.9381		20 61 93	jsr $9361	                jsr xt_tick             ; ( [n] xt )
.9384		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9386		18		clc		                clc
.9387		69 03		adc #$03	                adc #3
.9389		85 25		sta $25		                sta tmp1
.938b		b5 01		lda $01,x	                lda 1,x                 ; MSB
.938d		69 00		adc #$00	                adc #0                  ; we just want the carry
.938f		85 26		sta $26		                sta tmp1+1
.9391		a5 1a		lda $1a		                lda state
.9393		05 1b		ora $1b		                ora state+1
.9395		f0 14		beq $93ab	                beq _interpret
.9397		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.9399		95 00		sta $00,x	                sta 0,x
.939b		a5 26		lda $26		                lda tmp1+1
.939d		95 01		sta $01,x	                sta 1,x
.939f		20 1b 8b	jsr $8b1b	                jsr xt_literal      ; generate the runtime for LITERAL tmp1
.93a2		a0 93		ldy #$93	                ldy #>xt_store      ; write the runtime for !
.93a4		a9 37		lda #$37	                lda #<xt_store
.93a6		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.93a9		80 11		bra $93bc	                bra _done
.93ab						_interpret:
.93ab		20 69 d7	jsr $d769	                jsr underflow_2
.93ae		e8		inx		                inx
.93af		e8		inx		                inx                     ; leaving just ( n )
.93b0		b5 00		lda $00,x	                lda 0,x
.93b2		92 25		sta ($25)	                sta (tmp1)              ; LSB
.93b4		a0 01		ldy #$01	                ldy #1
.93b6		b5 01		lda $01,x	                lda 1,x                 ; MSB
.93b8		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.93ba		e8		inx		                inx                     ; DROP
.93bb		e8		inx		                inx
.93bc						_done:
.93bc		60		rts		z_to:           rts
.93bd						xt_to_body:
.93bd		20 64 d7	jsr $d764	                jsr underflow_1
.93c0		20 42 87	jsr $8742	                jsr xt_dup              ; ( xt xt )
.93c3		20 43 9b	jsr $9b43	                jsr xt_int_to_name      ; ( xt nt )
.93c6		f6 00		inc $00,x	                inc 0,x
.93c8		d0 02		bne $93cc	                bne +
.93ca		f6 01		inc $01,x	                inc 1,x
.93cc						+
.93cc		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.93ce		29 20		and #$20	                and #HC
.93d0		f0 0b		beq $93dd	                beq _no_cfa
.93d2		18		clc		                clc
.93d3		b5 02		lda $02,x	                lda 2,x         ; LSB
.93d5		69 03		adc #$03	                adc #3
.93d7		95 02		sta $02,x	                sta 2,x
.93d9		90 02		bcc $93dd	                bcc _no_cfa
.93db		f6 03		inc $03,x	                inc 3,x         ; MSB
.93dd						_no_cfa:
.93dd		e8		inx		                inx             ; get rid of the nt
.93de		e8		inx		                inx
.93df						_done:
.93df		60		rts		z_to_body:      rts
.93e0						xt_to_in:
.93e0		ca		dex		                dex
.93e1		ca		dex		                dex
.93e2		a9 10		lda #$10	                lda #<toin
.93e4		95 00		sta $00,x	                sta 0,x
.93e6		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.93e8		95 01		sta $01,x	                sta 1,x
.93ea		60		rts		z_to_in:        rts
.93eb						xt_to_number:
.93eb		20 73 d7	jsr $d773	                jsr underflow_4
.93ee		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.93f0		85 2d		sta $2d		                sta scratch
.93f2		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.93f4		85 2e		sta $2e		                sta scratch+1
.93f6		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.93f8		85 2f		sta $2f		                sta scratch+2
.93fa		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.93fc		85 30		sta $30		                sta scratch+3
.93fe		ca		dex		                dex
.93ff		ca		dex		                dex
.9400						_loop:
.9400		a1 04		lda ($04,x)	                lda (4,x)
.9402		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.9404		74 01		stz $01,x	                stz 1,x                 ; paranoid
.9406		20 2f 9a	jsr $9a2f	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.9409		b5 00		lda $00,x	                lda 0,x
.940b		d0 04		bne $9411	                bne _digit_ok
.940d		e8		inx		                inx
.940e		e8		inx		                inx
.940f		80 67		bra $9478	                bra _done       ; ( ud-lo ud-hi addr u char )
.9411						_digit_ok:
.9411		b5 02		lda $02,x	                lda 2,x
.9413		85 31		sta $31		                sta scratch+4
.9415		b5 03		lda $03,x	                lda 3,x
.9417		85 32		sta $32		                sta scratch+5
.9419		a5 2f		lda $2f		                lda scratch+2
.941b		95 02		sta $02,x	                sta 2,x         ; NOS
.941d		a5 30		lda $30		                lda scratch+3
.941f		95 03		sta $03,x	                sta 3,x
.9421		a5 18		lda $18		                lda base
.9423		95 00		sta $00,x	                sta 0,x         ; TOS
.9425		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.9427		20 9b 96	jsr $969b	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.942a		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.942c		85 33		sta $33		                sta scratch+6
.942e		b5 03		lda $03,x	                lda 3,x
.9430		85 34		sta $34		                sta scratch+7
.9432		a5 2d		lda $2d		                lda scratch
.9434		95 02		sta $02,x	                sta 2,x
.9436		a5 2e		lda $2e		                lda scratch+1
.9438		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.943a		a5 18		lda $18		                lda base
.943c		95 00		sta $00,x	                sta 0,x
.943e		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.9440		20 9b 96	jsr $969b	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9443		b5 00		lda $00,x	                lda 0,x
.9445		85 2f		sta $2f		                sta scratch+2
.9447		b5 01		lda $01,x	                lda 1,x
.9449		85 30		sta $30		                sta scratch+3
.944b		b5 02		lda $02,x	                lda 2,x
.944d		85 2d		sta $2d		                sta scratch
.944f		b5 03		lda $03,x	                lda 3,x
.9451		85 2e		sta $2e		                sta scratch+1
.9453		18		clc		                clc
.9454		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.9456		65 31		adc $31		                adc scratch+4   ; n LSB
.9458		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.945a		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.945c		65 32		adc $32		                adc scratch+5   ; n MSB
.945e		85 2e		sta $2e		                sta scratch+1
.9460		a5 2f		lda $2f		                lda scratch+2   ; LSB
.9462		65 33		adc $33		                adc scratch+6
.9464		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.9466		a5 30		lda $30		                lda scratch+3   ; MSB
.9468		65 34		adc $34		                adc scratch+7
.946a		85 30		sta $30		                sta scratch+3
.946c		e8		inx		                inx
.946d		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.946e		f6 04		inc $04,x	                inc 4,x
.9470		d0 02		bne $9474	                bne +
.9472		f6 05		inc $05,x	                inc 5,x
.9474						+
.9474		d6 02		dec $02,x	                dec 2,x
.9476		d0 88		bne $9400	                bne _loop
.9478						_done:
.9478		e8		inx		                inx
.9479		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.947a		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.947c		95 06		sta $06,x	                sta 6,x
.947e		a5 2e		lda $2e		                lda scratch+1
.9480		95 07		sta $07,x	                sta 7,x
.9482		a5 2f		lda $2f		                lda scratch+2
.9484		95 04		sta $04,x	                sta 4,x
.9486		a5 30		lda $30		                lda scratch+3
.9488		95 05		sta $05,x	                sta 5,x
.948a		60		rts		z_to_number:    rts
.948b						xt_to_r:
.948b		68		pla		                pla             ; LSB
.948c		85 23		sta $23		                sta tmptos
.948e		7a		ply		                ply             ; MSB
.948f		20 64 d7	jsr $d764	                jsr underflow_1
.9492		b5 01		lda $01,x	                lda 1,x         ; MSB
.9494		48		pha		                pha
.9495		b5 00		lda $00,x	                lda 0,x         ; LSB
.9497		48		pha		                pha
.9498		e8		inx		                inx
.9499		e8		inx		                inx
.949a		5a		phy		                phy             ; MSB
.949b		a5 23		lda $23		                lda tmptos
.949d		48		pha		                pha             ; LSB
.949e		60		rts		z_to_r:         rts
.949f						xt_true:
.949f		ca		dex		                dex
.94a0		ca		dex		                dex
.94a1		a9 ff		lda #$ff	                lda #$FF
.94a3		95 00		sta $00,x	                sta 0,x
.94a5		95 01		sta $01,x	                sta 1,x
.94a7		60		rts		z_true:         rts
.94a8						xt_tuck:
.94a8		20 69 d7	jsr $d769	                jsr underflow_2
.94ab		ca		dex		                dex
.94ac		ca		dex		                dex
.94ad		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.94af		b5 02		lda $02,x	                lda 2,x
.94b1		95 04		sta $04,x	                sta 4,x
.94b3		94 02		sty $02,x	                sty 2,x
.94b5		95 00		sta $00,x	                sta 0,x
.94b7		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.94b9		b5 03		lda $03,x	                lda 3,x
.94bb		95 05		sta $05,x	                sta 5,x
.94bd		94 03		sty $03,x	                sty 3,x         ; bba
.94bf		95 01		sta $01,x	                sta 1,x         ; baa
.94c1		60		rts		z_tuck:         rts
.94c2						xt_two_drop:
.94c2		20 69 d7	jsr $d769	                jsr underflow_2
.94c5		e8		inx		                inx
.94c6		e8		inx		                inx
.94c7		e8		inx		                inx
.94c8		e8		inx		                inx
.94c9		60		rts		z_two_drop:     rts
.94ca						xt_two_dup:
.94ca		20 69 d7	jsr $d769	                jsr underflow_2
.94cd		ca		dex		                dex
.94ce		ca		dex		                dex
.94cf		ca		dex		                dex
.94d0		ca		dex		                dex
.94d1		b5 04		lda $04,x	                lda 4,x         ; TOS
.94d3		95 00		sta $00,x	                sta 0,x
.94d5		b5 05		lda $05,x	                lda 5,x
.94d7		95 01		sta $01,x	                sta 1,x
.94d9		b5 06		lda $06,x	                lda 6,x         ; NOS
.94db		95 02		sta $02,x	                sta 2,x
.94dd		b5 07		lda $07,x	                lda 7,x
.94df		95 03		sta $03,x	                sta 3,x
.94e1		60		rts		z_two_dup:      rts
.94e2						xt_two_fetch:
.94e2		20 64 d7	jsr $d764	                jsr underflow_1
.94e5		b5 00		lda $00,x	                lda 0,x
.94e7		85 25		sta $25		                sta tmp1
.94e9		b4 01		ldy $01,x	                ldy 1,x
.94eb		84 26		sty $26		                sty tmp1+1
.94ed		ca		dex		                dex             ; reuse one stack element
.94ee		ca		dex		                dex
.94ef		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.94f1		95 00		sta $00,x	                sta 0,x
.94f3		a0 01		ldy #$01	                ldy #1          ; copy next
.94f5		b1 25		lda ($25),y	                lda (tmp1),y
.94f7		95 01		sta $01,x	                sta 1,x
.94f9		c8		iny		                iny             ; copy next
.94fa		b1 25		lda ($25),y	                lda (tmp1),y
.94fc		95 02		sta $02,x	                sta 2,x
.94fe		c8		iny		                iny             ; copy next
.94ff		b1 25		lda ($25),y	                lda (tmp1),y
.9501		95 03		sta $03,x	                sta 3,x
.9503		60		rts		z_two_fetch:    rts
.9504						xt_two_over:
.9504		20 73 d7	jsr $d773	                jsr underflow_4
.9507		ca		dex		                dex
.9508		ca		dex		                dex
.9509		ca		dex		                dex
.950a		ca		dex		                dex
.950b		b5 08		lda $08,x	                lda 8,x
.950d		95 00		sta $00,x	                sta 0,x
.950f		b5 09		lda $09,x	                lda 9,x
.9511		95 01		sta $01,x	                sta 1,x
.9513		b5 0a		lda $0a,x	                lda 10,x
.9515		95 02		sta $02,x	                sta 2,x
.9517		b5 0b		lda $0b,x	                lda 11,x
.9519		95 03		sta $03,x	                sta 3,x
.951b		60		rts		z_two_over:     rts
.951c						xt_two_r_fetch:
.951c		ca		dex		                dex
.951d		ca		dex		                dex
.951e		ca		dex		                dex
.951f		ca		dex		                dex
.9520		8a		txa		                txa
.9521		ba		tsx		                tsx
.9522		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.9523		7a		ply		                ply
.9524		aa		tax		                tax
.9525		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.9528		95 00		sta $00,x	                sta 0,x
.952a		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.952d		95 01		sta $01,x	                sta 1,x
.952f		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.9532		95 02		sta $02,x	                sta 2,x
.9534		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.9537		95 03		sta $03,x	                sta 3,x
.9539		60		rts		z_two_r_fetch:  rts
.953a						xt_two_r_from:
.953a		68		pla		                pla                     ; LSB
.953b		85 25		sta $25		                sta tmp1
.953d		68		pla		                pla                     ; MSB
.953e		85 26		sta $26		                sta tmp1+1
.9540		ca		dex		                dex
.9541		ca		dex		                dex
.9542		ca		dex		                dex
.9543		ca		dex		                dex
.9544		68		pla		                pla                     ; LSB
.9545		95 00		sta $00,x	                sta 0,x
.9547		68		pla		                pla                     ; MSB
.9548		95 01		sta $01,x	                sta 1,x
.954a		68		pla		                pla                     ; LSB
.954b		95 02		sta $02,x	                sta 2,x
.954d		68		pla		                pla                     ; MSB
.954e		95 03		sta $03,x	                sta 3,x
.9550		a5 26		lda $26		                lda tmp1+1              ; MSB
.9552		48		pha		                pha
.9553		a5 25		lda $25		                lda tmp1                ; LSB
.9555		48		pha		                pha
.9556		60		rts		z_two_r_from:   rts
.9557						xt_two_slash:
.9557		20 64 d7	jsr $d764	                jsr underflow_1
.955a		b5 01		lda $01,x	                lda 1,x
.955c		0a		asl a		                asl                     ; save the sign
.955d		76 01		ror $01,x	                ror 1,x
.955f		76 00		ror $00,x	                ror 0,x
.9561		60		rts		z_two_slash:    rts
.9562						xt_two_star:
.9562						xt_cells:
.9562		20 64 d7	jsr $d764	                jsr underflow_1
.9565		16 00		asl $00,x	                asl 0,x
.9567		36 01		rol $01,x	                rol 1,x
.9569						z_cells:
.9569		60		rts		z_two_star:     rts
.956a						xt_two_store:
.956a		20 6e d7	jsr $d76e	                jsr underflow_3
.956d		b5 00		lda $00,x	                lda 0,x
.956f		85 25		sta $25		                sta tmp1
.9571		b4 01		ldy $01,x	                ldy 1,x
.9573		84 26		sty $26		                sty tmp1+1
.9575		e8		inx		                inx
.9576		e8		inx		                inx
.9577		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.9579		92 25		sta ($25)	                sta (tmp1)
.957b		b5 01		lda $01,x	                lda 1,x         ; copy next
.957d		a0 01		ldy #$01	                ldy #1
.957f		91 25		sta ($25),y	                sta (tmp1),y
.9581		b5 02		lda $02,x	                lda 2,x         ; copy next
.9583		c8		iny		                iny
.9584		91 25		sta ($25),y	                sta (tmp1),y
.9586		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.9588		c8		iny		                iny
.9589		91 25		sta ($25),y	                sta (tmp1),y
.958b		e8		inx		                inx             ; 2DROP
.958c		e8		inx		                inx
.958d		e8		inx		                inx
.958e		e8		inx		                inx
.958f		60		rts		z_two_store:    rts
.9590						xt_two_swap:
.9590		20 73 d7	jsr $d773	                jsr underflow_4
.9593		b5 00		lda $00,x	                lda 0,x
.9595		b4 04		ldy $04,x	                ldy 4,x
.9597		95 04		sta $04,x	                sta 4,x
.9599		94 00		sty $00,x	                sty 0,x
.959b		b5 01		lda $01,x	                lda 1,x
.959d		b4 05		ldy $05,x	                ldy 5,x
.959f		95 05		sta $05,x	                sta 5,x
.95a1		94 01		sty $01,x	                sty 1,x
.95a3		b5 02		lda $02,x	                lda 2,x
.95a5		b4 06		ldy $06,x	                ldy 6,x
.95a7		95 06		sta $06,x	                sta 6,x
.95a9		94 02		sty $02,x	                sty 2,x
.95ab		b5 03		lda $03,x	                lda 3,x
.95ad		b4 07		ldy $07,x	                ldy 7,x
.95af		95 07		sta $07,x	                sta 7,x
.95b1		94 03		sty $03,x	                sty 3,x
.95b3		60		rts		z_two_swap:     rts
.95b4						xt_two_to_r:
.95b4		68		pla		                pla             ; LSB
.95b5		85 25		sta $25		                sta tmp1
.95b7		68		pla		                pla             ; MSB
.95b8		85 26		sta $26		                sta tmp1+1
.95ba		20 69 d7	jsr $d769	                jsr underflow_2
.95bd		b5 03		lda $03,x	                lda 3,x         ; MSB
.95bf		48		pha		                pha
.95c0		b5 02		lda $02,x	                lda 2,x         ; LSB
.95c2		48		pha		                pha
.95c3		b5 01		lda $01,x	                lda 1,x         ; MSB
.95c5		48		pha		                pha
.95c6		b5 00		lda $00,x	                lda 0,x         ; LSB
.95c8		48		pha		                pha
.95c9		e8		inx		                inx
.95ca		e8		inx		                inx
.95cb		e8		inx		                inx
.95cc		e8		inx		                inx
.95cd		a5 26		lda $26		                lda tmp1+1      ; MSB
.95cf		48		pha		                pha
.95d0		a5 25		lda $25		                lda tmp1        ; LSB
.95d2		48		pha		                pha
.95d3		60		rts		z_two_to_r:     rts
.95d4						xt_type:
.95d4		20 69 d7	jsr $d769	                jsr underflow_2
.95d7		b5 02		lda $02,x	                lda 2,x
.95d9		85 25		sta $25		                sta tmp1
.95db		b5 03		lda $03,x	                lda 3,x
.95dd		85 26		sta $26		                sta tmp1+1
.95df						_loop:
.95df		b5 00		lda $00,x	                lda 0,x
.95e1		15 01		ora $01,x	                ora 1,x
.95e3		f0 15		beq $95fa	                beq _done
.95e5		b2 25		lda ($25)	                lda (tmp1)
.95e7		20 ac 87	jsr $87ac	                jsr emit_a      ; avoids stack foolery
.95ea		e6 25		inc $25		                inc tmp1
.95ec		d0 02		bne $95f0	                bne +
.95ee		e6 26		inc $26		                inc tmp1+1
.95f0						+
.95f0		b5 00		lda $00,x	                lda 0,x
.95f2		d0 02		bne $95f6	                bne +
.95f4		d6 01		dec $01,x	                dec 1,x
.95f6						+
.95f6		d6 00		dec $00,x	                dec 0,x
.95f8		80 e5		bra $95df	                bra _loop
.95fa						_done:
.95fa		e8		inx		                inx
.95fb		e8		inx		                inx
.95fc		e8		inx		                inx
.95fd		e8		inx		                inx
.95fe		60		rts		z_type:         rts
.95ff						xt_u_dot:
.95ff		20 64 d7	jsr $d764	                jsr underflow_1
.9602		20 d1 d7	jsr $d7d1	                jsr print_u
.9605		a9 20		lda #$20	                lda #AscSP
.9607		20 ac 87	jsr $87ac	                jsr emit_a
.960a		60		rts		z_u_dot:        rts
.960b						xt_u_dot_r:
.960b		20 69 d7	jsr $d769	                jsr underflow_2
.960e		20 8b 94	jsr $948b	                jsr xt_to_r
.9611		20 8c 9d	jsr $9d8c	                jsr xt_zero
.9614		20 f8 8a	jsr $8af8	                jsr xt_less_number_sign
.9617		20 b6 8d	jsr $8db6	                jsr xt_number_sign_s
.961a		20 94 8d	jsr $8d94	                jsr xt_number_sign_greater
.961d		20 f1 8f	jsr $8ff1	                jsr xt_r_from
.9620		20 08 8e	jsr $8e08	                jsr xt_over
.9623		20 e7 8c	jsr $8ce7	                jsr xt_minus
.9626		20 ce 92	jsr $92ce	                jsr xt_spaces
.9629		20 d4 95	jsr $95d4	                jsr xt_type
.962c		60		rts		z_u_dot_r:      rts
.962d						xt_u_greater_than:
.962d		20 69 d7	jsr $d769	                jsr underflow_2
.9630		b5 00		lda $00,x	                lda 0,x
.9632		d5 02		cmp $02,x	                cmp 2,x
.9634		b5 01		lda $01,x	                lda 1,x
.9636		f5 03		sbc $03,x	                sbc 3,x
.9638		e8		inx		                inx
.9639		e8		inx		                inx
.963a		a9 00		lda #$00	                lda #0
.963c		69 ff		adc #$ff	                adc #$FF
.963e		95 00		sta $00,x	                sta 0,x         ; store flag
.9640		95 01		sta $01,x	                sta 1,x
.9642		60		rts		z_u_greater_than:    rts
.9643						xt_u_less_than:
.9643		20 69 d7	jsr $d769	                jsr underflow_2
.9646		b5 02		lda $02,x	                lda 2,x
.9648		d5 00		cmp $00,x	                cmp 0,x
.964a		b5 03		lda $03,x	                lda 3,x
.964c		f5 01		sbc $01,x	                sbc 1,x
.964e		e8		inx		                inx
.964f		e8		inx		                inx
.9650		a9 00		lda #$00	                lda #0
.9652		69 ff		adc #$ff	                adc #$FF
.9654		95 00		sta $00,x	                sta 0,x         ; store flag
.9656		95 01		sta $01,x	                sta 1,x
.9658		60		rts		z_u_less_than:    rts
.9659						xt_um_slash_mod:
.9659		20 6e d7	jsr $d76e	                jsr underflow_3
.965c		b5 00		lda $00,x	                lda 0,x
.965e		15 01		ora $01,x	                ora 1,x
.9660		d0 05		bne $9667	                bne _not_zero
.9662		a9 04		lda #$04	                lda #err_divzero
.9664		4c 7a d7	jmp $d77a	                jmp error
.9667						_not_zero:
.9667		a9 11		lda #$11	                lda #17
.9669		85 23		sta $23		                sta tmptos
.966b						_loop:
.966b		36 04		rol $04,x	                rol 4,x
.966d		36 05		rol $05,x	                rol 5,x
.966f		c6 23		dec $23		                dec tmptos
.9671		f0 22		beq $9695	                beq _done
.9673		36 02		rol $02,x	                rol 2,x
.9675		36 03		rol $03,x	                rol 3,x
.9677		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.9679		26 25		rol $25		                rol tmp1
.967b		38		sec		                sec
.967c		b5 02		lda $02,x	                lda 2,x
.967e		f5 00		sbc $00,x	                sbc 0,x
.9680		85 26		sta $26		                sta tmp1+1
.9682		b5 03		lda $03,x	                lda 3,x
.9684		f5 01		sbc $01,x	                sbc 1,x
.9686		a8		tay		                tay
.9687		a5 25		lda $25		                lda tmp1
.9689		e9 00		sbc #$00	                sbc #0
.968b		90 de		bcc $966b	                bcc _loop
.968d		a5 26		lda $26		                lda tmp1+1
.968f		95 02		sta $02,x	                sta 2,x
.9691		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.9693		80 d6		bra $966b	                bra _loop
.9695						_done:
.9695		e8		inx		                inx
.9696		e8		inx		                inx
.9697		20 4d 93	jsr $934d	                jsr xt_swap
.969a		60		rts		z_um_slash_mod: rts
.969b						xt_um_star:
.969b		20 69 d7	jsr $d769	                jsr underflow_2
.969e		18		clc		                clc
.969f		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.96a1		e9 00		sbc #$00	                sbc #0
.96a3		85 27		sta $27		                sta tmp2
.96a5		b5 01		lda $01,x	                lda 1,x
.96a7		e9 00		sbc #$00	                sbc #0
.96a9		90 31		bcc $96dc	                bcc _zero       ; is TOS zero?
.96ab		85 28		sta $28		                sta tmp2+1
.96ad		a9 00		lda #$00	                lda #0
.96af		85 25		sta $25		                sta tmp1
.96b1		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.96b3		ca		dex		                dex
.96b4		ca		dex		                dex
.96b5						_outer_loop:
.96b5		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.96b7		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.96b9						_inner_loop:
.96b9		90 0c		bcc $96c7	                bcc _no_add
.96bb		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.96bd		a5 25		lda $25		                lda tmp1
.96bf		65 27		adc $27		                adc tmp2
.96c1		85 25		sta $25		                sta tmp1
.96c3		a5 26		lda $26		                lda tmp1+1
.96c5		65 28		adc $28		                adc tmp2+1
.96c7						_no_add:
.96c7		6a		ror a		                ror
.96c8		66 25		ror $25		                ror tmp1
.96ca		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.96cc		88		dey		                dey
.96cd		d0 ea		bne $96b9	                bne _inner_loop ; go back for one more shift?
.96cf		e8		inx		                inx
.96d0		e4 29		cpx $29		                cpx tmp3
.96d2		d0 e1		bne $96b5	                bne _outer_loop ; go back for eight more shifts?
.96d4		95 01		sta $01,x	                sta 1,x
.96d6		a5 25		lda $25		                lda tmp1
.96d8		95 00		sta $00,x	                sta 0,x
.96da		80 04		bra $96e0	                bra _done
.96dc						_zero:
.96dc		74 02		stz $02,x	                stz 2,x
.96de		74 03		stz $03,x	                stz 3,x
.96e0						_done:
.96e0		60		rts		z_um_star:      rts
.96e1						xt_unloop:
.96e1		a4 1f		ldy $1f		                ldy loopctrl
.96e3		88		dey		                dey
.96e4		88		dey		                dey
.96e5		88		dey		                dey
.96e6		88		dey		                dey
.96e7		84 1f		sty $1f		                sty loopctrl
.96e9		30 05		bmi $96f0	                bmi z_unloop            ; no active loops?
.96eb		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.96ee		85 20		sta $20		                sta loopidx0
.96f0		60		rts		z_unloop:       rts
.96f1						xt_until:
.96f1		a0 00		ldy #$00	                ldy #0
.96f3						-
.96f3		b9 4c 8a	lda $8a4c,y	                lda zero_test_runtime,y
.96f6		c9 60		cmp #$60	                cmp #OpRTS
.96f8		f0 03		beq $96fd	                beq +
.96fa		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.96fd						+
.96fd		c8		iny		                iny
.96fe		c0 0a		cpy #$0a	                cpy #(zero_test_footer_end - zero_test_runtime)
.9700		d0 f1		bne $96f3	                bne -
.9702		20 cf 83	jsr $83cf	                jsr xt_comma
.9705		60		rts		z_until:        rts
.9706						xt_unused:
.9706		ca		dex		                dex
.9707		ca		dex		                dex
.9708		a9 00		lda #$00	                lda #<cp_end
.970a		38		sec		                sec
.970b		e5 00		sbc $00		                sbc cp
.970d		95 00		sta $00,x	                sta 0,x
.970f		a9 7c		lda #$7c	                lda #>cp_end
.9711		e5 01		sbc $01		                sbc cp+1
.9713		95 01		sta $01,x	                sta 1,x
.9715		60		rts		z_unused:       rts
.9716						xt_variable:
.9716		20 00 85	jsr $8500	                jsr xt_create
.9719		a9 00		lda #$00	                lda #0
.971b		92 00		sta ($00)	                sta (cp)
.971d		e6 00		inc $00		                inc cp
.971f		d0 02		bne $9723	                bne +
.9721		e6 01		inc $01		                inc cp+1
.9723						+
.9723		92 00		sta ($00)	                sta (cp)
.9725		e6 00		inc $00		                inc cp
.9727		d0 02		bne $972b	                bne +
.9729		e6 01		inc $01		                inc cp+1
.972b						+
.972b		20 c8 84	jsr $84c8	                jsr adjust_z
.972e		60		rts		z_variable:     rts
.972f						xt_while:
.972f		a0 8a		ldy #$8a	                ldy #>zero_branch_runtime
.9731		a9 56		lda #$56	                lda #<zero_branch_runtime
.9733		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.9736		20 02 8a	jsr $8a02	                jsr xt_here
.9739		a9 ff		lda #$ff	                lda #$FF
.973b		a8		tay		                tay
.973c		20 9a d5	jsr $d59a	                jsr cmpl_word_ya
.973f		20 4d 93	jsr $934d	                jsr xt_swap
.9742		60		rts		z_while:        rts
.9743						xt_within:
.9743		20 6e d7	jsr $d76e	                jsr underflow_3
.9746		20 08 8e	jsr $8e08	                jsr xt_over
.9749		20 e7 8c	jsr $8ce7	                jsr xt_minus
.974c		20 8b 94	jsr $948b	                jsr xt_to_r
.974f		20 e7 8c	jsr $8ce7	                jsr xt_minus
.9752		20 f1 8f	jsr $8ff1	                jsr xt_r_from
.9755		20 43 96	jsr $9643	                jsr xt_u_less_than
.9758		60		rts		z_within:       rts
.9759						xt_word:
.9759		20 64 d7	jsr $d764	                jsr underflow_1
.975c		a4 10		ldy $10		                ldy toin                ; >IN
.975e						_loop:
.975e		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.9760		f0 09		beq $976b	                beq _found_char
.9762		b1 0c		lda ($0c),y	                lda (cib),y
.9764		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.9766		d0 03		bne $976b	                bne _found_char
.9768		c8		iny		                iny
.9769		80 f3		bra $975e	                bra _loop
.976b						_found_char:
.976b		84 10		sty $10		                sty toin
.976d		20 af 8e	jsr $8eaf	                jsr xt_parse            ; Returns ( addr u )
.9770		b5 00		lda $00,x	                lda 0,x
.9772		92 00		sta ($00)	                sta (cp)                ; Save length of string
.9774		48		pha		                pha                     ; Keep copy of length for later
.9775		20 42 87	jsr $8742	                jsr xt_dup              ; ( addr u u )
.9778		a5 00		lda $00		                lda cp
.977a		18		clc		                clc
.977b		69 01		adc #$01	                adc #1
.977d		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.977f		a5 01		lda $01		                lda cp+1
.9781		69 00		adc #$00	                adc #0
.9783		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.9785		20 03 8d	jsr $8d03	                jsr xt_move
.9788		ca		dex		                dex
.9789		ca		dex		                dex
.978a		a5 00		lda $00		                lda cp
.978c		95 00		sta $00,x	                sta 0,x
.978e		a5 01		lda $01		                lda cp+1
.9790		95 01		sta $01,x	                sta 1,x
.9792		68		pla		                pla                     ; length of string
.9793		18		clc		                clc
.9794		65 00		adc $00		                adc cp
.9796		85 00		sta $00		                sta cp
.9798		90 02		bcc $979c	                bcc z_word
.979a		e6 01		inc $01		                inc cp+1
.979c		60		rts		z_word:         rts
.979d						xt_xor:
.979d		20 69 d7	jsr $d769	                jsr underflow_2
.97a0		b5 00		lda $00,x	                lda 0,x
.97a2		55 02		eor $02,x	                eor 2,x
.97a4		95 02		sta $02,x	                sta 2,x
.97a6		b5 01		lda $01,x	                lda 1,x
.97a8		55 03		eor $03,x	                eor 3,x
.97aa		95 03		sta $03,x	                sta 3,x
.97ac		e8		inx		                inx
.97ad		e8		inx		                inx
.97ae		60		rts		z_xor:          rts
.97af						xt_zero_equal:
.97af		20 64 d7	jsr $d764	                jsr underflow_1
.97b2		b5 00		lda $00,x	                lda 0,x
.97b4		15 01		ora $01,x	                ora 1,x
.97b6		f0 02		beq $97ba	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.97b8		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.97ba						_zero:
.97ba		49 ff		eor #$ff	                eor #$FF        ; now just invert
.97bc						_store:
.97bc		95 00		sta $00,x	                sta 0,x
.97be		95 01		sta $01,x	                sta 1,x
.97c0		60		rts		z_zero_equal:   rts
.97c1						xt_zero_greater:
.97c1		20 64 d7	jsr $d764	                jsr underflow_1
.97c4		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.97c6		b5 01		lda $01,x	                lda 1,x         ; MSB
.97c8		30 05		bmi $97cf	                bmi _done       ; TOS is negative, keep FLASE
.97ca		15 00		ora $00,x	                ora 0,x
.97cc		f0 01		beq $97cf	                beq _done       ; TOS is zero, keep FALSE
.97ce		88		dey		                dey             ; TOS is postive, make true
.97cf						_done:
.97cf		98		tya		                tya
.97d0		95 00		sta $00,x	                sta 0,x
.97d2		95 01		sta $01,x	                sta 1,x
.97d4		60		rts		z_zero_greater: rts
.97d5						xt_zero_less:
.97d5		20 64 d7	jsr $d764	                jsr underflow_1
.97d8		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.97da		b5 01		lda $01,x	                lda 1,x         ; MSB
.97dc		10 01		bpl $97df	                bpl _done       ; TOS is positive, so keep FALSE
.97de		88		dey		                dey             ; TOS is negative, make TRUE
.97df						_done:
.97df		98		tya		                tya
.97e0		95 00		sta $00,x	                sta 0,x
.97e2		95 01		sta $01,x	                sta 1,x
.97e4		60		rts		z_zero_less:    rts
.97e5						xt_zero_unequal:
.97e5		20 64 d7	jsr $d764	                jsr underflow_1
.97e8		b5 00		lda $00,x	                lda 0,x
.97ea		15 01		ora $01,x	                ora 1,x
.97ec		f0 02		beq $97f0	                beq _zero
.97ee		a9 ff		lda #$ff	                lda #$FF
.97f0						_zero:
.97f0		95 00		sta $00,x	                sta 0,x
.97f2		95 01		sta $01,x	                sta 1,x
.97f4		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.97f5						xt_bye:
.97f5		4c 31 f0	jmp $f031	                jmp kernel_bye
.97f8						z_bye:
.97f8						xt_dot_s:
.97f8		20 12 86	jsr $8612	                jsr xt_depth    ; ( -- u )
.97fb		a9 3c		lda #$3c	                lda #'<'
.97fd		20 ac 87	jsr $87ac	                jsr emit_a
.9800		b5 00		lda $00,x	                lda 0,x
.9802		48		pha		                pha
.9803		ca		dex		                dex             ; DUP
.9804		ca		dex		                dex
.9805		95 00		sta $00,x	                sta 0,x
.9807		74 01		stz $01,x	                stz 1,x
.9809		20 d1 d7	jsr $d7d1	                jsr print_u
.980c		a9 3e		lda #$3e	                lda #'>'
.980e		20 ac 87	jsr $87ac	                jsr emit_a
.9811		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.9813		20 ac 87	jsr $87ac	                jsr emit_a
.9816		e8		inx		                inx
.9817		e8		inx		                inx
.9818		e0 78		cpx #$78	                cpx #dsp0
.981a		f0 1e		beq $983a	                beq _done
.981c						_have_stack:
.981c		7a		ply		                ply
.981d		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.981f		85 29		sta $29		                sta tmp3
.9821		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.9823						_loop:
.9823		ca		dex		                dex
.9824		ca		dex		                dex
.9825		b2 29		lda ($29)	                lda (tmp3)
.9827		95 01		sta $01,x	                sta 1,x
.9829		c6 29		dec $29		                dec tmp3
.982b		b2 29		lda ($29)	                lda (tmp3)
.982d		95 00		sta $00,x	                sta 0,x
.982f		c6 29		dec $29		                dec tmp3
.9831		5a		phy		                phy
.9832		20 d2 86	jsr $86d2	                jsr xt_dot
.9835		7a		ply		                ply
.9836		88		dey		                dey
.9837		d0 ea		bne $9823	                bne _loop
.9839		48		pha		                pha             ; dummy to balance stack
.983a						_done:
.983a		68		pla		                pla
.983b		60		rts		z_dot_s:        rts
.983c						xt_dump:
.983c		20 69 d7	jsr $d769	                jsr underflow_2
.983f						_row:
.983f		a0 10		ldy #$10	                ldy #16
.9841		64 27		stz $27		                stz tmp2
.9843		20 fa 84	jsr $84fa	                jsr xt_cr
.9846		b5 03		lda $03,x	                lda 3,x
.9848		20 2f d6	jsr $d62f	                jsr byte_to_ascii
.984b		b5 02		lda $02,x	                lda 2,x
.984d		20 2f d6	jsr $d62f	                jsr byte_to_ascii
.9850		20 c8 92	jsr $92c8	                jsr xt_space
.9853		20 c8 92	jsr $92c8	                jsr xt_space
.9856						_loop:
.9856		b5 00		lda $00,x	                lda 0,x
.9858		15 01		ora $01,x	                ora 1,x
.985a		f0 39		beq $9895	                beq _all_printed
.985c		a1 02		lda ($02,x)	                lda (2,x)
.985e		48		pha		                pha                     ; byte_to_ascii destroys A
.985f		20 2f d6	jsr $d62f	                jsr byte_to_ascii
.9862		20 c8 92	jsr $92c8	                jsr xt_space
.9865		68		pla		                pla
.9866		20 4a d7	jsr $d74a	                jsr is_printable
.9869		b0 02		bcs $986d	                bcs _printable
.986b		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.986d						_printable:
.986d		5a		phy		                phy                     ; save counter
.986e		a4 27		ldy $27		                ldy tmp2
.9870		91 00		sta ($00),y	                sta (cp),y
.9872		e6 27		inc $27		                inc tmp2
.9874		7a		ply		                ply
.9875		c0 09		cpy #$09	                cpy #9
.9877		d0 03		bne $987c	                bne _next_char
.9879		20 c8 92	jsr $92c8	                jsr xt_space
.987c						_next_char:
.987c		f6 02		inc $02,x	                inc 2,x
.987e		d0 02		bne $9882	                bne _counter
.9880		f6 03		inc $03,x	                inc 3,x
.9882						_counter:
.9882		b5 00		lda $00,x	                lda 0,x
.9884		d0 02		bne $9888	                bne +
.9886		d6 01		dec $01,x	                dec 1,x
.9888						+
.9888		d6 00		dec $00,x	                dec 0,x
.988a		88		dey		                dey
.988b		d0 c9		bne $9856	                bne _loop               ; next byte
.988d		20 c8 92	jsr $92c8	                jsr xt_space
.9890		20 a3 98	jsr $98a3	                jsr dump_print_ascii
.9893		80 aa		bra $983f	                bra _row                ; new row
.9895						_all_printed:
.9895		a5 27		lda $27		                lda tmp2
.9897		f0 06		beq $989f	                beq _done
.9899		20 c8 92	jsr $92c8	                jsr xt_space
.989c		20 a3 98	jsr $98a3	                jsr dump_print_ascii
.989f						_done:
.989f		20 c2 94	jsr $94c2	                jsr xt_two_drop         ; one byte less than 4x INX
.98a2		60		rts		z_dump:         rts
.98a3						dump_print_ascii:
.98a3		a0 00		ldy #$00	                ldy #0
.98a5						_ascii_loop:
.98a5		b1 00		lda ($00),y	                lda (cp),y
.98a7		20 ac 87	jsr $87ac	                jsr emit_a
.98aa		c8		iny		                iny
.98ab		c0 08		cpy #$08	                cpy #8
.98ad		d0 03		bne $98b2	                bne +
.98af		20 c8 92	jsr $92c8	                jsr xt_space
.98b2						+
.98b2		c6 27		dec $27		                dec tmp2
.98b4		d0 ef		bne $98a5	                bne _ascii_loop
.98b6		60		rts		                rts
.98b7						xt_question:
.98b7		20 01 89	jsr $8901	                jsr xt_fetch
.98ba		20 d2 86	jsr $86d2	                jsr xt_dot
.98bd		60		rts		z_question:     rts
.98be						xt_see:
.98be		20 54 8e	jsr $8e54	                jsr xt_parse_name       ; ( addr u )
.98c1		20 8b 9a	jsr $9a8b	                jsr xt_find_name        ; ( nt | 0 )
.98c4		b5 00		lda $00,x	                lda 0,x
.98c6		15 01		ora $01,x	                ora 1,x
.98c8		d0 05		bne $98cf	                bne +
.98ca		a9 05		lda #$05	                lda #err_noname
.98cc		4c 7a d7	jmp $d77a	                jmp error
.98cf						+
.98cf		20 fa 84	jsr $84fa	                jsr xt_cr
.98d2		a5 18		lda $18		                lda base
.98d4		48		pha		                pha
.98d5		20 0d 8a	jsr $8a0d	                jsr xt_hex
.98d8		a9 09		lda #$09	                lda #str_see_nt
.98da		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf
.98dd		20 42 87	jsr $8742	                jsr xt_dup              ; ( nt nt )
.98e0		20 ff 95	jsr $95ff	                jsr xt_u_dot
.98e3		20 c8 92	jsr $92c8	                jsr xt_space            ; ( nt )
.98e6		20 42 87	jsr $8742	                jsr xt_dup              ; ( nt nt )
.98e9		20 c9 9b	jsr $9bc9	                jsr xt_name_to_int      ; ( nt xt )
.98ec		a9 0a		lda #$0a	                lda #str_see_xt
.98ee		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf
.98f1		20 42 87	jsr $8742	                jsr xt_dup              ; ( nt xt xt )
.98f4		20 ff 95	jsr $95ff	                jsr xt_u_dot
.98f7		20 fa 84	jsr $84fa	                jsr xt_cr               ; ( nt xt )
.98fa		a9 08		lda #$08	                lda #str_see_flags
.98fc		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf
.98ff		20 08 8e	jsr $8e08	                jsr xt_over             ; ( nt xt nt )
.9902		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9905		20 01 89	jsr $8901	                jsr xt_fetch            ; ( nt xt flags )
.9908		b5 00		lda $00,x	                lda 0,x
.990a		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.990c						_flag_loop:
.990c		48		pha		                pha
.990d		29 01		and #$01	                and #%00000001
.990f		18		clc		                clc
.9910		69 30		adc #$30	                adc #'0'
.9912		20 ac 87	jsr $87ac	                jsr emit_a
.9915		20 c8 92	jsr $92c8	                jsr xt_space
.9918		68		pla		                pla
.9919		6a		ror a		                ror                     ; Next flag
.991a		88		dey		                dey
.991b		d0 ef		bne $990c	                bne _flag_loop
.991d		20 fa 84	jsr $84fa	                jsr xt_cr
.9920		e8		inx		                inx
.9921		e8		inx		                inx                     ; ( nt xt )
.9922		a9 0b		lda #$0b	                lda #str_see_size
.9924		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf
.9927		20 4d 93	jsr $934d	                jsr xt_swap             ; ( xt nt )
.992a		20 6b 9d	jsr $9d6b	                jsr xt_wordsize         ; ( xt u )
.992d		20 42 87	jsr $8742	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9930		20 ca 85	jsr $85ca	                jsr xt_decimal
.9933		20 ff 95	jsr $95ff	                jsr xt_u_dot            ; ( xt u )
.9936		20 0d 8a	jsr $8a0d	                jsr xt_hex
.9939		20 fa 84	jsr $84fa	                jsr xt_cr
.993c		20 ca 94	jsr $94ca	                jsr xt_two_dup          ; ( xt u xt u )
.993f		20 3c 98	jsr $983c	                jsr xt_dump
.9942		20 fa 84	jsr $84fa	                jsr xt_cr
.9945		20 39 a1	jsr $a139	                jsr xt_disasm
.9948		68		pla		                pla
.9949		85 18		sta $18		                sta base
.994b		60		rts		z_see:          rts
.994c						xt_words:
.994c		20 fa 84	jsr $84fa	                jsr xt_cr
.994f		a9 00		lda #$00	                lda #0
.9951		48		pha		                pha
.9952		ca		dex		                dex                     ; Make room on the stack for
.9953		ca		dex		                dex                     ; a dictionary pointer.
.9954		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.9956						_wordlist_loop:
.9956		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.9958		a5 29		lda $29		                lda tmp3
.995a		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.995c		d0 02		bne $9960	                bne _have_wordlist
.995e		80 45		bra $99a5	                bra _words_done
.9960						_have_wordlist:
.9960		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.9961		69 23		adc #$23	                adc #search_order_offset
.9963		a8		tay		                tay
.9964		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.9966		0a		asl a		                asl                     ; Turn offset into cells offset.
.9967		18		clc		                clc
.9968		69 0a		adc #$0a	                adc #wordlists_offset
.996a		a8		tay		                tay
.996b		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.996d		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.996f		c8		iny		                iny
.9970		b1 08		lda ($08),y	                lda (up),y
.9972		95 01		sta $01,x	                sta 1,x
.9974						_loop:
.9974		20 42 87	jsr $8742	                jsr xt_dup              ; ( nt nt )
.9977		20 e6 9b	jsr $9be6	                jsr xt_name_to_string   ; ( nt addr u )
.997a		68		pla		                pla
.997b		18		clc		                clc
.997c		75 00		adc $00,x	                adc 0,x
.997e		1a		inc a		                ina                     ; don't forget the space between words
.997f		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.9981		90 06		bcc $9989	                bcc +
.9983		20 fa 84	jsr $84fa	                jsr xt_cr
.9986		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.9988		1a		inc a		                ina                     ; with length of this word.
.9989						+
.9989		48		pha		                pha
.998a		20 d4 95	jsr $95d4	                jsr xt_type             ; ( nt )
.998d		a9 20		lda #$20	                lda #AscSP
.998f		20 ac 87	jsr $87ac	                jsr emit_a
.9992		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+
.9995		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+
.9998		20 01 89	jsr $8901	                jsr xt_fetch            ; @ ( nt+1 )
.999b		b5 00		lda $00,x	                lda 0,x
.999d		15 01		ora $01,x	                ora 1,x
.999f		d0 d3		bne $9974	                bne _loop
.99a1		e6 29		inc $29		                inc tmp3
.99a3		80 b1		bra $9956	                bra _wordlist_loop
.99a5						_words_done:
.99a5		68		pla		                pla                     ; dump counter
.99a6		e8		inx		                inx
.99a7		e8		inx		                inx
.99a8		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.99a9						xt_allow_native:
.99a9		20 bb d6	jsr $d6bb	                jsr current_to_dp
.99ac		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.99ae		b1 02		lda ($02),y	                lda (dp),y
.99b0		29 f5		and #$f5	                and #$FF-NN-AN  ; AN and NN flag is clear.
.99b2		91 02		sta ($02),y	                sta (dp),y
.99b4						z_allow_native:
.99b4		60		rts		                rts
.99b5						xt_always_native:
.99b5		20 bb d6	jsr $d6bb	                jsr current_to_dp
.99b8		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.99ba		b1 02		lda ($02),y	                lda (dp),y
.99bc		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.99be		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.99c0		91 02		sta ($02),y	                sta (dp),y
.99c2						z_always_native:
.99c2		60		rts		                rts
.99c3						xt_bell:
.99c3		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.99c5		20 ac 87	jsr $87ac	                jsr emit_a
.99c8		60		rts		z_bell:         rts
.99c9						xt_bounds:
.99c9		20 69 d7	jsr $d769	                jsr underflow_2
.99cc		18		clc		                clc
.99cd		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.99cf		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.99d1		75 02		adc $02,x	                adc 2,x
.99d3		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.99d5		94 00		sty $00,x	                sty 0,x
.99d7		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.99d9		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.99db		75 03		adc $03,x	                adc 3,x
.99dd		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.99df		94 01		sty $01,x	                sty 1,x
.99e1		60		rts		z_bounds:       rts
.99e2						xt_cleave:
.99e2		20 69 d7	jsr $d769	                jsr underflow_2
.99e5		20 b8 9f	jsr $9fb8	                jsr xt_minus_leading    ; -LEADING ( addr u )
.99e8		20 2d 9b	jsr $9b2d	                jsr xt_input_to_r       ; save old imput state
.99eb		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.99ed		85 0e		sta $0e		                sta ciblen
.99ef		b5 01		lda $01,x	                lda 1,x
.99f1		85 0f		sta $0f		                sta ciblen+1
.99f3		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.99f5		85 0c		sta $0c		                sta cib
.99f7		b5 03		lda $03,x	                lda 3,x
.99f9		85 0d		sta $0d		                sta cib+1
.99fb		64 10		stz $10		                stz toin        ; >IN pointer is zero
.99fd		64 11		stz $11		                stz toin+1
.99ff		20 54 8e	jsr $8e54	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.9a02		b5 00		lda $00,x	                lda 0,x
.9a04		15 01		ora $01,x	                ora 1,x
.9a06		f0 23		beq $9a2b	                beq _done
.9a08		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9a0a		38		sec		                sec
.9a0b		f5 00		sbc $00,x	                sbc 0,x
.9a0d		95 04		sta $04,x	                sta 4,x
.9a0f		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9a11		f5 01		sbc $01,x	                sbc 1,x
.9a13		95 05		sta $05,x	                sta 5,x
.9a15		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9a17		18		clc		                clc
.9a18		75 00		adc $00,x	                adc 0,x
.9a1a		95 06		sta $06,x	                sta 6,x
.9a1c		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9a1e		75 01		adc $01,x	                adc 1,x
.9a20		95 07		sta $07,x	                sta 7,x
.9a22		20 90 95	jsr $9590	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.9a25		20 b8 9f	jsr $9fb8	                jsr xt_minus_leading
.9a28		20 90 95	jsr $9590	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.9a2b						_done:
.9a2b		20 3a 9d	jsr $9d3a	                jsr xt_r_to_input
.9a2e		60		rts		z_cleave:       rts
.9a2f						xt_digit_question:
.9a2f		20 64 d7	jsr $d764	                jsr underflow_1
.9a32		ca		dex		                dex
.9a33		ca		dex		                dex
.9a34		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9a36		74 01		stz $01,x	                stz 1,x
.9a38		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9a3a		b5 02		lda $02,x	                lda 2,x
.9a3c		c9 30		cmp #$30	                cmp #'0'
.9a3e		90 23		bcc $9a63	                bcc _done               ; failure flag already set
.9a40		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9a42		90 12		bcc $9a56	                bcc _checkbase
.9a44		c9 41		cmp #$41	                cmp #'A'
.9a46		90 1b		bcc $9a63	                bcc _done               ; failure flag is already set
.9a48		c9 61		cmp #$61	                cmp #'a'
.9a4a		90 07		bcc $9a53	                bcc _case_done          ; not lower case, too low
.9a4c		c9 7b		cmp #$7b	                cmp #'z'+1
.9a4e		b0 03		bcs $9a53	                bcs _case_done          ; not lower case, too high
.9a50		18		clc		                clc                     ; just right
.9a51		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9a53						_case_done:
.9a53		38		sec		                sec
.9a54		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9a56						_checkbase:
.9a56		38		sec		                sec
.9a57		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9a59		c5 18		cmp $18		                cmp base
.9a5b		b0 06		bcs $9a63	                bcs _done               ; already have false flag
.9a5d		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9a5f		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9a61		d6 01		dec $01,x	                dec 1,x
.9a63						_done:
.9a63						z_digit_question:
.9a63		60		rts		                rts
.9a64						xt_execute_parsing:
.9a64		20 6e d7	jsr $d76e	                jsr underflow_3
.9a67		20 2d 9b	jsr $9b2d	                jsr xt_input_to_r       ; save normal input for later
.9a6a		20 10 9c	jsr $9c10	                jsr xt_not_rote         ; -ROT ( xt addr u )
.9a6d		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9a6f		85 0e		sta $0e		                sta ciblen
.9a71		b5 01		lda $01,x	                lda 1,x
.9a73		85 0f		sta $0f		                sta ciblen+1
.9a75		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9a77		85 0c		sta $0c		                sta cib
.9a79		b5 03		lda $03,x	                lda 3,x
.9a7b		85 0d		sta $0d		                sta cib+1
.9a7d		64 10		stz $10		                stz toin                ; Set >IN to zero
.9a7f		64 11		stz $11		                stz toin+1
.9a81		20 c2 94	jsr $94c2	                jsr xt_two_drop         ; 2DROP ( xt )
.9a84		20 ec 88	jsr $88ec	                jsr xt_execute
.9a87		20 3a 9d	jsr $9d3a	                jsr xt_r_to_input
.9a8a						z_execute_parsing:
.9a8a		60		rts		                rts
.9a8b						xt_find_name:
.9a8b		20 69 d7	jsr $d769	                jsr underflow_2
.9a8e		b5 00		lda $00,x	                lda 0,x
.9a90		15 01		ora $01,x	                ora 1,x
.9a92		d0 03		bne $9a97	                bne _nonempty
.9a94		4c c8 9a	jmp $9ac8	                jmp _fail_done
.9a97						_nonempty:
.9a97		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9a99						_wordlist_loop:
.9a99		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9a9b		a5 29		lda $29		                lda tmp3
.9a9d		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9a9f		f0 27		beq $9ac8	                beq _fail_done
.9aa1		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9aa2		69 23		adc #$23	                adc #search_order_offset
.9aa4		a8		tay		                tay
.9aa5		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9aa7		0a		asl a		                asl                     ; Turn offset into cells offset.
.9aa8		18		clc		                clc
.9aa9		69 0a		adc #$0a	                adc #wordlists_offset
.9aab		a8		tay		                tay
.9aac		b1 08		lda ($08),y	                lda (up),y
.9aae		85 25		sta $25		                sta tmp1
.9ab0		c8		iny		                iny
.9ab1		b1 08		lda ($08),y	                lda (up),y
.9ab3		85 26		sta $26		                sta tmp1+1
.9ab5		20 46 d6	jsr $d646	                jsr find_header_name
.9ab8		d0 04		bne $9abe	                bne _success
.9aba		e6 29		inc $29		                inc tmp3
.9abc		80 db		bra $9a99	                bra _wordlist_loop
.9abe						_success:
.9abe		a5 25		lda $25		                lda tmp1
.9ac0		95 02		sta $02,x	                sta 2,x
.9ac2		a5 26		lda $26		                lda tmp1+1
.9ac4		95 03		sta $03,x	                sta 3,x
.9ac6		80 04		bra $9acc	                bra _done
.9ac8						_fail_done:
.9ac8		74 02		stz $02,x	                stz 2,x         ; failure flag
.9aca		74 03		stz $03,x	                stz 3,x
.9acc						_done:
.9acc		e8		inx		                inx
.9acd		e8		inx		                inx
.9ace		60		rts		z_find_name:    rts
.9acf						xt_hexstore:
.9acf		20 6e d7	jsr $d76e	                jsr underflow_3
.9ad2		20 42 87	jsr $8742	                jsr xt_dup              ; Save copy of original address
.9ad5		20 b4 95	jsr $95b4	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9ad8						_loop:
.9ad8		b5 00		lda $00,x	                lda 0,x
.9ada		15 01		ora $01,x	                ora 1,x
.9adc		f0 36		beq $9b14	                beq _done
.9ade		20 e2 99	jsr $99e2	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9ae1		20 b4 95	jsr $95b4	                jsr xt_two_to_r
.9ae4		20 8c 9d	jsr $9d8c	                jsr xt_zero
.9ae7		20 8c 9d	jsr $9d8c	                jsr xt_zero
.9aea		20 3a 95	jsr $953a	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9aed		20 eb 93	jsr $93eb	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9af0		b5 00		lda $00,x	                lda 0,x
.9af2		15 01		ora $01,x	                ora 1,x
.9af4		d0 17		bne $9b0d	                bne _have_chars_left
.9af6		20 c2 94	jsr $94c2	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9af9		20 d5 9d	jsr $9dd5	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9afc		20 dc 8f	jsr $8fdc	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9aff		20 39 83	jsr $8339	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b02		20 f1 8f	jsr $8ff1	                jsr xt_r_from           ; R>
.9b05		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+
.9b08		20 8b 94	jsr $948b	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9b0b		80 cb		bra $9ad8	                bra _loop
.9b0d						_have_chars_left:
.9b0d		8a		txa		                txa
.9b0e		18		clc		                clc
.9b0f		69 08		adc #$08	                adc #8
.9b11		aa		tax		                tax
.9b12		80 c4		bra $9ad8	                bra _loop
.9b14						_done:
.9b14		e8		inx		                inx
.9b15		e8		inx		                inx
.9b16		e8		inx		                inx
.9b17		e8		inx		                inx                     ; 2DROP
.9b18		20 3a 95	jsr $953a	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9b1b		20 4d 93	jsr $934d	                jsr xt_swap
.9b1e		20 e7 8c	jsr $8ce7	                jsr xt_minus            ; ( n )
.9b21		60		rts		z_hexstore:     rts
.9b22						xt_input:
.9b22		ca		dex		                dex
.9b23		ca		dex		                dex
.9b24		a9 14		lda #$14	                lda #<input
.9b26		95 00		sta $00,x	                sta 0,x
.9b28		a9 00		lda #$00	                lda #>input
.9b2a		95 01		sta $01,x	                sta 1,x
.9b2c		60		rts		z_input:        rts
.9b2d						xt_input_to_r:
.9b2d		68		pla		                pla
.9b2e		85 25		sta $25		                sta tmp1
.9b30		68		pla		                pla
.9b31		85 26		sta $26		                sta tmp1+1
.9b33		a0 07		ldy #$07	                ldy #7
.9b35						_loop:
.9b35		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9b38		48		pha		                pha
.9b39		88		dey		                dey
.9b3a		10 f9		bpl $9b35	                bpl _loop
.9b3c		a5 26		lda $26		                lda tmp1+1
.9b3e		48		pha		                pha
.9b3f		a5 25		lda $25		                lda tmp1
.9b41		48		pha		                pha
.9b42		60		rts		z_input_to_r: 	rts
.9b43						xt_int_to_name:
.9b43		20 64 d7	jsr $d764	                jsr underflow_1
.9b46		ca		dex		                dex
.9b47		ca		dex		                dex
.9b48		74 00		stz $00,x	                stz 0,x
.9b4a		74 01		stz $01,x	                stz 1,x
.9b4c						_wordlist_loop:
.9b4c		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9b4e		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b4f		18		clc		                clc
.9b50		69 0a		adc #$0a	                adc #wordlists_offset
.9b52		a8		tay		                tay
.9b53		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9b55		85 27		sta $27		                sta tmp2                ; into tmp2
.9b57		c8		iny		                iny
.9b58		b1 08		lda ($08),y	                lda (up),y
.9b5a		85 28		sta $28		                sta tmp2+1
.9b5c		a5 27		lda $27		                lda tmp2
.9b5e		05 28		ora $28		                ora tmp2+1
.9b60		f0 36		beq $9b98	                beq _next_wordlist
.9b62		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9b64		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9b66		b5 03		lda $03,x	                lda 3,x
.9b68		85 2a		sta $2a		                sta tmp3+1
.9b6a						_loop:
.9b6a		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9b6c		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9b6e		c5 29		cmp $29		                cmp tmp3
.9b70		d0 07		bne $9b79	                bne _no_match
.9b72		c8		iny		                iny
.9b73		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9b75		c5 2a		cmp $2a		                cmp tmp3+1
.9b77		f0 30		beq $9ba9	                beq _match
.9b79						_no_match:
.9b79		18		clc		                clc
.9b7a		a5 27		lda $27		                lda tmp2
.9b7c		69 02		adc #$02	                adc #2
.9b7e		85 27		sta $27		                sta tmp2
.9b80		90 02		bcc $9b84	                bcc +
.9b82		e6 28		inc $28		                inc tmp2+1
.9b84						+
.9b84		a0 00		ldy #$00	                ldy #0
.9b86		b1 27		lda ($27),y	                lda (tmp2),y
.9b88		48		pha		                pha
.9b89		c8		iny		                iny
.9b8a		11 27		ora ($27),y	                ora (tmp2),y
.9b8c		f0 09		beq $9b97	                beq _zero
.9b8e		b1 27		lda ($27),y	                lda (tmp2),y
.9b90		85 28		sta $28		                sta tmp2+1
.9b92		68		pla		                pla
.9b93		85 27		sta $27		                sta tmp2
.9b95		80 d3		bra $9b6a	                bra _loop
.9b97						_zero:
.9b97		68		pla		                pla             ; Leftover from above loop
.9b98						_next_wordlist:
.9b98		b5 00		lda $00,x	                lda 0,x
.9b9a		1a		inc a		                ina
.9b9b		95 00		sta $00,x	                sta 0,x
.9b9d		c9 0c		cmp #$0c	                cmp #max_wordlists
.9b9f		d0 ab		bne $9b4c	                bne _wordlist_loop
.9ba1		e8		inx		                inx
.9ba2		e8		inx		                inx
.9ba3		74 00		stz $00,x	                stz 0,x
.9ba5		74 01		stz $01,x	                stz 1,x
.9ba7		80 0a		bra $9bb3	                bra z_int_to_name
.9ba9						_match:
.9ba9		e8		inx		                inx
.9baa		e8		inx		                inx
.9bab		a5 27		lda $27		                lda tmp2
.9bad		95 00		sta $00,x	                sta 0,x
.9baf		a5 28		lda $28		                lda tmp2+1
.9bb1		95 01		sta $01,x	                sta 1,x
.9bb3		60		rts		z_int_to_name:  rts
.9bb4						xt_latestnt:
.9bb4		ca		dex		                dex
.9bb5		ca		dex		                dex
.9bb6		20 bb d6	jsr $d6bb	                jsr current_to_dp
.9bb9		a5 02		lda $02		                lda dp
.9bbb		95 00		sta $00,x	                sta 0,x
.9bbd		a5 03		lda $03		                lda dp+1
.9bbf		95 01		sta $01,x	                sta 1,x
.9bc1		60		rts		z_latestnt:     rts
.9bc2						xt_latestxt:
.9bc2		20 b4 9b	jsr $9bb4	                jsr xt_latestnt         ; ( nt )
.9bc5		20 c9 9b	jsr $9bc9	                jsr xt_name_to_int      ; ( xt )
.9bc8		60		rts		z_latestxt:     rts
.9bc9						xt_name_to_int:
.9bc9		20 64 d7	jsr $d764	                jsr underflow_1
.9bcc		b5 00		lda $00,x	                lda 0,x
.9bce		18		clc		                clc
.9bcf		69 04		adc #$04	                adc #4
.9bd1		85 29		sta $29		                sta tmp3
.9bd3		b5 01		lda $01,x	                lda 1,x
.9bd5		90 01		bcc $9bd8	                bcc _done
.9bd7		1a		inc a		                ina
.9bd8						_done:
.9bd8		85 2a		sta $2a		                sta tmp3+1
.9bda		a0 00		ldy #$00	                ldy #0
.9bdc		b1 29		lda ($29),y	                lda (tmp3),y
.9bde		95 00		sta $00,x	                sta 0,x
.9be0		c8		iny		                iny
.9be1		b1 29		lda ($29),y	                lda (tmp3),y
.9be3		95 01		sta $01,x	                sta 1,x
.9be5		60		rts		z_name_to_int:  rts
.9be6						xt_name_to_string:
.9be6		20 64 d7	jsr $d764	                jsr underflow_1
.9be9		ca		dex		                dex
.9bea		ca		dex		                dex
.9beb		a1 02		lda ($02,x)	                lda (2,x)
.9bed		95 00		sta $00,x	                sta 0,x
.9bef		74 01		stz $01,x	                stz 1,x
.9bf1		b5 02		lda $02,x	                lda 2,x         ; LSB
.9bf3		18		clc		                clc
.9bf4		69 08		adc #$08	                adc #8
.9bf6		95 02		sta $02,x	                sta 2,x
.9bf8		90 02		bcc $9bfc	                bcc z_name_to_string
.9bfa		f6 03		inc $03,x	                inc 3,x         ; MSB
.9bfc						z_name_to_string:
.9bfc		60		rts		                rts
.9bfd						xt_nc_limit:
.9bfd		a9 00		lda #$00	                lda #nc_limit_offset
.9bff		4c 20 d6	jmp $d620	                jmp push_upvar_tos
.9c02						z_nc_limit:
.9c02						xt_never_native:
.9c02		20 bb d6	jsr $d6bb	                jsr current_to_dp
.9c05		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9c07		b1 02		lda ($02),y	                lda (dp),y
.9c09		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9c0b		29 fd		and #$fd	                and #$FF-AN     ; and AN flag is clear.
.9c0d		91 02		sta ($02),y	                sta (dp),y
.9c0f						z_never_native:
.9c0f		60		rts		                rts
.9c10						xt_not_rote:
.9c10		20 6e d7	jsr $d76e	                jsr underflow_3
.9c13		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9c15		b5 03		lda $03,x	                lda 3,x
.9c17		95 01		sta $01,x	                sta 1,x
.9c19		b5 05		lda $05,x	                lda 5,x
.9c1b		95 03		sta $03,x	                sta 3,x
.9c1d		94 05		sty $05,x	                sty 5,x
.9c1f		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9c21		b5 02		lda $02,x	                lda 2,x
.9c23		95 00		sta $00,x	                sta 0,x
.9c25		b5 04		lda $04,x	                lda 4,x
.9c27		95 02		sta $02,x	                sta 2,x
.9c29		94 04		sty $04,x	                sty 4,x
.9c2b		60		rts		z_not_rote:     rts
.9c2c						xt_number:
.9c2c		20 69 d7	jsr $d769	                jsr underflow_2
.9c2f		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9c31		a5 18		lda $18		                lda base
.9c33		48		pha		                pha
.9c34		20 ca 94	jsr $94ca	                jsr xt_two_dup
.9c37		a1 02		lda ($02,x)	                lda (2,x)
.9c39						_check_dec:
.9c39		c9 23		cmp #$23	                cmp #'#'
.9c3b		d0 04		bne $9c41	                bne _check_hex
.9c3d		a9 0a		lda #$0a	                lda #10
.9c3f		80 42		bra $9c83	                bra _base_changed
.9c41						_check_hex:
.9c41		c9 24		cmp #$24	                cmp #'$'
.9c43		d0 04		bne $9c49	                bne _check_binary
.9c45		a9 10		lda #$10	                lda #16
.9c47		80 3a		bra $9c83	                bra _base_changed
.9c49						_check_binary:
.9c49		c9 25		cmp #$25	                cmp #'%'
.9c4b		d0 04		bne $9c51	                bne _check_char
.9c4d		a9 02		lda #$02	                lda #2
.9c4f		80 32		bra $9c83	                bra _base_changed
.9c51						_check_char:
.9c51		c9 27		cmp #$27	                cmp #"'"
.9c53		d0 3a		bne $9c8f	                bne _check_minus
.9c55		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9c57		c9 03		cmp #$03	                cmp #3
.9c59		d0 26		bne $9c81	                bne _not_a_char
.9c5b		b5 01		lda $01,x	                lda 1,x
.9c5d		d0 22		bne $9c81	                bne _not_a_char ; No compare needed to check for non-zero.
.9c5f		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9c61		18		clc		                clc
.9c62		69 02		adc #$02	                adc #2          ; length of string
.9c64		85 23		sta $23		                sta tmptos
.9c66		b5 03		lda $03,x	                lda 3,x
.9c68		69 00		adc #$00	                adc #0          ; only need carry
.9c6a		85 24		sta $24		                sta tmptos+1
.9c6c		b2 23		lda ($23)	                lda (tmptos)
.9c6e		c9 27		cmp #$27	                cmp #"'"
.9c70		d0 0f		bne $9c81	                bne _not_a_char
.9c72		f6 02		inc $02,x	                inc 2,x
.9c74		d0 02		bne $9c78	                bne +
.9c76		f6 03		inc $03,x	                inc 3,x
.9c78						+
.9c78		a1 02		lda ($02,x)	                lda (2,x)
.9c7a		95 02		sta $02,x	                sta 2,x
.9c7c		74 03		stz $03,x	                stz 3,x
.9c7e		4c 01 9d	jmp $9d01	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9c81						_not_a_char:
.9c81		80 5c		bra $9cdf	                bra _number_error
.9c83						_base_changed:
.9c83		85 18		sta $18		                sta base        ; Switch to the new base
.9c85		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9c87		d0 02		bne $9c8b	                bne +
.9c89		f6 03		inc $03,x	                inc 3,x
.9c8b						+
.9c8b		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9c8d		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9c8f						_check_minus:
.9c8f		c9 2d		cmp #$2d	                cmp #'-'
.9c91		d0 0c		bne $9c9f	                bne _check_dot
.9c93		a9 80		lda #$80	                lda #$80
.9c95		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9c97		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9c99		d0 02		bne $9c9d	                bne +
.9c9b		f6 03		inc $03,x	                inc 3,x
.9c9d						+
.9c9d		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9c9f						_check_dot:
.9c9f		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9ca1		18		clc		                clc
.9ca2		75 00		adc $00,x	                adc 0,x         ; length of string
.9ca4		85 23		sta $23		                sta tmptos
.9ca6		b5 03		lda $03,x	                lda 3,x
.9ca8		69 00		adc #$00	                adc #0          ; only need carry
.9caa		85 24		sta $24		                sta tmptos+1
.9cac		a5 23		lda $23		                lda tmptos
.9cae		d0 02		bne $9cb2	                bne +
.9cb0		c6 24		dec $24		                dec tmptos+1
.9cb2						+
.9cb2		c6 23		dec $23		                dec tmptos
.9cb4		b2 23		lda ($23)	                lda (tmptos)
.9cb6		c9 2e		cmp #$2e	                cmp #'.'
.9cb8		d0 04		bne $9cbe	                bne _main
.9cba		e6 1e		inc $1e		                inc tmpdsp
.9cbc		d6 00		dec $00,x	                dec 0,x
.9cbe						_main:
.9cbe		ca		dex		                dex
.9cbf		ca		dex		                dex
.9cc0		ca		dex		                dex
.9cc1		ca		dex		                dex
.9cc2		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9cc4		95 00		sta $00,x	                sta 0,x
.9cc6		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9cc8		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9cca		95 02		sta $02,x	                sta 2,x
.9ccc		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9cce		95 03		sta $03,x	                sta 3,x
.9cd0		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9cd2		74 05		stz $05,x	                stz 5,x
.9cd4		74 06		stz $06,x	                stz 6,x
.9cd6		74 07		stz $07,x	                stz 7,x
.9cd8		20 eb 93	jsr $93eb	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9cdb		b5 00		lda $00,x	                lda 0,x
.9cdd		f0 1e		beq $9cfd	                beq _all_converted
.9cdf						_number_error:
.9cdf		20 c2 94	jsr $94c2	                jsr xt_two_drop ; >NUMBER modified addr u
.9ce2		20 c2 94	jsr $94c2	                jsr xt_two_drop ; ud   (partially converted number)
.9ce5		a9 3e		lda #$3e	                lda #'>'
.9ce7		20 ac 87	jsr $87ac	                jsr emit_a
.9cea		20 d4 95	jsr $95d4	                jsr xt_type
.9ced		a9 3c		lda #$3c	                lda #'<'
.9cef		20 ac 87	jsr $87ac	                jsr emit_a
.9cf2		20 c8 92	jsr $92c8	                jsr xt_space
.9cf5		68		pla		                pla
.9cf6		85 18		sta $18		                sta base
.9cf8		a9 08		lda #$08	                lda #err_syntax
.9cfa		4c 7a d7	jmp $d77a	                jmp error
.9cfd						_all_converted:
.9cfd		e8		inx		                inx ; Drop the current addr u
.9cfe		e8		inx		                inx
.9cff		e8		inx		                inx
.9d00		e8		inx		                inx
.9d01						_drop_original_string:
.9d01		20 90 95	jsr $9590	                jsr xt_two_swap  ; Drop the original addr u
.9d04		20 c2 94	jsr $94c2	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9d07		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9d09		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9d0b		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9d0c		f0 0a		beq $9d18	                beq _single
.9d0e		98		tya		                tya
.9d0f		04 1c		tsb $1c		                tsb status
.9d11		90 0f		bcc $9d22	                bcc _done       ; no minus, all done
.9d13		20 fa 9d	jsr $9dfa	                jsr xt_dnegate
.9d16		80 0a		bra $9d22	                bra _done
.9d18						_single:
.9d18		e8		inx		                inx
.9d19		e8		inx		                inx
.9d1a		98		tya		                tya
.9d1b		14 1c		trb $1c		                trb status
.9d1d		90 03		bcc $9d22	                bcc _done       ; no minus, all done
.9d1f		20 22 8d	jsr $8d22	                jsr xt_negate
.9d22						_done:
.9d22		68		pla		                pla
.9d23		85 18		sta $18		                sta base
.9d25		60		rts		z_number:       rts
.9d26						xt_editor_wordlist:
.9d26						xt_one:
.9d26		ca		dex		                dex
.9d27		ca		dex		                dex
.9d28		a9 01		lda #$01	                lda #1
.9d2a		95 00		sta $00,x	                sta 0,x
.9d2c		74 01		stz $01,x	                stz 1,x
.9d2e						z_editor_wordlist:
.9d2e						z_one:
.9d2e		60		rts		                rts
.9d2f						xt_output:
.9d2f		ca		dex		                dex
.9d30		ca		dex		                dex
.9d31		a9 12		lda #$12	                lda #<output
.9d33		95 00		sta $00,x	                sta 0,x
.9d35		a9 00		lda #$00	                lda #>output
.9d37		95 01		sta $01,x	                sta 1,x
.9d39		60		rts		z_output:       rts
.9d3a						xt_r_to_input:
.9d3a		68		pla		                pla
.9d3b		85 25		sta $25		                sta tmp1
.9d3d		68		pla		                pla
.9d3e		85 26		sta $26		                sta tmp1+1
.9d40		a0 00		ldy #$00	                ldy #0
.9d42						_loop:
.9d42		68		pla		                pla
.9d43		99 0a 00	sta $000a,y	                sta insrc,y
.9d46		c8		iny		                iny
.9d47		c0 08		cpy #$08	                cpy #8
.9d49		d0 f7		bne $9d42	                bne _loop
.9d4b		a5 26		lda $26		                lda tmp1+1
.9d4d		48		pha		                pha
.9d4e		a5 25		lda $25		                lda tmp1
.9d50		48		pha		                pha
.9d51		60		rts		z_r_to_input: 	rts
.9d52						xt_strip_underflow:
.9d52		a9 02		lda #$02	                lda #uf_strip_offset
.9d54		4c 20 d6	jmp $d620	                jmp push_upvar_tos
.9d57						z_strip_underflow:
.9d57						xt_assembler_wordlist:
.9d57						xt_two:
.9d57		ca		dex		                dex
.9d58		ca		dex		                dex
.9d59		a9 02		lda #$02	                lda #2
.9d5b		95 00		sta $00,x	                sta 0,x
.9d5d		74 01		stz $01,x	                stz 1,x
.9d5f						z_assembler_wordlist:
.9d5f		60		rts		z_two:          rts
.9d60						xt_useraddr:
.9d60		ca		dex		                dex
.9d61		ca		dex		                dex
.9d62		a9 08		lda #$08	                lda #<up
.9d64		95 00		sta $00,x	                sta 0,x
.9d66		a9 00		lda #$00	                lda #>up
.9d68		95 01		sta $01,x	                sta 1,x
.9d6a		60		rts		z_useraddr:     rts
.9d6b						xt_wordsize:
.9d6b		20 64 d7	jsr $d764	                jsr underflow_1
.9d6e		b5 00		lda $00,x	                lda 0,x
.9d70		85 25		sta $25		                sta tmp1
.9d72		b5 01		lda $01,x	                lda 1,x
.9d74		85 26		sta $26		                sta tmp1+1
.9d76		a0 06		ldy #$06	                ldy #6
.9d78		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9d7a		88		dey		                dey
.9d7b		88		dey		                dey
.9d7c		38		sec		                sec
.9d7d		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9d7f		95 00		sta $00,x	                sta 0,x
.9d81		a0 07		ldy #$07	                ldy #7
.9d83		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9d85		88		dey		                dey
.9d86		88		dey		                dey
.9d87		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9d89		95 01		sta $01,x	                sta 1,x
.9d8b		60		rts		z_wordsize:     rts
.9d8c						xt_case:
.9d8c						xt_false:
.9d8c						xt_forth_wordlist:
.9d8c						xt_zero:
.9d8c		ca		dex		                dex             ; push
.9d8d		ca		dex		                dex
.9d8e		74 00		stz $00,x	                stz 0,x
.9d90		74 01		stz $01,x	                stz 1,x
.9d92						z_case:
.9d92						z_false:
.9d92						z_forth_wordlist:
.9d92						z_zero:
.9d92		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9d93						xt_d_minus:
.9d93		20 73 d7	jsr $d773	                jsr underflow_4 ; two double numbers
.9d96		38		sec		                sec
.9d97		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9d99		f5 02		sbc $02,x	                sbc 2,x
.9d9b		95 06		sta $06,x	                sta 6,x
.9d9d		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9d9f		f5 03		sbc $03,x	                sbc 3,x
.9da1		95 07		sta $07,x	                sta 7,x
.9da3		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9da5		f5 00		sbc $00,x	                sbc 0,x
.9da7		95 04		sta $04,x	                sta 4,x
.9da9		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9dab		f5 01		sbc $01,x	                sbc 1,x
.9dad		95 05		sta $05,x	                sta 5,x
.9daf		e8		inx		                inx
.9db0		e8		inx		                inx
.9db1		e8		inx		                inx
.9db2		e8		inx		                inx
.9db3		60		rts		z_d_minus:      rts
.9db4						xt_d_plus:
.9db4		20 73 d7	jsr $d773	                jsr underflow_4 ; two double numbers
.9db7		18		clc		                clc
.9db8		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9dba		75 06		adc $06,x	                adc 6,x
.9dbc		95 06		sta $06,x	                sta 6,x
.9dbe		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9dc0		75 07		adc $07,x	                adc 7,x
.9dc2		95 07		sta $07,x	                sta 7,x
.9dc4		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9dc6		75 04		adc $04,x	                adc 4,x
.9dc8		95 04		sta $04,x	                sta 4,x
.9dca		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9dcc		75 05		adc $05,x	                adc 5,x
.9dce		95 05		sta $05,x	                sta 5,x
.9dd0		e8		inx		                inx
.9dd1		e8		inx		                inx
.9dd2		e8		inx		                inx
.9dd3		e8		inx		                inx
.9dd4		60		rts		z_d_plus:       rts
.9dd5						xt_d_to_s:
.9dd5		20 69 d7	jsr $d769	                jsr underflow_2
.9dd8		e8		inx		                inx
.9dd9		e8		inx		                inx
.9dda		60		rts		z_d_to_s:       rts
.9ddb						xt_dabs:
.9ddb		20 69 d7	jsr $d769	                jsr underflow_2 ; double number
.9dde		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9de0		10 17		bpl $9df9	                bpl _done       ; positive, we get off light
.9de2		a0 00		ldy #$00	                ldy #0
.9de4		38		sec		                sec
.9de5		98		tya		                tya
.9de6		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9de8		95 02		sta $02,x	                sta 2,x
.9dea		98		tya		                tya
.9deb		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9ded		95 03		sta $03,x	                sta 3,x
.9def		98		tya		                tya
.9df0		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9df2		95 00		sta $00,x	                sta 0,x
.9df4		98		tya		                tya
.9df5		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9df7		95 01		sta $01,x	                sta 1,x
.9df9						_done:
.9df9		60		rts		z_dabs:         rts
.9dfa						xt_dnegate:
.9dfa		20 69 d7	jsr $d769	                jsr underflow_2 ; double number
.9dfd		a0 00		ldy #$00	     		ldy #0
.9dff		38		sec		                sec
.9e00		98		tya		                tya
.9e01		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e03		95 02		sta $02,x	                sta 2,x
.9e05		98		tya		                tya
.9e06		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e08		95 03		sta $03,x	                sta 3,x
.9e0a		98		tya		                tya
.9e0b		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e0d		95 00		sta $00,x	                sta 0,x
.9e0f		98		tya		                tya
.9e10		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e12		95 01		sta $01,x	                sta 1,x
.9e14		60		rts		z_dnegate:      rts
.9e15						xt_d_dot:
.9e15		20 69 d7	jsr $d769	                jsr underflow_2
.9e18		20 a8 94	jsr $94a8	                jsr xt_tuck
.9e1b		20 db 9d	jsr $9ddb	                jsr xt_dabs
.9e1e		20 f8 8a	jsr $8af8	                jsr xt_less_number_sign
.9e21		20 b6 8d	jsr $8db6	                jsr xt_number_sign_s
.9e24		20 8e 90	jsr $908e	                jsr xt_rot
.9e27		20 4d 92	jsr $924d	                jsr xt_sign
.9e2a		20 94 8d	jsr $8d94	                jsr xt_number_sign_greater
.9e2d		20 d4 95	jsr $95d4	                jsr xt_type
.9e30		20 c8 92	jsr $92c8	                jsr xt_space
.9e33		60		rts		z_d_dot:        rts
.9e34						xt_d_dot_r:
.9e34		20 6e d7	jsr $d76e	                jsr underflow_3
.9e37		20 8b 94	jsr $948b	                jsr xt_to_r
.9e3a		20 a8 94	jsr $94a8	                jsr xt_tuck
.9e3d		20 db 9d	jsr $9ddb	                jsr xt_dabs
.9e40		20 f8 8a	jsr $8af8	                jsr xt_less_number_sign
.9e43		20 b6 8d	jsr $8db6	                jsr xt_number_sign_s
.9e46		20 8e 90	jsr $908e	                jsr xt_rot
.9e49		20 4d 92	jsr $924d	                jsr xt_sign
.9e4c		20 94 8d	jsr $8d94	                jsr xt_number_sign_greater
.9e4f		20 f1 8f	jsr $8ff1	                jsr xt_r_from
.9e52		20 08 8e	jsr $8e08	                jsr xt_over
.9e55		20 e7 8c	jsr $8ce7	                jsr xt_minus
.9e58		20 ce 92	jsr $92ce	                jsr xt_spaces
.9e5b		20 d4 95	jsr $95d4	                jsr xt_type
.9e5e		60		rts		z_d_dot_r:      rts
.9e5f						xt_two_constant:
.9e5f		20 69 d7	jsr $d769	                jsr underflow_2
.9e62		20 00 85	jsr $8500	                jsr xt_create
.9e65		20 4d 93	jsr $934d	                jsr xt_swap
.9e68		20 cf 83	jsr $83cf	                jsr xt_comma
.9e6b		20 cf 83	jsr $83cf	                jsr xt_comma
.9e6e		20 a0 86	jsr $86a0	                jsr does_runtime    ; does> turns into these two routines.
.9e71		20 f9 d5	jsr $d5f9	                jsr dodoes
.9e74		20 42 87	jsr $8742	                jsr xt_dup
.9e77		20 01 89	jsr $8901	                jsr xt_fetch
.9e7a		20 4d 93	jsr $934d	                jsr xt_swap
.9e7d		20 45 83	jsr $8345	                jsr xt_cell_plus
.9e80		20 01 89	jsr $8901	                jsr xt_fetch
.9e83		60		rts		z_two_constant: rts
.9e84						xt_two_literal:
.9e84		20 69 d7	jsr $d769	                jsr underflow_2 ; double number
.9e87		a9 0a		lda #$0a	                lda # z_template_push_tos - template_push_tos
.9e89		0a		asl a		                asl
.9e8a		20 bd d5	jsr $d5bd	                jsr check_nc_limit
.9e8d		b0 09		bcs $9e98	                bcs _no_inline
.9e8f		20 4d 93	jsr $934d	                jsr xt_swap
.9e92		20 1b 8b	jsr $8b1b	                jsr xt_literal
.9e95		4c 1b 8b	jmp $8b1b	                jmp xt_literal
.9e98						_no_inline:
.9e98		20 f7 a0	jsr $a0f7	                jsr cmpl_two_literal
.9e9b		60		rts		z_two_literal:  rts
.9e9c						xt_two_variable:
.9e9c		20 00 85	jsr $8500	                jsr xt_create
.9e9f		ca		dex		                dex
.9ea0		ca		dex		                dex
.9ea1		a9 04		lda #$04	                lda #4
.9ea3		95 00		sta $00,x	                sta 0,x
.9ea5		74 01		stz $01,x	                stz 1,x
.9ea7		20 29 82	jsr $8229	                jsr xt_allot
.9eaa		60		rts		z_two_variable: rts
.9eab						xt_ud_dot:
.9eab		20 69 d7	jsr $d769	                jsr underflow_2 ; double number
.9eae		20 f8 8a	jsr $8af8	                jsr xt_less_number_sign
.9eb1		20 b6 8d	jsr $8db6	                jsr xt_number_sign_s
.9eb4		20 94 8d	jsr $8d94	                jsr xt_number_sign_greater
.9eb7		20 d4 95	jsr $95d4	                jsr xt_type
.9eba		20 c8 92	jsr $92c8	                jsr xt_space
.9ebd		60		rts		z_ud_dot:        rts
.9ebe						xt_ud_dot_r:
.9ebe		20 6e d7	jsr $d76e	                jsr underflow_3
.9ec1		20 8b 94	jsr $948b	                jsr xt_to_r
.9ec4		20 f8 8a	jsr $8af8	                jsr xt_less_number_sign
.9ec7		20 b6 8d	jsr $8db6	                jsr xt_number_sign_s
.9eca		20 94 8d	jsr $8d94	                jsr xt_number_sign_greater
.9ecd		20 f1 8f	jsr $8ff1	                jsr xt_r_from
.9ed0		20 08 8e	jsr $8e08	                jsr xt_over
.9ed3		20 e7 8c	jsr $8ce7	                jsr xt_minus
.9ed6		20 ce 92	jsr $92ce	                jsr xt_spaces
.9ed9		20 d4 95	jsr $95d4	                jsr xt_type
.9edc		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.9edd						xt_cmove:
.9edd		20 6e d7	jsr $d76e	                jsr underflow_3
.9ee0		b5 02		lda $02,x	                lda 2,x
.9ee2		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9ee4		b5 03		lda $03,x	                lda 3,x
.9ee6		85 28		sta $28		                sta tmp2+1
.9ee8		b5 04		lda $04,x	                lda 4,x
.9eea		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9eec		b5 05		lda $05,x	                lda 5,x
.9eee		85 26		sta $26		                sta tmp1+1
.9ef0		a0 00		ldy #$00	                ldy #0
.9ef2		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.9ef4		f0 0f		beq $9f05	                beq _dopartial
.9ef6						_page:
.9ef6		b1 25		lda ($25),y	                lda (tmp1),y
.9ef8		91 27		sta ($27),y	                sta (tmp2),y
.9efa		c8		iny		                iny
.9efb		d0 f9		bne $9ef6	                bne _page
.9efd		e6 26		inc $26		                inc tmp1+1
.9eff		e6 28		inc $28		                inc tmp2+1
.9f01		d6 01		dec $01,x	                dec 1,x
.9f03		d0 f1		bne $9ef6	                bne _page
.9f05						_dopartial:
.9f05		b5 00		lda $00,x	                lda 0,x         ; length of last page
.9f07		f0 09		beq $9f12	                beq _done
.9f09						_partial:
.9f09		b1 25		lda ($25),y	                lda (tmp1),y
.9f0b		91 27		sta ($27),y	                sta (tmp2),y
.9f0d		c8		iny		                iny
.9f0e		d6 00		dec $00,x	                dec 0,x
.9f10		d0 f7		bne $9f09	                bne _partial
.9f12						_done:
.9f12		8a		txa		                txa
.9f13		18		clc		                clc
.9f14		69 06		adc #$06	                adc #6
.9f16		aa		tax		                tax
.9f17		60		rts		z_cmove:        rts
.9f18						xt_cmove_up:
.9f18		20 6e d7	jsr $d76e	                jsr underflow_3
.9f1b		b5 02		lda $02,x	                lda 2,x
.9f1d		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f1f		b5 03		lda $03,x	                lda 3,x
.9f21		18		clc		                clc
.9f22		75 01		adc $01,x	                adc 1,x
.9f24		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.9f26		b5 04		lda $04,x	                lda 4,x
.9f28		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9f2a		b5 05		lda $05,x	                lda 5,x
.9f2c		18		clc		                clc
.9f2d		75 01		adc $01,x	                adc 1,x
.9f2f		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.9f31		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.9f33		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.9f35		f0 0e		beq $9f45	                beq _nopartial
.9f37						_outerloop:
.9f37		88		dey		                dey
.9f38		f0 07		beq $9f41	                beq _finishpage
.9f3a						_innerloop:
.9f3a		b1 25		lda ($25),y	                lda (tmp1),y
.9f3c		91 27		sta ($27),y	                sta (tmp2),y
.9f3e		88		dey		                dey
.9f3f		d0 f9		bne $9f3a	                bne _innerloop
.9f41						_finishpage:
.9f41		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.9f43		92 27		sta ($27)	                sta (tmp2)
.9f45						_nopartial:
.9f45		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.9f47		c6 28		dec $28		                dec tmp2+1
.9f49		d6 01		dec $01,x	                dec 1,x
.9f4b		d0 ea		bne $9f37	                bne _outerloop
.9f4d						_done:
.9f4d		8a		txa		                txa
.9f4e		18		clc		                clc
.9f4f		69 06		adc #$06	                adc #6
.9f51		aa		tax		                tax
.9f52		60		rts		z_cmove_up:     rts
.9f53						xt_compare:
.9f53		20 73 d7	jsr $d773	                jsr underflow_4
.9f56		b5 02		lda $02,x	                lda 2,x
.9f58		85 27		sta $27		                sta tmp2
.9f5a		b5 03		lda $03,x	                lda 3,x
.9f5c		85 28		sta $28		                sta tmp2+1
.9f5e		b5 06		lda $06,x	                lda 6,x
.9f60		85 25		sta $25		                sta tmp1
.9f62		b5 07		lda $07,x	                lda 7,x
.9f64		85 26		sta $26		                sta tmp1+1
.9f66						_compare_loop:
.9f66		b5 04		lda $04,x	                lda 4,x
.9f68		15 05		ora $05,x	                ora 5,x
.9f6a		f0 2c		beq $9f98	                beq _str1_done
.9f6c		b5 00		lda $00,x	                lda 0,x
.9f6e		15 01		ora $01,x	                ora 1,x
.9f70		f0 3a		beq $9fac	                beq _greater    ; Str2 empty first
.9f72						_check_letter:
.9f72		b2 25		lda ($25)	                lda (tmp1)
.9f74		d2 27		cmp ($27)	                cmp (tmp2)
.9f76		90 26		bcc $9f9e	                bcc _less
.9f78		d0 32		bne $9fac	                bne _greater
.9f7a						_next_letter:
.9f7a		e6 25		inc $25		                inc tmp1
.9f7c		d0 02		bne $9f80	                bne +
.9f7e		e6 26		inc $26		                inc tmp1+1
.9f80						+
.9f80		e6 27		inc $27		                inc tmp2
.9f82		d0 02		bne $9f86	                bne +
.9f84		e6 28		inc $28		                inc tmp2+1
.9f86						+
.9f86		b5 04		lda $04,x	                lda 4,x
.9f88		d0 02		bne $9f8c	                bne +
.9f8a		d6 05		dec $05,x	                dec 5,x
.9f8c						+
.9f8c		d6 04		dec $04,x	                dec 4,x
.9f8e		b5 00		lda $00,x	                lda 0,x
.9f90		d0 02		bne $9f94	                bne +
.9f92		d6 01		dec $01,x	                dec 1,x
.9f94						+
.9f94		d6 00		dec $00,x	                dec 0,x
.9f96		80 ce		bra $9f66	                bra _compare_loop
.9f98						_str1_done:
.9f98		b5 00		lda $00,x	                lda 0,x
.9f9a		15 01		ora $01,x	                ora 1,x
.9f9c		f0 08		beq $9fa6	                beq _equal      ; Both out of letters
.9f9e						_less:
.9f9e		a9 ff		lda #$ff	                lda #$FF
.9fa0		95 06		sta $06,x	                sta 6,x
.9fa2		95 07		sta $07,x	                sta 7,x
.9fa4		80 0c		bra $9fb2	                bra _done
.9fa6						_equal:
.9fa6		74 06		stz $06,x	                stz 6,x
.9fa8		74 07		stz $07,x	                stz 7,x
.9faa		80 06		bra $9fb2	                bra _done
.9fac						_greater:
.9fac		a9 01		lda #$01	                lda #1
.9fae		95 06		sta $06,x	                sta 6,x
.9fb0		74 07		stz $07,x	                stz 7,x
.9fb2						_done:
.9fb2		8a		txa		                txa
.9fb3		18		clc		                clc
.9fb4		69 06		adc #$06	                adc #6
.9fb6		aa		tax		                tax
.9fb7		60		rts		z_compare:      rts
.9fb8						xt_minus_leading:
.9fb8		20 69 d7	jsr $d769	                jsr underflow_2
.9fbb						_loop:
.9fbb		b5 00		lda $00,x	                lda 0,x
.9fbd		15 01		ora $01,x	                ora 1,x
.9fbf		f0 0f		beq $9fd0	                beq _done
.9fc1		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.9fc3		20 57 d7	jsr $d757	                jsr is_whitespace
.9fc6		90 08		bcc $9fd0	                bcc _done
.9fc8		20 26 9d	jsr $9d26	                jsr xt_one              ; ( addr u 1 )
.9fcb		20 ad a0	jsr $a0ad	                jsr xt_slash_string     ; ( addr+ u-1 )
.9fce		80 eb		bra $9fbb	                bra _loop
.9fd0						_done:
.9fd0						z_minus_leading:
.9fd0		60		rts		                rts
.9fd1						xt_minus_trailing:
.9fd1		20 69 d7	jsr $d769	                jsr underflow_2
.9fd4		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.9fd6		15 01		ora $01,x	                ora 1,x         ; MSB of n
.9fd8		f0 33		beq $a00d	                beq _done
.9fda		18		clc		                clc
.9fdb		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.9fdd		75 00		adc $00,x	                adc 0,x
.9fdf		85 25		sta $25		                sta tmp1
.9fe1		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.9fe3		75 01		adc $01,x	                adc 1,x
.9fe5		85 26		sta $26		                sta tmp1+1
.9fe7		a5 25		lda $25		                lda tmp1
.9fe9		d0 02		bne $9fed	                bne +
.9feb		c6 26		dec $26		                dec tmp1+1
.9fed						+
.9fed		c6 25		dec $25		                dec tmp1
.9fef						_loop:
.9fef		b2 25		lda ($25)	                lda (tmp1)
.9ff1		c9 20		cmp #$20	                cmp #AscSP
.9ff3		d0 18		bne $a00d	                bne _done
.9ff5		a5 25		lda $25		                lda tmp1
.9ff7		d0 02		bne $9ffb	                bne +
.9ff9		c6 26		dec $26		                dec tmp1+1
.9ffb						+
.9ffb		c6 25		dec $25		                dec tmp1
.9ffd		b5 00		lda $00,x	                lda 0,x
.9fff		d0 02		bne $a003	                bne +
.a001		d6 01		dec $01,x	                dec 1,x
.a003						+
.a003		d6 00		dec $00,x	                dec 0,x
.a005		b5 00		lda $00,x	                lda 0,x
.a007		15 01		ora $01,x	                ora 1,x
.a009		f0 02		beq $a00d	                beq _done       ; Count has reached zero - we're done!
.a00b		80 e2		bra $9fef	                bra _loop
.a00d						_done:
.a00d						z_minus_trailing:
.a00d		60		rts		                rts
.a00e						xt_search:
.a00e		20 73 d7	jsr $d773	                jsr underflow_4
.a011		b5 00		lda $00,x	                lda 0,x
.a013		15 01		ora $01,x	                ora 1,x
.a015		d0 0b		bne $a022	                bne _start_search
.a017		e8		inx		                inx             ; Remove u2
.a018		e8		inx		                inx
.a019		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a01b		95 00		sta $00,x	                sta 0,x
.a01d		95 01		sta $01,x	                sta 1,x
.a01f		4c ac a0	jmp $a0ac	                jmp z_search
.a022						_start_search:
.a022		20 8c 9d	jsr $9d8c	                jsr xt_zero
.a025						_search_loop:
.a025		18		clc		                clc
.a026		b5 00		lda $00,x	                lda 0,x
.a028		75 02		adc $02,x	                adc 2,x
.a02a		85 25		sta $25		                sta tmp1
.a02c		b5 01		lda $01,x	                lda 1,x
.a02e		75 03		adc $03,x	                adc 3,x
.a030		d5 07		cmp $07,x	                cmp 7,x
.a032		90 12		bcc $a046	                bcc _init_comparison ; Obviously less
.a034		d0 06		bne $a03c	                bne _not_found
.a036		b5 06		lda $06,x	                lda 6,x
.a038		c5 25		cmp $25		                cmp tmp1
.a03a		b0 0a		bcs $a046	                bcs _init_comparison
.a03c						_not_found:
.a03c		e8		inx		                inx             ; Remove offset
.a03d		e8		inx		                inx
.a03e		e8		inx		                inx             ; Remove u2
.a03f		e8		inx		                inx
.a040		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a042		74 01		stz $01,x	                stz 1,x
.a044		80 66		bra $a0ac	                bra z_search
.a046						_init_comparison:
.a046		18		clc		                clc
.a047		b5 08		lda $08,x	                lda 8,x
.a049		75 00		adc $00,x	                adc 0,x
.a04b		85 25		sta $25		                sta tmp1
.a04d		b5 09		lda $09,x	                lda 9,x
.a04f		75 01		adc $01,x	                adc 1,x
.a051		85 26		sta $26		                sta tmp1+1
.a053		b5 04		lda $04,x	                lda 4,x
.a055		85 27		sta $27		                sta tmp2
.a057		b5 05		lda $05,x	                lda 5,x
.a059		85 28		sta $28		                sta tmp2+1
.a05b		b5 02		lda $02,x	                lda 2,x
.a05d		85 29		sta $29		                sta tmp3
.a05f		b5 03		lda $03,x	                lda 3,x
.a061		85 2a		sta $2a		                sta tmp3+1
.a063						_comparison_loop:
.a063		b2 25		lda ($25)	                lda (tmp1)
.a065		d2 27		cmp ($27)	                cmp (tmp2)
.a067		f0 05		beq $a06e	                beq _letters_match
.a069		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.a06c		80 b7		bra $a025	                bra _search_loop
.a06e						_letters_match:
.a06e		e6 25		inc $25		                inc tmp1
.a070		d0 02		bne $a074	                bne +
.a072		e6 26		inc $26		                inc tmp1+1
.a074						+
.a074		e6 27		inc $27		                inc tmp2
.a076		d0 02		bne $a07a	                bne +
.a078		e6 28		inc $28		                inc tmp2+1
.a07a						+
.a07a		a5 29		lda $29		                lda tmp3
.a07c		d0 02		bne $a080	                bne +
.a07e		c6 2a		dec $2a		                dec tmp3+1
.a080						+
.a080		c6 29		dec $29		                dec tmp3
.a082		a5 29		lda $29		                lda tmp3
.a084		05 2a		ora $2a		                ora tmp3+1
.a086		d0 db		bne $a063	                bne _comparison_loop ; Check the next letter
.a088		18		clc		                clc
.a089		b5 00		lda $00,x	                lda 0,x
.a08b		75 08		adc $08,x	                adc 8,x
.a08d		95 08		sta $08,x	                sta 8,x
.a08f		b5 01		lda $01,x	                lda 1,x
.a091		75 09		adc $09,x	                adc 9,x
.a093		95 09		sta $09,x	                sta 9,x
.a095		38		sec		                sec
.a096		b5 06		lda $06,x	                lda 6,x
.a098		f5 00		sbc $00,x	                sbc 0,x
.a09a		95 06		sta $06,x	                sta 6,x
.a09c		b5 07		lda $07,x	                lda 7,x
.a09e		f5 01		sbc $01,x	                sbc 1,x
.a0a0		95 07		sta $07,x	                sta 7,x
.a0a2		e8		inx		                inx             ; drop offset
.a0a3		e8		inx		                inx
.a0a4		e8		inx		                inx             ; drop u2
.a0a5		e8		inx		                inx
.a0a6		a9 ff		lda #$ff	                lda #$FF
.a0a8		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a0aa		95 01		sta $01,x	                sta 1,x
.a0ac		60		rts		z_search:       rts
.a0ad						xt_slash_string:
.a0ad		20 6e d7	jsr $d76e	                jsr underflow_3
.a0b0		18		clc		                clc             ; 3OS+TOS
.a0b1		b5 00		lda $00,x	                lda 0,x
.a0b3		75 04		adc $04,x	                adc 4,x
.a0b5		95 04		sta $04,x	                sta 4,x
.a0b7		b5 01		lda $01,x	                lda 1,x
.a0b9		75 05		adc $05,x	                adc 5,x
.a0bb		95 05		sta $05,x	                sta 5,x
.a0bd		38		sec		                sec             ; NOS-TOS
.a0be		b5 02		lda $02,x	                lda 2,x
.a0c0		f5 00		sbc $00,x	                sbc 0,x
.a0c2		95 02		sta $02,x	                sta 2,x
.a0c4		b5 03		lda $03,x	                lda 3,x
.a0c6		f5 01		sbc $01,x	                sbc 1,x
.a0c8		95 03		sta $03,x	                sta 3,x
.a0ca		e8		inx		                inx
.a0cb		e8		inx		                inx
.a0cc		60		rts		z_slash_string: rts
.a0cd						xt_sliteral:
.a0cd		20 69 d7	jsr $d769	                jsr underflow_2
.a0d0		20 b3 d5	jsr $d5b3	                jsr cmpl_jump_later
.a0d3		20 8b 94	jsr $948b	                jsr xt_to_r
.a0d6		20 02 8a	jsr $8a02	                jsr xt_here
.a0d9		20 4d 93	jsr $934d	                jsr xt_swap
.a0dc		20 42 87	jsr $8742	                jsr xt_dup
.a0df		20 29 82	jsr $8229	                jsr xt_allot            ; reserve u bytes for string
.a0e2		20 02 8a	jsr $8a02	                jsr xt_here
.a0e5		20 f1 8f	jsr $8ff1	                jsr xt_r_from
.a0e8		20 37 93	jsr $9337	                jsr xt_store            ; point jmp past string
.a0eb		20 ca 94	jsr $94ca	                jsr xt_two_dup
.a0ee		20 b4 95	jsr $95b4	                jsr xt_two_to_r
.a0f1		20 03 8d	jsr $8d03	                jsr xt_move             ; copy u bytes from addr -> addr'
.a0f4		20 3a 95	jsr $953a	                jsr xt_two_r_from
.a0f7						cmpl_sliteral:
.a0f7						cmpl_two_literal:
.a0f7		a0 a1		ldy #$a1	                ldy #>sliteral_runtime
.a0f9		a9 11		lda #$11	                lda #<sliteral_runtime
.a0fb		20 8e d5	jsr $d58e	                jsr cmpl_call_ya
.a0fe		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a100		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a102		20 9a d5	jsr $d59a	                jsr cmpl_word_ya
.a105		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a107		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a109		20 9a d5	jsr $d59a	                jsr cmpl_word_ya
.a10c		e8		inx		                inx
.a10d		e8		inx		                inx
.a10e		e8		inx		                inx
.a10f		e8		inx		                inx
.a110		60		rts		z_sliteral:     rts
.a111						two_literal_runtime:
.a111						sliteral_runtime:
.a111		ca		dex		                dex
.a112		ca		dex		                dex
.a113		ca		dex		                dex
.a114		ca		dex		                dex
.a115		68		pla		                pla
.a116		85 25		sta $25		                sta tmp1        ; LSB of address
.a118		7a		ply		                ply
.a119		84 26		sty $26		                sty tmp1+1      ; MSB of address
.a11b		18		clc		                clc
.a11c		69 04		adc #$04	                adc #4
.a11e		90 01		bcc $a121	                bcc +
.a120		c8		iny		                iny
.a121						+
.a121		5a		phy		                phy
.a122		48		pha		                pha
.a123		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a125		b1 25		lda ($25),y	                lda (tmp1),y
.a127		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a129		c8		iny		                iny
.a12a		b1 25		lda ($25),y	                lda (tmp1),y
.a12c		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a12e		c8		iny		                iny
.a12f		b1 25		lda ($25),y	                lda (tmp1),y
.a131		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a133		c8		iny		                iny
.a134		b1 25		lda ($25),y	                lda (tmp1),y
.a136		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a138		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a139						xt_disasm:
.a139		20 69 d7	jsr $d769	                jsr underflow_2
.a13c		20 40 a1	jsr $a140	                jsr disassembler
.a13f		60		rts		z_disasm:       rts
.a140						disassembler:
.a140		20 fa 84	jsr $84fa	                jsr xt_cr       ; ( addr u )
.a143						_byte_loop:
.a143		20 08 8e	jsr $8e08	                jsr xt_over     ; ( addr u addr )
.a146		20 ff 95	jsr $95ff	                jsr xt_u_dot    ; ( addr u )
.a149		20 c8 92	jsr $92c8	                jsr xt_space
.a14c		a9 64		lda #$64	                lda #<oc_index_table
.a14e		85 27		sta $27		                sta tmp2
.a150		a9 b3		lda #$b3	                lda #>oc_index_table
.a152		85 28		sta $28		                sta tmp2+1
.a154		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a156		85 2d		sta $2d		                sta scratch     ; Save opcode
.a158		0a		asl a		                asl             ; multiply by two for offset
.a159		90 02		bcc $a15d	                bcc +
.a15b		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a15d						+
.a15d		a8		tay		                tay             ; use Y as the index
.a15e		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a160		85 29		sta $29		                sta tmp3
.a162		48		pha		                pha
.a163		c8		iny		                iny
.a164		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a166		85 2a		sta $2a		                sta tmp3+1
.a168		48		pha		                pha
.a169		b2 29		lda ($29)	                lda (tmp3)
.a16b		a8		tay		                tay                     ; save copy of lengths byte
.a16c		10 3c		bpl $a1aa	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a16e		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.a171		f6 04		inc $04,x	                inc 4,x
.a173		d0 02		bne $a177	                bne +
.a175		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.a177						+
.a177		b5 02		lda $02,x	                lda 2,x
.a179		d0 02		bne $a17d	                bne +
.a17b		d6 03		dec $03,x	                dec 3,x
.a17d						+
.a17d		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.a17f		a1 04		lda ($04,x)	                lda (4,x)
.a181		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a183		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a185		98		tya		                tya                     ; retrieve copy of lengths byte
.a186		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a187		10 14		bpl $a19d	                bpl _print_operand
.a189		f6 04		inc $04,x	                inc 4,x
.a18b		d0 02		bne $a18f	                bne +
.a18d		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.a18f						+
.a18f		b5 02		lda $02,x	                lda 2,x
.a191		d0 02		bne $a195	                bne +
.a193		d6 03		dec $03,x	                dec 3,x
.a195						+
.a195		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.a197		a1 04		lda ($04,x)	                lda (4,x)
.a199		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a19b		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a19d						_print_operand:
.a19d		ca		dex		                dex
.a19e		ca		dex		                dex
.a19f		a9 05		lda #$05	                lda #5
.a1a1		95 00		sta $00,x	                sta 0,x
.a1a3		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.a1a5		20 0b 96	jsr $960b	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.a1a8		80 0b		bra $a1b5	                bra _print_mnemonic
.a1aa						_no_operand:
.a1aa		ca		dex		                dex
.a1ab		ca		dex		                dex
.a1ac		a9 05		lda #$05	                lda #5
.a1ae		95 00		sta $00,x	                sta 0,x
.a1b0		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.a1b2		20 ce 92	jsr $92ce	                jsr xt_spaces           ; ( addr u )
.a1b5						_print_mnemonic:
.a1b5		20 c8 92	jsr $92c8	                jsr xt_space
.a1b8		ca		dex		                dex
.a1b9		ca		dex		                dex                     ; ( addr u ? )
.a1ba		68		pla		                pla                     ; MSB
.a1bb		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a1bd		68		pla		                pla                     ; LSB
.a1be		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a1c0		20 e6 84	jsr $84e6	                jsr xt_count            ; ( addr u addr-o u-o )
.a1c3		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a1c5		b5 00		lda $00,x	                lda 0,x
.a1c7		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a1c9		95 00		sta $00,x	                sta 0,x
.a1cb		20 d4 95	jsr $95d4	                jsr xt_type             ; ( addr u )
.a1ce		a5 2d		lda $2d		                lda scratch
.a1d0		c9 20		cmp #$20	                cmp #OpJSR
.a1d2		d0 4e		bne $a222	                bne _not_jsr
.a1d4		ca		dex		                dex
.a1d5		ca		dex		                dex
.a1d6		a9 05		lda #$05	                lda #5
.a1d8		95 00		sta $00,x	                sta 0,x
.a1da		74 01		stz $01,x	                stz 1,x
.a1dc		20 ce 92	jsr $92ce	                jsr xt_spaces
.a1df		a0 10		ldy #$10	                ldy #(_end_handlers - _special_handlers - 4)
.a1e1		b9 0e a2	lda $a20e,y	_check_handler: lda _special_handlers,y
.a1e4		c5 2e		cmp $2e		                cmp scratch+1
.a1e6		d0 07		bne $a1ef	                bne _next_handler
.a1e8		b9 0f a2	lda $a20f,y	                lda _special_handlers+1,y
.a1eb		c5 2f		cmp $2f		                cmp scratch+2
.a1ed		f0 0c		beq $a1fb	                beq _run_handler
.a1ef		88		dey		_next_handler:  dey
.a1f0		88		dey		                dey
.a1f1		88		dey		                dey
.a1f2		88		dey		                dey
.a1f3		10 ec		bpl $a1e1	                bpl _check_handler
.a1f5						_not_special:
.a1f5		20 45 a3	jsr $a345	                jsr disasm_jsr
.a1f8		4c 8c a2	jmp $a28c	                jmp _printing_done
.a1fb						_run_handler:
.a1fb		b9 10 a2	lda $a210,y	                lda _special_handlers+2,y
.a1fe		85 30		sta $30		                sta scratch+3
.a200		b9 11 a2	lda $a211,y	                lda _special_handlers+3,y
.a203		85 31		sta $31		                sta scratch+4
.a205		20 0b a2	jsr $a20b	                jsr _dispatch_handler
.a208		4c 8c a2	jmp $a28c	                jmp _printing_done
.a20b						_dispatch_handler:
.a20b		6c 30 00	jmp ($0030)	                jmp (scratch+3)
.a20e						_special_handlers:
>a20e		63 8b 27 a3			    .word literal_runtime,      disasm_literal
>a212		11 a1 d2 a2			    .word sliteral_runtime,     disasm_sliteral
>a216		56 8a 09 a3			    .word zero_branch_runtime,  disasm_0branch
>a21a		4c 8a 15 a3			    .word zero_test_runtime,    disasm_0test
>a21e		5e 86 1d a3			    .word do_runtime,           disasm_do
.a222						_end_handlers:
.a222						_not_jsr:
.a222		c9 4c		cmp #$4c	                cmp #OpJMP
.a224		d0 2c		bne $a252	                bne _not_jmp
.a226		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.a228		85 30		sta $30		                sta scratch+3
.a22a		a5 2f		lda $2f		                lda scratch+2
.a22c		85 31		sta $31		                sta scratch+4
.a22e		b2 30		lda ($30)	                lda (scratch+3)
.a230		c9 20		cmp #$20	                cmp #OpJSR ; check for JSR
.a232		d0 58		bne $a28c	                bne _printing_done
.a234		e6 30		inc $30		                inc scratch+3
.a236		d0 02		bne $a23a	                bne +
.a238		e6 31		inc $31		                inc scratch+4
.a23a						+
.a23a		b2 30		lda ($30)	                lda (scratch+3)
.a23c		c9 11		cmp #$11	                cmp #<sliteral_runtime
.a23e		d0 4c		bne $a28c	                bne _printing_done
.a240		e6 30		inc $30		                inc scratch+3
.a242		d0 02		bne $a246	                bne +
.a244		e6 31		inc $31		                inc scratch+4
.a246						+
.a246		b2 30		lda ($30)	                lda (scratch+3)
.a248		c9 a1		cmp #$a1	                cmp #>sliteral_runtime
.a24a		d0 40		bne $a28c	                bne _printing_done
.a24c		20 a8 a2	jsr $a2a8	                jsr disasm_sliteral_jump
.a24f		4c 8c a2	jmp $a28c	                jmp _printing_done
.a252						_not_jmp:
.a252		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a254		f0 06		beq $a25c	                beq _is_rel
.a256		29 1f		and #$1f	                and #$1F
.a258		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a25a		d0 30		bne $a28c	                bne _printing_done
.a25c						_is_rel:
.a25c		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a25e		ca		dex		                dex
.a25f		ca		dex		                dex
.a260		74 01		stz $01,x	                stz 1,x
.a262		a5 2e		lda $2e		                lda scratch+1
.a264		95 00		sta $00,x	                sta 0,x
.a266		10 04		bpl $a26c	                bpl +
.a268		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a26a		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a26c		38		sec		+               sec                 ; start counting from address after opcode
.a26d		75 04		adc $04,x	                adc 4,x
.a26f		95 00		sta $00,x	                sta 0,x
.a271		b5 01		lda $01,x	                lda 1,x
.a273		75 05		adc $05,x	                adc 5,x
.a275		95 01		sta $01,x	                sta 1,x
.a277		5a		phy		                phy                 ; save the direction indicator
.a278		ca		dex		                dex
.a279		ca		dex		                dex
.a27a		a9 09		lda #$09	                lda #9
.a27c		95 00		sta $00,x	                sta 0,x
.a27e		74 01		stz $01,x	                stz 1,x
.a280		20 0b 96	jsr $960b	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.a283		a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.a285		20 ac 87	jsr $87ac	                jsr emit_a
.a288		68		pla		                pla
.a289		20 ac 87	jsr $87ac	                jsr emit_a
.a28c						_printing_done:
.a28c		20 fa 84	jsr $84fa	                jsr xt_cr
.a28f		f6 02		inc $02,x	                inc 2,x
.a291		d0 02		bne $a295	                bne +
.a293		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.a295						+
.a295		20 e0 8d	jsr $8de0	                jsr xt_one_minus        ; ( addr+1 u-1 )
.a298		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a29a		15 01		ora $01,x	                ora 1,x
.a29c		f0 07		beq $a2a5	                beq _done
.a29e		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a2a0		30 03		bmi $a2a5	                bmi _done
.a2a2		4c 43 a1	jmp $a143	                jmp _byte_loop          ; out of range for BRA
.a2a5						_done:
.a2a5		4c c2 94	jmp $94c2	                jmp xt_two_drop         ; JSR/RTS
.a2a8						disasm_sliteral_jump:
.a2a8		20 4d 93	jsr $934d	                jsr xt_swap
.a2ab		ca		dex		                dex
.a2ac		ca		dex		                dex
.a2ad		a5 2e		lda $2e		                lda scratch+1
.a2af		95 00		sta $00,x	                sta 0,x
.a2b1		a5 2f		lda $2f		                lda scratch+2
.a2b3		95 01		sta $01,x	                sta 1,x
.a2b5		20 4d 93	jsr $934d	                jsr xt_swap
.a2b8		20 e7 8c	jsr $8ce7	                jsr xt_minus
.a2bb		20 e0 8d	jsr $8de0	                jsr xt_one_minus
.a2be		20 e7 8c	jsr $8ce7	                jsr xt_minus
.a2c1		ca		dex		                dex
.a2c2		ca		dex		                dex
.a2c3		a5 2e		lda $2e		                lda scratch+1
.a2c5		95 00		sta $00,x	                sta 0,x
.a2c7		a5 2f		lda $2f		                lda scratch+2
.a2c9		95 01		sta $01,x	                sta 1,x
.a2cb		20 e0 8d	jsr $8de0	                jsr xt_one_minus
.a2ce		20 4d 93	jsr $934d	                jsr xt_swap ; ( new_addr new_n )
.a2d1		60		rts		                rts
.a2d2						disasm_sliteral:
.a2d2		a9 53		lda #$53	                lda #'S'
.a2d4		20 ac 87	jsr $87ac	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.a2d7		a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.a2d9		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf
.a2dc		20 4d 93	jsr $934d	                jsr xt_swap             ; switch to (u addr)
.a2df		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.a2e2		20 42 87	jsr $8742	                jsr xt_dup
.a2e5		20 01 89	jsr $8901	                jsr xt_fetch
.a2e8		20 ff 95	jsr $95ff	                jsr xt_u_dot            ; Print the address of the string
.a2eb		20 57 9d	jsr $9d57	                jsr xt_two
.a2ee		20 56 8f	jsr $8f56	                jsr xt_plus
.a2f1		20 42 87	jsr $8742	                jsr xt_dup
.a2f4		20 b7 98	jsr $98b7	                jsr xt_question         ; Print the length of the string
.a2f7		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.a2fa		20 4d 93	jsr $934d	                jsr xt_swap            ; ( addr+4 u )
.a2fd		ca		dex		                dex
.a2fe		ca		dex		                dex
.a2ff		a9 04		lda #$04	                lda #4
.a301		95 00		sta $00,x	                sta 0,x
.a303		74 01		stz $01,x	                stz 1,x
.a305		20 e7 8c	jsr $8ce7	                jsr xt_minus            ; ( addr+4 u-4 )
.a308		60		rts		                rts
.a309						disasm_0branch:
.a309		a9 30		lda #$30	                lda #'0'
.a30b		20 ac 87	jsr $87ac	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.a30e						disasm_branch:
.a30e		a9 0e		lda #$0e	                lda #str_disasm_bra
.a310		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf ; "BRANCH "
.a313		80 17		bra $a32c	                bra disasm_print_literal
.a315						disasm_0test:
.a315		a9 0f		lda #$0f	                lda #str_disasm_0test
.a317		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf
.a31a		4c ac 87	jmp $87ac	                jmp emit_a
.a31d						disasm_do:
.a31d		a9 44		lda #$44	                lda #'D'
.a31f		20 ac 87	jsr $87ac	                jsr emit_a
.a322		a9 4f		lda #$4f	                lda #'O'
.a324		4c ac 87	jmp $87ac	                jmp emit_a
.a327						disasm_literal:
.a327		a9 0c		lda #$0c	                lda #str_disasm_lit
.a329		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf ; "LITERAL "
.a32c						disasm_print_literal:
.a32c		20 4d 93	jsr $934d	                jsr xt_swap ; switch to (u addr)
.a32f		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.a332		20 42 87	jsr $8742	                jsr xt_dup
.a335		20 b7 98	jsr $98b7	                jsr xt_question ; Print the value at the address
.a338		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.a33b		20 4d 93	jsr $934d	                jsr xt_swap ; (addr+2 u)
.a33e		20 e0 8d	jsr $8de0	                jsr xt_one_minus
.a341		20 e0 8d	jsr $8de0	                jsr xt_one_minus ; (addr+2 u-2)
.a344		60		rts		                rts
.a345						disasm_jsr:
.a345		ca		dex		                dex
.a346		ca		dex		                dex
.a347		a5 2e		lda $2e		                lda scratch+1
.a349		95 00		sta $00,x	                sta 0,x
.a34b		a5 2f		lda $2f		                lda scratch+2
.a34d		95 01		sta $01,x	                sta 1,x
.a34f		20 43 9b	jsr $9b43	                jsr xt_int_to_name
.a352		b5 00		lda $00,x	                lda 0,x
.a354		15 01		ora $01,x	                ora 1,x
.a356		f0 07		beq $a35f	                beq _disasm_no_nt
.a358		20 e6 9b	jsr $9be6	                jsr xt_name_to_string
.a35b		20 d4 95	jsr $95d4	                jsr xt_type
.a35e		60		rts		                rts
.a35f						_disasm_no_nt:
.a35f		20 3c 87	jsr $873c	                jsr xt_drop ; the 0 indicating no name token
.a362		ca		dex		                dex
.a363		ca		dex		                dex
.a364		a5 2e		lda $2e		                lda scratch+1
.a366		95 00		sta $00,x	                sta 0,x
.a368		a5 2f		lda $2f		                lda scratch+2
.a36a		95 01		sta $01,x	                sta 1,x
.a36c		ca		dex		                dex
.a36d		ca		dex		                dex
.a36e		a9 64		lda #$64	                lda #<underflow_1
.a370		95 00		sta $00,x	                sta 0,x
.a372		a9 d7		lda #$d7	                lda #>underflow_1
.a374		95 01		sta $01,x	                sta 1,x
.a376		20 a2 d6	jsr $d6a2	                jsr compare_16bit
.a379		f0 02		beq $a37d	                beq _disasm_jsr_uflow_check_upper
.a37b		b0 14		bcs $a391	                bcs _disasm_jsr_unknown
.a37d						_disasm_jsr_uflow_check_upper:
.a37d		a9 73		lda #$73	                lda #<underflow_4
.a37f		95 00		sta $00,x	                sta 0,x
.a381		a9 d7		lda #$d7	                lda #>underflow_4
.a383		95 01		sta $01,x	                sta 1,x
.a385		20 a2 d6	jsr $d6a2	                jsr compare_16bit
.a388		f0 02		beq $a38c	                beq _disasm_jsr_soc
.a38a		90 05		bcc $a391	                bcc _disasm_jsr_unknown
.a38c						_disasm_jsr_soc:
.a38c		a9 0d		lda #$0d	                lda #str_disasm_sdc
.a38e		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.a391						_disasm_jsr_unknown:
.a391		20 c2 94	jsr $94c2	                jsr xt_two_drop
.a394		60		rts		                rts
.a395						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a395						assembler:
.a395						xt_asm_adc_h:
.a395		a9 69		lda #$69	                lda #$69
.a397		4c f0 a6	jmp $a6f0	                jmp asm_common
.a39a						z_asm_adc_h:
.a39a						xt_asm_adc_x:
.a39a		a9 7d		lda #$7d	                lda #$7D
.a39c		4c f0 a6	jmp $a6f0	                jmp asm_common
.a39f						z_asm_adc_x:
.a39f						xt_asm_adc_y:
.a39f		a9 79		lda #$79	                lda #$79
.a3a1		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3a4						z_asm_adc_y:
.a3a4						xt_asm_adc_z:
.a3a4		a9 65		lda #$65	                lda #$65
.a3a6		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3a9						z_asm_adc_z:
.a3a9						xt_asm_adc_zi:
.a3a9		a9 72		lda #$72	                lda #$72
.a3ab		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3ae						z_asm_adc_zi:
.a3ae						xt_asm_adc_ziy:
.a3ae		a9 71		lda #$71	                lda #$71
.a3b0		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3b3						z_asm_adc_ziy:
.a3b3						xt_asm_adc_zx:
.a3b3		a9 75		lda #$75	                lda #$75
.a3b5		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3b8						z_asm_adc_zx:
.a3b8						xt_asm_adc_zxi:
.a3b8		a9 61		lda #$61	                lda #$61
.a3ba		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3bd						z_asm_adc_zxi:
.a3bd						xt_asm_and:
.a3bd		a9 2d		lda #$2d	                lda #$2D
.a3bf		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3c2						z_asm_and:
.a3c2						xt_asm_and_h:
.a3c2		a9 29		lda #$29	                lda #$29
.a3c4		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3c7						z_asm_and_h:
.a3c7						xt_asm_and_x:
.a3c7		a9 3d		lda #$3d	                lda #$3D
.a3c9		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3cc						z_asm_and_x:
.a3cc						xt_asm_and_y:
.a3cc		a9 39		lda #$39	                lda #$39
.a3ce		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3d1						z_asm_and_y:
.a3d1						xt_asm_and_z:
.a3d1		a9 25		lda #$25	                lda #$25
.a3d3		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3d6						z_asm_and_z:
.a3d6						xt_asm_and_zi:
.a3d6		a9 32		lda #$32	                lda #$32
.a3d8		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3db						z_asm_and_zi:
.a3db						xt_asm_and_ziy:
.a3db		a9 31		lda #$31	                lda #$31
.a3dd		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3e0						z_asm_and_ziy:
.a3e0						xt_asm_and_zx:
.a3e0		a9 35		lda #$35	                lda #$35
.a3e2		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3e5						z_asm_and_zx:
.a3e5						xt_asm_and_zxi:
.a3e5		a9 21		lda #$21	                lda #$21
.a3e7		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3ea						z_asm_and_zxi:
.a3ea						xt_asm_asl:
.a3ea		a9 0e		lda #$0e	                lda #$0E
.a3ec		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3ef						z_asm_asl:
.a3ef						xt_asm_asl_a:
.a3ef		a9 0a		lda #$0a	                lda #$0A
.a3f1		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3f4						z_asm_asl_a:
.a3f4						xt_asm_asl_x:
.a3f4		a9 1e		lda #$1e	                lda #$1E
.a3f6		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3f9						z_asm_asl_x:
.a3f9						xt_asm_asl_z:
.a3f9		a9 06		lda #$06	                lda #$06
.a3fb		4c f0 a6	jmp $a6f0	                jmp asm_common
.a3fe						z_asm_asl_z:
.a3fe						xt_asm_asl_zx:
.a3fe		a9 16		lda #$16	                lda #$16
.a400		4c f0 a6	jmp $a6f0	                jmp asm_common
.a403						z_asm_asl_zx:
.a403						xt_asm_bcc:
.a403		a9 90		lda #$90	                lda #$90
.a405		4c f0 a6	jmp $a6f0	                jmp asm_common
.a408						z_asm_bcc:
.a408						xt_asm_bcs:
.a408		a9 b0		lda #$b0	                lda #$B0
.a40a		a0 02		ldy #$02	                ldy #2
.a40c		4c f0 a6	jmp $a6f0	                jmp asm_common
.a40f						z_asm_bcs:
.a40f						xt_asm_beq:
.a40f		a9 f0		lda #$f0	                lda #$F0
.a411		4c f0 a6	jmp $a6f0	                jmp asm_common
.a414						z_asm_beq:
.a414						xt_asm_bit:
.a414		a9 2c		lda #$2c	                lda #$2C
.a416		4c f0 a6	jmp $a6f0	                jmp asm_common
.a419						z_asm_bit:
.a419						xt_asm_bit_h:
.a419		a9 89		lda #$89	                lda #$89
.a41b		4c f0 a6	jmp $a6f0	                jmp asm_common
.a41e						z_asm_bit_h:
.a41e						xt_asm_bit_x:
.a41e		a9 3c		lda #$3c	                lda #$3C
.a420		4c f0 a6	jmp $a6f0	                jmp asm_common
.a423						z_asm_bit_x:
.a423						xt_asm_bit_z:
.a423		a9 24		lda #$24	                lda #$24
.a425		4c f0 a6	jmp $a6f0	                jmp asm_common
.a428						z_asm_bit_z:
.a428						xt_asm_bit_zx:
.a428		a9 34		lda #$34	                lda #$34
.a42a		4c f0 a6	jmp $a6f0	                jmp asm_common
.a42d						z_asm_bit_zx:
.a42d						xt_asm_bmi:
.a42d		a9 30		lda #$30	                lda #$30
.a42f		4c f0 a6	jmp $a6f0	                jmp asm_common
.a432						z_asm_bmi:
.a432						xt_asm_bne:
.a432		a9 d0		lda #$d0	                lda #$D0
.a434		4c f0 a6	jmp $a6f0	                jmp asm_common
.a437						z_asm_bne:
.a437						xt_asm_bpl:
.a437		a9 10		lda #$10	                lda #$10
.a439		4c f0 a6	jmp $a6f0	                jmp asm_common
.a43c						z_asm_bpl:
.a43c						xt_asm_bra:
.a43c		a9 80		lda #$80	                lda #$80
.a43e		4c f0 a6	jmp $a6f0	                jmp asm_common
.a441						z_asm_bra:
.a441						xt_asm_brk:
.a441		a9 00		lda #$00	                lda #$00
.a443		4c f0 a6	jmp $a6f0	                jmp asm_common
.a446						z_asm_brk:
.a446						xt_asm_bvc:
.a446		a9 50		lda #$50	                lda #$50
.a448		4c f0 a6	jmp $a6f0	                jmp asm_common
.a44b						z_asm_bvc:
.a44b						xt_asm_bvs:
.a44b		a9 70		lda #$70	                lda #$70
.a44d		4c f0 a6	jmp $a6f0	                jmp asm_common
.a450						z_asm_bvs:
.a450						xt_asm_clc:
.a450		a9 18		lda #$18	                lda #$18
.a452		4c f0 a6	jmp $a6f0	                jmp asm_common
.a455						z_asm_clc:
.a455						xt_asm_cld:
.a455		a9 d8		lda #$d8	                lda #$D8
.a457		4c f0 a6	jmp $a6f0	                jmp asm_common
.a45a						z_asm_cld:
.a45a						xt_asm_cli:
.a45a		a9 58		lda #$58	                lda #$58
.a45c		4c f0 a6	jmp $a6f0	                jmp asm_common
.a45f						z_asm_cli:
.a45f						xt_asm_clv:
.a45f		a9 b8		lda #$b8	                lda #$B8
.a461		4c f0 a6	jmp $a6f0	                jmp asm_common
.a464						z_asm_clv:
.a464						xt_asm_cmp:
.a464		a9 cd		lda #$cd	                lda #$CD
.a466		4c f0 a6	jmp $a6f0	                jmp asm_common
.a469						z_asm_cmp:
.a469						xt_asm_cmp_h:
.a469		a9 c9		lda #$c9	                lda #$C9
.a46b		4c f0 a6	jmp $a6f0	                jmp asm_common
.a46e						z_asm_cmp_h:
.a46e						xt_asm_cmp_x:
.a46e		a9 dd		lda #$dd	                lda #$DD
.a470		4c f0 a6	jmp $a6f0	                jmp asm_common
.a473						z_asm_cmp_x:
.a473						xt_asm_cmp_y:
.a473		a9 d9		lda #$d9	                lda #$D9
.a475		4c f0 a6	jmp $a6f0	                jmp asm_common
.a478						z_asm_cmp_y:
.a478						xt_asm_cmp_z:
.a478		a9 c5		lda #$c5	                lda #$C5
.a47a		4c f0 a6	jmp $a6f0	                jmp asm_common
.a47d						z_asm_cmp_z:
.a47d						xt_asm_cmp_zi:
.a47d		a9 d2		lda #$d2	                lda #$D2
.a47f		4c f0 a6	jmp $a6f0	                jmp asm_common
.a482						z_asm_cmp_zi:
.a482						xt_asm_cmp_ziy:
.a482		a9 d1		lda #$d1	                lda #$D1
.a484		4c f0 a6	jmp $a6f0	                jmp asm_common
.a487						z_asm_cmp_ziy:
.a487						xt_asm_cmp_zx:
.a487		a9 d5		lda #$d5	                lda #$D5
.a489		4c f0 a6	jmp $a6f0	                jmp asm_common
.a48c						z_asm_cmp_zx:
.a48c						xt_asm_cmp_zxi:
.a48c		a9 c1		lda #$c1	                lda #$C1
.a48e		4c f0 a6	jmp $a6f0	                jmp asm_common
.a491						z_asm_cmp_zxi:
.a491						xt_asm_cpx:
.a491		a9 ec		lda #$ec	                lda #$EC
.a493		4c f0 a6	jmp $a6f0	                jmp asm_common
.a496						z_asm_cpx:
.a496						xt_asm_cpx_h:
.a496		a9 e0		lda #$e0	                lda #$E0
.a498		4c f0 a6	jmp $a6f0	                jmp asm_common
.a49b						z_asm_cpx_h:
.a49b						xt_asm_cpx_z:
.a49b		a9 e4		lda #$e4	                lda #$E4
.a49d		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4a0						z_asm_cpx_z:
.a4a0						xt_asm_cpy:
.a4a0		a9 cc		lda #$cc	                lda #$CC
.a4a2		a0 03		ldy #$03	                ldy #3
.a4a4		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4a7						z_asm_cpy:
.a4a7						xt_asm_cpy_h:
.a4a7		a9 c0		lda #$c0	                lda #$C0
.a4a9		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4ac						z_asm_cpy_h:
.a4ac						xt_asm_cpy_z:
.a4ac		a9 c4		lda #$c4	                lda #$C4
.a4ae		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4b1						z_asm_cpy_z:
.a4b1						xt_asm_dec:
.a4b1		a9 ce		lda #$ce	                lda #$CE
.a4b3		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4b6						z_asm_dec:
.a4b6						xt_asm_dec_a:
.a4b6		a9 3a		lda #$3a	                lda #$3A
.a4b8		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4bb						z_asm_dec_a:
.a4bb						xt_asm_dec_x:
.a4bb		a9 de		lda #$de	                lda #$DE
.a4bd		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4c0						z_asm_dec_x:
.a4c0						xt_asm_dec_z:
.a4c0		a9 c6		lda #$c6	                lda #$C6
.a4c2		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4c5						z_asm_dec_z:
.a4c5						xt_asm_dec_zx:
.a4c5		a9 d6		lda #$d6	                lda #$D6
.a4c7		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4ca						z_asm_dec_zx:
.a4ca						xt_asm_dex:
.a4ca		a9 ca		lda #$ca	                lda #$CA
.a4cc		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4cf						z_asm_dex:
.a4cf						xt_asm_dey:
.a4cf		a9 88		lda #$88	                lda #$88
.a4d1		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4d4						z_asm_dey:
.a4d4						xt_asm_eor:
.a4d4		a9 4d		lda #$4d	                lda #$4D
.a4d6		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4d9						z_asm_eor:
.a4d9						xt_asm_eor_h:
.a4d9		a9 49		lda #$49	                lda #$49
.a4db		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4de						z_asm_eor_h:
.a4de						xt_asm_eor_x:
.a4de		a9 5d		lda #$5d	                lda #$5D
.a4e0		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4e3						z_asm_eor_x:
.a4e3						xt_asm_eor_y:
.a4e3		a9 59		lda #$59	                lda #$59
.a4e5		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4e8						z_asm_eor_y:
.a4e8						xt_asm_eor_z:
.a4e8		a9 45		lda #$45	                lda #$45
.a4ea		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4ed						z_asm_eor_z:
.a4ed						xt_asm_eor_zi:
.a4ed		a9 52		lda #$52	                lda #$52
.a4ef		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4f2						z_asm_eor_zi:
.a4f2						xt_asm_eor_ziy:
.a4f2		a9 51		lda #$51	                lda #$51
.a4f4		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4f7						z_asm_eor_ziy:
.a4f7						xt_asm_eor_zx:
.a4f7		a9 55		lda #$55	                lda #$55
.a4f9		4c f0 a6	jmp $a6f0	                jmp asm_common
.a4fc						z_asm_eor_zx:
.a4fc						xt_asm_eor_zxi:
.a4fc		a9 41		lda #$41	                lda #$41
.a4fe		4c f0 a6	jmp $a6f0	                jmp asm_common
.a501						z_asm_eor_zxi:
.a501						xt_asm_inc:
.a501		a9 ee		lda #$ee	                lda #$EE
.a503		4c f0 a6	jmp $a6f0	                jmp asm_common
.a506						z_asm_inc:
.a506						xt_asm_inc_a:
.a506		a9 1a		lda #$1a	                lda #$1A
.a508		4c f0 a6	jmp $a6f0	                jmp asm_common
.a50b						z_asm_inc_a:
.a50b						xt_asm_inc_x:
.a50b		a9 fe		lda #$fe	                lda #$FE
.a50d		4c f0 a6	jmp $a6f0	                jmp asm_common
.a510						z_asm_inc_x:
.a510						xt_asm_inc_z:
.a510		a9 e6		lda #$e6	                lda #$E6
.a512		4c f0 a6	jmp $a6f0	                jmp asm_common
.a515						z_asm_inc_z:
.a515						xt_asm_inc_zx:
.a515		a9 f6		lda #$f6	                lda #$F6
.a517		4c f0 a6	jmp $a6f0	                jmp asm_common
.a51a						z_asm_inc_zx:
.a51a						xt_asm_inx:
.a51a		a9 e8		lda #$e8	                lda #$E8
.a51c		4c f0 a6	jmp $a6f0	                jmp asm_common
.a51f						z_asm_inx:
.a51f						xt_asm_iny:
.a51f		a9 c8		lda #$c8	                lda #$C8
.a521		4c f0 a6	jmp $a6f0	                jmp asm_common
.a524						z_asm_iny:
.a524						xt_asm_jmp:
.a524		a9 4c		lda #$4c	                lda #$4C
.a526		4c f0 a6	jmp $a6f0	                jmp asm_common
.a529						z_asm_jmp:
.a529						xt_asm_jmp_i:
.a529		a9 6c		lda #$6c	                lda #$6C
.a52b		4c f0 a6	jmp $a6f0	                jmp asm_common
.a52e						z_asm_jmp_i:
.a52e						xt_asm_jmp_xi:
.a52e		a9 7c		lda #$7c	                lda #$7C
.a530		4c f0 a6	jmp $a6f0	                jmp asm_common
.a533						z_asm_jmp_xi:
.a533						xt_asm_jsr:
.a533		a9 20		lda #$20	                lda #$20
.a535		4c f0 a6	jmp $a6f0	                jmp asm_common
.a538						z_asm_jsr:
.a538						xt_asm_lda:
.a538		a9 ad		lda #$ad	                lda #$AD
.a53a		4c f0 a6	jmp $a6f0	                jmp asm_common
.a53d						z_asm_lda:
.a53d						xt_asm_lda_h:
.a53d		a9 a9		lda #$a9	                lda #$A9
.a53f		4c f0 a6	jmp $a6f0	                jmp asm_common
.a542						z_asm_lda_h:
.a542						xt_asm_lda_x:
.a542		a9 bd		lda #$bd	                lda #$BD
.a544		4c f0 a6	jmp $a6f0	                jmp asm_common
.a547						z_asm_lda_x:
.a547						xt_asm_lda_y:
.a547		a9 b9		lda #$b9	                lda #$B9
.a549		4c f0 a6	jmp $a6f0	                jmp asm_common
.a54c						z_asm_lda_y:
.a54c						xt_asm_lda_z:
.a54c		a9 a5		lda #$a5	                lda #$A5
.a54e		4c f0 a6	jmp $a6f0	                jmp asm_common
.a551						z_asm_lda_z:
.a551						xt_asm_lda_zi:
.a551		a9 b2		lda #$b2	                lda #$B2
.a553		4c f0 a6	jmp $a6f0	                jmp asm_common
.a556						z_asm_lda_zi:
.a556						xt_asm_lda_ziy:
.a556		a9 b1		lda #$b1	                lda #$B1
.a558		4c f0 a6	jmp $a6f0	                jmp asm_common
.a55b						z_asm_lda_ziy:
.a55b						xt_asm_lda_zx:
.a55b		a9 b5		lda #$b5	                lda #$B5
.a55d		4c f0 a6	jmp $a6f0	                jmp asm_common
.a560						z_asm_lda_zx:
.a560						xt_asm_lda_zxi:
.a560		a9 a1		lda #$a1	                lda #$A1
.a562		4c f0 a6	jmp $a6f0	                jmp asm_common
.a565						z_asm_lda_zxi:
.a565						xt_asm_ldx:
.a565		a9 ae		lda #$ae	                lda #$AE
.a567		4c f0 a6	jmp $a6f0	                jmp asm_common
.a56a						z_asm_ldx:
.a56a						xt_asm_ldx_h:
.a56a		a9 a2		lda #$a2	                lda #$A2
.a56c		4c f0 a6	jmp $a6f0	                jmp asm_common
.a56f						z_asm_ldx_h:
.a56f						xt_asm_ldx_y:
.a56f		a9 be		lda #$be	                lda #$BE
.a571		4c f0 a6	jmp $a6f0	                jmp asm_common
.a574						z_asm_ldx_y:
.a574						xt_asm_ldx_z:
.a574		a9 a6		lda #$a6	                lda #$A6
.a576		4c f0 a6	jmp $a6f0	                jmp asm_common
.a579						z_asm_ldx_z:
.a579						xt_asm_ldx_zy:
.a579		a9 b6		lda #$b6	                lda #$B6
.a57b		4c f0 a6	jmp $a6f0	                jmp asm_common
.a57e						z_asm_ldx_zy:
.a57e						xt_asm_ldy:
.a57e		a9 ac		lda #$ac	                lda #$AC
.a580		4c f0 a6	jmp $a6f0	                jmp asm_common
.a583						z_asm_ldy:
.a583						xt_asm_ldy_h:
.a583		a9 a0		lda #$a0	                lda #$A0
.a585		4c f0 a6	jmp $a6f0	                jmp asm_common
.a588						z_asm_ldy_h:
.a588						xt_asm_ldy_x:
.a588		a9 bc		lda #$bc	                lda #$BC
.a58a		4c f0 a6	jmp $a6f0	                jmp asm_common
.a58d						z_asm_ldy_x:
.a58d						xt_asm_ldy_z:
.a58d		a9 a4		lda #$a4	                lda #$A4
.a58f		4c f0 a6	jmp $a6f0	                jmp asm_common
.a592						z_asm_ldy_z:
.a592						xt_asm_ldy_zx:
.a592		a9 b4		lda #$b4	                lda #$B4
.a594		4c f0 a6	jmp $a6f0	                jmp asm_common
.a597						z_asm_ldy_zx:
.a597						xt_asm_lsr:
.a597		a9 4e		lda #$4e	                lda #$4E
.a599		4c f0 a6	jmp $a6f0	                jmp asm_common
.a59c						z_asm_lsr:
.a59c						xt_asm_lsr_a:
.a59c		a9 4a		lda #$4a	                lda #$4A
.a59e		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5a1						z_asm_lsr_a:
.a5a1						xt_asm_lsr_x:
.a5a1		a9 5e		lda #$5e	                lda #$5E
.a5a3		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5a6						z_asm_lsr_x:
.a5a6						xt_asm_lsr_z:
.a5a6		a9 46		lda #$46	                lda #$46
.a5a8		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5ab						z_asm_lsr_z:
.a5ab						xt_asm_lsr_zx:
.a5ab		a9 56		lda #$56	                lda #$56
.a5ad		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5b0						z_asm_lsr_zx:
.a5b0						xt_asm_nop:
.a5b0		a9 ea		lda #$ea	                lda #$EA
.a5b2		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5b5						z_asm_nop:
.a5b5						xt_asm_ora:
.a5b5		a9 0d		lda #$0d	                lda #$0D
.a5b7		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5ba						z_asm_ora:
.a5ba						xt_asm_ora_h:
.a5ba		a9 09		lda #$09	                lda #$09
.a5bc		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5bf						z_asm_ora_h:
.a5bf						xt_asm_ora_x:
.a5bf		a9 1d		lda #$1d	                lda #$1D
.a5c1		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5c4						z_asm_ora_x:
.a5c4						xt_asm_ora_y:
.a5c4		a9 19		lda #$19	                lda #$19
.a5c6		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5c9						z_asm_ora_y:
.a5c9						xt_asm_ora_z:
.a5c9		a9 05		lda #$05	                lda #$05
.a5cb		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5ce						z_asm_ora_z:
.a5ce						xt_asm_ora_zi:
.a5ce		a9 12		lda #$12	                lda #$12
.a5d0		a0 02		ldy #$02	                ldy #2
.a5d2		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5d5						z_asm_ora_zi:
.a5d5						xt_asm_ora_ziy:
.a5d5		a9 11		lda #$11	                lda #$11
.a5d7		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5da						z_asm_ora_ziy:
.a5da						xt_asm_ora_zx:
.a5da		a9 15		lda #$15	                lda #$15
.a5dc		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5df						z_asm_ora_zx:
.a5df						xt_asm_ora_zxi:
.a5df		a9 01		lda #$01	                lda #$01
.a5e1		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5e4						z_asm_ora_zxi:
.a5e4						xt_asm_pha:
.a5e4		a9 48		lda #$48	                lda #$48
.a5e6		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5e9						z_asm_pha:
.a5e9						xt_asm_php:
.a5e9		a9 08		lda #$08	                lda #$08
.a5eb		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5ee						z_asm_php:
.a5ee						xt_asm_phx:
.a5ee		a9 da		lda #$da	                lda #$DA
.a5f0		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5f3						z_asm_phx:
.a5f3						xt_asm_phy:
.a5f3		a9 5a		lda #$5a	                lda #$5A
.a5f5		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5f8						z_asm_phy:
.a5f8						xt_asm_pla:
.a5f8		a9 68		lda #$68	                lda #$68
.a5fa		4c f0 a6	jmp $a6f0	                jmp asm_common
.a5fd						z_asm_pla:
.a5fd						xt_asm_plp:
.a5fd		a9 28		lda #$28	                lda #$28
.a5ff		4c f0 a6	jmp $a6f0	                jmp asm_common
.a602						z_asm_plp:
.a602						xt_asm_plx:
.a602		a9 fa		lda #$fa	                lda #$FA
.a604		4c f0 a6	jmp $a6f0	                jmp asm_common
.a607						z_asm_plx:
.a607						xt_asm_ply:
.a607		a9 7a		lda #$7a	                lda #$7A
.a609		4c f0 a6	jmp $a6f0	                jmp asm_common
.a60c						z_asm_ply:
.a60c						xt_asm_rol:
.a60c		a9 2e		lda #$2e	                lda #$2E
.a60e		4c f0 a6	jmp $a6f0	                jmp asm_common
.a611						z_asm_rol:
.a611						xt_asm_rol_a:
.a611		a9 2a		lda #$2a	                lda #$2A
.a613		4c f0 a6	jmp $a6f0	                jmp asm_common
.a616						z_asm_rol_a:
.a616						xt_asm_rol_x:
.a616		a9 3e		lda #$3e	                lda #$3E
.a618		4c f0 a6	jmp $a6f0	                jmp asm_common
.a61b						z_asm_rol_x:
.a61b						xt_asm_rol_z:
.a61b		a9 26		lda #$26	                lda #$26
.a61d		4c f0 a6	jmp $a6f0	                jmp asm_common
.a620						z_asm_rol_z:
.a620						xt_asm_rol_zx:
.a620		a9 36		lda #$36	                lda #$36
.a622		4c f0 a6	jmp $a6f0	                jmp asm_common
.a625						z_asm_rol_zx:
.a625						xt_asm_ror:
.a625		a9 6e		lda #$6e	                lda #$6E
.a627		4c f0 a6	jmp $a6f0	                jmp asm_common
.a62a						z_asm_ror:
.a62a						xt_asm_ror_a:
.a62a		a9 6a		lda #$6a	                lda #$6A
.a62c		4c f0 a6	jmp $a6f0	                jmp asm_common
.a62f						z_asm_ror_a:
.a62f						xt_asm_ror_x:
.a62f		a9 7e		lda #$7e	                lda #$7E
.a631		4c f0 a6	jmp $a6f0	                jmp asm_common
.a634						z_asm_ror_x:
.a634						xt_asm_ror_z:
.a634		a9 66		lda #$66	                lda #$66
.a636		4c f0 a6	jmp $a6f0	                jmp asm_common
.a639						z_asm_ror_z:
.a639						xt_asm_ror_zx:
.a639		a9 76		lda #$76	                lda #$76
.a63b		4c f0 a6	jmp $a6f0	                jmp asm_common
.a63e						z_asm_ror_zx:
.a63e						xt_asm_rti:
.a63e		a9 40		lda #$40	                lda #$40
.a640		4c f0 a6	jmp $a6f0	                jmp asm_common
.a643						z_asm_rti:
.a643						xt_asm_rts:
.a643		a9 60		lda #$60	                lda #$60
.a645		4c f0 a6	jmp $a6f0	                jmp asm_common
.a648						z_asm_rts:
.a648						xt_asm_sbc:
.a648		a9 ed		lda #$ed	                lda #$ED
.a64a		4c f0 a6	jmp $a6f0	                jmp asm_common
.a64d						z_asm_sbc:
.a64d						xt_asm_sbc_h:
.a64d		a9 e9		lda #$e9	                lda #$E9
.a64f		4c f0 a6	jmp $a6f0	                jmp asm_common
.a652						z_asm_sbc_h:
.a652						xt_asm_sbc_x:
.a652		a9 fd		lda #$fd	                lda #$FD
.a654		4c f0 a6	jmp $a6f0	                jmp asm_common
.a657						z_asm_sbc_x:
.a657						xt_asm_sbc_y:
.a657		a9 f9		lda #$f9	                lda #$F9
.a659		4c f0 a6	jmp $a6f0	                jmp asm_common
.a65c						z_asm_sbc_y:
.a65c						xt_asm_sbc_z:
.a65c		a9 e5		lda #$e5	                lda #$E5
.a65e		4c f0 a6	jmp $a6f0	                jmp asm_common
.a661						z_asm_sbc_z:
.a661						xt_asm_sbc_zi:
.a661		a9 f2		lda #$f2	                lda #$F2
.a663		4c f0 a6	jmp $a6f0	                jmp asm_common
.a666						z_asm_sbc_zi:
.a666						xt_asm_sbc_ziy:
.a666		a9 f1		lda #$f1	                lda #$F1
.a668		4c f0 a6	jmp $a6f0	                jmp asm_common
.a66b						z_asm_sbc_ziy:
.a66b						xt_asm_sbc_zx:
.a66b		a9 f5		lda #$f5	                lda #$F5
.a66d		4c f0 a6	jmp $a6f0	                jmp asm_common
.a670						z_asm_sbc_zx:
.a670						xt_asm_sbc_zxi:
.a670		a9 e1		lda #$e1	                lda #$E1
.a672		80 7c		bra $a6f0	                bra asm_common  ; <-- limit for BRA instead of JMP
.a674						z_asm_sbc_zxi:
.a674						xt_asm_sec:
.a674		a9 38		lda #$38	                lda #$38
.a676		80 78		bra $a6f0	                bra asm_common
.a678						z_asm_sec:
.a678						xt_asm_sed:
.a678		a9 f8		lda #$f8	                lda #$F8
.a67a		80 74		bra $a6f0	                bra asm_common
.a67c						z_asm_sed:
.a67c						xt_asm_sei:
.a67c		a9 78		lda #$78	                lda #$78
.a67e		80 70		bra $a6f0	                bra asm_common
.a680						z_asm_sei:
.a680						xt_asm_sta:
.a680		a9 8d		lda #$8d	                lda #$8D
.a682		80 6c		bra $a6f0	                bra asm_common
.a684						z_asm_sta:
.a684						xt_asm_sta_x:
.a684		a9 9d		lda #$9d	                lda #$9D
.a686		80 68		bra $a6f0	                bra asm_common
.a688						z_asm_sta_x:
.a688						xt_asm_sta_y:
.a688		a9 99		lda #$99	                lda #$99
.a68a		80 64		bra $a6f0	                bra asm_common
.a68c						z_asm_sta_y:
.a68c						xt_asm_sta_z:
.a68c		a9 85		lda #$85	                lda #$85
.a68e		80 60		bra $a6f0	                bra asm_common
.a690						z_asm_sta_z:
.a690						xt_asm_sta_zi:
.a690		a9 92		lda #$92	                lda #$92
.a692		80 5c		bra $a6f0	                bra asm_common
.a694						z_asm_sta_zi:
.a694						xt_asm_sta_ziy:
.a694		a9 91		lda #$91	                lda #$91
.a696		80 58		bra $a6f0	                bra asm_common
.a698						z_asm_sta_ziy:
.a698						xt_asm_sta_zx:
.a698		a9 95		lda #$95	                lda #$95
.a69a		80 54		bra $a6f0	                bra asm_common
.a69c						z_asm_sta_zx:
.a69c						xt_asm_sta_zxi:
.a69c		a9 81		lda #$81	                lda #$81
.a69e		80 50		bra $a6f0	                bra asm_common
.a6a0						z_asm_sta_zxi:
.a6a0						xt_asm_stx:
.a6a0		a9 8e		lda #$8e	                lda #$8E
.a6a2		80 4c		bra $a6f0	                bra asm_common
.a6a4						z_asm_stx:
.a6a4						xt_asm_stx_z:
.a6a4		a9 86		lda #$86	                lda #$86
.a6a6		80 48		bra $a6f0	                bra asm_common
.a6a8						z_asm_stx_z:
.a6a8						xt_asm_stx_zy:
.a6a8		a9 96		lda #$96	                lda #$96
.a6aa		80 44		bra $a6f0	                bra asm_common
.a6ac						z_asm_stx_zy:
.a6ac						xt_asm_sty:
.a6ac		a9 8c		lda #$8c	                lda #$8C
.a6ae		80 40		bra $a6f0	                bra asm_common
.a6b0						z_asm_sty:
.a6b0						xt_asm_sty_z:
.a6b0		a9 84		lda #$84	                lda #$84
.a6b2		80 3c		bra $a6f0	                bra asm_common
.a6b4						z_asm_sty_z:
.a6b4						xt_asm_sty_zx:
.a6b4		a9 94		lda #$94	                lda #$94
.a6b6		80 38		bra $a6f0	                bra asm_common
.a6b8						z_asm_sty_zx:
.a6b8						xt_asm_stz:
.a6b8		a9 9c		lda #$9c	                lda #$9C
.a6ba		80 34		bra $a6f0	                bra asm_common
.a6bc						z_asm_stz:
.a6bc						xt_asm_stz_x:
.a6bc		a9 9e		lda #$9e	                lda #$9E
.a6be		80 30		bra $a6f0	                bra asm_common
.a6c0						z_asm_stz_x:
.a6c0						xt_asm_stz_z:
.a6c0		a9 64		lda #$64	                lda #$64
.a6c2		80 2c		bra $a6f0	                bra asm_common
.a6c4						z_asm_stz_z:
.a6c4						xt_asm_stz_zx:
.a6c4		a9 74		lda #$74	                lda #$74
.a6c6		80 28		bra $a6f0	                bra asm_common
.a6c8						z_asm_stz_zx:
.a6c8						xt_asm_tax:
.a6c8		a9 aa		lda #$aa	                lda #$AA
.a6ca		80 24		bra $a6f0	                bra asm_common
.a6cc						z_asm_tax:
.a6cc						xt_asm_tay:
.a6cc		a9 a8		lda #$a8	                lda #$A8
.a6ce		80 20		bra $a6f0	                bra asm_common
.a6d0						z_asm_tay:
.a6d0						xt_asm_trb:
.a6d0		a9 1c		lda #$1c	                lda #$1C
.a6d2		80 1c		bra $a6f0	                bra asm_common
.a6d4						z_asm_trb:
.a6d4						xt_asm_trb_z:
.a6d4		a9 14		lda #$14	                lda #$14
.a6d6		80 18		bra $a6f0	                bra asm_common
.a6d8						z_asm_trb_z:
.a6d8						xt_asm_tsb:
.a6d8		a9 0c		lda #$0c	                lda #$0C
.a6da		80 14		bra $a6f0	                bra asm_common
.a6dc						z_asm_tsb:
.a6dc						xt_asm_tsb_z:
.a6dc		a9 04		lda #$04	                lda #$04
.a6de		80 10		bra $a6f0	                bra asm_common
.a6e0						z_asm_tsb_z:
.a6e0						xt_asm_tsx:
.a6e0		a9 ba		lda #$ba	                lda #$BA
.a6e2		80 0c		bra $a6f0	                bra asm_common
.a6e4						z_asm_tsx:
.a6e4						xt_asm_txa:
.a6e4		a9 8a		lda #$8a	                lda #$8A
.a6e6		80 08		bra $a6f0	                bra asm_common
.a6e8						z_asm_txa:
.a6e8						xt_asm_txs:
.a6e8		a9 9a		lda #$9a	                lda #$9A
.a6ea		80 04		bra $a6f0	                bra asm_common
.a6ec						z_asm_txs:
.a6ec						xt_asm_tya:
.a6ec		a9 98		lda #$98	                lda #$98
.a6ee		80 00		bra $a6f0	                bra asm_common
.a6f0						z_asm_tya:
.a6f0						asm_common:
.a6f0		a8		tay		                tay
.a6f1		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.a6f4		a9 64		lda #$64	                lda #<oc_index_table
.a6f6		85 27		sta $27		                sta tmp2
.a6f8		a9 b3		lda #$b3	                lda #>oc_index_table
.a6fa		85 28		sta $28		                sta tmp2+1
.a6fc		98		tya		                tya             ; retrieve opcode
.a6fd		0a		asl a		                asl             ; times two for offset
.a6fe		90 02		bcc $a702	                bcc +
.a700		e6 28		inc $28		                inc tmp2+1
.a702						+
.a702		a8		tay		                tay             ; use Y as the index
.a703		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a705		85 29		sta $29		                sta tmp3
.a707		c8		iny		                iny
.a708		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a70a		85 2a		sta $2a		                sta tmp3+1
.a70c		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a70e		2a		rol a		                rol
.a70f		2a		rol a		                rol
.a710		2a		rol a		                rol             ; Three times because we go through Carry
.a711		29 03		and #$03	                and #%00000011
.a713		a8		tay		                tay
.a714		88		dey		                dey
.a715		f0 12		beq $a729	                beq _done
.a717		20 64 d7	jsr $d764	                jsr underflow_1
.a71a		b5 00		lda $00,x	                lda 0,x
.a71c		20 9e d5	jsr $d59e	                jsr cmpl_byte_a      ; does not use Y
.a71f		88		dey		                dey
.a720		f0 05		beq $a727	                beq _done_drop
.a722		b5 01		lda $01,x	                lda 1,x
.a724		20 9e d5	jsr $d59e	                jsr cmpl_byte_a      ; Fall through to _done_drop
.a727						_done_drop:
.a727		e8		inx		                inx
.a728		e8		inx		                inx             ; Fall through to _done
.a729						_done:
.a729		60		rts		                rts             ; Returns to original caller
.a72a						xt_asm_push_a:
.a72a		a0 00		ldy #$00	                ldy #0
.a72c						_loop:
.a72c		b9 3a a7	lda $a73a,y	                lda asm_push_a_data,y
.a72f		c9 ff		cmp #$ff	                cmp #$FF
.a731		f0 06		beq $a739	                beq _done
.a733		20 9e d5	jsr $d59e	                jsr cmpl_byte_a      ; does not change Y
.a736		c8		iny		                iny
.a737		80 f3		bra $a72c	                bra _loop
.a739						_done:
.a739						z_asm_push_a:
.a739		60		rts		                rts
.a73a						asm_push_a_data:
>a73a		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>a740		ff				        .byte $FF               ; terminator
.a741						xt_asm_back_jump:
.a741						z_asm_back_jump:
.a741		60		rts		                rts
.a742						xt_asm_back_branch:
.a742		20 02 8a	jsr $8a02	                jsr xt_here             ; ( addr-l addr-h )
.a745		20 e7 8c	jsr $8ce7	                jsr xt_minus            ; ( offset )
.a748		3a		dec a		                dea
.a749		3a		dec a		                dea
.a74a						z_asm_back_branch:
.a74a		60		rts		                rts
.a74b						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a74b						xt_ed:
.a74b		20 4f a7	jsr $a74f	                jsr ed6502      ; kept in separate file
.a74e		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a74f						ed6502:
.a74f		a5 18		lda $18		                lda base
.a751		85 3a		sta $3a		                sta ed_base
.a753		a9 0a		lda #$0a	                lda #10
.a755		85 18		sta $18		                sta base
.a757		64 35		stz $35		                stz ed_head
.a759		64 36		stz $36		                stz ed_head+1
.a75b		64 37		stz $37		                stz ed_cur
.a75d		64 38		stz $38		                stz ed_cur+1
.a75f		64 39		stz $39		                stz ed_flags
.a761		20 8c 9d	jsr $9d8c	                jsr xt_zero
.a764		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; ( addr-t u-t )
.a767		20 fa 84	jsr $84fa	                jsr xt_cr
.a76a						ed_input_loop:
.a76a		a9 81		lda #$81	                lda #%10000001
.a76c		14 39		trb $39		                trb ed_flags
.a76e		20 49 ac	jsr $ac49	                jsr ed_get_input
.a771		a5 0e		lda $0e		                lda ciblen
.a773		d0 1f		bne $a794	                bne _command_mode
.a775		ca		dex		                dex
.a776		ca		dex		                dex                     ; ( addr-t u-t ? )
.a777		a5 37		lda $37		                lda ed_cur
.a779		95 00		sta $00,x	                sta 0,x
.a77b		a5 38		lda $38		                lda ed_cur+1
.a77d		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a77f		a9 80		lda #$80	                lda #%10000000
.a781		04 39		tsb $39		                tsb ed_flags
.a783		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.a786		20 65 ac	jsr $ac65	                jsr ed_is_valid_line
.a789		b0 03		bcs $a78e	                bcs +
.a78b		4c 39 ac	jmp $ac39	                jmp ed_error_1drop
.a78e						+
.a78e		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.a791		4c 5f a8	jmp $a85f	                jmp _line_number_only_from_external
.a794						_command_mode:
.a794		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a797		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a79a						_prefix_dot:
.a79a		b2 0c		lda ($0c)	                lda (cib)
.a79c		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a79e		d0 3a		bne $a7da	                bne _prefix_dollar
.a7a0		20 5a ac	jsr $ac5a	                jsr ed_have_text
.a7a3		a5 37		lda $37		                lda ed_cur
.a7a5		95 02		sta $02,x	                sta 2,x
.a7a7		a5 38		lda $38		                lda ed_cur+1
.a7a9		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a7ab		a9 80		lda #$80	                lda #%10000000
.a7ad		04 39		tsb $39		                tsb ed_flags
.a7af		a5 0e		lda $0e		                lda ciblen
.a7b1		3a		dec a		                dea                     ; sets Z if A was 1
.a7b2		d0 03		bne $a7b7	                bne +
.a7b4		4c 5f a8	jmp $a85f	                jmp _line_number_only_from_external
.a7b7						+
.a7b7		ca		dex		                dex
.a7b8		ca		dex		                dex
.a7b9		ca		dex		                dex
.a7ba		ca		dex		                dex
.a7bb		a5 0c		lda $0c		                lda cib
.a7bd		95 02		sta $02,x	                sta 2,x
.a7bf		a5 0d		lda $0d		                lda cib+1
.a7c1		95 03		sta $03,x	                sta 3,x
.a7c3		a5 0e		lda $0e		                lda ciblen
.a7c5		95 00		sta $00,x	                sta 0,x
.a7c7		a5 0f		lda $0f		                lda ciblen+1
.a7c9		95 01		sta $01,x	                sta 1,x
.a7cb		20 e0 8d	jsr $8de0	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a7ce		20 4d 93	jsr $934d	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a7d1		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a7d4		20 4d 93	jsr $934d	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a7d7		4c b7 a8	jmp $a8b7	                jmp _check_for_para2
.a7da						_prefix_dollar:
.a7da		b2 0c		lda ($0c)	                lda (cib)
.a7dc		c9 24		cmp #$24	                cmp #'$'
.a7de		d0 1c		bne $a7fc	                bne _prefix_percent
.a7e0		20 5a ac	jsr $ac5a	                jsr ed_have_text
.a7e3		e8		inx		                inx
.a7e4		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a7e5		20 87 ac	jsr $ac87	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a7e8		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.a7eb		a9 80		lda #$80	                lda #%10000000
.a7ed		04 39		tsb $39		                tsb ed_flags
.a7ef		a5 0e		lda $0e		                lda ciblen
.a7f1		3a		dec a		                dea                     ; sets Z if A was 1
.a7f2		d0 03		bne $a7f7	                bne +
.a7f4		4c 5f a8	jmp $a85f	                jmp _line_number_only_from_external
.a7f7						+
.a7f7		a0 01		ldy #$01	                ldy #01
.a7f9		4c 33 a9	jmp $a933	                jmp _check_command
.a7fc						_prefix_percent:
.a7fc		b2 0c		lda ($0c)	                lda (cib)
.a7fe		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a800		f0 04		beq $a806	                beq _whole_text
.a802		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a804		d0 17		bne $a81d	                bne _prefix_semicolon
.a806						_whole_text:
.a806		20 5a ac	jsr $ac5a	                jsr ed_have_text
.a809		a9 01		lda #$01	                lda #01
.a80b		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a80d		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a80f						_semicolon_entry:
.a80f		e8		inx		                inx
.a810		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a811		20 87 ac	jsr $ac87	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a814		a9 80		lda #$80	                lda #%10000000
.a816		04 39		tsb $39		                tsb ed_flags
.a818		a0 01		ldy #$01	                ldy #01
.a81a		4c 33 a9	jmp $a933	                jmp _check_command
.a81d						_prefix_semicolon:
.a81d		b2 0c		lda ($0c)	                lda (cib)
.a81f		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a821		d0 0d		bne $a830	                bne _prefix_number
.a823		20 5a ac	jsr $ac5a	                jsr ed_have_text
.a826		a5 37		lda $37		                lda ed_cur
.a828		95 02		sta $02,x	                sta 2,x
.a82a		a5 38		lda $38		                lda ed_cur+1
.a82c		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a82e		80 df		bra $a80f	                bra _semicolon_entry
.a830						_prefix_number:
.a830		20 8c 9d	jsr $9d8c	                jsr xt_zero
.a833		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.a836		ca		dex		                dex
.a837		ca		dex		                dex
.a838		ca		dex		                dex
.a839		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a83a		a5 0c		lda $0c		                lda cib
.a83c		95 02		sta $02,x	                sta 2,x
.a83e		a5 0d		lda $0d		                lda cib+1
.a840		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a842		a5 0e		lda $0e		                lda ciblen
.a844		95 00		sta $00,x	                sta 0,x
.a846		a5 0f		lda $0f		                lda ciblen+1
.a848		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a84a		20 eb 93	jsr $93eb	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a84d		b5 00		lda $00,x	                lda 0,x
.a84f		15 01		ora $01,x	                ora 1,x
.a851		d0 24		bne $a877	                bne _have_unconverted_chars
.a853		e8		inx		                inx
.a854		e8		inx		                inx
.a855		e8		inx		                inx
.a856		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a857		20 d5 9d	jsr $9dd5	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a85a		20 10 9c	jsr $9c10	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.a85d		e8		inx		                inx
.a85e		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a85f						_line_number_only_from_external:
.a85f		20 4d 93	jsr $934d	                jsr xt_swap             ; ( addr-t u-t 0 u )
.a862		20 65 ac	jsr $ac65	                jsr ed_is_valid_line
.a865		b0 03		bcs $a86a	                bcs +
.a867		4c 37 ac	jmp $ac37	                jmp ed_error_2drop
.a86a						+
.a86a		20 4d 93	jsr $934d	                jsr xt_swap             ; ( addr-t u-t u 0 )
.a86d		20 f4 ac	jsr $acf4	                jsr ed_para1_to_cur
.a870		a9 80		lda #$80	                lda #%10000000
.a872		04 39		tsb $39		                tsb ed_flags
.a874		4c 12 ab	jmp $ab12	                jmp ed_cmd_p_from_external
.a877						_have_unconverted_chars:
.a877		20 42 87	jsr $8742	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a87a		ca		dex		                dex
.a87b		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a87c		a5 0e		lda $0e		                lda ciblen
.a87e		95 00		sta $00,x	                sta 0,x
.a880		a5 0f		lda $0f		                lda ciblen+1
.a882		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a884		20 7d 88	jsr $887d	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a887		b5 00		lda $00,x	                lda 0,x
.a889		15 01		ora $01,x	                ora 1,x
.a88b		f0 0e		beq $a89b	                beq _no_command_yet
.a88d		8a		txa		                txa
.a88e		18		clc		                clc
.a88f		69 0a		adc #$0a	                adc #10
.a891		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a892		a9 80		lda #$80	                lda #%10000000
.a894		14 39		trb $39		                trb ed_flags
.a896		a0 00		ldy #$00	                ldy #00
.a898		4c 33 a9	jmp $a933	                jmp _check_command
.a89b						_no_command_yet:
.a89b		e8		inx		                inx
.a89c		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a89d		20 8b 94	jsr $948b	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a8a0		20 10 9c	jsr $9c10	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a8a3		20 d5 9d	jsr $9dd5	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a8a6		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a8a8		95 06		sta $06,x	                sta 6,x
.a8aa		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a8ac		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a8ae		e8		inx		                inx
.a8af		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a8b0		20 f1 8f	jsr $8ff1	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a8b3		a9 80		lda #$80	                lda #%10000000
.a8b5		04 39		tsb $39		                tsb ed_flags
.a8b7						_check_for_para2:
.a8b7		a1 02		lda ($02,x)	                lda (2,x)
.a8b9		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a8bb		f0 0d		beq $a8ca	                beq _got_comma
.a8bd		38		sec		                sec
.a8be		a5 0e		lda $0e		                lda ciblen
.a8c0		f5 00		sbc $00,x	                sbc 0,x
.a8c2		a8		tay		                tay
.a8c3		e8		inx		                inx
.a8c4		e8		inx		                inx
.a8c5		e8		inx		                inx
.a8c6		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a8c7		4c 33 a9	jmp $a933	                jmp _check_command
.a8ca						_got_comma:
.a8ca		f6 02		inc $02,x	                inc 2,x
.a8cc		d0 02		bne $a8d0	                bne +
.a8ce		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a8d0						+
.a8d0		b5 01		lda $01,x	                lda 1,x
.a8d2		f0 02		beq $a8d6	                beq +
.a8d4		d6 01		dec $01,x	                dec 1,x
.a8d6						+
.a8d6		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a8d8		a1 02		lda ($02,x)	                lda (2,x)
.a8da		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a8dc		d0 14		bne $a8f2	                bne _para2_not_dollar
.a8de		38		sec		                sec
.a8df		a5 0e		lda $0e		                lda ciblen
.a8e1		f5 02		sbc $02,x	                sbc 2,x
.a8e3		a8		tay		                tay
.a8e4		c8		iny		                iny
.a8e5		5a		phy		                phy
.a8e6		8a		txa		                txa
.a8e7		18		clc		                clc
.a8e8		69 06		adc #$06	                adc #06
.a8ea		aa		tax		                tax                     ; ( addr-t u-t para1 )
.a8eb		20 87 ac	jsr $ac87	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a8ee		7a		ply		                ply
.a8ef		4c 33 a9	jmp $a933	                jmp _check_command
.a8f2						_para2_not_dollar:
.a8f2		20 8b 94	jsr $948b	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.a8f5		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.a8f8		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.a8fb		20 8e 90	jsr $908e	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.a8fe		20 f1 8f	jsr $8ff1	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.a901		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.a904		20 8b 94	jsr $948b	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.a907		20 eb 93	jsr $93eb	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.a90a		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.a90d		20 f1 8f	jsr $8ff1	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.a910		20 7d 88	jsr $887d	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.a913		b5 00		lda $00,x	                lda 0,x
.a915		15 01		ora $01,x	                ora 1,x
.a917		f0 08		beq $a921	                beq _second_number
.a919		8a		txa		                txa
.a91a		18		clc		                clc
.a91b		69 0c		adc #$0c	                adc #12
.a91d		aa		tax		                tax                     ; back to ( addr-t u-t )
.a91e		4c 3b ac	jmp $ac3b	                jmp ed_error
.a921						_second_number:
.a921		e8		inx		                inx
.a922		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.a923		38		sec		                sec
.a924		a5 0e		lda $0e		                lda ciblen
.a926		f5 00		sbc $00,x	                sbc 0,x
.a928		48		pha		                pha
.a929		20 c2 94	jsr $94c2	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.a92c		20 d5 9d	jsr $9dd5	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.a92f		20 33 8d	jsr $8d33	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.a932		7a		ply		                ply
.a933						_check_command:
.a933		24 39		bit $39		                bit ed_flags
.a935		30 08		bmi $a93f	                bmi _check_command_have_arg
.a937		a5 37		lda $37		                lda ed_cur
.a939		95 02		sta $02,x	                sta 2,x
.a93b		a5 38		lda $38		                lda ed_cur+1
.a93d		95 03		sta $03,x	                sta 3,x
.a93f						_check_command_have_arg:
.a93f		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.a941		85 25		sta $25		                sta tmp1
.a943		da		phx		                phx
.a944		a2 00		ldx #$00	                ldx #00
.a946						_cmd_loop:
.a946		bd 1f ad	lda $ad1f,x	                lda ed_cmd_list,x
.a949		f0 07		beq $a952	                beq _illegal_command    ; zero marks end of list
.a94b		c5 25		cmp $25		                cmp tmp1
.a94d		f0 07		beq $a956	                beq _found_cmd
.a94f		e8		inx		                inx
.a950		80 f4		bra $a946	                bra _cmd_loop
.a952						_illegal_command:
.a952		fa		plx		                plx
.a953		4c 37 ac	jmp $ac37	                jmp ed_error_2drop
.a956						_found_cmd:
.a956		8a		txa		                txa
.a957		0a		asl a		                asl
.a958		aa		tax		                tax                     ; X * 2 for table
.a959		7c 2a ad	jmp ($ad2a,x)	                jmp (ed_cmd_table,x)
.a95c						ed_next_command:
.a95c		e8		inx		                inx
.a95d		e8		inx		                inx
.a95e		e8		inx		                inx
.a95f		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.a960						_next_command_empty:
.a960		4c 6a a7	jmp $a76a	                jmp ed_input_loop
.a963						ed_all_done:
.a963		64 0e		stz $0e		                stz ciblen
.a965		64 0f		stz $0f		                stz ciblen+1
.a967		20 c2 94	jsr $94c2	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.a96a		a5 3a		lda $3a		                lda ed_base
.a96c		85 18		sta $18		                sta base
.a96e		60		rts		                rts
.a96f						ed_cmd_a:
.a96f		fa		plx		                plx
.a970		e8		inx		                inx
.a971		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.a972						ed_entry_cmd_i:
.a972						ed_cmd_a_have_para:
.a972		20 bd ac	jsr $acbd	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.a975		20 fa 84	jsr $84fa	                jsr xt_cr
.a978						_next_string_loop:
.a978		20 49 ac	jsr $ac49	                jsr ed_get_input
.a97b		b2 0c		lda ($0c)	                lda (cib)
.a97d		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.a97f		d0 16		bne $a997	                bne _add_line
.a981		a4 0e		ldy $0e		                ldy ciblen
.a983		c0 01		cpy #$01	                cpy #01
.a985		d0 10		bne $a997	                bne _add_line
.a987		a4 0f		ldy $0f		                ldy ciblen+1
.a989		d0 0c		bne $a997	                bne _add_line
.a98b		e8		inx		                inx
.a98c		e8		inx		                inx
.a98d		a9 40		lda #$40	                lda #%01000000
.a98f		04 39		tsb $39		                tsb ed_flags
.a991		20 fa 84	jsr $84fa	                jsr xt_cr
.a994		4c 6a a7	jmp $a76a	                jmp ed_input_loop
.a997						_add_line:
.a997		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.a99a		20 02 8a	jsr $8a02	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.a99d		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.a9a0		20 01 89	jsr $8901	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.a9a3		20 cf 83	jsr $83cf	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.a9a6		20 a8 94	jsr $94a8	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.a9a9		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.a9ac		20 37 93	jsr $9337	                jsr xt_store            ; ! ( addr-t u-t here )
.a9af		20 02 8a	jsr $8a02	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.a9b2		a5 00		lda $00		                lda cp
.a9b4		18		clc		                clc
.a9b5		69 04		adc #$04	                adc #04
.a9b7		85 00		sta $00		                sta cp
.a9b9		90 02		bcc $a9bd	                bcc +
.a9bb		e6 01		inc $01		                inc cp+1
.a9bd						+
.a9bd		e6 37		inc $37		                inc ed_cur
.a9bf		d0 02		bne $a9c3	                bne +
.a9c1		e6 38		inc $38		                inc ed_cur+1
.a9c3						+
.a9c3		20 02 8a	jsr $8a02	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.a9c6		20 42 87	jsr $8742	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.a9c9		ca		dex		                dex
.a9ca		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.a9cb		a5 0c		lda $0c		                lda cib
.a9cd		95 00		sta $00,x	                sta 0,x
.a9cf		a5 0d		lda $0d		                lda cib+1
.a9d1		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.a9d3		20 4d 93	jsr $934d	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.a9d6		ca		dex		                dex
.a9d7		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.a9d8		a5 0e		lda $0e		                lda ciblen
.a9da		95 00		sta $00,x	                sta 0,x
.a9dc		a5 0f		lda $0f		                lda ciblen+1
.a9de		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.a9e0		20 03 8d	jsr $8d03	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.a9e3		18		clc		                clc
.a9e4		a5 00		lda $00		                lda cp
.a9e6		65 0e		adc $0e		                adc ciblen
.a9e8		85 00		sta $00		                sta cp
.a9ea		90 06		bcc $a9f2	                bcc +
.a9ec		a5 01		lda $01		                lda cp+1
.a9ee		65 0f		adc $0f		                adc ciblen+1
.a9f0		85 01		sta $01		                sta cp+1
.a9f2						+
.a9f2		20 08 8e	jsr $8e08	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.a9f5		20 37 93	jsr $9337	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.a9f8		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+
.a9fb		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.a9fe		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.aa01		a5 0e		lda $0e		                lda ciblen
.aa03		95 02		sta $02,x	                sta 2,x
.aa05		a5 0f		lda $0f		                lda ciblen+1
.aa07		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.aa09		20 37 93	jsr $9337	                jsr xt_store            ; ! ( addr-t u-t here )
.aa0c		20 fa 84	jsr $84fa	                jsr xt_cr
.aa0f		4c 78 a9	jmp $a978	                jmp _next_string_loop
.aa12						ed_cmd_d:
.aa12		fa		plx		                plx
.aa13		20 5a ac	jsr $ac5a	                jsr ed_have_text
.aa16		20 af ac	jsr $acaf	                jsr ed_no_line_zero
.aa19		b5 00		lda $00,x	                lda 0,x
.aa1b		15 01		ora $01,x	                ora 1,x
.aa1d		d0 08		bne $aa27	                bne +
.aa1f		20 08 8e	jsr $8e08	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.aa22		20 64 aa	jsr $aa64	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.aa25		80 33		bra $aa5a	                bra _cmd_d_done
.aa27						+
.aa27		20 65 ac	jsr $ac65	                jsr ed_is_valid_line      ; result is in C flag
.aa2a		b0 03		bcs $aa2f	                bcs _cmd_d_loop
.aa2c		4c 37 ac	jmp $ac37	                jmp ed_error_2drop
.aa2f						_cmd_d_loop:
.aa2f		20 ca 94	jsr $94ca	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.aa32		20 ed 89	jsr $89ed	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.aa35		b5 00		lda $00,x	                lda 0,x
.aa37		15 01		ora $01,x	                ora 1,x
.aa39		d0 0d		bne $aa48	                bne _cmd_d_done_with_flag
.aa3b		e8		inx		                inx
.aa3c		e8		inx		                inx                     ; Get rid of the flag from >
.aa3d		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.aa40		20 64 aa	jsr $aa64	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.aa43		20 e0 8d	jsr $8de0	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.aa46		80 e7		bra $aa2f	                bra _cmd_d_loop
.aa48						_cmd_d_done_with_flag:
.aa48		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.aa49		e8		inx		                inx
.aa4a		b5 02		lda $02,x	                lda 2,x
.aa4c		d0 02		bne $aa50	                bne +
.aa4e		d6 03		dec $03,x	                dec 3,x
.aa50						+
.aa50		d6 02		dec $02,x	                dec 2,x
.aa52		b5 02		lda $02,x	                lda 2,x
.aa54		85 37		sta $37		                sta ed_cur
.aa56		b5 03		lda $03,x	                lda 3,x
.aa58		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.aa5a						_cmd_d_done:
.aa5a		a9 40		lda #$40	                lda #%01000000
.aa5c		04 39		tsb $39		                tsb ed_flags
.aa5e		20 fa 84	jsr $84fa	                jsr xt_cr
.aa61		4c 5c a9	jmp $a95c	                jmp ed_next_command
.aa64						_cmd_d_common:
.aa64		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.aa67		20 bd ac	jsr $acbd	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.aa6a		20 01 89	jsr $8901	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.aa6d		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.aa70		20 e0 8d	jsr $8de0	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.aa73		20 bd ac	jsr $acbd	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.aa76		20 37 93	jsr $9337	                jsr xt_store            ; ! ( addr-t u-t )
.aa79		60		rts		                rts
.aa7a						ed_cmd_equ:
.aa7a		fa		plx		                plx
.aa7b		a5 35		lda $35		                lda ed_head
.aa7d		05 36		ora $36		                ora ed_head+1
.aa7f		d0 08		bne $aa89	                bne _cmd_equ_have_text
.aa81		ca		dex		                dex
.aa82		ca		dex		                dex
.aa83		74 00		stz $00,x	                stz 0,x
.aa85		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.aa87		80 21		bra $aaaa	                bra _cmd_equ_done
.aa89						_cmd_equ_have_text:
.aa89		20 af ac	jsr $acaf	                jsr ed_no_line_zero
.aa8c		24 39		bit $39		                bit ed_flags
.aa8e		30 0c		bmi $aa9c	                bmi _cmd_equ_have_para
.aa90		ca		dex		                dex
.aa91		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.aa92		a5 37		lda $37		                lda ed_cur
.aa94		95 00		sta $00,x	                sta 0,x
.aa96		a5 38		lda $38		                lda ed_cur+1
.aa98		95 01		sta $01,x	                sta 1,x
.aa9a		80 0e		bra $aaaa	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.aa9c						_cmd_equ_have_para:
.aa9c		b5 00		lda $00,x	                lda 0,x
.aa9e		15 01		ora $01,x	                ora 1,x
.aaa0		d0 05		bne $aaa7	                bne _cmd_equ_two_paras
.aaa2		20 08 8e	jsr $8e08	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.aaa5		80 03		bra $aaaa	                bra _cmd_equ_done
.aaa7						_cmd_equ_two_paras:
.aaa7		20 42 87	jsr $8742	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.aaaa						_cmd_equ_done:
.aaaa		20 fa 84	jsr $84fa	                jsr xt_cr               ; number goes on new line
.aaad		20 ff 95	jsr $95ff	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.aab0		20 fa 84	jsr $84fa	                jsr xt_cr
.aab3		4c 5c a9	jmp $a95c	                jmp ed_next_command
.aab6						ed_cmd_f:
.aab6		fa		plx		                plx
.aab7		24 39		bit $39		                bit ed_flags
.aab9		30 17		bmi $aad2	                bmi _cmd_f_have_para
.aabb		20 fa 84	jsr $84fa	                jsr xt_cr
.aabe		20 8b 94	jsr $948b	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.aac1		20 8e 90	jsr $908e	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.aac4		20 42 87	jsr $8742	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.aac7		20 ff 95	jsr $95ff	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.aaca		20 10 9c	jsr $9c10	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.aacd		20 f1 8f	jsr $8ff1	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.aad0		80 11		bra $aae3	                bra _cmd_f_done
.aad2						_cmd_f_have_para:
.aad2		20 08 8e	jsr $8e08	                jsr xt_over
.aad5		20 fa 84	jsr $84fa	                jsr xt_cr
.aad8		20 ff 95	jsr $95ff	                jsr xt_u_dot
.aadb		b5 02		lda $02,x	                lda 2,x
.aadd		95 06		sta $06,x	                sta 6,x
.aadf		b5 03		lda $03,x	                lda 3,x
.aae1		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.aae3						_cmd_f_done:
.aae3		20 fa 84	jsr $84fa	                jsr xt_cr
.aae6		4c 5c a9	jmp $a95c	                jmp ed_next_command
.aae9						ed_cmd_i:
.aae9		fa		plx		                plx
.aaea		e8		inx		                inx
.aaeb		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.aaec		24 39		bit $39		                bit ed_flags
.aaee		30 08		bmi $aaf8	                bmi _cmd_i_have_para
.aaf0		a5 37		lda $37		                lda ed_cur
.aaf2		95 00		sta $00,x	                sta 0,x
.aaf4		a5 38		lda $38		                lda ed_cur+1
.aaf6		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.aaf8						_cmd_i_have_para:
.aaf8		b5 00		lda $00,x	                lda 0,x
.aafa		15 01		ora $01,x	                ora 1,x
.aafc		f0 09		beq $ab07	                beq _cmd_i_done
.aafe		20 e0 8d	jsr $8de0	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.ab01		20 8c 9d	jsr $9d8c	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.ab04		20 af 8c	jsr $8caf	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.ab07						_cmd_i_done:
.ab07		4c 72 a9	jmp $a972	                jmp ed_entry_cmd_i
.ab0a						ed_cmd_n:
.ab0a		fa		plx		                plx
.ab0b		a9 01		lda #$01	                lda #%00000001
.ab0d		04 39		tsb $39		                tsb ed_flags
.ab0f		80 05		bra $ab16	                bra ed_cmd_p_entry_for_cmd_n
.ab11						ed_cmd_p:
.ab11		fa		plx		                plx
.ab12						ed_cmd_p_from_external:
.ab12		a9 01		lda #$01	                lda #%00000001
.ab14		14 39		trb $39		                trb ed_flags
.ab16						ed_cmd_p_entry_for_cmd_n:
.ab16		20 5a ac	jsr $ac5a	                jsr ed_have_text
.ab19		20 af ac	jsr $acaf	                jsr ed_no_line_zero
.ab1c		20 fa 84	jsr $84fa	                jsr xt_cr
.ab1f		b5 00		lda $00,x	                lda 0,x
.ab21		15 01		ora $01,x	                ora 1,x
.ab23		d0 10		bne $ab35	                bne _cmd_p_loop
.ab25		b5 02		lda $02,x	                lda 2,x
.ab27		85 37		sta $37		                sta ed_cur
.ab29		b5 03		lda $03,x	                lda 3,x
.ab2b		85 38		sta $38		                sta ed_cur+1
.ab2d		20 08 8e	jsr $8e08	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ab30		20 5e ab	jsr $ab5e	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ab33		80 26		bra $ab5b	                bra _cmd_p_all_done
.ab35						_cmd_p_loop:
.ab35		20 ca 94	jsr $94ca	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab38		20 ed 89	jsr $89ed	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab3b		b5 00		lda $00,x	                lda 0,x
.ab3d		15 01		ora $01,x	                ora 1,x
.ab3f		d0 10		bne $ab51	                bne _cmd_p_done
.ab41		e8		inx		                inx
.ab42		e8		inx		                inx                     ; Get rid of the flag from >
.ab43		20 08 8e	jsr $8e08	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.ab46		20 5e ab	jsr $ab5e	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ab49		f6 02		inc $02,x	                inc 2,x
.ab4b		d0 02		bne $ab4f	                bne +
.ab4d		f6 03		inc $03,x	                inc 3,x
.ab4f						+
.ab4f		80 e4		bra $ab35	                bra _cmd_p_loop
.ab51						_cmd_p_done:
.ab51		e8		inx		                inx
.ab52		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.ab53		b5 00		lda $00,x	                lda 0,x
.ab55		85 37		sta $37		                sta ed_cur
.ab57		b5 01		lda $01,x	                lda 1,x
.ab59		85 38		sta $38		                sta ed_cur+1
.ab5b						_cmd_p_all_done:
.ab5b		4c 5c a9	jmp $a95c	                jmp ed_next_command
.ab5e						_cmd_p_common:
.ab5e		a5 39		lda $39		                lda ed_flags
.ab60		4a		lsr a		                lsr                     ; bit 0 now in carry
.ab61		90 0b		bcc $ab6e	                bcc _cmd_p_common_no_num
.ab63		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.ab66		20 ff 95	jsr $95ff	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.ab69		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.ab6b		20 ac 87	jsr $87ac	                jsr emit_a
.ab6e						_cmd_p_common_no_num:
.ab6e		20 bd ac	jsr $acbd	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.ab71		20 fd ac	jsr $acfd	                jsr ed_print_addr
.ab74		60		rts		                rts
.ab75						ed_cmd_q:
.ab75		fa		plx		                plx
.ab76		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.ab78		50 03		bvc $ab7d	                bvc +
.ab7a		4c 37 ac	jmp $ac37	                jmp ed_error_2drop
.ab7d						+
.ab7d		4c 63 a9	jmp $a963	                jmp ed_all_done            ; can't fall thru because of PLX
.ab80						ed_cmd_qq:
.ab80		fa		plx		                plx
.ab81		4c 63 a9	jmp $a963	                jmp ed_all_done
.ab84						ed_cmd_w:
.ab84		fa		plx		                plx
.ab85		20 5a ac	jsr $ac5a	                jsr ed_have_text
.ab88		24 39		bit $39		                bit ed_flags
.ab8a		30 13		bmi $ab9f	                bmi _cmd_w_have_para
.ab8c		b5 06		lda $06,x	                lda 6,x
.ab8e		15 07		ora $07,x	                ora 7,x
.ab90		d0 03		bne $ab95	                bne +
.ab92		4c 37 ac	jmp $ac37	                jmp ed_error_2drop
.ab95						+
.ab95		b5 06		lda $06,x	                lda 6,x
.ab97		95 02		sta $02,x	                sta 2,x
.ab99		b5 07		lda $07,x	                lda 7,x
.ab9b		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.ab9d		80 08		bra $aba7	                bra _cmd_w_para_ready
.ab9f						_cmd_w_have_para:
.ab9f		b5 02		lda $02,x	                lda 2,x
.aba1		95 06		sta $06,x	                sta 6,x
.aba3		b5 03		lda $03,x	                lda 3,x
.aba5		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.aba7						_cmd_w_para_ready:
.aba7		a9 35		lda #$35	                lda #<ed_head
.aba9		95 00		sta $00,x	                sta 0,x
.abab		a9 00		lda #$00	                lda #>ed_head
.abad		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.abaf		20 08 8e	jsr $8e08	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.abb2		20 8b 94	jsr $948b	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.abb5						_cmd_w_loop:
.abb5		20 01 89	jsr $8901	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.abb8		b5 00		lda $00,x	                lda 0,x
.abba		15 01		ora $01,x	                ora 1,x
.abbc		f0 55		beq $ac13	                beq _cmd_w_eol
.abbe		20 ca 94	jsr $94ca	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.abc1		20 b4 95	jsr $95b4	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.abc4		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.abc7		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.abca		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.abcd		20 01 89	jsr $8901	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.abd0		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.abd3		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.abd6		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.abd9		20 01 89	jsr $8901	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.abdc		20 10 9c	jsr $9c10	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.abdf		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.abe2		20 8e 90	jsr $908e	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.abe5		20 42 87	jsr $8742	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.abe8		20 8b 94	jsr $948b	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.abeb		20 03 8d	jsr $8d03	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.abee		20 f1 8f	jsr $8ff1	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.abf1		20 3a 95	jsr $953a	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.abf4		20 10 9c	jsr $9c10	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.abf7		20 56 8f	jsr $8f56	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.abfa		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.abfd		ca		dex		                dex
.abfe		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.abff		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ac01		95 00		sta $00,x	                sta 0,x
.ac03		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ac05		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ac08		20 37 93	jsr $9337	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ac0b		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ac0e		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ac11		80 a2		bra $abb5	                bra _cmd_w_loop
.ac13						_cmd_w_eol:
.ac13		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ac16		20 f1 8f	jsr $8ff1	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ac19		20 e7 8c	jsr $8ce7	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ac1c		b5 00		lda $00,x	                lda 0,x
.ac1e		95 04		sta $04,x	                sta 4,x
.ac20		b5 01		lda $01,x	                lda 1,x
.ac22		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ac24		20 fa 84	jsr $84fa	                jsr xt_cr
.ac27		20 42 87	jsr $8742	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ac2a		20 ff 95	jsr $95ff	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ac2d		20 fa 84	jsr $84fa	                jsr xt_cr
.ac30		a9 40		lda #$40	                lda #%01000000
.ac32		14 39		trb $39		                trb ed_flags
.ac34		4c 5c a9	jmp $a95c	                jmp ed_next_command
.ac37						ed_error_2drop:
.ac37		e8		inx		                inx
.ac38		e8		inx		                inx                     ; drop through to _error_1drop
.ac39						ed_error_1drop:
.ac39		e8		inx		                inx
.ac3a		e8		inx		                inx                     ; drop through to _error
.ac3b						ed_error:
.ac3b		20 fa 84	jsr $84fa	                jsr xt_cr
.ac3e		a9 3f		lda #$3f	                lda #'?'
.ac40		20 ac 87	jsr $87ac	                jsr emit_a
.ac43		20 fa 84	jsr $84fa	                jsr xt_cr
.ac46		4c 6a a7	jmp $a76a	                jmp ed_input_loop
.ac49						ed_get_input:
.ac49		20 3f 90	jsr $903f	                jsr xt_refill           ;  ( addr-t u-t f )
.ac4c		b5 00		lda $00,x	                lda 0,x
.ac4e		15 01		ora $01,x	                ora 1,x
.ac50		d0 05		bne $ac57	                bne +
.ac52		7a		ply		                ply
.ac53		7a		ply		                ply
.ac54		4c 39 ac	jmp $ac39	                jmp ed_error_1drop
.ac57						+
.ac57		e8		inx		                inx
.ac58		e8		inx		                inx
.ac59		60		rts		                rts
.ac5a						ed_have_text:
.ac5a		a5 35		lda $35		                lda ed_head
.ac5c		05 36		ora $36		                ora ed_head+1
.ac5e		d0 04		bne $ac64	                bne +
.ac60		7a		ply		                ply
.ac61		7a		ply		                ply
.ac62		80 d7		bra $ac3b	                bra ed_error
.ac64						+
.ac64		60		rts		                rts
.ac65						ed_is_valid_line:
.ac65		38		sec		                sec                             ; default is legal line number
.ac66		b5 00		lda $00,x	                lda 0,x
.ac68		15 01		ora $01,x	                ora 1,x
.ac6a		f0 19		beq $ac85	                beq _is_valid_line_nope_zero    ; ( n )
.ac6c		20 42 87	jsr $8742	                jsr xt_dup                      ; DUP ( n n )
.ac6f		20 87 ac	jsr $ac87	                jsr ed_last_line                  ; ( n n last )
.ac72		20 4d 93	jsr $934d	                jsr xt_swap                     ; SWAP ( n last n )
.ac75		20 06 8b	jsr $8b06	                jsr xt_less_than                ; < ( n f )
.ac78		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ac7a		15 01		ora $01,x	                ora 1,x
.ac7c		d0 05		bne $ac83	                bne _is_valid_line_too_small
.ac7e		e8		inx		                inx
.ac7f		e8		inx		                inx                     ; DROP flag ( n )
.ac80		38		sec		                sec                     ; Who knows what's happened to C by now
.ac81		80 03		bra $ac86	                bra _is_valid_line_done ; only one exit from this routine
.ac83						_is_valid_line_too_small:
.ac83		e8		inx		                inx
.ac84		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ac85						_is_valid_line_nope_zero:
.ac85		18		clc		                clc                     ; drop through to _is_valid_line_done
.ac86						_is_valid_line_done:
.ac86		60		rts		                rts
.ac87						ed_last_line:
.ac87		64 25		stz $25		                stz tmp1
.ac89		64 26		stz $26		                stz tmp1+1
.ac8b		ca		dex		                dex
.ac8c		ca		dex		                dex                     ; ( ? )
.ac8d		a9 35		lda #$35	                lda #<ed_head
.ac8f		95 00		sta $00,x	                sta 0,x
.ac91		a9 00		lda #$00	                lda #>ed_head
.ac93		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.ac95						_last_line_loop:
.ac95		20 01 89	jsr $8901	                jsr xt_fetch            ; ( addr | 0 )
.ac98		b5 00		lda $00,x	                lda 0,x
.ac9a		15 01		ora $01,x	                ora 1,x
.ac9c		f0 08		beq $aca6	                beq _last_line_done
.ac9e		e6 25		inc $25		                inc tmp1
.aca0		d0 02		bne $aca4	                bne +
.aca2		e6 26		inc $26		                inc tmp1+1
.aca4						+
.aca4		80 ef		bra $ac95	                bra _last_line_loop
.aca6						_last_line_done:
.aca6		a5 25		lda $25		                lda tmp1
.aca8		95 00		sta $00,x	                sta 0,x
.acaa		a5 26		lda $26		                lda tmp1+1
.acac		95 01		sta $01,x	                sta 1,x                 ; ( u )
.acae		60		rts		                rts
.acaf						ed_no_line_zero:
.acaf		b5 02		lda $02,x	                lda 2,x
.acb1		15 03		ora $03,x	                ora 3,x
.acb3		d0 07		bne $acbc	                bne _no_line_zero_done
.acb5		24 39		bit $39		                bit ed_flags
.acb7		10 03		bpl $acbc	                bpl _no_line_zero_done
.acb9		4c 37 ac	jmp $ac37	                jmp ed_error_2drop
.acbc						_no_line_zero_done:
.acbc		60		rts		                rts
.acbd						ed_num_to_addr:
.acbd		ca		dex		                dex
.acbe		ca		dex		                dex                     ; ( u ? )
.acbf		a9 35		lda #$35	                lda #<ed_head
.acc1		95 00		sta $00,x	                sta 0,x
.acc3		a9 00		lda #$00	                lda #>ed_head
.acc5		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.acc7		b5 02		lda $02,x	                lda 2,x
.acc9		15 03		ora $03,x	                ora 3,x
.accb		d0 05		bne $acd2	                bne _num_to_addr_loop
.accd		20 33 8d	jsr $8d33	                jsr xt_nip              ; ( addr-h )
.acd0		80 21		bra $acf3	                bra _num_to_addr_done
.acd2						_num_to_addr_loop:
.acd2		20 01 89	jsr $8901	                jsr xt_fetch            ; @ ( u addr1 )
.acd5		b5 00		lda $00,x	                lda 0,x
.acd7		15 01		ora $01,x	                ora 1,x
.acd9		d0 05		bne $ace0	                bne +
.acdb		20 33 8d	jsr $8d33	                jsr xt_nip              ; NIP ( addr1 )
.acde		80 13		bra $acf3	                bra _num_to_addr_done
.ace0						+
.ace0		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( addr1 u )
.ace3		20 e0 8d	jsr $8de0	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.ace6		b5 00		lda $00,x	                lda 0,x
.ace8		15 01		ora $01,x	                ora 1,x
.acea		f0 05		beq $acf1	                beq _num_to_addr_finished
.acec		20 4d 93	jsr $934d	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.acef		80 e1		bra $acd2	                bra _num_to_addr_loop
.acf1						_num_to_addr_finished:
.acf1		e8		inx		                inx
.acf2		e8		inx		                inx                     ; ( addr )
.acf3						_num_to_addr_done:
.acf3		60		rts		                rts
.acf4						ed_para1_to_cur:
.acf4		b5 02		lda $02,x	                lda 2,x
.acf6		85 37		sta $37		                sta ed_cur
.acf8		b5 03		lda $03,x	                lda 3,x
.acfa		85 38		sta $38		                sta ed_cur+1
.acfc		60		rts		                rts
.acfd						ed_print_addr:
.acfd		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.ad00		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; ( addr+2 )
.ad03		20 42 87	jsr $8742	                jsr xt_dup              ; ( addr+2 addr+2 )
.ad06		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.ad09		20 ec 8d	jsr $8dec	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.ad0c		20 01 89	jsr $8901	                jsr xt_fetch            ; ( addr+2 u-s )
.ad0f		20 4d 93	jsr $934d	                jsr xt_swap             ; ( u-s addr+2 )
.ad12		20 01 89	jsr $8901	                jsr xt_fetch            ; ( u-s addr-s )
.ad15		20 4d 93	jsr $934d	                jsr xt_swap             ; ( addr-s u-s )
.ad18		20 d4 95	jsr $95d4	                jsr xt_type
.ad1b		20 fa 84	jsr $84fa	                jsr xt_cr
.ad1e		60		rts		                rts
>ad1f		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ad27		71 51 00
.ad2a						ed_cmd_table:
>ad2a		6f a9 b6 aa e9 aa 12 aa		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ad32		11 ab 0a ab
>ad36		7a aa 84 ab 75 ab 80 ab		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ad3e						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ad3e						xt_blk:
.ad3e		a9 04		lda #$04	                lda #blk_offset
.ad40		4c 20 d6	jmp $d620	                jmp push_upvar_tos
.ad43						z_blk:
.ad43						xt_blkbuffer:
.ad43		ca		dex		                dex
.ad44		ca		dex		                dex
.ad45		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ad47		b1 08		lda ($08),y	                lda (up),y
.ad49		95 00		sta $00,x	                sta 0,x
.ad4b		c8		iny		                iny             ; Move along to the next byte
.ad4c		b1 08		lda ($08),y	                lda (up),y
.ad4e		95 01		sta $01,x	                sta 1,x
.ad50		60		rts		z_blkbuffer:    rts
.ad51						xt_block:
.ad51		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ad53		b1 08		lda ($08),y	                lda (up),y
.ad55		d5 00		cmp $00,x	                cmp 0,x
.ad57		d0 0f		bne $ad68	                bne _not_in_buffer
.ad59		c8		iny		                iny
.ad5a		b1 08		lda ($08),y	                lda (up),y
.ad5c		d5 01		cmp $01,x	                cmp 1,x
.ad5e		d0 08		bne $ad68	                bne _not_in_buffer
.ad60		a0 30		ldy #$30	                ldy #buffstatus_offset
.ad62		b1 08		lda ($08),y	                lda (up),y
.ad64		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ad66		d0 30		bne $ad98	                bne _done       ; It's already in the buffer and in use.
.ad68						_not_in_buffer:
.ad68		a0 30		ldy #$30	                ldy #buffstatus_offset
.ad6a		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ad6c		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ad6e		d0 0c		bne $ad7c	                bne _buffer_available ; Unused or not dirty = available
.ad70		20 43 ad	jsr $ad43	                jsr xt_blkbuffer
.ad73		20 4d af	jsr $af4d	                jsr xt_buffblocknum
.ad76		20 01 89	jsr $8901	                jsr xt_fetch
.ad79		20 3a af	jsr $af3a	                jsr xt_block_write
.ad7c						_buffer_available:
.ad7c		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ad7e		b5 00		lda $00,x	                lda 0,x
.ad80		91 08		sta ($08),y	                sta (up),y
.ad82		c8		iny		                iny
.ad83		b5 01		lda $01,x	                lda 1,x
.ad85		91 08		sta ($08),y	                sta (up),y
.ad87		20 43 ad	jsr $ad43	                jsr xt_blkbuffer
.ad8a		20 4d 93	jsr $934d	                jsr xt_swap
.ad8d		20 22 af	jsr $af22	                jsr xt_block_read
.ad90		a9 01		lda #$01	                lda #1
.ad92		a0 30		ldy #$30	                ldy #buffstatus_offset
.ad94		91 08		sta ($08),y	                sta (up),y
.ad96		ca		dex		                dex
.ad97		ca		dex		                dex
.ad98						_done:
.ad98		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ad9a		b1 08		lda ($08),y	                lda (up),y
.ad9c		95 00		sta $00,x	                sta 0,x
.ad9e		c8		iny		                iny
.ad9f		b1 08		lda ($08),y	                lda (up),y
.ada1		95 01		sta $01,x	                sta 1,x
.ada3		60		rts		z_block:        rts
.ada4						xt_block_c65_init:
=0						io_blk_status = 0
=0						io_blk_action = 0
=0						io_blk_number = 0
=0						io_blk_buffer = 0
.ada4		a9 ff		lda #$ff	                lda #$ff
.ada6		8d 11 f0	sta $f011	                sta io_blk_status
.ada9		a9 00		lda #$00	                lda #$0
.adab		8d 10 f0	sta $f010	                sta io_blk_action
.adae		ad 11 f0	lda $f011	                lda io_blk_status      ; $0 if OK, $ff otherwise
.adb1		49 ff		eor #$ff	                eor #$ff            ; invert to forth true/false
.adb3		ca		dex		                dex
.adb4		ca		dex		                dex
.adb5		95 00		sta $00,x	                sta 0,x             ; true ($ff) if OK, false (0) otherwise
.adb7		95 01		sta $01,x	                sta 1,x
.adb9		ca		dex		                dex
.adba		ca		dex		                dex
.adbb		a9 de		lda #$de	                lda #<c65_blk_read
.adbd		95 00		sta $00,x	                sta 0,x
.adbf		a9 ad		lda #$ad	                lda #>c65_blk_read
.adc1		95 01		sta $01,x	                sta 1,x
.adc3		20 30 af	jsr $af30	                jsr xt_block_read_vector
.adc6		20 37 93	jsr $9337	                jsr xt_store
.adc9		ca		dex		                dex
.adca		ca		dex		                dex
.adcb		a9 da		lda #$da	                lda #<c65_blk_write
.adcd		95 00		sta $00,x	                sta 0,x
.adcf		a9 ad		lda #$ad	                lda #>c65_blk_write
.add1		95 01		sta $01,x	                sta 1,x
.add3		20 48 af	jsr $af48	                jsr xt_block_write_vector
.add6		20 37 93	jsr $9337	                jsr xt_store
.add9						z_block_c65_init:
.add9		60		rts		                rts
.adda		a0 02		ldy #$02	c65_blk_write:  ldy #2
.addc		80 02		bra $ade0	                bra c65_blk_rw
.adde		a0 01		ldy #$01	c65_blk_read:   ldy #1
.ade0		b5 00		lda $00,x	c65_blk_rw:     lda 0,x                 ; ( addr blk# )
.ade2		8d 12 f0	sta $f012	                sta io_blk_number
.ade5		b5 01		lda $01,x	                lda 1,x
.ade7		8d 13 f0	sta $f013	                sta io_blk_number+1
.adea		b5 02		lda $02,x	                lda 2,x
.adec		8d 14 f0	sta $f014	                sta io_blk_buffer
.adef		b5 03		lda $03,x	                lda 3,x
.adf1		8d 15 f0	sta $f015	                sta io_blk_buffer+1
.adf4		8c 10 f0	sty $f010	                sty io_blk_action       ; trigger the r/w
.adf7		e8		inx		                inx                     ; clean up stack
.adf8		e8		inx		                inx
.adf9		e8		inx		                inx
.adfa		e8		inx		                inx
.adfb		60		rts		                rts
.adfc						xt_block_ramdrive_init:
.adfc		20 64 d7	jsr $d764	                jsr underflow_1
.adff		20 11 a1	jsr $a111	                jsr sliteral_runtime
>ae02		0a ae 18 01			                .word ramdrive_code, ramdrive_code_end-ramdrive_code
.ae06		20 99 89	jsr $8999	                jsr xt_evaluate
.ae09						z_block_ramdrive_init:
.ae09		60		rts		                rts
.ae0a						ramdrive_code:
>ae0a		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>ae12		77 61 70 20 64 65 63 69 6d 61 6c
>ae1d		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>ae24		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>ae28		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>ae30		20 72 61 6d 64 72 69 76 65
>ae39		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>ae41		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>ae4f		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>ae57		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>ae67		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>ae77		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>ae7f		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>ae8e		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>ae96		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>aea6		31 30 32 34 20 6d 6f 76 65 20 3b
>aeb1		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>aeb9		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>aec9		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>aed9		20 21
>aedb		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>aee3		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>aef3		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>af03		6f 72 20 21
>af07		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>af0f		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>af1f		65 20 21
.af22						ramdrive_code_end:
.af22						xt_block_read:
.af22		a0 32		ldy #$32	                ldy #blockread_offset
.af24		b1 08		lda ($08),y	                lda (up),y
.af26		85 25		sta $25		                sta tmp1
.af28		c8		iny		                iny
.af29		b1 08		lda ($08),y	                lda (up),y
.af2b		85 26		sta $26		                sta tmp1+1
.af2d		6c 25 00	jmp ($0025)	                jmp (tmp1)
.af30						z_block_read:
.af30						xt_block_read_vector:
.af30		a9 32		lda #$32	                lda #blockread_offset
.af32		4c 20 d6	jmp $d620	                jmp push_upvar_tos
.af35						z_block_read_vector:
.af35						xt_block_word_error:
.af35		a9 0c		lda #$0c	                lda #err_blockwords
.af37		4c 7a d7	jmp $d77a	                jmp error       ; no RTS needed
.af3a						z_block_word_error:
.af3a						xt_block_write:
.af3a		a0 34		ldy #$34	                ldy #blockwrite_offset
.af3c		b1 08		lda ($08),y	                lda (up),y
.af3e		85 25		sta $25		                sta tmp1
.af40		c8		iny		                iny
.af41		b1 08		lda ($08),y	                lda (up),y
.af43		85 26		sta $26		                sta tmp1+1
.af45		6c 25 00	jmp ($0025)	                jmp (tmp1)
.af48						z_block_write:
.af48						xt_block_write_vector:
.af48		a9 34		lda #$34	                lda #blockwrite_offset
.af4a		4c 20 d6	jmp $d620	                jmp push_upvar_tos
.af4d						z_block_write_vector:
.af4d						xt_buffblocknum:
.af4d		a9 2e		lda #$2e	                lda #buffblocknum_offset
.af4f		4c 20 d6	jmp $d620	                jmp push_upvar_tos
.af52						z_buffblocknum:
.af52						xt_buffer:
.af52		a0 30		ldy #$30	                ldy #buffstatus_offset
.af54		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.af56		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.af58		d0 0c		bne $af66	                bne _buffer_available ; Unused or not dirty = available
.af5a		20 43 ad	jsr $ad43	                jsr xt_blkbuffer
.af5d		20 4d af	jsr $af4d	                jsr xt_buffblocknum
.af60		20 01 89	jsr $8901	                jsr xt_fetch
.af63		20 3a af	jsr $af3a	                jsr xt_block_write
.af66						_buffer_available:
.af66		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.af68		b5 00		lda $00,x	                lda 0,x
.af6a		91 08		sta ($08),y	                sta (up),y
.af6c		c8		iny		                iny
.af6d		b5 01		lda $01,x	                lda 1,x
.af6f		91 08		sta ($08),y	                sta (up),y
.af71		a9 01		lda #$01	                lda #1
.af73		a0 30		ldy #$30	                ldy #buffstatus_offset
.af75		91 08		sta ($08),y	                sta (up),y
.af77						_done:
.af77		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.af79		b1 08		lda ($08),y	                lda (up),y
.af7b		95 00		sta $00,x	                sta 0,x
.af7d		c8		iny		                iny
.af7e		b1 08		lda ($08),y	                lda (up),y
.af80		95 01		sta $01,x	                sta 1,x
.af82		60		rts		z_buffer:       rts
.af83						xt_buffstatus:
.af83		a9 30		lda #$30	                lda #buffstatus_offset
.af85		4c 20 d6	jmp $d620	                jmp push_upvar_tos
.af88						z_buffstatus:
.af88						xt_empty_buffers:
.af88		a0 30		ldy #$30	                ldy #buffstatus_offset
.af8a		a9 00		lda #$00	                lda #0
.af8c		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.af8e						z_empty_buffers:
.af8e		60		rts		                rts
.af8f						xt_flush:
.af8f		20 ea af	jsr $afea	                jsr xt_save_buffers
.af92		a0 30		ldy #$30	                ldy #buffstatus_offset
.af94		a9 00		lda #$00	                lda #0
.af96		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.af98						z_flush:
.af98		60		rts		                rts
.af99						xt_list:
.af99		20 64 d7	jsr $d764	                jsr underflow_1
.af9c		20 05 b0	jsr $b005	                jsr xt_scr
.af9f		20 37 93	jsr $9337	                jsr xt_store
.afa2		20 a5 b0	jsr $b0a5	                jsr xt_editor_l
.afa5		60		rts		z_list:         rts
.afa6						xt_load:
.afa6		20 64 d7	jsr $d764	                jsr underflow_1
.afa9		a0 05		ldy #$05	                ldy #blk_offset+1
.afab		b1 08		lda ($08),y	                lda (up),y
.afad		48		pha		                pha
.afae		88		dey		                dey
.afaf		b1 08		lda ($08),y	                lda (up),y
.afb1		48		pha		                pha
.afb2		b5 00		lda $00,x	                lda 0,x
.afb4		91 08		sta ($08),y	                sta (up),y
.afb6		c8		iny		                iny
.afb7		b5 01		lda $01,x	                lda 1,x
.afb9		91 08		sta ($08),y	                sta (up),y
.afbb		20 51 ad	jsr $ad51	                jsr xt_block
.afbe		ca		dex		                dex
.afbf		ca		dex		                dex
.afc0		a9 04		lda #$04	                lda #4
.afc2		95 01		sta $01,x	                sta 1,x
.afc4		74 00		stz $00,x	                stz 0,x
.afc6		20 93 89	jsr $8993	                jsr load_evaluate
.afc9		a0 04		ldy #$04	                ldy #blk_offset
.afcb		68		pla		                pla
.afcc		91 08		sta ($08),y	                sta (up),y
.afce		c8		iny		                iny
.afcf		68		pla		                pla
.afd0		91 08		sta ($08),y	                sta (up),y
.afd2		88		dey		                dey
.afd3		11 08		ora ($08),y	                ora (up),y
.afd5		f0 12		beq $afe9	                beq _done
.afd7		ca		dex		                dex
.afd8		ca		dex		                dex
.afd9		a0 04		ldy #$04	                ldy #blk_offset
.afdb		b1 08		lda ($08),y	                lda (up),y
.afdd		95 00		sta $00,x	                sta 0,x
.afdf		c8		iny		                iny
.afe0		b1 08		lda ($08),y	                lda (up),y
.afe2		95 01		sta $01,x	                sta 1,x
.afe4		20 51 ad	jsr $ad51	                jsr xt_block
.afe7		e8		inx		                inx
.afe8		e8		inx		                inx
.afe9						_done:
.afe9		60		rts		z_load:         rts
.afea						xt_save_buffers:
.afea		a0 30		ldy #$30	                ldy #buffstatus_offset
.afec		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.afee		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.aff0		d0 12		bne $b004	                bne _done       ; Either not used or not dirty = done!
.aff2		20 43 ad	jsr $ad43	                jsr xt_blkbuffer
.aff5		20 4d af	jsr $af4d	                jsr xt_buffblocknum
.aff8		20 01 89	jsr $8901	                jsr xt_fetch
.affb		20 3a af	jsr $af3a	                jsr xt_block_write
.affe		a9 01		lda #$01	                lda #1
.b000		a0 30		ldy #$30	                ldy #buffstatus_offset
.b002		91 08		sta ($08),y	                sta (up),y
.b004						_done:
.b004		60		rts		z_save_buffers: rts
.b005						xt_scr:
.b005		a9 06		lda #$06	                lda #scr_offset
.b007		4c 20 d6	jmp $d620	                jmp push_upvar_tos
.b00a						z_scr:
.b00a						xt_thru:
.b00a		20 69 d7	jsr $d769	                jsr underflow_2
.b00d		b5 01		lda $01,x	                lda 1,x
.b00f		48		pha		                pha
.b010		b5 00		lda $00,x	                lda 0,x
.b012		48		pha		                pha
.b013		e8		inx		                inx
.b014		e8		inx		                inx
.b015						_thru_loop:
.b015		b5 01		lda $01,x	                lda 1,x
.b017		48		pha		                pha
.b018		b5 00		lda $00,x	                lda 0,x
.b01a		48		pha		                pha
.b01b		20 a6 af	jsr $afa6	                jsr xt_load
.b01e		68		pla		                pla
.b01f		85 25		sta $25		                sta tmp1
.b021		68		pla		                pla
.b022		85 26		sta $26		                sta tmp1+1
.b024		68		pla		                pla
.b025		85 27		sta $27		                sta tmp2
.b027		68		pla		                pla
.b028		85 28		sta $28		                sta tmp2+1
.b02a		c5 26		cmp $26		                cmp tmp1+1
.b02c		d0 08		bne $b036	                bne _next_screen
.b02e		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b030		c5 25		cmp $25		                cmp tmp1
.b032		d0 02		bne $b036	                bne _next_screen
.b034		80 18		bra $b04e	                bra _done       ; We just did the last screen.
.b036						_next_screen:
.b036		a5 28		lda $28		                lda tmp2+1
.b038		48		pha		                pha
.b039		a5 27		lda $27		                lda tmp2
.b03b		48		pha		                pha
.b03c		e6 25		inc $25		                inc tmp1
.b03e		d0 02		bne $b042	                bne +
.b040		e6 26		inc $26		                inc tmp1+1
.b042						+
.b042		ca		dex		                dex
.b043		ca		dex		                dex
.b044		a5 25		lda $25		                lda tmp1
.b046		95 00		sta $00,x	                sta 0,x
.b048		a5 26		lda $26		                lda tmp1+1
.b04a		95 01		sta $01,x	                sta 1,x
.b04c		80 c7		bra $b015	                bra _thru_loop
.b04e						_done:
.b04e		60		rts		z_thru:         rts
.b04f						xt_update:
.b04f		a0 30		ldy #$30	                ldy #buffstatus_offset
.b051		b1 08		lda ($08),y	                lda (up),y
.b053		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b055		91 08		sta ($08),y	                sta (up),y
.b057		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b058						xt_editor_screen_helper:
.b058		20 42 87	jsr $8742	                jsr xt_dup
.b05b		20 05 b0	jsr $b005	                jsr xt_scr
.b05e		20 37 93	jsr $9337	                jsr xt_store
.b061		20 52 af	jsr $af52	                jsr xt_buffer
.b064						z_editor_screen_helper:
.b064		60		rts		                rts
.b065						xt_editor_enter_screen:
.b065		20 58 b0	jsr $b058	                jsr xt_editor_screen_helper
.b068		20 3c 87	jsr $873c	                jsr xt_drop
.b06b		64 35		stz $35		                stz ed_head
.b06d						_prompt_loop:
.b06d		ca		dex		                dex
.b06e		ca		dex		                dex
.b06f		a5 35		lda $35		                lda ed_head
.b071		95 00		sta $00,x	                sta 0,x
.b073		74 01		stz $01,x	                stz 1,x
.b075		20 38 b1	jsr $b138	                jsr xt_editor_o
.b078		e6 35		inc $35		                inc ed_head
.b07a		a9 10		lda #$10	                lda #16
.b07c		c5 35		cmp $35		                cmp ed_head
.b07e		d0 ed		bne $b06d	                bne _prompt_loop
.b080						z_editor_enter_screen:
.b080		60		rts		                rts
.b081						xt_editor_erase_screen:
.b081		20 58 b0	jsr $b058	                jsr xt_editor_screen_helper
.b084		ca		dex		                dex
.b085		ca		dex		                dex
.b086		74 00		stz $00,x	                stz 0,x
.b088		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b08a		95 01		sta $01,x	                sta 1,x
.b08c		20 99 88	jsr $8899	                jsr xt_blank
.b08f		20 4f b0	jsr $b04f	                jsr xt_update
.b092						z_editor_erase_screen:
.b092		60		rts		                rts
.b093						xt_editor_el:
.b093		20 1f b1	jsr $b11f	                jsr xt_editor_line
.b096		ca		dex		                dex
.b097		ca		dex		                dex
.b098		a9 40		lda #$40	                lda #64
.b09a		95 00		sta $00,x	                sta 0,x
.b09c		74 01		stz $01,x	                stz 1,x
.b09e		20 99 88	jsr $8899	                jsr xt_blank
.b0a1		20 4f b0	jsr $b04f	                jsr xt_update
.b0a4		60		rts		z_editor_el:    rts
.b0a5						xt_editor_l:
.b0a5		ca		dex		                dex             ; Put SCR on the stack.
.b0a6		ca		dex		                dex
.b0a7		a0 06		ldy #$06	                ldy #scr_offset
.b0a9		b1 08		lda ($08),y	                lda (up),y
.b0ab		95 00		sta $00,x	                sta 0,x
.b0ad		c8		iny		                iny
.b0ae		b1 08		lda ($08),y	                lda (up),y
.b0b0		95 01		sta $01,x	                sta 1,x
.b0b2		20 51 ad	jsr $ad51	                jsr xt_block    ; Get the current screen.
.b0b5		20 fa 84	jsr $84fa	                jsr xt_cr
.b0b8		80 08		bra $b0c2	                bra _after_screen_msg
.b0ba						_screen_msg:
>b0ba		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b0c2						_after_screen_msg:
.b0c2		20 11 a1	jsr $a111	                jsr sliteral_runtime
>b0c5		ba b0 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.b0c9		20 d4 95	jsr $95d4	                jsr xt_type
.b0cc		20 05 b0	jsr $b005	                jsr xt_scr
.b0cf		20 01 89	jsr $8901	                jsr xt_fetch
.b0d2		ca		dex		                dex
.b0d3		ca		dex		                dex
.b0d4		a9 04		lda #$04	                lda #4          ; four spaces
.b0d6		95 00		sta $00,x	                sta 0,x
.b0d8		74 01		stz $01,x	                stz 1,x
.b0da		20 0b 96	jsr $960b	                jsr xt_u_dot_r
.b0dd		64 29		stz $29		                stz tmp3
.b0df						_line_loop:
.b0df		20 fa 84	jsr $84fa	                jsr xt_cr
.b0e2		ca		dex		                dex
.b0e3		ca		dex		                dex
.b0e4		ca		dex		                dex
.b0e5		ca		dex		                dex
.b0e6		74 03		stz $03,x	                stz 3,x
.b0e8		a5 29		lda $29		                lda tmp3
.b0ea		95 02		sta $02,x	                sta 2,x
.b0ec		74 01		stz $01,x	                stz 1,x
.b0ee		a9 02		lda #$02	                lda #2
.b0f0		95 00		sta $00,x	                sta 0,x
.b0f2		20 0b 96	jsr $960b	                jsr xt_u_dot_r
.b0f5		20 c8 92	jsr $92c8	                jsr xt_space
.b0f8		20 42 87	jsr $8742	                jsr xt_dup
.b0fb		ca		dex		                dex
.b0fc		ca		dex		                dex
.b0fd		a9 40		lda #$40	                lda #64
.b0ff		95 00		sta $00,x	                sta 0,x
.b101		74 01		stz $01,x	                stz 1,x
.b103		20 d4 95	jsr $95d4	                jsr xt_type
.b106		18		clc		                clc
.b107		a9 40		lda #$40	                lda #64
.b109		75 00		adc $00,x	                adc 0,x
.b10b		95 00		sta $00,x	                sta 0,x
.b10d		90 02		bcc $b111	                bcc +
.b10f		f6 01		inc $01,x	                inc 1,x
.b111						+
.b111		e6 29		inc $29		                inc tmp3
.b113		a5 29		lda $29		                lda tmp3
.b115		c9 10		cmp #$10	                cmp #16
.b117		d0 c6		bne $b0df	                bne _line_loop
.b119		20 fa 84	jsr $84fa	                jsr xt_cr
.b11c		e8		inx		                inx
.b11d		e8		inx		                inx
.b11e		60		rts		z_editor_l:            rts
.b11f						xt_editor_line:
.b11f		20 64 d7	jsr $d764	                jsr underflow_1
.b122		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b124						_shift_tos_left:
.b124		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b126		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b128		88		dey		                dey
.b129		d0 f9		bne $b124	                bne _shift_tos_left
.b12b		20 05 b0	jsr $b005	                jsr xt_scr
.b12e		20 01 89	jsr $8901	                jsr xt_fetch
.b131		20 51 ad	jsr $ad51	                jsr xt_block
.b134		20 56 8f	jsr $8f56	                jsr xt_plus
.b137		60		rts		z_editor_line:  rts
.b138						xt_editor_o:
.b138		20 fa 84	jsr $84fa	                jsr xt_cr
.b13b		20 42 87	jsr $8742	                jsr xt_dup
.b13e		20 57 9d	jsr $9d57	                jsr xt_two
.b141		20 0b 96	jsr $960b	                jsr xt_u_dot_r
.b144		20 c8 92	jsr $92c8	                jsr xt_space
.b147		a9 2a		lda #$2a	                lda #'*'
.b149		20 ac 87	jsr $87ac	                jsr emit_a
.b14c		20 c8 92	jsr $92c8	                jsr xt_space
.b14f		20 1f b1	jsr $b11f	                jsr xt_editor_line
.b152		20 42 87	jsr $8742	                jsr xt_dup      ; Save a copy of the line address for later.
.b155		ca		dex		                dex
.b156		ca		dex		                dex
.b157		a9 40		lda #$40	                lda #64         ; chars/line
.b159		95 00		sta $00,x	                sta 0,x
.b15b		74 01		stz $01,x	                stz 1,x
.b15d		20 e6 80	jsr $80e6	                jsr xt_accept
.b160		20 42 87	jsr $8742	                jsr xt_dup
.b163		20 10 9c	jsr $9c10	                jsr xt_not_rote ; -rot
.b166		20 56 8f	jsr $8f56	                jsr xt_plus
.b169		ca		dex		                dex
.b16a		ca		dex		                dex
.b16b		a9 40		lda #$40	                lda #64         ; chars/line
.b16d		95 00		sta $00,x	                sta 0,x
.b16f		74 01		stz $01,x	                stz 1,x
.b171		20 8e 90	jsr $908e	                jsr xt_rot
.b174		20 e7 8c	jsr $8ce7	                jsr xt_minus
.b177		20 99 88	jsr $8899	                jsr xt_blank
.b17a		20 4f b0	jsr $b04f	                jsr xt_update
.b17d		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b17e						xt_also:
.b17e		20 a9 b1	jsr $b1a9	                jsr xt_get_order
.b181		20 08 8e	jsr $8e08	                jsr xt_over
.b184		20 4d 93	jsr $934d	                jsr xt_swap
.b187		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.b18a		20 b2 b2	jsr $b2b2	                jsr xt_set_order
.b18d		60		rts		z_also:         rts
.b18e						xt_definitions:
.b18e		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b190		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b192		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b194		91 08		sta ($08),y	                sta (up),y
.b196		60		rts		z_definitions:  rts
.b197						xt_forth:
.b197		a0 23		ldy #$23	                ldy #search_order_offset
.b199		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b19b		91 08		sta ($08),y	                sta (up),y
.b19d						z_forth:
.b19d		60		rts		                rts
.b19e						xt_get_current:
.b19e		ca		dex		                dex
.b19f		ca		dex		                dex
.b1a0		a0 08		ldy #$08	                ldy #current_offset
.b1a2		b1 08		lda ($08),y	                lda (up),y
.b1a4		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b1a6		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b1a8		60		rts		z_get_current:  rts
.b1a9						xt_get_order:
.b1a9		a0 22		ldy #$22	                ldy #num_order_offset
.b1ab		b1 08		lda ($08),y	                lda (up),y
.b1ad		85 25		sta $25		                sta tmp1
.b1af		f0 16		beq $b1c7	                beq _done       ; If zero, there are no wordlists.
.b1b1						_loop:
.b1b1		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b1b3		a9 23		lda #$23	                lda #search_order_offset
.b1b5		18		clc		                clc
.b1b6		65 25		adc $25		                adc tmp1
.b1b8		a8		tay		                tay
.b1b9		ca		dex		                dex
.b1ba		ca		dex		                dex
.b1bb		b1 08		lda ($08),y	                lda (up),y
.b1bd		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b1bf		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b1c1		a9 00		lda #$00	                lda #0
.b1c3		c5 25		cmp $25		                cmp tmp1
.b1c5		d0 ea		bne $b1b1	                bne _loop
.b1c7						_done:
.b1c7		ca		dex		                dex
.b1c8		ca		dex		                dex
.b1c9		a0 22		ldy #$22	                ldy #num_order_offset
.b1cb		b1 08		lda ($08),y	                lda (up),y
.b1cd		95 00		sta $00,x	                sta 0,x
.b1cf		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b1d1		60		rts		z_get_order:    rts
.b1d2						xt_only:
.b1d2		20 9f 94	jsr $949f	                jsr xt_true
.b1d5		20 b2 b2	jsr $b2b2	                jsr xt_set_order
.b1d8		60		rts		z_only:         rts
.b1d9						xt_order:
.b1d9		20 fa 84	jsr $84fa	                jsr xt_cr
.b1dc		20 a9 b1	jsr $b1a9	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.b1df		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.b1e1		f0 1e		beq $b201	                beq _drop_done
.b1e3						_have_wordlists:
.b1e3		a8		tay		                tay
.b1e4						_loop:
.b1e4		e8		inx		                inx
.b1e5		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.b1e6		b5 00		lda $00,x	                lda 0,x
.b1e8		5a		phy		                phy
.b1e9		20 04 b2	jsr $b204	                jsr order_print_wid_string   ; internal helper function
.b1ec		7a		ply		                ply
.b1ed		88		dey		                dey
.b1ee		d0 f4		bne $b1e4	                bne _loop
.b1f0		20 c8 92	jsr $92c8	                jsr xt_space
.b1f3		20 c8 92	jsr $92c8	                jsr xt_space
.b1f6		20 9e b1	jsr $b19e	                jsr xt_get_current      ; ( wid )
.b1f9		b5 00		lda $00,x	                lda 0,x
.b1fb		20 04 b2	jsr $b204	                jsr order_print_wid_string
.b1fe		20 fa 84	jsr $84fa	                jsr xt_cr
.b201						_drop_done:
.b201		e8		inx		                inx
.b202		e8		inx		                inx
.b203						z_order:
.b203		60		rts		                rts
.b204						order_print_wid_string:
.b204		c9 04		cmp #$04	                cmp #4
.b206		90 09		bcc $b211	                bcc _output_string      ; less than 4, print a real string
.b208		ca		dex		                dex
.b209		ca		dex		                dex
.b20a		95 00		sta $00,x	                sta 0,x
.b20c		74 01		stz $01,x	                stz 1,x
.b20e		4c ff 95	jmp $95ff	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.b211						_output_string:
.b211		a8		tay		                tay
.b212		b9 18 b2	lda $b218,y	                lda _wid_data,y
.b215		4c a0 d7	jmp $d7a0	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b218						_wid_data:
>b218		04				        .byte str_wid_forth            ; WID 0: "Forth"
>b219		05				        .byte str_wid_editor           ; WID 1: "Editor"
>b21a		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>b21b		07				        .byte str_wid_root             ; WID 3: "Root"
.b21c						xt_previous:
.b21c		20 a9 b1	jsr $b1a9	                jsr xt_get_order
.b21f		20 33 8d	jsr $8d33	                jsr xt_nip
.b222		20 e0 8d	jsr $8de0	                jsr xt_one_minus
.b225		20 b2 b2	jsr $b2b2	                jsr xt_set_order
.b228		60		rts		z_previous:     rts
.b229						xt_root_wordlist:
.b229		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b22a		ca		dex		                dex
.b22b		a9 03		lda #$03	                lda #3
.b22d		95 00		sta $00,x	                sta 0,x
.b22f		74 01		stz $01,x	                stz 1,x
.b231						z_root_wordlist:
.b231		60		rts		                rts
.b232						xt_search_wordlist:
.b232		20 6e d7	jsr $d76e	                jsr underflow_3
.b235		a5 08		lda $08		                lda up
.b237		18		clc		                clc
.b238		69 0a		adc #$0a	                adc #wordlists_offset
.b23a		85 27		sta $27		                sta tmp2
.b23c		a5 09		lda $09		                lda up+1
.b23e		69 00		adc #$00	                adc #0          ; Adding carry
.b240		85 28		sta $28		                sta tmp2+1
.b242		b5 00		lda $00,x	                lda 0,x
.b244		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b245		65 27		adc $27		                adc tmp2
.b247		85 27		sta $27		                sta tmp2
.b249		90 02		bcc $b24d	                bcc +
.b24b		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b24d						+
.b24d		e8		inx		                inx
.b24e		e8		inx		                inx
.b24f		b5 00		lda $00,x	                lda 0,x
.b251		15 01		ora $01,x	                ora 1,x
.b253		f0 4e		beq $b2a3	                beq _done
.b255		a5 27		lda $27		                lda tmp2
.b257		05 28		ora $28		                ora tmp2+1
.b259		f0 48		beq $b2a3	                beq _done
.b25b		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b25d		85 25		sta $25		                sta tmp1
.b25f		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b261		d0 02		bne $b265	                bne +
.b263		e6 28		inc $28		                inc tmp2+1
.b265						+
.b265		b2 27		lda ($27)	                lda (tmp2)
.b267		85 26		sta $26		                sta tmp1+1
.b269		20 46 d6	jsr $d646	                jsr find_header_name
.b26c		f0 31		beq $b29f	                beq _fail_done
.b26e		e8		inx		                inx
.b26f		e8		inx		                inx
.b270		a5 25		lda $25		                lda tmp1
.b272		95 00		sta $00,x	                sta 0,x
.b274		a5 26		lda $26		                lda tmp1+1
.b276		95 01		sta $01,x	                sta 1,x
.b278		20 42 87	jsr $8742	                jsr xt_dup              ; ( nt nt )
.b27b		20 c9 9b	jsr $9bc9	                jsr xt_name_to_int      ; ( nt xt )
.b27e		20 4d 93	jsr $934d	                jsr xt_swap             ; ( xt nt )
.b281		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b283		f6 00		inc $00,x	                inc 0,x
.b285		d0 02		bne $b289	                bne +
.b287		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b289						+
.b289		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b28b		29 04		and #$04	                and #IM
.b28d		d0 08		bne $b297	                bne _immediate          ; bit set, we're immediate
.b28f		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b291		95 00		sta $00,x	                sta 0,x
.b293		95 01		sta $01,x	                sta 1,x
.b295		80 0e		bra $b2a5	                bra _done_nodrop
.b297						_immediate:
.b297		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b299		95 00		sta $00,x	                sta 0,x
.b29b		74 01		stz $01,x	                stz 1,x
.b29d		80 06		bra $b2a5	                bra _done_nodrop
.b29f						_fail_done:
.b29f		74 02		stz $02,x	                stz 2,x         ; failure flag
.b2a1		74 03		stz $03,x	                stz 3,x
.b2a3						_done:
.b2a3		e8		inx		                inx
.b2a4		e8		inx		                inx
.b2a5						_done_nodrop:
.b2a5						z_search_wordlist:
.b2a5		60		rts		                rts
.b2a6						xt_set_current:
.b2a6		20 64 d7	jsr $d764	                jsr underflow_1
.b2a9		a0 08		ldy #$08	                ldy #current_offset
.b2ab		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b2ad		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b2af		e8		inx		                inx
.b2b0		e8		inx		                inx
.b2b1		60		rts		z_set_current:  rts
.b2b2						xt_set_order:
.b2b2		a9 ff		lda #$ff	                lda #$FF
.b2b4		d5 01		cmp $01,x	                cmp 1,x
.b2b6		d0 12		bne $b2ca	                bne _start
.b2b8		d5 00		cmp $00,x	                cmp 0,x
.b2ba		d0 0e		bne $b2ca	                bne _start
.b2bc		ca		dex		                dex             ; Make room for the count.
.b2bd		ca		dex		                dex
.b2be		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b2c0		a9 03		lda #$03	                lda #3
.b2c2		95 02		sta $02,x	                sta 2,x
.b2c4		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b2c6		a9 01		lda #$01	                lda #1
.b2c8		95 00		sta $00,x	                sta 0,x
.b2ca						_start:
.b2ca		a0 22		ldy #$22	                ldy #num_order_offset
.b2cc		b5 00		lda $00,x	                lda 0,x
.b2ce		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b2d0		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b2d2		e8		inx		                inx             ; Drop the count off the data stack.
.b2d3		e8		inx		                inx
.b2d4		a5 25		lda $25		                lda tmp1
.b2d6		f0 0d		beq $b2e5	                beq _done       ; If zero, there are no wordlists.
.b2d8		a0 23		ldy #$23	                ldy #search_order_offset
.b2da						_loop:
.b2da		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b2dc		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b2de		c8		iny		                iny
.b2df		e8		inx		                inx
.b2e0		e8		inx		                inx
.b2e1		c6 25		dec $25		                dec tmp1
.b2e3		d0 f5		bne $b2da	                bne _loop
.b2e5						_done:
.b2e5		60		rts		z_set_order:    rts
.b2e6						xt_to_order:
.b2e6		20 8b 94	jsr $948b	                jsr xt_to_r
.b2e9		20 a9 b1	jsr $b1a9	                jsr xt_get_order
.b2ec		20 f1 8f	jsr $8ff1	                jsr xt_r_from
.b2ef		20 4d 93	jsr $934d	                jsr xt_swap
.b2f2		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.b2f5		20 b2 b2	jsr $b2b2	                jsr xt_set_order
.b2f8		60		rts		z_to_order:     rts
.b2f9						xt_wordlist:
.b2f9		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b2fb		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b2fd		c9 0c		cmp #$0c	                cmp #max_wordlists
.b2ff		d0 05		bne $b306	                bne _ok
.b301		a9 0b		lda #$0b	                lda #err_wordlist
.b303		4c 7a d7	jmp $d77a	                jmp error
.b306						_ok:
.b306		1a		inc a		                ina             ; Increment the wordlist#
.b307		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b309		ca		dex		                dex             ; and put it on the stack.
.b30a		ca		dex		                dex
.b30b		95 00		sta $00,x	                sta 0,x
.b30d		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b30f		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7             ; initial Data Stack Pointer
.b310						cold_zp_table:
>b310	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b312	0002	e0 ba				dp:         .word dictionary_start  ; Dictionary Pointer
>b314	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b316	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b318	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b31a	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b31c	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b31e	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b320	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b322	0012	2d f0				output:     .word kernel_putc       ; vector for EMIT
>b324	0014	27 f0				input:      .word kernel_getc       ; vector for KEY
>b326	0016	00 00				havekey:    .word 0                 ; vector for KEY?
>b328	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b32a	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b32c	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>b32e	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b32f	001f					loopctrl:   .byte ?         ; Offset and flags for DO/LOOP/+LOOP control.
>b330	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$100						lcbstack = $100
=256						loopindex = lcbstack+0      ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack+2      ; loop control block offset for limit fudge factor
>b331	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b333	0023					tmptos:     .word ?         ; temporary TOS storage
>b335	0025					tmp1:       .word ?         ; temporary storage
>b337	0027					tmp2:       .word ?         ; temporary storage
>b339	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b33b	002b					tohold:     .word ?         ; pointer for formatted output
>b33d	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b345	0035					tmped:      .word ?,?,?     ; temporary for editors
.b32e						cold_zp_table_end:
.b32e						cold_user_table:
>b32e	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b330	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b332	0004	00 00				blk_offset:             .word 0         ; BLK
>b334	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
.b336	0008					marker_start_offset:
>b336	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b337	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b338	000a					wordlists_offset:
>b338	000a	e0 ba				    .word dictionary_start              ; FORTH-WORDLIST
>b33a	000c	3f c9				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b33c	000e	8f c9				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b33e	0010	fe c8				    .word root_dictionary_start         ; ROOT-WORDLIST
>b340	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b348	001a	00 00 00 00 00 00 00 00
>b350	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b351	0023					search_order_offset:
>b351	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b359	002b	00
.b35a	002c					marker_end_offset:
>b35a	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b35c	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b35e	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b360	0032	35 af				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b362	0034	35 af				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b364						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b364						oc_index_table:
>b364		64 b5 68 b5 fc b9 fc b9		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>b36c		70 b5 76 b5 7c b5 fc b9
>b374		82 b5 86 b5 8c b5 fc b9		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b37c		92 b5 96 b5 9a b5 9e b5
>b384		a3 b5 a7 b5 af b5 fc b9		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b38c		b6 b5 bc b5 c3 b5 ca b5
>b394		d1 b5 d5 b5 db b5 fc b9		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc__, oc1F
>b39c		e1 b5 e5 b5 fc b9 eb b5
>b3a4		f1 b5 f5 b5 fc b9 fc b9		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b3ac		fd b5 03 b6 09 b6 0f b6
>b3b4		16 b6 1a b6 20 b6 fc b9		        .word oc28, oc29, oc2A, oc__, OC2C, oc2D, oc2E, oc2F
>b3bc		26 b6 2a b6 2f b6 33 b6
>b3c4		38 b6 3c b6 44 b6 fc b9		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b3cc		4b b6 53 b6 5a b6 61 b6
>b3d4		68 b6 6c b6 72 b6 fc b9		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc0F
>b3dc		78 b6 7e b6 84 b6 9e b5
>b3e4		8f b6 93 b6 fc b9 fc b9		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b3ec		fc b9 9b b6 a1 b6 a7 b6
>b3f4		ae b6 b2 b6 b8 b6 fc b9		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b3fc		be b6 c2 b6 c6 b6 ca b6
>b404		cf b6 d3 b6 db b6 fc b9		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b40c		fc b9 e2 b6 e9 b6 f0 b6
>b414		f7 b6 fb b6 01 b7 fc b9		        .word oc58, oc59, oc5A, oc__, oc__, oc__, oc5E, oc5F
>b41c		fc b9 fc b9 0b b7 11 b7
>b424		16 b7 1a b7 fc b9 fc b9		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b42c		22 b7 28 b7 2e b7 34 b7
>b434		3b b7 3f b7 45 b7 fc b9		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b43c		4b b7 51 b7 55 b7 59 b7
>b444		5e b7 62 b7 6a b7 fc b9		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b44c		71 b7 78 b7 7f b7 86 b7
>b454		8d b7 91 b7 97 b7 fc b9		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b45c		9b b7 a2 b7 a8 b7 ae b7
>b464		b3 b7 b7 b7 fc b9 fc b9		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b46c		bf b7 c5 b7 cb b7 fc b9
>b474		d1 b7 d5 b7 db b7 fc b9		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b47c		df b7 e3 b7 e7 b7 eb b7
>b484		f0 b7 f4 b7 fc b7 fc b9		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b48c		03 b8 0a b8 11 b8 18 b8
>b494		1f b8 23 b8 29 b8 fc b9		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b49c		2d b8 31 b8 37 b8 3d b8
>b4a4		42 b8 48 b8 50 b8 fc b9		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b4ac		56 b8 5c b8 62 b8 68 b8
>b4b4		6f b8 73 b8 79 b8 fc b9		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b4bc		7d b8 81 b8 85 b8 89 b8
>b4c4		8e b8 92 b8 9a b8 fc b9		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b4cc		a1 b8 a8 b8 af b8 b6 b8
>b4d4		bd b8 c1 b8 c7 b8 fc b9		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b4dc		cb b8 d1 b8 d7 b8 dd b8
>b4e4		e2 b8 e8 b8 fc b9 fc b9		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b4ec		f0 b8 f6 b8 fc b8 02 b9
>b4f4		09 b9 0d b9 13 b9 fc b9		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b4fc		17 b9 1b b9 1f b9 23 b9
>b504		28 b9 2c b9 34 b9 fc b9		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b50c		fc b9 3b b9 42 b9 49 b9
>b514		50 b9 54 b9 5a b9 fc b9		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b51c		fc b9 5e b9 64 b9 6a b9
>b524		6f b9 75 b9 fc b9 fc b9		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b52c		7d b9 83 b9 89 b9 8f b9
>b534		96 b9 9a b9 a0 b9 fc b9		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b53c		a4 b9 a8 b9 ac b9 b0 b9
>b544		b5 b9 b9 b9 c1 b9 fc b9		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b54c		fc b9 c8 b9 cf b9 d6 b9
>b554		dd b9 e1 b9 e7 b9 fc b9		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b55c		fc b9 eb b9 f1 b9 f7 b9
.b564						oc_table:
>b564		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b568		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b570		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b576		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b57c		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b582		43 70 68 70				oc08:	.text 1*64+3, "php"
>b586		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b58c		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b592		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b596		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b59a		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b59e		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b5a3		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b5a7		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b5af		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b5b6		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b5bc		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b5c3		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b5ca		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b5d1		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b5d5		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b5db		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b5e1		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b5e5		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b5eb		c5 61 73 6c 2e 78			oc1F:	.text 3*64+5, "asl.x"
>b5f1		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b5f5		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b5fd		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b603		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b609		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b60f		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b616		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b61a		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b620		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b626		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b62a		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b62f		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b633		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b638		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b63c		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b644		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b64b		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b653		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b65a		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b661		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b668		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b66c		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b672		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b678		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b67e		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b684		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b68a		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b68f		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b693		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b69b		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b6a1		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b6a7		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b6ae		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b6b2		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b6b8		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b6be		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b6c2		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b6c6		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b6ca		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b6cf		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b6d3		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b6db		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b6e2		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b6e9		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b6f0		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b6f7		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b6fb		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b701		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b705		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b70b		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b711		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b716		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b71a		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b722		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b728		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b72e		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b734		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b73b		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b73f		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b745		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b74b		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b751		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b755		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b759		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b75e		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b762		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b76a		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b771		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b778		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b77f		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b786		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b78d		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b791		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b797		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b79b		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b7a2		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b7a8		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b7ae		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b7b3		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b7b7		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b7bf		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b7c5		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b7cb		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b7d1		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b7d5		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b7db		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b7df		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b7e3		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b7e7		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b7eb		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b7f0		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b7f4		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b7fc		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b803		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b80a		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b811		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b818		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b81f		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b823		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b829		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b82d		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b831		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b837		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b83d		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b842		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b848		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b850		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b856		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b85c		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b862		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b868		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b86f		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b873		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b879		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b87d		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b881		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b885		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b889		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b88e		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b892		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b89a		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b8a1		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b8a8		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b8af		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b8b6		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b8bd		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b8c1		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b8c7		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b8cb		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b8d1		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b8d7		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b8dd		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b8e2		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b8e8		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b8f0		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b8f6		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b8fc		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b902		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b909		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b90d		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b913		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>b917		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>b91b		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>b91f		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>b923		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>b928		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>b92c		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>b934		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>b93b		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>b942		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>b949		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>b950		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>b954		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>b95a		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>b95e		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>b964		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>b96a		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>b96f		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>b975		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>b97d		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>b983		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>b989		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>b98f		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>b996		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>b99a		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>b9a0		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>b9a4		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>b9a8		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>b9ac		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>b9b0		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>b9b5		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>b9b9		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>b9c1		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>b9c8		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>b9cf		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>b9d6		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>b9dd		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>b9e1		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>b9e7		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>b9eb		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>b9f1		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>b9f7		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>b9fc		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.b9fe						forth_words_start:
>b9fe		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>ba06		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>ba16		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>ba26		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>ba36		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>ba46		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>ba56		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>ba66		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>ba76		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>ba86		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>ba96		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>baa6		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bab6		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bac6		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bad6		78 69 74 29 20 63 72 20
.bade						forth_words_end:
.bade						user_words_start:
>bade		20 20				.binary "user_words.asc"
.bae0						user_words_end:

;******  Processing file: platform/../headers.asm

.bae0						dictionary_start:
.bae0						nt_drop:
>bae0		04 10				        .byte 4, UF
>bae2		ec ba 3c 87 41 87		        .word nt_dup, xt_drop, z_drop
>bae8		64 72 6f 70			        .text "drop"
.baec						nt_dup:
>baec		03 10				        .byte 3, UF
>baee		f7 ba 42 87 4f 87		        .word nt_swap, xt_dup, z_dup
>baf4		64 75 70			        .text "dup"
.baf7						nt_swap:
>baf7		04 10				        .byte 4, UF
>baf9		03 bb 4d 93 60 93		        .word nt_store, xt_swap, z_swap
>baff		73 77 61 70			        .text "swap"
.bb03						nt_store:
>bb03		01 10				        .byte 1, UF
>bb05		0c bb 37 93 4c 93		        .word nt_fetch, xt_store, z_store
>bb0b		21				        .text "!"
.bb0c						nt_fetch:
>bb0c		01 10				        .byte 1, UF
>bb0e		15 bb 01 89 13 89		        .word nt_over, xt_fetch, z_fetch
>bb14		40				        .text "@"
.bb15						nt_over:
>bb15		04 10				        .byte 4, UF
>bb17		21 bb 08 8e 15 8e		        .word nt_to_r, xt_over, z_over
>bb1d		6f 76 65 72			        .text "over"
.bb21						nt_to_r:
>bb21		02 11				        .byte 2, CO+UF ; native is special case
>bb23		2b bb 8b 94 9e 94		        .word nt_r_from, xt_to_r, z_to_r
>bb29		3e 72				        .text ">r"
.bb2b						nt_r_from:
>bb2b		02 01				        .byte 2, CO    ; native is special case
>bb2d		35 bb f1 8f 01 90		        .word nt_r_fetch, xt_r_from, z_r_from
>bb33		72 3e				        .text "r>"
.bb35						nt_r_fetch:
>bb35		02 01				        .byte 2, CO    ; native is special case
>bb37		3f bb dc 8f f0 8f		        .word nt_nip, xt_r_fetch, z_r_fetch
>bb3d		72 40				        .text "r@"
.bb3f						nt_nip:
>bb3f		03 10				        .byte 3, UF
>bb41		4a bb 33 8d 40 8d		        .word nt_rot, xt_nip, z_nip
>bb47		6e 69 70			        .text "nip"
.bb4a						nt_rot:
>bb4a		03 10				        .byte 3, UF
>bb4c		55 bb 8e 90 a9 90		        .word nt_not_rote, xt_rot, z_rot
>bb52		72 6f 74			        .text "rot"
.bb55						nt_not_rote:
>bb55		04 10				        .byte 4, UF
>bb57		61 bb 10 9c 2b 9c		        .word nt_tuck, xt_not_rote, z_not_rote
>bb5d		2d 72 6f 74			        .text "-rot"
.bb61						nt_tuck:
>bb61		04 10				        .byte 4, UF
>bb63		6d bb a8 94 c1 94		        .word nt_comma, xt_tuck, z_tuck
>bb69		74 75 63 6b			        .text "tuck"
.bb6d						nt_comma:
>bb6d		01 10				        .byte 1, UF
>bb6f		76 bb cf 83 dd 83		        .word nt_c_fetch, xt_comma, z_comma
>bb75		2c				        .text ","
.bb76						nt_c_fetch:
>bb76		02 10				        .byte 2, UF
>bb78		80 bb 2f 83 38 83		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bb7e		63 40				        .text "c@"
.bb80						nt_c_store:
>bb80		02 10				        .byte 2, UF
>bb82		8a bb 39 83 44 83		        .word nt_plus_store, xt_c_store, z_c_store
>bb88		63 21				        .text "c!"
.bb8a						nt_plus_store:
>bb8a		02 10				        .byte 2, UF
>bb8c		94 bb 69 8f 88 8f		        .word nt_execute, xt_plus_store, z_plus_store
>bb92		2b 21				        .text "+!"
.bb94						nt_execute:
>bb94		07 10				        .byte 7, UF
>bb96		a3 bb ec 88 f2 88		        .word nt_emit, xt_execute, z_execute
>bb9c		65 78 65 63 75 74 65		        .text "execute"
.bba3						nt_emit:
>bba3		04 18				        .byte 4, NN+UF
>bba5		af bb a5 87 af 87		        .word nt_type, xt_emit, z_emit
>bbab		65 6d 69 74			        .text "emit"
.bbaf						nt_type:
>bbaf		04 10				        .byte 4, UF
>bbb1		bb bb d4 95 fe 95		        .word nt_dot, xt_type, z_type
>bbb7		74 79 70 65			        .text "type"
.bbbb						nt_dot:
>bbbb		01 10				        .byte 1, UF
>bbbd		c4 bb d2 86 f3 86		        .word nt_u_dot, xt_dot, z_dot
>bbc3		2e				        .text "."
.bbc4						nt_u_dot:
>bbc4		02 10				        .byte 2, UF
>bbc6		ce bb ff 95 0a 96		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bbcc		75 2e				        .text "u."
.bbce						nt_u_dot_r:
>bbce		03 10				        .byte 3, UF
>bbd0		d9 bb 0b 96 2c 96		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bbd6		75 2e 72			        .text "u.r"
.bbd9						nt_dot_r:
>bbd9		02 10				        .byte 2, UF
>bbdb		e3 bb 0e 87 3b 87		        .word nt_d_dot, xt_dot_r, z_dot_r
>bbe1		2e 72				        .text ".r"
.bbe3						nt_d_dot:
>bbe3		02 10				        .byte 2, UF
>bbe5		ed bb 15 9e 33 9e		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bbeb		64 2e				        .text "d."
.bbed						nt_d_dot_r:
>bbed		03 10				        .byte 3, UF
>bbef		f8 bb 34 9e 5e 9e		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bbf5		64 2e 72			        .text "d.r"
.bbf8						nt_ud_dot:
>bbf8		03 10				        .byte 3, UF
>bbfa		03 bc ab 9e bd 9e		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bc00		75 64 2e			        .text "ud."
.bc03						nt_ud_dot_r:
>bc03		04 10				        .byte 4, UF
>bc05		0f bc be 9e dc 9e		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bc0b		75 64 2e 72			        .text "ud.r"
.bc0f						nt_question:
>bc0f		01 00				        .byte 1, 0
>bc11		18 bc b7 98 bd 98		        .word nt_false, xt_question, z_question
>bc17		3f				        .text "?"
.bc18						nt_false:
>bc18		05 00				        .byte 5, 0
>bc1a		25 bc 8c 9d 92 9d		        .word nt_true, xt_false, z_false
>bc20		66 61 6c 73 65			        .text "false"
.bc25						nt_true:
>bc25		04 00				        .byte 4, 0
>bc27		31 bc 9f 94 a7 94		        .word nt_space, xt_true, z_true
>bc2d		74 72 75 65			        .text "true"
.bc31						nt_space:
>bc31		05 00				        .byte 5, 0
>bc33		3e bc c8 92 cd 92		        .word nt_zero, xt_space, z_space
>bc39		73 70 61 63 65			        .text "space"
.bc3e						nt_zero:
>bc3e		01 00				        .byte 1, 0
>bc40		47 bc 8c 9d 92 9d		        .word nt_one, xt_zero, z_zero
>bc46		30				        .text "0"
.bc47						nt_one:
>bc47		01 00				        .byte 1, 0
>bc49		50 bc 26 9d 2e 9d		        .word nt_two, xt_one, z_one
>bc4f		31				        .text "1"
.bc50						nt_two:
>bc50		01 00				        .byte 1, 0
>bc52		59 bc 57 9d 5f 9d		        .word nt_two_dup, xt_two, z_two
>bc58		32				        .text "2"
.bc59						nt_two_dup:
>bc59		04 10				        .byte 4, UF
>bc5b		65 bc ca 94 e1 94		        .word nt_question_dup, xt_two_dup, z_two_dup
>bc61		32 64 75 70			        .text "2dup"
.bc65						nt_question_dup:
>bc65		04 10				        .byte 4, UF
>bc67		71 bc c8 8f db 8f		        .word nt_plus, xt_question_dup, z_question_dup
>bc6d		3f 64 75 70			        .text "?dup"
.bc71						nt_plus:
>bc71		01 10				        .byte 1, UF
>bc73		7a bc 56 8f 68 8f		        .word nt_minus, xt_plus, z_plus
>bc79		2b				        .text "+"
.bc7a						nt_minus:
>bc7a		01 10				        .byte 1, UF
>bc7c		83 bc e7 8c f9 8c		        .word nt_one_minus, xt_minus, z_minus
>bc82		2d				        .text "-"
.bc83						nt_one_minus:
>bc83		02 10				        .byte 2, UF
>bc85		8d bc e0 8d eb 8d		        .word nt_one_plus, xt_one_minus, z_one_minus
>bc8b		31 2d				        .text "1-"
.bc8d						nt_one_plus:
>bc8d		02 10				        .byte 2, UF
>bc8f		97 bc ec 8d f5 8d		        .word nt_two_star, xt_one_plus, z_one_plus
>bc95		31 2b				        .text "1+"
.bc97						nt_two_star:
>bc97		02 10				        .byte 2, UF
>bc99		a1 bc 62 95 69 95		        .word nt_two_slash, xt_two_star, z_two_star
>bc9f		32 2a				        .text "2*"
.bca1						nt_two_slash:
>bca1		02 10				        .byte 2, UF
>bca3		ab bc 57 95 61 95		        .word nt_abs, xt_two_slash, z_two_slash
>bca9		32 2f				        .text "2/"
.bcab						nt_abs:
>bcab		03 10				        .byte 3, UF
>bcad		b6 bc d1 80 e5 80		        .word nt_dabs, xt_abs, z_abs
>bcb3		61 62 73			        .text "abs"
.bcb6						nt_dabs:
>bcb6		04 10				        .byte 4, UF
>bcb8		c2 bc db 9d f9 9d		        .word nt_and, xt_dabs, z_dabs
>bcbe		64 61 62 73			        .text "dabs"
.bcc2						nt_and:
>bcc2		03 10				        .byte 3, UF
>bcc4		cd bc 92 82 a3 82		        .word nt_or, xt_and, z_and
>bcca		61 6e 64			        .text "and"
.bccd						nt_or:
>bccd		02 10				        .byte 2, UF
>bccf		d7 bc f6 8d 07 8e		        .word nt_xor, xt_or, z_or
>bcd5		6f 72				        .text "or"
.bcd7						nt_xor:
>bcd7		03 10				        .byte 3, UF
>bcd9		e2 bc 9d 97 ae 97		        .word nt_rshift, xt_xor, z_xor
>bcdf		78 6f 72			        .text "xor"
.bce2						nt_rshift:
>bce2		06 10				        .byte 6, UF
>bce4		f0 bc aa 90 bd 90		        .word nt_lshift, xt_rshift, z_rshift
>bcea		72 73 68 69 66 74		        .text "rshift"
.bcf0						nt_lshift:
>bcf0		06 10				        .byte 6, UF
>bcf2		fe bc 10 8c 23 8c		        .word nt_pick, xt_lshift, z_lshift
>bcf8		6c 73 68 69 66 74		        .text "lshift"
.bcfe						nt_pick:
>bcfe		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bd00		0a bd 45 8f 55 8f		        .word nt_char, xt_pick, z_pick
>bd06		70 69 63 6b			        .text "pick"
.bd0a						nt_char:
>bd0a		04 00				        .byte 4, 0
>bd0c		16 bd 55 83 6b 83		        .word nt_bracket_char, xt_char, z_char
>bd12		63 68 61 72			        .text "char"
.bd16						nt_bracket_char:
>bd16		06 05				        .byte 6, CO+IM
>bd18		24 bd 0f 83 15 83		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bd1e		5b 63 68 61 72 5d		        .text "[char]"
.bd24						nt_char_plus:
>bd24		05 00				        .byte 5, 0
>bd26		31 bd ec 8d f5 8d		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bd2c		63 68 61 72 2b			        .text "char+"
.bd31						nt_chars:
>bd31		05 10				        .byte 5, UF     ; deleted during compile
>bd33		3e bd 6c 83 6f 83		        .word nt_cells, xt_chars, z_chars
>bd39		63 68 61 72 73			        .text "chars"
.bd3e						nt_cells:
>bd3e		05 00				        .byte 5, 0
>bd40		4b bd 62 95 69 95		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bd46		63 65 6c 6c 73			        .text "cells"
.bd4b						nt_cell_plus:
>bd4b		05 10				        .byte 5, UF
>bd4d		58 bd 45 83 54 83		        .word nt_here, xt_cell_plus, z_cell_plus
>bd53		63 65 6c 6c 2b			        .text "cell+"
.bd58						nt_here:
>bd58		04 00				        .byte 4, 0
>bd5a		64 bd 02 8a 0c 8a		        .word nt_equal, xt_here, z_here
>bd60		68 65 72 65			        .text "here"
.bd64						nt_equal:
>bd64		01 10				        .byte 1, UF
>bd66		6d bd 7d 88 98 88		        .word nt_not_equals, xt_equal, z_equal
>bd6c		3d				        .text "="
.bd6d						nt_not_equals:
>bd6d		02 10				        .byte 2, UF
>bd6f		77 bd 41 8d 5e 8d		        .word nt_less_than, xt_not_equals, z_not_equals
>bd75		3c 3e				        .text "<>"
.bd77						nt_less_than:
>bd77		01 10				        .byte 1, UF
>bd79		80 bd 06 8b 1a 8b		        .word nt_u_less_than, xt_less_than, z_less_than
>bd7f		3c				        .text "<"
.bd80						nt_u_less_than:
>bd80		02 10				        .byte 2, UF
>bd82		8a bd 43 96 58 96		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bd88		75 3c				        .text "u<"
.bd8a						nt_u_greater_than:
>bd8a		02 10				        .byte 2, UF
>bd8c		94 bd 2d 96 42 96		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bd92		75 3e				        .text "u>"
.bd94						nt_greater_than:
>bd94		01 10				        .byte 1, UF
>bd96		9d bd ed 89 01 8a		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bd9c		3e				        .text ">"
.bd9d						nt_zero_equal:
>bd9d		02 10				        .byte 2, UF
>bd9f		a7 bd af 97 c0 97		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bda5		30 3d				        .text "0="
.bda7						nt_zero_unequal:
>bda7		03 10				        .byte 3, UF
>bda9		b2 bd e5 97 f4 97		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bdaf		30 3c 3e			        .text "0<>"
.bdb2						nt_zero_greater:
>bdb2		02 10				        .byte 2, UF
>bdb4		bc bd c1 97 d4 97		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bdba		30 3e				        .text "0>"
.bdbc						nt_zero_less:
>bdbc		02 10				        .byte 2, UF
>bdbe		c6 bd d5 97 e4 97		        .word nt_min, xt_zero_less, z_zero_less
>bdc4		30 3c				        .text "0<"
.bdc6						nt_min:
>bdc6		03 10				        .byte 3, UF
>bdc8		d1 bd cb 8c e6 8c		        .word nt_max, xt_min, z_min
>bdce		6d 69 6e			        .text "min"
.bdd1						nt_max:
>bdd1		03 10				        .byte 3, UF
>bdd3		dc bd af 8c ca 8c		        .word nt_two_drop, xt_max, z_max
>bdd9		6d 61 78			        .text "max"
.bddc						nt_two_drop:
>bddc		05 10				        .byte 5, UF
>bdde		e9 bd c2 94 c9 94		        .word nt_two_swap, xt_two_drop, z_two_drop
>bde4		32 64 72 6f 70			        .text "2drop"
.bde9						nt_two_swap:
>bde9		05 10				        .byte 5, UF
>bdeb		f6 bd 90 95 b3 95		        .word nt_two_over, xt_two_swap, z_two_swap
>bdf1		32 73 77 61 70			        .text "2swap"
.bdf6						nt_two_over:
>bdf6		05 10				        .byte 5, UF
>bdf8		03 be 04 95 1b 95		        .word nt_two_store, xt_two_over, z_two_over
>bdfe		32 6f 76 65 72			        .text "2over"
.be03						nt_two_store:
>be03		02 10				        .byte 2, UF
>be05		0d be 6a 95 8f 95		        .word nt_two_fetch, xt_two_store, z_two_store
>be0b		32 21				        .text "2!"
.be0d						nt_two_fetch:
>be0d		02 10				        .byte 2, UF
>be0f		17 be e2 94 03 95		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>be15		32 40				        .text "2@"
.be17						nt_two_variable:
>be17		09 00				        .byte 9, 0
>be19		28 be 9c 9e aa 9e		        .word nt_two_constant, xt_two_variable, z_two_variable
>be1f		32 76 61 72 69 61 62 6c		        .text "2variable"
>be27		65
.be28						nt_two_constant:
>be28		09 10				        .byte 9, UF
>be2a		39 be 5f 9e 83 9e		        .word nt_two_literal, xt_two_constant, z_two_constant
>be30		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>be38		74
.be39						nt_two_literal:
>be39		08 14				        .byte 8, UF+IM
>be3b		49 be 84 9e 9b 9e		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>be41		32 6c 69 74 65 72 61 6c		        .text "2literal"
.be49						nt_two_r_fetch:
>be49		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>be4b		54 be 1c 95 39 95		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>be51		32 72 40			        .text "2r@"
.be54						nt_two_r_from:
>be54		03 01				        .byte 3, CO             ; native is special case
>be56		5f be 3a 95 56 95		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>be5c		32 72 3e			        .text "2r>"
.be5f						nt_two_to_r:
>be5f		03 11				        .byte 3, CO+UF          ; native is special case
>be61		6a be b4 95 d3 95		        .word nt_invert, xt_two_to_r, z_two_to_r
>be67		32 3e 72			        .text "2>r"
.be6a						nt_invert:
>be6a		06 10				        .byte 6, UF
>be6c		78 be 8d 8a 9c 8a		        .word nt_negate, xt_invert, z_invert
>be72		69 6e 76 65 72 74		        .text "invert"
.be78						nt_negate:
>be78		06 10				        .byte 6, UF
>be7a		86 be 22 8d 32 8d		        .word nt_dnegate, xt_negate, z_negate
>be80		6e 65 67 61 74 65		        .text "negate"
.be86						nt_dnegate:
>be86		07 10				        .byte 7, UF
>be88		95 be fa 9d 14 9e		        .word nt_c_comma, xt_dnegate, z_dnegate
>be8e		64 6e 65 67 61 74 65		        .text "dnegate"
.be95						nt_c_comma:
>be95		02 10				        .byte 2, UF
>be97		9f be 24 83 2e 83		        .word nt_bounds, xt_c_comma, z_c_comma
>be9d		63 2c				        .text "c,"
.be9f						nt_bounds:
>be9f		06 10				        .byte 6, UF
>bea1		ad be c9 99 e1 99		        .word nt_spaces, xt_bounds, z_bounds
>bea7		62 6f 75 6e 64 73		        .text "bounds"
.bead						nt_spaces:
>bead		06 10				        .byte 6, UF
>beaf		bb be ce 92 09 93		        .word nt_bl, xt_spaces, z_spaces
>beb5		73 70 61 63 65 73		        .text "spaces"
.bebb						nt_bl:
>bebb		02 00				        .byte 2, 0
>bebd		c5 be 06 83 0e 83		        .word nt_minus_trailing, xt_bl, z_bl
>bec3		62 6c				        .text "bl"
.bec5						nt_minus_trailing:
>bec5		09 10				        .byte 9, UF
>bec7		d6 be d1 9f 0d a0		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>becd		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>bed5		67
.bed6						nt_minus_leading:
>bed6		08 10				        .byte 8, UF
>bed8		e6 be b8 9f d0 9f		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>bede		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.bee6						nt_slash_string:
>bee6		07 10				        .byte 7, UF
>bee8		f5 be ad a0 cc a0		        .word nt_refill, xt_slash_string, z_slash_string
>beee		2f 73 74 72 69 6e 67		        .text "/string"
.bef5						nt_refill:
>bef5		06 00				        .byte 6, 0
>bef7		03 bf 3f 90 80 90		        .word nt_accept, xt_refill, z_refill
>befd		72 65 66 69 6c 6c		        .text "refill"
.bf03						nt_accept:
>bf03		06 18				        .byte 6, UF+NN
>bf05		11 bf e6 80 de 81		        .word nt_input_to_r, xt_accept, z_accept
>bf0b		61 63 63 65 70 74		        .text "accept"
.bf11						nt_input_to_r:
>bf11		07 08				        .byte 7, NN
>bf13		20 bf 2d 9b 42 9b		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>bf19		69 6e 70 75 74 3e 72		        .text "input>r"
.bf20						nt_r_to_input:
>bf20		07 08				        .byte 7, NN
>bf22		2f bf 3a 9d 51 9d		        .word nt_unused, xt_r_to_input, z_r_to_input
>bf28		72 3e 69 6e 70 75 74		        .text "r>input"
.bf2f						nt_unused:
>bf2f		06 00				        .byte 6, 0
>bf31		3d bf 06 97 15 97		        .word nt_depth, xt_unused, z_unused
>bf37		75 6e 75 73 65 64		        .text "unused"
.bf3d						nt_depth:
>bf3d		05 00				        .byte 5, 0
>bf3f		4a bf 12 86 20 86		        .word nt_key, xt_depth, z_depth
>bf45		64 65 70 74 68			        .text "depth"
.bf4a						nt_key:
>bf4a		03 00				        .byte 3, 0
>bf4c		55 bf d0 8a d9 8a		        .word nt_allot, xt_key, z_key
>bf52		6b 65 79			        .text "key"
.bf55						nt_allot:
>bf55		05 10				        .byte 5, UF
>bf57		62 bf 29 82 91 82		        .word nt_create, xt_allot, z_allot
>bf5d		61 6c 6c 6f 74			        .text "allot"
.bf62						nt_create:
>bf62		06 00				        .byte 6, 0
>bf64		70 bf 00 85 c9 85		        .word nt_does, xt_create, z_create
>bf6a		63 72 65 61 74 65		        .text "create"
.bf70						nt_does:
>bf70		05 05				        .byte 5, CO+IM
>bf72		7d bf 91 86 9f 86		        .word nt_variable, xt_does, z_does
>bf78		64 6f 65 73 3e			        .text "does>"
.bf7d						nt_variable:
>bf7d		08 00				        .byte 8, 0
>bf7f		8d bf 16 97 2e 97		        .word nt_constant, xt_variable, z_variable
>bf85		76 61 72 69 61 62 6c 65		        .text "variable"
.bf8d						nt_constant:
>bf8d		08 10				        .byte 8, UF
>bf8f		9d bf a8 84 e5 84		        .word nt_value, xt_constant, z_constant
>bf95		63 6f 6e 73 74 61 6e 74		        .text "constant"
.bf9d						nt_value:
>bf9d		05 10				        .byte 5, UF
>bf9f		aa bf a8 84 e5 84		        .word nt_to, xt_constant, z_constant
>bfa5		76 61 6c 75 65			        .text "value"
.bfaa						nt_to:
>bfaa		02 0c				        .byte 2, NN+IM
>bfac		b4 bf 81 93 bc 93		        .word nt_s_to_d, xt_to, z_to
>bfb2		74 6f				        .text "to"
.bfb4						nt_s_to_d:
>bfb4		03 10				        .byte 3, UF
>bfb6		bf bf dc 91 ed 91		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>bfbc		73 3e 64			        .text "s>d"
.bfbf						nt_d_to_s:
>bfbf		03 10				        .byte 3, UF
>bfc1		ca bf d5 9d da 9d		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>bfc7		64 3e 73			        .text "d>s"
.bfca						nt_d_minus:
>bfca		02 10				        .byte 2, UF
>bfcc		d4 bf 93 9d b3 9d		        .word nt_d_plus, xt_d_minus, z_d_minus
>bfd2		64 2d				        .text "d-"
.bfd4						nt_d_plus:
>bfd4		02 10				        .byte 2, UF
>bfd6		de bf b4 9d d4 9d		        .word nt_erase, xt_d_plus, z_d_plus
>bfdc		64 2b				        .text "d+"
.bfde						nt_erase:
>bfde		05 00				        .byte 5, 0      ; underflow checked by FILL
>bfe0		eb bf a3 88 eb 88		        .word nt_blank, xt_erase, z_erase
>bfe6		65 72 61 73 65			        .text "erase"
.bfeb						nt_blank:
>bfeb		05 00				        .byte 5, 0     ; underflow checked by FILL
>bfed		f8 bf 99 88 eb 88		        .word nt_fill, xt_blank, z_blank
>bff3		62 6c 61 6e 6b			        .text "blank"
.bff8						nt_fill:
>bff8		04 10				        .byte 4, UF
>bffa		04 c0 a9 88 eb 88		        .word nt_find_name, xt_fill, z_fill
>c000		66 69 6c 6c			        .text "fill"
.c004						nt_find_name:
>c004		09 10				        .byte 9, UF
>c006		15 c0 8b 9a ce 9a		        .word nt_tick, xt_find_name, z_find_name
>c00c		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c014		65
.c015						nt_tick:
>c015		01 00				        .byte 1, 0
>c017		1e c0 61 93 80 93		        .word nt_bracket_tick, xt_tick, z_tick
>c01d		27				        .text "'"
.c01e						nt_bracket_tick:
>c01e		03 05				        .byte 3, CO+IM
>c020		29 c0 16 83 1c 83		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c026		5b 27 5d			        .text "[']"
.c029						nt_name_to_int:
>c029		08 10				        .byte 8, UF
>c02b		39 c0 c9 9b e5 9b		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c031		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c039						nt_int_to_name:
>c039		08 10				        .byte 8, UF
>c03b		49 c0 43 9b b3 9b		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c041		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c049						nt_name_to_string:
>c049		0b 10				        .byte 11, UF
>c04b		5c c0 e6 9b fc 9b		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c051		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c059		69 6e 67
.c05c						nt_to_body:
>c05c		05 10				        .byte 5, UF
>c05e		69 c0 bd 93 df 93		        .word nt_defer, xt_to_body, z_to_body
>c064		3e 62 6f 64 79			        .text ">body"
.c069						nt_defer:
>c069		05 00				        .byte 5, 0
>c06b		76 c0 d1 85 03 86		        .word nt_latestxt, xt_defer, z_defer
>c071		64 65 66 65 72			        .text "defer"
.c076						nt_latestxt:
>c076		08 00				        .byte 8, 0
>c078		86 c0 c2 9b c8 9b		        .word nt_latestnt, xt_latestxt, z_latestxt
>c07e		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c086						nt_latestnt:
>c086		08 00				        .byte 8, 0
>c088		96 c0 b4 9b c1 9b		        .word nt_parse_name, xt_latestnt, z_latestnt
>c08e		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c096						nt_parse_name:
>c096		0a 08				        .byte 10, NN
>c098		a8 c0 54 8e 44 8f		        .word nt_parse, xt_parse_name, z_parse_name
>c09e		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c0a6		6d 65
.c0a8						nt_parse:
>c0a8		05 10				        .byte 5, UF
>c0aa		b5 c0 af 8e 44 8f		        .word nt_execute_parsing, xt_parse, z_parse
>c0b0		70 61 72 73 65			        .text "parse"
.c0b5						nt_execute_parsing:
>c0b5		0f 10				        .byte 15, UF
>c0b7		cc c0 64 9a 8a 9a		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c0bd		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c0c5		70 61 72 73 69 6e 67
.c0cc						nt_source:
>c0cc		06 00				        .byte 6, 0
>c0ce		da c0 a8 92 bc 92		        .word nt_source_id, xt_source, z_source
>c0d4		73 6f 75 72 63 65		        .text "source"
.c0da						nt_source_id:
>c0da		09 00				        .byte 9, 0
>c0dc		eb c0 bd 92 c7 92		        .word nt_colon, xt_source_id, z_source_id
>c0e2		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c0ea		64
.c0eb						nt_colon:
>c0eb		01 00				        .byte 1, 0
>c0ed		f4 c0 70 83 b2 83		        .word nt_semicolon, xt_colon, z_colon
>c0f3		3a				        .text ":"
.c0f4						nt_semicolon:
>c0f4		01 05				        .byte 1, CO+IM
>c0f6		fd c0 ee 91 4c 92		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c0fc		3b				        .text ";"
.c0fd						nt_colon_noname:
>c0fd		07 00				        .byte 7, 0
>c0ff		0c c1 b3 83 ce 83		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c105		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c10c						nt_compile_comma:
>c10c		08 18				        .byte 8, UF+NN
>c10e		1c c1 de 83 9c 84		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c114		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c11c						nt_left_bracket:
>c11c		01 05				        .byte 1, IM+CO
>c11e		25 c1 f3 8a f7 8a		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c124		5b				        .text "["
.c125						nt_right_bracket:
>c125		01 04				        .byte 1, IM
>c127		2e c1 87 90 8d 90		        .word nt_literal, xt_right_bracket, z_right_bracket
>c12d		5d				        .text "]"
.c12e						nt_literal:
>c12e		07 15				        .byte 7, IM+CO+UF
>c130		3d c1 1b 8b 58 8b		        .word nt_sliteral, xt_literal, z_literal
>c136		6c 69 74 65 72 61 6c		        .text "literal"
.c13d						nt_sliteral:
>c13d		08 15				        .byte 8, CO+IM+UF
>c13f		4d c1 cd a0 10 a1		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c145		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c14d						nt_dot_quote:
>c14d		02 05				        .byte 2, CO+IM
>c14f		57 c1 03 87 0d 87		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c155		2e 22				        .text ".", $22
.c157						nt_s_quote:
>c157		02 0c				        .byte 2, IM+NN
>c159		61 c1 d7 90 db 91		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c15f		73 22				        .text "s", $22
.c161						nt_s_backslash_quote:
>c161		03 04				        .byte 3, IM
>c163		6c c1 be 90 c7 90		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c169		73 5c 22			        .text "s", $5C, $22
.c16c						nt_postpone:
>c16c		08 05				        .byte 8, IM+CO
>c16e		7c c1 89 8f c7 8f		        .word nt_immediate, xt_postpone, z_postpone
>c174		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c17c						nt_immediate:
>c17c		09 00				        .byte 9, 0
>c17e		8d c1 81 8a 8c 8a		        .word nt_compile_only, xt_immediate, z_immediate
>c184		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c18c		65
.c18d						nt_compile_only:
>c18d		0c 00				        .byte 12, 0
>c18f		a1 c1 9c 84 a7 84		        .word nt_never_native, xt_compile_only, z_compile_only
>c195		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c19d		6f 6e 6c 79
.c1a1						nt_never_native:
>c1a1		0c 00				        .byte 12, 0
>c1a3		b5 c1 02 9c 0f 9c		        .word nt_always_native, xt_never_native, z_never_native
>c1a9		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c1b1		74 69 76 65
.c1b5						nt_always_native:
>c1b5		0d 00				        .byte 13, 0
>c1b7		ca c1 b5 99 c2 99		        .word nt_allow_native, xt_always_native, z_always_native
>c1bd		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c1c5		61 74 69 76 65
.c1ca						nt_allow_native:
>c1ca		0c 00				        .byte 12, 0
>c1cc		de c1 a9 99 b4 99		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c1d2		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c1da		74 69 76 65
.c1de						nt_nc_limit:
>c1de		08 08				        .byte 8, NN
>c1e0		ee c1 fd 9b 02 9c		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c1e6		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c1ee						nt_strip_underflow:
>c1ee		0f 08				        .byte 15, NN
>c1f0		05 c2 52 9d 57 9d		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c1f6		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c1fe		64 65 72 66 6c 6f 77
.c205						nt_abort:
>c205		05 00				        .byte 5, 0
>c207		12 c2 60 80 b1 80		        .word nt_abort_quote, xt_abort, z_abort
>c20d		61 62 6f 72 74			        .text "abort"
.c212						nt_abort_quote:
>c212		06 0d				        .byte 6, CO+IM+NN
>c214		20 c2 b1 80 bb 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c21a		61 62 6f 72 74 22		        .text "abort", $22
.c220						nt_do:
>c220		02 0d				        .byte 2, CO+IM+NN
>c222		2a c2 35 86 4e 86		        .word nt_question_do, xt_do, z_do
>c228		64 6f				        .text "do"
.c22a						nt_question_do:
>c22a		03 0d				        .byte 3, CO+IM+NN
>c22c		35 c2 21 86 4e 86		        .word nt_i, xt_question_do, z_question_do
>c232		3f 64 6f			        .text "?do"
.c235						nt_i:
>c235		01 01				        .byte 1, CO
>c237		3e c2 26 8a 3a 8a		        .word nt_j, xt_i, z_i
>c23d		69				        .text "i"
.c23e						nt_j:
>c23e		01 01				        .byte 1, CO
>c240		47 c2 b6 8a cf 8a		        .word nt_loop, xt_j, z_j
>c246		6a				        .text "j"
.c247						nt_loop:
>c247		04 05				        .byte 4, CO+IM
>c249		53 c2 82 8b e4 8b		        .word nt_plus_loop, xt_loop, z_loop
>c24f		6c 6f 6f 70			        .text "loop"
.c253						nt_plus_loop:
>c253		05 05				        .byte 5, CO+IM
>c255		60 c2 93 8b e4 8b		        .word nt_exit, xt_plus_loop, z_plus_loop
>c25b		2b 6c 6f 6f 70			        .text "+loop"
.c260						nt_exit:
>c260		04 03				        .byte 4, AN+CO
>c262		6c c2 00 89 01 89		        .word nt_unloop, xt_exit, z_exit
>c268		65 78 69 74			        .text "exit"
.c26c						nt_unloop:
>c26c		06 01				        .byte 6, CO
>c26e		7a c2 e1 96 f0 96		        .word nt_leave, xt_unloop, z_unloop
>c274		75 6e 6c 6f 6f 70		        .text "unloop"
.c27a						nt_leave:
>c27a		05 05				        .byte 5, CO+IM
>c27c		87 c2 dd 8a f2 8a		        .word nt_recurse, xt_leave, z_leave
>c282		6c 65 61 76 65			        .text "leave"
.c287						nt_recurse:
>c287		07 0d				        .byte 7, CO+IM+NN
>c289		96 c2 02 90 3e 90		        .word nt_quit, xt_recurse, z_recurse
>c28f		72 65 63 75 72 73 65		        .text "recurse"
.c296						nt_quit:
>c296		04 00				        .byte 4, 0
>c298		a2 c2 62 80 b1 80		        .word nt_begin, xt_quit, z_quit
>c29e		71 75 69 74			        .text "quit"
.c2a2						nt_begin:
>c2a2		05 05				        .byte 5, CO+IM
>c2a4		af c2 02 8a 0c 8a		        .word nt_again, xt_begin, z_begin
>c2aa		62 65 67 69 6e			        .text "begin"
.c2af						nt_again:
>c2af		05 15				        .byte 5, CO+IM+UF
>c2b1		bc c2 21 82 27 82		        .word nt_state, xt_again, z_again
>c2b7		61 67 61 69 6e			        .text "again"
.c2bc						nt_state:
>c2bc		05 00				        .byte 5, 0
>c2be		c9 c2 2c 93 36 93		        .word nt_evaluate, xt_state, z_state
>c2c4		73 74 61 74 65			        .text "state"
.c2c9						nt_evaluate:
>c2c9		08 10				        .byte 8, UF
>c2cb		d9 c2 99 89 ec 89		        .word nt_base, xt_evaluate, z_evaluate
>c2d1		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c2d9						nt_base:
>c2d9		04 00				        .byte 4, 0
>c2db		e5 c2 fd 82 05 83		        .word nt_digit_question, xt_base, z_base
>c2e1		62 61 73 65			        .text "base"
.c2e5						nt_digit_question:
>c2e5		06 10				        .byte 6, UF
>c2e7		f3 c2 2f 9a 63 9a		        .word nt_number, xt_digit_question, z_digit_question
>c2ed		64 69 67 69 74 3f		        .text "digit?"
.c2f3						nt_number:
>c2f3		06 10				        .byte 6, UF
>c2f5		01 c3 2c 9c 25 9d		        .word nt_to_number, xt_number, z_number
>c2fb		6e 75 6d 62 65 72		        .text "number"
.c301						nt_to_number:
>c301		07 10				        .byte 7, UF
>c303		10 c3 eb 93 8a 94		        .word nt_hex, xt_to_number, z_to_number
>c309		3e 6e 75 6d 62 65 72		        .text ">number"
.c310						nt_hex:
>c310		03 00				        .byte 3, 0
>c312		1b c3 0d 8a 13 8a		        .word nt_decimal, xt_hex, z_hex
>c318		68 65 78			        .text "hex"
.c31b						nt_decimal:
>c31b		07 00				        .byte 7, 0
>c31d		2a c3 ca 85 d0 85		        .word nt_count, xt_decimal, z_decimal
>c323		64 65 63 69 6d 61 6c		        .text "decimal"
.c32a						nt_count:
>c32a		05 10				        .byte 5, UF
>c32c		37 c3 e6 84 f9 84		        .word nt_m_star, xt_count, z_count
>c332		63 6f 75 6e 74			        .text "count"
.c337						nt_m_star:
>c337		02 10				        .byte 2, UF
>c339		41 c3 24 8c 3e 8c		        .word nt_um_star, xt_m_star, z_m_star
>c33f		6d 2a				        .text "m*"
.c341						nt_um_star:
>c341		03 10				        .byte 3, UF
>c343		4c c3 9b 96 e0 96		        .word nt_star, xt_um_star, z_um_star
>c349		75 6d 2a			        .text "um*"
.c34c						nt_star:
>c34c		01 10				        .byte 1, UF
>c34e		55 c3 0a 93 12 93		        .word nt_um_slash_mod, xt_star, z_star
>c354		2a				        .text "*"
.c355						nt_um_slash_mod:
>c355		06 10				        .byte 6, UF
>c357		63 c3 59 96 9a 96		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c35d		75 6d 2f 6d 6f 64		        .text "um/mod"
.c363						nt_sm_slash_rem:
>c363		06 10				        .byte 6, UF
>c365		71 c3 7f 92 a7 92		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c36b		73 6d 2f 72 65 6d		        .text "sm/rem"
.c371						nt_fm_slash_mod:
>c371		06 10				        .byte 6, UF
>c373		7f c3 5c 89 92 89		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c379		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c37f						nt_slash:
>c37f		01 10				        .byte 1, UF
>c381		88 c3 62 92 7e 92		        .word nt_slash_mod, xt_slash, z_slash
>c387		2f				        .text "/"
.c388						nt_slash_mod:
>c388		04 10				        .byte 4, UF
>c38a		94 c3 67 92 7e 92		        .word nt_mod, xt_slash_mod, z_slash_mod
>c390		2f 6d 6f 64			        .text "/mod"
.c394						nt_mod:
>c394		03 10				        .byte 3, UF
>c396		9f c3 fa 8c 02 8d		        .word nt_star_slash_mod, xt_mod, z_mod
>c39c		6d 6f 64			        .text "mod"
.c39f						nt_star_slash_mod:
>c39f		05 10				        .byte 5, UF
>c3a1		ac c3 1c 93 2b 93		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c3a7		2a 2f 6d 6f 64			        .text "*/mod"
.c3ac						nt_star_slash:
>c3ac		02 10				        .byte 2, UF
>c3ae		b6 c3 13 93 1b 93		        .word nt_backslash, xt_star_slash, z_star_slash
>c3b4		2a 2f				        .text "*/"
.c3b6						nt_backslash:
>c3b6		01 04				        .byte 1, IM
>c3b8		bf c3 d2 82 fc 82		        .word nt_move, xt_backslash, z_backslash
>c3be		5c				        .byte '\'
.c3bf						nt_move:
>c3bf		04 18				        .byte 4, NN+UF
>c3c1		cb c3 03 8d 21 8d		        .word nt_cmove_up, xt_move, z_move
>c3c7		6d 6f 76 65			        .text "move"
.c3cb						nt_cmove_up:
>c3cb		06 10				        .byte 6, UF
>c3cd		d9 c3 18 9f 52 9f		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c3d3		63 6d 6f 76 65 3e		        .text "cmove>"
.c3d9						nt_cmove:
>c3d9		05 10				        .byte 5, UF
>c3db		e6 c3 dd 9e 17 9f		        .word nt_pad, xt_cmove, z_cmove
>c3e1		63 6d 6f 76 65			        .text "cmove"
.c3e6						nt_pad:
>c3e6		03 00				        .byte 3, 0
>c3e8		f1 c3 16 8e 25 8e		        .word nt_cleave, xt_pad, z_pad
>c3ee		70 61 64			        .text "pad"
.c3f1						nt_cleave:
>c3f1		06 10				        .byte 6, UF
>c3f3		ff c3 e2 99 2e 9a		        .word nt_hexstore, xt_cleave, z_cleave
>c3f9		63 6c 65 61 76 65		        .text "cleave"
.c3ff						nt_hexstore:
>c3ff		08 10				        .byte 8, UF
>c401		0f c4 cf 9a 21 9b		        .word nt_within, xt_hexstore, z_hexstore
>c407		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c40f						nt_within:
>c40f		06 10				        .byte 6, UF
>c411		1d c4 43 97 58 97		        .word nt_to_in, xt_within, z_within
>c417		77 69 74 68 69 6e		        .text "within"
.c41d						nt_to_in:
>c41d		03 00				        .byte 3, 0
>c41f		28 c4 e0 93 ea 93		        .word nt_less_number_sign, xt_to_in, z_to_in
>c425		3e 69 6e			        .text ">in"
.c428						nt_less_number_sign:
>c428		02 00				        .byte 2, 0
>c42a		32 c4 f8 8a 05 8b		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c430		3c 23				        .text "<#"
.c432						nt_number_sign:
>c432		01 10				        .byte 1, UF
>c434		3b c4 5f 8d 93 8d		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c43a		23				        .text "#"
.c43b						nt_number_sign_s:
>c43b		02 10				        .byte 2, UF
>c43d		45 c4 b6 8d c6 8d		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c443		23 73				        .text "#s"
.c445						nt_number_sign_greater:
>c445		02 10				        .byte 2, UF
>c447		4f c4 94 8d b5 8d		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c44d		23 3e				        .text "#>"
.c44f						nt_hold:
>c44f		04 10				        .byte 4, UF
>c451		5b c4 14 8a 25 8a		        .word nt_sign, xt_hold, z_hold
>c457		68 6f 6c 64			        .text "hold"
.c45b						nt_sign:
>c45b		04 10				        .byte 4, UF
>c45d		67 c4 4d 92 61 92		        .word nt_output, xt_sign, z_sign
>c463		73 69 67 6e			        .text "sign"
.c467						nt_output:
>c467		06 00				        .byte 6, 0
>c469		75 c4 2f 9d 39 9d		        .word nt_input, xt_output, z_output
>c46f		6f 75 74 70 75 74		        .text "output"
.c475						nt_input:
>c475		05 00				        .byte 5, 0
>c477		82 c4 22 9b 2c 9b		        .word nt_cr, xt_input, z_input
>c47d		69 6e 70 75 74			        .text "input"
.c482						nt_cr:
>c482		02 00				        .byte 2, 0
>c484		8c c4 fa 84 ff 84		        .word nt_page, xt_cr, z_cr
>c48a		63 72				        .text "cr"
.c48c						nt_page:
>c48c		04 00				        .byte 4, 0
>c48e		98 c4 26 8e 43 8e		        .word nt_at_xy, xt_page, z_page
>c494		70 61 67 65			        .text "page"
.c498						nt_at_xy:
>c498		05 10				        .byte 5, UF
>c49a		a5 c4 a4 82 d1 82		        .word nt_marker, xt_at_xy, z_at_xy
>c4a0		61 74 2d 78 79			        .text "at-xy"
.c4a5						nt_marker:
>c4a5		06 04				        .byte 6, IM
>c4a7		b3 c4 3f 8c 79 8c		        .word nt_words, xt_marker, z_marker
>c4ad		6d 61 72 6b 65 72		        .text "marker"
.c4b3						nt_words:
>c4b3		05 00				        .byte 5, 0
>c4b5		c0 c4 4c 99 a8 99		        .word nt_wordsize, xt_words, z_words
>c4bb		77 6f 72 64 73			        .text "words"
.c4c0						nt_wordsize:
>c4c0		08 10				        .byte 8, UF
>c4c2		d0 c4 6b 9d 8b 9d		        .word nt_aligned, xt_wordsize, z_wordsize
>c4c8		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c4d0						nt_aligned:
>c4d0		07 00				        .byte 7, 0
>c4d2		df c4 28 82 28 82		        .word nt_align, xt_align, z_align
>c4d8		61 6c 69 67 6e 65 64		        .text "aligned"
.c4df						nt_align:
>c4df		05 00				        .byte 5, 0
>c4e1		ec c4 28 82 28 82		        .word nt_bell, xt_align, z_align
>c4e7		61 6c 69 67 6e			        .text "align"
.c4ec						nt_bell:
>c4ec		04 00				        .byte 4, 0
>c4ee		f8 c4 c3 99 c8 99		        .word nt_dump, xt_bell, z_bell
>c4f4		62 65 6c 6c			        .text "bell"
.c4f8						nt_dump:
>c4f8		04 10				        .byte 4, UF
>c4fa		04 c5 3c 98 a2 98		        .word nt_dot_s, xt_dump, z_dump
>c500		64 75 6d 70			        .text "dump"
.c504						nt_dot_s:
>c504		02 00				        .byte 2, 0
>c506		0e c5 f8 97 3b 98		        .word +, xt_dot_s, z_dot_s
>c50c		2e 73				        .text ".s"
.c50e						+
.c50e						nt_disasm:
>c50e		06 10				        .byte 6, UF
>c510		1c c5 39 a1 3f a1		        .word +, xt_disasm, z_disasm
>c516		64 69 73 61 73 6d		        .text "disasm"
.c51c						+
.c51c						nt_compare:
>c51c		07 10				        .byte 7, UF
>c51e		2b c5 53 9f b7 9f		        .word nt_search, xt_compare, z_compare
>c524		63 6f 6d 70 61 72 65		        .text "compare"
.c52b						nt_search:
>c52b		06 18				        .byte 6, UF+NN
>c52d		39 c5 0e a0 ac a0		        .word +, xt_search, z_search
>c533		73 65 61 72 63 68		        .text "search"
.c539						+
.c539						nt_environment_q:
>c539		0c 10				        .byte 12, UF
>c53b		4d c5 c4 87 40 88		        .word +, xt_environment_q, z_environment_q
>c541		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c549		65 6e 74 3f
.c54d						+
.c54d						nt_find:
>c54d		04 10				        .byte 4, UF
>c54f		59 c5 14 89 5b 89		        .word nt_word, xt_find, z_find
>c555		66 69 6e 64			        .text "find"
.c559						nt_word:
>c559		04 10				        .byte 4, UF
>c55b		65 c5 59 97 9c 97		        .word nt_paren, xt_word, z_word
>c561		77 6f 72 64			        .text "word"
.c565						nt_paren:
>c565		01 04				        .byte 1, IM
>c567		6e c5 44 8e 53 8e		        .word nt_dot_paren, xt_paren, z_paren
>c56d		28				        .text "("
.c56e						nt_dot_paren:
>c56e		02 04				        .byte 2, IM
>c570		78 c5 f4 86 02 87		        .word nt_if, xt_dot_paren, z_dot_paren
>c576		2e 28				        .text ".("
.c578						nt_if:
>c578		02 0d				        .byte 2, IM+CO+NN
>c57a		82 c5 3b 8a 4b 8a		        .word nt_then, xt_if, z_if
>c580		69 66				        .text "if"
.c582						nt_then:
>c582		04 0d				        .byte 4, IM+CO+NN
>c584		8e c5 56 87 9f 87		        .word nt_else, xt_then, z_then
>c58a		74 68 65 6e			        .text "then"
.c58e						nt_else:
>c58e		04 0d				        .byte 4, IM+CO+NN
>c590		9a c5 50 87 9f 87		        .word nt_repeat, xt_else, z_else
>c596		65 6c 73 65			        .text "else"
.c59a						nt_repeat:
>c59a		06 0d				        .byte 6, IM+CO+NN
>c59c		a8 c5 81 90 87 90		        .word nt_until, xt_repeat, z_repeat
>c5a2		72 65 70 65 61 74		        .text "repeat"
.c5a8						nt_until:
>c5a8		05 0d				        .byte 5, IM+CO+NN
>c5aa		b5 c5 f1 96 05 97		        .word nt_while, xt_until, z_until
>c5b0		75 6e 74 69 6c			        .text "until"
.c5b5						nt_while:
>c5b5		05 0d				        .byte 5, IM+CO+NN
>c5b7		c2 c5 2f 97 42 97		        .word nt_case, xt_while, z_while
>c5bd		77 68 69 6c 65			        .text "while"
.c5c2						nt_case:
>c5c2		04 0d				        .byte 4, IM+CO+NN
>c5c4		ce c5 8c 9d 92 9d		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c5ca		63 61 73 65			        .text "case"
.c5ce						nt_of:
>c5ce		02 0d				        .byte 2, IM+CO+NN
>c5d0		d8 c5 c7 8d df 8d		        .word nt_endof, xt_of, z_of
>c5d6		6f 66				        .text "of"
.c5d8						nt_endof:
>c5d8		05 0d				        .byte 5, IM+CO+NN
>c5da		e5 c5 50 87 9f 87		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c5e0		65 6e 64 6f 66			        .text "endof"
.c5e5						nt_endcase:
>c5e5		07 0d				        .byte 7, IM+CO+NN
>c5e7		f4 c5 af 87 c3 87		        .word nt_defer_fetch, xt_endcase, z_endcase
>c5ed		65 6e 64 63 61 73 65		        .text "endcase"
.c5f4						nt_defer_fetch:
>c5f4		06 00				        .byte 6, 0
>c5f6		02 c6 04 86 0a 86		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c5fc		64 65 66 65 72 40		        .text "defer@"
.c602						nt_defer_store:
>c602		06 00				        .byte 6, 0
>c604		10 c6 0b 86 11 86		        .word nt_is, xt_defer_store, z_defer_store
>c60a		64 65 66 65 72 21		        .text "defer!"
.c610						nt_is:
>c610		02 04				        .byte 2, IM
>c612		1a c6 9d 8a b5 8a		        .word nt_action_of, xt_is, z_is
>c618		69 73				        .text "is"
.c61a						nt_action_of:
>c61a		09 04				        .byte 9, IM
>c61c		2b c6 08 82 20 82		        .word nt_useraddr, xt_action_of, z_action_of
>c622		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c62a		66
.c62b						nt_useraddr:
>c62b		08 00				        .byte 8, 0
>c62d		3b c6 60 9d 6a 9d		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c633		75 73 65 72 61 64 64 72		        .text "useraddr"
.c63b						nt_buffer_colon:
>c63b		07 00				        .byte 7, 0
>c63d		4a c6 1d 83 23 83		        .word +, xt_buffer_colon, z_buffer_colon
>c643		62 75 66 66 65 72 3a		        .text "buffer:"
.c64a						+
.c64a						nt_buffstatus:
>c64a		0a 00				        .byte 10, 0
>c64c		5c c6 83 af 88 af		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c652		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c65a		75 73
.c65c						nt_buffblocknum:
>c65c		0c 00				        .byte 12, 0
>c65e		70 c6 4d af 52 af		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c664		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c66c		6b 6e 75 6d
.c670						nt_blkbuffer:
>c670		09 00				        .byte 9, 0
>c672		81 c6 43 ad 50 ad		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c678		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c680		72
.c681						nt_scr:
>c681		03 08				        .byte 3, NN
>c683		8c c6 05 b0 0a b0		        .word nt_blk, xt_scr, z_scr
>c689		73 63 72			        .text "scr"
.c68c						nt_blk:
>c68c		03 08				        .byte 3, NN
>c68e		97 c6 3e ad 43 ad		        .word nt_block_write, xt_blk, z_blk
>c694		62 6c 6b			        .text "blk"
.c697						nt_block_write:
>c697		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c699		aa c6 3a af 48 af		        .word nt_block_write_vector, xt_block_write, z_block_write
>c69f		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c6a7		69 74 65
.c6aa						nt_block_write_vector:
>c6aa		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c6ac		c4 c6 48 af 4d af		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c6b2		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c6ba		69 74 65 2d 76 65 63 74 6f 72
.c6c4						nt_block_read:
>c6c4		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c6c6		d6 c6 22 af 30 af		        .word nt_block_read_vector, xt_block_read, z_block_read
>c6cc		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c6d4		61 64
.c6d6						nt_block_read_vector:
>c6d6		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c6d8		ef c6 30 af 35 af		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c6de		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c6e6		61 64 2d 76 65 63 74 6f 72
.c6ef						nt_save_buffers:
>c6ef		0c 00				        .byte 12, 0
>c6f1		03 c7 ea af 04 b0		        .word nt_block, xt_save_buffers, z_save_buffers
>c6f7		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c6ff		66 65 72 73
.c703						nt_block:
>c703		05 00				        .byte 5, 0
>c705		10 c7 51 ad a3 ad		        .word nt_update, xt_block, z_block
>c70b		62 6c 6f 63 6b			        .text "block"
.c710						nt_update:
>c710		06 00				        .byte 6, 0
>c712		1e c7 4f b0 57 b0		        .word nt_buffer, xt_update, z_update
>c718		75 70 64 61 74 65		        .text "update"
.c71e						nt_buffer:
>c71e		06 00				        .byte 6, 0
>c720		2c c7 52 af 82 af		        .word nt_empty_buffers, xt_buffer, z_buffer
>c726		62 75 66 66 65 72		        .text "buffer"
.c72c						nt_empty_buffers:
>c72c		0d 00				        .byte 13, 0
>c72e		41 c7 88 af 8e af		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c734		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c73c		66 66 65 72 73
.c741						nt_flush:
>c741		05 00				        .byte 5, 0
>c743		4e c7 8f af 98 af		        .word nt_load, xt_flush, z_flush
>c749		66 6c 75 73 68			        .text "flush"
.c74e						nt_load:
>c74e		04 10				        .byte 4, UF
>c750		5a c7 a6 af e9 af		        .word nt_thru, xt_load, z_load
>c756		6c 6f 61 64			        .text "load"
.c75a						nt_thru:
>c75a		04 10				        .byte 4, UF
>c75c		66 c7 0a b0 4e b0		        .word +, xt_thru, z_thru
>c762		74 68 72 75			        .text "thru"
.c766						+
.c766						nt_list:
>c766		04 10				        .byte 4, UF
>c768		72 c7 99 af a5 af		        .word nt_block_c65_init, xt_list, z_list
>c76e		6c 69 73 74			        .text "list"
.c772						nt_block_c65_init:
>c772		0e 00				        .byte 14, 0
>c774		88 c7 a4 ad d9 ad		        .word +, xt_block_c65_init, z_block_c65_init
>c77a		62 6c 6f 63 6b 2d 63 36		        .text "block-c65-init"
>c782		35 2d 69 6e 69 74
.c788						+
.c788						nt_block_ramdrive_init:
>c788		13 10				        .byte 19, UF
>c78a		a3 c7 fc ad 09 ae		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c790		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c798		6d 64 72 69 76 65 2d 69 6e 69 74
.c7a3						+
.c7a3						nt_definitions:
>c7a3		0b 00				        .byte 11, 0
>c7a5		b6 c7 8e b1 96 b1		        .word nt_wordlist, xt_definitions, z_definitions
>c7ab		64 65 66 69 6e 69 74 69		        .text "definitions"
>c7b3		6f 6e 73
.c7b6						nt_wordlist:
>c7b6		08 00				        .byte 8, 0
>c7b8		c6 c7 f9 b2 0f b3		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c7be		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c7c6						nt_search_wordlist:
>c7c6		0f 10				        .byte 15, UF
>c7c8		dd c7 32 b2 a5 b2		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c7ce		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c7d6		6f 72 64 6c 69 73 74
.c7dd						nt_set_current:
>c7dd		0b 10				        .byte 11, UF
>c7df		f0 c7 a6 b2 b1 b2		        .word nt_get_current, xt_set_current, z_set_current
>c7e5		73 65 74 2d 63 75 72 72		        .text "set-current"
>c7ed		65 6e 74
.c7f0						nt_get_current:
>c7f0		0b 00				        .byte 11, 0
>c7f2		03 c8 9e b1 a8 b1		        .word nt_set_order, xt_get_current, z_get_current
>c7f8		67 65 74 2d 63 75 72 72		        .text "get-current"
>c800		65 6e 74
.c803						nt_set_order:
>c803		09 00				        .byte 9, 0
>c805		14 c8 b2 b2 e5 b2		        .word nt_get_order, xt_set_order, z_set_order
>c80b		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c813		72
.c814						nt_get_order:
>c814		09 00				        .byte 9, 0
>c816		25 c8 a9 b1 d1 b1		        .word nt_root_wordlist, xt_get_order, z_get_order
>c81c		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c824		72
.c825						nt_root_wordlist:
>c825		0d 00				        .byte 13, 0
>c827		3a c8 29 b2 31 b2		        .word +, xt_root_wordlist, z_root_wordlist
>c82d		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c835		64 6c 69 73 74
.c83a						+
.c83a						nt_assembler_wordlist:
>c83a		12 00				        .byte 18, 0
>c83c		54 c8 57 9d 5f 9d		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c842		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c84a		72 2d 77 6f 72 64 6c 69 73 74
.c854						+
.c854						nt_editor_wordlist:
>c854		0f 00				        .byte 15, 0
>c856		6b c8 26 9d 2e 9d		        .word +, xt_editor_wordlist, z_editor_wordlist
>c85c		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c864		6f 72 64 6c 69 73 74
.c86b						+
.c86b						nt_forth_wordlist:
>c86b		0e 00				        .byte 14, 0
>c86d		81 c8 8c 9d 92 9d		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c873		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c87b		72 64 6c 69 73 74
.c881						nt_only:
>c881		04 00				        .byte 4, 0
>c883		8d c8 d2 b1 d8 b1		        .word nt_also, xt_only, z_only
>c889		6f 6e 6c 79			        .text "only"
.c88d						nt_also:
>c88d		04 00				        .byte 4, 0
>c88f		99 c8 7e b1 8d b1		        .word nt_previous, xt_also, z_also
>c895		61 6c 73 6f			        .text "also"
.c899						nt_previous:
>c899		08 00				        .byte 8, 0
>c89b		a9 c8 1c b2 28 b2		        .word nt_to_order, xt_previous, z_previous
>c8a1		70 72 65 76 69 6f 75 73		        .text "previous"
.c8a9						nt_to_order:
>c8a9		06 00				        .byte 6, 0
>c8ab		b7 c8 e6 b2 f8 b2		        .word nt_order, xt_to_order, z_to_order
>c8b1		3e 6f 72 64 65 72		        .text ">order"
.c8b7						nt_order:
>c8b7		05 00				        .byte 5, 0
>c8b9		c4 c8 d9 b1 03 b2		        .word nt_forth, xt_order, z_order
>c8bf		6f 72 64 65 72			        .text "order"
.c8c4						nt_forth:
>c8c4		05 00				        .byte 5, 0
>c8c6		d1 c8 97 b1 9d b1		        .word +, xt_forth, z_forth
>c8cc		66 6f 72 74 68			        .text "forth"
.c8d1						+
>c8d1		03 08				nt_see: .byte 3, NN
>c8d3		dc c8 be 98 4b 99		        .word +, xt_see, z_see
>c8d9		73 65 65			        .text "see"
.c8dc						+
.c8dc						nt_ed:
>c8dc		03 08				        .byte 3, NN
>c8de		e7 c8 4b a7 4e a7		        .word +, xt_ed, z_ed
>c8e4		65 64 3a			        .text "ed:"
.c8e7						+
.c8e7						nt_cold:
>c8e7		04 00				        .byte 4, 0
>c8e9		f3 c8 00 80 b1 80		        .word nt_bye, xt_cold, z_cold
>c8ef		63 6f 6c 64			        .text "cold"
.c8f3						nt_bye:
>c8f3		03				        .byte 3         ; length of word strings
>c8f4		00				        .byte 0         ; status byte
>c8f5		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>c8f7		f5 97				        .word xt_bye    ; start of code block (xt of this word)
>c8f9		f8 97				        .word z_bye     ; end of code (RTS)
>c8fb		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.c8fe						root_dictionary_start:
.c8fe						nt_root_set_order:
>c8fe		09 00				        .byte 9, 0
>c900		0f c9 b2 b2 e5 b2		        .word nt_root_forth, xt_set_order, z_set_order
>c906		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c90e		72
.c90f						nt_root_forth:
>c90f		05 00				        .byte 5, 0
>c911		1c c9 97 b1 9d b1		        .word nt_root_forth_wordlist, xt_forth, z_forth
>c917		66 6f 72 74 68			        .text "forth"
.c91c						nt_root_forth_wordlist:
>c91c		0e 00				        .byte 14, 0
>c91e		32 c9 8c 9d 92 9d		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>c924		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c92c		72 64 6c 69 73 74
.c932						nt_root_words:
>c932		05 00				        .byte 5, 0
>c934		00 00 4c 99 a8 99		        .word 0000, xt_words, z_words
>c93a		77 6f 72 64 73			        .text "words"
.c93f						editor_dictionary_start:
.c93f						nt_editor_o:
>c93f		01 00				        .byte 1, 0
>c941		48 c9 38 b1 7d b1		        .word nt_editor_line, xt_editor_o, z_editor_o
>c947		6f				        .text "o"
.c948						nt_editor_line:
>c948		04 10				        .byte 4, UF
>c94a		54 c9 1f b1 37 b1		        .word nt_editor_l, xt_editor_line, z_editor_line
>c950		6c 69 6e 65			        .text "line"
.c954						nt_editor_l:
>c954		01 00				        .byte 1, 0
>c956		5d c9 a5 b0 1e b1		        .word nt_editor_el, xt_editor_l, z_editor_l
>c95c		6c				        .text "l"
.c95d						nt_editor_el:
>c95d		02 00				        .byte 2, 0
>c95f		67 c9 93 b0 a4 b0		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>c965		65 6c				        .text "el"
.c967						nt_editor_erase_screen:
>c967		0c 00				        .byte 12, 0
>c969		7b c9 81 b0 92 b0		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>c96f		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>c977		72 65 65 6e
.c97b						nt_editor_enter_screen:
>c97b		0c 00				        .byte 12, 0
>c97d		00 00 65 b0 80 b0		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>c983		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>c98b		72 65 65 6e
.c98f						assembler_dictionary_start:
.c98f						nt_asm_adc_h:
>c98f		05 0c						.byte 5, IM+NN
>c991		9c c9				                .word nt_asm_adc_x
>c993		95 a3 9a a3					.word xt_asm_adc_h, z_asm_adc_h
>c997		61 64 63 2e 23					.text "adc.#"
.c99c						nt_asm_adc_x:
>c99c		05 0c						.byte 5, IM+NN
>c99e		a9 c9				                .word nt_asm_adc_y
>c9a0		9a a3 9f a3					.word xt_asm_adc_x, z_asm_adc_x
>c9a4		61 64 63 2e 78					.text "adc.x"
.c9a9						nt_asm_adc_y:
>c9a9		05 0c						.byte 5, IM+NN
>c9ab		b6 c9				                .word nt_asm_adc_z
>c9ad		9f a3 a4 a3					.word xt_asm_adc_y, z_asm_adc_y
>c9b1		61 64 63 2e 79					.text "adc.y"
.c9b6						nt_asm_adc_z:
>c9b6		05 0c						.byte 5, IM+NN
>c9b8		c3 c9				                .word nt_asm_adc_zi
>c9ba		a4 a3 a9 a3					.word xt_asm_adc_z, z_asm_adc_z
>c9be		61 64 63 2e 7a					.text "adc.z"
.c9c3						nt_asm_adc_zi:
>c9c3		06 0c						.byte 6, IM+NN
>c9c5		d1 c9				                .word nt_asm_adc_ziy
>c9c7		a9 a3 ae a3					.word xt_asm_adc_zi, z_asm_adc_zi
>c9cb		61 64 63 2e 7a 69				.text "adc.zi"
.c9d1						nt_asm_adc_ziy:
>c9d1		07 0c						.byte 7, IM+NN
>c9d3		e0 c9				                .word nt_asm_adc_zx
>c9d5		ae a3 b3 a3					.word xt_asm_adc_ziy, z_asm_adc_ziy
>c9d9		61 64 63 2e 7a 69 79				.text "adc.ziy"
.c9e0						nt_asm_adc_zx:
>c9e0		06 0c						.byte 6, IM+NN
>c9e2		ee c9				                .word nt_asm_adc_zxi
>c9e4		b3 a3 b8 a3					.word xt_asm_adc_zx, z_asm_adc_zx
>c9e8		61 64 63 2e 7a 78				.text "adc.zx"
.c9ee						nt_asm_adc_zxi:
>c9ee		07 0c						.byte 7, IM+NN
>c9f0		fd c9				                .word nt_asm_and
>c9f2		b8 a3 bd a3					.word xt_asm_adc_zxi, z_asm_adc_zxi
>c9f6		61 64 63 2e 7a 78 69				.text "adc.zxi"
.c9fd						nt_asm_and:
>c9fd		04 0c						.byte 4, IM+NN
>c9ff		09 ca				                .word nt_asm_and_h
>ca01		bd a3 c2 a3					.word xt_asm_and, z_asm_and
>ca05		61 6e 64 2e					.text "and."
.ca09						nt_asm_and_h:
>ca09		05 0c						.byte 5, IM+NN
>ca0b		16 ca				                .word nt_asm_and_x
>ca0d		c2 a3 c7 a3					.word xt_asm_and_h, z_asm_and_h
>ca11		61 6e 64 2e 23					.text "and.#"
.ca16						nt_asm_and_x:
>ca16		05 0c						.byte 5, IM+NN
>ca18		23 ca				                .word nt_asm_and_y
>ca1a		c7 a3 cc a3					.word xt_asm_and_x, z_asm_and_x
>ca1e		61 6e 64 2e 78					.text "and.x"
.ca23						nt_asm_and_y:
>ca23		05 0c						.byte 5, IM+NN
>ca25		30 ca				                .word nt_asm_and_z
>ca27		cc a3 d1 a3					.word xt_asm_and_y, z_asm_and_y
>ca2b		61 6e 64 2e 79					.text "and.y"
.ca30						nt_asm_and_z:
>ca30		05 0c						.byte 5, IM+NN
>ca32		3d ca				                .word nt_asm_and_zi
>ca34		d1 a3 d6 a3					.word xt_asm_and_z, z_asm_and_z
>ca38		61 6e 64 2e 7a					.text "and.z"
.ca3d						nt_asm_and_zi:
>ca3d		06 0c						.byte 6, IM+NN
>ca3f		4b ca				                .word nt_asm_and_ziy
>ca41		d6 a3 db a3					.word xt_asm_and_zi, z_asm_and_zi
>ca45		61 6e 64 2e 7a 69				.text "and.zi"
.ca4b						nt_asm_and_ziy:
>ca4b		07 0c						.byte 7, IM+NN
>ca4d		5a ca				                .word nt_asm_and_zx
>ca4f		db a3 e0 a3					.word xt_asm_and_ziy, z_asm_and_ziy
>ca53		61 6e 64 2e 7a 69 79				.text "and.ziy"
.ca5a						nt_asm_and_zx:
>ca5a		06 0c						.byte 6, IM+NN
>ca5c		68 ca				                .word nt_asm_and_zxi
>ca5e		e0 a3 e5 a3					.word xt_asm_and_zx, z_asm_and_zx
>ca62		61 6e 64 2e 7a 78				.text "and.zx"
.ca68						nt_asm_and_zxi:
>ca68		07 0c						.byte 7, IM+NN
>ca6a		77 ca				                .word nt_asm_asl
>ca6c		e5 a3 ea a3					.word xt_asm_and_zxi, z_asm_and_zxi
>ca70		61 6e 64 2e 7a 78 69				.text "and.zxi"
.ca77						nt_asm_asl:
>ca77		03 0c						.byte 3, IM+NN
>ca79		82 ca				                .word nt_asm_asl_a
>ca7b		ea a3 ef a3					.word xt_asm_asl, z_asm_asl
>ca7f		61 73 6c					.text "asl"
.ca82						nt_asm_asl_a:
>ca82		05 0c						.byte 5, IM+NN
>ca84		8f ca				                .word nt_asm_asl_x
>ca86		ef a3 f4 a3					.word xt_asm_asl_a, z_asm_asl_a
>ca8a		61 73 6c 2e 61					.text "asl.a"
.ca8f						nt_asm_asl_x:
>ca8f		05 0c						.byte 5, IM+NN
>ca91		9c ca				                .word nt_asm_asl_z
>ca93		f4 a3 f9 a3					.word xt_asm_asl_x, z_asm_asl_x
>ca97		61 73 6c 2e 78					.text "asl.x"
.ca9c						nt_asm_asl_z:
>ca9c		05 0c						.byte 5, IM+NN
>ca9e		a9 ca				                .word nt_asm_asl_zx
>caa0		f9 a3 fe a3					.word xt_asm_asl_z, z_asm_asl_z
>caa4		61 73 6c 2e 7a					.text "asl.z"
.caa9						nt_asm_asl_zx:
>caa9		06 0c						.byte 6, IM+NN
>caab		b7 ca				                .word nt_asm_bcc
>caad		fe a3 03 a4					.word xt_asm_asl_zx, z_asm_asl_zx
>cab1		61 73 6c 2e 7a 78				.text "asl.zx"
.cab7						nt_asm_bcc:
>cab7		03 0c						.byte 3, IM+NN
>cab9		c2 ca				                .word nt_asm_bcs
>cabb		03 a4 08 a4					.word xt_asm_bcc, z_asm_bcc
>cabf		62 63 63					.text "bcc"
.cac2						nt_asm_bcs:
>cac2		03 0c						.byte 3, IM+NN
>cac4		cd ca				                .word nt_asm_beq
>cac6		08 a4 0f a4					.word xt_asm_bcs, z_asm_bcs
>caca		62 63 73					.text "bcs"
.cacd						nt_asm_beq:
>cacd		03 0c						.byte 3, IM+NN
>cacf		d8 ca				                .word nt_asm_bit
>cad1		0f a4 14 a4					.word xt_asm_beq, z_asm_beq
>cad5		62 65 71					.text "beq"
.cad8						nt_asm_bit:
>cad8		03 0c						.byte 3, IM+NN
>cada		e3 ca				                .word nt_asm_bit_h
>cadc		14 a4 19 a4					.word xt_asm_bit, z_asm_bit
>cae0		62 69 74					.text "bit"
.cae3						nt_asm_bit_h:
>cae3		05 0c						.byte 5, IM+NN
>cae5		f0 ca				                .word nt_asm_bit_x
>cae7		19 a4 1e a4					.word xt_asm_bit_h, z_asm_bit_h
>caeb		62 69 74 2e 23					.text "bit.#"
.caf0						nt_asm_bit_x:
>caf0		05 0c						.byte 5, IM+NN
>caf2		fd ca				                .word nt_asm_bit_z
>caf4		1e a4 23 a4					.word xt_asm_bit_x, z_asm_bit_x
>caf8		62 69 74 2e 78					.text "bit.x"
.cafd						nt_asm_bit_z:
>cafd		05 0c						.byte 5, IM+NN
>caff		0a cb				                .word nt_asm_bit_zx
>cb01		23 a4 28 a4					.word xt_asm_bit_z, z_asm_bit_z
>cb05		62 69 74 2e 7a					.text "bit.z"
.cb0a						nt_asm_bit_zx:
>cb0a		06 0c						.byte 6, IM+NN
>cb0c		18 cb				                .word nt_asm_bmi
>cb0e		28 a4 2d a4					.word xt_asm_bit_zx, z_asm_bit_zx
>cb12		62 69 74 2e 7a 78				.text "bit.zx"
.cb18						nt_asm_bmi:
>cb18		03 0c						.byte 3, IM+NN
>cb1a		23 cb				                .word nt_asm_bne
>cb1c		2d a4 32 a4					.word xt_asm_bmi, z_asm_bmi
>cb20		62 6d 69					.text "bmi"
.cb23						nt_asm_bne:
>cb23		03 0c						.byte 3, IM+NN
>cb25		2e cb				                .word nt_asm_bpl
>cb27		32 a4 37 a4					.word xt_asm_bne, z_asm_bne
>cb2b		62 6e 65					.text "bne"
.cb2e						nt_asm_bpl:
>cb2e		03 0c						.byte 3, IM+NN
>cb30		39 cb				                .word nt_asm_bra
>cb32		37 a4 3c a4					.word xt_asm_bpl, z_asm_bpl
>cb36		62 70 6c					.text "bpl"
.cb39						nt_asm_bra:
>cb39		03 0c						.byte 3, IM+NN
>cb3b		44 cb				                .word nt_asm_brk
>cb3d		3c a4 41 a4					.word xt_asm_bra, z_asm_bra
>cb41		62 72 61					.text "bra"
.cb44						nt_asm_brk:
>cb44		03 0c						.byte 3, IM+NN
>cb46		4f cb				                .word nt_asm_bvc
>cb48		41 a4 46 a4					.word xt_asm_brk, z_asm_brk
>cb4c		62 72 6b					.text "brk"
.cb4f						nt_asm_bvc:
>cb4f		03 0c						.byte 3, IM+NN
>cb51		5a cb				                .word nt_asm_bvs
>cb53		46 a4 4b a4					.word xt_asm_bvc, z_asm_bvc
>cb57		62 76 63					.text "bvc"
.cb5a						nt_asm_bvs:
>cb5a		03 0c						.byte 3, IM+NN
>cb5c		65 cb				                .word nt_asm_clc
>cb5e		4b a4 50 a4					.word xt_asm_bvs, z_asm_bvs
>cb62		62 76 73					.text "bvs"
.cb65						nt_asm_clc:
>cb65		03 0c						.byte 3, IM+NN
>cb67		70 cb				                .word nt_asm_cld
>cb69		50 a4 55 a4					.word xt_asm_clc, z_asm_clc
>cb6d		63 6c 63					.text "clc"
.cb70						nt_asm_cld:
>cb70		03 0c						.byte 3, IM+NN
>cb72		7b cb				                .word nt_asm_cli
>cb74		55 a4 5a a4					.word xt_asm_cld, z_asm_cld
>cb78		63 6c 64					.text "cld"
.cb7b						nt_asm_cli:
>cb7b		03 0c						.byte 3, IM+NN
>cb7d		86 cb				                .word nt_asm_clv
>cb7f		5a a4 5f a4					.word xt_asm_cli, z_asm_cli
>cb83		63 6c 69					.text "cli"
.cb86						nt_asm_clv:
>cb86		03 0c						.byte 3, IM+NN
>cb88		91 cb				                .word nt_asm_cmp
>cb8a		5f a4 64 a4					.word xt_asm_clv, z_asm_clv
>cb8e		63 6c 76					.text "clv"
.cb91						nt_asm_cmp:
>cb91		03 0c						.byte 3, IM+NN
>cb93		9c cb				                .word nt_asm_cmp_h
>cb95		64 a4 69 a4					.word xt_asm_cmp, z_asm_cmp
>cb99		63 6d 70					.text "cmp"
.cb9c						nt_asm_cmp_h:
>cb9c		05 0c						.byte 5, IM+NN
>cb9e		a9 cb				                .word nt_asm_cmp_x
>cba0		69 a4 6e a4					.word xt_asm_cmp_h, z_asm_cmp_h
>cba4		63 6d 70 2e 23					.text "cmp.#"
.cba9						nt_asm_cmp_x:
>cba9		05 0c						.byte 5, IM+NN
>cbab		b6 cb				                .word nt_asm_cmp_y
>cbad		6e a4 73 a4					.word xt_asm_cmp_x, z_asm_cmp_x
>cbb1		63 6d 70 2e 78					.text "cmp.x"
.cbb6						nt_asm_cmp_y:
>cbb6		05 0c						.byte 5, IM+NN
>cbb8		c3 cb				                .word nt_asm_cmp_z
>cbba		73 a4 78 a4					.word xt_asm_cmp_y, z_asm_cmp_y
>cbbe		63 6d 70 2e 79					.text "cmp.y"
.cbc3						nt_asm_cmp_z:
>cbc3		05 0c						.byte 5, IM+NN
>cbc5		d0 cb				                .word nt_asm_cmp_zi
>cbc7		78 a4 7d a4					.word xt_asm_cmp_z, z_asm_cmp_z
>cbcb		63 6d 70 2e 7a					.text "cmp.z"
.cbd0						nt_asm_cmp_zi:
>cbd0		06 0c						.byte 6, IM+NN
>cbd2		de cb				                .word nt_asm_cmp_ziy
>cbd4		7d a4 82 a4					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cbd8		63 6d 70 2e 7a 69				.text "cmp.zi"
.cbde						nt_asm_cmp_ziy:
>cbde		07 0c						.byte 7, IM+NN
>cbe0		ed cb				                .word nt_asm_cmp_zx
>cbe2		82 a4 87 a4					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cbe6		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cbed						nt_asm_cmp_zx:
>cbed		06 0c						.byte 6, IM+NN
>cbef		fb cb				                .word nt_asm_cmp_zxi
>cbf1		87 a4 8c a4					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cbf5		63 6d 70 2e 7a 78				.text "cmp.zx"
.cbfb						nt_asm_cmp_zxi:
>cbfb		07 0c						.byte 7, IM+NN
>cbfd		0a cc				                .word nt_asm_cpx
>cbff		8c a4 91 a4					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cc03		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cc0a						nt_asm_cpx:
>cc0a		03 0c						.byte 3, IM+NN
>cc0c		15 cc				                .word nt_asm_cpx_h
>cc0e		91 a4 96 a4					.word xt_asm_cpx, z_asm_cpx
>cc12		63 70 78					.text "cpx"
.cc15						nt_asm_cpx_h:
>cc15		05 0c						.byte 5, IM+NN
>cc17		22 cc				                .word nt_asm_cpx_z
>cc19		96 a4 9b a4					.word xt_asm_cpx_h, z_asm_cpx_h
>cc1d		63 70 78 2e 23					.text "cpx.#"
.cc22						nt_asm_cpx_z:
>cc22		05 0c						.byte 5, IM+NN
>cc24		2f cc				                .word nt_asm_cpy
>cc26		9b a4 a0 a4					.word xt_asm_cpx_z, z_asm_cpx_z
>cc2a		63 70 78 2e 7a					.text "cpx.z"
.cc2f						nt_asm_cpy:
>cc2f		03 0c						.byte 3, IM+NN
>cc31		3a cc				                .word nt_asm_cpy_h
>cc33		a0 a4 a7 a4					.word xt_asm_cpy, z_asm_cpy
>cc37		63 70 79					.text "cpy"
.cc3a						nt_asm_cpy_h:
>cc3a		05 0c						.byte 5, IM+NN
>cc3c		47 cc				                .word nt_asm_cpy_z
>cc3e		a7 a4 ac a4					.word xt_asm_cpy_h, z_asm_cpy_h
>cc42		63 70 79 2e 23					.text "cpy.#"
.cc47						nt_asm_cpy_z:
>cc47		05 0c						.byte 5, IM+NN
>cc49		54 cc				                .word nt_asm_dec
>cc4b		ac a4 b1 a4					.word xt_asm_cpy_z, z_asm_cpy_z
>cc4f		63 70 79 2e 7a					.text "cpy.z"
.cc54						nt_asm_dec:
>cc54		03 0c						.byte 3, IM+NN
>cc56		5f cc				                .word nt_asm_dec_a
>cc58		b1 a4 b6 a4					.word xt_asm_dec, z_asm_dec
>cc5c		64 65 63					.text "dec"
.cc5f						nt_asm_dec_a:
>cc5f		05 0c						.byte 5, IM+NN
>cc61		6c cc				                .word nt_asm_dec_x
>cc63		b6 a4 bb a4					.word xt_asm_dec_a, z_asm_dec_a
>cc67		64 65 63 2e 61					.text "dec.a"
.cc6c						nt_asm_dec_x:
>cc6c		05 0c						.byte 5, IM+NN
>cc6e		79 cc				                .word nt_asm_dec_z
>cc70		bb a4 c0 a4					.word xt_asm_dec_x, z_asm_dec_x
>cc74		64 65 63 2e 78					.text "dec.x"
.cc79						nt_asm_dec_z:
>cc79		05 0c						.byte 5, IM+NN
>cc7b		86 cc				                .word nt_asm_dec_zx
>cc7d		c0 a4 c5 a4					.word xt_asm_dec_z, z_asm_dec_z
>cc81		64 65 63 2e 7a					.text "dec.z"
.cc86						nt_asm_dec_zx:
>cc86		06 0c						.byte 6, IM+NN
>cc88		94 cc				                .word nt_asm_dex
>cc8a		c5 a4 ca a4					.word xt_asm_dec_zx, z_asm_dec_zx
>cc8e		64 65 63 2e 7a 78				.text "dec.zx"
.cc94						nt_asm_dex:
>cc94		03 0c						.byte 3, IM+NN
>cc96		9f cc				                .word nt_asm_dey
>cc98		ca a4 cf a4					.word xt_asm_dex, z_asm_dex
>cc9c		64 65 78					.text "dex"
.cc9f						nt_asm_dey:
>cc9f		03 0c						.byte 3, IM+NN
>cca1		aa cc				                .word nt_asm_eor
>cca3		cf a4 d4 a4					.word xt_asm_dey, z_asm_dey
>cca7		64 65 79					.text "dey"
.ccaa						nt_asm_eor:
>ccaa		03 0c						.byte 3, IM+NN
>ccac		b5 cc				                .word nt_asm_eor_h
>ccae		d4 a4 d9 a4					.word xt_asm_eor, z_asm_eor
>ccb2		65 6f 72					.text "eor"
.ccb5						nt_asm_eor_h:
>ccb5		05 0c						.byte 5, IM+NN
>ccb7		c2 cc				                .word nt_asm_eor_x
>ccb9		d9 a4 de a4					.word xt_asm_eor_h, z_asm_eor_h
>ccbd		65 6f 72 2e 23					.text "eor.#"
.ccc2						nt_asm_eor_x:
>ccc2		05 0c						.byte 5, IM+NN
>ccc4		cf cc				                .word nt_asm_eor_y
>ccc6		de a4 e3 a4					.word xt_asm_eor_x, z_asm_eor_x
>ccca		65 6f 72 2e 78					.text "eor.x"
.cccf						nt_asm_eor_y:
>cccf		05 0c						.byte 5, IM+NN
>ccd1		dc cc				                .word nt_asm_eor_z
>ccd3		e3 a4 e8 a4					.word xt_asm_eor_y, z_asm_eor_y
>ccd7		65 6f 72 2e 79					.text "eor.y"
.ccdc						nt_asm_eor_z:
>ccdc		05 0c						.byte 5, IM+NN
>ccde		e9 cc				                .word nt_asm_eor_zi
>cce0		e8 a4 ed a4					.word xt_asm_eor_z, z_asm_eor_z
>cce4		65 6f 72 2e 7a					.text "eor.z"
.cce9						nt_asm_eor_zi:
>cce9		06 0c						.byte 6, IM+NN
>cceb		f7 cc				                .word nt_asm_eor_ziy
>cced		ed a4 f2 a4					.word xt_asm_eor_zi, z_asm_eor_zi
>ccf1		65 6f 72 2e 7a 69				.text "eor.zi"
.ccf7						nt_asm_eor_ziy:
>ccf7		07 0c						.byte 7, IM+NN
>ccf9		06 cd				                .word nt_asm_eor_zx
>ccfb		f2 a4 f7 a4					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ccff		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cd06						nt_asm_eor_zx:
>cd06		06 0c						.byte 6, IM+NN
>cd08		14 cd				                .word nt_asm_eor_zxi
>cd0a		f7 a4 fc a4					.word xt_asm_eor_zx, z_asm_eor_zx
>cd0e		65 6f 72 2e 7a 78				.text "eor.zx"
.cd14						nt_asm_eor_zxi:
>cd14		07 0c						.byte 7, IM+NN
>cd16		23 cd				                .word nt_asm_inc
>cd18		fc a4 01 a5					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cd1c		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cd23						nt_asm_inc:
>cd23		03 0c						.byte 3, IM+NN
>cd25		2e cd				                .word nt_asm_inc_a
>cd27		01 a5 06 a5					.word xt_asm_inc, z_asm_inc
>cd2b		69 6e 63					.text "inc"
.cd2e						nt_asm_inc_a:
>cd2e		05 0c						.byte 5, IM+NN
>cd30		3b cd				                .word nt_asm_inc_x
>cd32		06 a5 0b a5					.word xt_asm_inc_a, z_asm_inc_a
>cd36		69 6e 63 2e 61					.text "inc.a"
.cd3b						nt_asm_inc_x:
>cd3b		05 0c						.byte 5, IM+NN
>cd3d		48 cd				                .word nt_asm_inc_z
>cd3f		0b a5 10 a5					.word xt_asm_inc_x, z_asm_inc_x
>cd43		69 6e 63 2e 78					.text "inc.x"
.cd48						nt_asm_inc_z:
>cd48		05 0c						.byte 5, IM+NN
>cd4a		55 cd				                .word nt_asm_inc_zx
>cd4c		10 a5 15 a5					.word xt_asm_inc_z, z_asm_inc_z
>cd50		69 6e 63 2e 7a					.text "inc.z"
.cd55						nt_asm_inc_zx:
>cd55		06 0c						.byte 6, IM+NN
>cd57		63 cd				                .word nt_asm_inx
>cd59		15 a5 1a a5					.word xt_asm_inc_zx, z_asm_inc_zx
>cd5d		69 6e 63 2e 7a 78				.text "inc.zx"
.cd63						nt_asm_inx:
>cd63		03 0c						.byte 3, IM+NN
>cd65		6e cd				                .word nt_asm_iny
>cd67		1a a5 1f a5					.word xt_asm_inx, z_asm_inx
>cd6b		69 6e 78					.text "inx"
.cd6e						nt_asm_iny:
>cd6e		03 0c						.byte 3, IM+NN
>cd70		79 cd				                .word nt_asm_jmp
>cd72		1f a5 24 a5					.word xt_asm_iny, z_asm_iny
>cd76		69 6e 79					.text "iny"
.cd79						nt_asm_jmp:
>cd79		03 0c						.byte 3, IM+NN
>cd7b		84 cd				                .word nt_asm_jmp_i
>cd7d		24 a5 29 a5					.word xt_asm_jmp, z_asm_jmp
>cd81		6a 6d 70					.text "jmp"
.cd84						nt_asm_jmp_i:
>cd84		05 0c						.byte 5, IM+NN
>cd86		91 cd				                .word nt_asm_jmp_xi
>cd88		29 a5 2e a5					.word xt_asm_jmp_i, z_asm_jmp_i
>cd8c		6a 6d 70 2e 69					.text "jmp.i"
.cd91						nt_asm_jmp_xi:
>cd91		06 0c						.byte 6, IM+NN
>cd93		9f cd				                .word nt_asm_jsr
>cd95		2e a5 33 a5					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cd99		6a 6d 70 2e 78 69				.text "jmp.xi"
.cd9f						nt_asm_jsr:
>cd9f		03 0c						.byte 3, IM+NN
>cda1		aa cd				                .word nt_asm_lda
>cda3		33 a5 38 a5					.word xt_asm_jsr, z_asm_jsr
>cda7		6a 73 72					.text "jsr"
.cdaa						nt_asm_lda:
>cdaa		03 0c						.byte 3, IM+NN
>cdac		b5 cd				                .word nt_asm_lda_h
>cdae		38 a5 3d a5					.word xt_asm_lda, z_asm_lda
>cdb2		6c 64 61					.text "lda"
.cdb5						nt_asm_lda_h:
>cdb5		05 0c						.byte 5, IM+NN
>cdb7		c2 cd				                .word nt_asm_lda_x
>cdb9		3d a5 42 a5					.word xt_asm_lda_h, z_asm_lda_h
>cdbd		6c 64 61 2e 23					.text "lda.#"
.cdc2						nt_asm_lda_x:
>cdc2		05 0c						.byte 5, IM+NN
>cdc4		cf cd				                .word nt_asm_lda_y
>cdc6		42 a5 47 a5					.word xt_asm_lda_x, z_asm_lda_x
>cdca		6c 64 61 2e 78					.text "lda.x"
.cdcf						nt_asm_lda_y:
>cdcf		05 0c						.byte 5, IM+NN
>cdd1		dc cd				                .word nt_asm_lda_z
>cdd3		47 a5 4c a5					.word xt_asm_lda_y, z_asm_lda_y
>cdd7		6c 64 61 2e 79					.text "lda.y"
.cddc						nt_asm_lda_z:
>cddc		05 0c						.byte 5, IM+NN
>cdde		e9 cd				                .word nt_asm_lda_zi
>cde0		4c a5 51 a5					.word xt_asm_lda_z, z_asm_lda_z
>cde4		6c 64 61 2e 7a					.text "lda.z"
.cde9						nt_asm_lda_zi:
>cde9		06 0c						.byte 6, IM+NN
>cdeb		f7 cd				                .word nt_asm_lda_ziy
>cded		51 a5 56 a5					.word xt_asm_lda_zi, z_asm_lda_zi
>cdf1		6c 64 61 2e 7a 69				.text "lda.zi"
.cdf7						nt_asm_lda_ziy:
>cdf7		07 0c						.byte 7, IM+NN
>cdf9		06 ce				                .word nt_asm_lda_zx
>cdfb		56 a5 5b a5					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cdff		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.ce06						nt_asm_lda_zx:
>ce06		06 0c						.byte 6, IM+NN
>ce08		14 ce				                .word nt_asm_lda_zxi
>ce0a		5b a5 60 a5					.word xt_asm_lda_zx, z_asm_lda_zx
>ce0e		6c 64 61 2e 7a 78				.text "lda.zx"
.ce14						nt_asm_lda_zxi:
>ce14		07 0c						.byte 7, IM+NN
>ce16		23 ce				                .word nt_asm_ldx
>ce18		60 a5 65 a5					.word xt_asm_lda_zxi, z_asm_lda_zxi
>ce1c		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.ce23						nt_asm_ldx:
>ce23		03 0c						.byte 3, IM+NN
>ce25		2e ce				                .word nt_asm_ldx_h
>ce27		65 a5 6a a5					.word xt_asm_ldx, z_asm_ldx
>ce2b		6c 64 78					.text "ldx"
.ce2e						nt_asm_ldx_h:
>ce2e		05 0c						.byte 5, IM+NN
>ce30		3b ce				                .word nt_asm_ldx_y
>ce32		6a a5 6f a5					.word xt_asm_ldx_h, z_asm_ldx_h
>ce36		6c 64 78 2e 23					.text "ldx.#"
.ce3b						nt_asm_ldx_y:
>ce3b		05 0c						.byte 5, IM+NN
>ce3d		48 ce				                .word nt_asm_ldx_z
>ce3f		6f a5 74 a5					.word xt_asm_ldx_y, z_asm_ldx_y
>ce43		6c 64 78 2e 79					.text "ldx.y"
.ce48						nt_asm_ldx_z:
>ce48		05 0c						.byte 5, IM+NN
>ce4a		55 ce				                .word nt_asm_ldx_zy
>ce4c		74 a5 79 a5					.word xt_asm_ldx_z, z_asm_ldx_z
>ce50		6c 64 78 2e 7a					.text "ldx.z"
.ce55						nt_asm_ldx_zy:
>ce55		06 0c						.byte 6, IM+NN
>ce57		63 ce				                .word nt_asm_ldy
>ce59		79 a5 7e a5					.word xt_asm_ldx_zy, z_asm_ldx_zy
>ce5d		6c 64 78 2e 7a 79				.text "ldx.zy"
.ce63						nt_asm_ldy:
>ce63		03 0c						.byte 3, IM+NN
>ce65		6e ce				                .word nt_asm_ldy_h
>ce67		7e a5 83 a5					.word xt_asm_ldy, z_asm_ldy
>ce6b		6c 64 79					.text "ldy"
.ce6e						nt_asm_ldy_h:
>ce6e		05 0c						.byte 5, IM+NN
>ce70		7b ce				                .word nt_asm_ldy_x
>ce72		83 a5 88 a5					.word xt_asm_ldy_h, z_asm_ldy_h
>ce76		6c 64 79 2e 23					.text "ldy.#"
.ce7b						nt_asm_ldy_x:
>ce7b		05 0c						.byte 5, IM+NN
>ce7d		88 ce				                .word nt_asm_ldy_z
>ce7f		88 a5 8d a5					.word xt_asm_ldy_x, z_asm_ldy_x
>ce83		6c 64 79 2e 78					.text "ldy.x"
.ce88						nt_asm_ldy_z:
>ce88		05 0c						.byte 5, IM+NN
>ce8a		95 ce				                .word nt_asm_ldy_zx
>ce8c		8d a5 92 a5					.word xt_asm_ldy_z, z_asm_ldy_z
>ce90		6c 64 79 2e 7a					.text "ldy.z"
.ce95						nt_asm_ldy_zx:
>ce95		06 0c						.byte 6, IM+NN
>ce97		a3 ce				                .word nt_asm_lsr
>ce99		92 a5 97 a5					.word xt_asm_ldy_zx, z_asm_ldy_zx
>ce9d		6c 64 79 2e 7a 78				.text "ldy.zx"
.cea3						nt_asm_lsr:
>cea3		03 0c						.byte 3, IM+NN
>cea5		ae ce				                .word nt_asm_lsr_a
>cea7		97 a5 9c a5					.word xt_asm_lsr, z_asm_lsr
>ceab		6c 73 72					.text "lsr"
.ceae						nt_asm_lsr_a:
>ceae		05 0c						.byte 5, IM+NN
>ceb0		bb ce				                .word nt_asm_lsr_x
>ceb2		9c a5 a1 a5					.word xt_asm_lsr_a, z_asm_lsr_a
>ceb6		6c 73 72 2e 61					.text "lsr.a"
.cebb						nt_asm_lsr_x:
>cebb		05 0c						.byte 5, IM+NN
>cebd		c8 ce				                .word nt_asm_lsr_z
>cebf		a1 a5 a6 a5					.word xt_asm_lsr_x, z_asm_lsr_x
>cec3		6c 73 72 2e 78					.text "lsr.x"
.cec8						nt_asm_lsr_z:
>cec8		05 0c						.byte 5, IM+NN
>ceca		d5 ce				                .word nt_asm_lsr_zx
>cecc		a6 a5 ab a5					.word xt_asm_lsr_z, z_asm_lsr_z
>ced0		6c 73 72 2e 7a					.text "lsr.z"
.ced5						nt_asm_lsr_zx:
>ced5		06 0c						.byte 6, IM+NN
>ced7		e3 ce				                .word nt_asm_nop
>ced9		ab a5 b0 a5					.word xt_asm_lsr_zx, z_asm_lsr_zx
>cedd		6c 73 72 2e 7a 78				.text "lsr.zx"
.cee3						nt_asm_nop:
>cee3		03 0c						.byte 3, IM+NN
>cee5		ee ce				                .word nt_asm_ora
>cee7		b0 a5 b5 a5					.word xt_asm_nop, z_asm_nop
>ceeb		6e 6f 70					.text "nop"
.ceee						nt_asm_ora:
>ceee		03 0c						.byte 3, IM+NN
>cef0		f9 ce				                .word nt_asm_ora_h
>cef2		b5 a5 ba a5					.word xt_asm_ora, z_asm_ora
>cef6		6f 72 61					.text "ora"
.cef9						nt_asm_ora_h:
>cef9		05 0c						.byte 5, IM+NN
>cefb		06 cf				                .word nt_asm_ora_x
>cefd		ba a5 bf a5					.word xt_asm_ora_h, z_asm_ora_h
>cf01		6f 72 61 2e 23					.text "ora.#"
.cf06						nt_asm_ora_x:
>cf06		05 0c						.byte 5, IM+NN
>cf08		13 cf				                .word nt_asm_ora_y
>cf0a		bf a5 c4 a5					.word xt_asm_ora_x, z_asm_ora_x
>cf0e		6f 72 61 2e 78					.text "ora.x"
.cf13						nt_asm_ora_y:
>cf13		05 0c						.byte 5, IM+NN
>cf15		20 cf				                .word nt_asm_ora_z
>cf17		c4 a5 c9 a5					.word xt_asm_ora_y, z_asm_ora_y
>cf1b		6f 72 61 2e 79					.text "ora.y"
.cf20						nt_asm_ora_z:
>cf20		05 0c						.byte 5, IM+NN
>cf22		2d cf				                .word nt_asm_ora_zi
>cf24		c9 a5 ce a5					.word xt_asm_ora_z, z_asm_ora_z
>cf28		6f 72 61 2e 7a					.text "ora.z"
.cf2d						nt_asm_ora_zi:
>cf2d		06 0c						.byte 6, IM+NN
>cf2f		3b cf				                .word nt_asm_ora_ziy
>cf31		ce a5 d5 a5					.word xt_asm_ora_zi, z_asm_ora_zi
>cf35		6f 72 61 2e 7a 69				.text "ora.zi"
.cf3b						nt_asm_ora_ziy:
>cf3b		07 0c						.byte 7, IM+NN
>cf3d		4a cf				                .word nt_asm_ora_zx
>cf3f		d5 a5 da a5					.word xt_asm_ora_ziy, z_asm_ora_ziy
>cf43		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.cf4a						nt_asm_ora_zx:
>cf4a		06 0c						.byte 6, IM+NN
>cf4c		58 cf				                .word nt_asm_ora_zxi
>cf4e		da a5 df a5					.word xt_asm_ora_zx, z_asm_ora_zx
>cf52		6f 72 61 2e 7a 78				.text "ora.zx"
.cf58						nt_asm_ora_zxi:
>cf58		07 0c						.byte 7, IM+NN
>cf5a		67 cf				                .word nt_asm_pha
>cf5c		df a5 e4 a5					.word xt_asm_ora_zxi, z_asm_ora_zxi
>cf60		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.cf67						nt_asm_pha:
>cf67		03 0c						.byte 3, IM+NN
>cf69		72 cf				                .word nt_asm_php
>cf6b		e4 a5 e9 a5					.word xt_asm_pha, z_asm_pha
>cf6f		70 68 61					.text "pha"
.cf72						nt_asm_php:
>cf72		03 0c						.byte 3, IM+NN
>cf74		7d cf				                .word nt_asm_phx
>cf76		e9 a5 ee a5					.word xt_asm_php, z_asm_php
>cf7a		70 68 70					.text "php"
.cf7d						nt_asm_phx:
>cf7d		03 0c						.byte 3, IM+NN
>cf7f		88 cf				                .word nt_asm_phy
>cf81		ee a5 f3 a5					.word xt_asm_phx, z_asm_phx
>cf85		70 68 78					.text "phx"
.cf88						nt_asm_phy:
>cf88		03 0c						.byte 3, IM+NN
>cf8a		93 cf				                .word nt_asm_pla
>cf8c		f3 a5 f8 a5					.word xt_asm_phy, z_asm_phy
>cf90		70 68 79					.text "phy"
.cf93						nt_asm_pla:
>cf93		03 0c						.byte 3, IM+NN
>cf95		9e cf				                .word nt_asm_plp
>cf97		f8 a5 fd a5					.word xt_asm_pla, z_asm_pla
>cf9b		70 6c 61					.text "pla"
.cf9e						nt_asm_plp:
>cf9e		03 0c						.byte 3, IM+NN
>cfa0		a9 cf				                .word nt_asm_plx
>cfa2		fd a5 02 a6					.word xt_asm_plp, z_asm_plp
>cfa6		70 6c 70					.text "plp"
.cfa9						nt_asm_plx:
>cfa9		03 0c						.byte 3, IM+NN
>cfab		b4 cf				                .word nt_asm_ply
>cfad		02 a6 07 a6					.word xt_asm_plx, z_asm_plx
>cfb1		70 6c 78					.text "plx"
.cfb4						nt_asm_ply:
>cfb4		03 0c						.byte 3, IM+NN
>cfb6		bf cf				                .word nt_asm_rol
>cfb8		07 a6 0c a6					.word xt_asm_ply, z_asm_ply
>cfbc		70 6c 79					.text "ply"
.cfbf						nt_asm_rol:
>cfbf		03 0c						.byte 3, IM+NN
>cfc1		ca cf				                .word nt_asm_rol_a
>cfc3		0c a6 11 a6					.word xt_asm_rol, z_asm_rol
>cfc7		72 6f 6c					.text "rol"
.cfca						nt_asm_rol_a:
>cfca		05 0c						.byte 5, IM+NN
>cfcc		d7 cf				                .word nt_asm_rol_x
>cfce		11 a6 16 a6					.word xt_asm_rol_a, z_asm_rol_a
>cfd2		72 6f 6c 2e 61					.text "rol.a"
.cfd7						nt_asm_rol_x:
>cfd7		05 0c						.byte 5, IM+NN
>cfd9		e4 cf				                .word nt_asm_rol_z
>cfdb		16 a6 1b a6					.word xt_asm_rol_x, z_asm_rol_x
>cfdf		72 6f 6c 2e 78					.text "rol.x"
.cfe4						nt_asm_rol_z:
>cfe4		05 0c						.byte 5, IM+NN
>cfe6		f1 cf				                .word nt_asm_rol_zx
>cfe8		1b a6 20 a6					.word xt_asm_rol_z, z_asm_rol_z
>cfec		72 6f 6c 2e 7a					.text "rol.z"
.cff1						nt_asm_rol_zx:
>cff1		06 0c						.byte 6, IM+NN
>cff3		ff cf				                .word nt_asm_ror
>cff5		20 a6 25 a6					.word xt_asm_rol_zx, z_asm_rol_zx
>cff9		72 6f 6c 2e 7a 78				.text "rol.zx"
.cfff						nt_asm_ror:
>cfff		03 0c						.byte 3, IM+NN
>d001		0a d0				                .word nt_asm_ror_a
>d003		25 a6 2a a6					.word xt_asm_ror, z_asm_ror
>d007		72 6f 72					.text "ror"
.d00a						nt_asm_ror_a:
>d00a		05 0c						.byte 5, IM+NN
>d00c		17 d0				                .word nt_asm_ror_x
>d00e		2a a6 2f a6					.word xt_asm_ror_a, z_asm_ror_a
>d012		72 6f 72 2e 61					.text "ror.a"
.d017						nt_asm_ror_x:
>d017		05 0c						.byte 5, IM+NN
>d019		24 d0				                .word nt_asm_ror_z
>d01b		2f a6 34 a6					.word xt_asm_ror_x, z_asm_ror_x
>d01f		72 6f 72 2e 78					.text "ror.x"
.d024						nt_asm_ror_z:
>d024		05 0c						.byte 5, IM+NN
>d026		31 d0				                .word nt_asm_ror_zx
>d028		34 a6 39 a6					.word xt_asm_ror_z, z_asm_ror_z
>d02c		72 6f 72 2e 7a					.text "ror.z"
.d031						nt_asm_ror_zx:
>d031		06 0c						.byte 6, IM+NN
>d033		3f d0				                .word nt_asm_rti
>d035		39 a6 3e a6					.word xt_asm_ror_zx, z_asm_ror_zx
>d039		72 6f 72 2e 7a 78				.text "ror.zx"
.d03f						nt_asm_rti:
>d03f		03 0c						.byte 3, IM+NN
>d041		4a d0				                .word nt_asm_rts
>d043		3e a6 43 a6					.word xt_asm_rti, z_asm_rti
>d047		72 74 69					.text "rti"
.d04a						nt_asm_rts:
>d04a		03 0c						.byte 3, IM+NN
>d04c		55 d0				                .word nt_asm_sbc
>d04e		43 a6 48 a6					.word xt_asm_rts, z_asm_rts
>d052		72 74 73					.text "rts"
.d055						nt_asm_sbc:
>d055		03 0c						.byte 3, IM+NN
>d057		60 d0				                .word nt_asm_sbc_h
>d059		48 a6 4d a6					.word xt_asm_sbc, z_asm_sbc
>d05d		73 62 63					.text "sbc"
.d060						nt_asm_sbc_h:
>d060		05 0c						.byte 5, IM+NN
>d062		6d d0				                .word nt_asm_sbc_x
>d064		4d a6 52 a6					.word xt_asm_sbc_h, z_asm_sbc_h
>d068		73 62 63 2e 23					.text "sbc.#"
.d06d						nt_asm_sbc_x:
>d06d		05 0c						.byte 5, IM+NN
>d06f		7a d0				                .word nt_asm_sbc_y
>d071		52 a6 57 a6					.word xt_asm_sbc_x, z_asm_sbc_x
>d075		73 62 63 2e 78					.text "sbc.x"
.d07a						nt_asm_sbc_y:
>d07a		05 0c						.byte 5, IM+NN
>d07c		87 d0				                .word nt_asm_sbc_z
>d07e		57 a6 5c a6					.word xt_asm_sbc_y, z_asm_sbc_y
>d082		73 62 63 2e 79					.text "sbc.y"
.d087						nt_asm_sbc_z:
>d087		05 0c						.byte 5, IM+NN
>d089		94 d0				                .word nt_asm_sbc_zi
>d08b		5c a6 61 a6					.word xt_asm_sbc_z, z_asm_sbc_z
>d08f		73 62 63 2e 7a					.text "sbc.z"
.d094						nt_asm_sbc_zi:
>d094		06 0c						.byte 6, IM+NN
>d096		a2 d0				                .word nt_asm_sbc_ziy
>d098		61 a6 66 a6					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d09c		73 62 63 2e 7a 69				.text "sbc.zi"
.d0a2						nt_asm_sbc_ziy:
>d0a2		07 0c						.byte 7, IM+NN
>d0a4		b1 d0				                .word nt_asm_sbc_zx
>d0a6		66 a6 6b a6					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d0aa		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d0b1						nt_asm_sbc_zx:
>d0b1		06 0c						.byte 6, IM+NN
>d0b3		bf d0				                .word nt_asm_sbc_zxi
>d0b5		6b a6 70 a6					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d0b9		73 62 63 2e 7a 78				.text "sbc.zx"
.d0bf						nt_asm_sbc_zxi:
>d0bf		07 0c						.byte 7, IM+NN
>d0c1		ce d0				                .word nt_asm_sec
>d0c3		70 a6 74 a6					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d0c7		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d0ce						nt_asm_sec:
>d0ce		03 0c						.byte 3, IM+NN
>d0d0		d9 d0				                .word nt_asm_sed
>d0d2		74 a6 78 a6					.word xt_asm_sec, z_asm_sec
>d0d6		73 65 63					.text "sec"
.d0d9						nt_asm_sed:
>d0d9		03 0c						.byte 3, IM+NN
>d0db		e4 d0				                .word nt_asm_sei
>d0dd		78 a6 7c a6					.word xt_asm_sed, z_asm_sed
>d0e1		73 65 64					.text "sed"
.d0e4						nt_asm_sei:
>d0e4		03 0c						.byte 3, IM+NN
>d0e6		ef d0				                .word nt_asm_sta
>d0e8		7c a6 80 a6					.word xt_asm_sei, z_asm_sei
>d0ec		73 65 69					.text "sei"
.d0ef						nt_asm_sta:
>d0ef		03 0c						.byte 3, IM+NN
>d0f1		fa d0				                .word nt_asm_sta_x
>d0f3		80 a6 84 a6					.word xt_asm_sta, z_asm_sta
>d0f7		73 74 61					.text "sta"
.d0fa						nt_asm_sta_x:
>d0fa		05 0c						.byte 5, IM+NN
>d0fc		07 d1				                .word nt_asm_sta_y
>d0fe		84 a6 88 a6					.word xt_asm_sta_x, z_asm_sta_x
>d102		73 74 61 2e 78					.text "sta.x"
.d107						nt_asm_sta_y:
>d107		05 0c						.byte 5, IM+NN
>d109		14 d1				                .word nt_asm_sta_z
>d10b		88 a6 8c a6					.word xt_asm_sta_y, z_asm_sta_y
>d10f		73 74 61 2e 79					.text "sta.y"
.d114						nt_asm_sta_z:
>d114		05 0c						.byte 5, IM+NN
>d116		21 d1				                .word nt_asm_sta_zi
>d118		8c a6 90 a6					.word xt_asm_sta_z, z_asm_sta_z
>d11c		73 74 61 2e 7a					.text "sta.z"
.d121						nt_asm_sta_zi:
>d121		06 0c						.byte 6, IM+NN
>d123		2f d1				                .word nt_asm_sta_ziy
>d125		90 a6 94 a6					.word xt_asm_sta_zi, z_asm_sta_zi
>d129		73 74 61 2e 7a 69				.text "sta.zi"
.d12f						nt_asm_sta_ziy:
>d12f		07 0c						.byte 7, IM+NN
>d131		3e d1				                .word nt_asm_sta_zx
>d133		94 a6 98 a6					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d137		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d13e						nt_asm_sta_zx:
>d13e		06 0c						.byte 6, IM+NN
>d140		4c d1				                .word nt_asm_sta_zxi
>d142		98 a6 9c a6					.word xt_asm_sta_zx, z_asm_sta_zx
>d146		73 74 61 2e 7a 78				.text "sta.zx"
.d14c						nt_asm_sta_zxi:
>d14c		07 0c						.byte 7, IM+NN
>d14e		5b d1				                .word nt_asm_stx
>d150		9c a6 a0 a6					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d154		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d15b						nt_asm_stx:
>d15b		03 0c						.byte 3, IM+NN
>d15d		66 d1				                .word nt_asm_stx_z
>d15f		a0 a6 a4 a6					.word xt_asm_stx, z_asm_stx
>d163		73 74 78					.text "stx"
.d166						nt_asm_stx_z:
>d166		05 0c						.byte 5, IM+NN
>d168		73 d1				                .word nt_asm_stx_zy
>d16a		a4 a6 a8 a6					.word xt_asm_stx_z, z_asm_stx_z
>d16e		73 74 78 2e 7a					.text "stx.z"
.d173						nt_asm_stx_zy:
>d173		06 0c						.byte 6, IM+NN
>d175		81 d1				                .word nt_asm_sty
>d177		a8 a6 ac a6					.word xt_asm_stx_zy, z_asm_stx_zy
>d17b		73 74 78 2e 7a 79				.text "stx.zy"
.d181						nt_asm_sty:
>d181		03 0c						.byte 3, IM+NN
>d183		8c d1				                .word nt_asm_sty_z
>d185		ac a6 b0 a6					.word xt_asm_sty, z_asm_sty
>d189		73 74 79					.text "sty"
.d18c						nt_asm_sty_z:
>d18c		05 0c						.byte 5, IM+NN
>d18e		99 d1				                .word nt_asm_sty_zx
>d190		b0 a6 b4 a6					.word xt_asm_sty_z, z_asm_sty_z
>d194		73 74 79 2e 7a					.text "sty.z"
.d199						nt_asm_sty_zx:
>d199		06 0c						.byte 6, IM+NN
>d19b		a7 d1				                .word nt_asm_stz
>d19d		b4 a6 b8 a6					.word xt_asm_sty_zx, z_asm_sty_zx
>d1a1		73 74 79 2e 7a 78				.text "sty.zx"
.d1a7						nt_asm_stz:
>d1a7		03 0c						.byte 3, IM+NN
>d1a9		b2 d1				                .word nt_asm_stz_x
>d1ab		b8 a6 bc a6					.word xt_asm_stz, z_asm_stz
>d1af		73 74 7a					.text "stz"
.d1b2						nt_asm_stz_x:
>d1b2		05 0c						.byte 5, IM+NN
>d1b4		bf d1				                .word nt_asm_stz_z
>d1b6		bc a6 c0 a6					.word xt_asm_stz_x, z_asm_stz_x
>d1ba		73 74 7a 2e 78					.text "stz.x"
.d1bf						nt_asm_stz_z:
>d1bf		05 0c						.byte 5, IM+NN
>d1c1		cc d1				                .word nt_asm_stz_zx
>d1c3		c0 a6 c4 a6					.word xt_asm_stz_z, z_asm_stz_z
>d1c7		73 74 7a 2e 7a					.text "stz.z"
.d1cc						nt_asm_stz_zx:
>d1cc		06 0c						.byte 6, IM+NN
>d1ce		da d1				                .word nt_asm_tax
>d1d0		c4 a6 c8 a6					.word xt_asm_stz_zx, z_asm_stz_zx
>d1d4		73 74 7a 2e 7a 78				.text "stz.zx"
.d1da						nt_asm_tax:
>d1da		03 0c						.byte 3, IM+NN
>d1dc		e5 d1				                .word nt_asm_tay
>d1de		c8 a6 cc a6					.word xt_asm_tax, z_asm_tax
>d1e2		74 61 78					.text "tax"
.d1e5						nt_asm_tay:
>d1e5		03 0c						.byte 3, IM+NN
>d1e7		f0 d1				                .word nt_asm_trb
>d1e9		cc a6 d0 a6					.word xt_asm_tay, z_asm_tay
>d1ed		74 61 79					.text "tay"
.d1f0						nt_asm_trb:
>d1f0		03 0c						.byte 3, IM+NN
>d1f2		fb d1				                .word nt_asm_trb_z
>d1f4		d0 a6 d4 a6					.word xt_asm_trb, z_asm_trb
>d1f8		74 72 62					.text "trb"
.d1fb						nt_asm_trb_z:
>d1fb		05 0c						.byte 5, IM+NN
>d1fd		08 d2				                .word nt_asm_tsb
>d1ff		d4 a6 d8 a6					.word xt_asm_trb_z, z_asm_trb_z
>d203		74 72 62 2e 7a					.text "trb.z"
.d208						nt_asm_tsb:
>d208		03 0c						.byte 3, IM+NN
>d20a		13 d2				                .word nt_asm_tsb_z
>d20c		d8 a6 dc a6					.word xt_asm_tsb, z_asm_tsb
>d210		74 73 62					.text "tsb"
.d213						nt_asm_tsb_z:
>d213		05 0c						.byte 5, IM+NN
>d215		20 d2				                .word nt_asm_tsx
>d217		dc a6 e0 a6					.word xt_asm_tsb_z, z_asm_tsb_z
>d21b		74 73 62 2e 7a					.text "tsb.z"
.d220						nt_asm_tsx:
>d220		03 0c						.byte 3, IM+NN
>d222		2b d2				                .word nt_asm_txa
>d224		e0 a6 e4 a6					.word xt_asm_tsx, z_asm_tsx
>d228		74 73 78					.text "tsx"
.d22b						nt_asm_txa:
>d22b		03 0c						.byte 3, IM+NN
>d22d		36 d2				                .word nt_asm_txs
>d22f		e4 a6 e8 a6					.word xt_asm_txa, z_asm_txa
>d233		74 78 61					.text "txa"
.d236						nt_asm_txs:
>d236		03 0c						.byte 3, IM+NN
>d238		41 d2				                .word nt_asm_tya
>d23a		e8 a6 ec a6					.word xt_asm_txs, z_asm_txs
>d23e		74 78 73					.text "txs"
.d241						nt_asm_tya:
>d241		03 0c						.byte 3, IM+NN
>d243		4c d2				                .word nt_asm_arrow
>d245		ec a6 f0 a6					.word xt_asm_tya, z_asm_tya
>d249		74 79 61					.text "tya"
.d24c						nt_asm_arrow:
>d24c		03 04				                .byte 3, IM
>d24e		57 d2				                .word nt_asm_back_jump
>d250		02 8a 0c 8a			                .word xt_asm_arrow, z_asm_arrow
>d254		2d 2d 3e			                .text "-->"
.d257						nt_asm_back_jump:
>d257		02 04				                .byte 2, IM
>d259		61 d2				                .word nt_asm_back_branch
>d25b		41 a7 41 a7			                .word xt_asm_back_jump, z_asm_back_jump
>d25f		3c 6a				                .text "<j"
.d261						nt_asm_back_branch:
>d261		02 04				                .byte 2, IM
>d263		6b d2				                .word nt_asm_push_a
>d265		42 a7 4a a7			                .word xt_asm_back_branch, z_asm_back_branch
>d269		3c 62				                .text "<b"
.d26b						nt_asm_push_a:
>d26b		06 0c				                .byte 6, IM+NN
>d26d		00 00				                .word 0000
>d26f		2a a7 39 a7			                .word xt_asm_push_a, z_asm_push_a
>d273		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix
=1						ix += 1
=1						str_compile        = ix
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_sdc     = ix
=14						ix += 1
=14						str_disasm_bra     = ix
=15						ix += 1
=15						str_disasm_0test   = ix
=16						ix += 1
.d279						string_table:
>d279		99 d2 9d d2 a7 d2 b2 d2		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d281		e9 d2 e1 d2 d6 d2 f0 d2		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d289		f6 d2 12 d3 17 d3 1c d3		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d291		2d d3 36 d3 48 d3 50 d3		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra, s_disasm_0test ; 12-15
>d299		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d29d		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d2a5		64 00
>d2a7		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d2af		64 20 00
>d2b2		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d2ba		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d2ca		4f 50 51 52 53 54 55 56 57 58 59 5a
>d2d6		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d2de		72 20 00
>d2e1		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d2e9		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d2f0		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d2f6		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d2fe		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d30e		29 3a 20 00
>d312		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d317		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d31c		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d324		63 69 6d 61 6c 29 3a 20 00
>d32d		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d335		00
>d336		53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d33e		50 54 48 20 43 48 45 43 4b 00
>d348		42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
>d350		30 54 45 53 54 00		s_disasm_0test: .text "0TEST",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d356						error_table:
>d356		72 d3 93 d3 b3 d3 d4 d3		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d35e		f1 d3 02 d4 12 d4 40 d4		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d366		58 d4 79 d4 8e d4 aa d4		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d36e		c1 d4 00 d5			        .word es_blockwords, es_returnstack                     ; 12-13
>d372		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d37a		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d38a		65 20 6d 65 6d 6f 72 79 00
>d393		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d39b		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d3ab		20 52 45 46 49 4c 4c 00
>d3b3		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d3bb		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d3cb		6e 6c 79 20 77 6f 72 64 00
>d3d4		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d3dc		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d3ec		20 79 65 74 00
>d3f1		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d3f9		20 62 79 20 7a 65 72 6f 00
>d402		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d40a		66 61 69 6c 75 72 65 00
>d412		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d41a		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d42a		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d43a		64 20 2d 31 29 00
>d440		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d448		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d458		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d460		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d470		64 20 6e 75 6d 62 65 72 00
>d479		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d481		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d48e		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d496		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d4a6		4c 4f 54 00
>d4aa		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d4b2		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d4c1		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d4c9		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d4d9		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d4e9		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d4f9		56 45 43 54 4f 52 00
>d500		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d508		74 61 63 6b 3a 00
>d50e		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d516		44 2d 53 54 52 49 4e 47
>d51e		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d524		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d529		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d531		2d 55 4e 49 54 2d 42 49 54 53
>d53b		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d543		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d54b		52
>d54c		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d552		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d558		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d560		53 54 41 43 4b 2d 43 45 4c 4c 53
>d56b		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d573		45 4c 4c 53
>d577		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d57f		54 53
>d581		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d587		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d58e						cmpl_call_ya:
.d58e		48		pha		                pha             ; save LSB of address
.d58f		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR
.d591		80 03		bra $d596	                bra +
.d593						cmpl_jump_ya:
.d593		48		pha		                pha             ; save LSB of address
.d594		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP, fall thru
.d596						+
.d596		20 9e d5	jsr $d59e	                jsr cmpl_byte_a      ; compile opcode
.d599		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word_ya
.d59a						cmpl_word_ya:
.d59a		20 9e d5	jsr $d59e	                jsr cmpl_byte_a      ; compile LSB of address
.d59d		98		tya		                tya             ; fall thru for MSB
.d59e						cmpl_byte_a:
.d59e		92 00		sta ($00)	                sta (cp)
.d5a0		e6 00		inc $00		                inc cp
.d5a2		d0 02		bne $d5a6	                bne _done
.d5a4		e6 01		inc $01		                inc cp+1
.d5a6						_done:
.d5a6		60		rts		                rts
.d5a7						cmpl_call_tos:
.d5a7		a9 20		lda #$20	                lda #OpJSR
.d5a9		80 02		bra $d5ad	                bra +
.d5ab						cmpl_jump_tos:
.d5ab		a9 4c		lda #$4c	                lda #OpJMP
.d5ad						+
.d5ad		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.d5b0		4c cf 83	jmp $83cf	                jmp xt_comma
.d5b3						cmpl_jump_later:
.d5b3		a9 4c		lda #$4c	                lda #OpJMP
.d5b5		20 9e d5	jsr $d59e	                jsr cmpl_byte_a
.d5b8		20 02 8a	jsr $8a02	                jsr xt_here
.d5bb		80 dd		bra $d59a	                bra cmpl_word_ya
.d5bd						check_nc_limit:
.d5bd		48		pha		                pha
.d5be		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.d5c0		18		clc		                clc
.d5c1		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're done, leave with C=0
.d5c3		d0 06		bne $d5cb	                bne _done
.d5c5		68		pla		                pla
.d5c6		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.d5c7		88		dey		                dey
.d5c8		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.d5ca		1a		inc a		                ina                     ; restore A
.d5cb						_done:
.d5cb		60		rts		                rts
.d5cc						doconst:
.d5cc		ca		dex		                dex             ; make room for constant
.d5cd		ca		dex		                dex
.d5ce		68		pla		                pla             ; LSB of return address
.d5cf		85 25		sta $25		                sta tmp1
.d5d1		68		pla		                pla             ; MSB of return address
.d5d2		85 26		sta $26		                sta tmp1+1
.d5d4		a0 01		ldy #$01	                ldy #1
.d5d6		b1 25		lda ($25),y	                lda (tmp1),y
.d5d8		95 00		sta $00,x	                sta 0,x
.d5da		c8		iny		                iny
.d5db		b1 25		lda ($25),y	                lda (tmp1),y
.d5dd		95 01		sta $01,x	                sta 1,x
.d5df		60		rts		                rts
.d5e0						dodefer:
.d5e0		68		pla		                pla             ; LSB
.d5e1		85 25		sta $25		                sta tmp1
.d5e3		68		pla		                pla             ; MSB
.d5e4		85 26		sta $26		                sta tmp1+1
.d5e6		a0 01		ldy #$01	                ldy #1
.d5e8		b1 25		lda ($25),y	                lda (tmp1),y
.d5ea		85 27		sta $27		                sta tmp2
.d5ec		c8		iny		                iny
.d5ed		b1 25		lda ($25),y	                lda (tmp1),y
.d5ef		85 28		sta $28		                sta tmp2+1
.d5f1		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d5f4						defer_error:
.d5f4		a9 03		lda #$03	                lda #err_defer
.d5f6		4c 7a d7	jmp $d77a	                jmp error
.d5f9						dodoes:
.d5f9		7a		ply		                ply             ; LSB
.d5fa		68		pla		                pla             ; MSB
.d5fb		c8		iny		                iny
.d5fc		d0 01		bne $d5ff	                bne +
.d5fe		1a		inc a		                ina
.d5ff						+
.d5ff		84 27		sty $27		                sty tmp2
.d601		85 28		sta $28		                sta tmp2+1
.d603		ca		dex		                dex
.d604		ca		dex		                dex
.d605		7a		ply		                ply
.d606		68		pla		                pla
.d607		c8		iny		                iny
.d608		d0 01		bne $d60b	                bne +
.d60a		1a		inc a		                ina
.d60b						+
.d60b		94 00		sty $00,x	                sty 0,x         ; LSB
.d60d		95 01		sta $01,x	                sta 1,x         ; MSB
.d60f		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d612						dovar:
.d612		7a		ply		                ply             ; LSB
.d613		68		pla		                pla             ; MSB
.d614		c8		iny		                iny
.d615		d0 01		bne $d618	                bne +
.d617		1a		inc a		                ina
.d618						+
.d618		ca		dex		                dex
.d619		ca		dex		                dex
.d61a		95 01		sta $01,x	                sta 1,x
.d61c		98		tya		                tya
.d61d		95 00		sta $00,x	                sta 0,x
.d61f		60		rts		                rts
.d620						push_upvar_tos:
.d620		ca		dex		                dex
.d621		ca		dex		                dex
.d622		18		clc		                clc
.d623		65 08		adc $08		                adc up
.d625		95 00		sta $00,x	                sta 0,x
.d627		a5 09		lda $09		                lda up+1
.d629		90 01		bcc $d62c	                bcc +
.d62b		1a		inc a		                ina
.d62c						+
.d62c		95 01		sta $01,x	                sta 1,x
.d62e		60		rts		                rts
.d62f						byte_to_ascii:
.d62f		48		pha		                pha
.d630		4a		lsr a		                lsr             ; convert high nibble first
.d631		4a		lsr a		                lsr
.d632		4a		lsr a		                lsr
.d633		4a		lsr a		                lsr
.d634		20 38 d6	jsr $d638	                jsr _nibble_to_ascii
.d637		68		pla		                pla
.d638						_nibble_to_ascii:
.d638		29 0f		and #$0f	                and #$F
.d63a		09 30		ora #$30	                ora #'0'
.d63c		c9 3a		cmp #$3a	                cmp #'9'+1
.d63e		90 02		bcc $d642	                bcc +
.d640		69 06		adc #$06	                adc #6
.d642		4c ac 87	jmp $87ac	+               jmp emit_a
.d645		60		rts		                rts
.d646						find_header_name:
.d646		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d648		85 27		sta $27		                sta tmp2
.d64a		b5 03		lda $03,x	                lda 3,x
.d64c		85 28		sta $28		                sta tmp2+1
.d64e						_loop:
.d64e		b2 25		lda ($25)	                lda (tmp1)
.d650		d5 00		cmp $00,x	                cmp 0,x
.d652		d0 3a		bne $d68e	                bne _next_entry
.d654		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d656		a0 08		ldy #$08	                ldy #8
.d658		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d65a		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d65c		d0 30		bne $d68e	                bne _next_entry ; definitely not equal if any bits differ
.d65e		a5 25		lda $25		                lda tmp1
.d660		48		pha		                pha             ; Save original address on the stack
.d661		18		clc		                clc
.d662		69 08		adc #$08	                adc #8
.d664		85 25		sta $25		                sta tmp1
.d666		a5 26		lda $26		                lda tmp1+1
.d668		48		pha		                pha
.d669		90 03		bcc $d66e	                bcc +
.d66b		1a		inc a		                ina
.d66c		85 26		sta $26		                sta tmp1+1
.d66e						+
.d66e		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d670		88		dey		                dey
.d671						_next_char:
.d671		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d673		c9 5b		cmp #$5b	                cmp #'Z'+1
.d675		b0 06		bcs $d67d	                bcs _check_char
.d677		c9 41		cmp #$41	                cmp #'A'
.d679		90 02		bcc $d67d	                bcc _check_char
.d67b		09 20		ora #$20	                ora #$20
.d67d						_check_char:
.d67d		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d67f		d0 03		bne $d684	                bne _reset_tmp1
.d681		88		dey		                dey
.d682		10 ed		bpl $d671	                bpl _next_char
.d684						_reset_tmp1:
.d684		68		pla		                pla
.d685		85 26		sta $26		                sta tmp1+1
.d687		68		pla		                pla
.d688		85 25		sta $25		                sta tmp1
.d68a		98		tya		                tya             ; leave A = $FF on success
.d68b		c8		iny		                iny             ; if Y was $FF, we succeeded
.d68c		f0 11		beq $d69f	                beq _done
.d68e						_next_entry:
.d68e		a0 02		ldy #$02	                ldy #2
.d690		b1 25		lda ($25),y	                lda (tmp1),y
.d692		48		pha		                pha
.d693		c8		iny		                iny
.d694		b1 25		lda ($25),y	                lda (tmp1),y
.d696		85 26		sta $26		                sta tmp1+1
.d698		68		pla		                pla
.d699		85 25		sta $25		                sta tmp1
.d69b		05 26		ora $26		                ora tmp1+1
.d69d		d0 af		bne $d64e	                bne _loop
.d69f		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d6a1		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d6a2						compare_16bit:
.d6a2		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d6a4		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d6a6		f0 08		beq $d6b0	                beq _equal
.d6a8		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6aa		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6ac		70 08		bvs $d6b6	                bvs _overflow
.d6ae		80 08		bra $d6b8	                bra _not_equal
.d6b0						_equal:
.d6b0		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6b2		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6b4		50 04		bvc $d6ba	                bvc _done
.d6b6						_overflow:
.d6b6		49 80		eor #$80	                eor #$80                ; complement negative flag
.d6b8						_not_equal:
.d6b8		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d6ba						_done:
.d6ba		60		rts		                rts
.d6bb						current_to_dp:
.d6bb		a0 08		ldy #$08	                ldy #current_offset
.d6bd		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6bf		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6c0		18		clc		                clc
.d6c1		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6c3		a8		tay		                tay
.d6c4		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d6c6		85 02		sta $02		                sta dp
.d6c8		c8		iny		                iny
.d6c9		b1 08		lda ($08),y	                lda (up),y
.d6cb		85 03		sta $03		                sta dp+1
.d6cd		60		rts		                rts
.d6ce						dp_to_current:
.d6ce		a0 08		ldy #$08	                ldy #current_offset
.d6d0		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6d2		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6d3		18		clc		                clc
.d6d4		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6d6		a8		tay		                tay
.d6d7		a5 02		lda $02		                lda dp
.d6d9		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d6db		c8		iny		                iny
.d6dc		a5 03		lda $03		                lda dp+1
.d6de		91 08		sta ($08),y	                sta (up),y
.d6e0		60		rts		                rts
.d6e1						interpret:
.d6e1						_loop:
.d6e1		20 54 8e	jsr $8e54	                jsr xt_parse_name       ; ( "string" -- addr u )
.d6e4		b5 00		lda $00,x	                lda 0,x
.d6e6		15 01		ora $01,x	                ora 1,x
.d6e8		f0 5b		beq $d745	                beq _line_done
.d6ea		20 ca 94	jsr $94ca	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d6ed		20 8b 9a	jsr $9a8b	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d6f0		b5 00		lda $00,x	                lda 0,x
.d6f2		15 01		ora $01,x	                ora 1,x
.d6f4		d0 19		bne $d70f	                bne _got_name_token
.d6f6		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d6f7		e8		inx		                inx
.d6f8		20 2c 9c	jsr $9c2c	                jsr xt_number           ; ( addr u -- u|d )
.d6fb		a5 1a		lda $1a		                lda state
.d6fd		f0 e2		beq $d6e1	                beq _loop
.d6ff		a9 20		lda #$20	                lda #%00100000
.d701		24 1c		bit $1c		                bit status
.d703		d0 05		bne $d70a	                bne _double_number
.d705		20 1b 8b	jsr $8b1b	                jsr xt_literal
.d708		80 d7		bra $d6e1	                bra _loop
.d70a						_double_number:
.d70a		20 84 9e	jsr $9e84	                jsr xt_two_literal
.d70d		80 d2		bra $d6e1	                bra _loop
.d70f						_got_name_token:
.d70f		b5 00		lda $00,x	                lda 0,x
.d711		95 04		sta $04,x	                sta 4,x
.d713		b5 01		lda $01,x	                lda 1,x
.d715		95 05		sta $05,x	                sta 5,x
.d717		e8		inx		                inx
.d718		e8		inx		                inx
.d719		e8		inx		                inx
.d71a		e8		inx		                inx                     ; ( nt )
.d71b		20 ec 8d	jsr $8dec	                jsr xt_one_plus
.d71e		a1 00		lda ($00,x)	                lda (0,x)
.d720		48		pha		                pha
.d721		20 e0 8d	jsr $8de0	                jsr xt_one_minus
.d724		20 c9 9b	jsr $9bc9	                jsr xt_name_to_int      ; ( nt - xt )
.d727		a5 1a		lda $1a		                lda state
.d729		d0 10		bne $d73b	                bne _compile
.d72b		68		pla		                pla
.d72c		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d72e		f0 05		beq $d735	                beq _interpret
.d730		a9 02		lda #$02	                lda #err_compileonly
.d732		4c 7a d7	jmp $d77a	                jmp error
.d735						_interpret:
.d735		20 ec 88	jsr $88ec	                jsr xt_execute
.d738		4c e1 d6	jmp $d6e1	                jmp _loop
.d73b						_compile:
.d73b		68		pla		                pla
.d73c		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d73e		d0 f5		bne $d735	                bne _interpret          ; IMMEDIATE word, execute right now
.d740		20 de 83	jsr $83de	                jsr xt_compile_comma
.d743		80 9c		bra $d6e1	                bra _loop
.d745						_line_done:
.d745		e8		inx		                inx
.d746		e8		inx		                inx
.d747		e8		inx		                inx
.d748		e8		inx		                inx
.d749		60		rts		                rts
.d74a						is_printable:
.d74a		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d74c		90 08		bcc $d756	                bcc _done
.d74e		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d750		b0 03		bcs $d755	                bcs _failed
.d752		38		sec		                sec
.d753		80 01		bra $d756	                bra _done
.d755						_failed:
.d755		18		clc		                clc
.d756						_done:
.d756		60		rts		                rts
.d757						is_whitespace:
.d757		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d759		90 08		bcc $d763	                bcc _done
.d75b		c9 21		cmp #$21	                cmp #AscSP+1
.d75d		b0 03		bcs $d762	                bcs _failed
.d75f		38		sec		                sec
.d760		80 01		bra $d763	                bra _done
.d762						_failed:
.d762		18		clc		                clc
.d763						_done:
.d763		60		rts		                rts
.d764						underflow_1:
.d764		e0 77		cpx #$77	                cpx #dsp0-1
.d766		10 10		bpl $d778	                bpl underflow_error
.d768		60		rts		                rts
.d769						underflow_2:
.d769		e0 75		cpx #$75	                cpx #dsp0-3
.d76b		10 0b		bpl $d778	                bpl underflow_error
.d76d		60		rts		                rts
.d76e						underflow_3:
.d76e		e0 73		cpx #$73	                cpx #dsp0-5
.d770		10 06		bpl $d778	                bpl underflow_error
.d772		60		rts		                rts
.d773						underflow_4:
.d773		e0 71		cpx #$71	                cpx #dsp0-7
.d775		10 01		bpl $d778	                bpl underflow_error
.d777		60		rts		                rts
.d778						underflow_error:
.d778		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d77a						error:
.d77a		48		pha		                pha                     ; save error
.d77b		20 ba d7	jsr $d7ba	                jsr print_error
.d77e		20 fa 84	jsr $84fa	                jsr xt_cr
.d781		68		pla		                pla
.d782		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d784		d0 17		bne $d79d	                bne _no_underflow
.d786		a9 0d		lda #$0d	                lda #err_returnstack
.d788		20 ba d7	jsr $d7ba	                jsr print_error
.d78b		ba		tsx		                tsx
.d78c						-
.d78c		e8		inx		                inx
.d78d		f0 0b		beq $d79a	                beq +
.d78f		20 c8 92	jsr $92c8	                jsr xt_space
.d792		bd 00 01	lda $0100,x	                lda $100,x
.d795		20 2f d6	jsr $d62f	                jsr byte_to_ascii
.d798		80 f2		bra $d78c	                bra -
.d79a						+
.d79a		20 fa 84	jsr $84fa	                jsr xt_cr
.d79d						_no_underflow:
.d79d		4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d7a0						print_string_no_lf:
.d7a0		0a		asl a		                asl
.d7a1		a8		tay		                tay
.d7a2		b9 79 d2	lda $d279,y	                lda string_table,y
.d7a5		85 29		sta $29		                sta tmp3                ; LSB
.d7a7		c8		iny		                iny
.d7a8		b9 79 d2	lda $d279,y	                lda string_table,y
.d7ab		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7ad						print_common:
.d7ad		a0 00		ldy #$00	                ldy #0
.d7af						_loop:
.d7af		b1 29		lda ($29),y	                lda (tmp3),y
.d7b1		f0 06		beq $d7b9	                beq _done               ; strings are zero-terminated
.d7b3		20 ac 87	jsr $87ac	                jsr emit_a              ; allows vectoring via output
.d7b6		c8		iny		                iny
.d7b7		80 f6		bra $d7af	                bra _loop
.d7b9						_done:
.d7b9		60		rts		                rts
.d7ba						print_error:
.d7ba		0a		asl a		                asl
.d7bb		a8		tay		                tay
.d7bc		b9 56 d3	lda $d356,y	                lda error_table,y
.d7bf		85 29		sta $29		                sta tmp3                ; LSB
.d7c1		c8		iny		                iny
.d7c2		b9 56 d3	lda $d356,y	                lda error_table,y
.d7c5		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7c7		20 ad d7	jsr $d7ad	                jsr print_common
.d7ca		60		rts		                rts
.d7cb						print_string:
.d7cb		20 a0 d7	jsr $d7a0	                jsr print_string_no_lf
.d7ce		4c fa 84	jmp $84fa	                jmp xt_cr               ; JSR/RTS because never compiled
.d7d1						print_u:
.d7d1		20 8c 9d	jsr $9d8c	                jsr xt_zero                     ; 0
.d7d4		20 f8 8a	jsr $8af8	                jsr xt_less_number_sign         ; <#
.d7d7		20 b6 8d	jsr $8db6	                jsr xt_number_sign_s            ; #S
.d7da		20 94 8d	jsr $8d94	                jsr xt_number_sign_greater      ; #>
.d7dd		4c d4 95	jmp $95d4	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm


;******  Processing file: platform/simulator.asm

=$f000						io_start = $f000
>f000						                .byte ?
>f001						io_putc:        .byte ?     ; $f001     write byte to stdout
>f002						                .word ?
>f004						io_getc:        .byte ?     ; $f004     read byte from stdin
>f005						io_peekc:       .byte ?     ; $f005     non-blocking input
>f006						io_clk_start:   .byte ?     ; $f006     *read* to start cycle counter
>f007						io_clk_stop:    .byte ?     ; $f007     *read* to stop the cycle counter
>f008						io_clk_cycles:  .word ?,?   ; $f008-b   32-bit cycle count in NUXI order
>f00c						                .word ?,?
>f010						io_blk_action:  .byte ?     ; $f010     Write to act (status=0 read=1 write=2)
>f011						io_blk_status:  .byte ?     ; $f011     Read action result (OK=0)
>f012						io_blk_number:  .word ?     ; $f012     Little endian block number 0-ffff
>f014						io_blk_buffer:  .word ?     ; $f014     Little endian memory address
.f016						io_end:
.f016						kernel_init:
.f016		78		sei		                sei             ; Disable interrupts
.f017		a2 00		ldx #$00	                ldx #0
.f019		bd 32 f0	lda $f032,x	-               lda s_kernel_id,x
.f01c		f0 06		beq $f024	                beq _done
.f01e		20 2d f0	jsr $f02d	                jsr kernel_putc
.f021		e8		inx		                inx
.f022		80 f5		bra $f019	                bra -
.f024						_done:
.f024		4c 00 80	jmp $8000	                jmp forth
.f027						kernel_getc:
.f027						_loop:
.f027		ad 04 f0	lda $f004	                lda io_getc
.f02a		f0 fb		beq $f027	                beq _loop
.f02c		60		rts		                rts
.f02d						kernel_putc:
.f02d		8d 01 f0	sta $f001	                sta io_putc
.f030		60		rts		                rts
.f031						kernel_bye:
.f031		00		brk #		                brk

;******  Return to file: platform/platform-py65mon.asm

.f032						s_kernel_id:
>f032		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f03a		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f04a		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f05a		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		16 f0				v_nmi   .word kernel_init
>fffc		16 f0				v_reset .word kernel_init
>fffe		16 f0				v_irq   .word kernel_init

;******  End of listing
