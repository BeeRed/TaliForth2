
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Wed Mar 13 07:11:42 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000					ram_start = $0000          ; start of installed 32 KiB of RAM
=32767					ram_end   = $8000-1        ; end of installed RAM
=$0000					zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f					zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100					stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744					hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000					user0     = zpage            ; TaliForth2 system variables
=$ff					rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff					bsize     = $ff              ; size of input/output buffers
=512					buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768					cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744					cp_end    = hist_buff        ; Last RAM byte available for code
=$ff					padoffset = $ff              ; offset from CP to PAD (holds number strings)
=					TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]
=["lf"]					TALI_OPTION_CR_EOL := [ "lf" ]

;******  Processing file: platform/../taliforth.asm

.8000					code0:

;******  Processing file: platform/../definitions.asm

=0					cp        = user0+0   ; Compiler Pointer
=2					dp        = user0+2   ; Dictionary Pointer
=4					workword  = user0+4   ; nt (not xt!) of word being compiled, except in
=6					insrc     = user0+6   ; input Source for SOURCE-ID
=8					cib       = user0+8   ; address of current input buffer
=10					ciblen    = user0+10  ; length of current input buffer
=12					toin      = user0+12  ; pointer to CIB (>IN in Forth)
=14					ip        = user0+14  ; Instruction Pointer (current xt)
=16					output    = user0+16  ; vector for EMIT
=18					input     = user0+18  ; vector for KEY
=20					havekey   = user0+20  ; vector for KEY?
=22					state     = user0+22  ; STATE: -1 compile, 0 interpret
=24					base      = user0+24  ; number radix, default decimal
=26					nc_limit  = user0+26  ; limit for Native Compile size
=28					uf_strip  = user0+28  ; flag to strip underflow detection code
=30					up        = user0+30  ; User Pointer (Address of user variables)
=32					status    = user0+32  ; internal status information
=34					tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
=36					tmp1      = user0+36  ; temporary storage
=38					tmp2      = user0+38  ; temporary storage
=40					tmp3      = user0+40  ; temporary storage (especially for print)
=42					tmpdsp    = user0+42  ; temporary DSP (X) storage (two bytes)
=44					tmptos    = user0+44  ; temporary TOS storage
=46					editor1   = user0+46  ; temporary for editors
=48					editor2   = user0+48  ; temporary for editors
=50					editor3   = user0+50  ; temporary for editors
=52					tohold    = user0+52  ; pointer for formatted output
=54					scratch   = user0+54  ; 8 byte scratchpad (see UM/MOD)
=120					dsp0      = zpage_end-7    ; initial Data Stack Pointer
=0					blk_offset = 0        ; BLK : UP + 0
=2					scr_offset = 2        ; SCR : UP + 2
=4					current_offset = 4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
=5					num_wordlists_offset = 5
=6					wordlists_offset = 6  ; WORDLISTS (cells) : UP + 6 to UP + 29
=30					num_order_offset = 30 ; #ORDER (byte) : UP + 30
=31					search_order_offset = 31
=12					max_wordlists = 12    ; Maximum number of wordlists supported
=40					blkbuffer_offset    = 40   ; Address of buffer
=42					buffblocknum_offset = 42   ; Block number current in buffer
=44					buffstatus_offset   = 44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
=46					blockread_offset    = 46   ; Vector to block reading routine
=48					blockwrite_offset   = 48   ; Vector to block writing routine
=$03					AscCC   = $03  ; break (CTRL-c)
=$07					AscBELL = $07  ; bell sound
=$08					AscBS   = $08  ; backspace
=$0a					AscLF   = $0a  ; line feed
=$0d					AscCR   = $0d  ; carriage return
=$1b					AscESC  = $1b  ; escape
=$20					AscSP   = $20  ; space
=$7f					AscDEL  = $7f  ; delete (CTRL-h)
=$10					AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e					AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1					CO = 1  ; Compile Only
=2					AN = 2  ; Always Native Compile
=4					IM = 4  ; Immediate Word
=8					NN = 8  ; Never Native Compile
=16					UF = 16 ; Includes Underflow Check (RESERVED)
=32					HC = 32 ; Word has Code Field Area (CFA)
=79					MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm

.8000					forth:

;******  Processing file: platform/../native_words.asm

.8000					xt_cold:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 10		sta $10		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 11		sta $11		                sta output+1
.8009	a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b					_load_zp_loop:
.800b	bd a4 80	lda $80a4,x	                lda cold_zp_table,x
.800e	95 00		sta $00,x	                sta zpage,x
.8010	ca		dex		                dex
.8011	d0 f8		bne $800b	                bne _load_zp_loop
.8013	ad a4 80	lda $80a4	                lda cold_zp_table
.8016	85 00		sta $00		                sta zpage
.8018	a2 ff		ldx #$ff	                ldx #rsp0
.801a	9a		txs		                txs
.801b	a2 78		ldx #$78	                ldx #dsp0
.801d	a0 33		ldy #$33	                ldy #cold_user_table_end-cold_user_table-1
.801f	a9 00		lda #$00	                lda #0
.8021					_load_user_vars_loop:
.8021	b9 c6 80	lda $80c6,y	                lda cold_user_table,y
.8024	91 1e		sta ($1e),y	                sta (up),y
.8026	88		dey		                dey
.8027	d0 f8		bne $8021	                bne _load_user_vars_loop
.8029	ad c6 80	lda $80c6	                lda cold_user_table
.802c	92 1e		sta ($1e)	                sta (up)
.802e	20 44 89	jsr $8944	                jsr xt_cr
.8031	ca		dex		                dex
.8032	ca		dex		                dex
.8033	ca		dex		                dex
.8034	ca		dex		                dex
.8035	a9 23		lda #$23	                lda #<forth_words_start
.8037	95 02		sta $02,x	                sta 2,x
.8039	a9 bb		lda #$bb	                lda #>forth_words_start
.803b	95 03		sta $03,x	                sta 3,x
.803d	a9 d3		lda #$d3	                lda #<(user_words_end-forth_words_start)
.803f	95 00		sta $00,x	                sta 0,x
.8041	a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043	95 01		sta $01,x	                sta 1,x
.8045	20 b6 90	jsr $90b6	                jsr xt_evaluate
.8048	9c 00 7c	stz $7c00	                stz hist_buff
.804b	9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e	9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051	9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054	9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057	9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a	9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d	9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060					xt_abort:
.8060	a2 78		ldx #$78	                ldx #dsp0
.8062					xt_quit:
.8062	8a		txa		                txa             ; Save the DSP that we just defined
.8063	a2 ff		ldx #$ff	                ldx #rsp0
.8065	9a		txs		                txs
.8066	aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067	64 0e		stz $0e		                stz ip
.8069	64 0f		stz $0f		                stz ip+1
.806b	64 06		stz $06		                stz insrc
.806d	64 07		stz $07		                stz insrc+1
.806f	64 16		stz $16		                stz state
.8071	64 17		stz $17		                stz state+1
.8073					_get_line:
.8073	a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8075	85 08		sta $08		                sta cib
.8077	a9 02		lda #$02	                lda #>buffer0
.8079	85 09		sta $09		                sta cib+1
.807b	64 0a		stz $0a		                stz ciblen
.807d	64 0b		stz $0b		                stz ciblen+1
.807f	20 d9 9a	jsr $9ad9	                jsr xt_refill           ; ( -- f )
.8082	b5 00		lda $00,x	                lda 0,x
.8084	d0 05		bne $808b	                bne _success
.8086	a9 06		lda #$06	                lda #err_refill
.8088	4c 0c d8	jmp $d80c	                jmp error
.808b					_success:
.808b	e8		inx		                inx                     ; drop
.808c	e8		inx		                inx
.808d	20 5e d7	jsr $d75e	                jsr interpret
.8090	e0 78		cpx #$78	                cpx #dsp0
.8092	f0 05		beq $8099	                beq _stack_ok
.8094	90 03		bcc $8099	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.8096	4c 0a d8	jmp $d80a	                jmp underflow_error
.8099					_stack_ok:
.8099	a5 16		lda $16		                lda state
.809b	f0 02		beq $809f	                beq _print
.809d	a9 01		lda #$01	                lda #1                  ; number for "compile" string
.809f					_print:
.809f	20 5d d8	jsr $d85d	                jsr print_string
.80a2	80 cf		bra $8073	                bra _get_line
.80a4					z_cold:
.80a4					z_abort:
.80a4					z_quit:
.80a4					cold_zp_table:
>80a4	00 08				        .word cp0+256+1024      ; cp moved to make room for user vars and
>80a6	f6 bb				        .word dictionary_start  ; dp
>80a8	00 00				        .word 0                 ; workword
>80aa	00 00				        .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
>80ac	00 02				        .word buffer0           ; cib
>80ae	00 00				        .word 0                 ; ciblen
>80b0	00 00				        .word 0                 ; toin
>80b2	00 00				        .word 0                 ; ip
>80b4	27 f0				        .word kernel_putc       ; output
>80b6	21 f0				        .word kernel_getc       ; input
>80b8	00 00				        .word 0                 ; havekey
>80ba	00 00				        .word 0                 ; state (0 = interpret)
>80bc	0a 00				        .word 10                ; base
>80be	14 00				        .word 20                ; nc-limit
>80c0	00 00				        .word 0                 ; uf_strip (off by default)
>80c2	00 03				        .word cp0               ; up (user vars put right at beginning of
>80c4	00 00				        .word 0                 ; status
.80c6					cold_zp_table_end:
.80c6					cold_user_table:
>80c6	00 00				        .word 0                         ;  0 BLK
>80c8	00 00				        .word 0                         ;  2 SCR
>80ca	00				        .byte 0                         ;  4 CURRENT = FORTH-WORDLIST
>80cb	04				        .byte 4                         ;  5 #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>80cc	f6 bb				        .word dictionary_start          ;  6 FORTH-WORDLIST
>80ce	3e ca				        .word editor_dictionary_start   ;  8 EDITOR-WORDLIST
>80d0	8e ca				        .word assembler_dictionary_start ; a ASSEMBLER-WORDLIST
>80d2	fd c9				        .word root_dictionary_start     ;  c ROOT-WORDLIST
>80d4	00 00 00 00 00 00 00 00		        .word 0,0,0,0,0,0,0,0           ;  e User wordlists
>80dc	00 00 00 00 00 00 00 00
>80e4	01				        .byte 1                         ; 1e #ORDER
>80e5	00 00 00 00 00 00 00 00		        .byte 0,0,0,0,0,0,0,0,0         ; 1f search-order
>80ed	00
>80ee	00 04				        .word cp0+256                   ; 28 Address of buffer (right after USER vars)
>80f0	00 00				        .word 0                         ; 2a block in buffer
>80f2	00 00				        .word 0                         ; 2c buffer status (not in use)
>80f4	3c 85				        .word xt_block_word_error       ; 2e block-read vector
>80f6	3c 85				        .word xt_block_word_error       ; 30 block-write vector
>80f8	00 00				        .word 0                         ; 32 'COLD
.80fa					cold_user_table_end:
.80fa					xt_abort_quote:
.80fa	20 30 9d	jsr $9d30	                jsr xt_s_quote          ; S"
.80fd	a0 81		ldy #$81	                ldy #>abort_quote_runtime
.80ff	a9 05		lda #$05	                lda #<abort_quote_runtime
.8101	20 99 d6	jsr $d699	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.8104	60		rts		z_abort_quote:  rts
.8105					abort_quote_runtime:
.8105	b5 04		lda $04,x	                lda 4,x
.8107	15 05		ora $05,x	                ora 5,x
.8109	f0 09		beq $8114	                beq _done       ; if FALSE, we're done
.810b	20 b5 a4	jsr $a4b5	                jsr xt_type
.810e	20 44 89	jsr $8944	                jsr xt_cr
.8111	4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.8114					_done:
.8114	8a		txa		                txa
.8115	18		clc		                clc
.8116	69 06		adc #$06	                adc #6
.8118	aa		tax		                tax
.8119	60		rts		                rts
.811a					xt_abs:
.811a	20 f6 d7	jsr $d7f6	                jsr underflow_1
.811d	b5 01		lda $01,x	                lda 1,x
.811f	10 0d		bpl $812e	                bpl _done       ; positive number, easy money!
.8121	38		sec		                sec
.8122	a9 00		lda #$00	                lda #0
.8124	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8126	95 00		sta $00,x	                sta 0,x
.8128	a9 00		lda #$00	                lda #0          ; MSB
.812a	f5 01		sbc $01,x	                sbc 1,x
.812c	95 01		sta $01,x	                sta 1,x
.812e					_done:
.812e	60		rts		z_abs:          rts
.812f					xt_accept:
.812f	20 fb d7	jsr $d7fb	                jsr underflow_2
.8132	b5 00		lda $00,x	                lda 0,x
.8134	15 01		ora $01,x	                ora 1,x
.8136	d0 09		bne $8141	                bne _not_zero
.8138	e8		inx		                inx
.8139	e8		inx		                inx
.813a	74 00		stz $00,x	                stz 0,x
.813c	74 01		stz $01,x	                stz 1,x
.813e	4c 0d 82	jmp $820d	                jmp accept_done
.8141					_not_zero:
.8141	b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.8143	85 26		sta $26		                sta tmp2
.8145	64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.8147	b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8149	85 24		sta $24		                sta tmp1
.814b	b5 03		lda $03,x	                lda 3,x
.814d	85 25		sta $25		                sta tmp1+1
.814f	e8		inx		                inx
.8150	e8		inx		                inx
.8151	a0 00		ldy #$00	                ldy #0
.8153	a5 20		lda $20		                lda status
.8155	29 f7		and #$f7	                and #$f7
.8157	1a		inc a		               ina
.8158	09 08		ora #$08	                ora #$08
.815a	85 20		sta $20		                sta status
.815c					accept_loop:
.815c	20 19 93	jsr $9319	                jsr key_a
.815f	c9 0a		cmp #$0a	                cmp #AscLF
.8161	f0 20		beq $8183	                beq _eol
.8163	c9 0d		cmp #$0d	                cmp #AscCR
.8165	f0 1c		beq $8183	                beq _eol
.8167	c9 08		cmp #$08	                cmp #AscBS
.8169	f0 22		beq $818d	                beq _backspace
.816b	c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.816d	f0 1e		beq $818d	                beq _backspace
.816f	c9 10		cmp #$10	                cmp #AscCP
.8171	f0 36		beq $81a9	                beq _ctrl_p
.8173	c9 0e		cmp #$0e	                cmp #AscCN
.8175	f0 44		beq $81bb	                beq _ctrl_n
.8177	91 24		sta ($24),y	                sta (tmp1),y
.8179	c8		iny		                iny
.817a	20 d7 8d	jsr $8dd7	                jsr emit_a
.817d	c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.817f	d0 db		bne $815c	                bne accept_loop       ; fall through if buffer limit reached
.8181	80 03		bra $8186	                bra _buffer_full
.8183					_eol:
.8183	20 d0 a0	jsr $a0d0	                jsr xt_space    ; print final space
.8186					_buffer_full:
.8186	94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.8188	74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.818a	4c 0d 82	jmp $820d	                jmp accept_done
.818d					_backspace:
.818d	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.818f	d0 06		bne $8197	                bne +
.8191	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8193	20 d7 8d	jsr $8dd7	                jsr emit_a
.8196	c8		iny		                iny
.8197					+
.8197	88		dey		                dey
.8198	a9 08		lda #$08	                lda #AscBS      ; move back one
.819a	20 d7 8d	jsr $8dd7	                jsr emit_a
.819d	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.819f	20 d7 8d	jsr $8dd7	                jsr emit_a
.81a2	a9 08		lda #$08	                lda #AscBS      ; move back over space
.81a4	20 d7 8d	jsr $8dd7	                jsr emit_a
.81a7	80 b3		bra $815c	                bra accept_loop
.81a9					_ctrl_p:
.81a9	a5 20		lda $20		                lda status
.81ab	29 07		and #$07	                and #7
.81ad	d0 08		bne $81b7	                bne _ctrl_p_dec
.81af	a5 20		lda $20		                lda status
.81b1	09 07		ora #$07	                ora #7
.81b3	85 20		sta $20		                sta status
.81b5	80 11		bra $81c8	                bra _recall_history
.81b7					_ctrl_p_dec:
.81b7	c6 20		dec $20		                dec status
.81b9	80 0d		bra $81c8	                bra _recall_history
.81bb					_ctrl_n:
.81bb	a9 08		lda #$08	                lda #$8
.81bd	24 20		bit $20		                bit status
.81bf	d0 07		bne $81c8	                bne _recall_history
.81c1	a5 20		lda $20		                lda status
.81c3	29 f7		and #$f7	                and #$f7
.81c5	1a		inc a		               ina
.81c6	85 20		sta $20		                sta status
.81c8					_recall_history:
.81c8	a9 08		lda #$08	                lda #%00001000
.81ca	14 20		trb $20		                trb status
.81cc	20 28 82	jsr $8228	                jsr accept_total_recall
.81cf	a9 0d		lda #$0d	                lda #AscCR
.81d1	20 d7 8d	jsr $8dd7	                jsr emit_a
.81d4					input_clear:
.81d4	c0 00		cpy #$00	                cpy #0
.81d6	f0 08		beq $81e0	                beq input_cleared
.81d8	a9 20		lda #$20	                lda #AscSP
.81da	20 d7 8d	jsr $8dd7	                jsr emit_a
.81dd	88		dey		                dey
.81de	80 f4		bra $81d4	                bra input_clear
.81e0					input_cleared:
.81e0	a9 0d		lda #$0d	                lda #AscCR
.81e2	20 d7 8d	jsr $8dd7	                jsr emit_a
.81e5	b1 28		lda ($28),y	                lda (tmp3),y
.81e7	85 21		sta $21		                sta status+1
.81e9	e6 28		inc $28		                inc tmp3
.81eb	d0 02		bne $81ef	                bne +           ; Increment the upper byte on carry.
.81ed	e6 29		inc $29		                inc tmp3+1
.81ef					+
.81ef	a9 0d		lda #$0d	                lda #AscCR
.81f1	20 d7 8d	jsr $8dd7	                jsr emit_a
.81f4					_history_loop:
.81f4	c4 21		cpy $21		                cpy status+1
.81f6	d0 03		bne $81fb	                bne +
.81f8	4c 5c 81	jmp $815c	                jmp accept_loop       ; Needs a long jump
.81fb					+
.81fb	c4 26		cpy $26		                cpy tmp2
.81fd	f0 0a		beq $8209	                beq _hist_filled_buffer
.81ff	b1 28		lda ($28),y	                lda (tmp3),y
.8201	91 24		sta ($24),y	                sta (tmp1),y
.8203	20 d7 8d	jsr $8dd7	                jsr emit_a
.8206	c8		iny		                iny
.8207	80 eb		bra $81f4	                bra _history_loop
.8209					_hist_filled_buffer:
.8209	88		dey		                dey
.820a	4c 5c 81	jmp $815c	                jmp accept_loop
.820d					accept_done:
.820d	20 28 82	jsr $8228	                jsr accept_total_recall
.8210	85 21		sta $21		                sta status+1
.8212	a0 00		ldy #$00	                ldy #0
.8214	91 28		sta ($28),y	                sta (tmp3),y
.8216	e6 28		inc $28		                inc tmp3
.8218	d0 02		bne $821c	                bne +           ; Increment the upper byte on carry.
.821a	e6 29		inc $29		                inc tmp3+1
.821c					+
.821c					_save_history_loop:
.821c	c4 21		cpy $21		                cpy status+1
.821e	f0 07		beq $8227	                beq _save_history_done
.8220	b1 24		lda ($24),y	                lda (tmp1),y
.8222	91 28		sta ($28),y	                sta (tmp3),y
.8224	c8		iny		                iny
.8225	80 f5		bra $821c	                bra _save_history_loop
.8227					_save_history_done:
.8227					z_accept:
.8227	60		rts		                rts
.8228					accept_total_recall:
.8228	a9 00		lda #$00	                lda #<hist_buff
.822a	85 28		sta $28		                sta tmp3
.822c	a9 7c		lda #$7c	                lda #>hist_buff
.822e	85 29		sta $29		                sta tmp3+1
.8230	a5 20		lda $20		                lda status
.8232	6a		ror a		                ror
.8233	29 03		and #$03	                and #3
.8235	18		clc		                clc
.8236	65 29		adc $29		                adc tmp3+1
.8238	85 29		sta $29		                sta tmp3+1
.823a	a5 20		lda $20		                lda status
.823c	6a		ror a		                ror             ; Rotate through carry into msb.
.823d	6a		ror a		                ror
.823e	29 80		and #$80	                and #$80
.8240	18		clc		                clc
.8241	65 28		adc $28		                adc tmp3
.8243	85 28		sta $28		                sta tmp3
.8245	90 02		bcc $8249	                bcc +           ; Increment the upper byte on carry.
.8247	e6 29		inc $29		                inc tmp3+1
.8249					+
.8249	98		tya		                tya
.824a	c9 80		cmp #$80	                cmp #$80
.824c	90 02		bcc $8250	                bcc +
.824e	a9 7f		lda #$7f	                lda #$7F
.8250					+
.8250	60		rts		                rts
.8251					xt_action_of:
.8251	a5 16		lda $16		                lda state
.8253	05 17		ora $17		                ora state+1
.8255	f0 0c		beq $8263	                beq _interpreting
.8257					_compiling:
.8257	20 7f 85	jsr $857f	                jsr xt_bracket_tick
.825a	a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.825c	a9 c0		lda #$c0	                lda #<xt_defer_fetch
.825e	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.8261	80 06		bra $8269	                bra _done
.8263					_interpreting:
.8263	20 c3 a1	jsr $a1c3	                jsr xt_tick
.8266	20 c0 8a	jsr $8ac0	                jsr xt_defer_fetch
.8269					_done:
.8269	60		rts		z_action_of:           rts
.826a					xt_again:
.826a	20 f6 d7	jsr $d7f6	                jsr underflow_1
.826d	a0 00		ldy #$00	                ldy #0
.826f	a9 4c		lda #$4c	                lda #$4C        ; JMP
.8271	91 00		sta ($00),y	                sta (cp),y
.8273	c8		iny		                iny
.8274	b5 00		lda $00,x	                lda 0,x         ; LSB of address
.8276	91 00		sta ($00),y	                sta (cp),y
.8278	c8		iny		                iny
.8279	b5 01		lda $01,x	                lda 1,x         ; MSB of address
.827b	91 00		sta ($00),y	                sta (cp),y
.827d	c8		iny		                iny
.827e	98		tya		                tya
.827f	18		clc		                clc
.8280	65 00		adc $00		                adc cp
.8282	85 00		sta $00		                sta cp
.8284	90 02		bcc $8288	                bcc _done
.8286	e6 01		inc $01		                inc cp+1
.8288					_done:
.8288	e8		inx		                inx
.8289	e8		inx		                inx
.828a	60		rts		z_again:        rts
.828b					xt_align:
.828b					xt_aligned:
.828b					z_align:
.828b	60		rts		z_aligned:      rts             ; stripped out during native compile
.828c					xt_allot:
.828c	20 f6 d7	jsr $d7f6	                jsr underflow_1
.828f	b5 01		lda $01,x	                lda 1,x
.8291	30 22		bmi $82b5	                bmi _release
.8293	18		clc		                clc
.8294	a5 00		lda $00		                lda cp
.8296	75 00		adc $00,x	                adc 0,x
.8298	85 00		sta $00		                sta cp
.829a	a5 01		lda $01		                lda cp+1
.829c	75 01		adc $01,x	                adc 1,x
.829e	85 01		sta $01		                sta cp+1
.82a0	a0 00		ldy #$00	                ldy #<cp_end
.82a2	c4 00		cpy $00		                cpy cp
.82a4	a9 7c		lda #$7c	                lda #>cp_end
.82a6	e5 01		sbc $01		                sbc cp+1
.82a8	b0 48		bcs $82f2	                bcs _done               ; we're fine.
.82aa	84 00		sty $00		                sty cp                  ; still #<cp_end
.82ac	a9 7c		lda #$7c	                lda #>cp_end
.82ae	85 01		sta $01		                sta cp+1
.82b0	a9 00		lda #$00	                lda #err_allot
.82b2	4c 0c d8	jmp $d80c	                jmp error
.82b5					_release:
.82b5	ca		dex		                dex
.82b6	ca		dex		                dex
.82b7	a5 00		lda $00		                lda cp
.82b9	95 00		sta $00,x	                sta 0,x
.82bb	a5 01		lda $01		                lda cp+1
.82bd	95 01		sta $01,x	                sta 1,x
.82bf	20 c4 99	jsr $99c4	                jsr xt_plus                     ; new CP is now TOS
.82c2	ca		dex		                dex
.82c3	ca		dex		                dex                             ; new CP now NOS
.82c4	a9 00		lda #$00	                lda #<cp0
.82c6	95 00		sta $00,x	                sta 0,x
.82c8	a9 03		lda #$03	                lda #>cp0
.82ca	95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.82cc	20 1d d7	jsr $d71d	                jsr compare_16bit               ; still ( CP CP0 )
.82cf	f0 17		beq $82e8	                beq _nega_done
.82d1	30 15		bmi $82e8	                bmi _nega_done
.82d3	a9 00		lda #$00	                lda #<cp0
.82d5	85 00		sta $00		                sta cp
.82d7	a9 03		lda #$03	                lda #>cp0
.82d9	85 01		sta $01		                sta cp+1
.82db	a9 f6		lda #$f6	                lda #<dictionary_start
.82dd	85 02		sta $02		                sta dp
.82df	a9 bb		lda #$bb	                lda #>dictionary_start
.82e1	85 03		sta $03		                sta dp+1
.82e3	a9 0a		lda #$0a	                lda #err_negallot
.82e5	4c 0c d8	jmp $d80c	                jmp error
.82e8					_nega_done:
.82e8	b5 02		lda $02,x	                lda 2,x
.82ea	85 00		sta $00		                sta cp
.82ec	b5 03		lda $03,x	                lda 3,x
.82ee	85 01		sta $01		                sta cp+1
.82f0	e8		inx		                inx
.82f1	e8		inx		                inx                     ; drop through to _done
.82f2					_done:
.82f2	e8		inx		                inx
.82f3	e8		inx		                inx
.82f4					z_allot:
.82f4	60		rts		                rts
.82f5					xt_allow_native:
.82f5	20 38 d7	jsr $d738	                jsr current_to_dp
.82f8	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82fa	b1 02		lda ($02),y	                lda (dp),y
.82fc	29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.82fe	91 02		sta ($02),y	                sta (dp),y
.8300					z_allow_native:
.8300	60		rts		                rts
.8301					xt_also:
.8301	20 15 91	jsr $9115	                jsr xt_get_order
.8304	20 74 98	jsr $9874	                jsr xt_over
.8307	20 60 a1	jsr $a160	                jsr xt_swap
.830a	20 fe 97	jsr $97fe	                jsr xt_one_plus
.830d	20 fc 9c	jsr $9cfc	                jsr xt_set_order
.8310	60		rts		z_also:         rts
.8311					xt_always_native:
.8311	20 38 d7	jsr $d738	                jsr current_to_dp
.8314	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8316	b1 02		lda ($02),y	                lda (dp),y
.8318	09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.831a	29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.831c	91 02		sta ($02),y	                sta (dp),y
.831e					z_always_native:
.831e	60		rts		                rts
.831f					xt_and:
.831f	20 fb d7	jsr $d7fb	                jsr underflow_2
.8322	b5 00		lda $00,x	                lda 0,x
.8324	35 02		and $02,x	                and 2,x
.8326	95 02		sta $02,x	                sta 2,x
.8328	b5 01		lda $01,x	                lda 1,x
.832a	35 03		and $03,x	                and 3,x
.832c	95 03		sta $03,x	                sta 3,x
.832e	e8		inx		                inx
.832f	e8		inx		                inx
.8330	60		rts		z_and:          rts
.8331					xt_at_xy:
.8331	20 fb d7	jsr $d7fb	                jsr underflow_2
.8334	a5 18		lda $18		                lda base
.8336	48		pha		                pha
.8337	a9 0a		lda #$0a	                lda #10
.8339	85 18		sta $18		                sta base
.833b	a9 1b		lda #$1b	                lda #AscESC
.833d	20 d7 8d	jsr $8dd7	                jsr emit_a
.8340	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.8342	20 d7 8d	jsr $8dd7	                jsr emit_a
.8345	20 fe 97	jsr $97fe	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8348	20 63 d8	jsr $d863	                jsr print_u
.834b	a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.834d	20 d7 8d	jsr $8dd7	                jsr emit_a
.8350	20 fe 97	jsr $97fe	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8353	20 63 d8	jsr $d863	                jsr print_u
.8356	a9 48		lda #$48	                lda #'H'
.8358	20 d7 8d	jsr $8dd7	                jsr emit_a
.835b	68		pla		                pla
.835c	85 18		sta $18		                sta base
.835e	60		rts		z_at_xy:        rts
.835f					xt_backslash:
.835f	a5 0a		lda $0a		                lda ciblen
.8361	85 0c		sta $0c		                sta toin
.8363	a5 0b		lda $0b		                lda ciblen+1
.8365	85 0d		sta $0d		                sta toin+1
.8367	60		rts		z_backslash:    rts
.8368					xt_base:
.8368	ca		dex		                dex
.8369	ca		dex		                dex
.836a	a9 18		lda #$18	                lda #<base
.836c	95 00		sta $00,x	                sta 0,x         ; LSB
.836e	74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8370	60		rts		z_base:         rts
.8371					xt_begin:
.8371	20 53 91	jsr $9153	                jsr xt_here
.8374	60		rts		z_begin:        rts
.8375					xt_bell:
.8375	a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.8377	20 d7 8d	jsr $8dd7	                jsr emit_a
.837a	60		rts		z_bell:         rts
.837b					xt_bl:
.837b	ca		dex		                dex
.837c	ca		dex		                dex
.837d	a9 20		lda #$20	                lda #AscSP
.837f	95 00		sta $00,x	                sta 0,x
.8381	74 01		stz $01,x	                stz 1,x
.8383	60		rts		z_bl:           rts
.8384					xt_blk:
.8384	ca		dex		                dex
.8385	ca		dex		                dex
.8386	18		clc		                clc
.8387	a5 1e		lda $1e		                lda up
.8389	69 00		adc #$00	                adc #blk_offset ; Add offset
.838b	95 00		sta $00,x	                sta 0,x
.838d	a5 1f		lda $1f		                lda up+1
.838f	69 00		adc #$00	                adc #0          ; Adding carry
.8391	95 01		sta $01,x	                sta 1,x
.8393	60		rts		z_blk:          rts
.8394					xt_blkbuffer:
.8394	ca		dex		                dex
.8395	ca		dex		                dex
.8396	a0 28		ldy #$28	                ldy #blkbuffer_offset
.8398	b1 1e		lda ($1e),y	                lda (up),y
.839a	95 00		sta $00,x	                sta 0,x
.839c	c8		iny		                iny             ; Move along to the next byte
.839d	b1 1e		lda ($1e),y	                lda (up),y
.839f	95 01		sta $01,x	                sta 1,x
.83a1	60		rts		z_blkbuffer:    rts
.83a2					xt_block:
.83a2	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83a4	b1 1e		lda ($1e),y	                lda (up),y
.83a6	d5 00		cmp $00,x	                cmp 0,x
.83a8	d0 0f		bne $83b9	                bne _not_in_buffer
.83aa	c8		iny		                iny
.83ab	b1 1e		lda ($1e),y	                lda (up),y
.83ad	d5 01		cmp $01,x	                cmp 1,x
.83af	d0 08		bne $83b9	                bne _not_in_buffer
.83b1	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83b3	b1 1e		lda ($1e),y	                lda (up),y
.83b5	29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.83b7	d0 30		bne $83e9	                bne _done       ; It's already in the buffer and in use.
.83b9					_not_in_buffer:
.83b9	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83bb	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.83bd	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.83bf	d0 0c		bne $83cd	                bne _buffer_available ; Unused or not dirty = available
.83c1	20 94 83	jsr $8394	                jsr xt_blkbuffer
.83c4	20 86 85	jsr $8586	                jsr xt_buffblocknum
.83c7	20 61 8f	jsr $8f61	                jsr xt_fetch
.83ca	20 41 85	jsr $8541	                jsr xt_block_write
.83cd					_buffer_available:
.83cd	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83cf	b5 00		lda $00,x	                lda 0,x
.83d1	91 1e		sta ($1e),y	                sta (up),y
.83d3	c8		iny		                iny
.83d4	b5 01		lda $01,x	                lda 1,x
.83d6	91 1e		sta ($1e),y	                sta (up),y
.83d8	20 94 83	jsr $8394	                jsr xt_blkbuffer
.83db	20 60 a1	jsr $a160	                jsr xt_swap
.83de	20 1e 85	jsr $851e	                jsr xt_block_read
.83e1	a9 01		lda #$01	                lda #1
.83e3	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83e5	91 1e		sta ($1e),y	                sta (up),y
.83e7	ca		dex		                dex
.83e8	ca		dex		                dex
.83e9					_done:
.83e9	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83eb	b1 1e		lda ($1e),y	                lda (up),y
.83ed	95 00		sta $00,x	                sta 0,x
.83ef	c8		iny		                iny
.83f0	b1 1e		lda ($1e),y	                lda (up),y
.83f2	95 01		sta $01,x	                sta 1,x
.83f4	60		rts		z_block:        rts
.83f5					xt_block_ramdrive_init:
.83f5	20 f6 d7	jsr $d7f6	                jsr underflow_1
.83f8	4c 13 85	jmp $8513	                jmp _after_ramdrive_code
.83fb					_ramdrive_code:
>83fb	62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>8403	77 61 70 20 64 65 63 69 6d 61 6c
>840e	20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>8415	20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>8419	20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>8421	20 72 61 6d 64 72 69 76 65
>842a	20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>8432	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>8440	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8448	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8458	73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>8468	20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>8470	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>847f	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>8487	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8497	31 30 32 34 20 6d 6f 76 65 20 3b
>84a2	20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>84aa	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>84ba	6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>84ca	20 21
>84cc	20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84d4	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>84e4	62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>84f4	6f 72 20 21
>84f8	20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>8500	65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>8510	65 20 21
.8513					_after_ramdrive_code:
.8513	20 5b a0	jsr $a05b	                jsr sliteral_runtime
>8516	fb 83 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.851a	20 b6 90	jsr $90b6	                jsr xt_evaluate
.851d					z_block_ramdrive_init:
.851d	60		rts		                rts
.851e					xt_block_read:
.851e	a0 2e		ldy #$2e	                ldy #blockread_offset
.8520	b1 1e		lda ($1e),y	                lda (up),y
.8522	85 24		sta $24		                sta tmp1
.8524	c8		iny		                iny
.8525	b1 1e		lda ($1e),y	                lda (up),y
.8527	85 25		sta $25		                sta tmp1+1
.8529	6c 24 00	jmp ($0024)	                jmp (tmp1)
.852c					z_block_read:
.852c					xt_block_read_vector:
.852c	ca		dex		                dex
.852d	ca		dex		                dex
.852e	18		clc		                clc
.852f	a5 1e		lda $1e		                lda up
.8531	69 2e		adc #$2e	                adc #blockread_offset
.8533	95 00		sta $00,x	                sta 0,x
.8535	a5 1f		lda $1f		                lda up+1
.8537	69 00		adc #$00	                adc #0          ; Add carry
.8539	95 01		sta $01,x	                sta 1,x
.853b					z_block_read_vector:
.853b	60		rts		                rts
.853c					xt_block_word_error:
.853c	a9 0c		lda #$0c	                lda #err_blockwords
.853e	4c 0c d8	jmp $d80c	                jmp error       ; no RTS needed
.8541					z_block_word_error:
.8541					xt_block_write:
.8541	a0 30		ldy #$30	                ldy #blockwrite_offset
.8543	b1 1e		lda ($1e),y	                lda (up),y
.8545	85 24		sta $24		                sta tmp1
.8547	c8		iny		                iny
.8548	b1 1e		lda ($1e),y	                lda (up),y
.854a	85 25		sta $25		                sta tmp1+1
.854c	6c 24 00	jmp ($0024)	                jmp (tmp1)
.854f					z_block_write:
.854f					xt_block_write_vector:
.854f	ca		dex		                dex
.8550	ca		dex		                dex
.8551	18		clc		                clc
.8552	a5 1e		lda $1e		                lda up
.8554	69 30		adc #$30	                adc #blockwrite_offset
.8556	95 00		sta $00,x	                sta 0,x
.8558	a5 1f		lda $1f		                lda up+1
.855a	69 00		adc #$00	                adc #0          ; Add carry
.855c	95 01		sta $01,x	                sta 1,x
.855e					z_block_write_vector:
.855e	60		rts		                rts
.855f					xt_bounds:
.855f	20 fb d7	jsr $d7fb	                jsr underflow_2
.8562	18		clc		                clc
.8563	b5 00		lda $00,x	                lda 0,x                 ; LSB u
.8565	b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.8567	75 02		adc $02,x	                adc 2,x
.8569	95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.856b	94 00		sty $00,x	                sty 0,x
.856d	b5 01		lda $01,x	                lda 1,x                 ; MSB u
.856f	b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8571	75 03		adc $03,x	                adc 3,x
.8573	95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.8575	94 01		sty $01,x	                sty 1,x
.8577	60		rts		z_bounds:       rts
.8578					xt_bracket_char:
.8578	20 12 86	jsr $8612	                jsr xt_char
.857b	20 6b 93	jsr $936b	                jsr xt_literal
.857e	60		rts		z_bracket_char: rts
.857f					xt_bracket_tick:
.857f	20 c3 a1	jsr $a1c3	                jsr xt_tick
.8582	20 6b 93	jsr $936b	                jsr xt_literal
.8585	60		rts		z_bracket_tick: rts
.8586					xt_buffblocknum:
.8586	ca		dex		                dex
.8587	ca		dex		                dex
.8588	18		clc		                clc
.8589	a5 1e		lda $1e		                lda up
.858b	69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.858d	95 00		sta $00,x	                sta 0,x
.858f	a5 1f		lda $1f		                lda up+1
.8591	69 00		adc #$00	                adc #0                          ; Adding carry
.8593	95 01		sta $01,x	                sta 1,x
.8595	60		rts		z_buffblocknum: rts
.8596					xt_buffer:
.8596	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8598	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.859a	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.859c	d0 0c		bne $85aa	                bne _buffer_available ; Unused or not dirty = available
.859e	20 94 83	jsr $8394	                jsr xt_blkbuffer
.85a1	20 86 85	jsr $8586	                jsr xt_buffblocknum
.85a4	20 61 8f	jsr $8f61	                jsr xt_fetch
.85a7	20 41 85	jsr $8541	                jsr xt_block_write
.85aa					_buffer_available:
.85aa	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.85ac	b5 00		lda $00,x	                lda 0,x
.85ae	91 1e		sta ($1e),y	                sta (up),y
.85b0	c8		iny		                iny
.85b1	b5 01		lda $01,x	                lda 1,x
.85b3	91 1e		sta ($1e),y	                sta (up),y
.85b5	a9 01		lda #$01	                lda #1
.85b7	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85b9	91 1e		sta ($1e),y	                sta (up),y
.85bb					_done:
.85bb	a0 28		ldy #$28	                ldy #blkbuffer_offset
.85bd	b1 1e		lda ($1e),y	                lda (up),y
.85bf	95 00		sta $00,x	                sta 0,x
.85c1	c8		iny		                iny
.85c2	b1 1e		lda ($1e),y	                lda (up),y
.85c4	95 01		sta $01,x	                sta 1,x
.85c6	60		rts		z_buffer:       rts
.85c7					xt_buffer_colon:
.85c7	20 4a 89	jsr $894a	                jsr xt_create
.85ca	20 8c 82	jsr $828c	                jsr xt_allot
.85cd	60		rts		z_buffer_colon: rts
.85ce					xt_buffstatus:
.85ce	ca		dex		                dex
.85cf	ca		dex		                dex
.85d0	18		clc		                clc
.85d1	a5 1e		lda $1e		                lda up
.85d3	69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.85d5	95 00		sta $00,x	                sta 0,x
.85d7	a5 1f		lda $1f		                lda up+1
.85d9	69 00		adc #$00	                adc #0                  ; Adding carry
.85db	95 01		sta $01,x	                sta 1,x
.85dd	60		rts		z_buffstatus:   rts
.85de					xt_bye:
.85de	4c 2b f0	jmp $f02b	                jmp platform_bye
.85e1					z_bye:
.85e1					xt_c_comma:
.85e1	20 f6 d7	jsr $d7f6	                jsr underflow_1
.85e4	b5 00		lda $00,x	                lda 0,x
.85e6	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.85e9	e8		inx		                inx
.85ea	e8		inx		                inx
.85eb	60		rts		z_c_comma:      rts
.85ec					xt_c_fetch:
.85ec	20 f6 d7	jsr $d7f6	                jsr underflow_1
.85ef	a1 00		lda ($00,x)	                lda (0,x)
.85f1	95 00		sta $00,x	                sta 0,x
.85f3	74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.85f5	60		rts		z_c_fetch:      rts
.85f6					xt_c_store:
.85f6	20 fb d7	jsr $d7fb	                jsr underflow_2
.85f9	b5 02		lda $02,x	                lda 2,x
.85fb	81 00		sta ($00,x)	                sta (0,x)
.85fd	e8		inx		                inx
.85fe	e8		inx		                inx
.85ff	e8		inx		                inx
.8600	e8		inx		                inx
.8601	60		rts		z_c_store:      rts
.8602					xt_cell_plus:
.8602	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8605	f6 00		inc $00,x	                inc 0,x
.8607	d0 02		bne $860b	                bne +
.8609	f6 01		inc $01,x	                inc 1,x
.860b					+
.860b	f6 00		inc $00,x	                inc 0,x
.860d	d0 02		bne $8611	                bne _done
.860f	f6 01		inc $01,x	                inc 1,x
.8611					_done:
.8611	60		rts		z_cell_plus:    rts
.8612					xt_char:
.8612	20 c0 98	jsr $98c0	                jsr xt_parse_name
.8615	b5 00		lda $00,x	                lda 0,x
.8617	15 01		ora $01,x	                ora 1,x
.8619	d0 05		bne $8620	                bne _not_empty
.861b	a9 05		lda #$05	                lda #err_noname
.861d	4c 0c d8	jmp $d80c	                jmp error
.8620					_not_empty:
.8620	e8		inx		                inx             ; drop number of characters, leave addr
.8621	e8		inx		                inx
.8622	a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8624	95 00		sta $00,x	                sta 0,x
.8626	74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8628	60		rts		z_char:         rts
.8629					xt_chars:
.8629	20 f6 d7	jsr $d7f6	                jsr underflow_1
.862c	60		rts		z_chars:        rts
.862d					xt_cleave:
.862d	20 fb d7	jsr $d7fb	                jsr underflow_2
.8630	20 44 95	jsr $9544	                jsr xt_minus_leading    ; -LEADING ( addr u )
.8633	20 43 92	jsr $9243	                jsr xt_input_to_r       ; save old imput state
.8636	b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.8638	85 0a		sta $0a		                sta ciblen
.863a	b5 01		lda $01,x	                lda 1,x
.863c	85 0b		sta $0b		                sta ciblen+1
.863e	b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.8640	85 08		sta $08		                sta cib
.8642	b5 03		lda $03,x	                lda 3,x
.8644	85 09		sta $09		                sta cib+1
.8646	64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.8648	64 0d		stz $0d		                stz toin+1
.864a	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.864d	b5 00		lda $00,x	                lda 0,x
.864f	15 01		ora $01,x	                ora 1,x
.8651	f0 23		beq $8676	                beq _done
.8653	b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.8655	38		sec		                sec
.8656	f5 00		sbc $00,x	                sbc 0,x
.8658	95 04		sta $04,x	                sta 4,x
.865a	b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.865c	f5 01		sbc $01,x	                sbc 1,x
.865e	95 05		sta $05,x	                sta 5,x
.8660	b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.8662	18		clc		                clc
.8663	75 00		adc $00,x	                adc 0,x
.8665	95 06		sta $06,x	                sta 6,x
.8667	b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.8669	75 01		adc $01,x	                adc 1,x
.866b	95 07		sta $07,x	                sta 7,x
.866d	20 30 a4	jsr $a430	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.8670	20 44 95	jsr $9544	                jsr xt_minus_leading
.8673	20 30 a4	jsr $a430	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.8676					_done:
.8676	20 84 9a	jsr $9a84	                jsr xt_r_to_input
.8679	60		rts		z_cleave:       rts
.867a					xt_cmove:
.867a	20 00 d8	jsr $d800	                jsr underflow_3
.867d	b5 02		lda $02,x	                lda 2,x
.867f	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.8681	b5 03		lda $03,x	                lda 3,x
.8683	85 27		sta $27		                sta tmp2+1
.8685	b5 04		lda $04,x	                lda 4,x
.8687	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.8689	b5 05		lda $05,x	                lda 5,x
.868b	85 25		sta $25		                sta tmp1+1
.868d	a0 00		ldy #$00	                ldy #0
.868f	b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.8691	f0 0f		beq $86a2	                beq _dopartial
.8693					_page:
.8693	b1 24		lda ($24),y	                lda (tmp1),y
.8695	91 26		sta ($26),y	                sta (tmp2),y
.8697	c8		iny		                iny
.8698	d0 f9		bne $8693	                bne _page
.869a	e6 25		inc $25		                inc tmp1+1
.869c	e6 27		inc $27		                inc tmp2+1
.869e	d6 01		dec $01,x	                dec 1,x
.86a0	d0 f1		bne $8693	                bne _page
.86a2					_dopartial:
.86a2	b5 00		lda $00,x	                lda 0,x         ; length of last page
.86a4	f0 09		beq $86af	                beq _done
.86a6					_partial:
.86a6	b1 24		lda ($24),y	                lda (tmp1),y
.86a8	91 26		sta ($26),y	                sta (tmp2),y
.86aa	c8		iny		                iny
.86ab	d6 00		dec $00,x	                dec 0,x
.86ad	d0 f7		bne $86a6	                bne _partial
.86af					_done:
.86af	8a		txa		                txa
.86b0	18		clc		                clc
.86b1	69 06		adc #$06	                adc #6
.86b3	aa		tax		                tax
.86b4	60		rts		z_cmove:        rts
.86b5					xt_cmove_up:
.86b5	20 00 d8	jsr $d800	                jsr underflow_3
.86b8	b5 02		lda $02,x	                lda 2,x
.86ba	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86bc	b5 03		lda $03,x	                lda 3,x
.86be	18		clc		                clc
.86bf	75 01		adc $01,x	                adc 1,x
.86c1	85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.86c3	b5 04		lda $04,x	                lda 4,x
.86c5	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86c7	b5 05		lda $05,x	                lda 5,x
.86c9	18		clc		                clc
.86ca	75 01		adc $01,x	                adc 1,x
.86cc	85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86ce	f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86d0	b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86d2	f0 0e		beq $86e2	                beq _nopartial
.86d4					_outerloop:
.86d4	88		dey		                dey
.86d5	f0 07		beq $86de	                beq _finishpage
.86d7					_innerloop:
.86d7	b1 24		lda ($24),y	                lda (tmp1),y
.86d9	91 26		sta ($26),y	                sta (tmp2),y
.86db	88		dey		                dey
.86dc	d0 f9		bne $86d7	                bne _innerloop
.86de					_finishpage:
.86de	b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.86e0	92 26		sta ($26)	                sta (tmp2)
.86e2					_nopartial:
.86e2	c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.86e4	c6 27		dec $27		                dec tmp2+1
.86e6	d6 01		dec $01,x	                dec 1,x
.86e8	d0 ea		bne $86d4	                bne _outerloop
.86ea					_done:
.86ea	8a		txa		                txa
.86eb	18		clc		                clc
.86ec	69 06		adc #$06	                adc #6
.86ee	aa		tax		                tax
.86ef	60		rts		z_cmove_up:     rts
.86f0					xt_colon:
.86f0	a5 16		lda $16		                lda state
.86f2	05 17		ora $17		                ora state+1
.86f4	f0 05		beq $86fb	                beq +
.86f6	a9 07		lda #$07	                lda #err_state
.86f8	4c 0c d8	jmp $d80c	                jmp error
.86fb					+
.86fb	c6 16		dec $16		                dec state
.86fd	c6 17		dec $17		                dec state+1
.86ff	a9 40		lda #$40	                lda #%01000000
.8701	04 20		tsb $20		                tsb status
.8703	20 38 d7	jsr $d738	                jsr current_to_dp
.8706	a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8708	48		pha		                pha
.8709	a5 02		lda $02		                lda dp
.870b	48		pha		                pha
.870c	a9 80		lda #$80	                lda #%10000000
.870e	04 20		tsb $20		                tsb status
.8710	20 4a 89	jsr $894a	                jsr xt_create
.8713	20 38 d7	jsr $d738	                jsr current_to_dp   ; This might be able to be omitted
.8716	a5 02		lda $02		                lda dp
.8718	85 04		sta $04		                sta workword
.871a	a5 03		lda $03		                lda dp+1
.871c	85 05		sta $05		                sta workword+1
.871e	68		pla		                pla
.871f	85 02		sta $02		                sta dp
.8721	68		pla		                pla
.8722	85 03		sta $03		                sta dp+1
.8724	20 4b d7	jsr $d74b	                jsr dp_to_current
.8727	a5 00		lda $00		                lda cp
.8729	38		sec		                sec
.872a	e9 03		sbc #$03	                sbc #3
.872c	85 00		sta $00		                sta cp
.872e	b0 02		bcs $8732	                bcs _done
.8730	c6 01		dec $01		                dec cp+1
.8732					_done:
.8732	60		rts		z_colon:        rts
.8733					xt_colon_noname:
.8733	a5 16		lda $16		                lda state
.8735	05 17		ora $17		                ora state+1
.8737	f0 05		beq $873e	                beq +
.8739	a9 07		lda #$07	                lda #err_state
.873b	4c 0c d8	jmp $d80c	                jmp error
.873e					+
.873e	c6 16		dec $16		                dec state
.8740	c6 17		dec $17		                dec state+1
.8742	a9 40		lda #$40	                lda #%01000000
.8744	14 20		trb $20		                trb status
.8746	a5 00		lda $00		                lda cp
.8748	85 04		sta $04		                sta workword
.874a	a5 01		lda $01		                lda cp+1
.874c	85 05		sta $05		                sta workword+1
.874e					_done:
.874e	60		rts		z_colon_noname:        rts
.874f					xt_comma:
.874f	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8752	b5 00		lda $00,x	                lda 0,x
.8754	92 00		sta ($00)	                sta (cp)
.8756	e6 00		inc $00		                inc cp
.8758	d0 02		bne $875c	                bne +
.875a	e6 01		inc $01		                inc cp+1
.875c					+
.875c	b5 01		lda $01,x	                lda 1,x
.875e	92 00		sta ($00)	                sta (cp)
.8760	e6 00		inc $00		                inc cp
.8762	d0 02		bne $8766	                bne _done
.8764	e6 01		inc $01		                inc cp+1
.8766					_done:
.8766	e8		inx		                inx
.8767	e8		inx		                inx
.8768	60		rts		z_comma:        rts
.8769					xt_compare:
.8769	20 05 d8	jsr $d805	                jsr underflow_4
.876c	b5 02		lda $02,x	                lda 2,x
.876e	85 26		sta $26		                sta tmp2
.8770	b5 03		lda $03,x	                lda 3,x
.8772	85 27		sta $27		                sta tmp2+1
.8774	b5 06		lda $06,x	                lda 6,x
.8776	85 24		sta $24		                sta tmp1
.8778	b5 07		lda $07,x	                lda 7,x
.877a	85 25		sta $25		                sta tmp1+1
.877c					_compare_loop:
.877c	b5 04		lda $04,x	                lda 4,x
.877e	15 05		ora $05,x	                ora 5,x
.8780	f0 2c		beq $87ae	                beq _str1_done
.8782	b5 00		lda $00,x	                lda 0,x
.8784	15 01		ora $01,x	                ora 1,x
.8786	f0 3a		beq $87c2	                beq _greater    ; Str2 empty first
.8788					_check_letter:
.8788	b2 24		lda ($24)	                lda (tmp1)
.878a	d2 26		cmp ($26)	                cmp (tmp2)
.878c	90 26		bcc $87b4	                bcc _less
.878e	d0 32		bne $87c2	                bne _greater
.8790					_next_letter:
.8790	e6 24		inc $24		                inc tmp1
.8792	d0 02		bne $8796	                bne +
.8794	e6 25		inc $25		                inc tmp1+1
.8796					+
.8796	e6 26		inc $26		                inc tmp2
.8798	d0 02		bne $879c	                bne +
.879a	e6 27		inc $27		                inc tmp2+1
.879c					+
.879c	b5 04		lda $04,x	                lda 4,x
.879e	d0 02		bne $87a2	                bne +
.87a0	d6 05		dec $05,x	                dec 5,x
.87a2					+
.87a2	d6 04		dec $04,x	                dec 4,x
.87a4	b5 00		lda $00,x	                lda 0,x
.87a6	d0 02		bne $87aa	                bne +
.87a8	d6 01		dec $01,x	                dec 1,x
.87aa					+
.87aa	d6 00		dec $00,x	                dec 0,x
.87ac	80 ce		bra $877c	                bra _compare_loop
.87ae					_str1_done:
.87ae	b5 00		lda $00,x	                lda 0,x
.87b0	15 01		ora $01,x	                ora 1,x
.87b2	f0 08		beq $87bc	                beq _equal      ; Both out of letters
.87b4					_less:
.87b4	a9 ff		lda #$ff	                lda #$FF
.87b6	95 06		sta $06,x	                sta 6,x
.87b8	95 07		sta $07,x	                sta 7,x
.87ba	80 0c		bra $87c8	                bra _done
.87bc					_equal:
.87bc	74 06		stz $06,x	                stz 6,x
.87be	74 07		stz $07,x	                stz 7,x
.87c0	80 06		bra $87c8	                bra _done
.87c2					_greater:
.87c2	a9 01		lda #$01	                lda #1
.87c4	95 06		sta $06,x	                sta 6,x
.87c6	74 07		stz $07,x	                stz 7,x
.87c8					_done:
.87c8	8a		txa		                txa
.87c9	18		clc		                clc
.87ca	69 06		adc #$06	                adc #6
.87cc	aa		tax		                tax
.87cd	60		rts		z_compare:      rts
.87ce					xt_compile_comma:
.87ce	20 f6 d7	jsr $d7f6	                jsr underflow_1
.87d1	b5 01		lda $01,x	                lda 1,x                 ; MSB
.87d3	48		pha		                pha
.87d4	b5 00		lda $00,x	                lda 0,x
.87d6	48		pha		                pha                     ; LSB
.87d7	20 59 92	jsr $9259	                jsr xt_int_to_name      ; ( xt -- nt )
.87da	b5 00		lda $00,x	                lda 0,x
.87dc	15 01		ora $01,x	                ora 1,x
.87de	d0 03		bne $87e3	                bne _check_nt
.87e0	4c cb 88	jmp $88cb	                jmp _compile_as_jump
.87e3					_check_nt:
.87e3	b5 00		lda $00,x	                lda 0,x
.87e5	85 2c		sta $2c		                sta tmptos
.87e7	b5 01		lda $01,x	                lda 1,x
.87e9	85 2d		sta $2d		                sta tmptos+1
.87eb	f6 00		inc $00,x	                inc 0,x
.87ed	d0 02		bne $87f1	                bne +
.87ef	f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.87f1					+
.87f1	a1 00		lda ($00,x)	                lda (0,x)
.87f3	85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.87f5	29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.87f7	f0 0d		beq $8806	                beq _compile_check
.87f9	a5 2c		lda $2c		                lda tmptos
.87fb	95 00		sta $00,x	                sta 0,x
.87fd	a5 2d		lda $2d		                lda tmptos+1
.87ff	95 01		sta $01,x	                sta 1,x
.8801	20 27 a7	jsr $a727	                jsr xt_wordsize         ; ( nt -- u )
.8804	80 27		bra $882d	                bra _compile_as_code
.8806					_compile_check:
.8806	a5 28		lda $28		                lda tmp3
.8808	29 08		and #$08	                and #NN
.880a	f0 03		beq $880f	                beq _check_size_limit
.880c	4c cb 88	jmp $88cb	                jmp _compile_as_jump    ; too far for BRA
.880f					_check_size_limit:
.880f	a5 2c		lda $2c		                lda tmptos
.8811	95 00		sta $00,x	                sta 0,x
.8813	a5 2d		lda $2d		                lda tmptos+1
.8815	95 01		sta $01,x	                sta 1,x
.8817	20 27 a7	jsr $a727	                jsr xt_wordsize         ; ( nt -- u )
.881a	b5 01		lda $01,x	                lda 1,x
.881c	c5 1b		cmp $1b		                cmp nc_limit+1
.881e	90 0d		bcc $882d	                bcc _compile_as_code    ; user-defined limit MSB
.8820	d0 08		bne $882a	                bne _jumpto_compile_as_jump
.8822	b5 00		lda $00,x	                lda 0,x
.8824	c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.8826	90 05		bcc $882d	                bcc _compile_as_code    ; Allow native compiling for less
.8828	f0 03		beq $882d	                beq _compile_as_code    ; than or equal to the limit.
.882a					_jumpto_compile_as_jump:
.882a	4c cb 88	jmp $88cb	                jmp _compile_as_jump    ; too far for BRA
.882d					_compile_as_code:
.882d	ca		dex		                dex
.882e	ca		dex		                dex                     ; ( -- u ? )
.882f	ca		dex		                dex
.8830	ca		dex		                dex                     ; ( -- u ? ? )
.8831	b5 04		lda $04,x	                lda 4,x
.8833	95 00		sta $00,x	                sta 0,x                 ; LSB of u
.8835	b5 05		lda $05,x	                lda 5,x
.8837	95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.8839	68		pla		                pla
.883a	95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.883c	68		pla		                pla
.883d	95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.883f	a5 00		lda $00		                lda cp                  ; LSB of cp
.8841	95 02		sta $02,x	                sta 2,x
.8843	a5 01		lda $01		                lda cp+1
.8845	95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.8847	a0 00		ldy #$00	                ldy #0
.8849					_strip_loop:
.8849	b9 b9 88	lda $88b9,y	                lda _strip_table,y      ; LSB of first word
.884c	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.884e	d0 07		bne $8857	                bne _next_entry
.8850	b9 ba 88	lda $88ba,y	                lda _strip_table+1,y
.8853	d5 05		cmp $05,x	                cmp 5,x
.8855	f0 0c		beq $8863	                beq _found_entry
.8857					_next_entry:
.8857	b9 b9 88	lda $88b9,y	                lda _strip_table,y      ; pointing to LSB
.885a	19 ba 88	ora $88ba,y	                ora _strip_table+1,y    ; get MSB
.885d	f0 22		beq $8881	                beq _underflow_strip    ; table done, let's get out of here
.885f	c8		iny		                iny
.8860	c8		iny		                iny
.8861	80 e6		bra $8849	                bra _strip_loop
.8863					_found_entry:
.8863	98		tya		                tya
.8864	4a		lsr a		                lsr
.8865	a8		tay		                tay
.8866	b9 c5 88	lda $88c5,y	                lda _strip_size,y
.8869	85 2c		sta $2c		                sta tmptos              ; save a copy
.886b	18		clc		                clc
.886c	75 04		adc $04,x	                adc 4,x
.886e	95 04		sta $04,x	                sta 4,x
.8870	90 02		bcc $8874	                bcc+
.8872	f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8874					+
.8874	06 2c		asl $2c		                asl tmptos
.8876	38		sec		                sec
.8877	b5 00		lda $00,x	                lda 0,x
.8879	e5 2c		sbc $2c		                sbc tmptos
.887b	95 00		sta $00,x	                sta 0,x
.887d	b0 02		bcs $8881	                bcs +
.887f	d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8881					+
.8881					_underflow_strip:
.8881	a5 1c		lda $1c		                lda uf_strip
.8883	05 1d		ora $1d		                ora uf_strip+1
.8885	f0 1c		beq $88a3	                beq _specials_done
.8887	a5 28		lda $28		                lda tmp3
.8889	29 10		and #$10	                and #UF
.888b	f0 16		beq $88a3	                beq _specials_done
.888d	18		clc		                clc
.888e	b5 04		lda $04,x	                lda 4,x
.8890	69 03		adc #$03	                adc #3
.8892	95 04		sta $04,x	                sta 4,x
.8894	90 02		bcc $8898	                bcc +
.8896	f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.8898					+
.8898	38		sec		                sec
.8899	b5 00		lda $00,x	                lda 0,x
.889b	e9 03		sbc #$03	                sbc #3
.889d	95 00		sta $00,x	                sta 0,x
.889f	b0 02		bcs $88a3	                bcs +
.88a1	d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.88a3					+
.88a3					_specials_done:
.88a3	b5 01		lda $01,x	                lda 1,x                 ; MSB
.88a5	48		pha		                pha
.88a6	b5 00		lda $00,x	                lda 0,x                 ; LSB
.88a8	48		pha		                pha
.88a9	20 a3 95	jsr $95a3	                jsr xt_move
.88ac	18		clc		                clc
.88ad	68		pla		                pla                     ; LSB
.88ae	65 00		adc $00		                adc cp
.88b0	85 00		sta $00		                sta cp
.88b2	68		pla		                pla                     ; MSB
.88b3	65 01		adc $01		                adc cp+1
.88b5	85 01		sta $01		                sta cp+1
.88b7	80 2c		bra $88e5	                bra _done
.88b9					_strip_table:
>88b9	73 9a 5e 9a 22 a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88bf	54 a4 da a3 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88c5					_strip_size:
>88c5	04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88cb					_compile_as_jump:
.88cb	a9 20		lda #$20	                lda #$20
.88cd	92 00		sta ($00)	                sta (cp)
.88cf	a0 01		ldy #$01	                ldy #1
.88d1	68		pla		                pla             ; LSB
.88d2	91 00		sta ($00),y	                sta (cp),y
.88d4	c8		iny		                iny
.88d5	68		pla		                pla             ; MSB
.88d6	91 00		sta ($00),y	                sta (cp),y
.88d8	a9 03		lda #$03	                lda #3
.88da	18		clc		                clc
.88db	65 00		adc $00		                adc cp
.88dd	85 00		sta $00		                sta cp
.88df	90 02		bcc $88e3	                bcc +
.88e1	e6 01		inc $01		                inc cp+1
.88e3					+
.88e3	e8		inx		                inx             ; drop xt
.88e4	e8		inx		                inx
.88e5					_done:
.88e5					z_compile_comma:
.88e5	60		rts		                rts
.88e6					xt_compile_only:
.88e6	20 38 d7	jsr $d738	                jsr current_to_dp
.88e9	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.88eb	b1 02		lda ($02),y	                lda (dp),y
.88ed	09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.88ef	91 02		sta ($02),y	                sta (dp),y
.88f1	60		rts		z_compile_only: rts
.88f2					xt_value:
.88f2					xt_constant:
.88f2	20 f6 d7	jsr $d7f6	                jsr underflow_1
.88f5	20 4a 89	jsr $894a	                jsr xt_create
.88f8	38		sec		                sec
.88f9	a5 00		lda $00		                lda cp
.88fb	e9 02		sbc #$02	                sbc #2
.88fd	85 24		sta $24		                sta tmp1
.88ff	a5 01		lda $01		                lda cp+1
.8901	e9 00		sbc #$00	                sbc #0
.8903	85 25		sta $25		                sta tmp1+1
.8905	a9 b2		lda #$b2	                lda #<doconst           ; LSB of DOCONST
.8907	92 24		sta ($24)	                sta (tmp1)
.8909	a0 01		ldy #$01	                ldy #1
.890b	a9 d6		lda #$d6	                lda #>doconst           ; MSB of DOCONST
.890d	91 24		sta ($24),y	                sta (tmp1),y
.890f	20 4f 87	jsr $874f	                jsr xt_comma            ; drop through to adjust_z
.8912					adjust_z:
.8912	20 1c 93	jsr $931c	                jsr xt_latestnt         ; gives us ( -- nt )
.8915	b5 00		lda $00,x	                lda 0,x
.8917	85 24		sta $24		                sta tmp1
.8919	b5 01		lda $01,x	                lda 1,x
.891b	85 25		sta $25		                sta tmp1+1
.891d	a0 06		ldy #$06	                ldy #6
.891f	b1 24		lda ($24),y	                lda (tmp1),y
.8921	18		clc		                clc
.8922	69 02		adc #$02	                adc #2
.8924	91 24		sta ($24),y	                sta (tmp1),y
.8926	c8		iny		                iny
.8927	b1 24		lda ($24),y	                lda (tmp1),y
.8929	69 00		adc #$00	                adc #0                  ; only need carry
.892b	91 24		sta ($24),y	                sta (tmp1),y
.892d	e8		inx		                inx
.892e	e8		inx		                inx
.892f					z_value:
.892f	60		rts		z_constant:     rts
.8930					xt_count:
.8930	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8933	a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.8935	a8		tay		                tay
.8936	f6 00		inc $00,x	                inc 0,x         ; LSB
.8938	d0 02		bne $893c	                bne +
.893a	f6 01		inc $01,x	                inc 1,x         ; MSB
.893c	98		tya		+               tya
.893d	ca		dex		                dex
.893e	ca		dex		                dex
.893f	95 00		sta $00,x	                sta 0,x         ; LSB
.8941	74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8943	60		rts		z_count:        rts
.8944					xt_cr:
.8944	a9 0a		lda #$0a	                lda #AscLF
.8946	20 d7 8d	jsr $8dd7	                jsr emit_a
.8949	60		rts		z_cr:           rts
.894a					xt_create:
.894a	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( addr u )
.894d	b5 00		lda $00,x	                lda 0,x
.894f	15 01		ora $01,x	                ora 1,x
.8951	d0 05		bne $8958	                bne _got_name
.8953	a9 05		lda #$05	                lda #err_noname
.8955	4c 0c d8	jmp $d80c	                jmp error
.8958					_got_name:
.8958	74 01		stz $01,x	                stz 1,x
.895a	20 6a a3	jsr $a36a	                jsr xt_two_dup          ; ( addr u addr u )
.895d	20 bc 8f	jsr $8fbc	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8960	b5 00		lda $00,x	                lda 0,x
.8962	15 01		ora $01,x	                ora 1,x
.8964	f0 1e		beq $8984	                beq _new_name           ; We haven't seen this one before.
.8966	e8		inx		                inx                     ; Drop flag (nt) from find-name.
.8967	e8		inx		                inx
.8968	24 20		bit $20		                bit status
.896a	10 08		bpl $8974	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.896c	a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.896e	05 20		ora $20		                ora status
.8970	85 20		sta $20		                sta status
.8972	80 18		bra $898c	                bra _process_name
.8974					_redefined_name:
.8974	a9 02		lda #$02	                lda #str_redefined
.8976	20 32 d8	jsr $d832	                jsr print_string_no_lf
.8979	20 6a a3	jsr $a36a	                jsr xt_two_dup           ; ( addr u addr u )
.897c	20 b5 a4	jsr $a4b5	                jsr xt_type
.897f	20 d0 a0	jsr $a0d0	                jsr xt_space
.8982	80 08		bra $898c	                bra _process_name
.8984					_new_name:
.8984	e8		inx		                inx                     ; Drop flag (0) from find-name.
.8985	e8		inx		                inx
.8986	a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.8988	25 20		and $20		                and status
.898a	85 20		sta $20		                sta status
.898c					_process_name:
.898c	b5 00		lda $00,x	                lda 0,x
.898e	85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.8990	a5 00		lda $00		                lda cp
.8992	85 24		sta $24		                sta tmp1
.8994	a5 01		lda $01		                lda cp+1
.8996	85 25		sta $25		                sta tmp1+1
.8998	b5 00		lda $00,x	                lda 0,x
.899a	18		clc		                clc
.899b	69 08		adc #$08	                adc #8
.899d	85 28		sta $28		                sta tmp3                ; total header length
.899f	18		clc		                clc
.89a0	69 03		adc #$03	                adc #3
.89a2	95 00		sta $00,x	                sta 0,x
.89a4	74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.89a6	20 8c 82	jsr $828c	                jsr xt_allot    ; ( addr )
.89a9	20 38 d7	jsr $d738	                jsr current_to_dp
.89ac	a0 00		ldy #$00	                ldy #0
.89ae	a5 26		lda $26		                lda tmp2
.89b0	91 24		sta ($24),y	                sta (tmp1),y
.89b2	a9 08		lda #$08	                lda #NN
.89b4	09 20		ora #$20	                ora #HC
.89b6	c8		iny		                iny
.89b7	91 24		sta ($24),y	                sta (tmp1),y
.89b9	c8		iny		                iny
.89ba	a5 02		lda $02		                lda dp
.89bc	91 24		sta ($24),y	                sta (tmp1),y
.89be	c8		iny		                iny
.89bf	a5 03		lda $03		                lda dp+1
.89c1	91 24		sta ($24),y	                sta (tmp1),y
.89c3	c8		iny		                iny
.89c4	a5 25		lda $25		                lda tmp1+1
.89c6	85 03		sta $03		                sta dp+1
.89c8	a5 24		lda $24		                lda tmp1
.89ca	85 02		sta $02		                sta dp
.89cc	18		clc		                clc
.89cd	65 28		adc $28		                adc tmp3        ; add total header length
.89cf	91 24		sta ($24),y	                sta (tmp1),y
.89d1	48		pha		                pha             ; we need this in the next step
.89d2	c8		iny		                iny
.89d3	a5 25		lda $25		                lda tmp1+1
.89d5	69 00		adc #$00	                adc #0          ; only need the carry
.89d7	91 24		sta ($24),y	                sta (tmp1),y
.89d9	c8		iny		                iny
.89da	68		pla		                pla             ; LSB of "z_" address
.89db	18		clc		                clc
.89dc	69 03		adc #$03	                adc #3
.89de	91 24		sta ($24),y	                sta (tmp1),y
.89e0	88		dey		                dey             ; get the MSB of xt back
.89e1	b1 24		lda ($24),y	                lda (tmp1),y
.89e3	69 00		adc #$00	                adc #0          ; only need the carry
.89e5	c8		iny		                iny
.89e6	c8		iny		                iny
.89e7	91 24		sta ($24),y	                sta (tmp1),y
.89e9	c8		iny		                iny
.89ea	b5 00		lda $00,x	                lda 0,x
.89ec	38		sec		                sec
.89ed	e9 08		sbc #$08	                sbc #8
.89ef	85 2c		sta $2c		                sta tmptos
.89f1	b5 01		lda $01,x	                lda 1,x
.89f3	e9 00		sbc #$00	                sbc #0          ; only need carry
.89f5	85 2d		sta $2d		                sta tmptos+1
.89f7					_name_loop:
.89f7	b1 2c		lda ($2c),y	                lda (tmptos),y
.89f9	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.89fb	b0 07		bcs $8a04	                bcs _store_name
.89fd	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.89ff	90 03		bcc $8a04	                bcc _store_name
.8a01	18		clc		                clc
.8a02	69 20		adc #$20	                adc #$20
.8a04					_store_name:
.8a04	91 24		sta ($24),y	                sta (tmp1),y
.8a06	c8		iny		                iny
.8a07	c6 26		dec $26		                dec tmp2
.8a09	d0 ec		bne $89f7	                bne _name_loop
.8a0b	a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a0d	91 24		sta ($24),y	                sta (tmp1),y
.8a0f	c8		iny		                iny
.8a10	a9 f8		lda #$f8	                lda #<dovar
.8a12	91 24		sta ($24),y	                sta (tmp1),y
.8a14	c8		iny		                iny
.8a15	a9 d6		lda #$d6	                lda #>dovar
.8a17	91 24		sta ($24),y	                sta (tmp1),y
.8a19	20 4b d7	jsr $d74b	                jsr dp_to_current
.8a1c	e8		inx		                inx
.8a1d	e8		inx		                inx
.8a1e	60		rts		z_create:       rts
.8a1f					xt_d_minus:
.8a1f	20 05 d8	jsr $d805	                jsr underflow_4 ; two double numbers
.8a22	38		sec		                sec
.8a23	b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a25	f5 02		sbc $02,x	                sbc 2,x
.8a27	95 06		sta $06,x	                sta 6,x
.8a29	b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a2b	f5 03		sbc $03,x	                sbc 3,x
.8a2d	95 07		sta $07,x	                sta 7,x
.8a2f	b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a31	f5 00		sbc $00,x	                sbc 0,x
.8a33	95 04		sta $04,x	                sta 4,x
.8a35	b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a37	f5 01		sbc $01,x	                sbc 1,x
.8a39	95 05		sta $05,x	                sta 5,x
.8a3b	e8		inx		                inx
.8a3c	e8		inx		                inx
.8a3d	e8		inx		                inx
.8a3e	e8		inx		                inx
.8a3f	60		rts		z_d_minus:      rts
.8a40					xt_d_plus:
.8a40	20 05 d8	jsr $d805	                jsr underflow_4 ; two double numbers
.8a43	18		clc		                clc
.8a44	b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a46	75 06		adc $06,x	                adc 6,x
.8a48	95 06		sta $06,x	                sta 6,x
.8a4a	b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a4c	75 07		adc $07,x	                adc 7,x
.8a4e	95 07		sta $07,x	                sta 7,x
.8a50	b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a52	75 04		adc $04,x	                adc 4,x
.8a54	95 04		sta $04,x	                sta 4,x
.8a56	b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a58	75 05		adc $05,x	                adc 5,x
.8a5a	95 05		sta $05,x	                sta 5,x
.8a5c	e8		inx		                inx
.8a5d	e8		inx		                inx
.8a5e	e8		inx		                inx
.8a5f	e8		inx		                inx
.8a60	60		rts		z_d_plus:       rts
.8a61					xt_d_to_s:
.8a61	20 fb d7	jsr $d7fb	                jsr underflow_2
.8a64	e8		inx		                inx
.8a65	e8		inx		                inx
.8a66	60		rts		z_d_to_s:       rts
.8a67					xt_dabs:
.8a67	20 fb d7	jsr $d7fb	                jsr underflow_2 ; double number
.8a6a	b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a6c	10 17		bpl $8a85	                bpl _done       ; positive, we get off light
.8a6e	a0 00		ldy #$00	                ldy #0
.8a70	38		sec		                sec
.8a71	98		tya		                tya
.8a72	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a74	95 02		sta $02,x	                sta 2,x
.8a76	98		tya		                tya
.8a77	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a79	95 03		sta $03,x	                sta 3,x
.8a7b	98		tya		                tya
.8a7c	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a7e	95 00		sta $00,x	                sta 0,x
.8a80	98		tya		                tya
.8a81	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a83	95 01		sta $01,x	                sta 1,x
.8a85					_done:
.8a85	60		rts		z_dabs:         rts
.8a86					xt_decimal:
.8a86	a9 0a		lda #$0a	                lda #10
.8a88	85 18		sta $18		                sta base
.8a8a	64 19		stz $19		                stz base+1              ; paranoid
.8a8c	60		rts		z_decimal:      rts
.8a8d					xt_defer:
.8a8d	20 4a 89	jsr $894a	                jsr xt_create
.8a90	a5 00		lda $00		                lda cp          ; LSB
.8a92	38		sec		                sec
.8a93	e9 02		sbc #$02	                sbc #2
.8a95	85 24		sta $24		                sta tmp1
.8a97	a5 01		lda $01		                lda cp+1        ; MSB
.8a99	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8a9b	85 25		sta $25		                sta tmp1+1
.8a9d	a0 00		ldy #$00	                ldy #0
.8a9f	a9 c6		lda #$c6	                lda #<dodefer   ; LSB
.8aa1	91 24		sta ($24),y	                sta (tmp1),y
.8aa3	c8		iny		                iny
.8aa4	a9 d6		lda #$d6	                lda #>dodefer   ; MSB
.8aa6	91 24		sta ($24),y	                sta (tmp1),y
.8aa8	a9 da		lda #$da	                lda #<defer_error
.8aaa	92 00		sta ($00)	                sta (cp)
.8aac	e6 00		inc $00		                inc cp
.8aae	d0 02		bne $8ab2	                bne +
.8ab0	e6 01		inc $01		                inc cp+1
.8ab2					+
.8ab2	a9 d6		lda #$d6	                lda #>defer_error
.8ab4	92 00		sta ($00)	                sta (cp)
.8ab6	e6 00		inc $00		                inc cp
.8ab8	d0 02		bne $8abc	                bne +
.8aba	e6 01		inc $01		                inc cp+1
.8abc					+
.8abc	20 12 89	jsr $8912	                jsr adjust_z    ; adjust header to correct length
.8abf	60		rts		z_defer:        rts
.8ac0					xt_defer_fetch:
.8ac0	20 3f a2	jsr $a23f	                jsr xt_to_body
.8ac3	20 61 8f	jsr $8f61	                jsr xt_fetch
.8ac6	60		rts		z_defer_fetch:  rts
.8ac7					xt_defer_store:
.8ac7	20 3f a2	jsr $a23f	                jsr xt_to_body
.8aca	20 3f a1	jsr $a13f	                jsr xt_store
.8acd	60		rts		z_defer_store:  rts
.8ace					xt_definitions:
.8ace	a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8ad0	b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8ad2	a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8ad4	91 1e		sta ($1e),y	                sta (up),y
.8ad6	60		rts		z_definitions:  rts
.8ad7					xt_depth:
.8ad7	a9 78		lda #$78	                lda #dsp0
.8ad9	86 2a		stx $2a		                stx tmpdsp
.8adb	38		sec		                sec
.8adc	e5 2a		sbc $2a		                sbc tmpdsp
.8ade	4a		lsr a		                lsr
.8adf	ca		dex		                dex
.8ae0	ca		dex		                dex
.8ae1	95 00		sta $00,x	                sta 0,x
.8ae3	74 01		stz $01,x	                stz 1,x
.8ae5	60		rts		z_depth:        rts
.8ae6					xt_digit_question:
.8ae6	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8ae9	ca		dex		                dex
.8aea	ca		dex		                dex
.8aeb	74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8aed	74 01		stz $01,x	                stz 1,x
.8aef	74 03		stz $03,x	                stz 3,x                 ; paranoid
.8af1	b5 02		lda $02,x	                lda 2,x
.8af3	c9 30		cmp #$30	                cmp #'0'
.8af5	90 23		bcc $8b1a	                bcc _done               ; failure flag already set
.8af7	c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8af9	90 12		bcc $8b0d	                bcc _checkbase
.8afb	c9 41		cmp #$41	                cmp #'A'
.8afd	90 1b		bcc $8b1a	                bcc _done               ; failure flag is already set
.8aff	c9 61		cmp #$61	                cmp #'a'
.8b01	90 07		bcc $8b0a	                bcc _case_done          ; not lower case, too low
.8b03	c9 7b		cmp #$7b	                cmp #'z'+1
.8b05	b0 03		bcs $8b0a	                bcs _case_done          ; not lower case, too high
.8b07	18		clc		                clc                     ; just right
.8b08	69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b0a					_case_done:
.8b0a	38		sec		                sec
.8b0b	e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b0d					_checkbase:
.8b0d	38		sec		                sec
.8b0e	e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b10	c5 18		cmp $18		                cmp base
.8b12	b0 06		bcs $8b1a	                bcs _done               ; already have false flag
.8b14	95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b16	d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b18	d6 01		dec $01,x	                dec 1,x
.8b1a					_done:
.8b1a					z_digit_question:
.8b1a	60		rts		                rts
.8b1b					xt_disasm:
.8b1b	20 fb d7	jsr $d7fb	                jsr underflow_2
.8b1e	20 89 ac	jsr $ac89	                jsr disassembler
.8b21	60		rts		z_disasm:       rts
.8b22					xt_dnegate:
.8b22	20 fb d7	jsr $d7fb	                jsr underflow_2 ; double number
.8b25	a0 00		ldy #$00	     		ldy #0
.8b27	38		sec		                sec
.8b28	98		tya		                tya
.8b29	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b2b	95 02		sta $02,x	                sta 2,x
.8b2d	98		tya		                tya
.8b2e	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b30	95 03		sta $03,x	                sta 3,x
.8b32	98		tya		                tya
.8b33	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b35	95 00		sta $00,x	                sta 0,x
.8b37	98		tya		                tya
.8b38	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b3a	95 01		sta $01,x	                sta 1,x
.8b3c	60		rts		z_dnegate:      rts
.8b3d					xt_question_do:
.8b3d	a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b3f	85 24		sta $24		                sta tmp1
.8b41	80 02		bra $8b45	                bra do_common           ; skip flag for DO
.8b43					xt_do:
.8b43	64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b45					do_common:
.8b45	ca		dex		                dex
.8b46	ca		dex		                dex
.8b47	a5 00		lda $00		                lda cp
.8b49	95 00		sta $00,x	                sta 0,x                 ; LSB
.8b4b	a5 01		lda $01		                lda cp+1
.8b4d	95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b4f	a9 05		lda #$05	                lda #5                  ; we don't really care about the value,
.8b51	a8		tay		                tay                     ; so we use 5 to be tricky
.8b52					_loop:
.8b52	91 00		sta ($00),y	                sta (CP),y
.8b54	88		dey		                dey
.8b55	10 fb		bpl $8b52	                bpl _loop
.8b57	1a		inc a		                ina             ; we used 5 as a dummy value, this is why
.8b58	18		clc		                clc
.8b59	65 00		adc $00		                adc CP
.8b5b	85 00		sta $00		                sta CP
.8b5d	90 02		bcc $8b61	                bcc +
.8b5f	e6 01		inc $01		                inc CP+1
.8b61					+
.8b61	a5 24		lda $24		                lda tmp1
.8b63	f0 17		beq $8b7c	                beq _compile_do
.8b65	a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b67	5a		phy		                phy             ; save counter to calculate new CP
.8b68					-
.8b68	b9 c2 8b	lda $8bc2,y	                lda question_do_runtime,y
.8b6b	91 00		sta ($00),y	                sta (cp),y
.8b6d	88		dey		                dey
.8b6e	10 f8		bpl $8b68	                bpl -
.8b70	68		pla		                pla             ; retrieve counter
.8b71	18		clc		                clc
.8b72	65 00		adc $00		                adc cp
.8b74	85 00		sta $00		                sta cp
.8b76	a5 01		lda $01		                lda cp+1
.8b78	69 00		adc #$00	                adc #0          ; only care about carry
.8b7a	85 01		sta $01		                sta cp+1        ; fall through to _compile_do
.8b7c					_compile_do:
.8b7c	a0 24		ldy #$24	                ldy #do_runtime_end-do_runtime  ; counter
.8b7e	5a		phy		                phy             ; save counter to calculate new CP
.8b7f					-
.8b7f	b9 9e 8b	lda $8b9e,y	                lda do_runtime,y
.8b82	91 00		sta ($00),y	                sta (cp),y
.8b84	88		dey		                dey
.8b85	10 f8		bpl $8b7f	                bpl -
.8b87	68		pla		                pla             ; retrieve counter
.8b88	18		clc		                clc
.8b89	65 00		adc $00		                adc cp
.8b8b	85 00		sta $00		                sta cp
.8b8d	a5 01		lda $01		                lda cp+1
.8b8f	69 00		adc #$00	                adc #0          ; only care about carry
.8b91	85 01		sta $01		                sta cp+1
.8b93	ca		dex		                dex
.8b94	ca		dex		                dex
.8b95	a5 00		lda $00		                lda CP          ; LSB
.8b97	95 00		sta $00,x	                sta 0,x
.8b99	a5 01		lda $01		                lda CP+1        ; MSB
.8b9b	95 01		sta $01,x	                sta 1,x
.8b9d					z_question_do:
.8b9d	60		rts		z_do:           rts
.8b9e					do_runtime:
.8b9e	38		sec		                sec
.8b9f	a9 00		lda #$00	                lda #0
.8ba1	f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8ba3	95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8ba5	a9 80		lda #$80	                lda #$80
.8ba7	f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8ba9	95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8bab	48		pha		                pha             ; FUFA replaces limit on R stack
.8bac	b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8bae	48		pha		                pha
.8baf	18		clc		                clc
.8bb0	b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8bb2	75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8bb4	95 00		sta $00,x	                sta 0,x
.8bb6	b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8bb8	75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8bba	48		pha		                pha
.8bbb	b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8bbd	48		pha		                pha
.8bbe	e8		inx		                inx
.8bbf	e8		inx		                inx
.8bc0	e8		inx		                inx
.8bc1	e8		inx		                inx             ; no RTS because this is copied into code
.8bc2					do_runtime_end:
.8bc2					question_do_runtime:
.8bc2	20 6a a3	jsr $a36a	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8bc5	20 af 8e	jsr $8eaf	                jsr xt_equal            ; ( -- n1 n2 f )
.8bc8	b5 00		lda $00,x	                lda 0,x
.8bca	15 01		ora $01,x	                ora 1,x
.8bcc	f0 06		beq $8bd4	                beq _do_do
.8bce	8a		txa		                txa
.8bcf	18		clc		                clc
.8bd0	69 06		adc #$06	                adc #6
.8bd2	aa		tax		                tax
.8bd3	60		rts		                rts
.8bd4					_do_do:
.8bd4	e8		inx		                inx             ; clear flag from EQUAL off stack
.8bd5	e8		inx		                inx             ; no RTS because this is copied into code
.8bd6					question_do_runtime_end:
.8bd6					xt_does:
.8bd6	a0 8b		ldy #$8b	                ldy #>does_runtime
.8bd8	a9 e5		lda #$e5	                lda #<does_runtime
.8bda	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.8bdd	a0 d6		ldy #$d6	                ldy #>dodoes
.8bdf	a9 df		lda #$df	                lda #<dodoes
.8be1	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.8be4	60		rts		z_does:         rts
.8be5					does_runtime:
.8be5	7a		ply		                ply             ; LSB
.8be6	68		pla		                pla             ; MSB
.8be7	c8		iny		                iny
.8be8	d0 01		bne $8beb	                bne +
.8bea	1a		inc a		                ina
.8beb					+
.8beb	84 24		sty $24		                sty tmp1
.8bed	85 25		sta $25		                sta tmp1+1
.8bef	20 38 d7	jsr $d738	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8bf2	a5 02		lda $02		                lda dp
.8bf4	18		clc		                clc
.8bf5	69 04		adc #$04	                adc #4
.8bf7	85 26		sta $26		                sta tmp2
.8bf9	a5 03		lda $03		                lda dp+1
.8bfb	69 00		adc #$00	                adc #0          ; we only care about the carry
.8bfd	85 27		sta $27		                sta tmp2+1
.8bff	b2 26		lda ($26)	                lda (tmp2)
.8c01	18		clc		                clc
.8c02	69 01		adc #$01	                adc #1
.8c04	85 28		sta $28		                sta tmp3
.8c06	a0 01		ldy #$01	                ldy #1
.8c08	b1 26		lda ($26),y	                lda (tmp2),y
.8c0a	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c0c	85 29		sta $29		                sta tmp3+1
.8c0e	a5 24		lda $24		                lda tmp1        ; LSB
.8c10	92 28		sta ($28)	                sta (tmp3)
.8c12	a5 25		lda $25		                lda tmp1+1
.8c14	91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8c16	60		rts		                rts
.8c17					xt_dot:
.8c17	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8c1a	20 90 8d	jsr $8d90	                jsr xt_dup                      ; ( n n )
.8c1d	20 1a 81	jsr $811a	                jsr xt_abs                      ; ( n u )
.8c20	20 5a a7	jsr $a75a	                jsr xt_zero                     ; ( n u 0 )
.8c23	20 3b 93	jsr $933b	                jsr xt_less_number_sign         ; ( n u 0 )
.8c26	20 bf 97	jsr $97bf	                jsr xt_number_sign_s            ; ( n ud )
.8c29	20 38 9b	jsr $9b38	                jsr xt_rot                      ; ( ud n )
.8c2c	20 99 9f	jsr $9f99	                jsr xt_sign                     ; ( ud )
.8c2f	20 9d 97	jsr $979d	                jsr xt_number_sign_greater      ; ( addr u )
.8c32	20 b5 a4	jsr $a4b5	                jsr xt_type
.8c35	20 d0 a0	jsr $a0d0	                jsr xt_space
.8c38	60		rts		z_dot:          rts
.8c39					xt_dot_paren:
.8c39	ca		dex		                dex
.8c3a	ca		dex		                dex
.8c3b	a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c3d	95 00		sta $00,x	                sta 0,x
.8c3f	74 01		stz $01,x	                stz 1,x
.8c41	20 1b 99	jsr $991b	                jsr xt_parse
.8c44	20 b5 a4	jsr $a4b5	                jsr xt_type
.8c47	60		rts		z_dot_paren:    rts
.8c48					xt_dot_quote:
.8c48	20 30 9d	jsr $9d30	                jsr xt_s_quote
.8c4b	a0 a4		ldy #$a4	                ldy #>xt_type
.8c4d	a9 b5		lda #$b5	                lda #<xt_type
.8c4f	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.8c52	60		rts		z_dot_quote:    rts
.8c53					xt_dot_r:
.8c53	20 fb d7	jsr $d7fb	                jsr underflow_2
.8c56	20 22 a3	jsr $a322	                jsr xt_to_r
.8c59	20 90 8d	jsr $8d90	                jsr xt_dup
.8c5c	20 1a 81	jsr $811a	                jsr xt_abs
.8c5f	20 5a a7	jsr $a75a	                jsr xt_zero
.8c62	20 3b 93	jsr $933b	                jsr xt_less_number_sign
.8c65	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.8c68	20 38 9b	jsr $9b38	                jsr xt_rot
.8c6b	20 99 9f	jsr $9f99	                jsr xt_sign
.8c6e	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.8c71	20 73 9a	jsr $9a73	                jsr xt_r_from
.8c74	20 74 98	jsr $9874	                jsr xt_over
.8c77	20 31 95	jsr $9531	                jsr xt_minus
.8c7a	20 d6 a0	jsr $a0d6	                jsr xt_spaces
.8c7d	20 b5 a4	jsr $a4b5	                jsr xt_type
.8c80	60		rts		z_dot_r:        rts
.8c81					xt_dot_s:
.8c81	20 d7 8a	jsr $8ad7	                jsr xt_depth    ; ( -- u )
.8c84	a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8c86	20 d7 8d	jsr $8dd7	                jsr emit_a
.8c89	b5 00		lda $00,x	                lda 0,x
.8c8b	48		pha		                pha
.8c8c	ca		dex		                dex             ; DUP
.8c8d	ca		dex		                dex
.8c8e	95 00		sta $00,x	                sta 0,x
.8c90	74 01		stz $01,x	                stz 1,x
.8c92	20 63 d8	jsr $d863	                jsr print_u
.8c95	a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8c97	20 d7 8d	jsr $8dd7	                jsr emit_a
.8c9a	a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8c9c	20 d7 8d	jsr $8dd7	                jsr emit_a
.8c9f	e8		inx		                inx
.8ca0	e8		inx		                inx
.8ca1	e0 78		cpx #$78	                cpx #dsp0
.8ca3	f0 1e		beq $8cc3	                beq _done
.8ca5					_have_stack:
.8ca5	7a		ply		                ply
.8ca6	a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8ca8	85 28		sta $28		                sta tmp3
.8caa	64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8cac					_loop:
.8cac	ca		dex		                dex
.8cad	ca		dex		                dex
.8cae	b2 28		lda ($28)	                lda (tmp3)
.8cb0	95 01		sta $01,x	                sta 1,x
.8cb2	c6 28		dec $28		                dec tmp3
.8cb4	b2 28		lda ($28)	                lda (tmp3)
.8cb6	95 00		sta $00,x	                sta 0,x
.8cb8	c6 28		dec $28		                dec tmp3
.8cba	5a		phy		                phy
.8cbb	20 17 8c	jsr $8c17	                jsr xt_dot
.8cbe	7a		ply		                ply
.8cbf	88		dey		                dey
.8cc0	d0 ea		bne $8cac	                bne _loop
.8cc2	48		pha		                pha             ; dummy to balance stack
.8cc3					_done:
.8cc3	68		pla		                pla
.8cc4	60		rts		z_dot_s:        rts
.8cc5					xt_d_dot:
.8cc5	20 fb d7	jsr $d7fb	                jsr underflow_2
.8cc8	20 3f a3	jsr $a33f	                jsr xt_tuck
.8ccb	20 67 8a	jsr $8a67	                jsr xt_dabs
.8cce	20 3b 93	jsr $933b	                jsr xt_less_number_sign
.8cd1	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.8cd4	20 38 9b	jsr $9b38	                jsr xt_rot
.8cd7	20 99 9f	jsr $9f99	                jsr xt_sign
.8cda	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.8cdd	20 b5 a4	jsr $a4b5	                jsr xt_type
.8ce0	20 d0 a0	jsr $a0d0	                jsr xt_space
.8ce3	60		rts		z_d_dot:        rts
.8ce4					xt_d_dot_r:
.8ce4	20 00 d8	jsr $d800	                jsr underflow_3
.8ce7	20 22 a3	jsr $a322	                jsr xt_to_r
.8cea	20 3f a3	jsr $a33f	                jsr xt_tuck
.8ced	20 67 8a	jsr $8a67	                jsr xt_dabs
.8cf0	20 3b 93	jsr $933b	                jsr xt_less_number_sign
.8cf3	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.8cf6	20 38 9b	jsr $9b38	                jsr xt_rot
.8cf9	20 99 9f	jsr $9f99	                jsr xt_sign
.8cfc	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.8cff	20 73 9a	jsr $9a73	                jsr xt_r_from
.8d02	20 74 98	jsr $9874	                jsr xt_over
.8d05	20 31 95	jsr $9531	                jsr xt_minus
.8d08	20 d6 a0	jsr $a0d6	                jsr xt_spaces
.8d0b	20 b5 a4	jsr $a4b5	                jsr xt_type
.8d0e	60		rts		z_d_dot_r:      rts
.8d0f					xt_drop:
.8d0f	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8d12	e8		inx		                inx
.8d13	e8		inx		                inx
.8d14	60		rts		z_drop:         rts
.8d15					xt_dump:
.8d15	20 fb d7	jsr $d7fb	                jsr underflow_2
.8d18					_row:
.8d18	a0 10		ldy #$10	                ldy #16
.8d1a	64 26		stz $26		                stz tmp2
.8d1c	20 44 89	jsr $8944	                jsr xt_cr
.8d1f	b5 03		lda $03,x	                lda 3,x
.8d21	20 06 d7	jsr $d706	                jsr byte_to_ascii
.8d24	b5 02		lda $02,x	                lda 2,x
.8d26	20 06 d7	jsr $d706	                jsr byte_to_ascii
.8d29	20 d0 a0	jsr $a0d0	                jsr xt_space
.8d2c	20 d0 a0	jsr $a0d0	                jsr xt_space
.8d2f					_loop:
.8d2f	b5 00		lda $00,x	                lda 0,x
.8d31	15 01		ora $01,x	                ora 1,x
.8d33	f0 39		beq $8d6e	                beq _all_printed
.8d35	a1 02		lda ($02,x)	                lda (2,x)
.8d37	48		pha		                pha                     ; byte_to_ascii destroys A
.8d38	20 06 d7	jsr $d706	                jsr byte_to_ascii
.8d3b	20 d0 a0	jsr $a0d0	                jsr xt_space
.8d3e	68		pla		                pla
.8d3f	20 dc d7	jsr $d7dc	                jsr is_printable
.8d42	b0 02		bcs $8d46	                bcs _printable
.8d44	a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d46					_printable:
.8d46	5a		phy		                phy                     ; save counter
.8d47	a4 26		ldy $26		                ldy tmp2
.8d49	91 00		sta ($00),y	                sta (cp),y
.8d4b	e6 26		inc $26		                inc tmp2
.8d4d	7a		ply		                ply
.8d4e	c0 09		cpy #$09	                cpy #9
.8d50	d0 03		bne $8d55	                bne _next_char
.8d52	20 d0 a0	jsr $a0d0	                jsr xt_space
.8d55					_next_char:
.8d55	f6 02		inc $02,x	                inc 2,x
.8d57	d0 02		bne $8d5b	                bne _counter
.8d59	f6 03		inc $03,x	                inc 3,x
.8d5b					_counter:
.8d5b	b5 00		lda $00,x	                lda 0,x
.8d5d	d0 02		bne $8d61	                bne +
.8d5f	d6 01		dec $01,x	                dec 1,x
.8d61					+
.8d61	d6 00		dec $00,x	                dec 0,x
.8d63	88		dey		                dey
.8d64	d0 c9		bne $8d2f	                bne _loop               ; next byte
.8d66	20 d0 a0	jsr $a0d0	                jsr xt_space
.8d69	20 7c 8d	jsr $8d7c	                jsr dump_print_ascii
.8d6c	80 aa		bra $8d18	                bra _row                ; new row
.8d6e					_all_printed:
.8d6e	a5 26		lda $26		                lda tmp2
.8d70	f0 06		beq $8d78	                beq _done
.8d72	20 d0 a0	jsr $a0d0	                jsr xt_space
.8d75	20 7c 8d	jsr $8d7c	                jsr dump_print_ascii
.8d78					_done:
.8d78	20 62 a3	jsr $a362	                jsr xt_two_drop         ; one byte less than 4x INX
.8d7b	60		rts		z_dump:         rts
.8d7c					dump_print_ascii:
.8d7c	a0 00		ldy #$00	                ldy #0
.8d7e					_ascii_loop:
.8d7e	b1 00		lda ($00),y	                lda (cp),y
.8d80	20 d7 8d	jsr $8dd7	                jsr emit_a
.8d83	c8		iny		                iny
.8d84	c0 08		cpy #$08	                cpy #8
.8d86	d0 03		bne $8d8b	                bne +
.8d88	20 d0 a0	jsr $a0d0	                jsr xt_space
.8d8b					+
.8d8b	c6 26		dec $26		                dec tmp2
.8d8d	d0 ef		bne $8d7e	                bne _ascii_loop
.8d8f	60		rts		                rts
.8d90					xt_dup:
.8d90	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8d93	ca		dex		                dex
.8d94	ca		dex		                dex
.8d95	b5 02		lda $02,x	                lda 2,x         ; LSB
.8d97	95 00		sta $00,x	                sta 0,x
.8d99	b5 03		lda $03,x	                lda 3,x         ; MSB
.8d9b	95 01		sta $01,x	                sta 1,x
.8d9d	60		rts		z_dup:          rts
.8d9e					xt_ed:
.8d9e	20 34 b5	jsr $b534	                jsr ed6502      ; kept in separate file
.8da1	60		rts		z_ed:           rts
.8da2					xt_else:
.8da2					xt_endof:
.8da2	a0 8d		ldy #$8d	                ldy #>branch_runtime
.8da4	a9 bc		lda #$bc	                lda #<branch_runtime
.8da6	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.8da9	20 53 91	jsr $9153	                jsr xt_here
.8dac	20 5a a7	jsr $a75a	                jsr xt_zero
.8daf	20 4f 87	jsr $874f	                jsr xt_comma
.8db2	20 53 91	jsr $9153	                jsr xt_here
.8db5	20 38 9b	jsr $9b38	                jsr xt_rot
.8db8	20 3f a1	jsr $a13f	                jsr xt_store
.8dbb					z_else:
.8dbb					z_endof:
.8dbb	60		rts		                rts
.8dbc					branch_runtime:
.8dbc	68		pla		                pla
.8dbd	85 22		sta $22		                sta tmpbranch
.8dbf	68		pla		                pla
.8dc0	85 23		sta $23		                sta tmpbranch+1
.8dc2	a0 01		ldy #$01	                ldy #1
.8dc4	b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8dc6	85 24		sta $24		                sta tmp1
.8dc8	c8		iny		                iny
.8dc9	b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8dcb	85 25		sta $25		                sta tmp1+1
.8dcd	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8dd0					xt_emit:
.8dd0	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8dd3	b5 00		lda $00,x	                lda 0,x
.8dd5	e8		inx		                inx
.8dd6	e8		inx		                inx
.8dd7					emit_a:
.8dd7	6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8dda					z_emit:
.8dda					xt_empty_buffers:
.8dda	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8ddc	a9 00		lda #$00	                lda #0
.8dde	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8de0					z_empty_buffers:
.8de0	60		rts		                rts
.8de1					xt_endcase:
.8de1	a0 8d		ldy #$8d	                ldy #>xt_drop
.8de3	a9 0f		lda #$0f	                lda #<xt_drop
.8de5	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.8de8					_endcase_loop:
.8de8	b5 00		lda $00,x	                lda 0,x
.8dea	15 01		ora $01,x	                ora 1,x
.8dec	f0 05		beq $8df3	                beq _done
.8dee	20 74 a1	jsr $a174	                jsr xt_then
.8df1	80 f5		bra $8de8	                bra _endcase_loop
.8df3					_done:
.8df3	e8		inx		                inx
.8df4	e8		inx		                inx
.8df5	60		rts		z_endcase:      rts
.8df6					xt_environment_q:
.8df6	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8df9	a0 00		ldy #$00	                ldy #00                 ; counter for table
.8dfb	5a		phy		                phy
.8dfc					_table_loop:
.8dfc	20 6a a3	jsr $a36a	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8dff	ca		dex		                dex
.8e00	ca		dex		                dex                     ; ( addr u addr u ? )
.8e01	b9 73 8e	lda $8e73,y	                lda env_table_single,y
.8e04	95 00		sta $00,x	                sta 0,x
.8e06	c8		iny		                iny
.8e07	b9 73 8e	lda $8e73,y	                lda env_table_single,y
.8e0a	95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e0c	c8		iny		                iny
.8e0d	15 00		ora $00,x	                ora 0,x
.8e0f	f0 4d		beq $8e5e	                beq _table_done
.8e11	5a		phy		                phy                     ; save Y, which is used by COUNT
.8e12	20 30 89	jsr $8930	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e15	20 69 87	jsr $8769	                jsr xt_compare          ; ( addr u f )
.8e18	7a		ply		                ply
.8e19	b5 00		lda $00,x	                lda 0,x
.8e1b	15 01		ora $01,x	                ora 1,x
.8e1d	f0 04		beq $8e23	                beq _got_result
.8e1f	e8		inx		                inx                     ; DROP, now ( addr u )
.8e20	e8		inx		                inx
.8e21	80 d9		bra $8dfc	                bra _table_loop
.8e23					_got_result:
.8e23	e8		inx		                inx                     ; drop flag, now ( addr u )
.8e24	e8		inx		                inx
.8e25	88		dey		                dey                     ; go back to index we had
.8e26	88		dey		                dey
.8e27	68		pla		                pla
.8e28	d0 0d		bne $8e37	                bne _double_result
.8e2a	b9 91 8e	lda $8e91,y	                lda env_results_single,y
.8e2d	95 02		sta $02,x	                sta 2,x
.8e2f	c8		iny		                iny
.8e30	b9 91 8e	lda $8e91,y	                lda env_results_single,y
.8e33	95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e35	80 1f		bra $8e56	                bra _set_flag
.8e37					_double_result:
.8e37	ca		dex		                dex                     ; ( addr u ? )
.8e38	ca		dex		                dex
.8e39	98		tya		                tya
.8e3a	38		sec		                sec
.8e3b	e9 18		sbc #$18	                sbc #24
.8e3d	0a		asl a		                asl
.8e3e	a8		tay		                tay
.8e3f	b9 a7 8e	lda $8ea7,y	                lda env_results_double,y
.8e42	95 02		sta $02,x	                sta 2,x
.8e44	c8		iny		                iny
.8e45	b9 a7 8e	lda $8ea7,y	                lda env_results_double,y
.8e48	95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e4a	c8		iny		                iny
.8e4b	b9 a7 8e	lda $8ea7,y	                lda env_results_double,y
.8e4e	95 04		sta $04,x	                sta 4,x
.8e50	c8		iny		                iny
.8e51	b9 a7 8e	lda $8ea7,y	                lda env_results_double,y
.8e54	95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e56					_set_flag:
.8e56	a9 ff		lda #$ff	                lda #$ff
.8e58	95 00		sta $00,x	                sta 0,x
.8e5a	95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e5c	80 14		bra $8e72	                bra _done
.8e5e					_table_done:
.8e5e	68		pla		                pla
.8e5f	d0 09		bne $8e6a	                bne _no_match
.8e61	1a		inc a		                ina
.8e62	48		pha		                pha
.8e63	8a		txa		                txa
.8e64	18		clc		                clc
.8e65	69 06		adc #$06	                adc #6                  ; skip six bytes
.8e67	aa		tax		                tax                     ; ( addr u )
.8e68	80 92		bra $8dfc	                bra _table_loop
.8e6a					_no_match:
.8e6a	8a		txa		                txa
.8e6b	18		clc		                clc
.8e6c	69 0a		adc #$0a	                adc #10
.8e6e	aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e6f	20 5a 8f	jsr $8f5a	                jsr xt_false
.8e72					_done:
.8e72					z_environment_q:
.8e72	60		rts		                rts
.8e73					env_table_single:
>8e73	19 d6 29 d6 2f d6 34 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e7b	46 d6
>8e7d	4e d6 57 d6 5d d6 63 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e85	76 d6 82 d6 00 00		        .word envs_sc, envs_wl, 0000
.8e8b					env_table_double:
>8e8b	8c d6 92 d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8e91					env_results_single:
>8e91	ff 7f				        .word $7FFF     ; /COUNTED-STRING
>8e93	ff 00				        .word $00FF     ; /HOLD
>8e95	54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8e97	08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8e99	00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8e9b	ff 00				        .word $00FF     ; MAX-CHAR
>8e9d	ff 7f				        .word $7FFF     ; MAX-N
>8e9f	ff ff				        .word $FFFF     ; MAX-U
>8ea1	80 00				        .word $0080     ; RETURN-STACK-CELLS
>8ea3	20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8ea5	09 00				        .word $0009     ; WORDLISTS
.8ea7					env_results_double:
>8ea7	ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8eab	ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8eaf					xt_equal:
.8eaf	20 fb d7	jsr $d7fb	                jsr underflow_2
.8eb2	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8eb4	d5 02		cmp $02,x	                cmp 2,x
.8eb6	d0 0a		bne $8ec2	                bne _false
.8eb8	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8eba	d5 03		cmp $03,x	                cmp 3,x
.8ebc	d0 04		bne $8ec2	                bne _false
.8ebe	a9 ff		lda #$ff	                lda #$ff
.8ec0	80 02		bra $8ec4	                bra _done
.8ec2	a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8ec4	95 02		sta $02,x	_done:          sta 2,x
.8ec6	95 03		sta $03,x	                sta 3,x
.8ec8	e8		inx		                inx
.8ec9	e8		inx		                inx
.8eca	60		rts		z_equal:        rts
.8ecb					xt_blank:
.8ecb	ca		dex		                dex
.8ecc	ca		dex		                dex
.8ecd	a9 20		lda #$20	                lda #AscSP
.8ecf	95 00		sta $00,x	                sta 0,x
.8ed1	74 01		stz $01,x	                stz 1,x
.8ed3	80 06		bra $8edb	                bra xt_fill     ; skip over code for ERASE
.8ed5					xt_erase:
.8ed5	ca		dex		                dex
.8ed6	ca		dex		                dex
.8ed7	74 00		stz $00,x	                stz 0,x
.8ed9	74 01		stz $01,x	                stz 1,x
.8edb					xt_fill:
.8edb	20 00 d8	jsr $d800	                jsr underflow_3
.8ede	b5 04		lda $04,x	                lda 4,x         ; LSB
.8ee0	85 24		sta $24		                sta tmp1
.8ee2	b5 05		lda $05,x	                lda 5,x
.8ee4	85 25		sta $25		                sta tmp1+1
.8ee6	b5 02		lda $02,x	                lda 2,x
.8ee8	85 26		sta $26		                sta tmp2
.8eea	b5 03		lda $03,x	                lda 3,x
.8eec	85 27		sta $27		                sta tmp2+1
.8eee	b5 00		lda $00,x	                lda 0,x
.8ef0	a8		tay		                tay
.8ef1					_loop:
.8ef1	a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8ef3	c5 25		cmp $25		                cmp tmp1+1
.8ef5	90 21		bcc $8f18	                bcc _done               ; RAM_END < TMP1, so leave
.8ef7	d0 06		bne $8eff	                bne _check_counter      ; RAM_END is not smaller and not equal
.8ef9	a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8efb	c5 24		cmp $24		                cmp tmp1
.8efd	90 19		bcc $8f18	                bcc _done               ; RAM_END < TMP1, so leave
.8eff					_check_counter:
.8eff	a5 26		lda $26		                lda tmp2
.8f01	05 27		ora $27		                ora tmp2+1
.8f03	f0 13		beq $8f18	                beq _done
.8f05	98		tya		                tya
.8f06	92 24		sta ($24)	                sta (tmp1)
.8f08	a5 26		lda $26		                lda tmp2
.8f0a	d0 02		bne $8f0e	                bne +
.8f0c	c6 27		dec $27		                dec tmp2+1
.8f0e	c6 26		dec $26		+               dec tmp2
.8f10	e6 24		inc $24		                inc tmp1
.8f12	d0 dd		bne $8ef1	                bne _loop
.8f14	e6 25		inc $25		                inc tmp1+1
.8f16	80 d9		bra $8ef1	                bra _loop
.8f18					_done:
.8f18	8a		txa		                txa
.8f19	18		clc		                clc
.8f1a	69 06		adc #$06	                adc #6
.8f1c	aa		tax		                tax
.8f1d					z_blank:
.8f1d					z_erase:
.8f1d	60		rts		z_fill:         rts
.8f1e					xt_execute:
.8f1e	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8f21	20 25 8f	jsr $8f25	                jsr doexecute   ; do not combine to JMP (native coding)
.8f24	60		rts		z_execute:      rts
.8f25					doexecute:
.8f25	b5 00		lda $00,x	                lda 0,x
.8f27	85 0e		sta $0e		                sta ip
.8f29	b5 01		lda $01,x	                lda 1,x
.8f2b	85 0f		sta $0f		                sta ip+1
.8f2d	e8		inx		                inx
.8f2e	e8		inx		                inx
.8f2f	6c 0e 00	jmp ($000e)	                jmp (ip)
.8f32					xt_execute_parsing:
.8f32	20 00 d8	jsr $d800	                jsr underflow_3
.8f35	20 43 92	jsr $9243	                jsr xt_input_to_r       ; save normal input for later
.8f38	20 4f 96	jsr $964f	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f3b	b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f3d	85 0a		sta $0a		                sta ciblen
.8f3f	b5 01		lda $01,x	                lda 1,x
.8f41	85 0b		sta $0b		                sta ciblen+1
.8f43	b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f45	85 08		sta $08		                sta cib
.8f47	b5 03		lda $03,x	                lda 3,x
.8f49	85 09		sta $09		                sta cib+1
.8f4b	64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f4d	64 0d		stz $0d		                stz toin+1
.8f4f	20 62 a3	jsr $a362	                jsr xt_two_drop         ; 2DROP ( xt )
.8f52	20 1e 8f	jsr $8f1e	                jsr xt_execute
.8f55	20 84 9a	jsr $9a84	                jsr xt_r_to_input
.8f58					z_execute_parsing:
.8f58	60		rts		                rts
.8f59					xt_exit:
.8f59	60		rts		                rts             ; keep before z_exit
.8f5a					z_exit:
.8f5a					xt_false:
.8f5a	ca		dex		                dex
.8f5b	ca		dex		                dex
.8f5c	74 00		stz $00,x	                stz 0,x
.8f5e	74 01		stz $01,x	                stz 1,x
.8f60	60		rts		z_false:        rts
.8f61					xt_fetch:
.8f61	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8f64	a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f66	a8		tay		                tay
.8f67	f6 00		inc $00,x	                inc 0,x
.8f69	d0 02		bne $8f6d	                bne +
.8f6b	f6 01		inc $01,x	                inc 1,x
.8f6d					+
.8f6d	a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f6f	95 01		sta $01,x	                sta 1,x
.8f71	94 00		sty $00,x	                sty 0,x
.8f73	60		rts		z_fetch:        rts
.8f74					xt_find:
.8f74	20 f6 d7	jsr $d7f6	                jsr underflow_1
.8f77	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f79	48		pha		                pha
.8f7a	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f7c	48		pha		                pha
.8f7d	20 30 89	jsr $8930	                jsr xt_count            ; ( caddr -- addr u )
.8f80	20 bc 8f	jsr $8fbc	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f83	b5 00		lda $00,x	                lda 0,x
.8f85	15 01		ora $01,x	                ora 1,x
.8f87	d0 0b		bne $8f94	                bne _found_word
.8f89	20 5a 8f	jsr $8f5a	                jsr xt_false            ; ( 0 0 )
.8f8c	68		pla		                pla                     ; LSB of address
.8f8d	95 02		sta $02,x	                sta 2,x
.8f8f	68		pla		                pla
.8f90	95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8f92	80 27		bra $8fbb	                bra _done               ; ( addr 0 )
.8f94					_found_word:
.8f94	68		pla		                pla
.8f95	68		pla		                pla
.8f96	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( nt nt )
.8f99	20 c2 95	jsr $95c2	                jsr xt_name_to_int      ; ( nt xt )
.8f9c	20 60 a1	jsr $a160	                jsr xt_swap             ; ( xt nt )
.8f9f	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fa1	f6 00		inc $00,x	                inc 0,x
.8fa3	d0 02		bne $8fa7	                bne +
.8fa5	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fa7					+
.8fa7	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fa9	29 04		and #$04	                and #IM
.8fab	d0 08		bne $8fb5	                bne _immediate          ; bit set, we're immediate
.8fad	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8faf	95 00		sta $00,x	                sta 0,x
.8fb1	95 01		sta $01,x	                sta 1,x
.8fb3	80 06		bra $8fbb	                bra _done
.8fb5					_immediate:
.8fb5	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8fb7	95 00		sta $00,x	                sta 0,x
.8fb9	74 01		stz $01,x	                stz 1,x
.8fbb					_done:
.8fbb	60		rts		z_find:         rts
.8fbc					xt_find_name:
.8fbc	20 fb d7	jsr $d7fb	                jsr underflow_2
.8fbf	b5 00		lda $00,x	                lda 0,x
.8fc1	15 01		ora $01,x	                ora 1,x
.8fc3	d0 03		bne $8fc8	                bne _nonempty
.8fc5	4c 61 90	jmp $9061	                jmp _fail_done
.8fc8					_nonempty:
.8fc8	64 28		stz $28		                stz tmp3                ; Start at the beginning
.8fca					_wordlist_loop:
.8fca	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8fcc	a5 28		lda $28		                lda tmp3
.8fce	d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8fd0	d0 03		bne $8fd5	                bne _have_string
.8fd2	4c 61 90	jmp $9061	                jmp _fail_done
.8fd5					_have_string:
.8fd5	18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8fd6	69 1f		adc #$1f	                adc #search_order_offset
.8fd8	a8		tay		                tay
.8fd9	b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.8fdb	0a		asl a		                asl                     ; Turn offset into cells offset.
.8fdc	18		clc		                clc
.8fdd	69 06		adc #$06	                adc #wordlists_offset
.8fdf	a8		tay		                tay
.8fe0	b1 1e		lda ($1e),y	                lda (up),y
.8fe2	85 24		sta $24		                sta tmp1
.8fe4	c8		iny		                iny
.8fe5	b1 1e		lda ($1e),y	                lda (up),y
.8fe7	85 25		sta $25		                sta tmp1+1
.8fe9	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.8feb	85 26		sta $26		                sta tmp2
.8fed	b5 03		lda $03,x	                lda 3,x
.8fef	85 27		sta $27		                sta tmp2+1
.8ff1					_loop:
.8ff1	b2 24		lda ($24)	                lda (tmp1)
.8ff3	d5 00		cmp $00,x	                cmp 0,x
.8ff5	d0 54		bne $904b	                bne _next_entry
.8ff7					_compare_string:
.8ff7	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.8ff9	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.8ffb	b0 07		bcs $9004	                bcs _compare_first
.8ffd	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8fff	90 03		bcc $9004	                bcc _compare_first
.9001	18		clc		                clc
.9002	69 20		adc #$20	                adc #$20
.9004					_compare_first:
.9004	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9006	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9008	d0 41		bne $904b	                bne _next_entry
.900a	b5 00		lda $00,x	                lda 0,x
.900c	3a		dec a		                dea
.900d	f0 2c		beq $903b	                beq _success
.900f	a5 24		lda $24		                lda tmp1
.9011	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9012	18		clc		                clc
.9013	69 08		adc #$08	                adc #8
.9015	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9017	a5 25		lda $25		                lda tmp1+1
.9019	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.901a	69 00		adc #$00	                adc #0          ; we only need the carry
.901c	85 25		sta $25		                sta tmp1+1
.901e	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9020	88		dey		                dey
.9021					_string_loop:
.9021	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9023	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9025	b0 07		bcs $902e	                bcs _check_char
.9027	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9029	90 03		bcc $902e	                bcc _check_char
.902b	18		clc		                clc
.902c	69 20		adc #$20	                adc #$20
.902e					_check_char:
.902e	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9030	d0 13		bne $9045	                bne _next_entry_tmp1
.9032	88		dey		                dey
.9033	d0 ec		bne $9021	                bne _string_loop
.9035					_success_tmp1:
.9035	68		pla		                pla             ; Restore tmp1 from the return stack.
.9036	85 25		sta $25		                sta tmp1+1
.9038	68		pla		                pla
.9039	85 24		sta $24		                sta tmp1
.903b					_success:
.903b	a5 24		lda $24		                lda tmp1
.903d	95 02		sta $02,x	                sta 2,x
.903f	a5 25		lda $25		                lda tmp1+1
.9041	95 03		sta $03,x	                sta 3,x
.9043	80 20		bra $9065	                bra _done
.9045					_next_entry_tmp1:
.9045	68		pla		                pla             ; Restore tmp1 from the return stack.
.9046	85 25		sta $25		                sta tmp1+1
.9048	68		pla		                pla
.9049	85 24		sta $24		                sta tmp1
.904b					_next_entry:
.904b	a0 02		ldy #$02	                ldy #2
.904d	b1 24		lda ($24),y	                lda (tmp1),y
.904f	48		pha		                pha
.9050	c8		iny		                iny
.9051	b1 24		lda ($24),y	                lda (tmp1),y
.9053	85 25		sta $25		                sta tmp1+1
.9055	68		pla		                pla
.9056	85 24		sta $24		                sta tmp1
.9058	05 25		ora $25		                ora tmp1+1
.905a	d0 95		bne $8ff1	                bne _loop
.905c	e6 28		inc $28		                inc tmp3
.905e	4c ca 8f	jmp $8fca	                jmp _wordlist_loop
.9061					_fail_done:
.9061	74 02		stz $02,x	                stz 2,x         ; failure flag
.9063	74 03		stz $03,x	                stz 3,x
.9065					_done:
.9065	e8		inx		                inx
.9066	e8		inx		                inx
.9067	60		rts		z_find_name:    rts
.9068					xt_flush:
.9068	20 70 9e	jsr $9e70	                jsr xt_save_buffers
.906b	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.906d	a9 00		lda #$00	                lda #0
.906f	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.9071					z_flush:
.9071	60		rts		                rts
.9072					xt_fm_slash_mod:
.9072	20 00 d8	jsr $d800	                jsr underflow_3
.9075	64 26		stz $26		                stz tmp2        ; default: n is positive
.9077	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9079	10 0e		bpl $9089	                bpl _check_d
.907b	e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.907d	20 04 96	jsr $9604	                jsr xt_negate   ; NEGATE
.9080	20 22 a3	jsr $a322	                jsr xt_to_r     ; >R
.9083	20 22 8b	jsr $8b22	                jsr xt_dnegate  ; DNEGATE
.9086	20 73 9a	jsr $9a73	                jsr xt_r_from   ; R>
.9089					_check_d:
.9089	b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.908b	10 0d		bpl $909a	                bpl _multiply
.908d	18		clc		                clc
.908e	b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.9090	75 02		adc $02,x	                adc 2,x         ; LSB of dh
.9092	95 02		sta $02,x	                sta 2,x
.9094	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9096	75 03		adc $03,x	                adc 3,x         ; MSB of dh
.9098	95 03		sta $03,x	                sta 3,x
.909a					_multiply:
.909a	20 6c a5	jsr $a56c	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.909d	a5 26		lda $26		                lda tmp2
.909f	f0 07		beq $90a8	                beq _done
.90a1	e8		inx		                inx             ; pretend that we SWAP
.90a2	e8		inx		                inx
.90a3	20 04 96	jsr $9604	                jsr xt_negate
.90a6	ca		dex		                dex
.90a7	ca		dex		                dex
.90a8					_done:
.90a8	60		rts		z_fm_slash_mod: rts
.90a9					xt_forth:
.90a9	a0 1f		ldy #$1f	                ldy #search_order_offset
.90ab	a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90ad	91 1e		sta ($1e),y	                sta (up),y
.90af					z_forth:
.90af	60		rts		                rts
.90b0					load_evaluate:
.90b0	a9 ff		lda #$ff	                lda #$FF
.90b2	85 24		sta $24		                sta tmp1
.90b4	80 11		bra $90c7	                bra load_evaluate_start
.90b6					xt_evaluate:
.90b6	20 fb d7	jsr $d7fb	                jsr underflow_2
.90b9	64 24		stz $24		                stz tmp1
.90bb	b5 00		lda $00,x	                lda 0,x
.90bd	15 01		ora $01,x	                ora 1,x
.90bf	d0 06		bne $90c7	                bne evaluate_got_work
.90c1	e8		inx		                inx
.90c2	e8		inx		                inx
.90c3	e8		inx		                inx
.90c4	e8		inx		                inx
.90c5	80 42		bra $9109	                bra evaluate_done
.90c7					load_evaluate_start:
.90c7					evaluate_got_work:
.90c7	a0 01		ldy #$01	                ldy #blk_offset+1
.90c9	b1 1e		lda ($1e),y	                lda (up),y
.90cb	48		pha		                pha
.90cc	88		dey		                dey
.90cd	b1 1e		lda ($1e),y	                lda (up),y
.90cf	48		pha		                pha
.90d0	a5 24		lda $24		                lda tmp1
.90d2	d0 05		bne $90d9	                bne _nozero
.90d4	91 1e		sta ($1e),y	                sta (up),y
.90d6	c8		iny		                iny
.90d7	91 1e		sta ($1e),y	                sta (up),y
.90d9					_nozero:
.90d9	20 43 92	jsr $9243	                jsr xt_input_to_r
.90dc	a9 ff		lda #$ff	                lda #$ff
.90de	85 06		sta $06		                sta insrc
.90e0	85 07		sta $07		                sta insrc+1
.90e2	64 0c		stz $0c		                stz toin
.90e4	64 0d		stz $0d		                stz toin+1
.90e6	b5 00		lda $00,x	                lda 0,x
.90e8	85 0a		sta $0a		                sta ciblen
.90ea	b5 01		lda $01,x	                lda 1,x
.90ec	85 0b		sta $0b		                sta ciblen+1
.90ee	b5 02		lda $02,x	                lda 2,x
.90f0	85 08		sta $08		                sta cib
.90f2	b5 03		lda $03,x	                lda 3,x
.90f4	85 09		sta $09		                sta cib+1
.90f6	e8		inx		                inx             ; A clean stack is a clean mind
.90f7	e8		inx		                inx
.90f8	e8		inx		                inx
.90f9	e8		inx		                inx
.90fa	20 5e d7	jsr $d75e	                jsr interpret   ; ( -- )
.90fd	20 84 9a	jsr $9a84	                jsr xt_r_to_input
.9100	a0 00		ldy #$00	                ldy #blk_offset
.9102	68		pla		                pla
.9103	91 1e		sta ($1e),y	                sta (up),y
.9105	c8		iny		                iny
.9106	68		pla		                pla
.9107	91 1e		sta ($1e),y	                sta (up),y
.9109					evaluate_done:
.9109	60		rts		z_evaluate:     rts
.910a					xt_get_current:
.910a	ca		dex		                dex
.910b	ca		dex		                dex
.910c	a0 04		ldy #$04	                ldy #current_offset
.910e	b1 1e		lda ($1e),y	                lda (up),y
.9110	95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.9112	74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.9114	60		rts		z_get_current:  rts
.9115					xt_get_order:
.9115	a0 1e		ldy #$1e	                ldy #num_order_offset
.9117	b1 1e		lda ($1e),y	                lda (up),y
.9119	85 24		sta $24		                sta tmp1
.911b	f0 16		beq $9133	                beq _done       ; If zero, there are no wordlists.
.911d					_loop:
.911d	c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.911f	a9 1f		lda #$1f	                lda #search_order_offset
.9121	18		clc		                clc
.9122	65 24		adc $24		                adc tmp1
.9124	a8		tay		                tay
.9125	ca		dex		                dex
.9126	ca		dex		                dex
.9127	b1 1e		lda ($1e),y	                lda (up),y
.9129	95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.912b	74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.912d	a9 00		lda #$00	                lda #0
.912f	c5 24		cmp $24		                cmp tmp1
.9131	d0 ea		bne $911d	                bne _loop
.9133					_done:
.9133	ca		dex		                dex
.9134	ca		dex		                dex
.9135	a0 1e		ldy #$1e	                ldy #num_order_offset
.9137	b1 1e		lda ($1e),y	                lda (up),y
.9139	95 00		sta $00,x	                sta 0,x
.913b	74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.913d	60		rts		z_get_order:    rts
.913e					xt_greater_than:
.913e	20 fb d7	jsr $d7fb	                jsr underflow_2
.9141	a0 00		ldy #$00	                ldy #0          ; default false
.9143	20 1d d7	jsr $d71d	                jsr compare_16bit
.9146	f0 03		beq $914b	                beq _false
.9148	10 01		bpl $914b	                bpl _false
.914a	88		dey		                dey
.914b					_false:
.914b	98		tya		                tya
.914c	e8		inx		                inx
.914d	e8		inx		                inx
.914e	95 00		sta $00,x	                sta 0,x
.9150	95 01		sta $01,x	                sta 1,x
.9152	60		rts		z_greater_than: rts
.9153					xt_here:
.9153					xt_asm_arrow:
.9153	ca		dex		                dex
.9154	ca		dex		                dex
.9155	a5 00		lda $00		                lda cp
.9157	95 00		sta $00,x	                sta 0,x
.9159	a5 01		lda $01		                lda cp+1
.915b	95 01		sta $01,x	                sta 1,x
.915d					z_asm_arrow:
.915d	60		rts		z_here:         rts
.915e					xt_hex:
.915e	a9 10		lda #$10	                lda #16
.9160	85 18		sta $18		                sta base
.9162	64 19		stz $19		                stz base+1              ; paranoid
.9164	60		rts		z_hex:          rts
.9165					xt_hexstore:
.9165	20 00 d8	jsr $d800	                jsr underflow_3
.9168	20 90 8d	jsr $8d90	                jsr xt_dup              ; Save copy of original address
.916b	20 54 a4	jsr $a454	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.916e					_loop:
.916e	b5 00		lda $00,x	                lda 0,x
.9170	15 01		ora $01,x	                ora 1,x
.9172	f0 36		beq $91aa	                beq _done
.9174	20 2d 86	jsr $862d	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9177	20 54 a4	jsr $a454	                jsr xt_two_to_r
.917a	20 5a a7	jsr $a75a	                jsr xt_zero
.917d	20 5a a7	jsr $a75a	                jsr xt_zero
.9180	20 da a3	jsr $a3da	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9183	20 6f a2	jsr $a26f	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9186	b5 00		lda $00,x	                lda 0,x
.9188	15 01		ora $01,x	                ora 1,x
.918a	d0 17		bne $91a3	                bne _have_chars_left
.918c	20 62 a3	jsr $a362	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.918f	20 61 8a	jsr $8a61	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9192	20 5e 9a	jsr $9a5e	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9195	20 f6 85	jsr $85f6	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9198	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R>
.919b	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+
.919e	20 22 a3	jsr $a322	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91a1	80 cb		bra $916e	                bra _loop
.91a3					_have_chars_left:
.91a3	8a		txa		                txa
.91a4	18		clc		                clc
.91a5	69 08		adc #$08	                adc #8
.91a7	aa		tax		                tax
.91a8	80 c4		bra $916e	                bra _loop
.91aa					_done:
.91aa	e8		inx		                inx
.91ab	e8		inx		                inx
.91ac	e8		inx		                inx
.91ad	e8		inx		                inx                     ; 2DROP
.91ae	20 da a3	jsr $a3da	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91b1	20 60 a1	jsr $a160	                jsr xt_swap
.91b4	20 31 95	jsr $9531	                jsr xt_minus            ; ( n )
.91b7	60		rts		z_hexstore:     rts
.91b8					xt_hold:
.91b8	20 f6 d7	jsr $d7f6	                jsr underflow_1
.91bb	a5 34		lda $34		                lda tohold
.91bd	d0 02		bne $91c1	                bne +
.91bf	c6 35		dec $35		                dec tohold+1
.91c1					+
.91c1	c6 34		dec $34		                dec tohold
.91c3	b5 00		lda $00,x	                lda 0,x
.91c5	92 34		sta ($34)	                sta (tohold)
.91c7	e8		inx		                inx
.91c8	e8		inx		                inx
.91c9	60		rts		z_hold:         rts
.91ca					xt_i:
.91ca	ca		dex		                dex
.91cb	ca		dex		                dex
.91cc	86 2a		stx $2a		                stx tmpdsp
.91ce	ba		tsx		                tsx
.91cf	38		sec		                sec
.91d0	bd 01 01	lda $0101,x	                lda $0101,x     ; LSB
.91d3	fd 03 01	sbc $0103,x	                sbc $0103,x
.91d6	a8		tay		                tay
.91d7	bd 02 01	lda $0102,x	                lda $0102,x     ; MSB
.91da	fd 04 01	sbc $0104,x	                sbc $0104,x
.91dd	a6 2a		ldx $2a		                ldx tmpdsp
.91df	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.91e1	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.91e3	60		rts		z_i:            rts
.91e4					xt_if:
.91e4	a0 91		ldy #$91	                ldy #>zero_branch_runtime
.91e6	a9 f5		lda #$f5	                lda #<zero_branch_runtime
.91e8	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.91eb	20 53 91	jsr $9153	                jsr xt_here
.91ee	20 5a a7	jsr $a75a	                jsr xt_zero
.91f1	20 4f 87	jsr $874f	                jsr xt_comma
.91f4	60		rts		z_if:           rts
.91f5					zero_branch_runtime:
.91f5	68		pla		                pla
.91f6	85 22		sta $22		                sta tmpbranch
.91f8	68		pla		                pla
.91f9	85 23		sta $23		                sta tmpbranch+1
.91fb	b5 00		lda $00,x	                lda 0,x
.91fd	15 01		ora $01,x	                ora 1,x
.91ff	f0 0f		beq $9210	                beq _zero
.9201	a5 22		lda $22		                lda tmpbranch   ; LSB
.9203	18		clc		                clc
.9204	69 02		adc #$02	                adc #2
.9206	85 24		sta $24		                sta tmp1
.9208	a5 23		lda $23		                lda tmpbranch+1 ; MSB
.920a	69 00		adc #$00	                adc #0          ; For carry
.920c	85 25		sta $25		                sta tmp1+1
.920e	80 13		bra $9223	                bra _done
.9210					_zero:
.9210	a0 01		ldy #$01	                ldy #1
.9212	b1 22		lda ($22),y	                lda (tmpbranch),y
.9214	85 24		sta $24		                sta tmp1
.9216	c8		iny		                iny
.9217	b1 22		lda ($22),y	                lda (tmpbranch),y
.9219	85 25		sta $25		                sta tmp1+1
.921b	a5 24		lda $24		                lda tmp1
.921d	d0 02		bne $9221	                bne +
.921f	c6 25		dec $25		                dec tmp1+1
.9221					+
.9221	c6 24		dec $24		                dec tmp1
.9223					_done:
.9223	a5 25		lda $25		                lda tmp1+1
.9225	48		pha		                pha             ; MSB first
.9226	a5 24		lda $24		                lda tmp1
.9228	48		pha		                pha
.9229	e8		inx		                inx
.922a	e8		inx		                inx
.922b	60		rts		                rts
.922c					xt_immediate:
.922c	20 38 d7	jsr $d738	                jsr current_to_dp
.922f	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9231	b1 02		lda ($02),y	                lda (dp),y
.9233	09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9235	91 02		sta ($02),y	                sta (dp),y
.9237	60		rts		z_immediate:    rts
.9238					xt_input:
.9238	ca		dex		                dex
.9239	ca		dex		                dex
.923a	a9 12		lda #$12	                lda #<input
.923c	95 00		sta $00,x	                sta 0,x
.923e	a9 00		lda #$00	                lda #>input
.9240	95 01		sta $01,x	                sta 1,x
.9242	60		rts		z_input:        rts
.9243					xt_input_to_r:
.9243	68		pla		                pla
.9244	85 24		sta $24		                sta tmp1
.9246	68		pla		                pla
.9247	85 25		sta $25		                sta tmp1+1
.9249	a0 07		ldy #$07	                ldy #7
.924b					_loop:
.924b	b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.924e	48		pha		                pha
.924f	88		dey		                dey
.9250	10 f9		bpl $924b	                bpl _loop
.9252	a5 25		lda $25		                lda tmp1+1
.9254	48		pha		                pha
.9255	a5 24		lda $24		                lda tmp1
.9257	48		pha		                pha
.9258	60		rts		z_input_to_r: 	rts
.9259					xt_int_to_name:
.9259	20 f6 d7	jsr $d7f6	                jsr underflow_1
.925c	ca		dex		                dex
.925d	ca		dex		                dex
.925e	74 00		stz $00,x	                stz 0,x
.9260	74 01		stz $01,x	                stz 1,x
.9262					_wordlist_loop:
.9262	b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9264	0a		asl a		                asl                     ; Turn offset into cells offset.
.9265	18		clc		                clc
.9266	69 06		adc #$06	                adc #wordlists_offset
.9268	a8		tay		                tay
.9269	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.926b	85 26		sta $26		                sta tmp2                ; into tmp2
.926d	c8		iny		                iny
.926e	b1 1e		lda ($1e),y	                lda (up),y
.9270	85 27		sta $27		                sta tmp2+1
.9272	a5 26		lda $26		                lda tmp2
.9274	05 27		ora $27		                ora tmp2+1
.9276	f0 38		beq $92b0	                beq _next_wordlist
.9278	b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.927a	85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.927c	b5 03		lda $03,x	                lda 3,x
.927e	85 29		sta $29		                sta tmp3+1
.9280					_loop:
.9280	a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9282	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.9284	c5 28		cmp $28		                cmp tmp3
.9286	d0 07		bne $928f	                bne _no_match
.9288	c8		iny		                iny
.9289	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.928b	c5 29		cmp $29		                cmp tmp3+1
.928d	f0 32		beq $92c1	                beq _match
.928f					_no_match:
.928f	18		clc		                clc
.9290	a5 26		lda $26		                lda tmp2
.9292	69 02		adc #$02	                adc #2
.9294	85 26		sta $26		                sta tmp2
.9296	a5 27		lda $27		                lda tmp2+1
.9298	69 00		adc #$00	                adc #0          ; only care about carry
.929a	85 27		sta $27		                sta tmp2+1
.929c	a0 00		ldy #$00	                ldy #0
.929e	b1 26		lda ($26),y	                lda (tmp2),y
.92a0	48		pha		                pha
.92a1	c8		iny		                iny
.92a2	11 26		ora ($26),y	                ora (tmp2),y
.92a4	f0 09		beq $92af	                beq _zero
.92a6	b1 26		lda ($26),y	                lda (tmp2),y
.92a8	85 27		sta $27		                sta tmp2+1
.92aa	68		pla		                pla
.92ab	85 26		sta $26		                sta tmp2
.92ad	80 d1		bra $9280	                bra _loop
.92af					_zero:
.92af	68		pla		                pla             ; Leftover from above loop
.92b0					_next_wordlist:
.92b0	b5 00		lda $00,x	                lda 0,x
.92b2	1a		inc a		                ina
.92b3	95 00		sta $00,x	                sta 0,x
.92b5	c9 0c		cmp #$0c	                cmp #max_wordlists
.92b7	d0 a9		bne $9262	                bne _wordlist_loop
.92b9	e8		inx		                inx
.92ba	e8		inx		                inx
.92bb	74 00		stz $00,x	                stz 0,x
.92bd	74 01		stz $01,x	                stz 1,x
.92bf	80 0a		bra $92cb	                bra z_int_to_name
.92c1					_match:
.92c1	e8		inx		                inx
.92c2	e8		inx		                inx
.92c3	a5 26		lda $26		                lda tmp2
.92c5	95 00		sta $00,x	                sta 0,x
.92c7	a5 27		lda $27		                lda tmp2+1
.92c9	95 01		sta $01,x	                sta 1,x
.92cb	60		rts		z_int_to_name:  rts
.92cc					xt_invert:
.92cc	20 f6 d7	jsr $d7f6	                jsr underflow_1
.92cf	a9 ff		lda #$ff	                lda #$FF
.92d1	55 00		eor $00,x	                eor 0,x         ; LSB
.92d3	95 00		sta $00,x	                sta 0,x
.92d5	a9 ff		lda #$ff	                lda #$FF
.92d7	55 01		eor $01,x	                eor 1,x         ; MSB
.92d9	95 01		sta $01,x	                sta 1,x
.92db	60		rts		z_invert:       rts
.92dc					xt_is:
.92dc	a5 16		lda $16		                lda state
.92de	05 17		ora $17		                ora state+1
.92e0	f0 0c		beq $92ee	                beq _interpreting
.92e2					_compiling:
.92e2	20 7f 85	jsr $857f	                jsr xt_bracket_tick
.92e5	a0 8a		ldy #$8a	                ldy #>xt_defer_store
.92e7	a9 c7		lda #$c7	                lda #<xt_defer_store
.92e9	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.92ec	80 06		bra $92f4	                bra _done
.92ee					_interpreting:
.92ee	20 c3 a1	jsr $a1c3	                jsr xt_tick
.92f1	20 c7 8a	jsr $8ac7	                jsr xt_defer_store
.92f4					_done:
.92f4	60		rts		z_is:           rts
.92f5					xt_j:
.92f5	ca		dex		                dex
.92f6	ca		dex		                dex
.92f7	86 2a		stx $2a		                stx tmpdsp
.92f9	ba		tsx		                tsx
.92fa	38		sec		                sec
.92fb	bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.92fe	fd 09 01	sbc $0109,x	                sbc $0109,x
.9301	a8		tay		                tay
.9302	bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.9305	fd 0a 01	sbc $010a,x	                sbc $010A,x
.9308	a6 2a		ldx $2a		                ldx tmpdsp
.930a	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.930c	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.930e	60		rts		z_j:            rts
.930f					xt_key:
.930f	20 19 93	jsr $9319	                jsr key_a               ; returns char in A
.9312	ca		dex		                dex
.9313	ca		dex		                dex
.9314	95 00		sta $00,x	                sta 0,x
.9316	74 01		stz $01,x	                stz 1,x
.9318	60		rts		z_key:          rts
.9319					key_a:
.9319	6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.931c					xt_latestnt:
.931c	ca		dex		                dex
.931d	ca		dex		                dex
.931e	20 38 d7	jsr $d738	                jsr current_to_dp
.9321	a5 02		lda $02		                lda dp
.9323	95 00		sta $00,x	                sta 0,x
.9325	a5 03		lda $03		                lda dp+1
.9327	95 01		sta $01,x	                sta 1,x
.9329	60		rts		z_latestnt:     rts
.932a					xt_latestxt:
.932a	20 1c 93	jsr $931c	                jsr xt_latestnt         ; ( nt )
.932d	20 c2 95	jsr $95c2	                jsr xt_name_to_int      ; ( xt )
.9330	60		rts		z_latestxt:     rts
.9331					xt_leave:
.9331	68		pla		                pla
.9332	68		pla		                pla
.9333	68		pla		                pla
.9334	68		pla		                pla
.9335	60		rts		                rts             ; this must be compiled, so keep before z_leave
.9336					z_leave:
.9336					xt_left_bracket:
.9336	64 16		stz $16		                stz state
.9338	64 17		stz $17		                stz state+1
.933a	60		rts		z_left_bracket: rts
.933b					xt_less_number_sign:
.933b	20 82 98	jsr $9882	                jsr xt_pad      ; ( addr )
.933e	b5 00		lda $00,x	                lda 0,x
.9340	85 34		sta $34		                sta tohold
.9342	b5 01		lda $01,x	                lda 1,x
.9344	85 35		sta $35		                sta tohold+1
.9346	e8		inx		                inx
.9347	e8		inx		                inx
.9348					z_less_number_sign:
.9348	60		rts		                rts
.9349					xt_less_than:
.9349	20 fb d7	jsr $d7fb	                jsr underflow_2
.934c	a0 00		ldy #$00	                ldy #0          ; default false
.934e	20 1d d7	jsr $d71d	                jsr compare_16bit
.9351	f0 03		beq $9356	                beq _false
.9353	30 01		bmi $9356	                bmi _false
.9355	88		dey		                dey
.9356					_false:
.9356	98		tya		                tya
.9357	e8		inx		                inx
.9358	e8		inx		                inx
.9359	95 00		sta $00,x	                sta 0,x
.935b	95 01		sta $01,x	                sta 1,x
.935d	60		rts		z_less_than:    rts
.935e					xt_list:
.935e	20 f6 d7	jsr $d7f6	                jsr underflow_1
.9361	20 8b 9e	jsr $9e8b	                jsr xt_scr
.9364	20 3f a1	jsr $a13f	                jsr xt_store
.9367	20 f8 a7	jsr $a7f8	                jsr xt_editor_l
.936a	60		rts		z_list:         rts
.936b					xt_literal:
.936b	20 f6 d7	jsr $d7f6	                jsr underflow_1
.936e	a0 93		ldy #$93	                ldy #>literal_runtime
.9370	a9 79		lda #$79	                lda #<literal_runtime
.9372	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.9375	20 4f 87	jsr $874f	                jsr xt_comma
.9378	60		rts		z_literal:      rts
.9379					literal_runtime:
.9379	ca		dex		                dex
.937a	ca		dex		                dex
.937b	68		pla		                pla             ; LSB
.937c	85 24		sta $24		                sta tmp1
.937e	68		pla		                pla             ; MSB
.937f	85 25		sta $25		                sta tmp1+1
.9381	a0 01		ldy #$01	                ldy #1
.9383	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.9385	95 00		sta $00,x	                sta 0,x
.9387	c8		iny		                iny
.9388	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.938a	95 01		sta $01,x	                sta 1,x
.938c	98		tya		                tya
.938d	18		clc		                clc
.938e	65 24		adc $24		                adc tmp1
.9390	a8		tay		                tay
.9391	a5 25		lda $25		                lda tmp1+1
.9393	69 00		adc #$00	                adc #0
.9395	48		pha		                pha
.9396	5a		phy		                phy
.9397	60		rts		                rts
.9398					xt_load:
.9398	20 f6 d7	jsr $d7f6	                jsr underflow_1
.939b	a0 01		ldy #$01	                ldy #blk_offset+1
.939d	b1 1e		lda ($1e),y	                lda (up),y
.939f	48		pha		                pha
.93a0	88		dey		                dey
.93a1	b1 1e		lda ($1e),y	                lda (up),y
.93a3	48		pha		                pha
.93a4	b5 00		lda $00,x	                lda 0,x
.93a6	91 1e		sta ($1e),y	                sta (up),y
.93a8	c8		iny		                iny
.93a9	b5 01		lda $01,x	                lda 1,x
.93ab	91 1e		sta ($1e),y	                sta (up),y
.93ad	20 a2 83	jsr $83a2	                jsr xt_block
.93b0	ca		dex		                dex
.93b1	ca		dex		                dex
.93b2	a9 04		lda #$04	                lda #4
.93b4	95 01		sta $01,x	                sta 1,x
.93b6	74 00		stz $00,x	                stz 0,x
.93b8	20 b0 90	jsr $90b0	                jsr load_evaluate
.93bb	a0 00		ldy #$00	                ldy #blk_offset
.93bd	68		pla		                pla
.93be	91 1e		sta ($1e),y	                sta (up),y
.93c0	c8		iny		                iny
.93c1	68		pla		                pla
.93c2	91 1e		sta ($1e),y	                sta (up),y
.93c4	88		dey		                dey
.93c5	11 1e		ora ($1e),y	                ora (up),y
.93c7	f0 12		beq $93db	                beq _done
.93c9	ca		dex		                dex
.93ca	ca		dex		                dex
.93cb	a0 00		ldy #$00	                ldy #blk_offset
.93cd	b1 1e		lda ($1e),y	                lda (up),y
.93cf	95 00		sta $00,x	                sta 0,x
.93d1	c8		iny		                iny
.93d2	b1 1e		lda ($1e),y	                lda (up),y
.93d4	95 01		sta $01,x	                sta 1,x
.93d6	20 a2 83	jsr $83a2	                jsr xt_block
.93d9	e8		inx		                inx
.93da	e8		inx		                inx
.93db					_done:
.93db	60		rts		z_load:         rts
.93dc					xt_loop:
.93dc	a0 97		ldy #$97	                ldy #>xt_one
.93de	a9 e9		lda #$e9	                lda #<xt_one
.93e0	20 99 d6	jsr $d699	                jsr cmpl_subroutine     ; drop through to +LOOP
.93e3					xt_plus_loop:
.93e3	a0 11		ldy #$11	                ldy #plus_loop_runtime_end-plus_loop_runtime
.93e5	5a		phy		                phy             ; save counter to adjust CP
.93e6					-
.93e6	b9 4a 94	lda $944a,y	                lda plus_loop_runtime,y
.93e9	91 00		sta ($00),y	                sta (cp),y
.93eb	88		dey		                dey
.93ec	10 f8		bpl $93e6	                bpl -
.93ee	68		pla		                pla
.93ef	18		clc		                clc
.93f0	65 00		adc $00		                adc cp
.93f2	85 00		sta $00		                sta cp
.93f4	a5 01		lda $01		                lda cp+1
.93f6	69 00		adc #$00	                adc #0          ; only need carry
.93f8	85 01		sta $01		                sta cp+1
.93fa	20 4f 87	jsr $874f	                jsr xt_comma
.93fd	a9 68		lda #$68	                lda #$68                ; opcode for PLA
.93ff	a0 06		ldy #$06	                ldy #6
.9401					-
.9401	91 00		sta ($00),y	                sta (cp),y
.9403	88		dey		                dey
.9404	10 fb		bpl $9401	                bpl -
.9406	a9 06		lda #$06	                lda #6
.9408	18		clc		                clc
.9409	65 00		adc $00		                adc cp
.940b	85 00		sta $00		                sta cp
.940d	a5 01		lda $01		                lda cp+1
.940f	69 00		adc #$00	                adc #0                  ; only need carry
.9411	85 01		sta $01		                sta cp+1
.9413	b5 00		lda $00,x	                lda 0,x
.9415	85 24		sta $24		                sta tmp1
.9417	b5 01		lda $01,x	                lda 1,x
.9419	85 25		sta $25		                sta tmp1+1
.941b	e8		inx		                inx
.941c	e8		inx		                inx
.941d	a5 00		lda $00		                lda cp
.941f	38		sec		                sec
.9420	e9 01		sbc #$01	                sbc #1
.9422	85 26		sta $26		                sta tmp2
.9424	a5 01		lda $01		                lda cp+1
.9426	e9 00		sbc #$00	                sbc #0
.9428	85 27		sta $27		                sta tmp2+1
.942a	a0 00		ldy #$00	                ldy #0
.942c	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.942e	91 24		sta ($24),y	                sta (tmp1),y
.9430	c8		iny		                iny
.9431	a5 27		lda $27		                lda tmp2+1      ; MSB
.9433	91 24		sta ($24),y	                sta (tmp1),y
.9435	c8		iny		                iny
.9436	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9438	91 24		sta ($24),y	                sta (tmp1),y
.943a	c8		iny		                iny
.943b	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.943d	91 24		sta ($24),y	                sta (tmp1),y
.943f	c8		iny		                iny
.9440	a5 26		lda $26		                lda tmp2        ; LSB
.9442	91 24		sta ($24),y	                sta (tmp1),y
.9444	c8		iny		                iny
.9445	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9447	91 24		sta ($24),y	                sta (tmp1),y
.9449					z_loop:
.9449	60		rts		z_plus_loop:    rts
.944a					plus_loop_runtime:
.944a	18		clc		                clc
.944b	68		pla		                pla             ; LSB of index
.944c	75 00		adc $00,x	                adc 0,x         ; LSB of step
.944e	a8		tay		                tay             ; temporary storage of LSB
.944f	b8		clv		                clv
.9450	68		pla		                pla             ; MSB of index
.9451	75 01		adc $01,x	                adc 1,x         ; MSB of step
.9453	48		pha		                pha             ; put MSB of index back on stack
.9454	98		tya		                tya             ; put LSB of index back on stack
.9455	48		pha		                pha
.9456	e8		inx		                inx             ; dump step from TOS
.9457	e8		inx		                inx
.9458	70 03		bvs $945d	                bvs _hack+3     ; skip over JMP instruction
.945a					_hack:
>945a	4c				                .byte $4C
.945b					plus_loop_runtime_end:
.945b					xt_lshift:
.945b	20 fb d7	jsr $d7fb	                jsr underflow_2
.945e	b5 00		lda $00,x	                lda 0,x
.9460	29 0f		and #$0f	                and #%00001111
.9462	f0 08		beq $946c	                beq _done
.9464	a8		tay		                tay
.9465					_loop:
.9465	16 02		asl $02,x	                asl 2,x
.9467	36 03		rol $03,x	                rol 3,x
.9469	88		dey		                dey
.946a	d0 f9		bne $9465	                bne _loop
.946c					_done:
.946c	e8		inx		                inx
.946d	e8		inx		                inx
.946e	60		rts		z_lshift:       rts
.946f					xt_m_star:
.946f	20 fb d7	jsr $d7fb	                jsr underflow_2
.9472	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9474	55 03		eor $03,x	                eor 3,x         ; MSB of n2
.9476	48		pha		                pha
.9477	20 1a 81	jsr $811a	                jsr xt_abs
.947a	20 60 a1	jsr $a160	                jsr xt_swap
.947d	20 1a 81	jsr $811a	                jsr xt_abs
.9480	20 ae a5	jsr $a5ae	                jsr xt_um_star          ; ( d )
.9483	68		pla		                pla
.9484	10 03		bpl $9489	                bpl _done
.9486	20 22 8b	jsr $8b22	                jsr xt_dnegate
.9489					_done:
.9489	60		rts		z_m_star:       rts
.948a					xt_marker:
.948a	20 38 d7	jsr $d738	                jsr current_to_dp
.948d	a5 02		lda $02		                lda dp
.948f	48		pha		                pha
.9490	a5 03		lda $03		                lda dp+1
.9492	48		pha		                pha
.9493	a5 00		lda $00		                lda cp
.9495	48		pha		                pha
.9496	a5 01		lda $01		                lda cp+1
.9498	48		pha		                pha
.9499	20 4a 89	jsr $894a	                jsr xt_create
.949c	a5 00		lda $00		                lda cp          ; LSB
.949e	38		sec		                sec
.949f	e9 02		sbc #$02	                sbc #2
.94a1	85 00		sta $00		                sta cp
.94a3	a5 01		lda $01		                lda cp+1        ; MSB
.94a5	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94a7	85 01		sta $01		                sta cp+1
.94a9	a0 94		ldy #$94	                ldy #>marker_runtime
.94ab	a9 c8		lda #$c8	                lda #<marker_runtime
.94ad	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.94b0	7a		ply		                ply                     ; MSB
.94b1	68		pla		                pla                     ; LSB
.94b2	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.94b5	7a		ply		                ply                     ; MSB
.94b6	68		pla		                pla                     ; LSB
.94b7	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.94ba	a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94bc					_marker_loop:
.94bc	b1 1e		lda ($1e),y	                lda (up),y
.94be	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.94c1	c8		iny		                iny
.94c2	98		tya		                tya
.94c3	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94c5	d0 f5		bne $94bc	                bne _marker_loop
.94c7	60		rts		z_marker:       rts
.94c8					marker_runtime:
.94c8	68		pla		                pla
.94c9	85 24		sta $24		                sta tmp1        ; LSB of address
.94cb	68		pla		                pla
.94cc	85 25		sta $25		                sta tmp1+1      ; MSB of address
.94ce	e6 24		inc $24		                inc tmp1
.94d0	d0 02		bne $94d4	                bne +
.94d2	e6 25		inc $25		                inc tmp1+1
.94d4					+
.94d4	a0 00		ldy #$00	                ldy #0
.94d6	b1 24		lda ($24),y	                lda (tmp1),y
.94d8	85 00		sta $00		                sta cp
.94da	c8		iny		                iny
.94db	b1 24		lda ($24),y	                lda (tmp1),y
.94dd	85 01		sta $01		                sta cp+1
.94df	c8		iny		                iny
.94e0	b1 24		lda ($24),y	                lda (tmp1),y
.94e2	85 02		sta $02		                sta dp
.94e4	c8		iny		                iny
.94e5	b1 24		lda ($24),y	                lda (tmp1),y
.94e7	85 03		sta $03		                sta dp+1
.94e9	a0 04		ldy #$04	                ldy #4
.94eb					_marker_restore_loop:
.94eb	b1 24		lda ($24),y	                lda (tmp1), y
.94ed	91 1e		sta ($1e),y	                sta (up), y
.94ef	c8		iny		                iny
.94f0	98		tya		                tya
.94f1	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94f3	d0 f6		bne $94eb	                bne _marker_restore_loop
.94f5	20 4b d7	jsr $d74b	                jsr dp_to_current       ; Move the CURRENT DP back.
.94f8	60		rts		                rts
.94f9					xt_max:
.94f9	20 fb d7	jsr $d7fb	                jsr underflow_2
.94fc	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.94fe	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.9500	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9502	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9504	50 02		bvc $9508	                bvc _no_overflow
.9506	49 80		eor #$80	                eor #$80        ; complement negative flag
.9508					_no_overflow:
.9508	30 08		bmi $9512	                bmi _keep_nos
.950a	b5 00		lda $00,x	                lda 0,x
.950c	95 02		sta $02,x	                sta 2,x
.950e	b5 01		lda $01,x	                lda 1,x
.9510	95 03		sta $03,x	                sta 3,x
.9512					_keep_nos:
.9512	e8		inx		                inx
.9513	e8		inx		                inx
.9514	60		rts		z_max:          rts
.9515					xt_min:
.9515	20 fb d7	jsr $d7fb	                jsr underflow_2
.9518	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.951a	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.951c	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.951e	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9520	50 02		bvc $9524	                bvc _no_overflow
.9522	49 80		eor #$80	                eor #$80
.9524					_no_overflow:
.9524	10 08		bpl $952e	                bpl _keep_nos
.9526	b5 00		lda $00,x	                lda 0,x
.9528	95 02		sta $02,x	                sta 2,x
.952a	b5 01		lda $01,x	                lda 1,x
.952c	95 03		sta $03,x	                sta 3,x
.952e					_keep_nos:
.952e	e8		inx		                inx
.952f	e8		inx		                inx
.9530	60		rts		z_min:          rts
.9531					xt_minus:
.9531	20 fb d7	jsr $d7fb	                jsr underflow_2
.9534	38		sec		                sec
.9535	b5 02		lda $02,x	                lda 2,x         ; LSB
.9537	f5 00		sbc $00,x	                sbc 0,x
.9539	95 02		sta $02,x	                sta 2,x
.953b	b5 03		lda $03,x	                lda 3,x         ; MSB
.953d	f5 01		sbc $01,x	                sbc 1,x
.953f	95 03		sta $03,x	                sta 3,x
.9541	e8		inx		                inx
.9542	e8		inx		                inx
.9543	60		rts		z_minus:        rts
.9544					xt_minus_leading:
.9544	20 fb d7	jsr $d7fb	                jsr underflow_2
.9547					_loop:
.9547	b5 00		lda $00,x	                lda 0,x
.9549	15 01		ora $01,x	                ora 1,x
.954b	f0 0f		beq $955c	                beq _done
.954d	a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.954f	20 e9 d7	jsr $d7e9	                jsr is_whitespace
.9552	90 08		bcc $955c	                bcc _done
.9554	20 e9 97	jsr $97e9	                jsr xt_one              ; ( addr u 1 )
.9557	20 cb 9f	jsr $9fcb	                jsr xt_slash_string     ; ( addr+ u-1 )
.955a	80 eb		bra $9547	                bra _loop
.955c					_done:
.955c					z_minus_leading:
.955c	60		rts		                rts
.955d					xt_minus_trailing:
.955d	20 fb d7	jsr $d7fb	                jsr underflow_2
.9560	b5 00		lda $00,x	                lda 0,x         ; LSB of n
.9562	15 01		ora $01,x	                ora 1,x         ; MSB of n
.9564	f0 33		beq $9599	                beq _done
.9566	18		clc		                clc
.9567	b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.9569	75 00		adc $00,x	                adc 0,x
.956b	85 24		sta $24		                sta tmp1
.956d	b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.956f	75 01		adc $01,x	                adc 1,x
.9571	85 25		sta $25		                sta tmp1+1
.9573	a5 24		lda $24		                lda tmp1
.9575	d0 02		bne $9579	                bne +
.9577	c6 25		dec $25		                dec tmp1+1
.9579					+
.9579	c6 24		dec $24		                dec tmp1
.957b					_loop:
.957b	b2 24		lda ($24)	                lda (tmp1)
.957d	c9 20		cmp #$20	                cmp #AscSP
.957f	d0 18		bne $9599	                bne _done
.9581	a5 24		lda $24		                lda tmp1
.9583	d0 02		bne $9587	                bne +
.9585	c6 25		dec $25		                dec tmp1+1
.9587					+
.9587	c6 24		dec $24		                dec tmp1
.9589	b5 00		lda $00,x	                lda 0,x
.958b	d0 02		bne $958f	                bne +
.958d	d6 01		dec $01,x	                dec 1,x
.958f					+
.958f	d6 00		dec $00,x	                dec 0,x
.9591	b5 00		lda $00,x	                lda 0,x
.9593	15 01		ora $01,x	                ora 1,x
.9595	f0 02		beq $9599	                beq _done       ; Count has reached zero - we're done!
.9597	80 e2		bra $957b	                bra _loop
.9599					_done:
.9599					z_minus_trailing:
.9599	60		rts		                rts
.959a					xt_mod:
.959a	20 fb d7	jsr $d7fb	                jsr underflow_2
.959d	20 b3 9f	jsr $9fb3	                jsr xt_slash_mod
.95a0	e8		inx		                inx             ; DROP
.95a1	e8		inx		                inx
.95a2					z_mod:
.95a2	60		rts		                rts
.95a3					xt_move:
.95a3	b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95a5	d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95a7	f0 05		beq $95ae	                beq _lsb                ; wasn't helpful, move to LSB
.95a9	b0 0e		bcs $95b9	                bcs _to_move_up         ; we want CMOVE>
.95ab	4c 7a 86	jmp $867a	                jmp xt_cmove            ; JSR/RTS
.95ae					_lsb:
.95ae	b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95b0	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95b2	f0 08		beq $95bc	                beq _equal              ; LSB is equal as well
.95b4	b0 03		bcs $95b9	                bcs _to_move_up         ; we want CMOVE>
.95b6	4c 7a 86	jmp $867a	                jmp xt_cmove            ; JSR/RTS
.95b9					_to_move_up:
.95b9	4c b5 86	jmp $86b5	                jmp xt_cmove_up         ; JSR/RTS
.95bc					_equal:
.95bc	8a		txa		                txa
.95bd	18		clc		                clc
.95be	69 06		adc #$06	                adc #6
.95c0	aa		tax		                tax
.95c1	60		rts		z_move:         rts
.95c2					xt_name_to_int:
.95c2	20 f6 d7	jsr $d7f6	                jsr underflow_1
.95c5	b5 00		lda $00,x	                lda 0,x
.95c7	18		clc		                clc
.95c8	69 04		adc #$04	                adc #4
.95ca	85 28		sta $28		                sta tmp3
.95cc	b5 01		lda $01,x	                lda 1,x
.95ce	90 01		bcc $95d1	                bcc _done
.95d0	1a		inc a		                ina
.95d1					_done:
.95d1	85 29		sta $29		                sta tmp3+1
.95d3	a0 00		ldy #$00	                ldy #0
.95d5	b1 28		lda ($28),y	                lda (tmp3),y
.95d7	95 00		sta $00,x	                sta 0,x
.95d9	c8		iny		                iny
.95da	b1 28		lda ($28),y	                lda (tmp3),y
.95dc	95 01		sta $01,x	                sta 1,x
.95de	60		rts		z_name_to_int:  rts
.95df					xt_name_to_string:
.95df	20 f6 d7	jsr $d7f6	                jsr underflow_1
.95e2	ca		dex		                dex
.95e3	ca		dex		                dex
.95e4	a1 02		lda ($02,x)	                lda (2,x)
.95e6	95 00		sta $00,x	                sta 0,x
.95e8	74 01		stz $01,x	                stz 1,x
.95ea	b5 02		lda $02,x	                lda 2,x         ; LSB
.95ec	18		clc		                clc
.95ed	69 08		adc #$08	                adc #8
.95ef	a8		tay		                tay
.95f0	b5 03		lda $03,x	                lda 3,x         ; MSB
.95f2	69 00		adc #$00	                adc #0          ; just need carry
.95f4	95 03		sta $03,x	                sta 3,x
.95f6	94 02		sty $02,x	                sty 2,x
.95f8					z_name_to_string:
.95f8	60		rts		                rts
.95f9					xt_nc_limit:
.95f9	ca		dex		                dex
.95fa	ca		dex		                dex
.95fb	a9 1a		lda #$1a	                lda #<nc_limit
.95fd	95 00		sta $00,x	                sta 0,x
.95ff	a9 00		lda #$00	                lda #>nc_limit
.9601	95 01		sta $01,x	                sta 1,x
.9603	60		rts		z_nc_limit:     rts
.9604					xt_negate:
.9604	20 f6 d7	jsr $d7f6	                jsr underflow_1
.9607	a9 00		lda #$00	        	lda #0
.9609	38		sec		                sec
.960a	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.960c	95 00		sta $00,x	                sta 0,x
.960e	a9 00		lda #$00	                lda #0
.9610	f5 01		sbc $01,x	                sbc 1,x         ; MSB
.9612	95 01		sta $01,x	                sta 1,x
.9614	60		rts		z_negate:       rts
.9615					xt_never_native:
.9615	20 38 d7	jsr $d738	                jsr current_to_dp
.9618	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.961a	b1 02		lda ($02),y	                lda (dp),y
.961c	09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.961e	29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.9620	91 02		sta ($02),y	                sta (dp),y
.9622					z_never_native:
.9622	60		rts		                rts
.9623					xt_nip:
.9623	20 fb d7	jsr $d7fb	                jsr underflow_2
.9626	b5 00		lda $00,x	                lda 0,x         ; LSB
.9628	95 02		sta $02,x	                sta 2,x
.962a	b5 01		lda $01,x	                lda 1,x         ; MSB
.962c	95 03		sta $03,x	                sta 3,x
.962e	e8		inx		                inx
.962f	e8		inx		                inx
.9630	60		rts		z_nip:          rts
.9631					xt_not_equals:
.9631	20 fb d7	jsr $d7fb	                jsr underflow_2
.9634	a0 00		ldy #$00	                ldy #0                  ; default is true
.9636	b5 00		lda $00,x	                lda 0,x                 ; LSB
.9638	d5 02		cmp $02,x	                cmp 2,x
.963a	d0 0a		bne $9646	                bne _not_equal
.963c	b5 01		lda $01,x	                lda 1,x                 ; MSB
.963e	d5 03		cmp $03,x	                cmp 3,x
.9640	d0 04		bne $9646	                bne _not_equal
.9642	a9 ff		lda #$ff	                lda #$FF
.9644	80 01		bra $9647	                bra _done
.9646					_not_equal:
.9646	88		dey		                dey                     ; drop thru to done
.9647					_done:
.9647	98		tya		                tya
.9648	e8		inx		                inx
.9649	e8		inx		                inx
.964a	95 00		sta $00,x	                sta 0,x
.964c	95 01		sta $01,x	                sta 1,x
.964e	60		rts		z_not_equals:   rts
.964f					xt_not_rote:
.964f	20 00 d8	jsr $d800	                jsr underflow_3
.9652	b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9654	b5 03		lda $03,x	                lda 3,x
.9656	95 01		sta $01,x	                sta 1,x
.9658	b5 05		lda $05,x	                lda 5,x
.965a	95 03		sta $03,x	                sta 3,x
.965c	94 05		sty $05,x	                sty 5,x
.965e	b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9660	b5 02		lda $02,x	                lda 2,x
.9662	95 00		sta $00,x	                sta 0,x
.9664	b5 04		lda $04,x	                lda 4,x
.9666	95 02		sta $02,x	                sta 2,x
.9668	94 04		sty $04,x	                sty 4,x
.966a	60		rts		z_not_rote:     rts
.966b					xt_number:
.966b	20 fb d7	jsr $d7fb	                jsr underflow_2
.966e	64 2a		stz $2a		                stz tmpdsp      ; flag for double
.9670	64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.9672	a5 18		lda $18		                lda base
.9674	48		pha		                pha
.9675	20 6a a3	jsr $a36a	                jsr xt_two_dup
.9678	a1 02		lda ($02,x)	                lda (2,x)
.967a					_check_dec:
.967a	c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.967c	d0 04		bne $9682	                bne _check_hex
.967e	a9 0a		lda #$0a	                lda #$0A
.9680	80 42		bra $96c4	                bra _base_changed
.9682					_check_hex:
.9682	c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.9684	d0 04		bne $968a	                bne _check_binary
.9686	a9 10		lda #$10	                lda #$10
.9688	80 3a		bra $96c4	                bra _base_changed
.968a					_check_binary:
.968a	c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.968c	d0 04		bne $9692	                bne _check_char
.968e	a9 02		lda #$02	                lda #$02
.9690	80 32		bra $96c4	                bra _base_changed
.9692					_check_char:
.9692	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.9694	d0 3a		bne $96d0	                bne _check_minus
.9696	b5 00		lda $00,x	                lda 0,x         ; Get the length
.9698	c9 03		cmp #$03	                cmp #$03
.969a	d0 26		bne $96c2	                bne _not_a_char
.969c	b5 01		lda $01,x	                lda 1,x
.969e	d0 22		bne $96c2	                bne _not_a_char ; No compare needed to check for non-zero.
.96a0	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96a2	18		clc		                clc
.96a3	69 02		adc #$02	                adc #2          ; length of string
.96a5	85 2c		sta $2c		                sta tmptos
.96a7	b5 03		lda $03,x	                lda 3,x
.96a9	69 00		adc #$00	                adc #0          ; only need carry
.96ab	85 2d		sta $2d		                sta tmptos+1
.96ad	b2 2c		lda ($2c)	                lda (tmptos)
.96af	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96b1	d0 0f		bne $96c2	                bne _not_a_char
.96b3	f6 02		inc $02,x	                inc 2,x
.96b5	d0 02		bne $96b9	                bne +
.96b7	f6 03		inc $03,x	                inc 3,x
.96b9					+
.96b9	a1 02		lda ($02,x)	                lda (2,x)
.96bb	95 02		sta $02,x	                sta 2,x
.96bd	74 03		stz $03,x	                stz 3,x
.96bf	4c 40 97	jmp $9740	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.96c2					_not_a_char:
.96c2	80 5a		bra $971e	                bra _number_error
.96c4					_base_changed:
.96c4	85 18		sta $18		                sta base        ; Switch to the new base
.96c6	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96c8	d0 02		bne $96cc	                bne +
.96ca	f6 03		inc $03,x	                inc 3,x
.96cc					+
.96cc	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96ce	a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96d0					_check_minus:
.96d0	c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96d2	d0 0a		bne $96de	                bne _check_dot
.96d4	c6 2b		dec $2b		                dec tmpdsp+1
.96d6	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96d8	d0 02		bne $96dc	                bne +
.96da	f6 03		inc $03,x	                inc 3,x
.96dc					+
.96dc	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96de					_check_dot:
.96de	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96e0	18		clc		                clc
.96e1	75 00		adc $00,x	                adc 0,x         ; length of string
.96e3	85 2c		sta $2c		                sta tmptos
.96e5	b5 03		lda $03,x	                lda 3,x
.96e7	69 00		adc #$00	                adc #0          ; only need carry
.96e9	85 2d		sta $2d		                sta tmptos+1
.96eb	a5 2c		lda $2c		                lda tmptos
.96ed	d0 02		bne $96f1	                bne +
.96ef	c6 2d		dec $2d		                dec tmptos+1
.96f1					+
.96f1	c6 2c		dec $2c		                dec tmptos
.96f3	b2 2c		lda ($2c)	                lda (tmptos)
.96f5	c9 2e		cmp #$2e	                cmp #'.'
.96f7	d0 04		bne $96fd	                bne _main
.96f9	c6 2a		dec $2a		                dec tmpdsp
.96fb	d6 00		dec $00,x	                dec 0,x
.96fd					_main:
.96fd	ca		dex		                dex
.96fe	ca		dex		                dex
.96ff	ca		dex		                dex
.9700	ca		dex		                dex
.9701	b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9703	95 00		sta $00,x	                sta 0,x
.9705	74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9707	b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9709	95 02		sta $02,x	                sta 2,x
.970b	b5 07		lda $07,x	                lda 7,x         ; MSB of address
.970d	95 03		sta $03,x	                sta 3,x
.970f	74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9711	74 05		stz $05,x	                stz 5,x
.9713	74 06		stz $06,x	                stz 6,x
.9715	74 07		stz $07,x	                stz 7,x
.9717	20 6f a2	jsr $a26f	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.971a	b5 00		lda $00,x	                lda 0,x
.971c	f0 1e		beq $973c	                beq _all_converted
.971e					_number_error:
.971e	20 62 a3	jsr $a362	                jsr xt_two_drop ; >NUMBER modified addr u
.9721	20 62 a3	jsr $a362	                jsr xt_two_drop ; ud   (partially converted number)
.9724	a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9726	20 d7 8d	jsr $8dd7	                jsr emit_a
.9729	20 b5 a4	jsr $a4b5	                jsr xt_type
.972c	a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.972e	20 d7 8d	jsr $8dd7	                jsr emit_a
.9731	20 d0 a0	jsr $a0d0	                jsr xt_space
.9734	68		pla		                pla
.9735	85 18		sta $18		                sta base
.9737	a9 08		lda #$08	                lda #err_syntax
.9739	4c 0c d8	jmp $d80c	                jmp error
.973c					_all_converted:
.973c	e8		inx		                inx ; Drop the current addr u
.973d	e8		inx		                inx
.973e	e8		inx		                inx
.973f	e8		inx		                inx
.9740					_drop_original_string:
.9740	20 30 a4	jsr $a430	                jsr xt_two_swap  ; Drop the original addr u
.9743	20 62 a3	jsr $a362	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9746	a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9748	f0 0d		beq $9757	                beq _single
.974a	a9 20		lda #$20	                lda #%00100000
.974c	04 20		tsb $20		                tsb status
.974e	a5 2b		lda $2b		                lda tmpdsp+1
.9750	f0 12		beq $9764	                beq _done       ; no minus, all done
.9752	20 22 8b	jsr $8b22	                jsr xt_dnegate
.9755	80 0d		bra $9764	                bra _done
.9757					_single:
.9757	e8		inx		                inx
.9758	e8		inx		                inx
.9759	a9 20		lda #$20	                lda #%00100000
.975b	14 20		trb $20		                trb status
.975d	a5 2b		lda $2b		                lda tmpdsp+1
.975f	f0 03		beq $9764	                beq _done       ; no minus, all done
.9761	20 04 96	jsr $9604	                jsr xt_negate
.9764					_done:
.9764	68		pla		                pla
.9765	85 18		sta $18		                sta base
.9767	60		rts		z_number:       rts
.9768					xt_number_sign:
.9768	20 fb d7	jsr $d7fb	                jsr underflow_2         ; double number
.976b	20 68 83	jsr $8368	                jsr xt_base
.976e	20 61 8f	jsr $8f61	                jsr xt_fetch            ; ( ud1 base )
.9771	20 22 a3	jsr $a322	                jsr xt_to_r             ; >r
.9774	20 5a a7	jsr $a75a	                jsr xt_zero             ; 0
.9777	20 5e 9a	jsr $9a5e	                jsr xt_r_fetch          ; r@
.977a	20 6c a5	jsr $a56c	                jsr xt_um_slash_mod     ; um/mod
.977d	20 38 9b	jsr $9b38	                jsr xt_rot              ; rot
.9780	20 38 9b	jsr $9b38	                jsr xt_rot              ; rot
.9783	20 73 9a	jsr $9a73	                jsr xt_r_from           ; r>
.9786	20 6c a5	jsr $a56c	                jsr xt_um_slash_mod     ; um/mod
.9789	20 38 9b	jsr $9b38	                jsr xt_rot              ; rot
.978c	20 38 9b	jsr $9b38	                jsr xt_rot              ; ( ud rem )
.978f	b5 00		lda $00,x	                lda 0,x
.9791	a8		tay		                tay
.9792	b9 d5 d3	lda $d3d5,y	                lda s_abc_upper,y
.9795	95 00		sta $00,x	                sta 0,x
.9797	74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.9799	20 b8 91	jsr $91b8	                jsr xt_hold
.979c					z_number_sign:
.979c	60		rts		                rts
.979d					xt_number_sign_greater:
.979d	20 fb d7	jsr $d7fb	                jsr underflow_2         ; double number
.97a0	a5 34		lda $34		                lda tohold
.97a2	95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97a4	95 02		sta $02,x	                sta 2,x
.97a6	a5 35		lda $35		                lda tohold+1
.97a8	95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97aa	95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97ac	20 82 98	jsr $9882	                jsr xt_pad      ; ( addr addr pad )
.97af	38		sec		                sec
.97b0	b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97b2	f5 02		sbc $02,x	                sbc 2,x
.97b4	95 02		sta $02,x	                sta 2,x
.97b6	b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97b8	f5 03		sbc $03,x	                sbc 3,x
.97ba	95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97bc	e8		inx		                inx
.97bd	e8		inx		                inx
.97be					z_number_sign_greater:
.97be	60		rts		                rts
.97bf					xt_number_sign_s:
.97bf	20 fb d7	jsr $d7fb	                jsr underflow_2
.97c2					_loop:
.97c2	20 68 97	jsr $9768	                jsr xt_number_sign
.97c5	b5 00		lda $00,x	                lda 0,x
.97c7	15 01		ora $01,x	                ora 1,x
.97c9	15 02		ora $02,x	                ora 2,x
.97cb	15 03		ora $03,x	                ora 3,x
.97cd	d0 f3		bne $97c2	                bne _loop
.97cf					z_number_sign_s:
.97cf	60		rts		                rts
.97d0					xt_of:
.97d0	a0 98		ldy #$98	                ldy #>xt_over
.97d2	a9 74		lda #$74	                lda #<xt_over
.97d4	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.97d7	a0 8e		ldy #$8e	                ldy #>xt_equal
.97d9	a9 af		lda #$af	                lda #<xt_equal
.97db	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.97de	20 e4 91	jsr $91e4	                jsr xt_if
.97e1	a0 8d		ldy #$8d	                ldy #>xt_drop
.97e3	a9 0f		lda #$0f	                lda #<xt_drop
.97e5	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.97e8	60		rts		z_of:           rts
.97e9					xt_editor_wordlist:
.97e9					xt_one:
.97e9	ca		dex		                dex
.97ea	ca		dex		                dex
.97eb	a9 01		lda #$01	                lda #1
.97ed	95 00		sta $00,x	                sta 0,x
.97ef	74 01		stz $01,x	                stz 1,x
.97f1					z_editor_wordlist:
.97f1					z_one:
.97f1	60		rts		                rts
.97f2					xt_one_minus:
.97f2	20 f6 d7	jsr $d7f6	                jsr underflow_1
.97f5	b5 00		lda $00,x	                lda 0,x
.97f7	d0 02		bne $97fb	                bne +
.97f9	d6 01		dec $01,x	                dec 1,x
.97fb					+
.97fb	d6 00		dec $00,x	                dec 0,x
.97fd	60		rts		z_one_minus:    rts
.97fe					xt_char_plus:
.97fe					xt_one_plus:
.97fe	20 f6 d7	jsr $d7f6	                jsr underflow_1
.9801	f6 00		inc $00,x	                inc 0,x
.9803	d0 02		bne $9807	                bne _done
.9805	f6 01		inc $01,x	                inc 1,x
.9807					_done:
.9807					z_char_plus:
.9807	60		rts		z_one_plus:     rts
.9808					xt_only:
.9808	ca		dex		                dex
.9809	ca		dex		                dex
.980a	a9 ff		lda #$ff	                lda #$FF
.980c	95 00		sta $00,x	                sta 0,x
.980e	95 01		sta $01,x	                sta 1,x
.9810	20 fc 9c	jsr $9cfc	                jsr xt_set_order
.9813	60		rts		z_only:         rts
.9814					xt_or:
.9814	20 fb d7	jsr $d7fb	                jsr underflow_2
.9817	b5 00		lda $00,x	                lda 0,x
.9819	15 02		ora $02,x	                ora 2,x
.981b	95 02		sta $02,x	                sta 2,x
.981d	b5 01		lda $01,x	                lda 1,x
.981f	15 03		ora $03,x	                ora 3,x
.9821	95 03		sta $03,x	                sta 3,x
.9823	e8		inx		                inx
.9824	e8		inx		                inx
.9825	60		rts		z_or:           rts
.9826					xt_order:
.9826	20 44 89	jsr $8944	                jsr xt_cr
.9829	20 15 91	jsr $9115	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.982c	b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.982e	f0 1e		beq $984e	                beq _drop_done
.9830					_have_wordlists:
.9830	a8		tay		                tay
.9831					_loop:
.9831	e8		inx		                inx
.9832	e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.9833	b5 00		lda $00,x	                lda 0,x
.9835	5a		phy		                phy
.9836	20 51 98	jsr $9851	                jsr order_print_wid_string   ; internal helper function
.9839	7a		ply		                ply
.983a	88		dey		                dey
.983b	d0 f4		bne $9831	                bne _loop
.983d	20 d0 a0	jsr $a0d0	                jsr xt_space
.9840	20 d0 a0	jsr $a0d0	                jsr xt_space
.9843	20 0a 91	jsr $910a	                jsr xt_get_current      ; ( wid )
.9846	b5 00		lda $00,x	                lda 0,x
.9848	20 51 98	jsr $9851	                jsr order_print_wid_string
.984b	20 44 89	jsr $8944	                jsr xt_cr
.984e					_drop_done:
.984e	e8		inx		                inx
.984f	e8		inx		                inx
.9850					z_order:
.9850	60		rts		                rts
.9851					order_print_wid_string:
.9851	c9 04		cmp #$04	                cmp #4
.9853	90 09		bcc $985e	                bcc _output_string      ; less than 4, print a real string
.9855	ca		dex		                dex
.9856	ca		dex		                dex
.9857	95 00		sta $00,x	                sta 0,x
.9859	74 01		stz $01,x	                stz 1,x
.985b	4c e0 a4	jmp $a4e0	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.985e					_output_string:
.985e	a8		tay		                tay
.985f	b9 65 98	lda $9865,y	                lda _wid_data,y
.9862	4c 32 d8	jmp $d832	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.9865					_wid_data:
>9865	03				        .byte str_wid_forth            ; WID 0: "Forth"
>9866	06				        .byte str_wid_editor           ; WID 1: "Editor"
>9867	07				        .byte str_wid_assembler        ; WID 2: "Assembler"
>9868	08				        .byte str_wid_root             ; WID 3: "Root"
.9869					xt_output:
.9869	ca		dex		                dex
.986a	ca		dex		                dex
.986b	a9 10		lda #$10	                lda #<output
.986d	95 00		sta $00,x	                sta 0,x
.986f	a9 00		lda #$00	                lda #>output
.9871	95 01		sta $01,x	                sta 1,x
.9873	60		rts		z_output:       rts
.9874					xt_over:
.9874	20 fb d7	jsr $d7fb	                jsr underflow_2
.9877	ca		dex		                dex
.9878	ca		dex		                dex
.9879	b5 04		lda $04,x	                lda 4,x         ; LSB
.987b	95 00		sta $00,x	                sta 0,x
.987d	b5 05		lda $05,x	                lda 5,x         ; MSB
.987f	95 01		sta $01,x	                sta 1,x
.9881	60		rts		z_over:         rts
.9882					xt_pad:
.9882	ca		dex		                dex
.9883	ca		dex		                dex
.9884	a5 00		lda $00		                lda cp
.9886	18		clc		                clc
.9887	69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.9889	95 00		sta $00,x	                sta 0,x
.988b	a5 01		lda $01		                lda cp+1
.988d	69 00		adc #$00	                adc #0          ; only need carry
.988f	95 01		sta $01,x	                sta 1,x
.9891	60		rts		z_pad:          rts
.9892					xt_page:
.9892	a9 1b		lda #$1b	                lda #AscESC
.9894	20 d7 8d	jsr $8dd7	                jsr emit_a
.9897	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.9899	20 d7 8d	jsr $8dd7	                jsr emit_a
.989c	a9 32		lda #$32	                lda #'2'
.989e	20 d7 8d	jsr $8dd7	                jsr emit_a
.98a1	a9 4a		lda #$4a	                lda #'J'
.98a3	20 d7 8d	jsr $8dd7	                jsr emit_a
.98a6	20 5a a7	jsr $a75a	                jsr xt_zero
.98a9	20 5a a7	jsr $a75a	                jsr xt_zero
.98ac	20 31 83	jsr $8331	                jsr xt_at_xy
.98af	60		rts		z_page:         rts
.98b0					xt_paren:
.98b0	ca		dex		                dex
.98b1	ca		dex		                dex
.98b2	a9 29		lda #$29	                lda #41     ; Right parenthesis
.98b4	95 00		sta $00,x	                sta 0,x
.98b6	74 01		stz $01,x	                stz 1,x
.98b8	20 1b 99	jsr $991b	                jsr xt_parse
.98bb	e8		inx		                inx
.98bc	e8		inx		                inx
.98bd	e8		inx		                inx
.98be	e8		inx		                inx
.98bf	60		rts		z_paren:        rts
.98c0					xt_parse_name:
.98c0	a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98c2	38		sec		                sec
.98c3	e5 0c		sbc $0c		                sbc toin
.98c5	85 24		sta $24		                sta tmp1
.98c7	a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98c9	e5 0d		sbc $0d		                sbc toin+1
.98cb	85 25		sta $25		                sta tmp1+1
.98cd	a5 24		lda $24		                lda tmp1
.98cf	05 25		ora $25		                ora tmp1+1
.98d1	f0 28		beq $98fb	                beq _empty_line
.98d3	a5 08		lda $08		                lda cib
.98d5	18		clc		                clc
.98d6	65 0c		adc $0c		                adc toin
.98d8	85 26		sta $26		                sta tmp2                ; LSB of first character
.98da	a5 09		lda $09		                lda cib+1
.98dc	65 0d		adc $0d		                adc toin+1
.98de	85 27		sta $27		                sta tmp2+1              ; MSB
.98e0					_skip_loop:
.98e0	b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.98e2	20 e9 d7	jsr $d7e9	                jsr is_whitespace
.98e5	90 1f		bcc $9906	                bcc _char_found
.98e7	e6 26		inc $26		                inc tmp2
.98e9	d0 02		bne $98ed	                bne +
.98eb	e6 27		inc $27		                inc tmp2+1
.98ed					+
.98ed	a5 24		lda $24		                lda tmp1
.98ef	d0 02		bne $98f3	                bne +
.98f1	c6 25		dec $25		                dec tmp1+1
.98f3	c6 24		dec $24		+               dec tmp1
.98f5	a5 24		lda $24		                lda tmp1
.98f7	05 25		ora $25		                ora tmp1+1
.98f9	d0 e5		bne $98e0	                bne _skip_loop          ; fall through if empty line
.98fb					_empty_line:
.98fb	ca		dex		                dex
.98fc	ca		dex		                dex
.98fd	ca		dex		                dex
.98fe	ca		dex		                dex
.98ff	74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.9901	74 01		stz $01,x	                stz 1,x
.9903	4c b2 99	jmp $99b2	                jmp z_parse_name        ; skip over PARSE
.9906					_char_found:
.9906	a5 26		lda $26		                lda tmp2
.9908	38		sec		                sec
.9909	e5 08		sbc $08		                sbc cib
.990b	85 0c		sta $0c		                sta toin
.990d	a5 27		lda $27		                lda tmp2+1
.990f	e5 09		sbc $09		                sbc cib+1
.9911	85 0d		sta $0d		                sta toin+1
.9913	ca		dex		                dex
.9914	ca		dex		                dex
.9915	a9 20		lda #$20	                lda #AscSP
.9917	95 00		sta $00,x	                sta 0,x
.9919	74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.991b					xt_parse:
.991b	20 f6 d7	jsr $d7f6	                jsr underflow_1
.991e	a5 0a		lda $0a		                lda ciblen
.9920	05 0b		ora $0b		                ora ciblen+1
.9922	f0 0c		beq $9930	                beq _abort_parse
.9924	a5 0d		lda $0d		                lda toin+1              ; MSB
.9926	c5 0b		cmp $0b		                cmp ciblen+1
.9928	90 0e		bcc $9938	                bcc _go_parse           ; unsigned comparison
.992a	a5 0c		lda $0c		                lda toin                ; LSB
.992c	c5 0a		cmp $0a		                cmp ciblen
.992e	90 08		bcc $9938	                bcc _go_parse
.9930					_abort_parse:
.9930	ca		dex		                dex
.9931	ca		dex		                dex
.9932	74 00		stz $00,x	                stz 0,x
.9934	74 01		stz $01,x	                stz 1,x
.9936	80 7a		bra $99b2	                bra _done
.9938					_go_parse:
.9938	b5 00		lda $00,x	                lda 0,x
.993a	85 2c		sta $2c		                sta tmptos
.993c	ca		dex		                dex
.993d	ca		dex		                dex
.993e	a5 08		lda $08		                lda cib
.9940	18		clc		                clc
.9941	65 0c		adc $0c		                adc toin        ; LSB
.9943	85 24		sta $24		                sta tmp1
.9945	85 26		sta $26		                sta tmp2
.9947	95 02		sta $02,x	                sta 2,x
.9949	a5 09		lda $09		                lda cib+1
.994b	65 0d		adc $0d		                adc toin+1      ; MSB
.994d	85 25		sta $25		                sta tmp1+1
.994f	85 27		sta $27		                sta tmp2+1
.9951	95 03		sta $03,x	                sta 3,x
.9953	a5 08		lda $08		                lda cib
.9955	18		clc		                clc
.9956	65 0a		adc $0a		                adc ciblen
.9958	85 28		sta $28		                sta tmp3
.995a	a5 09		lda $09		                lda cib+1
.995c	65 0b		adc $0b		                adc ciblen+1
.995e	85 29		sta $29		                sta tmp3+1
.9960	64 2d		stz $2d		                stz tmptos+1
.9962					_loop:
.9962	a5 26		lda $26		                lda tmp2
.9964	c5 28		cmp $28		                cmp tmp3
.9966	d0 06		bne $996e	                bne _not_empty
.9968	a5 27		lda $27		                lda tmp2+1
.996a	c5 29		cmp $29		                cmp tmp3+1
.996c	f0 1d		beq $998b	                beq _eol
.996e					_not_empty:
.996e	b2 26		lda ($26)	                lda (tmp2)
.9970	a4 2c		ldy $2c		                ldy tmptos
.9972	c0 20		cpy #$20	                cpy #AscSP
.9974	d0 07		bne $997d	                bne _not_whitespace
.9976	20 e9 d7	jsr $d7e9	                jsr is_whitespace
.9979	90 02		bcc $997d	                bcc _not_whitespace
.997b	80 0c		bra $9989	                bra _found_delimiter
.997d					_not_whitespace:
.997d	c5 2c		cmp $2c		                cmp tmptos
.997f	f0 08		beq $9989	                beq _found_delimiter
.9981	e6 26		inc $26		                inc tmp2
.9983	d0 dd		bne $9962	                bne _loop
.9985	e6 27		inc $27		                inc tmp2+1
.9987	80 d9		bra $9962	                bra _loop
.9989					_found_delimiter:
.9989	e6 2d		inc $2d		                inc tmptos+1
.998b					_eol:
.998b	a5 26		lda $26		                lda tmp2
.998d	38		sec		                sec
.998e	e5 24		sbc $24		                sbc tmp1
.9990	95 00		sta $00,x	                sta 0,x
.9992	a5 27		lda $27		                lda tmp2+1
.9994	e5 25		sbc $25		                sbc tmp1+1
.9996	95 01		sta $01,x	                sta 1,x
.9998	a5 26		lda $26		                lda tmp2
.999a	38		sec		                sec
.999b	e5 08		sbc $08		                sbc cib
.999d	85 0c		sta $0c		                sta toin
.999f	a5 27		lda $27		                lda tmp2+1
.99a1	e5 09		sbc $09		                sbc cib+1
.99a3	85 0d		sta $0d		                sta toin+1
.99a5	a5 0c		lda $0c		                lda toin
.99a7	18		clc		                clc
.99a8	65 2d		adc $2d		                adc tmptos+1
.99aa	85 0c		sta $0c		                sta toin
.99ac	a5 0d		lda $0d		                lda toin+1
.99ae	69 00		adc #$00	                adc #0          ; we only need the carry
.99b0	85 0d		sta $0d		                sta toin+1
.99b2					_done:
.99b2					z_parse_name:
.99b2	60		rts		z_parse:        rts
.99b3					xt_pick:
.99b3	16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99b5	8a		txa		                txa
.99b6	75 00		adc $00,x	                adc 0,x
.99b8	a8		tay		                tay
.99b9	b9 02 00	lda $0002,y	                lda 0002,y
.99bc	95 00		sta $00,x	                sta 0,x
.99be	b9 03 00	lda $0003,y	                lda 0003,y
.99c1	95 01		sta $01,x	                sta 1,x
.99c3	60		rts		z_pick:         rts
.99c4					xt_plus:
.99c4	20 fb d7	jsr $d7fb	                jsr underflow_2
.99c7	18		clc		                clc
.99c8	b5 00		lda $00,x	                lda 0,x         ; LSB
.99ca	75 02		adc $02,x	                adc 2,x
.99cc	95 02		sta $02,x	                sta 2,x
.99ce	b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99d0	75 03		adc $03,x	                adc 3,x
.99d2	95 03		sta $03,x	                sta 3,x
.99d4	e8		inx		                inx
.99d5	e8		inx		                inx
.99d6	60		rts		z_plus:         rts
.99d7					xt_plus_store:
.99d7	20 fb d7	jsr $d7fb	                jsr underflow_2
.99da	b5 00		lda $00,x	                lda 0,x
.99dc	85 24		sta $24		                sta tmp1
.99de	b5 01		lda $01,x	                lda 1,x
.99e0	85 25		sta $25		                sta tmp1+1
.99e2	a0 00		ldy #$00	                ldy #0          ; LSB
.99e4	b1 24		lda ($24),y	                lda (tmp1),y
.99e6	18		clc		                clc
.99e7	75 02		adc $02,x	                adc 2,x
.99e9	91 24		sta ($24),y	                sta (tmp1),y
.99eb	c8		iny		                iny             ; MSB
.99ec	b1 24		lda ($24),y	                lda (tmp1),y
.99ee	75 03		adc $03,x	                adc 3,x
.99f0	91 24		sta ($24),y	                sta (tmp1),y
.99f2	e8		inx		                inx
.99f3	e8		inx		                inx
.99f4	e8		inx		                inx
.99f5	e8		inx		                inx
.99f6	60		rts		z_plus_store:   rts
.99f7					xt_postpone:
.99f7	20 c0 98	jsr $98c0	                jsr xt_parse_name               ; ( -- addr n )
.99fa	b5 00		lda $00,x	                lda 0,x
.99fc	15 01		ora $01,x	                ora 1,x
.99fe	d0 05		bne $9a05	                bne +
.9a00	a9 05		lda #$05	                lda #err_noname
.9a02	4c 0c d8	jmp $d80c	                jmp error
.9a05					+
.9a05	20 bc 8f	jsr $8fbc	                jsr xt_find_name                ; ( -- nt | 0 )
.9a08	d0 05		bne $9a0f	                bne +
.9a0a	a9 05		lda #$05	                lda #err_noname
.9a0c	4c 0c d8	jmp $d80c	                jmp error
.9a0f					+
.9a0f	b5 00		lda $00,x	                lda 0,x
.9a11	85 24		sta $24		                sta tmp1
.9a13	b5 01		lda $01,x	                lda 1,x
.9a15	85 25		sta $25		                sta tmp1+1
.9a17	20 c2 95	jsr $95c2	                jsr xt_name_to_int              ; ( nt -- xt )
.9a1a	e6 24		inc $24		                inc tmp1
.9a1c	d0 02		bne $9a20	                bne +
.9a1e	e6 25		inc $25		                inc tmp1+1
.9a20					+
.9a20	b2 24		lda ($24)	                lda (tmp1)
.9a22	29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a24	f0 05		beq $9a2b	                beq _not_immediate
.9a26	20 ce 87	jsr $87ce	                jsr xt_compile_comma
.9a29	80 0a		bra $9a35	                bra _done
.9a2b					_not_immediate:
.9a2b	20 6b 93	jsr $936b	                jsr xt_literal
.9a2e	a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a30	a9 ce		lda #$ce	                lda #<xt_compile_comma
.9a32	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.9a35					_done:
.9a35	60		rts		z_postpone:     rts
.9a36					xt_previous:
.9a36	20 15 91	jsr $9115	                jsr xt_get_order
.9a39	20 23 96	jsr $9623	                jsr xt_nip
.9a3c	20 f2 97	jsr $97f2	                jsr xt_one_minus
.9a3f	20 fc 9c	jsr $9cfc	                jsr xt_set_order
.9a42	60		rts		z_previous:     rts
.9a43					xt_question:
.9a43	20 61 8f	jsr $8f61	                jsr xt_fetch
.9a46	20 17 8c	jsr $8c17	                jsr xt_dot
.9a49	60		rts		z_question:     rts
.9a4a					xt_question_dup:
.9a4a	20 f6 d7	jsr $d7f6	                jsr underflow_1
.9a4d	b5 00		lda $00,x	                lda 0,x
.9a4f	15 01		ora $01,x	                ora 1,x
.9a51	f0 0a		beq $9a5d	                beq _done
.9a53	ca		dex		                dex
.9a54	ca		dex		                dex
.9a55	b5 02		lda $02,x	                lda 2,x
.9a57	95 00		sta $00,x	                sta 0,x
.9a59	b5 03		lda $03,x	                lda 3,x
.9a5b	95 01		sta $01,x	                sta 1,x
.9a5d					_done:
.9a5d	60		rts		z_question_dup: rts
.9a5e					xt_r_fetch:
.9a5e	7a		ply		                ply             ; LSB
.9a5f	84 24		sty $24		                sty tmp1
.9a61	7a		ply		                ply             ; MSB
.9a62	ca		dex		                dex
.9a63	ca		dex		                dex
.9a64	68		pla		                pla             ; LSB
.9a65	95 00		sta $00,x	                sta 0,x
.9a67	68		pla		                pla             ; MSB
.9a68	95 01		sta $01,x	                sta 1,x
.9a6a	48		pha		                pha
.9a6b	b5 00		lda $00,x	                lda 0,x
.9a6d	48		pha		                pha
.9a6e	5a		phy		                phy             ; MSB
.9a6f	a4 24		ldy $24		                ldy tmp1
.9a71	5a		phy		                phy             ; LSB
.9a72	60		rts		z_r_fetch:      rts
.9a73					xt_r_from:
.9a73	68		pla		                pla             ; LSB
.9a74	85 2c		sta $2c		                sta tmptos
.9a76	7a		ply		                ply             ; MSB
.9a77	ca		dex		                dex
.9a78	ca		dex		                dex
.9a79	68		pla		                pla             ; LSB
.9a7a	95 00		sta $00,x	                sta 0,x
.9a7c	68		pla		                pla             ; MSB
.9a7d	95 01		sta $01,x	                sta 1,x
.9a7f	5a		phy		                phy             ; MSB
.9a80	a5 2c		lda $2c		                lda tmptos
.9a82	48		pha		                pha             ; LSB
.9a83	60		rts		z_r_from:       rts
.9a84					xt_r_to_input:
.9a84	68		pla		                pla
.9a85	85 24		sta $24		                sta tmp1
.9a87	68		pla		                pla
.9a88	85 25		sta $25		                sta tmp1+1
.9a8a	a0 00		ldy #$00	                ldy #0
.9a8c					_loop:
.9a8c	68		pla		                pla
.9a8d	99 06 00	sta $0006,y	                sta insrc,y
.9a90	c8		iny		                iny
.9a91	c0 08		cpy #$08	                cpy #8
.9a93	d0 f7		bne $9a8c	                bne _loop
.9a95	a5 25		lda $25		                lda tmp1+1
.9a97	48		pha		                pha
.9a98	a5 24		lda $24		                lda tmp1
.9a9a	48		pha		                pha
.9a9b	60		rts		z_r_to_input: 	rts
.9a9c					xt_recurse:
.9a9c	a0 00		ldy #$00	                ldy #0
.9a9e	a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9aa0	91 00		sta ($00),y	                sta (cp),y
.9aa2	c8		iny		                iny
.9aa3	24 20		bit $20		                bit status
.9aa5	70 0c		bvs $9ab3	                bvs _nt_in_workword
.9aa7	a5 04		lda $04		                lda workword
.9aa9	91 00		sta ($00),y	                sta (cp),y
.9aab	c8		iny		                iny
.9aac	a5 05		lda $05		                lda workword+1
.9aae	91 00		sta ($00),y	                sta (cp),y
.9ab0	c8		iny		                iny
.9ab1	80 1b		bra $9ace	                bra _update_cp
.9ab3					_nt_in_workword:
.9ab3	a5 04		lda $04		                lda workword            ; LSB
.9ab5	18		clc		                clc
.9ab6	69 04		adc #$04	                adc #4
.9ab8	85 24		sta $24		                sta tmp1
.9aba	a5 05		lda $05		                lda workword+1          ; MSB
.9abc	69 00		adc #$00	                adc #0
.9abe	85 25		sta $25		                sta tmp1+1
.9ac0	b2 24		lda ($24)	                lda (tmp1)
.9ac2	91 00		sta ($00),y	                sta (cp),y
.9ac4	5a		phy		                phy
.9ac5	a0 01		ldy #$01	                ldy #1
.9ac7	b1 24		lda ($24),y	                lda (tmp1),y
.9ac9	7a		ply		                ply
.9aca	c8		iny		                iny
.9acb	91 00		sta ($00),y	                sta (cp),y
.9acd	c8		iny		                iny
.9ace					_update_cp:
.9ace	98		tya		                tya
.9acf	18		clc		                clc
.9ad0	65 00		adc $00		                adc cp
.9ad2	85 00		sta $00		                sta cp
.9ad4	90 02		bcc $9ad8	                bcc _done
.9ad6	e6 01		inc $01		                inc cp+1
.9ad8					_done:
.9ad8	60		rts		z_recurse:      rts
.9ad9					xt_refill:
.9ad9	a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9adb	d0 2d		bne $9b0a	                bne _src_not_kbd
.9add	ca		dex		                dex
.9ade	ca		dex		                dex
.9adf	ca		dex		                dex
.9ae0	ca		dex		                dex
.9ae1	a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9ae3	95 02		sta $02,x	                sta 2,x
.9ae5	a5 09		lda $09		                lda cib+1
.9ae7	95 03		sta $03,x	                sta 3,x
.9ae9	64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9aeb	64 0b		stz $0b		                stz ciblen+1
.9aed	a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9aef	95 00		sta $00,x	                sta 0,x
.9af1	74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9af3	20 2f 81	jsr $812f	                jsr xt_accept           ; ( addr n1 -- n2)
.9af6	b5 00		lda $00,x	                lda 0,x
.9af8	85 0a		sta $0a		                sta ciblen
.9afa	b5 01		lda $01,x	                lda 1,x
.9afc	85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9afe	64 0c		stz $0c		                stz toin
.9b00	64 0d		stz $0d		                stz toin+1
.9b02	a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b04	95 00		sta $00,x	                sta 0,x
.9b06	95 01		sta $01,x	                sta 1,x
.9b08	80 10		bra $9b1a	                bra _done
.9b0a					_src_not_kbd:
.9b0a	1a		inc a		                ina
.9b0b	d0 08		bne $9b15	                bne _src_not_string
.9b0d	ca		dex		                dex
.9b0e	ca		dex		                dex
.9b0f	74 00		stz $00,x	                stz 0,x
.9b11	74 01		stz $01,x	                stz 1,x
.9b13	80 05		bra $9b1a	                bra z_refill
.9b15					_src_not_string:
.9b15	a9 01		lda #$01	                lda #err_badsource
.9b17	4c 0c d8	jmp $d80c	                jmp error
.9b1a					_done:
.9b1a	60		rts		z_refill:       rts
.9b1b					xt_repeat:
.9b1b	20 6a 82	jsr $826a	                jsr xt_again
.9b1e	20 53 91	jsr $9153	                jsr xt_here
.9b21	20 60 a1	jsr $a160	                jsr xt_swap
.9b24	20 3f a1	jsr $a13f	                jsr xt_store
.9b27	60		rts		z_repeat:       rts
.9b28					xt_right_bracket:
.9b28	a9 ff		lda #$ff	                lda #$FF
.9b2a	85 16		sta $16		                sta state
.9b2c	85 17		sta $17		                sta state+1
.9b2e					z_right_bracket:
.9b2e	60		rts		                rts
.9b2f					xt_root_wordlist:
.9b2f	ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b30	ca		dex		                dex
.9b31	a9 03		lda #$03	                lda #3
.9b33	95 00		sta $00,x	                sta 0,x
.9b35	74 01		stz $01,x	                stz 1,x
.9b37					z_root_wordlist:
.9b37	60		rts		                rts
.9b38					xt_rot:
.9b38	20 00 d8	jsr $d800	                jsr underflow_3
.9b3b	b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b3d	b5 03		lda $03,x	                lda 3,x
.9b3f	95 05		sta $05,x	                sta 5,x
.9b41	b5 01		lda $01,x	                lda 1,x
.9b43	95 03		sta $03,x	                sta 3,x
.9b45	94 01		sty $01,x	                sty 1,x
.9b47	b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b49	b5 02		lda $02,x	                lda 2,x
.9b4b	95 04		sta $04,x	                sta 4,x
.9b4d	b5 00		lda $00,x	                lda 0,x
.9b4f	95 02		sta $02,x	                sta 2,x
.9b51	94 00		sty $00,x	                sty 0,x
.9b53	60		rts		z_rot:          rts
.9b54					xt_rshift:
.9b54	20 fb d7	jsr $d7fb	                jsr underflow_2
.9b57	b5 00		lda $00,x	                lda 0,x
.9b59	29 0f		and #$0f	                and #%00001111
.9b5b	f0 08		beq $9b65	                beq _done               ; if 0 shifts, quit
.9b5d	a8		tay		                tay
.9b5e					_loop:
.9b5e	56 03		lsr $03,x	                lsr 3,x
.9b60	76 02		ror $02,x	                ror 2,x
.9b62	88		dey		                dey
.9b63	d0 f9		bne $9b5e	                bne _loop
.9b65					_done:
.9b65	e8		inx		                inx
.9b66	e8		inx		                inx
.9b67	60		rts		z_rshift:       rts
.9b68					xt_s_backslash_quote:
.9b68	a9 ff		lda #$ff	                lda #$FF
.9b6a	85 26		sta $26		                sta tmp2
.9b6c	64 27		stz $27		                stz tmp2+1
.9b6e	20 34 9d	jsr $9d34	                jsr s_quote_start
.9b71					_done:
.9b71					z_s_backslash_quote:
.9b71	60		rts		                rts
.9b72					convert_hex_value:
.9b72	c9 41		cmp #$41	        cmp #'A'
.9b74	90 07		bcc $9b7d	        bcc _digit
.9b76	29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b78	38		sec		        sec
.9b79	e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b7b	80 03		bra $9b80	        bra _done
.9b7d					_digit:
.9b7d	38		sec		        sec
.9b7e	e9 30		sbc #$30	        sbc #'0'
.9b80					_done:
.9b80	60		rts		        rts
.9b81					xt_search_wordlist:
.9b81	20 00 d8	jsr $d800	                jsr underflow_3
.9b84	a5 1e		lda $1e		                lda up
.9b86	18		clc		                clc
.9b87	69 06		adc #$06	                adc #wordlists_offset
.9b89	85 26		sta $26		                sta tmp2
.9b8b	a5 1f		lda $1f		                lda up+1
.9b8d	69 00		adc #$00	                adc #0          ; Adding carry
.9b8f	85 27		sta $27		                sta tmp2+1
.9b91	b5 00		lda $00,x	                lda 0,x
.9b93	0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9b94	65 26		adc $26		                adc tmp2
.9b96	85 26		sta $26		                sta tmp2
.9b98	90 02		bcc $9b9c	                bcc +
.9b9a	e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9b9c					+
.9b9c	e8		inx		                inx
.9b9d	e8		inx		                inx
.9b9e	b5 00		lda $00,x	                lda 0,x
.9ba0	15 01		ora $01,x	                ora 1,x
.9ba2	d0 03		bne $9ba7	                bne _check_wordlist
.9ba4	4c 5f 9c	jmp $9c5f	                jmp _done
.9ba7					_check_wordlist:
.9ba7	a5 26		lda $26		                lda tmp2
.9ba9	05 27		ora $27		                ora tmp2+1
.9bab	d0 03		bne $9bb0	                bne _have_string
.9bad	4c 5f 9c	jmp $9c5f	                jmp _done
.9bb0					_have_string:
.9bb0	b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9bb2	85 24		sta $24		                sta tmp1
.9bb4	e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9bb6	d0 02		bne $9bba	                bne +
.9bb8	e6 27		inc $27		                inc tmp2+1
.9bba					+
.9bba	b2 26		lda ($26)	                lda (tmp2)
.9bbc	85 25		sta $25		                sta tmp1+1
.9bbe	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9bc0	85 26		sta $26		                sta tmp2
.9bc2	b5 03		lda $03,x	                lda 3,x
.9bc4	85 27		sta $27		                sta tmp2+1
.9bc6					_loop:
.9bc6	b2 24		lda ($24)	                lda (tmp1)
.9bc8	d5 00		cmp $00,x	                cmp 0,x
.9bca	d0 7b		bne $9c47	                bne _next_entry
.9bcc					_compare_string:
.9bcc	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9bce	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bd0	b0 07		bcs $9bd9	                bcs _compare_first
.9bd2	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bd4	90 03		bcc $9bd9	                bcc _compare_first
.9bd6	18		clc		                clc
.9bd7	69 20		adc #$20	                adc #$20
.9bd9					_compare_first:
.9bd9	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9bdb	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9bdd	d0 68		bne $9c47	                bne _next_entry
.9bdf	b5 00		lda $00,x	                lda 0,x
.9be1	3a		dec a		                dea
.9be2	f0 2c		beq $9c10	                beq _success
.9be4	a5 24		lda $24		                lda tmp1
.9be6	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9be7	18		clc		                clc
.9be8	69 08		adc #$08	                adc #8
.9bea	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9bec	a5 25		lda $25		                lda tmp1+1
.9bee	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9bef	69 00		adc #$00	                adc #0          ; we only need the carry
.9bf1	85 25		sta $25		                sta tmp1+1
.9bf3	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9bf5	88		dey		                dey
.9bf6					_string_loop:
.9bf6	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9bf8	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9bfa	b0 07		bcs $9c03	                bcs _check_char
.9bfc	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bfe	90 03		bcc $9c03	                bcc _check_char
.9c00	18		clc		                clc
.9c01	69 20		adc #$20	                adc #$20
.9c03					_check_char:
.9c03	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c05	d0 3a		bne $9c41	                bne _next_entry_tmp1
.9c07	88		dey		                dey
.9c08	d0 ec		bne $9bf6	                bne _string_loop
.9c0a					_success_tmp1:
.9c0a	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c0b	85 25		sta $25		                sta tmp1+1
.9c0d	68		pla		                pla
.9c0e	85 24		sta $24		                sta tmp1
.9c10					_success:
.9c10	e8		inx		                inx
.9c11	e8		inx		                inx
.9c12	a5 24		lda $24		                lda tmp1
.9c14	95 00		sta $00,x	                sta 0,x
.9c16	a5 25		lda $25		                lda tmp1+1
.9c18	95 01		sta $01,x	                sta 1,x
.9c1a	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( nt nt )
.9c1d	20 c2 95	jsr $95c2	                jsr xt_name_to_int      ; ( nt xt )
.9c20	20 60 a1	jsr $a160	                jsr xt_swap             ; ( xt nt )
.9c23	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c25	f6 00		inc $00,x	                inc 0,x
.9c27	d0 02		bne $9c2b	                bne +
.9c29	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c2b					+
.9c2b	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c2d	29 04		and #$04	                and #IM
.9c2f	d0 08		bne $9c39	                bne _immediate          ; bit set, we're immediate
.9c31	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c33	95 00		sta $00,x	                sta 0,x
.9c35	95 01		sta $01,x	                sta 1,x
.9c37	80 28		bra $9c61	                bra _done_nodrop
.9c39					_immediate:
.9c39	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c3b	95 00		sta $00,x	                sta 0,x
.9c3d	74 01		stz $01,x	                stz 1,x
.9c3f	80 20		bra $9c61	                bra _done_nodrop
.9c41					_next_entry_tmp1:
.9c41	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c42	85 25		sta $25		                sta tmp1+1
.9c44	68		pla		                pla
.9c45	85 24		sta $24		                sta tmp1
.9c47					_next_entry:
.9c47	a0 02		ldy #$02	                ldy #2
.9c49	b1 24		lda ($24),y	                lda (tmp1),y
.9c4b	48		pha		                pha
.9c4c	c8		iny		                iny
.9c4d	b1 24		lda ($24),y	                lda (tmp1),y
.9c4f	85 25		sta $25		                sta tmp1+1
.9c51	68		pla		                pla
.9c52	85 24		sta $24		                sta tmp1
.9c54	05 25		ora $25		                ora tmp1+1
.9c56	f0 03		beq $9c5b	                beq _fail_done
.9c58	4c c6 9b	jmp $9bc6	                jmp _loop
.9c5b					_fail_done:
.9c5b	74 02		stz $02,x	                stz 2,x         ; failure flag
.9c5d	74 03		stz $03,x	                stz 3,x
.9c5f					_done:
.9c5f	e8		inx		                inx
.9c60	e8		inx		                inx
.9c61					_done_nodrop:
.9c61					z_search_wordlist:
.9c61	60		rts		                rts
.9c62					xt_see:
.9c62	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( addr u )
.9c65	20 bc 8f	jsr $8fbc	                jsr xt_find_name        ; ( nt | 0 )
.9c68	b5 00		lda $00,x	                lda 0,x
.9c6a	15 01		ora $01,x	                ora 1,x
.9c6c	d0 05		bne $9c73	                bne +
.9c6e	a9 05		lda #$05	                lda #err_noname
.9c70	4c 0c d8	jmp $d80c	                jmp error
.9c73					+
.9c73	20 44 89	jsr $8944	                jsr xt_cr
.9c76	a5 18		lda $18		                lda base
.9c78	48		pha		                pha
.9c79	20 5e 91	jsr $915e	                jsr xt_hex
.9c7c	a9 0a		lda #$0a	                lda #str_see_nt
.9c7e	20 32 d8	jsr $d832	                jsr print_string_no_lf
.9c81	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( nt nt )
.9c84	20 e0 a4	jsr $a4e0	                jsr xt_u_dot
.9c87	20 d0 a0	jsr $a0d0	                jsr xt_space            ; ( nt )
.9c8a	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( nt nt )
.9c8d	20 c2 95	jsr $95c2	                jsr xt_name_to_int      ; ( nt xt )
.9c90	a9 0b		lda #$0b	                lda #str_see_xt
.9c92	20 32 d8	jsr $d832	                jsr print_string_no_lf
.9c95	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( nt xt xt )
.9c98	20 e0 a4	jsr $a4e0	                jsr xt_u_dot
.9c9b	20 44 89	jsr $8944	                jsr xt_cr               ; ( nt xt )
.9c9e	a9 09		lda #$09	                lda #str_see_flags
.9ca0	20 32 d8	jsr $d832	                jsr print_string_no_lf
.9ca3	20 74 98	jsr $9874	                jsr xt_over             ; ( nt xt nt )
.9ca6	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9ca9	20 61 8f	jsr $8f61	                jsr xt_fetch            ; ( nt xt flags )
.9cac	b5 00		lda $00,x	                lda 0,x
.9cae	a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9cb0					_flag_loop:
.9cb0	48		pha		                pha
.9cb1	29 01		and #$01	                and #%00000001
.9cb3	18		clc		                clc
.9cb4	69 30		adc #$30	                adc #$30                ; ASCII "0"
.9cb6	20 d7 8d	jsr $8dd7	                jsr emit_a
.9cb9	20 d0 a0	jsr $a0d0	                jsr xt_space
.9cbc	68		pla		                pla
.9cbd	6a		ror a		                ror                     ; Next flag
.9cbe	88		dey		                dey
.9cbf	d0 ef		bne $9cb0	                bne _flag_loop
.9cc1	20 44 89	jsr $8944	                jsr xt_cr
.9cc4	e8		inx		                inx
.9cc5	e8		inx		                inx                     ; ( nt xt )
.9cc6	a9 0c		lda #$0c	                lda #str_see_size
.9cc8	20 32 d8	jsr $d832	                jsr print_string_no_lf
.9ccb	20 60 a1	jsr $a160	                jsr xt_swap             ; ( xt nt )
.9cce	20 27 a7	jsr $a727	                jsr xt_wordsize         ; ( xt u )
.9cd1	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9cd4	20 86 8a	jsr $8a86	                jsr xt_decimal
.9cd7	20 e0 a4	jsr $a4e0	                jsr xt_u_dot            ; ( xt u )
.9cda	20 5e 91	jsr $915e	                jsr xt_hex
.9cdd	20 44 89	jsr $8944	                jsr xt_cr
.9ce0	20 6a a3	jsr $a36a	                jsr xt_two_dup          ; ( xt u xt u )
.9ce3	20 15 8d	jsr $8d15	                jsr xt_dump
.9ce6	20 44 89	jsr $8944	                jsr xt_cr
.9ce9	20 1b 8b	jsr $8b1b	                jsr xt_disasm
.9cec	68		pla		                pla
.9ced	85 18		sta $18		                sta base
.9cef	60		rts		z_see:          rts
.9cf0					xt_set_current:
.9cf0	20 f6 d7	jsr $d7f6	                jsr underflow_1
.9cf3	a0 04		ldy #$04	                ldy #current_offset
.9cf5	b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9cf7	91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9cf9	e8		inx		                inx
.9cfa	e8		inx		                inx
.9cfb	60		rts		z_set_current:  rts
.9cfc					xt_set_order:
.9cfc	a9 ff		lda #$ff	                lda #$FF
.9cfe	d5 01		cmp $01,x	                cmp 1,x
.9d00	d0 12		bne $9d14	                bne _start
.9d02	d5 00		cmp $00,x	                cmp 0,x
.9d04	d0 0e		bne $9d14	                bne _start
.9d06	ca		dex		                dex             ; Make room for the count.
.9d07	ca		dex		                dex
.9d08	74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d0a	a9 03		lda #$03	                lda #3
.9d0c	95 02		sta $02,x	                sta 2,x
.9d0e	74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d10	a9 01		lda #$01	                lda #1
.9d12	95 00		sta $00,x	                sta 0,x
.9d14					_start:
.9d14	a0 1e		ldy #$1e	                ldy #num_order_offset
.9d16	b5 00		lda $00,x	                lda 0,x
.9d18	91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d1a	85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d1c	e8		inx		                inx             ; Drop the count off the data stack.
.9d1d	e8		inx		                inx
.9d1e	a5 24		lda $24		                lda tmp1
.9d20	f0 0d		beq $9d2f	                beq _done       ; If zero, there are no wordlists.
.9d22	a0 1f		ldy #$1f	                ldy #search_order_offset
.9d24					_loop:
.9d24	b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d26	91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d28	c8		iny		                iny
.9d29	e8		inx		                inx
.9d2a	e8		inx		                inx
.9d2b	c6 24		dec $24		                dec tmp1
.9d2d	d0 f5		bne $9d24	                bne _loop
.9d2f					_done:
.9d2f	60		rts		z_set_order:    rts
.9d30					xt_s_quote:
.9d30	64 26		stz $26		                stz tmp2
.9d32	64 27		stz $27		                stz tmp2+1
.9d34					s_quote_start:
.9d34	ca		dex		                dex
.9d35	ca		dex		                dex
.9d36	ca		dex		                dex
.9d37	ca		dex		                dex
.9d38	a9 4c		lda #$4c	                lda #$4C
.9d3a	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.9d3d	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.9d40	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.9d43	a5 00		lda $00		                lda cp
.9d45	95 02		sta $02,x	                sta 2,x
.9d47	a5 01		lda $01		                lda cp+1
.9d49	95 03		sta $03,x	                sta 3,x
.9d4b					_savechars_loop:
.9d4b	a5 0d		lda $0d		                lda toin+1              ; MSB
.9d4d	c5 0b		cmp $0b		                cmp ciblen+1
.9d4f	90 2a		bcc $9d7b	                bcc _input_fine         ; unsigned comparison
.9d51	a5 0c		lda $0c		                lda toin                ; LSB
.9d53	c5 0a		cmp $0a		                cmp ciblen
.9d55	90 24		bcc $9d7b	                bcc _input_fine
.9d57	a5 26		lda $26		                lda tmp2
.9d59	48		pha		                pha
.9d5a	a5 27		lda $27		                lda tmp2+1
.9d5c	48		pha		                pha
.9d5d	a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d5f	48		pha		                pha
.9d60	20 d9 9a	jsr $9ad9	                jsr xt_refill           ; ( -- f )
.9d63	68		pla		                pla
.9d64	85 28		sta $28		                sta tmp3
.9d66	68		pla		                pla
.9d67	85 27		sta $27		                sta tmp2+1
.9d69	68		pla		                pla
.9d6a	85 26		sta $26		                sta tmp2
.9d6c	b5 00		lda $00,x	                lda 0,x
.9d6e	15 01		ora $01,x	                ora 1,x
.9d70	d0 05		bne $9d77	                bne _refill_ok
.9d72	a9 06		lda #$06	                lda #err_refill
.9d74	4c 0c d8	jmp $d80c	                jmp error
.9d77					_refill_ok:
.9d77	e8		inx		                inx
.9d78	e8		inx		                inx
.9d79	80 d0		bra $9d4b	                bra _savechars_loop
.9d7b					_input_fine:
.9d7b	a5 08		lda $08		                lda cib
.9d7d	18		clc		                clc
.9d7e	65 0c		adc $0c		                adc toin        ; LSB
.9d80	85 24		sta $24		                sta tmp1
.9d82	a5 09		lda $09		                lda cib+1
.9d84	65 0d		adc $0d		                adc toin+1      ; MSB
.9d86	85 25		sta $25		                sta tmp1+1
.9d88	b2 24		lda ($24)	                lda (tmp1)
.9d8a	24 26		bit $26		                bit tmp2
.9d8c	30 03		bmi $9d91	                bmi _handle_escapes    ; Only checking bit 7
.9d8e	4c 1a 9e	jmp $9e1a	                jmp _regular_char
.9d91					_handle_escapes:
.9d91	24 27		bit $27		                bit tmp2+1
.9d93	30 03		bmi $9d98	                bmi _escaped
.9d95	4c 10 9e	jmp $9e10	                jmp _not_escaped
.9d98					_escaped:
.9d98	70 3c		bvs $9dd6	                bvs _check_esc_chars
.9d9a	a9 01		lda #$01	                lda #1
.9d9c	24 27		bit $27		                bit tmp2+1
.9d9e	d0 10		bne $9db0	                bne _esc_x_second_digit
.9da0	e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9da2	b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9da4	20 72 9b	jsr $9b72	                jsr convert_hex_value
.9da7	0a		asl a		                asl
.9da8	0a		asl a		                asl
.9da9	0a		asl a		                asl
.9daa	0a		asl a		                asl
.9dab	85 28		sta $28		                sta tmp3    ; Save it for later.
.9dad	4c 21 9e	jmp $9e21	                jmp _next_character
.9db0					_esc_x_second_digit:
.9db0	64 27		stz $27		                stz tmp2+1
.9db2	b2 24		lda ($24)	                lda (tmp1)
.9db4	20 72 9b	jsr $9b72	                jsr convert_hex_value
.9db7	05 28		ora $28		                ora tmp3
.9db9	4c 1e 9e	jmp $9e1e	                jmp _save_character
.9dbc					_esc_tr_table:
>9dbc	07				    .byte   7               ; a -> BEL (ASCII value 7)
>9dbd	08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9dbe	00 00				    .byte   0,0             ; c, d no escape
>9dc0	1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9dc1	0c				    .byte   12              ; f -> FF (ASCII value 12)
>9dc2	00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9dc7	0a				    .byte   10              ; l -> LF (ASCII value 10)
>9dc8	8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9dc9	0a				    .byte   10              ; n -> newline, impl. dependant, using LF (ASCII values 10)
>9dca	00 00				    .byte   0,0             ; o,p
>9dcc	22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9dcd	0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9dce	00				    .byte   0               ; s
>9dcf	09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9dd0	00				    .byte   0               ; u
>9dd1	0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9dd2	00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9dd5	80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9dd6					_check_esc_chars:
.9dd6	64 27		stz $27		                stz tmp2+1
.9dd8	c9 61		cmp #$61	                cmp #'a'
.9dda	30 1a		bmi $9df6	                bmi _check_esc_quote
.9ddc	c9 7b		cmp #$7b	                cmp #'z'+1
.9dde	10 16		bpl $9df6	                bpl _check_esc_quote
.9de0	a8		tay		                tay
.9de1	b9 5b 9d	lda $9d5b,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9de4	d0 03		bne $9de9	                bne _esc_replace
.9de6	98		tya		                tya                     ; revert if no translation
.9de7	80 0d		bra $9df6	                bra _check_esc_quote
.9de9	10 33		bpl $9e1e	_esc_replace:   bpl _save_character     ; simple replacement
.9deb	29 7f		and #$7f	                and #$7f                ; clear hi bit
.9ded	f0 2f		beq $9e1e	                beq _save_character     ; NUL we can just output
.9def	20 a9 d6	jsr $d6a9	                jsr cmpl_a              ; else output first char (CR)
.9df2	a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9df4	80 28		bra $9e1e	                bra _save_character
.9df6					_check_esc_quote:
.9df6	c9 22		cmp #$22	                cmp #$22
.9df8	d0 04		bne $9dfe	                bne _check_esc_x
.9dfa	a9 22		lda #$22	                lda #34
.9dfc	80 20		bra $9e1e	                bra _save_character
.9dfe					_check_esc_x:
.9dfe	c9 78		cmp #$78	                cmp #'x'
.9e00	d0 06		bne $9e08	                bne _check_esc_backslash
.9e02	a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e04	85 27		sta $27		                sta tmp2+1
.9e06	80 19		bra $9e21	                bra _next_character
.9e08					_check_esc_backslash:
.9e08	c9 5c		cmp #$5c	                cmp #$5C
.9e0a	d0 04		bne $9e10	                bne _not_escaped
.9e0c	a9 5c		lda #$5c	                lda #92
.9e0e	80 0e		bra $9e1e	                bra _save_character
.9e10					_not_escaped:
.9e10	c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e12	d0 06		bne $9e1a	                bne _regular_char
.9e14	a9 ff		lda #$ff	                lda #$FF
.9e16	85 27		sta $27		                sta tmp2+1
.9e18	80 07		bra $9e21	                bra _next_character
.9e1a					_regular_char:
.9e1a	c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e1c	f0 0c		beq $9e2a	                beq _found_string_end
.9e1e					_save_character:
.9e1e	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.9e21					_next_character:
.9e21	e6 0c		inc $0c		                inc toin
.9e23	d0 02		bne $9e27	                bne _savechars_loop_longjump
.9e25	e6 0d		inc $0d		                inc toin+1
.9e27					_savechars_loop_longjump:
.9e27	4c 4b 9d	jmp $9d4b	                jmp _savechars_loop
.9e2a					_found_string_end:
.9e2a	e6 0c		inc $0c		                inc toin
.9e2c	d0 02		bne $9e30	                bne +
.9e2e	e6 0d		inc $0d		                inc toin+1
.9e30					+
.9e30	a5 00		lda $00		                lda cp
.9e32	38		sec		                sec
.9e33	f5 02		sbc $02,x	                sbc 2,x
.9e35	95 00		sta $00,x	                sta 0,x         ; LSB
.9e37	a5 01		lda $01		                lda cp+1
.9e39	f5 03		sbc $03,x	                sbc 3,x
.9e3b	95 01		sta $01,x	                sta 1,x         ; MSB
.9e3d	b5 02		lda $02,x	                lda 2,x
.9e3f	38		sec		                sec
.9e40	e9 02		sbc #$02	                sbc #2
.9e42	85 24		sta $24		                sta tmp1
.9e44	b5 03		lda $03,x	                lda 3,x
.9e46	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e48	85 25		sta $25		                sta tmp1+1
.9e4a	a5 00		lda $00		                lda cp
.9e4c	92 24		sta ($24)	                sta (tmp1)
.9e4e	a0 01		ldy #$01	                ldy #1
.9e50	a5 01		lda $01		                lda cp+1
.9e52	91 24		sta ($24),y	                sta (tmp1),y
.9e54	a5 16		lda $16		                lda state
.9e56	05 17		ora $17		                ora state+1             ; paranoid
.9e58	f0 03		beq $9e5d	                beq _done
.9e5a	20 41 a0	jsr $a041	                jsr sliteral_const_str         ; ( addr u -- )
.9e5d					_done:
.9e5d	60		rts		z_s_quote:      rts
.9e5e					xt_s_to_d:
.9e5e	20 f6 d7	jsr $d7f6	                jsr underflow_1
.9e61	ca		dex		                dex
.9e62	ca		dex		                dex
.9e63	74 00		stz $00,x	                stz 0,x
.9e65	74 01		stz $01,x	                stz 1,x
.9e67	b5 03		lda $03,x	                lda 3,x
.9e69	10 04		bpl $9e6f	                bpl _done
.9e6b	d6 00		dec $00,x	                dec 0,x
.9e6d	d6 01		dec $01,x	                dec 1,x
.9e6f					_done:
.9e6f	60		rts		z_s_to_d:       rts
.9e70					xt_save_buffers:
.9e70	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e72	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9e74	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9e76	d0 12		bne $9e8a	                bne _done       ; Either not used or not dirty = done!
.9e78	20 94 83	jsr $8394	                jsr xt_blkbuffer
.9e7b	20 86 85	jsr $8586	                jsr xt_buffblocknum
.9e7e	20 61 8f	jsr $8f61	                jsr xt_fetch
.9e81	20 41 85	jsr $8541	                jsr xt_block_write
.9e84	a9 01		lda #$01	                lda #1
.9e86	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e88	91 1e		sta ($1e),y	                sta (up),y
.9e8a					_done:
.9e8a	60		rts		z_save_buffers: rts
.9e8b					xt_scr:
.9e8b	ca		dex		                dex
.9e8c	ca		dex		                dex
.9e8d	18		clc		                clc
.9e8e	a5 1e		lda $1e		                lda up
.9e90	69 02		adc #$02	                adc #scr_offset ; Add offset
.9e92	95 00		sta $00,x	                sta 0,x
.9e94	a5 1f		lda $1f		                lda up+1
.9e96	69 00		adc #$00	                adc #0          ; Adding carry
.9e98	95 01		sta $01,x	                sta 1,x
.9e9a	60		rts		z_scr:          rts
.9e9b					xt_search:
.9e9b	20 05 d8	jsr $d805	                jsr underflow_4
.9e9e	b5 00		lda $00,x	                lda 0,x
.9ea0	15 01		ora $01,x	                ora 1,x
.9ea2	d0 0b		bne $9eaf	                bne _start_search
.9ea4	e8		inx		                inx             ; Remove u2
.9ea5	e8		inx		                inx
.9ea6	a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ea8	95 00		sta $00,x	                sta 0,x
.9eaa	95 01		sta $01,x	                sta 1,x
.9eac	4c 39 9f	jmp $9f39	                jmp z_search
.9eaf					_start_search:
.9eaf	20 5a a7	jsr $a75a	                jsr xt_zero
.9eb2					_search_loop:
.9eb2	18		clc		                clc
.9eb3	b5 00		lda $00,x	                lda 0,x
.9eb5	75 02		adc $02,x	                adc 2,x
.9eb7	85 24		sta $24		                sta tmp1
.9eb9	b5 01		lda $01,x	                lda 1,x
.9ebb	75 03		adc $03,x	                adc 3,x
.9ebd	d5 07		cmp $07,x	                cmp 7,x
.9ebf	90 12		bcc $9ed3	                bcc _init_comparison ; Obviously less
.9ec1	d0 06		bne $9ec9	                bne _not_found
.9ec3	b5 06		lda $06,x	                lda 6,x
.9ec5	c5 24		cmp $24		                cmp tmp1
.9ec7	b0 0a		bcs $9ed3	                bcs _init_comparison
.9ec9					_not_found:
.9ec9	e8		inx		                inx             ; Remove offset
.9eca	e8		inx		                inx
.9ecb	e8		inx		                inx             ; Remove u2
.9ecc	e8		inx		                inx
.9ecd	74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9ecf	74 01		stz $01,x	                stz 1,x
.9ed1	80 66		bra $9f39	                bra z_search
.9ed3					_init_comparison:
.9ed3	18		clc		                clc
.9ed4	b5 08		lda $08,x	                lda 8,x
.9ed6	75 00		adc $00,x	                adc 0,x
.9ed8	85 24		sta $24		                sta tmp1
.9eda	b5 09		lda $09,x	                lda 9,x
.9edc	75 01		adc $01,x	                adc 1,x
.9ede	85 25		sta $25		                sta tmp1+1
.9ee0	b5 04		lda $04,x	                lda 4,x
.9ee2	85 26		sta $26		                sta tmp2
.9ee4	b5 05		lda $05,x	                lda 5,x
.9ee6	85 27		sta $27		                sta tmp2+1
.9ee8	b5 02		lda $02,x	                lda 2,x
.9eea	85 28		sta $28		                sta tmp3
.9eec	b5 03		lda $03,x	                lda 3,x
.9eee	85 29		sta $29		                sta tmp3+1
.9ef0					_comparison_loop:
.9ef0	b2 24		lda ($24)	                lda (tmp1)
.9ef2	d2 26		cmp ($26)	                cmp (tmp2)
.9ef4	f0 05		beq $9efb	                beq _letters_match
.9ef6	20 fe 97	jsr $97fe	                jsr xt_one_plus
.9ef9	80 b7		bra $9eb2	                bra _search_loop
.9efb					_letters_match:
.9efb	e6 24		inc $24		                inc tmp1
.9efd	d0 02		bne $9f01	                bne +
.9eff	e6 25		inc $25		                inc tmp1+1
.9f01					+
.9f01	e6 26		inc $26		                inc tmp2
.9f03	d0 02		bne $9f07	                bne +
.9f05	e6 27		inc $27		                inc tmp2+1
.9f07					+
.9f07	a5 28		lda $28		                lda tmp3
.9f09	d0 02		bne $9f0d	                bne +
.9f0b	c6 29		dec $29		                dec tmp3+1
.9f0d					+
.9f0d	c6 28		dec $28		                dec tmp3
.9f0f	a5 28		lda $28		                lda tmp3
.9f11	05 29		ora $29		                ora tmp3+1
.9f13	d0 db		bne $9ef0	                bne _comparison_loop ; Check the next letter
.9f15	18		clc		                clc
.9f16	b5 00		lda $00,x	                lda 0,x
.9f18	75 08		adc $08,x	                adc 8,x
.9f1a	95 08		sta $08,x	                sta 8,x
.9f1c	b5 01		lda $01,x	                lda 1,x
.9f1e	75 09		adc $09,x	                adc 9,x
.9f20	95 09		sta $09,x	                sta 9,x
.9f22	38		sec		                sec
.9f23	b5 06		lda $06,x	                lda 6,x
.9f25	f5 00		sbc $00,x	                sbc 0,x
.9f27	95 06		sta $06,x	                sta 6,x
.9f29	b5 07		lda $07,x	                lda 7,x
.9f2b	f5 01		sbc $01,x	                sbc 1,x
.9f2d	95 07		sta $07,x	                sta 7,x
.9f2f	e8		inx		                inx             ; drop offset
.9f30	e8		inx		                inx
.9f31	e8		inx		                inx             ; drop u2
.9f32	e8		inx		                inx
.9f33	a9 ff		lda #$ff	                lda #$FF
.9f35	95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f37	95 01		sta $01,x	                sta 1,x
.9f39	60		rts		z_search:       rts
.9f3a					xt_semicolon:
.9f3a	24 20		bit $20		                bit status
.9f3c	70 11		bvs $9f4f	                bvs _colonword
.9f3e	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f40	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.9f43	ca		dex		                dex
.9f44	ca		dex		                dex
.9f45	a5 04		lda $04		                lda workword
.9f47	95 00		sta $00,x	                sta 0,x
.9f49	a5 05		lda $05		                lda workword+1
.9f4b	95 01		sta $01,x	                sta 1,x
.9f4d	80 45		bra $9f94	                bra _semicolon_done
.9f4f					_colonword:
.9f4f	a0 06		ldy #$06	                ldy #6
.9f51	a5 00		lda $00		                lda cp
.9f53	91 04		sta ($04),y	                sta (workword),y
.9f55	c8		iny		                iny
.9f56	a5 01		lda $01		                lda cp+1
.9f58	91 04		sta ($04),y	                sta (workword),y
.9f5a	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f5c	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.9f5f	24 20		bit $20		                bit status
.9f61	10 26		bpl $9f89	                bpl _new_word   ; Bit 7 is clear = new word
.9f63	ca		dex		                dex
.9f64	ca		dex		                dex
.9f65	ca		dex		                dex
.9f66	ca		dex		                dex
.9f67	b2 04		lda ($04)	                lda (workword)
.9f69	95 00		sta $00,x	                sta 0,x
.9f6b	74 01		stz $01,x	                stz 1,x
.9f6d	a5 04		lda $04		                lda workword
.9f6f	18		clc		                clc
.9f70	69 08		adc #$08	                adc #8
.9f72	95 02		sta $02,x	                sta 2,x
.9f74	a5 05		lda $05		                lda workword+1
.9f76	69 00		adc #$00	                adc #0                  ; only want carry
.9f78	95 03		sta $03,x	                sta 3,x
.9f7a	a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9f7c	20 32 d8	jsr $d832	                jsr print_string_no_lf
.9f7f	20 b5 a4	jsr $a4b5	                jsr xt_type
.9f82	20 d0 a0	jsr $a0d0	                jsr xt_space
.9f85	a9 80		lda #$80	                lda #%10000000
.9f87	14 20		trb $20		                trb status
.9f89					_new_word:
.9f89	a5 04		lda $04		                lda workword
.9f8b	85 02		sta $02		                sta dp
.9f8d	a5 05		lda $05		                lda workword+1
.9f8f	85 03		sta $03		                sta dp+1
.9f91	20 4b d7	jsr $d74b	                jsr dp_to_current       ; Save the updated DP to the
.9f94					_semicolon_done:
.9f94	64 16		stz $16		                stz state
.9f96	64 17		stz $17		                stz state+1
.9f98	60		rts		z_semicolon:    rts
.9f99					xt_sign:
.9f99	20 f6 d7	jsr $d7f6	                jsr underflow_1
.9f9c	b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9f9e	30 04		bmi $9fa4	                bmi _minus
.9fa0	e8		inx		                inx
.9fa1	e8		inx		                inx
.9fa2	80 09		bra $9fad	                bra _done
.9fa4					_minus:
.9fa4	a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9fa6	95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9fa8	74 01		stz $01,x	                stz 1,x         ; paranoid
.9faa	20 b8 91	jsr $91b8	                jsr xt_hold
.9fad					_done:
.9fad	60		rts		z_sign:         rts
.9fae					xt_slash:
.9fae	a9 00		lda #$00	                lda #0
.9fb0	48		pha		                pha
.9fb1	80 03		bra $9fb6	                bra slashmod_common
.9fb3					xt_slash_mod:
.9fb3	a9 ff		lda #$ff	                lda #$FF
.9fb5	48		pha		                pha             ; falls through to _common
.9fb6					slashmod_common:
.9fb6	20 22 a3	jsr $a322	                jsr xt_to_r             ; >R
.9fb9	20 5e 9e	jsr $9e5e	                jsr xt_s_to_d           ; S>D
.9fbc	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R>
.9fbf	20 87 a0	jsr $a087	                jsr xt_sm_slash_rem     ; SM/REM
.9fc2	68		pla		                pla
.9fc3	d0 05		bne $9fca	                bne _done
.9fc5	20 60 a1	jsr $a160	                jsr xt_swap
.9fc8	e8		inx		                inx             ; DROP
.9fc9	e8		inx		                inx
.9fca					_done:
.9fca					z_slash_mod:
.9fca	60		rts		z_slash:        rts
.9fcb					xt_slash_string:
.9fcb	20 00 d8	jsr $d800	                jsr underflow_3
.9fce	18		clc		                clc             ; 3OS+TOS
.9fcf	b5 00		lda $00,x	                lda 0,x
.9fd1	75 04		adc $04,x	                adc 4,x
.9fd3	95 04		sta $04,x	                sta 4,x
.9fd5	b5 01		lda $01,x	                lda 1,x
.9fd7	75 05		adc $05,x	                adc 5,x
.9fd9	95 05		sta $05,x	                sta 5,x
.9fdb	38		sec		                sec             ; NOS-TOS
.9fdc	b5 02		lda $02,x	                lda 2,x
.9fde	f5 00		sbc $00,x	                sbc 0,x
.9fe0	95 02		sta $02,x	                sta 2,x
.9fe2	b5 03		lda $03,x	                lda 3,x
.9fe4	f5 01		sbc $01,x	                sbc 1,x
.9fe6	95 03		sta $03,x	                sta 3,x
.9fe8	e8		inx		                inx
.9fe9	e8		inx		                inx
.9fea	60		rts		z_slash_string: rts
.9feb					xt_sliteral:
.9feb	20 fb d7	jsr $d7fb	                jsr underflow_2
.9fee	a9 4c		lda #$4c	                lda #$4C
.9ff0	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.9ff3	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.9ff6	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.9ff9	8a		txa		                txa
.9ffa	38		sec		                sec
.9ffb	e9 06		sbc #$06	                sbc #6
.9ffd	aa		tax		                tax
.9ffe	b5 08		lda $08,x	                lda 8,x
.a000	95 04		sta $04,x	                sta 4,x
.a002	b5 09		lda $09,x	                lda 9,x
.a004	95 05		sta $05,x	                sta 5,x
.a006	b5 06		lda $06,x	                lda 6,x
.a008	95 00		sta $00,x	                sta 0,x
.a00a	b5 07		lda $07,x	                lda 7,x
.a00c	95 01		sta $01,x	                sta 1,x
.a00e	a5 00		lda $00		                lda cp
.a010	95 08		sta $08,x	                sta 8,x
.a012	95 02		sta $02,x	                sta 2,x
.a014	a5 01		lda $01		                lda cp+1
.a016	95 09		sta $09,x	                sta 9,x
.a018	95 03		sta $03,x	                sta 3,x
.a01a	20 a3 95	jsr $95a3	                jsr xt_move
.a01d	18		clc		                clc
.a01e	a5 00		lda $00		                lda cp
.a020	75 00		adc $00,x	                adc 0,x
.a022	85 00		sta $00		                sta cp
.a024	a5 01		lda $01		                lda cp+1
.a026	75 01		adc $01,x	                adc 1,x
.a028	85 01		sta $01		                sta cp+1
.a02a	b5 02		lda $02,x	                lda 2,x
.a02c	38		sec		                sec
.a02d	e9 02		sbc #$02	                sbc #2
.a02f	85 24		sta $24		                sta tmp1
.a031	b5 03		lda $03,x	                lda 3,x
.a033	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a035	85 25		sta $25		                sta tmp1+1
.a037	a5 00		lda $00		                lda cp
.a039	92 24		sta ($24)	                sta (tmp1)
.a03b	a0 01		ldy #$01	                ldy #1
.a03d	a5 01		lda $01		                lda cp+1
.a03f	91 24		sta ($24),y	                sta (tmp1),y
.a041					sliteral_const_str:
.a041	a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a043	a9 5b		lda #$5b	                lda #<sliteral_runtime
.a045	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.a048	b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a04a	b5 02		lda $02,x	                lda 2,x                ; address LSB
.a04c	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.a04f	b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a051	b5 00		lda $00,x	                lda 0,x                ; length LSB
.a053	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.a056	e8		inx		                inx
.a057	e8		inx		                inx
.a058	e8		inx		                inx
.a059	e8		inx		                inx
.a05a	60		rts		z_sliteral:     rts
.a05b					sliteral_runtime:
.a05b	ca		dex		                dex
.a05c	ca		dex		                dex
.a05d	ca		dex		                dex
.a05e	ca		dex		                dex
.a05f	68		pla		                pla
.a060	85 24		sta $24		                sta tmp1        ; LSB of address
.a062	68		pla		                pla
.a063	85 25		sta $25		                sta tmp1+1      ; MSB of address
.a065	a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a067	b1 24		lda ($24),y	                lda (tmp1),y
.a069	95 02		sta $02,x	                sta 2,x         ; LSB of address
.a06b	c8		iny		                iny
.a06c	b1 24		lda ($24),y	                lda (tmp1),y
.a06e	95 03		sta $03,x	                sta 3,x         ; MSB of address
.a070	c8		iny		                iny
.a071	b1 24		lda ($24),y	                lda (tmp1),y
.a073	95 00		sta $00,x	                sta 0,x         ; LSB of length
.a075	c8		iny		                iny
.a076	b1 24		lda ($24),y	                lda (tmp1),y
.a078	95 01		sta $01,x	                sta 1,x         ; MSB of length
.a07a	18		clc		                clc
.a07b	a5 24		lda $24		                lda tmp1
.a07d	69 04		adc #$04	                adc #4
.a07f	a8		tay		                tay             ; LSB
.a080	a5 25		lda $25		                lda tmp1+1
.a082	69 00		adc #$00	                adc #0          ; we only need carry
.a084	48		pha		                pha             ; MSB
.a085	5a		phy		                phy
.a086	60		rts		                rts
.a087					xt_sm_slash_rem:
.a087	20 00 d8	jsr $d800	                jsr underflow_3 ; contains double number
.a08a	b5 03		lda $03,x	                lda 3,x
.a08c	48		pha		                pha
.a08d	b5 01		lda $01,x	                lda 1,x
.a08f	55 03		eor $03,x	                eor 3,x
.a091	48		pha		                pha
.a092	20 1a 81	jsr $811a	                jsr xt_abs
.a095	e8		inx		                inx             ; pretend we pushed n1 to R
.a096	e8		inx		                inx
.a097	20 67 8a	jsr $8a67	                jsr xt_dabs
.a09a	ca		dex		                dex
.a09b	ca		dex		                dex
.a09c	20 6c a5	jsr $a56c	                jsr xt_um_slash_mod     ; UM/MOD
.a09f	68		pla		                pla
.a0a0	10 03		bpl $a0a5	                bpl +
.a0a2	20 04 96	jsr $9604	                jsr xt_negate
.a0a5					+
.a0a5	68		pla		                pla
.a0a6	10 07		bpl $a0af	                bpl _done
.a0a8	e8		inx		                inx             ; pretend we pushed quotient to R
.a0a9	e8		inx		                inx
.a0aa	20 04 96	jsr $9604	                jsr xt_negate
.a0ad	ca		dex		                dex
.a0ae	ca		dex		                dex
.a0af					_done:
.a0af	60		rts		z_sm_slash_rem: rts
.a0b0					xt_source:
.a0b0	ca		dex		                dex
.a0b1	ca		dex		                dex
.a0b2	a5 08		lda $08		                lda cib
.a0b4	95 00		sta $00,x	                sta 0,x
.a0b6	a5 09		lda $09		                lda cib+1
.a0b8	95 01		sta $01,x	                sta 1,x
.a0ba	ca		dex		                dex
.a0bb	ca		dex		                dex
.a0bc	a5 0a		lda $0a		                lda ciblen
.a0be	95 00		sta $00,x	                sta 0,x
.a0c0	a5 0b		lda $0b		                lda ciblen+1
.a0c2	95 01		sta $01,x	                sta 1,x
.a0c4	60		rts		z_source:       rts
.a0c5					xt_source_id:
.a0c5	ca		dex		                dex
.a0c6	ca		dex		                dex
.a0c7	a5 06		lda $06		                lda insrc
.a0c9	95 00		sta $00,x	                sta 0,x
.a0cb	a5 07		lda $07		                lda insrc+1
.a0cd	95 01		sta $01,x	                sta 1,x
.a0cf	60		rts		z_source_id:    rts
.a0d0					xt_space:
.a0d0	a9 20		lda #$20	                lda #AscSP
.a0d2	20 d7 8d	jsr $8dd7	                jsr emit_a
.a0d5	60		rts		z_space:        rts
.a0d6					xt_spaces:
.a0d6	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a0d9	20 5a a7	jsr $a75a	                jsr xt_zero
.a0dc	20 f9 94	jsr $94f9	                jsr xt_max
.a0df	b5 00		lda $00,x	                lda 0,x
.a0e1	15 01		ora $01,x	                ora 1,x
.a0e3	f0 2a		beq $a10f	                beq _done
.a0e5	b4 01		ldy $01,x	                ldy 1,x
.a0e7	d0 0c		bne $a0f5	                bne _lots_of_spaces
.a0e9	b4 00		ldy $00,x	                ldy 0,x
.a0eb					_quick_loop:
.a0eb	a9 20		lda #$20	                lda #AscSP
.a0ed	20 d7 8d	jsr $8dd7	                jsr emit_a
.a0f0	88		dey		                dey
.a0f1	f0 1c		beq $a10f	                beq _done
.a0f3	80 f6		bra $a0eb	                bra _quick_loop
.a0f5					_lots_of_spaces:
.a0f5	b4 00		ldy $00,x	                ldy 0,x
.a0f7					_first_slow_loop:
.a0f7	f0 08		beq $a101	                beq _slow_outer_loop
.a0f9	a9 20		lda #$20	                lda #AscSP
.a0fb	20 d7 8d	jsr $8dd7	                jsr emit_a
.a0fe	88		dey		                dey
.a0ff	80 f6		bra $a0f7	                bra _first_slow_loop
.a101					_slow_outer_loop:
.a101	a0 00		ldy #$00	                ldy #00
.a103					_slow_inner_loop:
.a103	a9 20		lda #$20	                lda #AscSP
.a105	20 d7 8d	jsr $8dd7	                jsr emit_a
.a108	88		dey		                dey
.a109	d0 f8		bne $a103	                bne _slow_inner_loop
.a10b	d6 01		dec $01,x	                dec 1,x
.a10d	d0 f2		bne $a101	                bne _slow_outer_loop
.a10f					_done:
.a10f	e8		inx		                inx             ; drop
.a110	e8		inx		                inx
.a111	60		rts		z_spaces:       rts
.a112					xt_star:
.a112	20 fb d7	jsr $d7fb	                jsr underflow_2
.a115	20 ae a5	jsr $a5ae	                jsr xt_um_star
.a118	e8		inx		                inx
.a119	e8		inx		                inx
.a11a	60		rts		z_star:         rts
.a11b					xt_star_slash:
.a11b	20 24 a1	jsr $a124	                jsr xt_star_slash_mod
.a11e	20 60 a1	jsr $a160	                jsr xt_swap
.a121	e8		inx		                inx
.a122	e8		inx		                inx
.a123					z_star_slash:
.a123	60		rts		                rts
.a124					xt_star_slash_mod:
.a124	20 00 d8	jsr $d800	                jsr underflow_3
.a127	20 22 a3	jsr $a322	                jsr xt_to_r
.a12a	20 6f 94	jsr $946f	                jsr xt_m_star
.a12d	20 73 9a	jsr $9a73	                jsr xt_r_from
.a130	20 87 a0	jsr $a087	                jsr xt_sm_slash_rem
.a133					z_star_slash_mod:
.a133	60		rts		                rts
.a134					xt_state:
.a134	ca		dex		                dex
.a135	ca		dex		                dex
.a136	a9 16		lda #$16	                lda #<state
.a138	95 00		sta $00,x	                sta 0,x
.a13a	a9 00		lda #$00	                lda #>state
.a13c	95 01		sta $01,x	                sta 1,x
.a13e	60		rts		z_state:        rts
.a13f					xt_store:
.a13f	20 fb d7	jsr $d7fb	                jsr underflow_2
.a142	b5 02		lda $02,x	                lda 2,x         ; LSB
.a144	81 00		sta ($00,x)	                sta (0,x)
.a146	f6 00		inc $00,x	                inc 0,x
.a148	d0 02		bne $a14c	                bne +
.a14a	f6 01		inc $01,x	                inc 1,x
.a14c					+
.a14c	b5 03		lda $03,x	                lda 3,x         ; MSB
.a14e	81 00		sta ($00,x)	                sta (0,x)
.a150	e8		inx		                inx             ; 2DROP
.a151	e8		inx		                inx
.a152	e8		inx		                inx
.a153	e8		inx		                inx
.a154	60		rts		z_store:        rts
.a155					xt_strip_underflow:
.a155	ca		dex		                dex
.a156	ca		dex		                dex
.a157	a9 1c		lda #$1c	                lda #<uf_strip
.a159	95 00		sta $00,x	                sta 0,x
.a15b	a9 00		lda #$00	                lda #>uf_strip
.a15d	95 01		sta $01,x	                sta 1,x
.a15f					z_strip_underflow:
.a15f	60		rts		                rts
.a160					xt_swap:
.a160	20 fb d7	jsr $d7fb	                jsr underflow_2
.a163	b5 00		lda $00,x	                lda 0,x         ; LSB
.a165	b4 02		ldy $02,x	                ldy 2,x
.a167	95 02		sta $02,x	                sta 2,x
.a169	94 00		sty $00,x	                sty 0,x
.a16b	b5 01		lda $01,x	                lda 1,x         ; MSB
.a16d	b4 03		ldy $03,x	                ldy 3,x
.a16f	95 03		sta $03,x	                sta 3,x
.a171	94 01		sty $01,x	                sty 1,x
.a173	60		rts		z_swap:         rts
.a174					xt_then:
.a174	20 53 91	jsr $9153	                jsr xt_here
.a177	20 60 a1	jsr $a160	                jsr xt_swap
.a17a	20 3f a1	jsr $a13f	                jsr xt_store
.a17d	60		rts		z_then:         rts
.a17e					xt_thru:
.a17e	20 fb d7	jsr $d7fb	                jsr underflow_2
.a181	b5 01		lda $01,x	                lda 1,x
.a183	48		pha		                pha
.a184	b5 00		lda $00,x	                lda 0,x
.a186	48		pha		                pha
.a187	e8		inx		                inx
.a188	e8		inx		                inx
.a189					_thru_loop:
.a189	b5 01		lda $01,x	                lda 1,x
.a18b	48		pha		                pha
.a18c	b5 00		lda $00,x	                lda 0,x
.a18e	48		pha		                pha
.a18f	20 98 93	jsr $9398	                jsr xt_load
.a192	68		pla		                pla
.a193	85 24		sta $24		                sta tmp1
.a195	68		pla		                pla
.a196	85 25		sta $25		                sta tmp1+1
.a198	68		pla		                pla
.a199	85 26		sta $26		                sta tmp2
.a19b	68		pla		                pla
.a19c	85 27		sta $27		                sta tmp2+1
.a19e	c5 25		cmp $25		                cmp tmp1+1
.a1a0	d0 08		bne $a1aa	                bne _next_screen
.a1a2	a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a1a4	c5 24		cmp $24		                cmp tmp1
.a1a6	d0 02		bne $a1aa	                bne _next_screen
.a1a8	80 18		bra $a1c2	                bra _done       ; We just did the last screen.
.a1aa					_next_screen:
.a1aa	a5 27		lda $27		                lda tmp2+1
.a1ac	48		pha		                pha
.a1ad	a5 26		lda $26		                lda tmp2
.a1af	48		pha		                pha
.a1b0	e6 24		inc $24		                inc tmp1
.a1b2	d0 02		bne $a1b6	                bne +
.a1b4	e6 25		inc $25		                inc tmp1+1
.a1b6					+
.a1b6	ca		dex		                dex
.a1b7	ca		dex		                dex
.a1b8	a5 24		lda $24		                lda tmp1
.a1ba	95 00		sta $00,x	                sta 0,x
.a1bc	a5 25		lda $25		                lda tmp1+1
.a1be	95 01		sta $01,x	                sta 1,x
.a1c0	80 c7		bra $a189	                bra _thru_loop
.a1c2					_done:
.a1c2	60		rts		z_thru:         rts
.a1c3					xt_tick:
.a1c3	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( -- addr u )
.a1c6	b5 00		lda $00,x	                lda 0,x
.a1c8	15 01		ora $01,x	                ora 1,x
.a1ca	d0 05		bne $a1d1	                bne +
.a1cc	a9 05		lda #$05	                lda #err_noname
.a1ce	4c 0c d8	jmp $d80c	                jmp error
.a1d1					+
.a1d1	20 bc 8f	jsr $8fbc	                jsr xt_find_name        ; ( addr u -- nt )
.a1d4	b5 00		lda $00,x	                lda 0,x
.a1d6	15 01		ora $01,x	                ora 1,x
.a1d8	d0 05		bne $a1df	                bne +
.a1da	a9 08		lda #$08	                lda #err_syntax
.a1dc	4c 0c d8	jmp $d80c	                jmp error
.a1df					+
.a1df	20 c2 95	jsr $95c2	                jsr xt_name_to_int      ; ( nt -- xt )
.a1e2	60		rts		z_tick:         rts
.a1e3					xt_to:
.a1e3	20 c3 a1	jsr $a1c3	                jsr xt_tick             ; ( [n] xt )
.a1e6	b5 00		lda $00,x	                lda 0,x                 ; LSB
.a1e8	18		clc		                clc
.a1e9	69 03		adc #$03	                adc #3
.a1eb	85 24		sta $24		                sta tmp1
.a1ed	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a1ef	69 00		adc #$00	                adc #0                  ; we just want the carry
.a1f1	85 25		sta $25		                sta tmp1+1
.a1f3	e8		inx		                inx
.a1f4	e8		inx		                inx                     ; ( [n] )
.a1f5	a5 16		lda $16		                lda state
.a1f7	05 17		ora $17		                ora state+1
.a1f9	f0 34		beq $a22f	                beq _interpret
.a1fb	a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a1fd	a9 b5		lda #$b5	                lda #$B5
.a1ff	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.a202	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a204	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.a207	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a209	a5 24		lda $24		                lda tmp1
.a20b	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.a20e	a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a210	a9 b5		lda #$b5	                lda #$B5
.a212	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.a215	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a217	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.a21a	e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a21c	d0 02		bne $a220	                bne +
.a21e	e6 25		inc $25		                inc tmp1+1
.a220					+
.a220	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a222	a5 24		lda $24		                lda tmp1
.a224	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.a227	a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a229	98		tya		                tya
.a22a	20 a5 d6	jsr $d6a5	                jsr cmpl_word
.a22d	80 0f		bra $a23e	                bra _done
.a22f					_interpret:
.a22f	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a232	b5 00		lda $00,x	                lda 0,x
.a234	92 24		sta ($24)	                sta (tmp1)              ; LSB
.a236	a0 01		ldy #$01	                ldy #1
.a238	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a23a	91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a23c	e8		inx		                inx                     ; DROP
.a23d	e8		inx		                inx
.a23e					_done:
.a23e	60		rts		z_to:           rts
.a23f					xt_to_body:
.a23f	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a242	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( xt xt )
.a245	20 59 92	jsr $9259	                jsr xt_int_to_name      ; ( xt nt )
.a248	f6 00		inc $00,x	                inc 0,x
.a24a	d0 02		bne $a24e	                bne +
.a24c	f6 01		inc $01,x	                inc 1,x
.a24e					+
.a24e	a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a250	29 20		and #$20	                and #HC
.a252	f0 0d		beq $a261	                beq _no_cfa
.a254	18		clc		                clc
.a255	b5 02		lda $02,x	                lda 2,x         ; LSB
.a257	69 03		adc #$03	                adc #3
.a259	95 02		sta $02,x	                sta 2,x
.a25b	b5 03		lda $03,x	                lda 3,x         ; MSB
.a25d	69 00		adc #$00	                adc #0          ; we conly care about the carry
.a25f	95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a261					_no_cfa:
.a261	e8		inx		                inx             ; get rid of the nt
.a262	e8		inx		                inx
.a263					_done:
.a263	60		rts		z_to_body:      rts
.a264					xt_to_in:
.a264	ca		dex		                dex
.a265	ca		dex		                dex
.a266	a9 0c		lda #$0c	                lda #<toin
.a268	95 00		sta $00,x	                sta 0,x
.a26a	a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a26c	95 01		sta $01,x	                sta 1,x
.a26e	60		rts		z_to_in:        rts
.a26f					xt_to_number:
.a26f	20 05 d8	jsr $d805	                jsr underflow_4
.a272	b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a274	85 36		sta $36		                sta scratch
.a276	b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a278	85 37		sta $37		                sta scratch+1
.a27a	b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a27c	85 38		sta $38		                sta scratch+2
.a27e	b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a280	85 39		sta $39		                sta scratch+3
.a282	ca		dex		                dex
.a283	ca		dex		                dex
.a284					_loop:
.a284	a1 04		lda ($04,x)	                lda (4,x)
.a286	95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a288	74 01		stz $01,x	                stz 1,x                 ; paranoid
.a28a	20 e6 8a	jsr $8ae6	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a28d	b5 00		lda $00,x	                lda 0,x
.a28f	d0 04		bne $a295	                bne _digit_ok
.a291	e8		inx		                inx
.a292	e8		inx		                inx
.a293	80 67		bra $a2fc	                bra _done       ; ( ud-lo ud-hi addr u char )
.a295					_digit_ok:
.a295	b5 02		lda $02,x	                lda 2,x
.a297	85 3a		sta $3a		                sta scratch+4
.a299	b5 03		lda $03,x	                lda 3,x
.a29b	85 3b		sta $3b		                sta scratch+5
.a29d	a5 38		lda $38		                lda scratch+2
.a29f	95 02		sta $02,x	                sta 2,x         ; NOS
.a2a1	a5 39		lda $39		                lda scratch+3
.a2a3	95 03		sta $03,x	                sta 3,x
.a2a5	a5 18		lda $18		                lda base
.a2a7	95 00		sta $00,x	                sta 0,x         ; TOS
.a2a9	74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a2ab	20 ae a5	jsr $a5ae	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2ae	b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a2b0	85 3c		sta $3c		                sta scratch+6
.a2b2	b5 03		lda $03,x	                lda 3,x
.a2b4	85 3d		sta $3d		                sta scratch+7
.a2b6	a5 36		lda $36		                lda scratch
.a2b8	95 02		sta $02,x	                sta 2,x
.a2ba	a5 37		lda $37		                lda scratch+1
.a2bc	95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a2be	a5 18		lda $18		                lda base
.a2c0	95 00		sta $00,x	                sta 0,x
.a2c2	74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a2c4	20 ae a5	jsr $a5ae	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a2c7	b5 00		lda $00,x	                lda 0,x
.a2c9	85 38		sta $38		                sta scratch+2
.a2cb	b5 01		lda $01,x	                lda 1,x
.a2cd	85 39		sta $39		                sta scratch+3
.a2cf	b5 02		lda $02,x	                lda 2,x
.a2d1	85 36		sta $36		                sta scratch
.a2d3	b5 03		lda $03,x	                lda 3,x
.a2d5	85 37		sta $37		                sta scratch+1
.a2d7	18		clc		                clc
.a2d8	a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a2da	65 3a		adc $3a		                adc scratch+4   ; n LSB
.a2dc	85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a2de	a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a2e0	65 3b		adc $3b		                adc scratch+5   ; n MSB
.a2e2	85 37		sta $37		                sta scratch+1
.a2e4	a5 38		lda $38		                lda scratch+2   ; LSB
.a2e6	65 3c		adc $3c		                adc scratch+6
.a2e8	85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a2ea	a5 39		lda $39		                lda scratch+3   ; MSB
.a2ec	65 3d		adc $3d		                adc scratch+7
.a2ee	85 39		sta $39		                sta scratch+3
.a2f0	e8		inx		                inx
.a2f1	e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a2f2	f6 04		inc $04,x	                inc 4,x
.a2f4	d0 02		bne $a2f8	                bne +
.a2f6	f6 05		inc $05,x	                inc 5,x
.a2f8					+
.a2f8	d6 02		dec $02,x	                dec 2,x
.a2fa	d0 88		bne $a284	                bne _loop
.a2fc					_done:
.a2fc	e8		inx		                inx
.a2fd	e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a2fe	a5 36		lda $36		                lda scratch     ; new ud-lo
.a300	95 06		sta $06,x	                sta 6,x
.a302	a5 37		lda $37		                lda scratch+1
.a304	95 07		sta $07,x	                sta 7,x
.a306	a5 38		lda $38		                lda scratch+2
.a308	95 04		sta $04,x	                sta 4,x
.a30a	a5 39		lda $39		                lda scratch+3
.a30c	95 05		sta $05,x	                sta 5,x
.a30e	60		rts		z_to_number:    rts
.a30f					xt_to_order:
.a30f	20 22 a3	jsr $a322	                jsr xt_to_r
.a312	20 15 91	jsr $9115	                jsr xt_get_order
.a315	20 73 9a	jsr $9a73	                jsr xt_r_from
.a318	20 60 a1	jsr $a160	                jsr xt_swap
.a31b	20 fe 97	jsr $97fe	                jsr xt_one_plus
.a31e	20 fc 9c	jsr $9cfc	                jsr xt_set_order
.a321	60		rts		z_to_order:     rts
.a322					xt_to_r:
.a322	68		pla		                pla             ; LSB
.a323	85 2c		sta $2c		                sta tmptos
.a325	7a		ply		                ply             ; MSB
.a326	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a329	b5 01		lda $01,x	                lda 1,x         ; MSB
.a32b	48		pha		                pha
.a32c	b5 00		lda $00,x	                lda 0,x         ; LSB
.a32e	48		pha		                pha
.a32f	e8		inx		                inx
.a330	e8		inx		                inx
.a331	5a		phy		                phy             ; MSB
.a332	a5 2c		lda $2c		                lda tmptos
.a334	48		pha		                pha             ; LSB
.a335	60		rts		z_to_r:         rts
.a336					xt_true:
.a336	ca		dex		                dex
.a337	ca		dex		                dex
.a338	a9 ff		lda #$ff	                lda #$FF
.a33a	95 00		sta $00,x	                sta 0,x
.a33c	95 01		sta $01,x	                sta 1,x
.a33e	60		rts		z_true:         rts
.a33f					xt_tuck:
.a33f	20 fb d7	jsr $d7fb	                jsr underflow_2
.a342	ca		dex		                dex
.a343	ca		dex		                dex
.a344	b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a346	b5 02		lda $02,x	                lda 2,x
.a348	95 04		sta $04,x	                sta 4,x
.a34a	94 02		sty $02,x	                sty 2,x
.a34c	95 00		sta $00,x	                sta 0,x
.a34e	b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a350	b5 03		lda $03,x	                lda 3,x
.a352	95 05		sta $05,x	                sta 5,x
.a354	94 03		sty $03,x	                sty 3,x         ; bba
.a356	95 01		sta $01,x	                sta 1,x         ; baa
.a358	60		rts		z_tuck:         rts
.a359					xt_assembler_wordlist:
.a359					xt_two:
.a359	ca		dex		                dex
.a35a	ca		dex		                dex
.a35b	a9 02		lda #$02	                lda #2
.a35d	95 00		sta $00,x	                sta 0,x
.a35f	74 01		stz $01,x	                stz 1,x
.a361					z_assembler_wordlist:
.a361	60		rts		z_two:          rts
.a362					xt_two_drop:
.a362	20 fb d7	jsr $d7fb	                jsr underflow_2
.a365	e8		inx		                inx
.a366	e8		inx		                inx
.a367	e8		inx		                inx
.a368	e8		inx		                inx
.a369	60		rts		z_two_drop:     rts
.a36a					xt_two_dup:
.a36a	20 fb d7	jsr $d7fb	                jsr underflow_2
.a36d	ca		dex		                dex
.a36e	ca		dex		                dex
.a36f	ca		dex		                dex
.a370	ca		dex		                dex
.a371	b5 04		lda $04,x	                lda 4,x         ; TOS
.a373	95 00		sta $00,x	                sta 0,x
.a375	b5 05		lda $05,x	                lda 5,x
.a377	95 01		sta $01,x	                sta 1,x
.a379	b5 06		lda $06,x	                lda 6,x         ; NOS
.a37b	95 02		sta $02,x	                sta 2,x
.a37d	b5 07		lda $07,x	                lda 7,x
.a37f	95 03		sta $03,x	                sta 3,x
.a381	60		rts		z_two_dup:      rts
.a382					xt_two_fetch:
.a382	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a385	b5 00		lda $00,x	                lda 0,x
.a387	85 24		sta $24		                sta tmp1
.a389	b4 01		ldy $01,x	                ldy 1,x
.a38b	84 25		sty $25		                sty tmp1+1
.a38d	ca		dex		                dex             ; reuse one stack element
.a38e	ca		dex		                dex
.a38f	b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a391	95 00		sta $00,x	                sta 0,x
.a393	a0 01		ldy #$01	                ldy #1          ; copy next
.a395	b1 24		lda ($24),y	                lda (tmp1),y
.a397	95 01		sta $01,x	                sta 1,x
.a399	c8		iny		                iny             ; copy next
.a39a	b1 24		lda ($24),y	                lda (tmp1),y
.a39c	95 02		sta $02,x	                sta 2,x
.a39e	c8		iny		                iny             ; copy next
.a39f	b1 24		lda ($24),y	                lda (tmp1),y
.a3a1	95 03		sta $03,x	                sta 3,x
.a3a3	60		rts		z_two_fetch:    rts
.a3a4					xt_two_over:
.a3a4	20 05 d8	jsr $d805	                jsr underflow_4
.a3a7	ca		dex		                dex
.a3a8	ca		dex		                dex
.a3a9	ca		dex		                dex
.a3aa	ca		dex		                dex
.a3ab	b5 08		lda $08,x	                lda 8,x
.a3ad	95 00		sta $00,x	                sta 0,x
.a3af	b5 09		lda $09,x	                lda 9,x
.a3b1	95 01		sta $01,x	                sta 1,x
.a3b3	b5 0a		lda $0a,x	                lda 10,x
.a3b5	95 02		sta $02,x	                sta 2,x
.a3b7	b5 0b		lda $0b,x	                lda 11,x
.a3b9	95 03		sta $03,x	                sta 3,x
.a3bb	60		rts		z_two_over:     rts
.a3bc					xt_two_r_fetch:
.a3bc	ca		dex		                dex
.a3bd	ca		dex		                dex
.a3be	ca		dex		                dex
.a3bf	ca		dex		                dex
.a3c0	8a		txa		                txa
.a3c1	ba		tsx		                tsx
.a3c2	da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a3c3	7a		ply		                ply
.a3c4	aa		tax		                tax
.a3c5	b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a3c8	95 00		sta $00,x	                sta 0,x
.a3ca	b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a3cd	95 01		sta $01,x	                sta 1,x
.a3cf	b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a3d2	95 02		sta $02,x	                sta 2,x
.a3d4	b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a3d7	95 03		sta $03,x	                sta 3,x
.a3d9	60		rts		z_two_r_fetch:  rts
.a3da					xt_two_r_from:
.a3da	68		pla		                pla                     ; LSB
.a3db	85 24		sta $24		                sta tmp1
.a3dd	68		pla		                pla                     ; MSB
.a3de	85 25		sta $25		                sta tmp1+1
.a3e0	ca		dex		                dex
.a3e1	ca		dex		                dex
.a3e2	ca		dex		                dex
.a3e3	ca		dex		                dex
.a3e4	68		pla		                pla                     ; LSB
.a3e5	95 00		sta $00,x	                sta 0,x
.a3e7	68		pla		                pla                     ; MSB
.a3e8	95 01		sta $01,x	                sta 1,x
.a3ea	68		pla		                pla                     ; LSB
.a3eb	95 02		sta $02,x	                sta 2,x
.a3ed	68		pla		                pla                     ; MSB
.a3ee	95 03		sta $03,x	                sta 3,x
.a3f0	a5 25		lda $25		                lda tmp1+1              ; MSB
.a3f2	48		pha		                pha
.a3f3	a5 24		lda $24		                lda tmp1                ; LSB
.a3f5	48		pha		                pha
.a3f6	60		rts		z_two_r_from:   rts
.a3f7					xt_two_slash:
.a3f7	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a3fa	b5 01		lda $01,x	                lda 1,x
.a3fc	0a		asl a		                asl                     ; save the sign
.a3fd	76 01		ror $01,x	                ror 1,x
.a3ff	76 00		ror $00,x	                ror 0,x
.a401	60		rts		z_two_slash:    rts
.a402					xt_two_star:
.a402					xt_cells:
.a402	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a405	16 00		asl $00,x	                asl 0,x
.a407	36 01		rol $01,x	                rol 1,x
.a409					z_cells:
.a409	60		rts		z_two_star:     rts
.a40a					xt_two_store:
.a40a	20 00 d8	jsr $d800	                jsr underflow_3
.a40d	b5 00		lda $00,x	                lda 0,x
.a40f	85 24		sta $24		                sta tmp1
.a411	b4 01		ldy $01,x	                ldy 1,x
.a413	84 25		sty $25		                sty tmp1+1
.a415	e8		inx		                inx
.a416	e8		inx		                inx
.a417	b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a419	92 24		sta ($24)	                sta (tmp1)
.a41b	b5 01		lda $01,x	                lda 1,x         ; copy next
.a41d	a0 01		ldy #$01	                ldy #1
.a41f	91 24		sta ($24),y	                sta (tmp1),y
.a421	b5 02		lda $02,x	                lda 2,x         ; copy next
.a423	c8		iny		                iny
.a424	91 24		sta ($24),y	                sta (tmp1),y
.a426	b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a428	c8		iny		                iny
.a429	91 24		sta ($24),y	                sta (tmp1),y
.a42b	e8		inx		                inx             ; 2DROP
.a42c	e8		inx		                inx
.a42d	e8		inx		                inx
.a42e	e8		inx		                inx
.a42f	60		rts		z_two_store:    rts
.a430					xt_two_swap:
.a430	20 05 d8	jsr $d805	                jsr underflow_4
.a433	b5 00		lda $00,x	                lda 0,x
.a435	b4 04		ldy $04,x	                ldy 4,x
.a437	95 04		sta $04,x	                sta 4,x
.a439	94 00		sty $00,x	                sty 0,x
.a43b	b5 01		lda $01,x	                lda 1,x
.a43d	b4 05		ldy $05,x	                ldy 5,x
.a43f	95 05		sta $05,x	                sta 5,x
.a441	94 01		sty $01,x	                sty 1,x
.a443	b5 02		lda $02,x	                lda 2,x
.a445	b4 06		ldy $06,x	                ldy 6,x
.a447	95 06		sta $06,x	                sta 6,x
.a449	94 02		sty $02,x	                sty 2,x
.a44b	b5 03		lda $03,x	                lda 3,x
.a44d	b4 07		ldy $07,x	                ldy 7,x
.a44f	95 07		sta $07,x	                sta 7,x
.a451	94 03		sty $03,x	                sty 3,x
.a453	60		rts		z_two_swap:     rts
.a454					xt_two_to_r:
.a454	68		pla		                pla             ; LSB
.a455	85 24		sta $24		                sta tmp1
.a457	68		pla		                pla             ; MSB
.a458	85 25		sta $25		                sta tmp1+1
.a45a	20 fb d7	jsr $d7fb	                jsr underflow_2
.a45d	b5 03		lda $03,x	                lda 3,x         ; MSB
.a45f	48		pha		                pha
.a460	b5 02		lda $02,x	                lda 2,x         ; LSB
.a462	48		pha		                pha
.a463	b5 01		lda $01,x	                lda 1,x         ; MSB
.a465	48		pha		                pha
.a466	b5 00		lda $00,x	                lda 0,x         ; LSB
.a468	48		pha		                pha
.a469	e8		inx		                inx
.a46a	e8		inx		                inx
.a46b	e8		inx		                inx
.a46c	e8		inx		                inx
.a46d	a5 25		lda $25		                lda tmp1+1      ; MSB
.a46f	48		pha		                pha
.a470	a5 24		lda $24		                lda tmp1        ; LSB
.a472	48		pha		                pha
.a473	60		rts		z_two_to_r:     rts
.a474					xt_two_constant:
.a474	20 fb d7	jsr $d7fb	                jsr underflow_2
.a477	20 4a 89	jsr $894a	                jsr xt_create
.a47a	20 60 a1	jsr $a160	                jsr xt_swap
.a47d	20 4f 87	jsr $874f	                jsr xt_comma
.a480	20 4f 87	jsr $874f	                jsr xt_comma
.a483	20 e5 8b	jsr $8be5	                jsr does_runtime    ; does> turns into these two routines.
.a486	20 df d6	jsr $d6df	                jsr dodoes
.a489	20 90 8d	jsr $8d90	                jsr xt_dup
.a48c	20 61 8f	jsr $8f61	                jsr xt_fetch
.a48f	20 60 a1	jsr $a160	                jsr xt_swap
.a492	20 02 86	jsr $8602	                jsr xt_cell_plus
.a495	20 61 8f	jsr $8f61	                jsr xt_fetch
.a498	60		rts		z_two_constant: rts
.a499					xt_two_literal:
.a499	20 fb d7	jsr $d7fb	                jsr underflow_2 ; double number
.a49c	20 60 a1	jsr $a160	                jsr xt_swap
.a49f	20 6b 93	jsr $936b	                jsr xt_literal
.a4a2	20 6b 93	jsr $936b	                jsr xt_literal
.a4a5	60		rts		z_two_literal:  rts
.a4a6					xt_two_variable:
.a4a6	20 4a 89	jsr $894a	                jsr xt_create
.a4a9	ca		dex		                dex
.a4aa	ca		dex		                dex
.a4ab	a9 04		lda #$04	                lda #4
.a4ad	95 00		sta $00,x	                sta 0,x
.a4af	74 01		stz $01,x	                stz 1,x
.a4b1	20 8c 82	jsr $828c	                jsr xt_allot
.a4b4	60		rts		z_two_variable: rts
.a4b5					xt_type:
.a4b5	20 fb d7	jsr $d7fb	                jsr underflow_2
.a4b8	b5 02		lda $02,x	                lda 2,x
.a4ba	85 24		sta $24		                sta tmp1
.a4bc	b5 03		lda $03,x	                lda 3,x
.a4be	85 25		sta $25		                sta tmp1+1
.a4c0					_loop:
.a4c0	b5 00		lda $00,x	                lda 0,x
.a4c2	15 01		ora $01,x	                ora 1,x
.a4c4	f0 15		beq $a4db	                beq _done
.a4c6	b2 24		lda ($24)	                lda (tmp1)
.a4c8	20 d7 8d	jsr $8dd7	                jsr emit_a      ; avoids stack foolery
.a4cb	e6 24		inc $24		                inc tmp1
.a4cd	d0 02		bne $a4d1	                bne +
.a4cf	e6 25		inc $25		                inc tmp1+1
.a4d1					+
.a4d1	b5 00		lda $00,x	                lda 0,x
.a4d3	d0 02		bne $a4d7	                bne +
.a4d5	d6 01		dec $01,x	                dec 1,x
.a4d7					+
.a4d7	d6 00		dec $00,x	                dec 0,x
.a4d9	80 e5		bra $a4c0	                bra _loop
.a4db					_done:
.a4db	e8		inx		                inx
.a4dc	e8		inx		                inx
.a4dd	e8		inx		                inx
.a4de	e8		inx		                inx
.a4df	60		rts		z_type:         rts
.a4e0					xt_u_dot:
.a4e0	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a4e3	20 63 d8	jsr $d863	                jsr print_u
.a4e6	a9 20		lda #$20	                lda #AscSP
.a4e8	20 d7 8d	jsr $8dd7	                jsr emit_a
.a4eb	60		rts		z_u_dot:        rts
.a4ec					xt_u_dot_r:
.a4ec	20 fb d7	jsr $d7fb	                jsr underflow_2
.a4ef	20 22 a3	jsr $a322	                jsr xt_to_r
.a4f2	20 5a a7	jsr $a75a	                jsr xt_zero
.a4f5	20 3b 93	jsr $933b	                jsr xt_less_number_sign
.a4f8	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.a4fb	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.a4fe	20 73 9a	jsr $9a73	                jsr xt_r_from
.a501	20 74 98	jsr $9874	                jsr xt_over
.a504	20 31 95	jsr $9531	                jsr xt_minus
.a507	20 d6 a0	jsr $a0d6	                jsr xt_spaces
.a50a	20 b5 a4	jsr $a4b5	                jsr xt_type
.a50d	60		rts		z_u_dot_r:      rts
.a50e					xt_u_greater_than:
.a50e	20 fb d7	jsr $d7fb	                jsr underflow_2
.a511	b5 00		lda $00,x	                lda 0,x
.a513	d5 02		cmp $02,x	                cmp 2,x
.a515	b5 01		lda $01,x	                lda 1,x
.a517	f5 03		sbc $03,x	                sbc 3,x
.a519	e8		inx		                inx
.a51a	e8		inx		                inx
.a51b	a9 00		lda #$00	                lda #0
.a51d	69 ff		adc #$ff	                adc #$ff
.a51f	95 00		sta $00,x	                sta 0,x         ; store flag
.a521	95 01		sta $01,x	                sta 1,x
.a523	60		rts		z_u_greater_than:    rts
.a524					xt_u_less_than:
.a524	20 fb d7	jsr $d7fb	                jsr underflow_2
.a527	b5 02		lda $02,x	                lda 2,x
.a529	d5 00		cmp $00,x	                cmp 0,x
.a52b	b5 03		lda $03,x	                lda 3,x
.a52d	f5 01		sbc $01,x	                sbc 1,x
.a52f	e8		inx		                inx
.a530	e8		inx		                inx
.a531	a9 00		lda #$00	                lda #0
.a533	69 ff		adc #$ff	                adc #$ff
.a535	95 00		sta $00,x	                sta 0,x         ; store flag
.a537	95 01		sta $01,x	                sta 1,x
.a539	60		rts		z_u_less_than:    rts
.a53a					xt_ud_dot:
.a53a	20 fb d7	jsr $d7fb	                jsr underflow_2 ; double number
.a53d	20 3b 93	jsr $933b	                jsr xt_less_number_sign
.a540	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.a543	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.a546	20 b5 a4	jsr $a4b5	                jsr xt_type
.a549	20 d0 a0	jsr $a0d0	                jsr xt_space
.a54c	60		rts		z_ud_dot:        rts
.a54d					xt_ud_dot_r:
.a54d	20 00 d8	jsr $d800	                jsr underflow_3
.a550	20 22 a3	jsr $a322	                jsr xt_to_r
.a553	20 3b 93	jsr $933b	                jsr xt_less_number_sign
.a556	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.a559	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.a55c	20 73 9a	jsr $9a73	                jsr xt_r_from
.a55f	20 74 98	jsr $9874	                jsr xt_over
.a562	20 31 95	jsr $9531	                jsr xt_minus
.a565	20 d6 a0	jsr $a0d6	                jsr xt_spaces
.a568	20 b5 a4	jsr $a4b5	                jsr xt_type
.a56b	60		rts		z_ud_dot_r:      rts
.a56c					xt_um_slash_mod:
.a56c	20 00 d8	jsr $d800	                jsr underflow_3
.a56f	b5 00		lda $00,x	                lda 0,x
.a571	15 01		ora $01,x	                ora 1,x
.a573	d0 05		bne $a57a	                bne _not_zero
.a575	a9 04		lda #$04	                lda #err_divzero
.a577	4c 0c d8	jmp $d80c	                jmp error
.a57a					_not_zero:
.a57a	a9 11		lda #$11	                lda #17
.a57c	85 2c		sta $2c		                sta tmptos
.a57e					_loop:
.a57e	36 04		rol $04,x	                rol 4,x
.a580	36 05		rol $05,x	                rol 5,x
.a582	c6 2c		dec $2c		                dec tmptos
.a584	f0 22		beq $a5a8	                beq _done
.a586	36 02		rol $02,x	                rol 2,x
.a588	36 03		rol $03,x	                rol 3,x
.a58a	64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a58c	26 24		rol $24		                rol tmp1
.a58e	38		sec		                sec
.a58f	b5 02		lda $02,x	                lda 2,x
.a591	f5 00		sbc $00,x	                sbc 0,x
.a593	85 25		sta $25		                sta tmp1+1
.a595	b5 03		lda $03,x	                lda 3,x
.a597	f5 01		sbc $01,x	                sbc 1,x
.a599	a8		tay		                tay
.a59a	a5 24		lda $24		                lda tmp1
.a59c	e9 00		sbc #$00	                sbc #0
.a59e	90 de		bcc $a57e	                bcc _loop
.a5a0	a5 25		lda $25		                lda tmp1+1
.a5a2	95 02		sta $02,x	                sta 2,x
.a5a4	94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a5a6	80 d6		bra $a57e	                bra _loop
.a5a8					_done:
.a5a8	e8		inx		                inx
.a5a9	e8		inx		                inx
.a5aa	20 60 a1	jsr $a160	                jsr xt_swap
.a5ad	60		rts		z_um_slash_mod: rts
.a5ae					xt_um_star:
.a5ae	20 fb d7	jsr $d7fb	                jsr underflow_2
.a5b1	18		clc		                clc
.a5b2	b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a5b4	e9 00		sbc #$00	                sbc #0
.a5b6	85 26		sta $26		                sta tmp2
.a5b8	b5 01		lda $01,x	                lda 1,x
.a5ba	e9 00		sbc #$00	                sbc #0
.a5bc	90 31		bcc $a5ef	                bcc _zero       ; is TOS zero?
.a5be	85 27		sta $27		                sta tmp2+1
.a5c0	a9 00		lda #$00	                lda #0
.a5c2	85 24		sta $24		                sta tmp1
.a5c4	86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a5c6	ca		dex		                dex
.a5c7	ca		dex		                dex
.a5c8					_outer_loop:
.a5c8	a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a5ca	56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a5cc					_inner_loop:
.a5cc	90 0c		bcc $a5da	                bcc _no_add
.a5ce	85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a5d0	a5 24		lda $24		                lda tmp1
.a5d2	65 26		adc $26		                adc tmp2
.a5d4	85 24		sta $24		                sta tmp1
.a5d6	a5 25		lda $25		                lda tmp1+1
.a5d8	65 27		adc $27		                adc tmp2+1
.a5da					_no_add:
.a5da	6a		ror a		                ror
.a5db	66 24		ror $24		                ror tmp1
.a5dd	76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a5df	88		dey		                dey
.a5e0	d0 ea		bne $a5cc	                bne _inner_loop ; go back for one more shift?
.a5e2	e8		inx		                inx
.a5e3	e4 28		cpx $28		                cpx tmp3
.a5e5	d0 e1		bne $a5c8	                bne _outer_loop ; go back for eight more shifts?
.a5e7	95 01		sta $01,x	                sta 1,x
.a5e9	a5 24		lda $24		                lda tmp1
.a5eb	95 00		sta $00,x	                sta 0,x
.a5ed	80 04		bra $a5f3	                bra _done
.a5ef					_zero:
.a5ef	74 02		stz $02,x	                stz 2,x
.a5f1	74 03		stz $03,x	                stz 3,x
.a5f3					_done:
.a5f3	60		rts		z_um_star:      rts
.a5f4					xt_unloop:
.a5f4	68		pla		                pla
.a5f5	68		pla		                pla
.a5f6	68		pla		                pla
.a5f7	68		pla		                pla
.a5f8	68		pla		                pla
.a5f9	68		pla		                pla
.a5fa	60		rts		z_unloop:       rts
.a5fb					xt_until:
.a5fb	a0 91		ldy #$91	                ldy #>zero_branch_runtime
.a5fd	a9 f5		lda #$f5	                lda #<zero_branch_runtime
.a5ff	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.a602	20 4f 87	jsr $874f	                jsr xt_comma
.a605	60		rts		z_until:        rts
.a606					xt_unused:
.a606	ca		dex		                dex
.a607	ca		dex		                dex
.a608	a9 00		lda #$00	                lda #<cp_end
.a60a	38		sec		                sec
.a60b	e5 00		sbc $00		                sbc cp
.a60d	95 00		sta $00,x	                sta 0,x
.a60f	a9 7c		lda #$7c	                lda #>cp_end
.a611	e5 01		sbc $01		                sbc cp+1
.a613	95 01		sta $01,x	                sta 1,x
.a615	60		rts		z_unused:       rts
.a616					xt_update:
.a616	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a618	b1 1e		lda ($1e),y	                lda (up),y
.a61a	09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a61c	91 1e		sta ($1e),y	                sta (up),y
.a61e	60		rts		z_update:       rts
.a61f					xt_useraddr:
.a61f	ca		dex		                dex
.a620	ca		dex		                dex
.a621	a9 1e		lda #$1e	                lda #<up
.a623	95 00		sta $00,x	                sta 0,x
.a625	a9 00		lda #$00	                lda #>up
.a627	95 01		sta $01,x	                sta 1,x
.a629	60		rts		z_useraddr:     rts
.a62a					xt_variable:
.a62a	20 4a 89	jsr $894a	                jsr xt_create
.a62d	a9 00		lda #$00	                lda #0
.a62f	92 00		sta ($00)	                sta (cp)
.a631	e6 00		inc $00		                inc cp
.a633	d0 02		bne $a637	                bne +
.a635	e6 01		inc $01		                inc cp+1
.a637					+
.a637	92 00		sta ($00)	                sta (cp)
.a639	e6 00		inc $00		                inc cp
.a63b	d0 02		bne $a63f	                bne +
.a63d	e6 01		inc $01		                inc cp+1
.a63f					+
.a63f	20 12 89	jsr $8912	                jsr adjust_z
.a642	60		rts		z_variable:     rts
.a643					xt_while:
.a643	a0 91		ldy #$91	                ldy #>zero_branch_runtime
.a645	a9 f5		lda #$f5	                lda #<zero_branch_runtime
.a647	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.a64a	20 53 91	jsr $9153	                jsr xt_here
.a64d	20 5a a7	jsr $a75a	                jsr xt_zero
.a650	20 4f 87	jsr $874f	                jsr xt_comma
.a653	20 60 a1	jsr $a160	                jsr xt_swap
.a656	60		rts		z_while:        rts
.a657					xt_within:
.a657	20 00 d8	jsr $d800	                jsr underflow_3
.a65a	20 74 98	jsr $9874	                jsr xt_over
.a65d	20 31 95	jsr $9531	                jsr xt_minus
.a660	20 22 a3	jsr $a322	                jsr xt_to_r
.a663	20 31 95	jsr $9531	                jsr xt_minus
.a666	20 73 9a	jsr $9a73	                jsr xt_r_from
.a669	20 24 a5	jsr $a524	                jsr xt_u_less_than
.a66c	60		rts		z_within:       rts
.a66d					xt_word:
.a66d	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a670	a4 0c		ldy $0c		                ldy toin                ; >IN
.a672					_loop:
.a672	c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a674	f0 09		beq $a67f	                beq _found_char
.a676	b1 08		lda ($08),y	                lda (cib),y
.a678	d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a67a	d0 03		bne $a67f	                bne _found_char
.a67c	c8		iny		                iny
.a67d	80 f3		bra $a672	                bra _loop
.a67f					_found_char:
.a67f	84 0c		sty $0c		                sty toin
.a681	20 1b 99	jsr $991b	                jsr xt_parse            ; Returns ( addr u )
.a684	b5 00		lda $00,x	                lda 0,x
.a686	92 00		sta ($00)	                sta (cp)                ; Save length of string
.a688	48		pha		                pha                     ; Keep copy of length for later
.a689	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( addr u u )
.a68c	a5 00		lda $00		                lda cp
.a68e	18		clc		                clc
.a68f	69 01		adc #$01	                adc #1
.a691	95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a693	a5 01		lda $01		                lda cp+1
.a695	69 00		adc #$00	                adc #0
.a697	95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a699	20 a3 95	jsr $95a3	                jsr xt_move
.a69c	ca		dex		                dex
.a69d	ca		dex		                dex
.a69e	a5 00		lda $00		                lda cp
.a6a0	95 00		sta $00,x	                sta 0,x
.a6a2	a5 01		lda $01		                lda cp+1
.a6a4	95 01		sta $01,x	                sta 1,x
.a6a6	68		pla		                pla                     ; length of string
.a6a7	18		clc		                clc
.a6a8	65 00		adc $00		                adc cp
.a6aa	85 00		sta $00		                sta cp
.a6ac	a5 01		lda $01		                lda cp+1
.a6ae	69 00		adc #$00	                adc #0                  ; we only need the carry
.a6b0	85 01		sta $01		                sta cp+1
.a6b2	60		rts		z_word:         rts
.a6b3					xt_wordlist:
.a6b3	a0 05		ldy #$05	                ldy #num_wordlists_offset
.a6b5	b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a6b7	c9 0c		cmp #$0c	                cmp #max_wordlists
.a6b9	d0 05		bne $a6c0	                bne _ok
.a6bb	a9 0b		lda #$0b	                lda #err_wordlist
.a6bd	4c 0c d8	jmp $d80c	                jmp error
.a6c0					_ok:
.a6c0	1a		inc a		                ina             ; Increment the wordlist#
.a6c1	91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a6c3	ca		dex		                dex             ; and put it on the stack.
.a6c4	ca		dex		                dex
.a6c5	95 00		sta $00,x	                sta 0,x
.a6c7	74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a6c9	60		rts		z_wordlist:     rts
.a6ca					xt_words:
.a6ca	20 44 89	jsr $8944	                jsr xt_cr
.a6cd	a9 00		lda #$00	                lda #0
.a6cf	48		pha		                pha
.a6d0	ca		dex		                dex                     ; Make room on the stack for
.a6d1	ca		dex		                dex                     ; a dictionary pointer.
.a6d2	64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a6d4					_wordlist_loop:
.a6d4	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a6d6	a5 28		lda $28		                lda tmp3
.a6d8	d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a6da	d0 02		bne $a6de	                bne _have_wordlist
.a6dc	80 45		bra $a723	                bra _words_done
.a6de					_have_wordlist:
.a6de	18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a6df	69 1f		adc #$1f	                adc #search_order_offset
.a6e1	a8		tay		                tay
.a6e2	b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a6e4	0a		asl a		                asl                     ; Turn offset into cells offset.
.a6e5	18		clc		                clc
.a6e6	69 06		adc #$06	                adc #wordlists_offset
.a6e8	a8		tay		                tay
.a6e9	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a6eb	95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a6ed	c8		iny		                iny
.a6ee	b1 1e		lda ($1e),y	                lda (up),y
.a6f0	95 01		sta $01,x	                sta 1,x
.a6f2					_loop:
.a6f2	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( nt nt )
.a6f5	20 df 95	jsr $95df	                jsr xt_name_to_string   ; ( nt addr u )
.a6f8	68		pla		                pla
.a6f9	18		clc		                clc
.a6fa	75 00		adc $00,x	                adc 0,x
.a6fc	1a		inc a		                ina                     ; don't forget the space between words
.a6fd	c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a6ff	90 06		bcc $a707	                bcc +
.a701	20 44 89	jsr $8944	                jsr xt_cr
.a704	b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a706	1a		inc a		                ina                     ; with length of this word.
.a707					+
.a707	48		pha		                pha
.a708	20 b5 a4	jsr $a4b5	                jsr xt_type             ; ( nt )
.a70b	a9 20		lda #$20	                lda #AscSP
.a70d	20 d7 8d	jsr $8dd7	                jsr emit_a
.a710	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+
.a713	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+
.a716	20 61 8f	jsr $8f61	                jsr xt_fetch            ; @ ( nt+1 )
.a719	b5 00		lda $00,x	                lda 0,x
.a71b	15 01		ora $01,x	                ora 1,x
.a71d	d0 d3		bne $a6f2	                bne _loop
.a71f	e6 28		inc $28		                inc tmp3
.a721	80 b1		bra $a6d4	                bra _wordlist_loop
.a723					_words_done:
.a723	68		pla		                pla                     ; dump counter
.a724	e8		inx		                inx
.a725	e8		inx		                inx
.a726	60		rts		z_words:        rts
.a727					xt_wordsize:
.a727	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a72a	b5 00		lda $00,x	                lda 0,x
.a72c	85 24		sta $24		                sta tmp1
.a72e	b5 01		lda $01,x	                lda 1,x
.a730	85 25		sta $25		                sta tmp1+1
.a732	a0 06		ldy #$06	                ldy #6
.a734	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a736	88		dey		                dey
.a737	88		dey		                dey
.a738	38		sec		                sec
.a739	f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a73b	95 00		sta $00,x	                sta 0,x
.a73d	a0 07		ldy #$07	                ldy #7
.a73f	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a741	88		dey		                dey
.a742	88		dey		                dey
.a743	f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a745	95 01		sta $01,x	                sta 1,x
.a747	60		rts		z_wordsize:     rts
.a748					xt_xor:
.a748	20 fb d7	jsr $d7fb	                jsr underflow_2
.a74b	b5 00		lda $00,x	                lda 0,x
.a74d	55 02		eor $02,x	                eor 2,x
.a74f	95 02		sta $02,x	                sta 2,x
.a751	b5 01		lda $01,x	                lda 1,x
.a753	55 03		eor $03,x	                eor 3,x
.a755	95 03		sta $03,x	                sta 3,x
.a757	e8		inx		                inx
.a758	e8		inx		                inx
.a759	60		rts		z_xor:          rts
.a75a					xt_case:
.a75a					xt_forth_wordlist:
.a75a					xt_zero:
.a75a	ca		dex		                dex             ; push
.a75b	ca		dex		                dex
.a75c	74 00		stz $00,x	                stz 0,x
.a75e	74 01		stz $01,x	                stz 1,x
.a760					z_case:
.a760					z_forth_wordlist:
.a760					z_zero:
.a760	60		rts		                rts
.a761					xt_zero_equal:
.a761	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a764	b5 00		lda $00,x	                lda 0,x
.a766	15 01		ora $01,x	                ora 1,x
.a768	f0 04		beq $a76e	                beq _zero
.a76a	a9 00		lda #$00	                lda #0
.a76c	80 02		bra $a770	                bra _store
.a76e					_zero:
.a76e	a9 ff		lda #$ff	                lda #$ff
.a770					_store:
.a770	95 00		sta $00,x	                sta 0,x
.a772	95 01		sta $01,x	                sta 1,x
.a774	60		rts		z_zero_equal:   rts
.a775					xt_zero_greater:
.a775	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a778	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a77a	b5 01		lda $01,x	                lda 1,x         ; MSB
.a77c	30 05		bmi $a783	                bmi _done       ; TOS is negative, keep FLASE
.a77e	15 00		ora $00,x	                ora 0,x
.a780	f0 01		beq $a783	                beq _done       ; TOS is zero, keep FALSE
.a782	88		dey		                dey             ; TOS is postive, make true
.a783					_done:
.a783	98		tya		                tya
.a784	95 00		sta $00,x	                sta 0,x
.a786	95 01		sta $01,x	                sta 1,x
.a788	60		rts		z_zero_greater: rts
.a789					xt_zero_less:
.a789	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a78c	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a78e	b5 01		lda $01,x	                lda 1,x         ; MSB
.a790	10 01		bpl $a793	                bpl _done       ; TOS is positive, so keep FALSE
.a792	88		dey		                dey             ; TOS is negative, make TRUE
.a793					_done:
.a793	98		tya		                tya
.a794	95 00		sta $00,x	                sta 0,x
.a796	95 01		sta $01,x	                sta 1,x
.a798	60		rts		z_zero_less:    rts
.a799					xt_zero_unequal:
.a799	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a79c	a0 00		ldy #$00	                ldy #0          ; default false
.a79e	b5 00		lda $00,x	                lda 0,x
.a7a0	15 01		ora $01,x	                ora 1,x
.a7a2	f0 01		beq $a7a5	                beq _got_zero
.a7a4	88		dey		                dey
.a7a5					_got_zero:
.a7a5	98		tya		                tya
.a7a6	95 00		sta $00,x	                sta 0,x
.a7a8	95 01		sta $01,x	                sta 1,x
.a7aa	60		rts		z_zero_unequal: rts
.a7ab					xt_editor_screen_helper:
.a7ab	20 90 8d	jsr $8d90	                jsr xt_dup
.a7ae	20 8b 9e	jsr $9e8b	                jsr xt_scr
.a7b1	20 3f a1	jsr $a13f	                jsr xt_store
.a7b4	20 96 85	jsr $8596	                jsr xt_buffer
.a7b7					z_editor_screen_helper:
.a7b7	60		rts		                rts
.a7b8					xt_editor_enter_screen:
.a7b8	20 ab a7	jsr $a7ab	                jsr xt_editor_screen_helper
.a7bb	20 0f 8d	jsr $8d0f	                jsr xt_drop
.a7be	64 2e		stz $2e		                stz editor1
.a7c0					_prompt_loop:
.a7c0	ca		dex		                dex
.a7c1	ca		dex		                dex
.a7c2	a5 2e		lda $2e		                lda editor1
.a7c4	95 00		sta $00,x	                sta 0,x
.a7c6	74 01		stz $01,x	                stz 1,x
.a7c8	20 8d a8	jsr $a88d	                jsr xt_editor_o
.a7cb	e6 2e		inc $2e		                inc editor1
.a7cd	a9 10		lda #$10	                lda #16
.a7cf	c5 2e		cmp $2e		                cmp editor1
.a7d1	d0 ed		bne $a7c0	                bne _prompt_loop
.a7d3					z_editor_enter_screen:
.a7d3	60		rts		                rts
.a7d4					xt_editor_erase_screen:
.a7d4	20 ab a7	jsr $a7ab	                jsr xt_editor_screen_helper
.a7d7	ca		dex		                dex
.a7d8	ca		dex		                dex
.a7d9	74 00		stz $00,x	                stz 0,x
.a7db	a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a7dd	95 01		sta $01,x	                sta 1,x
.a7df	20 cb 8e	jsr $8ecb	                jsr xt_blank
.a7e2	20 16 a6	jsr $a616	                jsr xt_update
.a7e5					z_editor_erase_screen:
.a7e5	60		rts		                rts
.a7e6					xt_editor_el:
.a7e6	20 74 a8	jsr $a874	                jsr xt_editor_line
.a7e9	ca		dex		                dex
.a7ea	ca		dex		                dex
.a7eb	a9 40		lda #$40	                lda #64
.a7ed	95 00		sta $00,x	                sta 0,x
.a7ef	74 01		stz $01,x	                stz 1,x
.a7f1	20 cb 8e	jsr $8ecb	                jsr xt_blank
.a7f4	20 16 a6	jsr $a616	                jsr xt_update
.a7f7	60		rts		z_editor_el:    rts
.a7f8					xt_editor_l:
.a7f8	ca		dex		                dex             ; Put SCR on the stack.
.a7f9	ca		dex		                dex
.a7fa	a0 02		ldy #$02	                ldy #scr_offset
.a7fc	b1 1e		lda ($1e),y	                lda (up),y
.a7fe	95 00		sta $00,x	                sta 0,x
.a800	c8		iny		                iny
.a801	b1 1e		lda ($1e),y	                lda (up),y
.a803	95 01		sta $01,x	                sta 1,x
.a805	20 a2 83	jsr $83a2	                jsr xt_block    ; Get the current screen.
.a808	20 44 89	jsr $8944	                jsr xt_cr
.a80b	80 08		bra $a815	                bra _after_screen_msg
.a80d					_screen_msg:
>a80d	53 63 72 65 65 6e 20 23		                .text "Screen #"
.a815					_after_screen_msg:
.a815	20 5b a0	jsr $a05b	                jsr sliteral_runtime
>a818	0d a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a81c	20 b5 a4	jsr $a4b5	                jsr xt_type
.a81f	20 8b 9e	jsr $9e8b	                jsr xt_scr
.a822	20 61 8f	jsr $8f61	                jsr xt_fetch
.a825	ca		dex		                dex
.a826	ca		dex		                dex
.a827	a9 04		lda #$04	                lda #4          ; four spaces
.a829	95 00		sta $00,x	                sta 0,x
.a82b	74 01		stz $01,x	                stz 1,x
.a82d	20 ec a4	jsr $a4ec	                jsr xt_u_dot_r
.a830	64 28		stz $28		                stz tmp3
.a832					_line_loop:
.a832	20 44 89	jsr $8944	                jsr xt_cr
.a835	ca		dex		                dex
.a836	ca		dex		                dex
.a837	ca		dex		                dex
.a838	ca		dex		                dex
.a839	74 03		stz $03,x	                stz 3,x
.a83b	a5 28		lda $28		                lda tmp3
.a83d	95 02		sta $02,x	                sta 2,x
.a83f	74 01		stz $01,x	                stz 1,x
.a841	a9 02		lda #$02	                lda #2
.a843	95 00		sta $00,x	                sta 0,x
.a845	20 ec a4	jsr $a4ec	                jsr xt_u_dot_r
.a848	20 d0 a0	jsr $a0d0	                jsr xt_space
.a84b	20 90 8d	jsr $8d90	                jsr xt_dup
.a84e	ca		dex		                dex
.a84f	ca		dex		                dex
.a850	a9 40		lda #$40	                lda #64
.a852	95 00		sta $00,x	                sta 0,x
.a854	74 01		stz $01,x	                stz 1,x
.a856	20 b5 a4	jsr $a4b5	                jsr xt_type
.a859	18		clc		                clc
.a85a	a9 40		lda #$40	                lda #64
.a85c	75 00		adc $00,x	                adc 0,x
.a85e	95 00		sta $00,x	                sta 0,x
.a860	b5 01		lda $01,x	                lda 1,x
.a862	69 00		adc #$00	                adc #0      ; Add carry
.a864	95 01		sta $01,x	                sta 1,x
.a866	e6 28		inc $28		                inc tmp3
.a868	a5 28		lda $28		                lda tmp3
.a86a	c9 10		cmp #$10	                cmp #16
.a86c	d0 c4		bne $a832	                bne _line_loop
.a86e	20 44 89	jsr $8944	                jsr xt_cr
.a871	e8		inx		                inx
.a872	e8		inx		                inx
.a873	60		rts		z_editor_l:            rts
.a874					xt_editor_line:
.a874	20 f6 d7	jsr $d7f6	                jsr underflow_1
.a877	a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a879					_shift_tos_left:
.a879	16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a87b	36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a87d	88		dey		                dey
.a87e	d0 f9		bne $a879	                bne _shift_tos_left
.a880	20 8b 9e	jsr $9e8b	                jsr xt_scr
.a883	20 61 8f	jsr $8f61	                jsr xt_fetch
.a886	20 a2 83	jsr $83a2	                jsr xt_block
.a889	20 c4 99	jsr $99c4	                jsr xt_plus
.a88c	60		rts		z_editor_line:  rts
.a88d					xt_editor_o:
.a88d	20 44 89	jsr $8944	                jsr xt_cr
.a890	20 90 8d	jsr $8d90	                jsr xt_dup
.a893	20 59 a3	jsr $a359	                jsr xt_two
.a896	20 ec a4	jsr $a4ec	                jsr xt_u_dot_r
.a899	20 d0 a0	jsr $a0d0	                jsr xt_space
.a89c	a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a89e	20 d7 8d	jsr $8dd7	                jsr emit_a
.a8a1	20 d0 a0	jsr $a0d0	                jsr xt_space
.a8a4	20 74 a8	jsr $a874	                jsr xt_editor_line
.a8a7	20 90 8d	jsr $8d90	                jsr xt_dup      ; Save a copy of the line address for later.
.a8aa	ca		dex		                dex
.a8ab	ca		dex		                dex
.a8ac	a9 40		lda #$40	                lda #64         ; chars/line
.a8ae	95 00		sta $00,x	                sta 0,x
.a8b0	74 01		stz $01,x	                stz 1,x
.a8b2	20 2f 81	jsr $812f	                jsr xt_accept
.a8b5	20 90 8d	jsr $8d90	                jsr xt_dup
.a8b8	20 4f 96	jsr $964f	                jsr xt_not_rote ; -rot
.a8bb	20 c4 99	jsr $99c4	                jsr xt_plus
.a8be	ca		dex		                dex
.a8bf	ca		dex		                dex
.a8c0	a9 40		lda #$40	                lda #64         ; chars/line
.a8c2	95 00		sta $00,x	                sta 0,x
.a8c4	74 01		stz $01,x	                stz 1,x
.a8c6	20 38 9b	jsr $9b38	                jsr xt_rot
.a8c9	20 31 95	jsr $9531	                jsr xt_minus
.a8cc	20 cb 8e	jsr $8ecb	                jsr xt_blank
.a8cf	20 16 a6	jsr $a616	                jsr xt_update
.a8d2	60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a8d3					assembler:
.a8d3					xt_asm_adc_h:
.a8d3	a9 69		lda #$69	                lda #$69
.a8d5	4c 2e ac	jmp $ac2e	                jmp asm_common
.a8d8					z_asm_adc_h:
.a8d8					xt_asm_adc_x:
.a8d8	a9 7d		lda #$7d	                lda #$7D
.a8da	4c 2e ac	jmp $ac2e	                jmp asm_common
.a8dd					z_asm_adc_x:
.a8dd					xt_asm_adc_y:
.a8dd	a9 79		lda #$79	                lda #$79
.a8df	4c 2e ac	jmp $ac2e	                jmp asm_common
.a8e2					z_asm_adc_y:
.a8e2					xt_asm_adc_z:
.a8e2	a9 65		lda #$65	                lda #$65
.a8e4	4c 2e ac	jmp $ac2e	                jmp asm_common
.a8e7					z_asm_adc_z:
.a8e7					xt_asm_adc_zi:
.a8e7	a9 72		lda #$72	                lda #$72
.a8e9	4c 2e ac	jmp $ac2e	                jmp asm_common
.a8ec					z_asm_adc_zi:
.a8ec					xt_asm_adc_ziy:
.a8ec	a9 71		lda #$71	                lda #$71
.a8ee	4c 2e ac	jmp $ac2e	                jmp asm_common
.a8f1					z_asm_adc_ziy:
.a8f1					xt_asm_adc_zx:
.a8f1	a9 75		lda #$75	                lda #$75
.a8f3	4c 2e ac	jmp $ac2e	                jmp asm_common
.a8f6					z_asm_adc_zx:
.a8f6					xt_asm_adc_zxi:
.a8f6	a9 61		lda #$61	                lda #$61
.a8f8	4c 2e ac	jmp $ac2e	                jmp asm_common
.a8fb					z_asm_adc_zxi:
.a8fb					xt_asm_and:
.a8fb	a9 2d		lda #$2d	                lda #$2D
.a8fd	4c 2e ac	jmp $ac2e	                jmp asm_common
.a900					z_asm_and:
.a900					xt_asm_and_h:
.a900	a9 29		lda #$29	                lda #$29
.a902	4c 2e ac	jmp $ac2e	                jmp asm_common
.a905					z_asm_and_h:
.a905					xt_asm_and_x:
.a905	a9 3d		lda #$3d	                lda #$3D
.a907	4c 2e ac	jmp $ac2e	                jmp asm_common
.a90a					z_asm_and_x:
.a90a					xt_asm_and_y:
.a90a	a9 39		lda #$39	                lda #$39
.a90c	4c 2e ac	jmp $ac2e	                jmp asm_common
.a90f					z_asm_and_y:
.a90f					xt_asm_and_z:
.a90f	a9 25		lda #$25	                lda #$25
.a911	4c 2e ac	jmp $ac2e	                jmp asm_common
.a914					z_asm_and_z:
.a914					xt_asm_and_zi:
.a914	a9 32		lda #$32	                lda #$32
.a916	4c 2e ac	jmp $ac2e	                jmp asm_common
.a919					z_asm_and_zi:
.a919					xt_asm_and_ziy:
.a919	a9 31		lda #$31	                lda #$31
.a91b	4c 2e ac	jmp $ac2e	                jmp asm_common
.a91e					z_asm_and_ziy:
.a91e					xt_asm_and_zx:
.a91e	a9 35		lda #$35	                lda #$35
.a920	4c 2e ac	jmp $ac2e	                jmp asm_common
.a923					z_asm_and_zx:
.a923					xt_asm_and_zxi:
.a923	a9 21		lda #$21	                lda #$21
.a925	4c 2e ac	jmp $ac2e	                jmp asm_common
.a928					z_asm_and_zxi:
.a928					xt_asm_asl:
.a928	a9 0e		lda #$0e	                lda #$0E
.a92a	4c 2e ac	jmp $ac2e	                jmp asm_common
.a92d					z_asm_asl:
.a92d					xt_asm_asl_a:
.a92d	a9 0a		lda #$0a	                lda #$0A
.a92f	4c 2e ac	jmp $ac2e	                jmp asm_common
.a932					z_asm_asl_a:
.a932					xt_asm_asl_x:
.a932	a9 1e		lda #$1e	                lda #$1E
.a934	4c 2e ac	jmp $ac2e	                jmp asm_common
.a937					z_asm_asl_x:
.a937					xt_asm_asl_z:
.a937	a9 06		lda #$06	                lda #$06
.a939	4c 2e ac	jmp $ac2e	                jmp asm_common
.a93c					z_asm_asl_z:
.a93c					xt_asm_asl_zx:
.a93c	a9 16		lda #$16	                lda #$16
.a93e	4c 2e ac	jmp $ac2e	                jmp asm_common
.a941					z_asm_asl_zx:
.a941					xt_asm_bcc:
.a941	a9 90		lda #$90	                lda #$90
.a943	4c 2e ac	jmp $ac2e	                jmp asm_common
.a946					z_asm_bcc:
.a946					xt_asm_bcs:
.a946	a9 b0		lda #$b0	                lda #$B0
.a948	a0 02		ldy #$02	                ldy #2
.a94a	4c 2e ac	jmp $ac2e	                jmp asm_common
.a94d					z_asm_bcs:
.a94d					xt_asm_beq:
.a94d	a9 f0		lda #$f0	                lda #$F0
.a94f	4c 2e ac	jmp $ac2e	                jmp asm_common
.a952					z_asm_beq:
.a952					xt_asm_bit:
.a952	a9 2c		lda #$2c	                lda #$2C
.a954	4c 2e ac	jmp $ac2e	                jmp asm_common
.a957					z_asm_bit:
.a957					xt_asm_bit_h:
.a957	a9 89		lda #$89	                lda #$89
.a959	4c 2e ac	jmp $ac2e	                jmp asm_common
.a95c					z_asm_bit_h:
.a95c					xt_asm_bit_x:
.a95c	a9 3c		lda #$3c	                lda #$3C
.a95e	4c 2e ac	jmp $ac2e	                jmp asm_common
.a961					z_asm_bit_x:
.a961					xt_asm_bit_z:
.a961	a9 24		lda #$24	                lda #$24
.a963	4c 2e ac	jmp $ac2e	                jmp asm_common
.a966					z_asm_bit_z:
.a966					xt_asm_bit_zx:
.a966	a9 34		lda #$34	                lda #$34
.a968	4c 2e ac	jmp $ac2e	                jmp asm_common
.a96b					z_asm_bit_zx:
.a96b					xt_asm_bmi:
.a96b	a9 30		lda #$30	                lda #$30
.a96d	4c 2e ac	jmp $ac2e	                jmp asm_common
.a970					z_asm_bmi:
.a970					xt_asm_bne:
.a970	a9 d0		lda #$d0	                lda #$D0
.a972	4c 2e ac	jmp $ac2e	                jmp asm_common
.a975					z_asm_bne:
.a975					xt_asm_bpl:
.a975	a9 10		lda #$10	                lda #$10
.a977	4c 2e ac	jmp $ac2e	                jmp asm_common
.a97a					z_asm_bpl:
.a97a					xt_asm_bra:
.a97a	a9 80		lda #$80	                lda #$80
.a97c	4c 2e ac	jmp $ac2e	                jmp asm_common
.a97f					z_asm_bra:
.a97f					xt_asm_brk:
.a97f	a9 00		lda #$00	                lda #$00
.a981	4c 2e ac	jmp $ac2e	                jmp asm_common
.a984					z_asm_brk:
.a984					xt_asm_bvc:
.a984	a9 50		lda #$50	                lda #$50
.a986	4c 2e ac	jmp $ac2e	                jmp asm_common
.a989					z_asm_bvc:
.a989					xt_asm_bvs:
.a989	a9 70		lda #$70	                lda #$70
.a98b	4c 2e ac	jmp $ac2e	                jmp asm_common
.a98e					z_asm_bvs:
.a98e					xt_asm_clc:
.a98e	a9 18		lda #$18	                lda #$18
.a990	4c 2e ac	jmp $ac2e	                jmp asm_common
.a993					z_asm_clc:
.a993					xt_asm_cld:
.a993	a9 d8		lda #$d8	                lda #$D8
.a995	4c 2e ac	jmp $ac2e	                jmp asm_common
.a998					z_asm_cld:
.a998					xt_asm_cli:
.a998	a9 58		lda #$58	                lda #$58
.a99a	4c 2e ac	jmp $ac2e	                jmp asm_common
.a99d					z_asm_cli:
.a99d					xt_asm_clv:
.a99d	a9 b8		lda #$b8	                lda #$B8
.a99f	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9a2					z_asm_clv:
.a9a2					xt_asm_cmp:
.a9a2	a9 cd		lda #$cd	                lda #$CD
.a9a4	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9a7					z_asm_cmp:
.a9a7					xt_asm_cmp_h:
.a9a7	a9 c9		lda #$c9	                lda #$C9
.a9a9	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9ac					z_asm_cmp_h:
.a9ac					xt_asm_cmp_x:
.a9ac	a9 dd		lda #$dd	                lda #$DD
.a9ae	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9b1					z_asm_cmp_x:
.a9b1					xt_asm_cmp_y:
.a9b1	a9 d9		lda #$d9	                lda #$D9
.a9b3	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9b6					z_asm_cmp_y:
.a9b6					xt_asm_cmp_z:
.a9b6	a9 c5		lda #$c5	                lda #$C5
.a9b8	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9bb					z_asm_cmp_z:
.a9bb					xt_asm_cmp_zi:
.a9bb	a9 d2		lda #$d2	                lda #$D2
.a9bd	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9c0					z_asm_cmp_zi:
.a9c0					xt_asm_cmp_ziy:
.a9c0	a9 d1		lda #$d1	                lda #$D1
.a9c2	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9c5					z_asm_cmp_ziy:
.a9c5					xt_asm_cmp_zx:
.a9c5	a9 d5		lda #$d5	                lda #$D5
.a9c7	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9ca					z_asm_cmp_zx:
.a9ca					xt_asm_cmp_zxi:
.a9ca	a9 c1		lda #$c1	                lda #$C1
.a9cc	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9cf					z_asm_cmp_zxi:
.a9cf					xt_asm_cpx:
.a9cf	a9 ec		lda #$ec	                lda #$EC
.a9d1	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9d4					z_asm_cpx:
.a9d4					xt_asm_cpx_h:
.a9d4	a9 e0		lda #$e0	                lda #$E0
.a9d6	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9d9					z_asm_cpx_h:
.a9d9					xt_asm_cpx_z:
.a9d9	a9 e4		lda #$e4	                lda #$E4
.a9db	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9de					z_asm_cpx_z:
.a9de					xt_asm_cpy:
.a9de	a9 cc		lda #$cc	                lda #$CC
.a9e0	a0 03		ldy #$03	                ldy #3
.a9e2	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9e5					z_asm_cpy:
.a9e5					xt_asm_cpy_h:
.a9e5	a9 c0		lda #$c0	                lda #$C0
.a9e7	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9ea					z_asm_cpy_h:
.a9ea					xt_asm_cpy_z:
.a9ea	a9 c4		lda #$c4	                lda #$C4
.a9ec	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9ef					z_asm_cpy_z:
.a9ef					xt_asm_dec:
.a9ef	a9 ce		lda #$ce	                lda #$CE
.a9f1	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9f4					z_asm_dec:
.a9f4					xt_asm_dec_a:
.a9f4	a9 3a		lda #$3a	                lda #$3A
.a9f6	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9f9					z_asm_dec_a:
.a9f9					xt_asm_dec_x:
.a9f9	a9 de		lda #$de	                lda #$DE
.a9fb	4c 2e ac	jmp $ac2e	                jmp asm_common
.a9fe					z_asm_dec_x:
.a9fe					xt_asm_dec_z:
.a9fe	a9 c6		lda #$c6	                lda #$C6
.aa00	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa03					z_asm_dec_z:
.aa03					xt_asm_dec_zx:
.aa03	a9 d6		lda #$d6	                lda #$D6
.aa05	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa08					z_asm_dec_zx:
.aa08					xt_asm_dex:
.aa08	a9 ca		lda #$ca	                lda #$CA
.aa0a	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa0d					z_asm_dex:
.aa0d					xt_asm_dey:
.aa0d	a9 88		lda #$88	                lda #$88
.aa0f	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa12					z_asm_dey:
.aa12					xt_asm_eor:
.aa12	a9 4d		lda #$4d	                lda #$4D
.aa14	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa17					z_asm_eor:
.aa17					xt_asm_eor_h:
.aa17	a9 49		lda #$49	                lda #$49
.aa19	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa1c					z_asm_eor_h:
.aa1c					xt_asm_eor_x:
.aa1c	a9 5d		lda #$5d	                lda #$5D
.aa1e	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa21					z_asm_eor_x:
.aa21					xt_asm_eor_y:
.aa21	a9 59		lda #$59	                lda #$59
.aa23	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa26					z_asm_eor_y:
.aa26					xt_asm_eor_z:
.aa26	a9 45		lda #$45	                lda #$45
.aa28	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa2b					z_asm_eor_z:
.aa2b					xt_asm_eor_zi:
.aa2b	a9 52		lda #$52	                lda #$52
.aa2d	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa30					z_asm_eor_zi:
.aa30					xt_asm_eor_ziy:
.aa30	a9 51		lda #$51	                lda #$51
.aa32	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa35					z_asm_eor_ziy:
.aa35					xt_asm_eor_zx:
.aa35	a9 55		lda #$55	                lda #$55
.aa37	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa3a					z_asm_eor_zx:
.aa3a					xt_asm_eor_zxi:
.aa3a	a9 41		lda #$41	                lda #$41
.aa3c	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa3f					z_asm_eor_zxi:
.aa3f					xt_asm_inc:
.aa3f	a9 ee		lda #$ee	                lda #$EE
.aa41	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa44					z_asm_inc:
.aa44					xt_asm_inc_a:
.aa44	a9 1a		lda #$1a	                lda #$1A
.aa46	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa49					z_asm_inc_a:
.aa49					xt_asm_inc_x:
.aa49	a9 fe		lda #$fe	                lda #$FE
.aa4b	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa4e					z_asm_inc_x:
.aa4e					xt_asm_inc_z:
.aa4e	a9 e6		lda #$e6	                lda #$E6
.aa50	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa53					z_asm_inc_z:
.aa53					xt_asm_inc_zx:
.aa53	a9 f6		lda #$f6	                lda #$F6
.aa55	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa58					z_asm_inc_zx:
.aa58					xt_asm_inx:
.aa58	a9 e8		lda #$e8	                lda #$E8
.aa5a	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa5d					z_asm_inx:
.aa5d					xt_asm_iny:
.aa5d	a9 c8		lda #$c8	                lda #$C8
.aa5f	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa62					z_asm_iny:
.aa62					xt_asm_jmp:
.aa62	a9 4c		lda #$4c	                lda #$4C
.aa64	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa67					z_asm_jmp:
.aa67					xt_asm_jmp_i:
.aa67	a9 6c		lda #$6c	                lda #$6C
.aa69	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa6c					z_asm_jmp_i:
.aa6c					xt_asm_jmp_xi:
.aa6c	a9 7c		lda #$7c	                lda #$7C
.aa6e	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa71					z_asm_jmp_xi:
.aa71					xt_asm_jsr:
.aa71	a9 20		lda #$20	                lda #$20
.aa73	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa76					z_asm_jsr:
.aa76					xt_asm_lda:
.aa76	a9 ad		lda #$ad	                lda #$AD
.aa78	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa7b					z_asm_lda:
.aa7b					xt_asm_lda_h:
.aa7b	a9 a9		lda #$a9	                lda #$A9
.aa7d	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa80					z_asm_lda_h:
.aa80					xt_asm_lda_x:
.aa80	a9 bd		lda #$bd	                lda #$BD
.aa82	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa85					z_asm_lda_x:
.aa85					xt_asm_lda_y:
.aa85	a9 b9		lda #$b9	                lda #$B9
.aa87	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa8a					z_asm_lda_y:
.aa8a					xt_asm_lda_z:
.aa8a	a9 a5		lda #$a5	                lda #$A5
.aa8c	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa8f					z_asm_lda_z:
.aa8f					xt_asm_lda_zi:
.aa8f	a9 b2		lda #$b2	                lda #$B2
.aa91	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa94					z_asm_lda_zi:
.aa94					xt_asm_lda_ziy:
.aa94	a9 b1		lda #$b1	                lda #$B1
.aa96	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa99					z_asm_lda_ziy:
.aa99					xt_asm_lda_zx:
.aa99	a9 b5		lda #$b5	                lda #$B5
.aa9b	4c 2e ac	jmp $ac2e	                jmp asm_common
.aa9e					z_asm_lda_zx:
.aa9e					xt_asm_lda_zxi:
.aa9e	a9 a1		lda #$a1	                lda #$A1
.aaa0	4c 2e ac	jmp $ac2e	                jmp asm_common
.aaa3					z_asm_lda_zxi:
.aaa3					xt_asm_ldx:
.aaa3	a9 ae		lda #$ae	                lda #$AE
.aaa5	4c 2e ac	jmp $ac2e	                jmp asm_common
.aaa8					z_asm_ldx:
.aaa8					xt_asm_ldx_h:
.aaa8	a9 a2		lda #$a2	                lda #$A2
.aaaa	4c 2e ac	jmp $ac2e	                jmp asm_common
.aaad					z_asm_ldx_h:
.aaad					xt_asm_ldx_y:
.aaad	a9 be		lda #$be	                lda #$BE
.aaaf	4c 2e ac	jmp $ac2e	                jmp asm_common
.aab2					z_asm_ldx_y:
.aab2					xt_asm_ldx_z:
.aab2	a9 a6		lda #$a6	                lda #$A6
.aab4	4c 2e ac	jmp $ac2e	                jmp asm_common
.aab7					z_asm_ldx_z:
.aab7					xt_asm_ldx_zy:
.aab7	a9 b6		lda #$b6	                lda #$B6
.aab9	4c 2e ac	jmp $ac2e	                jmp asm_common
.aabc					z_asm_ldx_zy:
.aabc					xt_asm_ldy:
.aabc	a9 ac		lda #$ac	                lda #$AC
.aabe	4c 2e ac	jmp $ac2e	                jmp asm_common
.aac1					z_asm_ldy:
.aac1					xt_asm_ldy_h:
.aac1	a9 a0		lda #$a0	                lda #$A0
.aac3	4c 2e ac	jmp $ac2e	                jmp asm_common
.aac6					z_asm_ldy_h:
.aac6					xt_asm_ldy_x:
.aac6	a9 bc		lda #$bc	                lda #$BC
.aac8	4c 2e ac	jmp $ac2e	                jmp asm_common
.aacb					z_asm_ldy_x:
.aacb					xt_asm_ldy_z:
.aacb	a9 a4		lda #$a4	                lda #$A4
.aacd	4c 2e ac	jmp $ac2e	                jmp asm_common
.aad0					z_asm_ldy_z:
.aad0					xt_asm_ldy_zx:
.aad0	a9 b4		lda #$b4	                lda #$B4
.aad2	4c 2e ac	jmp $ac2e	                jmp asm_common
.aad5					z_asm_ldy_zx:
.aad5					xt_asm_lsr:
.aad5	a9 4e		lda #$4e	                lda #$4E
.aad7	4c 2e ac	jmp $ac2e	                jmp asm_common
.aada					z_asm_lsr:
.aada					xt_asm_lsr_a:
.aada	a9 4a		lda #$4a	                lda #$4A
.aadc	4c 2e ac	jmp $ac2e	                jmp asm_common
.aadf					z_asm_lsr_a:
.aadf					xt_asm_lsr_x:
.aadf	a9 5e		lda #$5e	                lda #$5E
.aae1	4c 2e ac	jmp $ac2e	                jmp asm_common
.aae4					z_asm_lsr_x:
.aae4					xt_asm_lsr_z:
.aae4	a9 46		lda #$46	                lda #$46
.aae6	4c 2e ac	jmp $ac2e	                jmp asm_common
.aae9					z_asm_lsr_z:
.aae9					xt_asm_lsr_zx:
.aae9	a9 56		lda #$56	                lda #$56
.aaeb	4c 2e ac	jmp $ac2e	                jmp asm_common
.aaee					z_asm_lsr_zx:
.aaee					xt_asm_nop:
.aaee	a9 ea		lda #$ea	                lda #$EA
.aaf0	4c 2e ac	jmp $ac2e	                jmp asm_common
.aaf3					z_asm_nop:
.aaf3					xt_asm_ora:
.aaf3	a9 0d		lda #$0d	                lda #$0D
.aaf5	4c 2e ac	jmp $ac2e	                jmp asm_common
.aaf8					z_asm_ora:
.aaf8					xt_asm_ora_h:
.aaf8	a9 09		lda #$09	                lda #$09
.aafa	4c 2e ac	jmp $ac2e	                jmp asm_common
.aafd					z_asm_ora_h:
.aafd					xt_asm_ora_x:
.aafd	a9 1d		lda #$1d	                lda #$1D
.aaff	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab02					z_asm_ora_x:
.ab02					xt_asm_ora_y:
.ab02	a9 19		lda #$19	                lda #$19
.ab04	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab07					z_asm_ora_y:
.ab07					xt_asm_ora_z:
.ab07	a9 05		lda #$05	                lda #$05
.ab09	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab0c					z_asm_ora_z:
.ab0c					xt_asm_ora_zi:
.ab0c	a9 12		lda #$12	                lda #$12
.ab0e	a0 02		ldy #$02	                ldy #2
.ab10	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab13					z_asm_ora_zi:
.ab13					xt_asm_ora_ziy:
.ab13	a9 11		lda #$11	                lda #$11
.ab15	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab18					z_asm_ora_ziy:
.ab18					xt_asm_ora_zx:
.ab18	a9 15		lda #$15	                lda #$15
.ab1a	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab1d					z_asm_ora_zx:
.ab1d					xt_asm_ora_zxi:
.ab1d	a9 01		lda #$01	                lda #$01
.ab1f	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab22					z_asm_ora_zxi:
.ab22					xt_asm_pha:
.ab22	a9 48		lda #$48	                lda #$48
.ab24	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab27					z_asm_pha:
.ab27					xt_asm_php:
.ab27	a9 08		lda #$08	                lda #$08
.ab29	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab2c					z_asm_php:
.ab2c					xt_asm_phx:
.ab2c	a9 da		lda #$da	                lda #$DA
.ab2e	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab31					z_asm_phx:
.ab31					xt_asm_phy:
.ab31	a9 5a		lda #$5a	                lda #$5A
.ab33	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab36					z_asm_phy:
.ab36					xt_asm_pla:
.ab36	a9 68		lda #$68	                lda #$68
.ab38	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab3b					z_asm_pla:
.ab3b					xt_asm_plp:
.ab3b	a9 28		lda #$28	                lda #$28
.ab3d	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab40					z_asm_plp:
.ab40					xt_asm_plx:
.ab40	a9 fa		lda #$fa	                lda #$FA
.ab42	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab45					z_asm_plx:
.ab45					xt_asm_ply:
.ab45	a9 7a		lda #$7a	                lda #$7A
.ab47	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab4a					z_asm_ply:
.ab4a					xt_asm_rol:
.ab4a	a9 2e		lda #$2e	                lda #$2E
.ab4c	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab4f					z_asm_rol:
.ab4f					xt_asm_rol_a:
.ab4f	a9 2a		lda #$2a	                lda #$2A
.ab51	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab54					z_asm_rol_a:
.ab54					xt_asm_rol_x:
.ab54	a9 3e		lda #$3e	                lda #$3E
.ab56	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab59					z_asm_rol_x:
.ab59					xt_asm_rol_z:
.ab59	a9 26		lda #$26	                lda #$26
.ab5b	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab5e					z_asm_rol_z:
.ab5e					xt_asm_rol_zx:
.ab5e	a9 36		lda #$36	                lda #$36
.ab60	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab63					z_asm_rol_zx:
.ab63					xt_asm_ror:
.ab63	a9 6e		lda #$6e	                lda #$6E
.ab65	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab68					z_asm_ror:
.ab68					xt_asm_ror_a:
.ab68	a9 6a		lda #$6a	                lda #$6A
.ab6a	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab6d					z_asm_ror_a:
.ab6d					xt_asm_ror_x:
.ab6d	a9 7e		lda #$7e	                lda #$7E
.ab6f	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab72					z_asm_ror_x:
.ab72					xt_asm_ror_z:
.ab72	a9 66		lda #$66	                lda #$66
.ab74	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab77					z_asm_ror_z:
.ab77					xt_asm_ror_zx:
.ab77	a9 76		lda #$76	                lda #$76
.ab79	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab7c					z_asm_ror_zx:
.ab7c					xt_asm_rti:
.ab7c	a9 40		lda #$40	                lda #$40
.ab7e	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab81					z_asm_rti:
.ab81					xt_asm_rts:
.ab81	a9 60		lda #$60	                lda #$60
.ab83	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab86					z_asm_rts:
.ab86					xt_asm_sbc:
.ab86	a9 ed		lda #$ed	                lda #$ED
.ab88	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab8b					z_asm_sbc:
.ab8b					xt_asm_sbc_h:
.ab8b	a9 e9		lda #$e9	                lda #$E9
.ab8d	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab90					z_asm_sbc_h:
.ab90					xt_asm_sbc_x:
.ab90	a9 fd		lda #$fd	                lda #$FD
.ab92	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab95					z_asm_sbc_x:
.ab95					xt_asm_sbc_y:
.ab95	a9 f9		lda #$f9	                lda #$F9
.ab97	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab9a					z_asm_sbc_y:
.ab9a					xt_asm_sbc_z:
.ab9a	a9 e5		lda #$e5	                lda #$E5
.ab9c	4c 2e ac	jmp $ac2e	                jmp asm_common
.ab9f					z_asm_sbc_z:
.ab9f					xt_asm_sbc_zi:
.ab9f	a9 f2		lda #$f2	                lda #$F2
.aba1	4c 2e ac	jmp $ac2e	                jmp asm_common
.aba4					z_asm_sbc_zi:
.aba4					xt_asm_sbc_ziy:
.aba4	a9 f1		lda #$f1	                lda #$F1
.aba6	4c 2e ac	jmp $ac2e	                jmp asm_common
.aba9					z_asm_sbc_ziy:
.aba9					xt_asm_sbc_zx:
.aba9	a9 f5		lda #$f5	                lda #$F5
.abab	4c 2e ac	jmp $ac2e	                jmp asm_common
.abae					z_asm_sbc_zx:
.abae					xt_asm_sbc_zxi:
.abae	a9 e1		lda #$e1	                lda #$E1
.abb0	80 7c		bra $ac2e	                bra asm_common  ; <-- limit for BRA instead of JMP
.abb2					z_asm_sbc_zxi:
.abb2					xt_asm_sec:
.abb2	a9 38		lda #$38	                lda #$38
.abb4	80 78		bra $ac2e	                bra asm_common
.abb6					z_asm_sec:
.abb6					xt_asm_sed:
.abb6	a9 f8		lda #$f8	                lda #$F8
.abb8	80 74		bra $ac2e	                bra asm_common
.abba					z_asm_sed:
.abba					xt_asm_sei:
.abba	a9 78		lda #$78	                lda #$78
.abbc	80 70		bra $ac2e	                bra asm_common
.abbe					z_asm_sei:
.abbe					xt_asm_sta:
.abbe	a9 8d		lda #$8d	                lda #$8D
.abc0	80 6c		bra $ac2e	                bra asm_common
.abc2					z_asm_sta:
.abc2					xt_asm_sta_x:
.abc2	a9 9d		lda #$9d	                lda #$9D
.abc4	80 68		bra $ac2e	                bra asm_common
.abc6					z_asm_sta_x:
.abc6					xt_asm_sta_y:
.abc6	a9 99		lda #$99	                lda #$99
.abc8	80 64		bra $ac2e	                bra asm_common
.abca					z_asm_sta_y:
.abca					xt_asm_sta_z:
.abca	a9 85		lda #$85	                lda #$85
.abcc	80 60		bra $ac2e	                bra asm_common
.abce					z_asm_sta_z:
.abce					xt_asm_sta_zi:
.abce	a9 92		lda #$92	                lda #$92
.abd0	80 5c		bra $ac2e	                bra asm_common
.abd2					z_asm_sta_zi:
.abd2					xt_asm_sta_ziy:
.abd2	a9 91		lda #$91	                lda #$91
.abd4	80 58		bra $ac2e	                bra asm_common
.abd6					z_asm_sta_ziy:
.abd6					xt_asm_sta_zx:
.abd6	a9 95		lda #$95	                lda #$95
.abd8	80 54		bra $ac2e	                bra asm_common
.abda					z_asm_sta_zx:
.abda					xt_asm_sta_zxi:
.abda	a9 81		lda #$81	                lda #$81
.abdc	80 50		bra $ac2e	                bra asm_common
.abde					z_asm_sta_zxi:
.abde					xt_asm_stx:
.abde	a9 8e		lda #$8e	                lda #$8E
.abe0	80 4c		bra $ac2e	                bra asm_common
.abe2					z_asm_stx:
.abe2					xt_asm_stx_z:
.abe2	a9 86		lda #$86	                lda #$86
.abe4	80 48		bra $ac2e	                bra asm_common
.abe6					z_asm_stx_z:
.abe6					xt_asm_stx_zy:
.abe6	a9 96		lda #$96	                lda #$96
.abe8	80 44		bra $ac2e	                bra asm_common
.abea					z_asm_stx_zy:
.abea					xt_asm_sty:
.abea	a9 8c		lda #$8c	                lda #$8C
.abec	80 40		bra $ac2e	                bra asm_common
.abee					z_asm_sty:
.abee					xt_asm_sty_z:
.abee	a9 84		lda #$84	                lda #$84
.abf0	80 3c		bra $ac2e	                bra asm_common
.abf2					z_asm_sty_z:
.abf2					xt_asm_sty_zx:
.abf2	a9 94		lda #$94	                lda #$94
.abf4	80 38		bra $ac2e	                bra asm_common
.abf6					z_asm_sty_zx:
.abf6					xt_asm_stz:
.abf6	a9 9c		lda #$9c	                lda #$9C
.abf8	80 34		bra $ac2e	                bra asm_common
.abfa					z_asm_stz:
.abfa					xt_asm_stz_x:
.abfa	a9 9e		lda #$9e	                lda #$9E
.abfc	80 30		bra $ac2e	                bra asm_common
.abfe					z_asm_stz_x:
.abfe					xt_asm_stz_z:
.abfe	a9 64		lda #$64	                lda #$64
.ac00	80 2c		bra $ac2e	                bra asm_common
.ac02					z_asm_stz_z:
.ac02					xt_asm_stz_zx:
.ac02	a9 74		lda #$74	                lda #$74
.ac04	80 28		bra $ac2e	                bra asm_common
.ac06					z_asm_stz_zx:
.ac06					xt_asm_tax:
.ac06	a9 aa		lda #$aa	                lda #$AA
.ac08	80 24		bra $ac2e	                bra asm_common
.ac0a					z_asm_tax:
.ac0a					xt_asm_tay:
.ac0a	a9 a8		lda #$a8	                lda #$A8
.ac0c	80 20		bra $ac2e	                bra asm_common
.ac0e					z_asm_tay:
.ac0e					xt_asm_trb:
.ac0e	a9 1c		lda #$1c	                lda #$1C
.ac10	80 1c		bra $ac2e	                bra asm_common
.ac12					z_asm_trb:
.ac12					xt_asm_trb_z:
.ac12	a9 14		lda #$14	                lda #$14
.ac14	80 18		bra $ac2e	                bra asm_common
.ac16					z_asm_trb_z:
.ac16					xt_asm_tsb:
.ac16	a9 0c		lda #$0c	                lda #$0C
.ac18	80 14		bra $ac2e	                bra asm_common
.ac1a					z_asm_tsb:
.ac1a					xt_asm_tsb_z:
.ac1a	a9 04		lda #$04	                lda #$04
.ac1c	80 10		bra $ac2e	                bra asm_common
.ac1e					z_asm_tsb_z:
.ac1e					xt_asm_tsx:
.ac1e	a9 ba		lda #$ba	                lda #$BA
.ac20	80 0c		bra $ac2e	                bra asm_common
.ac22					z_asm_tsx:
.ac22					xt_asm_txa:
.ac22	a9 8a		lda #$8a	                lda #$8A
.ac24	80 08		bra $ac2e	                bra asm_common
.ac26					z_asm_txa:
.ac26					xt_asm_txs:
.ac26	a9 9a		lda #$9a	                lda #$9A
.ac28	80 04		bra $ac2e	                bra asm_common
.ac2a					z_asm_txs:
.ac2a					xt_asm_tya:
.ac2a	a9 98		lda #$98	                lda #$98
.ac2c	80 00		bra $ac2e	                bra asm_common
.ac2e					z_asm_tya:
.ac2e					asm_common:
.ac2e	a8		tay		                tay
.ac2f	20 a9 d6	jsr $d6a9	                jsr cmpl_a
.ac32	a9 9a		lda #$9a	                lda #<oc_index_table
.ac34	85 26		sta $26		                sta tmp2
.ac36	a9 ae		lda #$ae	                lda #>oc_index_table
.ac38	85 27		sta $27		                sta tmp2+1
.ac3a	98		tya		                tya             ; retrieve opcode
.ac3b	0a		asl a		                asl             ; times two for offset
.ac3c	90 02		bcc $ac40	                bcc +
.ac3e	e6 27		inc $27		                inc tmp2+1
.ac40					+
.ac40	a8		tay		                tay             ; use Y as the index
.ac41	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac43	85 28		sta $28		                sta tmp3
.ac45	c8		iny		                iny
.ac46	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac48	85 29		sta $29		                sta tmp3+1
.ac4a	b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac4c	2a		rol a		                rol
.ac4d	2a		rol a		                rol
.ac4e	2a		rol a		                rol             ; Three times because we go through Carry
.ac4f	29 03		and #$03	                and #%00000011
.ac51	a8		tay		                tay
.ac52	88		dey		                dey
.ac53	f0 12		beq $ac67	                beq _done
.ac55	20 f6 d7	jsr $d7f6	                jsr underflow_1
.ac58	b5 00		lda $00,x	                lda 0,x
.ac5a	20 a9 d6	jsr $d6a9	                jsr cmpl_a      ; does not use Y
.ac5d	88		dey		                dey
.ac5e	f0 05		beq $ac65	                beq _done_drop
.ac60	b5 01		lda $01,x	                lda 1,x
.ac62	20 a9 d6	jsr $d6a9	                jsr cmpl_a      ; Fall through to _done_drop
.ac65					_done_drop:
.ac65	e8		inx		                inx
.ac66	e8		inx		                inx             ; Fall through to _done
.ac67					_done:
.ac67	60		rts		                rts             ; Returns to original caller
.ac68					xt_asm_push_a:
.ac68	a0 00		ldy #$00	                ldy #0
.ac6a					_loop:
.ac6a	b9 78 ac	lda $ac78,y	                lda asm_push_a_data,y
.ac6d	c9 ff		cmp #$ff	                cmp #$FF
.ac6f	f0 06		beq $ac77	                beq _done
.ac71	20 a9 d6	jsr $d6a9	                jsr cmpl_a      ; does not change Y
.ac74	c8		iny		                iny
.ac75	80 f3		bra $ac6a	                bra _loop
.ac77					_done:
.ac77					z_asm_push_a:
.ac77	60		rts		                rts
.ac78					asm_push_a_data:
>ac78	ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>ac7e	ff				        .byte $FF               ; terminator
.ac7f					xt_asm_back_jump:
.ac7f					z_asm_back_jump:
.ac7f	60		rts		                rts
.ac80					xt_asm_back_branch:
.ac80	20 53 91	jsr $9153	                jsr xt_here             ; ( addr-l addr-h )
.ac83	20 31 95	jsr $9531	                jsr xt_minus            ; ( offset )
.ac86	3a		dec a		                dea
.ac87	3a		dec a		                dea
.ac88					z_asm_back_branch:
.ac88	60		rts		                rts
.ac89					assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.ac89					disassembler:
.ac89	20 44 89	jsr $8944	                jsr xt_cr       ; ( addr u )
.ac8c					_byte_loop:
.ac8c	20 74 98	jsr $9874	                jsr xt_over     ; ( addr u addr )
.ac8f	20 e0 a4	jsr $a4e0	                jsr xt_u_dot    ; ( addr u )
.ac92	20 d0 a0	jsr $a0d0	                jsr xt_space
.ac95	a9 9a		lda #$9a	                lda #<oc_index_table
.ac97	85 26		sta $26		                sta tmp2
.ac99	a9 ae		lda #$ae	                lda #>oc_index_table
.ac9b	85 27		sta $27		                sta tmp2+1
.ac9d	a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.ac9f	85 36		sta $36		                sta scratch     ; Save opcode
.aca1	0a		asl a		                asl             ; multiply by two for offset
.aca2	90 02		bcc $aca6	                bcc +
.aca4	e6 27		inc $27		                inc tmp2+1      ; we're on second page
.aca6					+
.aca6	a8		tay		                tay             ; use Y as the index
.aca7	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.aca9	85 28		sta $28		                sta tmp3
.acab	48		pha		                pha
.acac	c8		iny		                iny
.acad	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acaf	85 29		sta $29		                sta tmp3+1
.acb1	48		pha		                pha
.acb2	b2 28		lda ($28)	                lda (tmp3)
.acb4	a8		tay		                tay                     ; save copy of lengths byte
.acb5	10 3c		bpl $acf3	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.acb7	20 5a a7	jsr $a75a	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.acba	f6 04		inc $04,x	                inc 4,x
.acbc	d0 02		bne $acc0	                bne +
.acbe	f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.acc0					+
.acc0	b5 02		lda $02,x	                lda 2,x
.acc2	d0 02		bne $acc6	                bne +
.acc4	d6 03		dec $03,x	                dec 3,x
.acc6					+
.acc6	d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.acc8	a1 04		lda ($04,x)	                lda (4,x)
.acca	95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.accc	85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.acce	98		tya		                tya                     ; retrieve copy of lengths byte
.accf	2a		rol a		                rol                     ; shift bit 6 to bit 7
.acd0	10 14		bpl $ace6	                bpl _print_operand
.acd2	f6 04		inc $04,x	                inc 4,x
.acd4	d0 02		bne $acd8	                bne +
.acd6	f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.acd8					+
.acd8	b5 02		lda $02,x	                lda 2,x
.acda	d0 02		bne $acde	                bne +
.acdc	d6 03		dec $03,x	                dec 3,x
.acde					+
.acde	d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ace0	a1 04		lda ($04,x)	                lda (4,x)
.ace2	95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ace4	85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ace6					_print_operand:
.ace6	ca		dex		                dex
.ace7	ca		dex		                dex
.ace8	a9 05		lda #$05	                lda #5
.acea	95 00		sta $00,x	                sta 0,x
.acec	74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.acee	20 ec a4	jsr $a4ec	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.acf1	80 0b		bra $acfe	                bra _print_mnemonic
.acf3					_no_operand:
.acf3	ca		dex		                dex
.acf4	ca		dex		                dex
.acf5	a9 05		lda #$05	                lda #5
.acf7	95 00		sta $00,x	                sta 0,x
.acf9	74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.acfb	20 d6 a0	jsr $a0d6	                jsr xt_spaces           ; ( addr u )
.acfe					_print_mnemonic:
.acfe	20 d0 a0	jsr $a0d0	                jsr xt_space
.ad01	ca		dex		                dex
.ad02	ca		dex		                dex                     ; ( addr u ? )
.ad03	68		pla		                pla                     ; MSB
.ad04	95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad06	68		pla		                pla                     ; LSB
.ad07	95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad09	20 30 89	jsr $8930	                jsr xt_count            ; ( addr u addr-o u-o )
.ad0c	74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad0e	b5 00		lda $00,x	                lda 0,x
.ad10	29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad12	95 00		sta $00,x	                sta 0,x
.ad14	20 b5 a4	jsr $a4b5	                jsr xt_type             ; ( addr u )
.ad17	a5 36		lda $36		                lda scratch
.ad19	c9 20		cmp #$20	                cmp #$20
.ad1b	d0 59		bne $ad76	                bne _not_jsr
.ad1d	ca		dex		                dex
.ad1e	ca		dex		                dex
.ad1f	a9 05		lda #$05	                lda #5
.ad21	95 00		sta $00,x	                sta 0,x
.ad23	74 01		stz $01,x	                stz 1,x
.ad25	20 d6 a0	jsr $a0d6	                jsr xt_spaces
.ad28	a9 79		lda #$79	                lda #<literal_runtime
.ad2a	c5 37		cmp $37		                cmp scratch+1
.ad2c	d0 0c		bne $ad3a	                bne _not_literal
.ad2e	a9 93		lda #$93	                lda #>literal_runtime
.ad30	c5 38		cmp $38		                cmp scratch+2
.ad32	d0 06		bne $ad3a	                bne _not_literal
.ad34	20 2c ae	jsr $ae2c	                jsr disasm_literal
.ad37	4c a3 ad	jmp $ada3	                jmp _printing_done
.ad3a					_not_literal:
.ad3a	a9 5b		lda #$5b	                lda #<sliteral_runtime
.ad3c	c5 37		cmp $37		                cmp scratch+1
.ad3e	d0 0c		bne $ad4c	                bne _not_sliteral
.ad40	a9 a0		lda #$a0	                lda #>sliteral_runtime
.ad42	c5 38		cmp $38		                cmp scratch+2
.ad44	d0 06		bne $ad4c	                bne _not_sliteral
.ad46	20 e9 ad	jsr $ade9	                jsr disasm_sliteral
.ad49	4c a3 ad	jmp $ada3	                jmp _printing_done
.ad4c					_not_sliteral:
.ad4c	a9 f5		lda #$f5	                lda #<zero_branch_runtime
.ad4e	c5 37		cmp $37		                cmp scratch+1
.ad50	d0 0c		bne $ad5e	                bne _not_0branch
.ad52	a9 91		lda #$91	                lda #>zero_branch_runtime
.ad54	c5 38		cmp $38		                cmp scratch+2
.ad56	d0 06		bne $ad5e	                bne _not_0branch
.ad58	20 20 ae	jsr $ae20	                jsr disasm_0branch
.ad5b	4c a3 ad	jmp $ada3	                jmp _printing_done
.ad5e					_not_0branch
.ad5e	a9 bc		lda #$bc	                lda #<branch_runtime
.ad60	c5 37		cmp $37		                cmp scratch+1
.ad62	d0 0c		bne $ad70	                bne _not_branch
.ad64	a9 8d		lda #$8d	                lda #>branch_runtime
.ad66	c5 38		cmp $38		                cmp scratch+2
.ad68	d0 06		bne $ad70	                bne _not_branch
.ad6a	20 25 ae	jsr $ae25	                jsr disasm_branch
.ad6d	4c a3 ad	jmp $ada3	                jmp _printing_done
.ad70					_not_branch
.ad70	20 4a ae	jsr $ae4a	                jsr disasm_jsr
.ad73	4c a3 ad	jmp $ada3	                jmp _printing_done
.ad76					_not_jsr:
.ad76	c9 4c		cmp #$4c	                cmp #$4C
.ad78	d0 29		bne $ada3	                bne _printing_done
.ad7a	a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.ad7c	85 39		sta $39		                sta scratch+3
.ad7e	a5 38		lda $38		                lda scratch+2
.ad80	85 3a		sta $3a		                sta scratch+4
.ad82	b2 39		lda ($39)	                lda (scratch+3)
.ad84	c9 20		cmp #$20	                cmp #$20 ; check for JSR
.ad86	d0 1b		bne $ada3	                bne _printing_done
.ad88	e6 39		inc $39		                inc scratch+3
.ad8a	d0 02		bne $ad8e	                bne +
.ad8c	e6 3a		inc $3a		                inc scratch+4
.ad8e					+
.ad8e	b2 39		lda ($39)	                lda (scratch+3)
.ad90	c9 5b		cmp #$5b	                cmp #<sliteral_runtime
.ad92	d0 0f		bne $ada3	                bne _printing_done
.ad94	e6 39		inc $39		                inc scratch+3
.ad96	d0 02		bne $ad9a	                bne +
.ad98	e6 3a		inc $3a		                inc scratch+4
.ad9a					+
.ad9a	b2 39		lda ($39)	                lda (scratch+3)
.ad9c	c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.ad9e	d0 03		bne $ada3	                bne _printing_done
.ada0	20 bf ad	jsr $adbf	                jsr disasm_sliteral_jump
.ada3					_printing_done:
.ada3	20 44 89	jsr $8944	                jsr xt_cr
.ada6	f6 02		inc $02,x	                inc 2,x
.ada8	d0 02		bne $adac	                bne +
.adaa	f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.adac					+
.adac	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; ( addr+1 u-1 )
.adaf	b5 00		lda $00,x	                lda 0,x                 ; All done?
.adb1	15 01		ora $01,x	                ora 1,x
.adb3	f0 07		beq $adbc	                beq _done
.adb5	b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.adb7	30 03		bmi $adbc	                bmi _done
.adb9	4c 8c ac	jmp $ac8c	                jmp _byte_loop          ; out of range for BRA
.adbc					_done:
.adbc	4c 62 a3	jmp $a362	                jmp xt_two_drop         ; JSR/RTS
.adbf					disasm_sliteral_jump:
.adbf	20 60 a1	jsr $a160	                jsr xt_swap
.adc2	ca		dex		                dex
.adc3	ca		dex		                dex
.adc4	a5 37		lda $37		                lda scratch+1
.adc6	95 00		sta $00,x	                sta 0,x
.adc8	a5 38		lda $38		                lda scratch+2
.adca	95 01		sta $01,x	                sta 1,x
.adcc	20 60 a1	jsr $a160	                jsr xt_swap
.adcf	20 31 95	jsr $9531	                jsr xt_minus
.add2	20 f2 97	jsr $97f2	                jsr xt_one_minus
.add5	20 31 95	jsr $9531	                jsr xt_minus
.add8	ca		dex		                dex
.add9	ca		dex		                dex
.adda	a5 37		lda $37		                lda scratch+1
.addc	95 00		sta $00,x	                sta 0,x
.adde	a5 38		lda $38		                lda scratch+2
.ade0	95 01		sta $01,x	                sta 1,x
.ade2	20 f2 97	jsr $97f2	                jsr xt_one_minus
.ade5	20 60 a1	jsr $a160	                jsr xt_swap ; ( new_addr new_n )
.ade8	60		rts		                rts
.ade9					disasm_sliteral:
.ade9	a9 53		lda #$53	                lda #'S'
.adeb	20 d7 8d	jsr $8dd7	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.adee	a9 0d		lda #$0d	                lda #str_disasm_lit     ; "LITERAL "
.adf0	20 32 d8	jsr $d832	                jsr print_string_no_lf
.adf3	20 60 a1	jsr $a160	                jsr xt_swap             ; switch to (u addr)
.adf6	20 fe 97	jsr $97fe	                jsr xt_one_plus
.adf9	20 90 8d	jsr $8d90	                jsr xt_dup
.adfc	20 61 8f	jsr $8f61	                jsr xt_fetch
.adff	20 e0 a4	jsr $a4e0	                jsr xt_u_dot            ; Print the address of the string
.ae02	20 59 a3	jsr $a359	                jsr xt_two
.ae05	20 c4 99	jsr $99c4	                jsr xt_plus
.ae08	20 90 8d	jsr $8d90	                jsr xt_dup
.ae0b	20 43 9a	jsr $9a43	                jsr xt_question         ; Print the length of the string
.ae0e	20 fe 97	jsr $97fe	                jsr xt_one_plus
.ae11	20 60 a1	jsr $a160	                jsr xt_swap            ; ( addr+4 u )
.ae14	ca		dex		                dex
.ae15	ca		dex		                dex
.ae16	a9 04		lda #$04	                lda #4
.ae18	95 00		sta $00,x	                sta 0,x
.ae1a	74 01		stz $01,x	                stz 1,x
.ae1c	20 31 95	jsr $9531	                jsr xt_minus            ; ( addr+4 u-4 )
.ae1f	60		rts		                rts
.ae20					disasm_0branch:
.ae20	a9 30		lda #$30	                lda #'0'
.ae22	20 d7 8d	jsr $8dd7	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ae25					disasm_branch:
.ae25	a9 0f		lda #$0f	                lda #str_disasm_bra
.ae27	20 32 d8	jsr $d832	                jsr print_string_no_lf ; "BRANCH "
.ae2a	80 05		bra $ae31	                bra disasm_print_literal
.ae2c					disasm_literal:
.ae2c	a9 0d		lda #$0d	                lda #str_disasm_lit
.ae2e	20 32 d8	jsr $d832	                jsr print_string_no_lf ; "LITERAL "
.ae31					disasm_print_literal:
.ae31	20 60 a1	jsr $a160	                jsr xt_swap ; switch to (u addr)
.ae34	20 fe 97	jsr $97fe	                jsr xt_one_plus
.ae37	20 90 8d	jsr $8d90	                jsr xt_dup
.ae3a	20 43 9a	jsr $9a43	                jsr xt_question ; Print the value at the adress
.ae3d	20 fe 97	jsr $97fe	                jsr xt_one_plus
.ae40	20 60 a1	jsr $a160	                jsr xt_swap ; (addr+2 u)
.ae43	20 f2 97	jsr $97f2	                jsr xt_one_minus
.ae46	20 f2 97	jsr $97f2	                jsr xt_one_minus ; (addr+2 u-2)
.ae49	60		rts		                rts
.ae4a					disasm_jsr:
.ae4a	ca		dex		                dex
.ae4b	ca		dex		                dex
.ae4c	a5 37		lda $37		                lda scratch+1
.ae4e	95 00		sta $00,x	                sta 0,x
.ae50	a5 38		lda $38		                lda scratch+2
.ae52	95 01		sta $01,x	                sta 1,x
.ae54	20 59 92	jsr $9259	                jsr xt_int_to_name
.ae57	b5 00		lda $00,x	                lda 0,x
.ae59	15 01		ora $01,x	                ora 1,x
.ae5b	f0 07		beq $ae64	                beq _disasm_no_nt
.ae5d	20 df 95	jsr $95df	                jsr xt_name_to_string
.ae60	20 b5 a4	jsr $a4b5	                jsr xt_type
.ae63	60		rts		                rts
.ae64					_disasm_no_nt:
.ae64	20 0f 8d	jsr $8d0f	                jsr xt_drop ; the 0 indicating no name token
.ae67	ca		dex		                dex
.ae68	ca		dex		                dex
.ae69	a5 37		lda $37		                lda scratch+1
.ae6b	95 00		sta $00,x	                sta 0,x
.ae6d	a5 38		lda $38		                lda scratch+2
.ae6f	95 01		sta $01,x	                sta 1,x
.ae71	ca		dex		                dex
.ae72	ca		dex		                dex
.ae73	a9 f6		lda #$f6	                lda #<underflow_1
.ae75	95 00		sta $00,x	                sta 0,x
.ae77	a9 d7		lda #$d7	                lda #>underflow_1
.ae79	95 01		sta $01,x	                sta 1,x
.ae7b	20 1d d7	jsr $d71d	                jsr compare_16bit
.ae7e	f0 02		beq $ae82	                beq _disasm_jsr_uflow_check_upper
.ae80	b0 14		bcs $ae96	                bcs _disasm_jsr_unknown
.ae82					_disasm_jsr_uflow_check_upper:
.ae82	a9 05		lda #$05	                lda #<underflow_4
.ae84	95 00		sta $00,x	                sta 0,x
.ae86	a9 d8		lda #$d8	                lda #>underflow_4
.ae88	95 01		sta $01,x	                sta 1,x
.ae8a	20 1d d7	jsr $d71d	                jsr compare_16bit
.ae8d	f0 02		beq $ae91	                beq _disasm_jsr_soc
.ae8f	90 05		bcc $ae96	                bcc _disasm_jsr_unknown
.ae91					_disasm_jsr_soc:
.ae91	a9 0e		lda #$0e	                lda #str_disasm_sdc
.ae93	20 32 d8	jsr $d832	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.ae96					_disasm_jsr_unknown:
.ae96	20 62 a3	jsr $a362	                jsr xt_two_drop
.ae99	60		rts		                rts
.ae9a					oc_index_table:
>ae9a	9a b0 9e b0 32 b5 32 b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>aea2	a6 b0 ac b0 b2 b0 32 b5
>aeaa	b8 b0 bc b0 c2 b0 32 b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>aeb2	c8 b0 cc b0 d0 b0 d4 b0
>aeba	d9 b0 dd b0 e5 b0 32 b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>aec2	ec b0 f2 b0 f9 b0 00 b1
>aeca	07 b1 0b b1 11 b1 32 b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>aed2	17 b1 1b b1 32 b5 21 b1
>aeda	27 b1 2b b1 32 b5 32 b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>aee2	33 b1 39 b1 3f b1 45 b1
>aeea	4c b1 50 b1 56 b1 32 b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>aef2	5c b1 60 b1 65 b1 69 b1
>aefa	6e b1 72 b1 7a b1 32 b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af02	81 b1 89 b1 90 b1 97 b1
>af0a	9e b1 a2 b1 a8 b1 32 b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af12	ae b1 b4 b1 ba b1 d4 b0
>af1a	c5 b1 c9 b1 32 b5 32 b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>af22	32 b5 d1 b1 d7 b1 dd b1
>af2a	e4 b1 e8 b1 ee b1 32 b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>af32	f4 b1 f8 b1 fc b1 00 b2
>af3a	05 b2 09 b2 11 b2 32 b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>af42	32 b5 18 b2 1f b2 26 b2
>af4a	2d b2 31 b2 37 b2 32 b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>af52	32 b5 32 b5 41 b2 47 b2
>af5a	4c b2 50 b2 32 b5 32 b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>af62	58 b2 5e b2 64 b2 6a b2
>af6a	71 b2 75 b2 7b b2 32 b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>af72	81 b2 87 b2 8b b2 8f b2
>af7a	94 b2 98 b2 a0 b2 32 b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>af82	a7 b2 ae b2 b5 b2 bc b2
>af8a	c3 b2 c7 b2 cd b2 32 b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>af92	d1 b2 d8 b2 de b2 e4 b2
>af9a	e9 b2 ed b2 32 b5 32 b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>afa2	f5 b2 fb b2 01 b3 32 b5
>afaa	07 b3 0b b3 11 b3 32 b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>afb2	15 b3 19 b3 1d b3 21 b3
>afba	26 b3 2a b3 32 b3 32 b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>afc2	39 b3 40 b3 47 b3 4e b3
>afca	55 b3 59 b3 5f b3 32 b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>afd2	63 b3 67 b3 6d b3 73 b3
>afda	78 b3 7e b3 86 b3 32 b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>afe2	8c b3 92 b3 98 b3 9e b3
>afea	a5 b3 a9 b3 af b3 32 b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>aff2	b3 b3 b7 b3 bb b3 bf b3
>affa	c4 b3 c8 b3 d0 b3 32 b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b002	d7 b3 de b3 e5 b3 ec b3
>b00a	f3 b3 f7 b3 fd b3 32 b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b012	01 b4 07 b4 0d b4 13 b4
>b01a	18 b4 1e b4 32 b5 32 b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b022	26 b4 2c b4 32 b4 38 b4
>b02a	3f b4 43 b4 49 b4 32 b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b032	4d b4 51 b4 55 b4 59 b4
>b03a	5e b4 62 b4 6a b4 32 b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b042	32 b5 71 b4 78 b4 7f b4
>b04a	86 b4 8a b4 90 b4 32 b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b052	32 b5 94 b4 9a b4 a0 b4
>b05a	a5 b4 ab b4 32 b5 32 b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b062	b3 b4 b9 b4 bf b4 c5 b4
>b06a	cc b4 d0 b4 d6 b4 32 b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b072	da b4 de b4 e2 b4 e6 b4
>b07a	eb b4 ef b4 f7 b4 32 b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b082	32 b5 fe b4 05 b5 0c b5
>b08a	13 b5 17 b5 1d b5 32 b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b092	32 b5 21 b5 27 b5 2d b5
.b09a					oc_table:
>b09a	83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b09e	87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b0a6	85 74 73 62 2e 7a		        oc04:   .text 2*64+5, "tsb.z"
>b0ac	85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b0b2	85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b0b8	43 70 68 70				oc08:	.text 1*64+3, "php"
>b0bc	85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b0c2	45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b0c8	c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b0cc	c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b0d0	c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b0d4	c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b0d9	83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b0dd	87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b0e5	86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b0ec	85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b0f2	86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b0f9	86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b100	86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b107	43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b10b	c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b111	45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b117	c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b11b	c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b121	c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b127	c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b12b	87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b133	85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b139	85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b13f	85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b145	86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b14c	43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b150	85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b156	45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b15c	c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b160	c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b165	c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b169	c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b16e	83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b172	87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b17a	86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b181	87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b189	86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b190	86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b197	86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b19e	43 73 65 63				oc38:	.text 1*64+3, "sec"
>b1a2	c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b1a8	45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b1ae	c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b1b4	c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b1ba	c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b1c0	c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b1c5	43 72 74 69				oc40:	.text 1*64+3, "rti"
>b1c9	87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b1d1	85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b1d7	85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b1dd	86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b1e4	43 70 68 61				oc48:	.text 1*64+3, "pha"
>b1e8	85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b1ee	45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b1f4	c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b1f8	c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b1fc	c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b200	c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b205	83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b209	87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b211	86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b218	86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b21f	86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b226	86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b22d	43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b231	c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b237	43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b23b	c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b241	c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b247	c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b24c	43 72 74 73				oc60:	.text 1*64+3, "rts"
>b250	87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b258	85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b25e	85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b264	85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b26a	86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b271	43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b275	85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b27b	45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b281	c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b287	c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b28b	c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b28f	c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b294	83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b298	87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b2a0	86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b2a7	86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b2ae	86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b2b5	86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b2bc	86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b2c3	43 73 65 69				oc78:	.text 1*64+3, "sei"
>b2c7	c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b2cd	43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b2d1	c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b2d8	c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b2de	c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b2e4	c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b2e9	83 62 72 61				oc80:	.text 2*64+3, "bra"
>b2ed	87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b2f5	85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b2fb	85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b301	85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b307	43 64 65 79				oc88:	.text 1*64+3, "dey"
>b30b	85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b311	43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b315	c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b319	c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b31d	c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b321	c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b326	83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b32a	87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b332	86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b339	86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b340	86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b347	86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b34e	86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b355	43 74 79 61				oc98:	.text 1*64+3, "tya"
>b359	c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b35f	43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b363	c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b367	c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b36d	c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b373	c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b378	85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b37e	87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b386	85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b38c	85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b392	85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b398	85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b39e	86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b3a5	43 74 61 79				oca8:	.text 1*64+3, "tay"
>b3a9	85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b3af	43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b3b3	c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b3b7	c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b3bb	c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b3bf	c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b3c4	83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b3c8	87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b3d0	86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b3d7	86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b3de	86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b3e5	86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b3ec	86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b3f3	43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b3f7	c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b3fd	43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b401	c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b407	c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b40d	c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b413	c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b418	85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b41e	87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b426	85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b42c	85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b432	85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b438	86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b43f	43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b443	85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b449	43 64 65 78				occa:	.text 1*64+3, "dex"
>b44d	c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b451	c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b455	c3 64 65 63				occe:	.text 3*64+3, "dec"
>b459	c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b45e	83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b462	87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b46a	86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b471	86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b478	86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b47f	86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b486	43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b48a	c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b490	43 70 68 78				ocda:	.text 1*64+3, "phx"
>b494	c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b49a	c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b4a0	c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b4a5	85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b4ab	87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b4b3	85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b4b9	85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b4bf	85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b4c5	86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b4cc	43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b4d0	85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b4d6	43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b4da	c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b4de	c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b4e2	c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b4e6	c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b4eb	83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b4ef	87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b4f7	86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b4fe	86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b505	86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b50c	86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b513	43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b517	c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b51d	43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b521	c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b527	c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b52d	c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b532	01 3f					oc__:	.text 1, "?"
.b534					disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=46					ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=48					ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=50					ed_flags = editor3  ; Flags used by ed, where
.b534					ed6502:
.b534	a5 18		lda $18		                lda base
.b536	85 33		sta $33		                sta editor3+1
.b538	a9 0a		lda #$0a	                lda #10
.b53a	85 18		sta $18		                sta base
.b53c	64 2e		stz $2e		                stz ed_head
.b53e	64 2f		stz $2f		                stz ed_head+1
.b540	64 30		stz $30		                stz ed_cur
.b542	64 31		stz $31		                stz ed_cur+1
.b544	64 32		stz $32		                stz ed_flags
.b546	20 5a a7	jsr $a75a	                jsr xt_zero
.b549	20 5a a7	jsr $a75a	                jsr xt_zero             ; ( addr-t u-t )
.b54c	20 44 89	jsr $8944	                jsr xt_cr
.b54f					ed_input_loop:
.b54f	a9 81		lda #$81	                lda #%10000001
.b551	14 32		trb $32		                trb ed_flags
.b553	20 2e ba	jsr $ba2e	                jsr ed_get_input
.b556	a5 0a		lda $0a		                lda ciblen
.b558	d0 1f		bne $b579	                bne _command_mode
.b55a	ca		dex		                dex
.b55b	ca		dex		                dex                     ; ( addr-t u-t ? )
.b55c	a5 30		lda $30		                lda ed_cur
.b55e	95 00		sta $00,x	                sta 0,x
.b560	a5 31		lda $31		                lda ed_cur+1
.b562	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b564	a9 80		lda #$80	                lda #%10000000
.b566	04 32		tsb $32		                tsb ed_flags
.b568	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b56b	20 4a ba	jsr $ba4a	                jsr ed_is_valid_line
.b56e	b0 03		bcs $b573	                bcs +
.b570	4c 1e ba	jmp $ba1e	                jmp ed_error_1drop
.b573					+
.b573	20 5a a7	jsr $a75a	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b576	4c 44 b6	jmp $b644	                jmp _line_number_only_from_external
.b579					_command_mode:
.b579	20 5a a7	jsr $a75a	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b57c	20 5a a7	jsr $a75a	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b57f					_prefix_dot:
.b57f	b2 08		lda ($08)	                lda (cib)
.b581	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b583	d0 3a		bne $b5bf	                bne _prefix_dollar
.b585	20 3f ba	jsr $ba3f	                jsr ed_have_text
.b588	a5 30		lda $30		                lda ed_cur
.b58a	95 02		sta $02,x	                sta 2,x
.b58c	a5 31		lda $31		                lda ed_cur+1
.b58e	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b590	a9 80		lda #$80	                lda #%10000000
.b592	04 32		tsb $32		                tsb ed_flags
.b594	a5 0a		lda $0a		                lda ciblen
.b596	3a		dec a		                dea                     ; sets Z if A was 1
.b597	d0 03		bne $b59c	                bne +
.b599	4c 44 b6	jmp $b644	                jmp _line_number_only_from_external
.b59c					+
.b59c	ca		dex		                dex
.b59d	ca		dex		                dex
.b59e	ca		dex		                dex
.b59f	ca		dex		                dex
.b5a0	a5 08		lda $08		                lda cib
.b5a2	95 02		sta $02,x	                sta 2,x
.b5a4	a5 09		lda $09		                lda cib+1
.b5a6	95 03		sta $03,x	                sta 3,x
.b5a8	a5 0a		lda $0a		                lda ciblen
.b5aa	95 00		sta $00,x	                sta 0,x
.b5ac	a5 0b		lda $0b		                lda ciblen+1
.b5ae	95 01		sta $01,x	                sta 1,x
.b5b0	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b5b3	20 60 a1	jsr $a160	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b5b6	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b5b9	20 60 a1	jsr $a160	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b5bc	4c 9c b6	jmp $b69c	                jmp _check_for_para2
.b5bf					_prefix_dollar:
.b5bf	b2 08		lda ($08)	                lda (cib)
.b5c1	c9 24		cmp #$24	                cmp #'$'
.b5c3	d0 1c		bne $b5e1	                bne _prefix_percent
.b5c5	20 3f ba	jsr $ba3f	                jsr ed_have_text
.b5c8	e8		inx		                inx
.b5c9	e8		inx		                inx                     ; ( addr-t u-t 0 )
.b5ca	20 6c ba	jsr $ba6c	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b5cd	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b5d0	a9 80		lda #$80	                lda #%10000000
.b5d2	04 32		tsb $32		                tsb ed_flags
.b5d4	a5 0a		lda $0a		                lda ciblen
.b5d6	3a		dec a		                dea                     ; sets Z if A was 1
.b5d7	d0 03		bne $b5dc	                bne +
.b5d9	4c 44 b6	jmp $b644	                jmp _line_number_only_from_external
.b5dc					+
.b5dc	a0 01		ldy #$01	                ldy #01
.b5de	4c 18 b7	jmp $b718	                jmp _check_command
.b5e1					_prefix_percent:
.b5e1	b2 08		lda ($08)	                lda (cib)
.b5e3	c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b5e5	f0 04		beq $b5eb	                beq _whole_text
.b5e7	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b5e9	d0 17		bne $b602	                bne _prefix_semicolon
.b5eb					_whole_text:
.b5eb	20 3f ba	jsr $ba3f	                jsr ed_have_text
.b5ee	a9 01		lda #$01	                lda #01
.b5f0	95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b5f2	74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b5f4					_semicolon_entry:
.b5f4	e8		inx		                inx
.b5f5	e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b5f6	20 6c ba	jsr $ba6c	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b5f9	a9 80		lda #$80	                lda #%10000000
.b5fb	04 32		tsb $32		                tsb ed_flags
.b5fd	a0 01		ldy #$01	                ldy #01
.b5ff	4c 18 b7	jmp $b718	                jmp _check_command
.b602					_prefix_semicolon:
.b602	b2 08		lda ($08)	                lda (cib)
.b604	c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b606	d0 0d		bne $b615	                bne _prefix_number
.b608	20 3f ba	jsr $ba3f	                jsr ed_have_text
.b60b	a5 30		lda $30		                lda ed_cur
.b60d	95 02		sta $02,x	                sta 2,x
.b60f	a5 31		lda $31		                lda ed_cur+1
.b611	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b613	80 df		bra $b5f4	                bra _semicolon_entry
.b615					_prefix_number:
.b615	20 5a a7	jsr $a75a	                jsr xt_zero
.b618	20 5a a7	jsr $a75a	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b61b	ca		dex		                dex
.b61c	ca		dex		                dex
.b61d	ca		dex		                dex
.b61e	ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b61f	a5 08		lda $08		                lda cib
.b621	95 02		sta $02,x	                sta 2,x
.b623	a5 09		lda $09		                lda cib+1
.b625	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b627	a5 0a		lda $0a		                lda ciblen
.b629	95 00		sta $00,x	                sta 0,x
.b62b	a5 0b		lda $0b		                lda ciblen+1
.b62d	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b62f	20 6f a2	jsr $a26f	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b632	b5 00		lda $00,x	                lda 0,x
.b634	15 01		ora $01,x	                ora 1,x
.b636	d0 24		bne $b65c	                bne _have_unconverted_chars
.b638	e8		inx		                inx
.b639	e8		inx		                inx
.b63a	e8		inx		                inx
.b63b	e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b63c	20 61 8a	jsr $8a61	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b63f	20 4f 96	jsr $964f	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b642	e8		inx		                inx
.b643	e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b644					_line_number_only_from_external:
.b644	20 60 a1	jsr $a160	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b647	20 4a ba	jsr $ba4a	                jsr ed_is_valid_line
.b64a	b0 03		bcs $b64f	                bcs +
.b64c	4c 1c ba	jmp $ba1c	                jmp ed_error_2drop
.b64f					+
.b64f	20 60 a1	jsr $a160	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b652	20 d9 ba	jsr $bad9	                jsr ed_para1_to_cur
.b655	a9 80		lda #$80	                lda #%10000000
.b657	04 32		tsb $32		                tsb ed_flags
.b659	4c f7 b8	jmp $b8f7	                jmp ed_cmd_p_from_external
.b65c					_have_unconverted_chars:
.b65c	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b65f	ca		dex		                dex
.b660	ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b661	a5 0a		lda $0a		                lda ciblen
.b663	95 00		sta $00,x	                sta 0,x
.b665	a5 0b		lda $0b		                lda ciblen+1
.b667	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b669	20 af 8e	jsr $8eaf	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b66c	b5 00		lda $00,x	                lda 0,x
.b66e	15 01		ora $01,x	                ora 1,x
.b670	f0 0e		beq $b680	                beq _no_command_yet
.b672	8a		txa		                txa
.b673	18		clc		                clc
.b674	69 0a		adc #$0a	                adc #10
.b676	aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b677	a9 80		lda #$80	                lda #%10000000
.b679	14 32		trb $32		                trb ed_flags
.b67b	a0 00		ldy #$00	                ldy #00
.b67d	4c 18 b7	jmp $b718	                jmp _check_command
.b680					_no_command_yet:
.b680	e8		inx		                inx
.b681	e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b682	20 22 a3	jsr $a322	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b685	20 4f 96	jsr $964f	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b688	20 61 8a	jsr $8a61	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b68b	b5 00		lda $00,x	                lda 0,x                 ; LSB
.b68d	95 06		sta $06,x	                sta 6,x
.b68f	b5 01		lda $01,x	                lda 1,x                 ; MSB
.b691	95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b693	e8		inx		                inx
.b694	e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b695	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b698	a9 80		lda #$80	                lda #%10000000
.b69a	04 32		tsb $32		                tsb ed_flags
.b69c					_check_for_para2:
.b69c	a1 02		lda ($02,x)	                lda (2,x)
.b69e	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b6a0	f0 0d		beq $b6af	                beq _got_comma
.b6a2	38		sec		                sec
.b6a3	a5 0a		lda $0a		                lda ciblen
.b6a5	f5 00		sbc $00,x	                sbc 0,x
.b6a7	a8		tay		                tay
.b6a8	e8		inx		                inx
.b6a9	e8		inx		                inx
.b6aa	e8		inx		                inx
.b6ab	e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b6ac	4c 18 b7	jmp $b718	                jmp _check_command
.b6af					_got_comma:
.b6af	f6 02		inc $02,x	                inc 2,x
.b6b1	d0 02		bne $b6b5	                bne +
.b6b3	f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b6b5					+
.b6b5	b5 01		lda $01,x	                lda 1,x
.b6b7	f0 02		beq $b6bb	                beq +
.b6b9	d6 01		dec $01,x	                dec 1,x
.b6bb					+
.b6bb	d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b6bd	a1 02		lda ($02,x)	                lda (2,x)
.b6bf	c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b6c1	d0 14		bne $b6d7	                bne _para2_not_dollar
.b6c3	38		sec		                sec
.b6c4	a5 0a		lda $0a		                lda ciblen
.b6c6	f5 02		sbc $02,x	                sbc 2,x
.b6c8	a8		tay		                tay
.b6c9	c8		iny		                iny
.b6ca	5a		phy		                phy
.b6cb	8a		txa		                txa
.b6cc	18		clc		                clc
.b6cd	69 06		adc #$06	                adc #06
.b6cf	aa		tax		                tax                     ; ( addr-t u-t para1 )
.b6d0	20 6c ba	jsr $ba6c	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b6d3	7a		ply		                ply
.b6d4	4c 18 b7	jmp $b718	                jmp _check_command
.b6d7					_para2_not_dollar:
.b6d7	20 22 a3	jsr $a322	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b6da	20 5a a7	jsr $a75a	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b6dd	20 5a a7	jsr $a75a	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b6e0	20 38 9b	jsr $9b38	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b6e3	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b6e6	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b6e9	20 22 a3	jsr $a322	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b6ec	20 6f a2	jsr $a26f	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b6ef	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b6f2	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b6f5	20 af 8e	jsr $8eaf	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b6f8	b5 00		lda $00,x	                lda 0,x
.b6fa	15 01		ora $01,x	                ora 1,x
.b6fc	f0 08		beq $b706	                beq _second_number
.b6fe	8a		txa		                txa
.b6ff	18		clc		                clc
.b700	69 0c		adc #$0c	                adc #12
.b702	aa		tax		                tax                     ; back to ( addr-t u-t )
.b703	4c 20 ba	jmp $ba20	                jmp ed_error
.b706					_second_number:
.b706	e8		inx		                inx
.b707	e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b708	38		sec		                sec
.b709	a5 0a		lda $0a		                lda ciblen
.b70b	f5 00		sbc $00,x	                sbc 0,x
.b70d	48		pha		                pha
.b70e	20 62 a3	jsr $a362	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b711	20 61 8a	jsr $8a61	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b714	20 23 96	jsr $9623	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b717	7a		ply		                ply
.b718					_check_command:
.b718	24 32		bit $32		                bit ed_flags
.b71a	30 08		bmi $b724	                bmi _check_command_have_arg
.b71c	a5 30		lda $30		                lda ed_cur
.b71e	95 02		sta $02,x	                sta 2,x
.b720	a5 31		lda $31		                lda ed_cur+1
.b722	95 03		sta $03,x	                sta 3,x
.b724					_check_command_have_arg:
.b724	b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b726	85 24		sta $24		                sta tmp1
.b728	da		phx		                phx
.b729	a2 00		ldx #$00	                ldx #00
.b72b					_cmd_loop:
.b72b	bd 04 bb	lda $bb04,x	                lda ed_cmd_list,x
.b72e	f0 07		beq $b737	                beq _illegal_command    ; zero marks end of list
.b730	c5 24		cmp $24		                cmp tmp1
.b732	f0 07		beq $b73b	                beq _found_cmd
.b734	e8		inx		                inx
.b735	80 f4		bra $b72b	                bra _cmd_loop
.b737					_illegal_command:
.b737	fa		plx		                plx
.b738	4c 1c ba	jmp $ba1c	                jmp ed_error_2drop
.b73b					_found_cmd:
.b73b	8a		txa		                txa
.b73c	0a		asl a		                asl
.b73d	aa		tax		                tax                     ; X * 2 for table
.b73e	7c 0f bb	jmp ($bb0f,x)	                jmp (ed_cmd_table,x)
.b741					ed_next_command:
.b741	e8		inx		                inx
.b742	e8		inx		                inx
.b743	e8		inx		                inx
.b744	e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b745					_next_command_empty:
.b745	4c 4f b5	jmp $b54f	                jmp ed_input_loop
.b748					ed_all_done:
.b748	64 0a		stz $0a		                stz ciblen
.b74a	64 0b		stz $0b		                stz ciblen+1
.b74c	20 62 a3	jsr $a362	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b74f	a5 33		lda $33		                lda editor3+1
.b751	85 18		sta $18		                sta base
.b753	60		rts		                rts
.b754					ed_cmd_a:
.b754	fa		plx		                plx
.b755	e8		inx		                inx
.b756	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b757					ed_entry_cmd_i:
.b757					ed_cmd_a_have_para:
.b757	20 a2 ba	jsr $baa2	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b75a	20 44 89	jsr $8944	                jsr xt_cr
.b75d					_next_string_loop:
.b75d	20 2e ba	jsr $ba2e	                jsr ed_get_input
.b760	b2 08		lda ($08)	                lda (cib)
.b762	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b764	d0 16		bne $b77c	                bne _add_line
.b766	a4 0a		ldy $0a		                ldy ciblen
.b768	c0 01		cpy #$01	                cpy #01
.b76a	d0 10		bne $b77c	                bne _add_line
.b76c	a4 0b		ldy $0b		                ldy ciblen+1
.b76e	d0 0c		bne $b77c	                bne _add_line
.b770	e8		inx		                inx
.b771	e8		inx		                inx
.b772	a9 40		lda #$40	                lda #%01000000
.b774	04 32		tsb $32		                tsb ed_flags
.b776	20 44 89	jsr $8944	                jsr xt_cr
.b779	4c 4f b5	jmp $b54f	                jmp ed_input_loop
.b77c					_add_line:
.b77c	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b77f	20 53 91	jsr $9153	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b782	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b785	20 61 8f	jsr $8f61	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b788	20 4f 87	jsr $874f	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b78b	20 3f a3	jsr $a33f	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b78e	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b791	20 3f a1	jsr $a13f	                jsr xt_store            ; ! ( addr-t u-t here )
.b794	20 53 91	jsr $9153	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b797	a5 00		lda $00		                lda cp
.b799	18		clc		                clc
.b79a	69 04		adc #$04	                adc #04
.b79c	85 00		sta $00		                sta cp
.b79e	90 02		bcc $b7a2	                bcc +
.b7a0	e6 01		inc $01		                inc cp+1
.b7a2					+
.b7a2	e6 30		inc $30		                inc ed_cur
.b7a4	d0 02		bne $b7a8	                bne +
.b7a6	e6 31		inc $31		                inc ed_cur+1
.b7a8					+
.b7a8	20 53 91	jsr $9153	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b7ab	20 90 8d	jsr $8d90	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b7ae	ca		dex		                dex
.b7af	ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b7b0	a5 08		lda $08		                lda cib
.b7b2	95 00		sta $00,x	                sta 0,x
.b7b4	a5 09		lda $09		                lda cib+1
.b7b6	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b7b8	20 60 a1	jsr $a160	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b7bb	ca		dex		                dex
.b7bc	ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b7bd	a5 0a		lda $0a		                lda ciblen
.b7bf	95 00		sta $00,x	                sta 0,x
.b7c1	a5 0b		lda $0b		                lda ciblen+1
.b7c3	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b7c5	20 a3 95	jsr $95a3	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b7c8	18		clc		                clc
.b7c9	a5 00		lda $00		                lda cp
.b7cb	65 0a		adc $0a		                adc ciblen
.b7cd	85 00		sta $00		                sta cp
.b7cf	90 06		bcc $b7d7	                bcc +
.b7d1	a5 01		lda $01		                lda cp+1
.b7d3	65 0b		adc $0b		                adc ciblen+1
.b7d5	85 01		sta $01		                sta cp+1
.b7d7					+
.b7d7	20 74 98	jsr $9874	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b7da	20 3f a1	jsr $a13f	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b7dd	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+
.b7e0	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b7e3	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b7e6	a5 0a		lda $0a		                lda ciblen
.b7e8	95 02		sta $02,x	                sta 2,x
.b7ea	a5 0b		lda $0b		                lda ciblen+1
.b7ec	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b7ee	20 3f a1	jsr $a13f	                jsr xt_store            ; ! ( addr-t u-t here )
.b7f1	20 44 89	jsr $8944	                jsr xt_cr
.b7f4	4c 5d b7	jmp $b75d	                jmp _next_string_loop
.b7f7					ed_cmd_d:
.b7f7	fa		plx		                plx
.b7f8	20 3f ba	jsr $ba3f	                jsr ed_have_text
.b7fb	20 94 ba	jsr $ba94	                jsr ed_no_line_zero
.b7fe	b5 00		lda $00,x	                lda 0,x
.b800	15 01		ora $01,x	                ora 1,x
.b802	d0 08		bne $b80c	                bne +
.b804	20 74 98	jsr $9874	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b807	20 49 b8	jsr $b849	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b80a	80 33		bra $b83f	                bra _cmd_d_done
.b80c					+
.b80c	20 4a ba	jsr $ba4a	                jsr ed_is_valid_line      ; result is in C flag
.b80f	b0 03		bcs $b814	                bcs _cmd_d_loop
.b811	4c 1c ba	jmp $ba1c	                jmp ed_error_2drop
.b814					_cmd_d_loop:
.b814	20 6a a3	jsr $a36a	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b817	20 3e 91	jsr $913e	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b81a	b5 00		lda $00,x	                lda 0,x
.b81c	15 01		ora $01,x	                ora 1,x
.b81e	d0 0d		bne $b82d	                bne _cmd_d_done_with_flag
.b820	e8		inx		                inx
.b821	e8		inx		                inx                     ; Get rid of the flag from >
.b822	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b825	20 49 b8	jsr $b849	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b828	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b82b	80 e7		bra $b814	                bra _cmd_d_loop
.b82d					_cmd_d_done_with_flag:
.b82d	e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b82e	e8		inx		                inx
.b82f	b5 02		lda $02,x	                lda 2,x
.b831	d0 02		bne $b835	                bne +
.b833	d6 03		dec $03,x	                dec 3,x
.b835					+
.b835	d6 02		dec $02,x	                dec 2,x
.b837	b5 02		lda $02,x	                lda 2,x
.b839	85 30		sta $30		                sta ed_cur
.b83b	b5 03		lda $03,x	                lda 3,x
.b83d	85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b83f					_cmd_d_done:
.b83f	a9 40		lda #$40	                lda #%01000000
.b841	04 32		tsb $32		                tsb ed_flags
.b843	20 44 89	jsr $8944	                jsr xt_cr
.b846	4c 41 b7	jmp $b741	                jmp ed_next_command
.b849					_cmd_d_common:
.b849	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b84c	20 a2 ba	jsr $baa2	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b84f	20 61 8f	jsr $8f61	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b852	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b855	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b858	20 a2 ba	jsr $baa2	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b85b	20 3f a1	jsr $a13f	                jsr xt_store            ; ! ( addr-t u-t )
.b85e	60		rts		                rts
.b85f					ed_cmd_equ:
.b85f	fa		plx		                plx
.b860	a5 2e		lda $2e		                lda ed_head
.b862	05 2f		ora $2f		                ora ed_head+1
.b864	d0 08		bne $b86e	                bne _cmd_equ_have_text
.b866	ca		dex		                dex
.b867	ca		dex		                dex
.b868	74 00		stz $00,x	                stz 0,x
.b86a	74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b86c	80 21		bra $b88f	                bra _cmd_equ_done
.b86e					_cmd_equ_have_text:
.b86e	20 94 ba	jsr $ba94	                jsr ed_no_line_zero
.b871	24 32		bit $32		                bit ed_flags
.b873	30 0c		bmi $b881	                bmi _cmd_equ_have_para
.b875	ca		dex		                dex
.b876	ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b877	a5 30		lda $30		                lda ed_cur
.b879	95 00		sta $00,x	                sta 0,x
.b87b	a5 31		lda $31		                lda ed_cur+1
.b87d	95 01		sta $01,x	                sta 1,x
.b87f	80 0e		bra $b88f	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b881					_cmd_equ_have_para:
.b881	b5 00		lda $00,x	                lda 0,x
.b883	15 01		ora $01,x	                ora 1,x
.b885	d0 05		bne $b88c	                bne _cmd_equ_two_paras
.b887	20 74 98	jsr $9874	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b88a	80 03		bra $b88f	                bra _cmd_equ_done
.b88c					_cmd_equ_two_paras:
.b88c	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b88f					_cmd_equ_done:
.b88f	20 44 89	jsr $8944	                jsr xt_cr               ; number goes on new line
.b892	20 e0 a4	jsr $a4e0	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b895	20 44 89	jsr $8944	                jsr xt_cr
.b898	4c 41 b7	jmp $b741	                jmp ed_next_command
.b89b					ed_cmd_f:
.b89b	fa		plx		                plx
.b89c	24 32		bit $32		                bit ed_flags
.b89e	30 17		bmi $b8b7	                bmi _cmd_f_have_para
.b8a0	20 44 89	jsr $8944	                jsr xt_cr
.b8a3	20 22 a3	jsr $a322	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b8a6	20 38 9b	jsr $9b38	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b8a9	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b8ac	20 e0 a4	jsr $a4e0	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b8af	20 4f 96	jsr $964f	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b8b2	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b8b5	80 11		bra $b8c8	                bra _cmd_f_done
.b8b7					_cmd_f_have_para:
.b8b7	20 74 98	jsr $9874	                jsr xt_over
.b8ba	20 44 89	jsr $8944	                jsr xt_cr
.b8bd	20 e0 a4	jsr $a4e0	                jsr xt_u_dot
.b8c0	b5 02		lda $02,x	                lda 2,x
.b8c2	95 06		sta $06,x	                sta 6,x
.b8c4	b5 03		lda $03,x	                lda 3,x
.b8c6	95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b8c8					_cmd_f_done:
.b8c8	20 44 89	jsr $8944	                jsr xt_cr
.b8cb	4c 41 b7	jmp $b741	                jmp ed_next_command
.b8ce					ed_cmd_i:
.b8ce	fa		plx		                plx
.b8cf	e8		inx		                inx
.b8d0	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b8d1	24 32		bit $32		                bit ed_flags
.b8d3	30 08		bmi $b8dd	                bmi _cmd_i_have_para
.b8d5	a5 30		lda $30		                lda ed_cur
.b8d7	95 00		sta $00,x	                sta 0,x
.b8d9	a5 31		lda $31		                lda ed_cur+1
.b8db	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b8dd					_cmd_i_have_para:
.b8dd	b5 00		lda $00,x	                lda 0,x
.b8df	15 01		ora $01,x	                ora 1,x
.b8e1	f0 09		beq $b8ec	                beq _cmd_i_done
.b8e3	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b8e6	20 5a a7	jsr $a75a	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b8e9	20 f9 94	jsr $94f9	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b8ec					_cmd_i_done:
.b8ec	4c 57 b7	jmp $b757	                jmp ed_entry_cmd_i
.b8ef					ed_cmd_n:
.b8ef	fa		plx		                plx
.b8f0	a9 01		lda #$01	                lda #%00000001
.b8f2	04 32		tsb $32		                tsb ed_flags
.b8f4	80 05		bra $b8fb	                bra ed_cmd_p_entry_for_cmd_n
.b8f6					ed_cmd_p:
.b8f6	fa		plx		                plx
.b8f7					ed_cmd_p_from_external:
.b8f7	a9 01		lda #$01	                lda #%00000001
.b8f9	14 32		trb $32		                trb ed_flags
.b8fb					ed_cmd_p_entry_for_cmd_n:
.b8fb	20 3f ba	jsr $ba3f	                jsr ed_have_text
.b8fe	20 94 ba	jsr $ba94	                jsr ed_no_line_zero
.b901	20 44 89	jsr $8944	                jsr xt_cr
.b904	b5 00		lda $00,x	                lda 0,x
.b906	15 01		ora $01,x	                ora 1,x
.b908	d0 10		bne $b91a	                bne _cmd_p_loop
.b90a	b5 02		lda $02,x	                lda 2,x
.b90c	85 30		sta $30		                sta ed_cur
.b90e	b5 03		lda $03,x	                lda 3,x
.b910	85 31		sta $31		                sta ed_cur+1
.b912	20 74 98	jsr $9874	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b915	20 43 b9	jsr $b943	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b918	80 26		bra $b940	                bra _cmd_p_all_done
.b91a					_cmd_p_loop:
.b91a	20 6a a3	jsr $a36a	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b91d	20 3e 91	jsr $913e	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b920	b5 00		lda $00,x	                lda 0,x
.b922	15 01		ora $01,x	                ora 1,x
.b924	d0 10		bne $b936	                bne _cmd_p_done
.b926	e8		inx		                inx
.b927	e8		inx		                inx                     ; Get rid of the flag from >
.b928	20 74 98	jsr $9874	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b92b	20 43 b9	jsr $b943	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b92e	f6 02		inc $02,x	                inc 2,x
.b930	d0 02		bne $b934	                bne +
.b932	f6 03		inc $03,x	                inc 3,x
.b934					+
.b934	80 e4		bra $b91a	                bra _cmd_p_loop
.b936					_cmd_p_done:
.b936	e8		inx		                inx
.b937	e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b938	b5 00		lda $00,x	                lda 0,x
.b93a	85 30		sta $30		                sta ed_cur
.b93c	b5 01		lda $01,x	                lda 1,x
.b93e	85 31		sta $31		                sta ed_cur+1
.b940					_cmd_p_all_done:
.b940	4c 41 b7	jmp $b741	                jmp ed_next_command
.b943					_cmd_p_common:
.b943	a5 32		lda $32		                lda ed_flags
.b945	4a		lsr a		                lsr                     ; bit 0 now in carry
.b946	90 0b		bcc $b953	                bcc _cmd_p_common_no_num
.b948	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b94b	20 e0 a4	jsr $a4e0	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b94e	a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b950	20 d7 8d	jsr $8dd7	                jsr emit_a
.b953					_cmd_p_common_no_num:
.b953	20 a2 ba	jsr $baa2	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b956	20 e2 ba	jsr $bae2	                jsr ed_print_addr
.b959	60		rts		                rts
.b95a					ed_cmd_q:
.b95a	fa		plx		                plx
.b95b	24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b95d	50 03		bvc $b962	                bvc +
.b95f	4c 1c ba	jmp $ba1c	                jmp ed_error_2drop
.b962					+
.b962	4c 48 b7	jmp $b748	                jmp ed_all_done            ; can't fall thru because of PLX
.b965					ed_cmd_qq:
.b965	fa		plx		                plx
.b966	4c 48 b7	jmp $b748	                jmp ed_all_done
.b969					ed_cmd_w:
.b969	fa		plx		                plx
.b96a	20 3f ba	jsr $ba3f	                jsr ed_have_text
.b96d	24 32		bit $32		                bit ed_flags
.b96f	30 13		bmi $b984	                bmi _cmd_w_have_para
.b971	b5 06		lda $06,x	                lda 6,x
.b973	15 07		ora $07,x	                ora 7,x
.b975	d0 03		bne $b97a	                bne +
.b977	4c 1c ba	jmp $ba1c	                jmp ed_error_2drop
.b97a					+
.b97a	b5 06		lda $06,x	                lda 6,x
.b97c	95 02		sta $02,x	                sta 2,x
.b97e	b5 07		lda $07,x	                lda 7,x
.b980	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b982	80 08		bra $b98c	                bra _cmd_w_para_ready
.b984					_cmd_w_have_para:
.b984	b5 02		lda $02,x	                lda 2,x
.b986	95 06		sta $06,x	                sta 6,x
.b988	b5 03		lda $03,x	                lda 3,x
.b98a	95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b98c					_cmd_w_para_ready:
.b98c	a9 2e		lda #$2e	                lda #<ed_head
.b98e	95 00		sta $00,x	                sta 0,x
.b990	a9 00		lda #$00	                lda #>ed_head
.b992	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.b994	20 74 98	jsr $9874	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.b997	20 22 a3	jsr $a322	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.b99a					_cmd_w_loop:
.b99a	20 61 8f	jsr $8f61	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.b99d	b5 00		lda $00,x	                lda 0,x
.b99f	15 01		ora $01,x	                ora 1,x
.b9a1	f0 55		beq $b9f8	                beq _cmd_w_eol
.b9a3	20 6a a3	jsr $a36a	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.b9a6	20 54 a4	jsr $a454	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.b9a9	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.b9ac	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.b9af	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.b9b2	20 61 8f	jsr $8f61	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.b9b5	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.b9b8	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.b9bb	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.b9be	20 61 8f	jsr $8f61	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.b9c1	20 4f 96	jsr $964f	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.b9c4	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.b9c7	20 38 9b	jsr $9b38	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.b9ca	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.b9cd	20 22 a3	jsr $a322	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.b9d0	20 a3 95	jsr $95a3	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.b9d3	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.b9d6	20 da a3	jsr $a3da	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.b9d9	20 4f 96	jsr $964f	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.b9dc	20 c4 99	jsr $99c4	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.b9df	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.b9e2	ca		dex		                dex
.b9e3	ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.b9e4	a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.b9e6	95 00		sta $00,x	                sta 0,x
.b9e8	74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.b9ea	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.b9ed	20 3f a1	jsr $a13f	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.b9f0	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.b9f3	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.b9f6	80 a2		bra $b99a	                bra _cmd_w_loop
.b9f8					_cmd_w_eol:
.b9f8	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.b9fb	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.b9fe	20 31 95	jsr $9531	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba01	b5 00		lda $00,x	                lda 0,x
.ba03	95 04		sta $04,x	                sta 4,x
.ba05	b5 01		lda $01,x	                lda 1,x
.ba07	95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba09	20 44 89	jsr $8944	                jsr xt_cr
.ba0c	20 90 8d	jsr $8d90	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba0f	20 e0 a4	jsr $a4e0	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba12	20 44 89	jsr $8944	                jsr xt_cr
.ba15	a9 40		lda #$40	                lda #%01000000
.ba17	14 32		trb $32		                trb ed_flags
.ba19	4c 41 b7	jmp $b741	                jmp ed_next_command
.ba1c					ed_error_2drop:
.ba1c	e8		inx		                inx
.ba1d	e8		inx		                inx                     ; drop through to _error_1drop
.ba1e					ed_error_1drop:
.ba1e	e8		inx		                inx
.ba1f	e8		inx		                inx                     ; drop through to _error
.ba20					ed_error:
.ba20	20 44 89	jsr $8944	                jsr xt_cr
.ba23	a9 3f		lda #$3f	                lda #'?'
.ba25	20 d7 8d	jsr $8dd7	                jsr emit_a
.ba28	20 44 89	jsr $8944	                jsr xt_cr
.ba2b	4c 4f b5	jmp $b54f	                jmp ed_input_loop
.ba2e					ed_get_input:
.ba2e	20 d9 9a	jsr $9ad9	                jsr xt_refill           ;  ( addr-t u-t f )
.ba31	b5 00		lda $00,x	                lda 0,x
.ba33	15 01		ora $01,x	                ora 1,x
.ba35	d0 05		bne $ba3c	                bne +
.ba37	7a		ply		                ply
.ba38	7a		ply		                ply
.ba39	4c 1e ba	jmp $ba1e	                jmp ed_error_1drop
.ba3c					+
.ba3c	e8		inx		                inx
.ba3d	e8		inx		                inx
.ba3e	60		rts		                rts
.ba3f					ed_have_text:
.ba3f	a5 2e		lda $2e		                lda ed_head
.ba41	05 2f		ora $2f		                ora ed_head+1
.ba43	d0 04		bne $ba49	                bne +
.ba45	7a		ply		                ply
.ba46	7a		ply		                ply
.ba47	80 d7		bra $ba20	                bra ed_error
.ba49					+
.ba49	60		rts		                rts
.ba4a					ed_is_valid_line:
.ba4a	38		sec		                sec                             ; default is legal line number
.ba4b	b5 00		lda $00,x	                lda 0,x
.ba4d	15 01		ora $01,x	                ora 1,x
.ba4f	f0 19		beq $ba6a	                beq _is_valid_line_nope_zero    ; ( n )
.ba51	20 90 8d	jsr $8d90	                jsr xt_dup                      ; DUP ( n n )
.ba54	20 6c ba	jsr $ba6c	                jsr ed_last_line                  ; ( n n last )
.ba57	20 60 a1	jsr $a160	                jsr xt_swap                     ; SWAP ( n last n )
.ba5a	20 49 93	jsr $9349	                jsr xt_less_than                ; < ( n f )
.ba5d	b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ba5f	15 01		ora $01,x	                ora 1,x
.ba61	d0 05		bne $ba68	                bne _is_valid_line_too_small
.ba63	e8		inx		                inx
.ba64	e8		inx		                inx                     ; DROP flag ( n )
.ba65	38		sec		                sec                     ; Who knows what's happened to C by now
.ba66	80 03		bra $ba6b	                bra _is_valid_line_done ; only one exit from this routine
.ba68					_is_valid_line_too_small:
.ba68	e8		inx		                inx
.ba69	e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ba6a					_is_valid_line_nope_zero:
.ba6a	18		clc		                clc                     ; drop through to _is_valid_line_done
.ba6b					_is_valid_line_done:
.ba6b	60		rts		                rts
.ba6c					ed_last_line:
.ba6c	64 24		stz $24		                stz tmp1
.ba6e	64 25		stz $25		                stz tmp1+1
.ba70	ca		dex		                dex
.ba71	ca		dex		                dex                     ; ( ? )
.ba72	a9 2e		lda #$2e	                lda #<ed_head
.ba74	95 00		sta $00,x	                sta 0,x
.ba76	a9 00		lda #$00	                lda #>ed_head
.ba78	95 01		sta $01,x	                sta 1,x                 ; ( addr )
.ba7a					_last_line_loop:
.ba7a	20 61 8f	jsr $8f61	                jsr xt_fetch            ; ( addr | 0 )
.ba7d	b5 00		lda $00,x	                lda 0,x
.ba7f	15 01		ora $01,x	                ora 1,x
.ba81	f0 08		beq $ba8b	                beq _last_line_done
.ba83	e6 24		inc $24		                inc tmp1
.ba85	d0 02		bne $ba89	                bne +
.ba87	e6 25		inc $25		                inc tmp1+1
.ba89					+
.ba89	80 ef		bra $ba7a	                bra _last_line_loop
.ba8b					_last_line_done:
.ba8b	a5 24		lda $24		                lda tmp1
.ba8d	95 00		sta $00,x	                sta 0,x
.ba8f	a5 25		lda $25		                lda tmp1+1
.ba91	95 01		sta $01,x	                sta 1,x                 ; ( u )
.ba93	60		rts		                rts
.ba94					ed_no_line_zero:
.ba94	b5 02		lda $02,x	                lda 2,x
.ba96	15 03		ora $03,x	                ora 3,x
.ba98	d0 07		bne $baa1	                bne _no_line_zero_done
.ba9a	24 32		bit $32		                bit ed_flags
.ba9c	10 03		bpl $baa1	                bpl _no_line_zero_done
.ba9e	4c 1c ba	jmp $ba1c	                jmp ed_error_2drop
.baa1					_no_line_zero_done:
.baa1	60		rts		                rts
.baa2					ed_num_to_addr:
.baa2	ca		dex		                dex
.baa3	ca		dex		                dex                     ; ( u ? )
.baa4	a9 2e		lda #$2e	                lda #<ed_head
.baa6	95 00		sta $00,x	                sta 0,x
.baa8	a9 00		lda #$00	                lda #>ed_head
.baaa	95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.baac	b5 02		lda $02,x	                lda 2,x
.baae	15 03		ora $03,x	                ora 3,x
.bab0	d0 05		bne $bab7	                bne _num_to_addr_loop
.bab2	20 23 96	jsr $9623	                jsr xt_nip              ; ( addr-h )
.bab5	80 21		bra $bad8	                bra _num_to_addr_done
.bab7					_num_to_addr_loop:
.bab7	20 61 8f	jsr $8f61	                jsr xt_fetch            ; @ ( u addr1 )
.baba	b5 00		lda $00,x	                lda 0,x
.babc	15 01		ora $01,x	                ora 1,x
.babe	d0 05		bne $bac5	                bne +
.bac0	20 23 96	jsr $9623	                jsr xt_nip              ; NIP ( addr1 )
.bac3	80 13		bra $bad8	                bra _num_to_addr_done
.bac5					+
.bac5	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( addr1 u )
.bac8	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bacb	b5 00		lda $00,x	                lda 0,x
.bacd	15 01		ora $01,x	                ora 1,x
.bacf	f0 05		beq $bad6	                beq _num_to_addr_finished
.bad1	20 60 a1	jsr $a160	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bad4	80 e1		bra $bab7	                bra _num_to_addr_loop
.bad6					_num_to_addr_finished:
.bad6	e8		inx		                inx
.bad7	e8		inx		                inx                     ; ( addr )
.bad8					_num_to_addr_done:
.bad8	60		rts		                rts
.bad9					ed_para1_to_cur:
.bad9	b5 02		lda $02,x	                lda 2,x
.badb	85 30		sta $30		                sta ed_cur
.badd	b5 03		lda $03,x	                lda 3,x
.badf	85 31		sta $31		                sta ed_cur+1
.bae1	60		rts		                rts
.bae2					ed_print_addr:
.bae2	20 fe 97	jsr $97fe	                jsr xt_one_plus
.bae5	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( addr+2 )
.bae8	20 90 8d	jsr $8d90	                jsr xt_dup              ; ( addr+2 addr+2 )
.baeb	20 fe 97	jsr $97fe	                jsr xt_one_plus
.baee	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.baf1	20 61 8f	jsr $8f61	                jsr xt_fetch            ; ( addr+2 u-s )
.baf4	20 60 a1	jsr $a160	                jsr xt_swap             ; ( u-s addr+2 )
.baf7	20 61 8f	jsr $8f61	                jsr xt_fetch            ; ( u-s addr-s )
.bafa	20 60 a1	jsr $a160	                jsr xt_swap             ; ( addr-s u-s )
.bafd	20 b5 a4	jsr $a4b5	                jsr xt_type
.bb00	20 44 89	jsr $8944	                jsr xt_cr
.bb03	60		rts		                rts
>bb04	61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb0c	71 51 00
.bb0f					ed_cmd_table:
>bb0f	54 b7 9b b8 ce b8 f7 b7		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bb17	f6 b8 ef b8
>bb1b	5f b8 69 b9 5a b9 65 b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bb23					ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bb23					forth_words_start:
>bb23	20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb2b	61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb3b	74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bb4b	20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bb5b	20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bb6b	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bb7b	2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bb8b	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bb9b	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bbab	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bbbb	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bbcb	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bbdb	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bbeb	65 78 69 74 29 20 63 72 20
.bbf4					forth_words_end:
.bbf4					user_words_start:
>bbf4	20 20				.binary "user_words.asc"
.bbf6					user_words_end:

;******  Processing file: platform/../headers.asm

.bbf6					dictionary_start:
.bbf6					nt_drop:
>bbf6	04 10				        .byte 4, UF
>bbf8	02 bc 0f 8d 14 8d		        .word nt_dup, xt_drop, z_drop
>bbfe	64 72 6f 70			        .text "drop"
.bc02					nt_dup:
>bc02	03 10				        .byte 3, UF
>bc04	0d bc 90 8d 9d 8d		        .word nt_swap, xt_dup, z_dup
>bc0a	64 75 70			        .text "dup"
.bc0d					nt_swap:
>bc0d	04 10				        .byte 4, UF
>bc0f	19 bc 60 a1 73 a1		        .word nt_store, xt_swap, z_swap
>bc15	73 77 61 70			        .text "swap"
.bc19					nt_store:
>bc19	01 10				        .byte 1, UF
>bc1b	22 bc 3f a1 54 a1		        .word nt_fetch, xt_store, z_store
>bc21	21				        .text "!"
.bc22					nt_fetch:
>bc22	01 10				        .byte 1, UF
>bc24	2b bc 61 8f 73 8f		        .word nt_over, xt_fetch, z_fetch
>bc2a	40				        .text "@"
.bc2b					nt_over:
>bc2b	04 10				        .byte 4, UF
>bc2d	37 bc 74 98 81 98		        .word nt_to_r, xt_over, z_over
>bc33	6f 76 65 72			        .text "over"
.bc37					nt_to_r:
>bc37	02 11				        .byte 2, CO+UF ; native is special case
>bc39	41 bc 22 a3 35 a3		        .word nt_r_from, xt_to_r, z_to_r
>bc3f	3e 72				        .text ">r"
.bc41					nt_r_from:
>bc41	02 01				        .byte 2, CO    ; native is special case
>bc43	4b bc 73 9a 83 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bc49	72 3e				        .text "r>"
.bc4b					nt_r_fetch:
>bc4b	02 01				        .byte 2, CO    ; native is special case
>bc4d	55 bc 5e 9a 72 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bc53	72 40				        .text "r@"
.bc55					nt_nip:
>bc55	03 10				        .byte 3, UF
>bc57	60 bc 23 96 30 96		        .word nt_rot, xt_nip, z_nip
>bc5d	6e 69 70			        .text "nip"
.bc60					nt_rot:
>bc60	03 10				        .byte 3, UF
>bc62	6b bc 38 9b 53 9b		        .word nt_not_rote, xt_rot, z_rot
>bc68	72 6f 74			        .text "rot"
.bc6b					nt_not_rote:
>bc6b	04 10				        .byte 4, UF
>bc6d	77 bc 4f 96 6a 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bc73	2d 72 6f 74			        .text "-rot"
.bc77					nt_tuck:
>bc77	04 10				        .byte 4, UF
>bc79	83 bc 3f a3 58 a3		        .word nt_comma, xt_tuck, z_tuck
>bc7f	74 75 63 6b			        .text "tuck"
.bc83					nt_comma:
>bc83	01 10				        .byte 1, UF
>bc85	8c bc 4f 87 68 87		        .word nt_c_fetch, xt_comma, z_comma
>bc8b	2c				        .text ","
.bc8c					nt_c_fetch:
>bc8c	02 10				        .byte 2, UF
>bc8e	96 bc ec 85 f5 85		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bc94	63 40				        .text "c@"
.bc96					nt_c_store:
>bc96	02 10				        .byte 2, UF
>bc98	a0 bc f6 85 01 86		        .word nt_plus_store, xt_c_store, z_c_store
>bc9e	63 21				        .text "c!"
.bca0					nt_plus_store:
>bca0	02 10				        .byte 2, UF
>bca2	aa bc d7 99 f6 99		        .word nt_execute, xt_plus_store, z_plus_store
>bca8	2b 21				        .text "+!"
.bcaa					nt_execute:
>bcaa	07 10				        .byte 7, UF
>bcac	b9 bc 1e 8f 24 8f		        .word nt_emit, xt_execute, z_execute
>bcb2	65 78 65 63 75 74 65		        .text "execute"
.bcb9					nt_emit:
>bcb9	04 18				        .byte 4, NN+UF
>bcbb	c5 bc d0 8d da 8d		        .word nt_type, xt_emit, z_emit
>bcc1	65 6d 69 74			        .text "emit"
.bcc5					nt_type:
>bcc5	04 10				        .byte 4, UF
>bcc7	d1 bc b5 a4 df a4		        .word nt_dot, xt_type, z_type
>bccd	74 79 70 65			        .text "type"
.bcd1					nt_dot:
>bcd1	01 10				        .byte 1, UF
>bcd3	da bc 17 8c 38 8c		        .word nt_u_dot, xt_dot, z_dot
>bcd9	2e				        .text "."
.bcda					nt_u_dot:
>bcda	02 10				        .byte 2, UF
>bcdc	e4 bc e0 a4 eb a4		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bce2	75 2e				        .text "u."
.bce4					nt_u_dot_r:
>bce4	03 10				        .byte 3, UF
>bce6	ef bc ec a4 0d a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bcec	75 2e 72			        .text "u.r"
.bcef					nt_dot_r:
>bcef	02 10				        .byte 2, UF
>bcf1	f9 bc 53 8c 80 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bcf7	2e 72				        .text ".r"
.bcf9					nt_d_dot:
>bcf9	02 10				        .byte 2, UF
>bcfb	03 bd c5 8c e3 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd01	64 2e				        .text "d."
.bd03					nt_d_dot_r:
>bd03	03 10				        .byte 3, UF
>bd05	0e bd e4 8c 0e 8d		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd0b	64 2e 72			        .text "d.r"
.bd0e					nt_ud_dot:
>bd0e	03 10				        .byte 3, UF
>bd10	19 bd 3a a5 4c a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd16	75 64 2e			        .text "ud."
.bd19					nt_ud_dot_r:
>bd19	04 10				        .byte 4, UF
>bd1b	25 bd 4d a5 6b a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd21	75 64 2e 72			        .text "ud.r"
.bd25					nt_question:
>bd25	01 00				        .byte 1, 0
>bd27	2e bd 43 9a 49 9a		        .word nt_false, xt_question, z_question
>bd2d	3f				        .text "?"
.bd2e					nt_false:
>bd2e	05 00				        .byte 5, 0
>bd30	3b bd 5a 8f 60 8f		        .word nt_true, xt_false, z_false
>bd36	66 61 6c 73 65			        .text "false"
.bd3b					nt_true:
>bd3b	04 00				        .byte 4, 0
>bd3d	47 bd 36 a3 3e a3		        .word nt_space, xt_true, z_true
>bd43	74 72 75 65			        .text "true"
.bd47					nt_space:
>bd47	05 00				        .byte 5, 0
>bd49	54 bd d0 a0 d5 a0		        .word nt_zero, xt_space, z_space
>bd4f	73 70 61 63 65			        .text "space"
.bd54					nt_zero:
>bd54	01 00				        .byte 1, 0
>bd56	5d bd 5a a7 60 a7		        .word nt_one, xt_zero, z_zero
>bd5c	30				        .text "0"
.bd5d					nt_one:
>bd5d	01 00				        .byte 1, 0
>bd5f	66 bd e9 97 f1 97		        .word nt_two, xt_one, z_one
>bd65	31				        .text "1"
.bd66					nt_two:
>bd66	01 00				        .byte 1, 0
>bd68	6f bd 59 a3 61 a3		        .word nt_two_dup, xt_two, z_two
>bd6e	32				        .text "2"
.bd6f					nt_two_dup:
>bd6f	04 10				        .byte 4, UF
>bd71	7b bd 6a a3 81 a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bd77	32 64 75 70			        .text "2dup"
.bd7b					nt_question_dup:
>bd7b	04 10				        .byte 4, UF
>bd7d	87 bd 4a 9a 5d 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bd83	3f 64 75 70			        .text "?dup"
.bd87					nt_plus:
>bd87	01 10				        .byte 1, UF
>bd89	90 bd c4 99 d6 99		        .word nt_minus, xt_plus, z_plus
>bd8f	2b				        .text "+"
.bd90					nt_minus:
>bd90	01 10				        .byte 1, UF
>bd92	99 bd 31 95 43 95		        .word nt_one_minus, xt_minus, z_minus
>bd98	2d				        .text "-"
.bd99					nt_one_minus:
>bd99	02 10				        .byte 2, UF
>bd9b	a3 bd f2 97 fd 97		        .word nt_one_plus, xt_one_minus, z_one_minus
>bda1	31 2d				        .text "1-"
.bda3					nt_one_plus:
>bda3	02 10				        .byte 2, UF
>bda5	ad bd fe 97 07 98		        .word nt_two_star, xt_one_plus, z_one_plus
>bdab	31 2b				        .text "1+"
.bdad					nt_two_star:
>bdad	02 10				        .byte 2, UF
>bdaf	b7 bd 02 a4 09 a4		        .word nt_two_slash, xt_two_star, z_two_star
>bdb5	32 2a				        .text "2*"
.bdb7					nt_two_slash:
>bdb7	02 10				        .byte 2, UF
>bdb9	c1 bd f7 a3 01 a4		        .word nt_abs, xt_two_slash, z_two_slash
>bdbf	32 2f				        .text "2/"
.bdc1					nt_abs:
>bdc1	03 10				        .byte 3, UF
>bdc3	cc bd 1a 81 2e 81		        .word nt_dabs, xt_abs, z_abs
>bdc9	61 62 73			        .text "abs"
.bdcc					nt_dabs:
>bdcc	04 10				        .byte 4, UF
>bdce	d8 bd 67 8a 85 8a		        .word nt_and, xt_dabs, z_dabs
>bdd4	64 61 62 73			        .text "dabs"
.bdd8					nt_and:
>bdd8	03 10				        .byte 3, UF
>bdda	e3 bd 1f 83 30 83		        .word nt_or, xt_and, z_and
>bde0	61 6e 64			        .text "and"
.bde3					nt_or:
>bde3	02 10				        .byte 2, UF
>bde5	ed bd 14 98 25 98		        .word nt_xor, xt_or, z_or
>bdeb	6f 72				        .text "or"
.bded					nt_xor:
>bded	03 10				        .byte 3, UF
>bdef	f8 bd 48 a7 59 a7		        .word nt_rshift, xt_xor, z_xor
>bdf5	78 6f 72			        .text "xor"
.bdf8					nt_rshift:
>bdf8	06 10				        .byte 6, UF
>bdfa	06 be 54 9b 67 9b		        .word nt_lshift, xt_rshift, z_rshift
>be00	72 73 68 69 66 74		        .text "rshift"
.be06					nt_lshift:
>be06	06 10				        .byte 6, UF
>be08	14 be 5b 94 6e 94		        .word nt_pick, xt_lshift, z_lshift
>be0e	6c 73 68 69 66 74		        .text "lshift"
.be14					nt_pick:
>be14	04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be16	20 be b3 99 c3 99		        .word nt_char, xt_pick, z_pick
>be1c	70 69 63 6b			        .text "pick"
.be20					nt_char:
>be20	04 00				        .byte 4, 0
>be22	2c be 12 86 28 86		        .word nt_bracket_char, xt_char, z_char
>be28	63 68 61 72			        .text "char"
.be2c					nt_bracket_char:
>be2c	06 05				        .byte 6, CO+IM
>be2e	3a be 78 85 7e 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>be34	5b 63 68 61 72 5d		        .text "[char]"
.be3a					nt_char_plus:
>be3a	05 00				        .byte 5, 0
>be3c	47 be fe 97 07 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>be42	63 68 61 72 2b			        .text "char+"
.be47					nt_chars:
>be47	05 12				        .byte 5, AN+UF   ; deleted during compile
>be49	54 be 29 86 2c 86		        .word nt_cells, xt_chars, z_chars
>be4f	63 68 61 72 73			        .text "chars"
.be54					nt_cells:
>be54	05 00				        .byte 5, 0
>be56	61 be 02 a4 09 a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>be5c	63 65 6c 6c 73			        .text "cells"
.be61					nt_cell_plus:
>be61	05 10				        .byte 5, UF
>be63	6e be 02 86 11 86		        .word nt_here, xt_cell_plus, z_cell_plus
>be69	63 65 6c 6c 2b			        .text "cell+"
.be6e					nt_here:
>be6e	04 00				        .byte 4, 0
>be70	7a be 53 91 5d 91		        .word nt_equal, xt_here, z_here
>be76	68 65 72 65			        .text "here"
.be7a					nt_equal:
>be7a	01 10				        .byte 1, UF
>be7c	83 be af 8e ca 8e		        .word nt_not_equals, xt_equal, z_equal
>be82	3d				        .text "="
.be83					nt_not_equals:
>be83	02 10				        .byte 2, UF
>be85	8d be 31 96 4e 96		        .word nt_less_than, xt_not_equals, z_not_equals
>be8b	3c 3e				        .text "<>"
.be8d					nt_less_than:
>be8d	01 10				        .byte 1, UF
>be8f	96 be 49 93 5d 93		        .word nt_u_less_than, xt_less_than, z_less_than
>be95	3c				        .text "<"
.be96					nt_u_less_than:
>be96	02 10				        .byte 2, UF
>be98	a0 be 24 a5 39 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>be9e	75 3c				        .text "u<"
.bea0					nt_u_greater_than:
>bea0	02 10				        .byte 2, UF
>bea2	aa be 0e a5 23 a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bea8	75 3e				        .text "u>"
.beaa					nt_greater_than:
>beaa	01 10				        .byte 1, UF
>beac	b3 be 3e 91 52 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>beb2	3e				        .text ">"
.beb3					nt_zero_equal:
>beb3	02 10				        .byte 2, UF
>beb5	bd be 61 a7 74 a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bebb	30 3d				        .text "0="
.bebd					nt_zero_unequal:
>bebd	03 10				        .byte 3, UF
>bebf	c8 be 99 a7 aa a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bec5	30 3c 3e			        .text "0<>"
.bec8					nt_zero_greater:
>bec8	02 10				        .byte 2, UF
>beca	d2 be 75 a7 88 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bed0	30 3e				        .text "0>"
.bed2					nt_zero_less:
>bed2	02 10				        .byte 2, UF
>bed4	dc be 89 a7 98 a7		        .word nt_min, xt_zero_less, z_zero_less
>beda	30 3c				        .text "0<"
.bedc					nt_min:
>bedc	03 10				        .byte 3, UF
>bede	e7 be 15 95 30 95		        .word nt_max, xt_min, z_min
>bee4	6d 69 6e			        .text "min"
.bee7					nt_max:
>bee7	03 10				        .byte 3, UF
>bee9	f2 be f9 94 14 95		        .word nt_two_drop, xt_max, z_max
>beef	6d 61 78			        .text "max"
.bef2					nt_two_drop:
>bef2	05 10				        .byte 5, UF
>bef4	ff be 62 a3 69 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>befa	32 64 72 6f 70			        .text "2drop"
.beff					nt_two_swap:
>beff	05 10				        .byte 5, UF
>bf01	0c bf 30 a4 53 a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf07	32 73 77 61 70			        .text "2swap"
.bf0c					nt_two_over:
>bf0c	05 10				        .byte 5, UF
>bf0e	19 bf a4 a3 bb a3		        .word nt_two_store, xt_two_over, z_two_over
>bf14	32 6f 76 65 72			        .text "2over"
.bf19					nt_two_store:
>bf19	02 10				        .byte 2, UF
>bf1b	23 bf 0a a4 2f a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bf21	32 21				        .text "2!"
.bf23					nt_two_fetch:
>bf23	02 10				        .byte 2, UF
>bf25	2d bf 82 a3 a3 a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bf2b	32 40				        .text "2@"
.bf2d					nt_two_variable:
>bf2d	09 00				        .byte 9, 0
>bf2f	3e bf a6 a4 b4 a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>bf35	32 76 61 72 69 61 62 6c		        .text "2variable"
>bf3d	65
.bf3e					nt_two_constant:
>bf3e	09 10				        .byte 9, UF
>bf40	4f bf 74 a4 98 a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bf46	32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bf4e	74
.bf4f					nt_two_literal:
>bf4f	08 14				        .byte 8, UF+IM
>bf51	5f bf 99 a4 a5 a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bf57	32 6c 69 74 65 72 61 6c		        .text "2literal"
.bf5f					nt_two_r_fetch:
>bf5f	03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bf61	6a bf bc a3 d9 a3		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bf67	32 72 40			        .text "2r@"
.bf6a					nt_two_r_from:
>bf6a	03 01				        .byte 3, CO             ; native is special case
>bf6c	75 bf da a3 f6 a3		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bf72	32 72 3e			        .text "2r>"
.bf75					nt_two_to_r:
>bf75	03 11				        .byte 3, CO+UF          ; native is special case
>bf77	80 bf 54 a4 73 a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>bf7d	32 3e 72			        .text "2>r"
.bf80					nt_invert:
>bf80	06 10				        .byte 6, UF
>bf82	8e bf cc 92 db 92		        .word nt_negate, xt_invert, z_invert
>bf88	69 6e 76 65 72 74		        .text "invert"
.bf8e					nt_negate:
>bf8e	06 10				        .byte 6, UF
>bf90	9c bf 04 96 14 96		        .word nt_dnegate, xt_negate, z_negate
>bf96	6e 65 67 61 74 65		        .text "negate"
.bf9c					nt_dnegate:
>bf9c	07 10				        .byte 7, UF
>bf9e	ab bf 22 8b 3c 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>bfa4	64 6e 65 67 61 74 65		        .text "dnegate"
.bfab					nt_c_comma:
>bfab	02 10				        .byte 2, UF
>bfad	b5 bf e1 85 eb 85		        .word nt_bounds, xt_c_comma, z_c_comma
>bfb3	63 2c				        .text "c,"
.bfb5					nt_bounds:
>bfb5	06 10				        .byte 6, UF
>bfb7	c3 bf 5f 85 77 85		        .word nt_spaces, xt_bounds, z_bounds
>bfbd	62 6f 75 6e 64 73		        .text "bounds"
.bfc3					nt_spaces:
>bfc3	06 10				        .byte 6, UF
>bfc5	d1 bf d6 a0 11 a1		        .word nt_bl, xt_spaces, z_spaces
>bfcb	73 70 61 63 65 73		        .text "spaces"
.bfd1					nt_bl:
>bfd1	02 00				        .byte 2, 0
>bfd3	db bf 7b 83 83 83		        .word nt_minus_trailing, xt_bl, z_bl
>bfd9	62 6c				        .text "bl"
.bfdb					nt_minus_trailing:
>bfdb	09 10				        .byte 9, UF
>bfdd	ec bf 5d 95 99 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>bfe3	2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>bfeb	67
.bfec					nt_minus_leading:
>bfec	08 10				        .byte 8, UF
>bfee	fc bf 44 95 5c 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>bff4	2d 6c 65 61 64 69 6e 67		        .text "-leading"
.bffc					nt_slash_string:
>bffc	07 10				        .byte 7, UF
>bffe	0b c0 cb 9f ea 9f		        .word nt_refill, xt_slash_string, z_slash_string
>c004	2f 73 74 72 69 6e 67		        .text "/string"
.c00b					nt_refill:
>c00b	06 00				        .byte 6, 0
>c00d	19 c0 d9 9a 1a 9b		        .word nt_accept, xt_refill, z_refill
>c013	72 65 66 69 6c 6c		        .text "refill"
.c019					nt_accept:
>c019	06 18				        .byte 6, UF+NN
>c01b	27 c0 2f 81 27 82		        .word nt_input_to_r, xt_accept, z_accept
>c021	61 63 63 65 70 74		        .text "accept"
.c027					nt_input_to_r:
>c027	07 08				        .byte 7, NN
>c029	36 c0 43 92 58 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c02f	69 6e 70 75 74 3e 72		        .text "input>r"
.c036					nt_r_to_input:
>c036	07 08				        .byte 7, NN
>c038	45 c0 84 9a 9b 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c03e	72 3e 69 6e 70 75 74		        .text "r>input"
.c045					nt_unused:
>c045	06 00				        .byte 6, 0
>c047	53 c0 06 a6 15 a6		        .word nt_depth, xt_unused, z_unused
>c04d	75 6e 75 73 65 64		        .text "unused"
.c053					nt_depth:
>c053	05 00				        .byte 5, 0
>c055	60 c0 d7 8a e5 8a		        .word nt_key, xt_depth, z_depth
>c05b	64 65 70 74 68			        .text "depth"
.c060					nt_key:
>c060	03 00				        .byte 3, 0
>c062	6b c0 0f 93 18 93		        .word nt_allot, xt_key, z_key
>c068	6b 65 79			        .text "key"
.c06b					nt_allot:
>c06b	05 10				        .byte 5, UF
>c06d	78 c0 8c 82 f4 82		        .word nt_create, xt_allot, z_allot
>c073	61 6c 6c 6f 74			        .text "allot"
.c078					nt_create:
>c078	06 00				        .byte 6, 0
>c07a	86 c0 4a 89 1e 8a		        .word nt_does, xt_create, z_create
>c080	63 72 65 61 74 65		        .text "create"
.c086					nt_does:
>c086	05 05				        .byte 5, CO+IM
>c088	93 c0 d6 8b e4 8b		        .word nt_variable, xt_does, z_does
>c08e	64 6f 65 73 3e			        .text "does>"
.c093					nt_variable:
>c093	08 00				        .byte 8, 0
>c095	a3 c0 2a a6 42 a6		        .word nt_constant, xt_variable, z_variable
>c09b	76 61 72 69 61 62 6c 65		        .text "variable"
.c0a3					nt_constant:
>c0a3	08 10				        .byte 8, UF
>c0a5	b3 c0 f2 88 2f 89		        .word nt_value, xt_constant, z_constant
>c0ab	63 6f 6e 73 74 61 6e 74		        .text "constant"
.c0b3					nt_value:
>c0b3	05 10				        .byte 5, UF
>c0b5	c0 c0 f2 88 2f 89		        .word nt_to, xt_constant, z_constant
>c0bb	76 61 6c 75 65			        .text "value"
.c0c0					nt_to:
>c0c0	02 0c				        .byte 2, NN+IM
>c0c2	ca c0 e3 a1 3e a2		        .word nt_s_to_d, xt_to, z_to
>c0c8	74 6f				        .text "to"
.c0ca					nt_s_to_d:
>c0ca	03 10				        .byte 3, UF
>c0cc	d5 c0 5e 9e 6f 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c0d2	73 3e 64			        .text "s>d"
.c0d5					nt_d_to_s:
>c0d5	03 10				        .byte 3, UF
>c0d7	e0 c0 61 8a 66 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c0dd	64 3e 73			        .text "d>s"
.c0e0					nt_d_minus:
>c0e0	02 10				        .byte 2, UF
>c0e2	ea c0 1f 8a 3f 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c0e8	64 2d				        .text "d-"
.c0ea					nt_d_plus:
>c0ea	02 10				        .byte 2, UF
>c0ec	f4 c0 40 8a 60 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c0f2	64 2b				        .text "d+"
.c0f4					nt_erase:
>c0f4	05 00				        .byte 5, 0      ; underflow checked by FILL
>c0f6	01 c1 d5 8e 1d 8f		        .word nt_blank, xt_erase, z_erase
>c0fc	65 72 61 73 65			        .text "erase"
.c101					nt_blank:
>c101	05 00				        .byte 5, 0     ; underflow checked by FILL
>c103	0e c1 cb 8e 1d 8f		        .word nt_fill, xt_blank, z_blank
>c109	62 6c 61 6e 6b			        .text "blank"
.c10e					nt_fill:
>c10e	04 10				        .byte 4, UF
>c110	1a c1 db 8e 1d 8f		        .word nt_find_name, xt_fill, z_fill
>c116	66 69 6c 6c			        .text "fill"
.c11a					nt_find_name:
>c11a	09 10				        .byte 9, UF
>c11c	2b c1 bc 8f 67 90		        .word nt_tick, xt_find_name, z_find_name
>c122	66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c12a	65
.c12b					nt_tick:
>c12b	01 00				        .byte 1, 0
>c12d	34 c1 c3 a1 e2 a1		        .word nt_bracket_tick, xt_tick, z_tick
>c133	27				        .text "'"
.c134					nt_bracket_tick:
>c134	03 05				        .byte 3, CO+IM
>c136	3f c1 7f 85 85 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c13c	5b 27 5d			        .text "[']"
.c13f					nt_name_to_int:
>c13f	08 10				        .byte 8, UF
>c141	4f c1 c2 95 de 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c147	6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c14f					nt_int_to_name:
>c14f	08 10				        .byte 8, UF
>c151	5f c1 59 92 cb 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c157	69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c15f					nt_name_to_string:
>c15f	0b 10				        .byte 11, UF
>c161	72 c1 df 95 f8 95		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c167	6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c16f	69 6e 67
.c172					nt_to_body:
>c172	05 10				        .byte 5, UF
>c174	7f c1 3f a2 63 a2		        .word nt_defer, xt_to_body, z_to_body
>c17a	3e 62 6f 64 79			        .text ">body"
.c17f					nt_defer:
>c17f	05 00				        .byte 5, 0
>c181	8c c1 8d 8a bf 8a		        .word nt_latestxt, xt_defer, z_defer
>c187	64 65 66 65 72			        .text "defer"
.c18c					nt_latestxt:
>c18c	08 00				        .byte 8, 0
>c18e	9c c1 2a 93 30 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c194	6c 61 74 65 73 74 78 74		        .text "latestxt"
.c19c					nt_latestnt:
>c19c	08 00				        .byte 8, 0
>c19e	ac c1 1c 93 29 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c1a4	6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c1ac					nt_parse_name:
>c1ac	0a 08				        .byte 10, NN
>c1ae	be c1 c0 98 b2 99		        .word nt_parse, xt_parse_name, z_parse_name
>c1b4	70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c1bc	6d 65
.c1be					nt_parse:
>c1be	05 10				        .byte 5, UF
>c1c0	cb c1 1b 99 b2 99		        .word nt_execute_parsing, xt_parse, z_parse
>c1c6	70 61 72 73 65			        .text "parse"
.c1cb					nt_execute_parsing:
>c1cb	0f 10				        .byte 15, UF
>c1cd	e2 c1 32 8f 58 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c1d3	65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c1db	70 61 72 73 69 6e 67
.c1e2					nt_source:
>c1e2	06 00				        .byte 6, 0
>c1e4	f0 c1 b0 a0 c4 a0		        .word nt_source_id, xt_source, z_source
>c1ea	73 6f 75 72 63 65		        .text "source"
.c1f0					nt_source_id:
>c1f0	09 00				        .byte 9, 0
>c1f2	01 c2 c5 a0 cf a0		        .word nt_colon, xt_source_id, z_source_id
>c1f8	73 6f 75 72 63 65 2d 69		        .text "source-id"
>c200	64
.c201					nt_colon:
>c201	01 00				        .byte 1, 0
>c203	0a c2 f0 86 32 87		        .word nt_semicolon, xt_colon, z_colon
>c209	3a				        .text ":"
.c20a					nt_semicolon:
>c20a	01 05				        .byte 1, CO+IM
>c20c	13 c2 3a 9f 98 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c212	3b				        .text ";"
.c213					nt_colon_noname:
>c213	07 00				        .byte 7, 0
>c215	22 c2 33 87 4e 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c21b	3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c222					nt_compile_comma:
>c222	08 18				        .byte 8, UF+NN
>c224	32 c2 ce 87 e5 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c22a	63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c232					nt_left_bracket:
>c232	01 05				        .byte 1, IM+CO
>c234	3b c2 36 93 3a 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c23a	5b				        .text "["
.c23b					nt_right_bracket:
>c23b	01 04				        .byte 1, IM
>c23d	44 c2 28 9b 2e 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c243	5d				        .text "]"
.c244					nt_literal:
>c244	07 15				        .byte 7, IM+CO+UF
>c246	53 c2 6b 93 78 93		        .word nt_sliteral, xt_literal, z_literal
>c24c	6c 69 74 65 72 61 6c		        .text "literal"
.c253					nt_sliteral:
>c253	08 15				        .byte 8, CO+IM+UF
>c255	63 c2 eb 9f 5a a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c25b	73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c263					nt_dot_quote:
>c263	02 05				        .byte 2, CO+IM
>c265	6d c2 48 8c 52 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c26b	2e 22				        .text ".", $22
.c26d					nt_s_quote:
>c26d	02 0c				        .byte 2, IM+NN
>c26f	77 c2 30 9d 5d 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c275	73 22				        .text "s", $22
.c277					nt_s_backslash_quote:
>c277	03 04				        .byte 3, IM
>c279	82 c2 68 9b 71 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c27f	73 5c 22			        .text "s", $5C, $22
.c282					nt_postpone:
>c282	08 05				        .byte 8, IM+CO
>c284	92 c2 f7 99 35 9a		        .word nt_immediate, xt_postpone, z_postpone
>c28a	70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c292					nt_immediate:
>c292	09 00				        .byte 9, 0
>c294	a3 c2 2c 92 37 92		        .word nt_compile_only, xt_immediate, z_immediate
>c29a	69 6d 6d 65 64 69 61 74		        .text "immediate"
>c2a2	65
.c2a3					nt_compile_only:
>c2a3	0c 00				        .byte 12, 0
>c2a5	b7 c2 e6 88 f1 88		        .word nt_never_native, xt_compile_only, z_compile_only
>c2ab	63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c2b3	6f 6e 6c 79
.c2b7					nt_never_native:
>c2b7	0c 00				        .byte 12, 0
>c2b9	cb c2 15 96 22 96		        .word nt_always_native, xt_never_native, z_never_native
>c2bf	6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c2c7	74 69 76 65
.c2cb					nt_always_native:
>c2cb	0d 00				        .byte 13, 0
>c2cd	e0 c2 11 83 1e 83		        .word nt_allow_native, xt_always_native, z_always_native
>c2d3	61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c2db	61 74 69 76 65
.c2e0					nt_allow_native:
>c2e0	0c 00				        .byte 12, 0
>c2e2	f4 c2 f5 82 00 83		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c2e8	61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c2f0	74 69 76 65
.c2f4					nt_nc_limit:
>c2f4	08 00				        .byte 8, 0
>c2f6	04 c3 f9 95 03 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c2fc	6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c304					nt_strip_underflow:
>c304	0f 00				        .byte 15, 0
>c306	1b c3 55 a1 5f a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c30c	73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c314	64 65 72 66 6c 6f 77
.c31b					nt_abort:
>c31b	05 00				        .byte 5, 0
>c31d	28 c3 60 80 a4 80		        .word nt_abort_quote, xt_abort, z_abort
>c323	61 62 6f 72 74			        .text "abort"
.c328					nt_abort_quote:
>c328	06 0d				        .byte 6, CO+IM+NN
>c32a	36 c3 fa 80 04 81		        .word nt_do, xt_abort_quote, z_abort_quote
>c330	61 62 6f 72 74 22		        .text "abort", $22
.c336					nt_do:
>c336	02 0d				        .byte 2, CO+IM+NN
>c338	40 c3 43 8b 9d 8b		        .word nt_question_do, xt_do, z_do
>c33e	64 6f				        .text "do"
.c340					nt_question_do:
>c340	03 0d				        .byte 3, CO+IM+NN
>c342	4b c3 3d 8b 9d 8b		        .word nt_i, xt_question_do, z_question_do
>c348	3f 64 6f			        .text "?do"
.c34b					nt_i:
>c34b	01 03				        .byte 1, AN+CO
>c34d	54 c3 ca 91 e3 91		        .word nt_j, xt_i, z_i
>c353	69				        .text "i"
.c354					nt_j:
>c354	01 03				        .byte 1, AN+CO
>c356	5d c3 f5 92 0e 93		        .word nt_loop, xt_j, z_j
>c35c	6a				        .text "j"
.c35d					nt_loop:
>c35d	04 05				        .byte 4, CO+IM
>c35f	69 c3 dc 93 49 94		        .word nt_plus_loop, xt_loop, z_loop
>c365	6c 6f 6f 70			        .text "loop"
.c369					nt_plus_loop:
>c369	05 05				        .byte 5, CO+IM
>c36b	76 c3 e3 93 49 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c371	2b 6c 6f 6f 70			        .text "+loop"
.c376					nt_exit:
>c376	04 03				        .byte 4, AN+CO
>c378	82 c3 59 8f 5a 8f		        .word nt_unloop, xt_exit, z_exit
>c37e	65 78 69 74			        .text "exit"
.c382					nt_unloop:
>c382	06 03				        .byte 6, AN+CO
>c384	90 c3 f4 a5 fa a5		        .word nt_leave, xt_unloop, z_unloop
>c38a	75 6e 6c 6f 6f 70		        .text "unloop"
.c390					nt_leave:
>c390	05 03				        .byte 5, AN+CO
>c392	9d c3 31 93 36 93		        .word nt_recurse, xt_leave, z_leave
>c398	6c 65 61 76 65			        .text "leave"
.c39d					nt_recurse:
>c39d	07 0d				        .byte 7, CO+IM+NN
>c39f	ac c3 9c 9a d8 9a		        .word nt_quit, xt_recurse, z_recurse
>c3a5	72 65 63 75 72 73 65		        .text "recurse"
.c3ac					nt_quit:
>c3ac	04 00				        .byte 4, 0
>c3ae	b8 c3 62 80 a4 80		        .word nt_begin, xt_quit, z_quit
>c3b4	71 75 69 74			        .text "quit"
.c3b8					nt_begin:
>c3b8	05 07				        .byte 5, AN+CO+IM
>c3ba	c5 c3 71 83 74 83		        .word nt_again, xt_begin, z_begin
>c3c0	62 65 67 69 6e			        .text "begin"
.c3c5					nt_again:
>c3c5	05 17				        .byte 5, AN+CO+IM+UF
>c3c7	d2 c3 6a 82 8a 82		        .word nt_state, xt_again, z_again
>c3cd	61 67 61 69 6e			        .text "again"
.c3d2					nt_state:
>c3d2	05 00				        .byte 5, 0
>c3d4	df c3 34 a1 3e a1		        .word nt_evaluate, xt_state, z_state
>c3da	73 74 61 74 65			        .text "state"
.c3df					nt_evaluate:
>c3df	08 10				        .byte 8, UF
>c3e1	ef c3 b6 90 09 91		        .word nt_base, xt_evaluate, z_evaluate
>c3e7	65 76 61 6c 75 61 74 65		        .text "evaluate"
.c3ef					nt_base:
>c3ef	04 00				        .byte 4, 0
>c3f1	fb c3 68 83 70 83		        .word nt_digit_question, xt_base, z_base
>c3f7	62 61 73 65			        .text "base"
.c3fb					nt_digit_question:
>c3fb	06 10				        .byte 6, UF
>c3fd	09 c4 e6 8a 1a 8b		        .word nt_number, xt_digit_question, z_digit_question
>c403	64 69 67 69 74 3f		        .text "digit?"
.c409					nt_number:
>c409	06 10				        .byte 6, UF
>c40b	17 c4 6b 96 67 97		        .word nt_to_number, xt_number, z_number
>c411	6e 75 6d 62 65 72		        .text "number"
.c417					nt_to_number:
>c417	07 10				        .byte 7, UF
>c419	26 c4 6f a2 0e a3		        .word nt_hex, xt_to_number, z_to_number
>c41f	3e 6e 75 6d 62 65 72		        .text ">number"
.c426					nt_hex:
>c426	03 00				        .byte 3, 0
>c428	31 c4 5e 91 64 91		        .word nt_decimal, xt_hex, z_hex
>c42e	68 65 78			        .text "hex"
.c431					nt_decimal:
>c431	07 00				        .byte 7, 0
>c433	40 c4 86 8a 8c 8a		        .word nt_count, xt_decimal, z_decimal
>c439	64 65 63 69 6d 61 6c		        .text "decimal"
.c440					nt_count:
>c440	05 10				        .byte 5, UF
>c442	4d c4 30 89 43 89		        .word nt_m_star, xt_count, z_count
>c448	63 6f 75 6e 74			        .text "count"
.c44d					nt_m_star:
>c44d	02 10				        .byte 2, UF
>c44f	57 c4 6f 94 89 94		        .word nt_um_star, xt_m_star, z_m_star
>c455	6d 2a				        .text "m*"
.c457					nt_um_star:
>c457	03 10				        .byte 3, UF
>c459	62 c4 ae a5 f3 a5		        .word nt_star, xt_um_star, z_um_star
>c45f	75 6d 2a			        .text "um*"
.c462					nt_star:
>c462	01 10				        .byte 1, UF
>c464	6b c4 12 a1 1a a1		        .word nt_um_slash_mod, xt_star, z_star
>c46a	2a				        .text "*"
.c46b					nt_um_slash_mod:
>c46b	06 10				        .byte 6, UF
>c46d	79 c4 6c a5 ad a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c473	75 6d 2f 6d 6f 64		        .text "um/mod"
.c479					nt_sm_slash_rem:
>c479	06 10				        .byte 6, UF
>c47b	87 c4 87 a0 af a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c481	73 6d 2f 72 65 6d		        .text "sm/rem"
.c487					nt_fm_slash_mod:
>c487	06 10				        .byte 6, UF
>c489	95 c4 72 90 a8 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c48f	66 6d 2f 6d 6f 64		        .text "fm/mod"
.c495					nt_slash:
>c495	01 10				        .byte 1, UF
>c497	9e c4 ae 9f ca 9f		        .word nt_slash_mod, xt_slash, z_slash
>c49d	2f				        .text "/"
.c49e					nt_slash_mod:
>c49e	04 10				        .byte 4, UF
>c4a0	aa c4 b3 9f ca 9f		        .word nt_mod, xt_slash_mod, z_slash_mod
>c4a6	2f 6d 6f 64			        .text "/mod"
.c4aa					nt_mod:
>c4aa	03 10				        .byte 3, UF
>c4ac	b5 c4 9a 95 a2 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c4b2	6d 6f 64			        .text "mod"
.c4b5					nt_star_slash_mod:
>c4b5	05 10				        .byte 5, UF
>c4b7	c2 c4 24 a1 33 a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c4bd	2a 2f 6d 6f 64			        .text "*/mod"
.c4c2					nt_star_slash:
>c4c2	02 10				        .byte 2, UF
>c4c4	cc c4 1b a1 23 a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c4ca	2a 2f				        .text "*/"
.c4cc					nt_backslash:
>c4cc	01 04				        .byte 1, IM
>c4ce	d5 c4 5f 83 67 83		        .word nt_move, xt_backslash, z_backslash
>c4d4	5c				        .byte $5c
.c4d5					nt_move:
>c4d5	04 18				        .byte 4, NN+UF
>c4d7	e1 c4 a3 95 c1 95		        .word nt_cmove_up, xt_move, z_move
>c4dd	6d 6f 76 65			        .text "move"
.c4e1					nt_cmove_up:
>c4e1	06 10				        .byte 6, UF
>c4e3	ef c4 b5 86 ef 86		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c4e9	63 6d 6f 76 65 3e		        .text "cmove>"
.c4ef					nt_cmove:
>c4ef	05 10				        .byte 5, UF
>c4f1	fc c4 7a 86 b4 86		        .word nt_pad, xt_cmove, z_cmove
>c4f7	63 6d 6f 76 65			        .text "cmove"
.c4fc					nt_pad:
>c4fc	03 00				        .byte 3, 0
>c4fe	07 c5 82 98 91 98		        .word nt_cleave, xt_pad, z_pad
>c504	70 61 64			        .text "pad"
.c507					nt_cleave:
>c507	06 10				        .byte 6, UF
>c509	15 c5 2d 86 79 86		        .word nt_hexstore, xt_cleave, z_cleave
>c50f	63 6c 65 61 76 65		        .text "cleave"
.c515					nt_hexstore:
>c515	08 10				        .byte 8, UF
>c517	25 c5 65 91 b7 91		        .word nt_within, xt_hexstore, z_hexstore
>c51d	68 65 78 73 74 6f 72 65		        .text "hexstore"
.c525					nt_within:
>c525	06 10				        .byte 6, UF
>c527	33 c5 57 a6 6c a6		        .word nt_to_in, xt_within, z_within
>c52d	77 69 74 68 69 6e		        .text "within"
.c533					nt_to_in:
>c533	03 00				        .byte 3, 0
>c535	3e c5 64 a2 6e a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c53b	3e 69 6e			        .text ">in"
.c53e					nt_less_number_sign:
>c53e	02 00				        .byte 2, 0
>c540	48 c5 3b 93 48 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c546	3c 23				        .text "<#"
.c548					nt_number_sign:
>c548	01 10				        .byte 1, UF
>c54a	51 c5 68 97 9c 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c550	23				        .text "#"
.c551					nt_number_sign_s:
>c551	02 10				        .byte 2, UF
>c553	5b c5 bf 97 cf 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c559	23 73				        .text "#s"
.c55b					nt_number_sign_greater:
>c55b	02 10				        .byte 2, UF
>c55d	65 c5 9d 97 be 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c563	23 3e				        .text "#>"
.c565					nt_hold:
>c565	04 10				        .byte 4, UF
>c567	71 c5 b8 91 c9 91		        .word nt_sign, xt_hold, z_hold
>c56d	68 6f 6c 64			        .text "hold"
.c571					nt_sign:
>c571	04 10				        .byte 4, UF
>c573	7d c5 99 9f ad 9f		        .word nt_output, xt_sign, z_sign
>c579	73 69 67 6e			        .text "sign"
.c57d					nt_output:
>c57d	06 00				        .byte 6, 0
>c57f	8b c5 69 98 73 98		        .word nt_input, xt_output, z_output
>c585	6f 75 74 70 75 74		        .text "output"
.c58b					nt_input:
>c58b	05 00				        .byte 5, 0
>c58d	98 c5 38 92 42 92		        .word nt_cr, xt_input, z_input
>c593	69 6e 70 75 74			        .text "input"
.c598					nt_cr:
>c598	02 00				        .byte 2, 0
>c59a	a2 c5 44 89 49 89		        .word nt_page, xt_cr, z_cr
>c5a0	63 72				        .text "cr"
.c5a2					nt_page:
>c5a2	04 00				        .byte 4, 0
>c5a4	ae c5 92 98 af 98		        .word nt_at_xy, xt_page, z_page
>c5aa	70 61 67 65			        .text "page"
.c5ae					nt_at_xy:
>c5ae	05 10				        .byte 5, UF
>c5b0	bb c5 31 83 5e 83		        .word nt_marker, xt_at_xy, z_at_xy
>c5b6	61 74 2d 78 79			        .text "at-xy"
.c5bb					nt_marker:
>c5bb	06 04				        .byte 6, IM
>c5bd	c9 c5 8a 94 c7 94		        .word nt_words, xt_marker, z_marker
>c5c3	6d 61 72 6b 65 72		        .text "marker"
.c5c9					nt_words:
>c5c9	05 00				        .byte 5, 0
>c5cb	d6 c5 ca a6 26 a7		        .word nt_wordsize, xt_words, z_words
>c5d1	77 6f 72 64 73			        .text "words"
.c5d6					nt_wordsize:
>c5d6	08 10				        .byte 8, UF
>c5d8	e6 c5 27 a7 47 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c5de	77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c5e6					nt_aligned:
>c5e6	07 00				        .byte 7, 0
>c5e8	f5 c5 8b 82 8b 82		        .word nt_align, xt_align, z_align
>c5ee	61 6c 69 67 6e 65 64		        .text "aligned"
.c5f5					nt_align:
>c5f5	05 00				        .byte 5, 0
>c5f7	02 c6 8b 82 8b 82		        .word nt_bell, xt_align, z_align
>c5fd	61 6c 69 67 6e			        .text "align"
.c602					nt_bell:
>c602	04 00				        .byte 4, 0
>c604	0e c6 75 83 7a 83		        .word nt_dump, xt_bell, z_bell
>c60a	62 65 6c 6c			        .text "bell"
.c60e					nt_dump:
>c60e	04 10				        .byte 4, UF
>c610	1a c6 15 8d 7b 8d		        .word nt_dot_s, xt_dump, z_dump
>c616	64 75 6d 70			        .text "dump"
.c61a					nt_dot_s:
>c61a	02 00				        .byte 2, 0
>c61c	24 c6 81 8c c4 8c		        .word nt_disasm, xt_dot_s, z_dot_s
>c622	2e 73				        .text ".s"
.c624					nt_disasm:
>c624	06 10				        .byte 6, UF
>c626	32 c6 1b 8b 21 8b		        .word nt_compare, xt_disasm, z_disasm
>c62c	64 69 73 61 73 6d		        .text "disasm"
.c632					nt_compare:
>c632	07 10				        .byte 7, UF
>c634	41 c6 69 87 cd 87		        .word nt_search, xt_compare, z_compare
>c63a	63 6f 6d 70 61 72 65		        .text "compare"
.c641					nt_search:
>c641	06 18				        .byte 6, UF+NN
>c643	4f c6 9b 9e 39 9f		        .word +, xt_search, z_search
>c649	73 65 61 72 63 68		        .text "search"
.c64f					+
.c64f					nt_environment_q:
>c64f	0c 10				        .byte 12, UF
>c651	63 c6 f6 8d 72 8e		        .word +, xt_environment_q, z_environment_q
>c657	65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c65f	65 6e 74 3f
.c663					+
.c663					nt_find:
>c663	04 10				        .byte 4, UF
>c665	6f c6 74 8f bb 8f		        .word nt_word, xt_find, z_find
>c66b	66 69 6e 64			        .text "find"
.c66f					nt_word:
>c66f	04 10				        .byte 4, UF
>c671	7b c6 6d a6 b2 a6		        .word nt_paren, xt_word, z_word
>c677	77 6f 72 64			        .text "word"
.c67b					nt_paren:
>c67b	01 04				        .byte 1, IM
>c67d	84 c6 b0 98 bf 98		        .word nt_dot_paren, xt_paren, z_paren
>c683	28				        .text "("
.c684					nt_dot_paren:
>c684	02 04				        .byte 2, IM
>c686	8e c6 39 8c 47 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c68c	2e 28				        .text ".("
.c68e					nt_if:
>c68e	02 0d				        .byte 2, IM+CO+NN
>c690	98 c6 e4 91 f4 91		        .word nt_then, xt_if, z_if
>c696	69 66				        .text "if"
.c698					nt_then:
>c698	04 0d				        .byte 4, IM+CO+NN
>c69a	a4 c6 74 a1 7d a1		        .word nt_else, xt_then, z_then
>c6a0	74 68 65 6e			        .text "then"
.c6a4					nt_else:
>c6a4	04 0d				        .byte 4, IM+CO+NN
>c6a6	b0 c6 a2 8d bb 8d		        .word nt_repeat, xt_else, z_else
>c6ac	65 6c 73 65			        .text "else"
.c6b0					nt_repeat:
>c6b0	06 0d				        .byte 6, IM+CO+NN
>c6b2	be c6 1b 9b 27 9b		        .word nt_until, xt_repeat, z_repeat
>c6b8	72 65 70 65 61 74		        .text "repeat"
.c6be					nt_until:
>c6be	05 0d				        .byte 5, IM+CO+NN
>c6c0	cb c6 fb a5 05 a6		        .word nt_while, xt_until, z_until
>c6c6	75 6e 74 69 6c			        .text "until"
.c6cb					nt_while:
>c6cb	05 0d				        .byte 5, IM+CO+NN
>c6cd	d8 c6 43 a6 56 a6		        .word nt_case, xt_while, z_while
>c6d3	77 68 69 6c 65			        .text "while"
.c6d8					nt_case:
>c6d8	04 0d				        .byte 4, IM+CO+NN
>c6da	e4 c6 5a a7 60 a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c6e0	63 61 73 65			        .text "case"
.c6e4					nt_of:
>c6e4	02 0d				        .byte 2, IM+CO+NN
>c6e6	ee c6 d0 97 e8 97		        .word nt_endof, xt_of, z_of
>c6ec	6f 66				        .text "of"
.c6ee					nt_endof:
>c6ee	05 0d				        .byte 5, IM+CO+NN
>c6f0	fb c6 a2 8d bb 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c6f6	65 6e 64 6f 66			        .text "endof"
.c6fb					nt_endcase:
>c6fb	07 0d				        .byte 7, IM+CO+NN
>c6fd	0a c7 e1 8d f5 8d		        .word nt_defer_fetch, xt_endcase, z_endcase
>c703	65 6e 64 63 61 73 65		        .text "endcase"
.c70a					nt_defer_fetch:
>c70a	06 00				        .byte 6, 0
>c70c	18 c7 c0 8a c6 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c712	64 65 66 65 72 40		        .text "defer@"
.c718					nt_defer_store:
>c718	06 00				        .byte 6, 0
>c71a	26 c7 c7 8a cd 8a		        .word nt_is, xt_defer_store, z_defer_store
>c720	64 65 66 65 72 21		        .text "defer!"
.c726					nt_is:
>c726	02 04				        .byte 2, IM
>c728	30 c7 dc 92 f4 92		        .word nt_action_of, xt_is, z_is
>c72e	69 73				        .text "is"
.c730					nt_action_of:
>c730	09 04				        .byte 9, IM
>c732	41 c7 51 82 69 82		        .word nt_useraddr, xt_action_of, z_action_of
>c738	61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c740	66
.c741					nt_useraddr:
>c741	08 00				        .byte 8, 0
>c743	51 c7 1f a6 29 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c749	75 73 65 72 61 64 64 72		        .text "useraddr"
.c751					nt_buffer_colon:
>c751	07 00				        .byte 7, 0
>c753	60 c7 c7 85 cd 85		        .word +, xt_buffer_colon, z_buffer_colon
>c759	62 75 66 66 65 72 3a		        .text "buffer:"
.c760					+
.c760					nt_buffstatus:
>c760	0a 00				        .byte 10, 0
>c762	72 c7 ce 85 dd 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c768	62 75 66 66 73 74 61 74		        .text "buffstatus"
>c770	75 73
.c772					nt_buffblocknum:
>c772	0c 00				        .byte 12, 0
>c774	86 c7 86 85 95 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c77a	62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c782	6b 6e 75 6d
.c786					nt_blkbuffer:
>c786	09 00				        .byte 9, 0
>c788	97 c7 94 83 a1 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c78e	62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c796	72
.c797					nt_scr:
>c797	03 00				        .byte 3, 0
>c799	a2 c7 8b 9e 9a 9e		        .word nt_blk, xt_scr, z_scr
>c79f	73 63 72			        .text "scr"
.c7a2					nt_blk:
>c7a2	03 00				        .byte 3, 0
>c7a4	ad c7 84 83 93 83		        .word nt_block_write, xt_blk, z_blk
>c7aa	62 6c 6b			        .text "blk"
.c7ad					nt_block_write:
>c7ad	0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c7af	c0 c7 41 85 4f 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c7b5	62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c7bd	69 74 65
.c7c0					nt_block_write_vector:
>c7c0	12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c7c2	da c7 4f 85 5e 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c7c8	62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c7d0	69 74 65 2d 76 65 63 74 6f 72
.c7da					nt_block_read:
>c7da	0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c7dc	ec c7 1e 85 2c 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c7e2	62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c7ea	61 64
.c7ec					nt_block_read_vector:
>c7ec	11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c7ee	05 c8 2c 85 3b 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c7f4	62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c7fc	61 64 2d 76 65 63 74 6f 72
.c805					nt_save_buffers:
>c805	0c 00				        .byte 12, 0
>c807	19 c8 70 9e 8a 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c80d	73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c815	66 65 72 73
.c819					nt_block:
>c819	05 00				        .byte 5, 0
>c81b	26 c8 a2 83 f4 83		        .word nt_update, xt_block, z_block
>c821	62 6c 6f 63 6b			        .text "block"
.c826					nt_update:
>c826	06 00				        .byte 6, 0
>c828	34 c8 16 a6 1e a6		        .word nt_buffer, xt_update, z_update
>c82e	75 70 64 61 74 65		        .text "update"
.c834					nt_buffer:
>c834	06 00				        .byte 6, 0
>c836	42 c8 96 85 c6 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c83c	62 75 66 66 65 72		        .text "buffer"
.c842					nt_empty_buffers:
>c842	0d 00				        .byte 13, 0
>c844	57 c8 da 8d e0 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c84a	65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c852	66 66 65 72 73
.c857					nt_flush:
>c857	05 00				        .byte 5, 0
>c859	64 c8 68 90 71 90		        .word nt_load, xt_flush, z_flush
>c85f	66 6c 75 73 68			        .text "flush"
.c864					nt_load:
>c864	04 10				        .byte 4, UF
>c866	70 c8 98 93 db 93		        .word nt_thru, xt_load, z_load
>c86c	6c 6f 61 64			        .text "load"
.c870					nt_thru:
>c870	04 10				        .byte 4, UF
>c872	7c c8 7e a1 c2 a1		        .word nt_list, xt_thru, z_thru
>c878	74 68 72 75			        .text "thru"
.c87c					nt_list:
>c87c	04 10				        .byte 4, UF
>c87e	88 c8 5e 93 6a 93		        .word +, xt_list, z_list
>c884	6c 69 73 74			        .text "list"
.c888					+
.c888					nt_block_ramdrive_init:
>c888	13 10				        .byte 19, UF
>c88a	a3 c8 f5 83 1d 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c890	62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c898	6d 64 72 69 76 65 2d 69 6e 69 74
.c8a3					+
.c8a3					nt_definitions:
>c8a3	0b 00				        .byte 11, 0
>c8a5	b6 c8 ce 8a d6 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c8ab	64 65 66 69 6e 69 74 69		        .text "definitions"
>c8b3	6f 6e 73
.c8b6					nt_wordlist:
>c8b6	08 00				        .byte 8, 0
>c8b8	c6 c8 b3 a6 c9 a6		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c8be	77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c8c6					nt_search_wordlist:
>c8c6	0f 10				        .byte 15, UF
>c8c8	dd c8 81 9b 61 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c8ce	73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c8d6	6f 72 64 6c 69 73 74
.c8dd					nt_set_current:
>c8dd	0b 10				        .byte 11, UF
>c8df	f0 c8 f0 9c fb 9c		        .word nt_get_current, xt_set_current, z_set_current
>c8e5	73 65 74 2d 63 75 72 72		        .text "set-current"
>c8ed	65 6e 74
.c8f0					nt_get_current:
>c8f0	0b 00				        .byte 11, 0
>c8f2	03 c9 0a 91 14 91		        .word nt_set_order, xt_get_current, z_get_current
>c8f8	67 65 74 2d 63 75 72 72		        .text "get-current"
>c900	65 6e 74
.c903					nt_set_order:
>c903	09 00				        .byte 9, 0
>c905	14 c9 fc 9c 2f 9d		        .word nt_get_order, xt_set_order, z_set_order
>c90b	73 65 74 2d 6f 72 64 65		        .text "set-order"
>c913	72
.c914					nt_get_order:
>c914	09 00				        .byte 9, 0
>c916	25 c9 15 91 3d 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c91c	67 65 74 2d 6f 72 64 65		        .text "get-order"
>c924	72
.c925					nt_root_wordlist:
>c925	0d 00				        .byte 13, 0
>c927	3a c9 2f 9b 37 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c92d	72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c935	64 6c 69 73 74
.c93a					+
.c93a					nt_assembler_wordlist:
>c93a	12 00				        .byte 18, 0
>c93c	54 c9 59 a3 61 a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c942	61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c94a	72 2d 77 6f 72 64 6c 69 73 74
.c954					+
.c954					nt_editor_wordlist:
>c954	0f 00				        .byte 15, 0
>c956	6b c9 e9 97 f1 97		        .word +, xt_editor_wordlist, z_editor_wordlist
>c95c	65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c964	6f 72 64 6c 69 73 74
.c96b					+
.c96b					nt_forth_wordlist:
>c96b	0e 00				        .byte 14, 0
>c96d	81 c9 5a a7 60 a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c973	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c97b	72 64 6c 69 73 74
.c981					nt_only:
>c981	04 00				        .byte 4, 0
>c983	8d c9 08 98 13 98		        .word nt_also, xt_only, z_only
>c989	6f 6e 6c 79			        .text "only"
.c98d					nt_also:
>c98d	04 00				        .byte 4, 0
>c98f	99 c9 01 83 10 83		        .word nt_previous, xt_also, z_also
>c995	61 6c 73 6f			        .text "also"
.c999					nt_previous:
>c999	08 00				        .byte 8, 0
>c99b	a9 c9 36 9a 42 9a		        .word nt_to_order, xt_previous, z_previous
>c9a1	70 72 65 76 69 6f 75 73		        .text "previous"
.c9a9					nt_to_order:
>c9a9	06 00				        .byte 6, 0
>c9ab	b7 c9 0f a3 21 a3		        .word nt_order, xt_to_order, z_to_order
>c9b1	3e 6f 72 64 65 72		        .text ">order"
.c9b7					nt_order:
>c9b7	05 00				        .byte 5, 0
>c9b9	c4 c9 26 98 50 98		        .word nt_forth, xt_order, z_order
>c9bf	6f 72 64 65 72			        .text "order"
.c9c4					nt_forth:
>c9c4	05 00				        .byte 5, 0
>c9c6	d1 c9 a9 90 af 90		        .word +, xt_forth, z_forth
>c9cc	66 6f 72 74 68			        .text "forth"
.c9d1					+
>c9d1	03 08				nt_see: .byte 3, NN
>c9d3	dc c9 62 9c ef 9c		        .word +, xt_see, z_see
>c9d9	73 65 65			        .text "see"
.c9dc					+
.c9dc					nt_ed:
>c9dc	02 08				        .byte 2, NN
>c9de	e6 c9 9e 8d a1 8d		        .word +, xt_ed, z_ed
>c9e4	65 64				        .text "ed"
.c9e6					+
.c9e6					nt_cold:
>c9e6	04 00				        .byte 4, 0
>c9e8	f2 c9 00 80 a4 80		        .word nt_bye, xt_cold, z_cold
>c9ee	63 6f 6c 64			        .text "cold"
.c9f2					nt_bye:
>c9f2	03				        .byte 3         ; length of word strings
>c9f3	00				        .byte 0         ; status byte
>c9f4	00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>c9f6	de 85				        .word xt_bye    ; start of code block (xt of this word)
>c9f8	e1 85				        .word z_bye     ; end of code (RTS)
>c9fa	62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.c9fd					root_dictionary_start:
.c9fd					nt_root_set_order:
>c9fd	09 00				        .byte 9, 0
>c9ff	0e ca fc 9c 2f 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca05	73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca0d	72
.ca0e					nt_root_forth:
>ca0e	05 00				        .byte 5, 0
>ca10	1b ca a9 90 af 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca16	66 6f 72 74 68			        .text "forth"
.ca1b					nt_root_forth_wordlist:
>ca1b	0e 00				        .byte 14, 0
>ca1d	31 ca 5a a7 60 a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca23	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca2b	72 64 6c 69 73 74
.ca31					nt_root_words:
>ca31	05 00				        .byte 5, 0
>ca33	00 00 ca a6 26 a7		        .word 0000, xt_words, z_words
>ca39	77 6f 72 64 73			        .text "words"
.ca3e					editor_dictionary_start:
.ca3e					nt_editor_o:
>ca3e	01 00				        .byte 1, 0
>ca40	47 ca 8d a8 d2 a8		        .word nt_editor_line, xt_editor_o, z_editor_o
>ca46	6f				        .text "o"
.ca47					nt_editor_line:
>ca47	04 10				        .byte 4, UF
>ca49	53 ca 74 a8 8c a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>ca4f	6c 69 6e 65			        .text "line"
.ca53					nt_editor_l:
>ca53	01 00				        .byte 1, 0
>ca55	5c ca f8 a7 73 a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>ca5b	6c				        .text "l"
.ca5c					nt_editor_el:
>ca5c	02 00				        .byte 2, 0
>ca5e	66 ca e6 a7 f7 a7		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>ca64	65 6c				        .text "el"
.ca66					nt_editor_erase_screen:
>ca66	0c 00				        .byte 12, 0
>ca68	7a ca d4 a7 e5 a7		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>ca6e	65 72 61 73 65 2d 73 63		        .text "erase-screen"
>ca76	72 65 65 6e
.ca7a					nt_editor_enter_screen:
>ca7a	0c 00				        .byte 12, 0
>ca7c	00 00 b8 a7 d3 a7		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>ca82	65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>ca8a	72 65 65 6e
.ca8e					assembler_dictionary_start:
.ca8e					nt_asm_adc_h:
>ca8e	05 0c						.byte 5, IM+NN
>ca90	9b ca				                .word nt_asm_adc_x
>ca92	d3 a8 d8 a8					.word xt_asm_adc_h, z_asm_adc_h
>ca96	61 64 63 2e 23					.text "adc.#"
.ca9b					nt_asm_adc_x:
>ca9b	05 0c						.byte 5, IM+NN
>ca9d	a8 ca				                .word nt_asm_adc_y
>ca9f	d8 a8 dd a8					.word xt_asm_adc_x, z_asm_adc_x
>caa3	61 64 63 2e 78					.text "adc.x"
.caa8					nt_asm_adc_y:
>caa8	05 0c						.byte 5, IM+NN
>caaa	b5 ca				                .word nt_asm_adc_z
>caac	dd a8 e2 a8					.word xt_asm_adc_y, z_asm_adc_y
>cab0	61 64 63 2e 79					.text "adc.y"
.cab5					nt_asm_adc_z:
>cab5	05 0c						.byte 5, IM+NN
>cab7	c2 ca				                .word nt_asm_adc_zi
>cab9	e2 a8 e7 a8					.word xt_asm_adc_z, z_asm_adc_z
>cabd	61 64 63 2e 7a					.text "adc.z"
.cac2					nt_asm_adc_zi:
>cac2	06 0c						.byte 6, IM+NN
>cac4	d0 ca				                .word nt_asm_adc_ziy
>cac6	e7 a8 ec a8					.word xt_asm_adc_zi, z_asm_adc_zi
>caca	61 64 63 2e 7a 69				.text "adc.zi"
.cad0					nt_asm_adc_ziy:
>cad0	07 0c						.byte 7, IM+NN
>cad2	df ca				                .word nt_asm_adc_zx
>cad4	ec a8 f1 a8					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cad8	61 64 63 2e 7a 69 79				.text "adc.ziy"
.cadf					nt_asm_adc_zx:
>cadf	06 0c						.byte 6, IM+NN
>cae1	ed ca				                .word nt_asm_adc_zxi
>cae3	f1 a8 f6 a8					.word xt_asm_adc_zx, z_asm_adc_zx
>cae7	61 64 63 2e 7a 78				.text "adc.zx"
.caed					nt_asm_adc_zxi:
>caed	07 0c						.byte 7, IM+NN
>caef	fc ca				                .word nt_asm_and
>caf1	f6 a8 fb a8					.word xt_asm_adc_zxi, z_asm_adc_zxi
>caf5	61 64 63 2e 7a 78 69				.text "adc.zxi"
.cafc					nt_asm_and:
>cafc	04 0c						.byte 4, IM+NN
>cafe	08 cb				                .word nt_asm_and_h
>cb00	fb a8 00 a9					.word xt_asm_and, z_asm_and
>cb04	61 6e 64 2e					.text "and."
.cb08					nt_asm_and_h:
>cb08	05 0c						.byte 5, IM+NN
>cb0a	15 cb				                .word nt_asm_and_x
>cb0c	00 a9 05 a9					.word xt_asm_and_h, z_asm_and_h
>cb10	61 6e 64 2e 23					.text "and.#"
.cb15					nt_asm_and_x:
>cb15	05 0c						.byte 5, IM+NN
>cb17	22 cb				                .word nt_asm_and_y
>cb19	05 a9 0a a9					.word xt_asm_and_x, z_asm_and_x
>cb1d	61 6e 64 2e 78					.text "and.x"
.cb22					nt_asm_and_y:
>cb22	05 0c						.byte 5, IM+NN
>cb24	2f cb				                .word nt_asm_and_z
>cb26	0a a9 0f a9					.word xt_asm_and_y, z_asm_and_y
>cb2a	61 6e 64 2e 79					.text "and.y"
.cb2f					nt_asm_and_z:
>cb2f	05 0c						.byte 5, IM+NN
>cb31	3c cb				                .word nt_asm_and_zi
>cb33	0f a9 14 a9					.word xt_asm_and_z, z_asm_and_z
>cb37	61 6e 64 2e 7a					.text "and.z"
.cb3c					nt_asm_and_zi:
>cb3c	06 0c						.byte 6, IM+NN
>cb3e	4a cb				                .word nt_asm_and_ziy
>cb40	14 a9 19 a9					.word xt_asm_and_zi, z_asm_and_zi
>cb44	61 6e 64 2e 7a 69				.text "and.zi"
.cb4a					nt_asm_and_ziy:
>cb4a	07 0c						.byte 7, IM+NN
>cb4c	59 cb				                .word nt_asm_and_zx
>cb4e	19 a9 1e a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cb52	61 6e 64 2e 7a 69 79				.text "and.ziy"
.cb59					nt_asm_and_zx:
>cb59	06 0c						.byte 6, IM+NN
>cb5b	67 cb				                .word nt_asm_and_zxi
>cb5d	1e a9 23 a9					.word xt_asm_and_zx, z_asm_and_zx
>cb61	61 6e 64 2e 7a 78				.text "and.zx"
.cb67					nt_asm_and_zxi:
>cb67	07 0c						.byte 7, IM+NN
>cb69	76 cb				                .word nt_asm_asl
>cb6b	23 a9 28 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cb6f	61 6e 64 2e 7a 78 69				.text "and.zxi"
.cb76					nt_asm_asl:
>cb76	03 0c						.byte 3, IM+NN
>cb78	81 cb				                .word nt_asm_asl_a
>cb7a	28 a9 2d a9					.word xt_asm_asl, z_asm_asl
>cb7e	61 73 6c					.text "asl"
.cb81					nt_asm_asl_a:
>cb81	05 0c						.byte 5, IM+NN
>cb83	8e cb				                .word nt_asm_asl_x
>cb85	2d a9 32 a9					.word xt_asm_asl_a, z_asm_asl_a
>cb89	61 73 6c 2e 61					.text "asl.a"
.cb8e					nt_asm_asl_x:
>cb8e	05 0c						.byte 5, IM+NN
>cb90	9b cb				                .word nt_asm_asl_z
>cb92	32 a9 37 a9					.word xt_asm_asl_x, z_asm_asl_x
>cb96	61 73 6c 2e 78					.text "asl.x"
.cb9b					nt_asm_asl_z:
>cb9b	05 0c						.byte 5, IM+NN
>cb9d	a8 cb				                .word nt_asm_asl_zx
>cb9f	37 a9 3c a9					.word xt_asm_asl_z, z_asm_asl_z
>cba3	61 73 6c 2e 7a					.text "asl.z"
.cba8					nt_asm_asl_zx:
>cba8	06 0c						.byte 6, IM+NN
>cbaa	b6 cb				                .word nt_asm_bcc
>cbac	3c a9 41 a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cbb0	61 73 6c 2e 7a 78				.text "asl.zx"
.cbb6					nt_asm_bcc:
>cbb6	03 0c						.byte 3, IM+NN
>cbb8	c1 cb				                .word nt_asm_bcs
>cbba	41 a9 46 a9					.word xt_asm_bcc, z_asm_bcc
>cbbe	62 63 63					.text "bcc"
.cbc1					nt_asm_bcs:
>cbc1	03 0c						.byte 3, IM+NN
>cbc3	cc cb				                .word nt_asm_beq
>cbc5	46 a9 4d a9					.word xt_asm_bcs, z_asm_bcs
>cbc9	62 63 73					.text "bcs"
.cbcc					nt_asm_beq:
>cbcc	03 0c						.byte 3, IM+NN
>cbce	d7 cb				                .word nt_asm_bit
>cbd0	4d a9 52 a9					.word xt_asm_beq, z_asm_beq
>cbd4	62 65 71					.text "beq"
.cbd7					nt_asm_bit:
>cbd7	03 0c						.byte 3, IM+NN
>cbd9	e2 cb				                .word nt_asm_bit_h
>cbdb	52 a9 57 a9					.word xt_asm_bit, z_asm_bit
>cbdf	62 69 74					.text "bit"
.cbe2					nt_asm_bit_h:
>cbe2	05 0c						.byte 5, IM+NN
>cbe4	ef cb				                .word nt_asm_bit_x
>cbe6	57 a9 5c a9					.word xt_asm_bit_h, z_asm_bit_h
>cbea	62 69 74 2e 23					.text "bit.#"
.cbef					nt_asm_bit_x:
>cbef	05 0c						.byte 5, IM+NN
>cbf1	fc cb				                .word nt_asm_bit_z
>cbf3	5c a9 61 a9					.word xt_asm_bit_x, z_asm_bit_x
>cbf7	62 69 74 2e 78					.text "bit.x"
.cbfc					nt_asm_bit_z:
>cbfc	05 0c						.byte 5, IM+NN
>cbfe	09 cc				                .word nt_asm_bit_zx
>cc00	61 a9 66 a9					.word xt_asm_bit_z, z_asm_bit_z
>cc04	62 69 74 2e 7a					.text "bit.z"
.cc09					nt_asm_bit_zx:
>cc09	06 0c						.byte 6, IM+NN
>cc0b	17 cc				                .word nt_asm_bmi
>cc0d	66 a9 6b a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cc11	62 69 74 2e 7a 78				.text "bit.zx"
.cc17					nt_asm_bmi:
>cc17	03 0c						.byte 3, IM+NN
>cc19	22 cc				                .word nt_asm_bne
>cc1b	6b a9 70 a9					.word xt_asm_bmi, z_asm_bmi
>cc1f	62 6d 69					.text "bmi"
.cc22					nt_asm_bne:
>cc22	03 0c						.byte 3, IM+NN
>cc24	2d cc				                .word nt_asm_bpl
>cc26	70 a9 75 a9					.word xt_asm_bne, z_asm_bne
>cc2a	62 6e 65					.text "bne"
.cc2d					nt_asm_bpl:
>cc2d	03 0c						.byte 3, IM+NN
>cc2f	38 cc				                .word nt_asm_bra
>cc31	75 a9 7a a9					.word xt_asm_bpl, z_asm_bpl
>cc35	62 70 6c					.text "bpl"
.cc38					nt_asm_bra:
>cc38	03 0c						.byte 3, IM+NN
>cc3a	43 cc				                .word nt_asm_brk
>cc3c	7a a9 7f a9					.word xt_asm_bra, z_asm_bra
>cc40	62 72 61					.text "bra"
.cc43					nt_asm_brk:
>cc43	03 0c						.byte 3, IM+NN
>cc45	4e cc				                .word nt_asm_bvc
>cc47	7f a9 84 a9					.word xt_asm_brk, z_asm_brk
>cc4b	62 72 6b					.text "brk"
.cc4e					nt_asm_bvc:
>cc4e	03 0c						.byte 3, IM+NN
>cc50	59 cc				                .word nt_asm_bvs
>cc52	84 a9 89 a9					.word xt_asm_bvc, z_asm_bvc
>cc56	62 76 63					.text "bvc"
.cc59					nt_asm_bvs:
>cc59	03 0c						.byte 3, IM+NN
>cc5b	64 cc				                .word nt_asm_clc
>cc5d	89 a9 8e a9					.word xt_asm_bvs, z_asm_bvs
>cc61	62 76 73					.text "bvs"
.cc64					nt_asm_clc:
>cc64	03 0c						.byte 3, IM+NN
>cc66	6f cc				                .word nt_asm_cld
>cc68	8e a9 93 a9					.word xt_asm_clc, z_asm_clc
>cc6c	63 6c 63					.text "clc"
.cc6f					nt_asm_cld:
>cc6f	03 0c						.byte 3, IM+NN
>cc71	7a cc				                .word nt_asm_cli
>cc73	93 a9 98 a9					.word xt_asm_cld, z_asm_cld
>cc77	63 6c 64					.text "cld"
.cc7a					nt_asm_cli:
>cc7a	03 0c						.byte 3, IM+NN
>cc7c	85 cc				                .word nt_asm_clv
>cc7e	98 a9 9d a9					.word xt_asm_cli, z_asm_cli
>cc82	63 6c 69					.text "cli"
.cc85					nt_asm_clv:
>cc85	03 0c						.byte 3, IM+NN
>cc87	90 cc				                .word nt_asm_cmp
>cc89	9d a9 a2 a9					.word xt_asm_clv, z_asm_clv
>cc8d	63 6c 76					.text "clv"
.cc90					nt_asm_cmp:
>cc90	03 0c						.byte 3, IM+NN
>cc92	9b cc				                .word nt_asm_cmp_h
>cc94	a2 a9 a7 a9					.word xt_asm_cmp, z_asm_cmp
>cc98	63 6d 70					.text "cmp"
.cc9b					nt_asm_cmp_h:
>cc9b	05 0c						.byte 5, IM+NN
>cc9d	a8 cc				                .word nt_asm_cmp_x
>cc9f	a7 a9 ac a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cca3	63 6d 70 2e 23					.text "cmp.#"
.cca8					nt_asm_cmp_x:
>cca8	05 0c						.byte 5, IM+NN
>ccaa	b5 cc				                .word nt_asm_cmp_y
>ccac	ac a9 b1 a9					.word xt_asm_cmp_x, z_asm_cmp_x
>ccb0	63 6d 70 2e 78					.text "cmp.x"
.ccb5					nt_asm_cmp_y:
>ccb5	05 0c						.byte 5, IM+NN
>ccb7	c2 cc				                .word nt_asm_cmp_z
>ccb9	b1 a9 b6 a9					.word xt_asm_cmp_y, z_asm_cmp_y
>ccbd	63 6d 70 2e 79					.text "cmp.y"
.ccc2					nt_asm_cmp_z:
>ccc2	05 0c						.byte 5, IM+NN
>ccc4	cf cc				                .word nt_asm_cmp_zi
>ccc6	b6 a9 bb a9					.word xt_asm_cmp_z, z_asm_cmp_z
>ccca	63 6d 70 2e 7a					.text "cmp.z"
.cccf					nt_asm_cmp_zi:
>cccf	06 0c						.byte 6, IM+NN
>ccd1	dd cc				                .word nt_asm_cmp_ziy
>ccd3	bb a9 c0 a9					.word xt_asm_cmp_zi, z_asm_cmp_zi
>ccd7	63 6d 70 2e 7a 69				.text "cmp.zi"
.ccdd					nt_asm_cmp_ziy:
>ccdd	07 0c						.byte 7, IM+NN
>ccdf	ec cc				                .word nt_asm_cmp_zx
>cce1	c0 a9 c5 a9					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cce5	63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.ccec					nt_asm_cmp_zx:
>ccec	06 0c						.byte 6, IM+NN
>ccee	fa cc				                .word nt_asm_cmp_zxi
>ccf0	c5 a9 ca a9					.word xt_asm_cmp_zx, z_asm_cmp_zx
>ccf4	63 6d 70 2e 7a 78				.text "cmp.zx"
.ccfa					nt_asm_cmp_zxi:
>ccfa	07 0c						.byte 7, IM+NN
>ccfc	09 cd				                .word nt_asm_cpx
>ccfe	ca a9 cf a9					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd02	63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd09					nt_asm_cpx:
>cd09	03 0c						.byte 3, IM+NN
>cd0b	14 cd				                .word nt_asm_cpx_h
>cd0d	cf a9 d4 a9					.word xt_asm_cpx, z_asm_cpx
>cd11	63 70 78					.text "cpx"
.cd14					nt_asm_cpx_h:
>cd14	05 0c						.byte 5, IM+NN
>cd16	21 cd				                .word nt_asm_cpx_z
>cd18	d4 a9 d9 a9					.word xt_asm_cpx_h, z_asm_cpx_h
>cd1c	63 70 78 2e 23					.text "cpx.#"
.cd21					nt_asm_cpx_z:
>cd21	05 0c						.byte 5, IM+NN
>cd23	2e cd				                .word nt_asm_cpy
>cd25	d9 a9 de a9					.word xt_asm_cpx_z, z_asm_cpx_z
>cd29	63 70 78 2e 7a					.text "cpx.z"
.cd2e					nt_asm_cpy:
>cd2e	03 0c						.byte 3, IM+NN
>cd30	39 cd				                .word nt_asm_cpy_h
>cd32	de a9 e5 a9					.word xt_asm_cpy, z_asm_cpy
>cd36	63 70 79					.text "cpy"
.cd39					nt_asm_cpy_h:
>cd39	05 0c						.byte 5, IM+NN
>cd3b	46 cd				                .word nt_asm_cpy_z
>cd3d	e5 a9 ea a9					.word xt_asm_cpy_h, z_asm_cpy_h
>cd41	63 70 79 2e 23					.text "cpy.#"
.cd46					nt_asm_cpy_z:
>cd46	05 0c						.byte 5, IM+NN
>cd48	53 cd				                .word nt_asm_dec
>cd4a	ea a9 ef a9					.word xt_asm_cpy_z, z_asm_cpy_z
>cd4e	63 70 79 2e 7a					.text "cpy.z"
.cd53					nt_asm_dec:
>cd53	03 0c						.byte 3, IM+NN
>cd55	5e cd				                .word nt_asm_dec_a
>cd57	ef a9 f4 a9					.word xt_asm_dec, z_asm_dec
>cd5b	64 65 63					.text "dec"
.cd5e					nt_asm_dec_a:
>cd5e	05 0c						.byte 5, IM+NN
>cd60	6b cd				                .word nt_asm_dec_x
>cd62	f4 a9 f9 a9					.word xt_asm_dec_a, z_asm_dec_a
>cd66	64 65 63 2e 61					.text "dec.a"
.cd6b					nt_asm_dec_x:
>cd6b	05 0c						.byte 5, IM+NN
>cd6d	78 cd				                .word nt_asm_dec_z
>cd6f	f9 a9 fe a9					.word xt_asm_dec_x, z_asm_dec_x
>cd73	64 65 63 2e 78					.text "dec.x"
.cd78					nt_asm_dec_z:
>cd78	05 0c						.byte 5, IM+NN
>cd7a	85 cd				                .word nt_asm_dec_zx
>cd7c	fe a9 03 aa					.word xt_asm_dec_z, z_asm_dec_z
>cd80	64 65 63 2e 7a					.text "dec.z"
.cd85					nt_asm_dec_zx:
>cd85	06 0c						.byte 6, IM+NN
>cd87	93 cd				                .word nt_asm_dex
>cd89	03 aa 08 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cd8d	64 65 63 2e 7a 78				.text "dec.zx"
.cd93					nt_asm_dex:
>cd93	03 0c						.byte 3, IM+NN
>cd95	9e cd				                .word nt_asm_dey
>cd97	08 aa 0d aa					.word xt_asm_dex, z_asm_dex
>cd9b	64 65 78					.text "dex"
.cd9e					nt_asm_dey:
>cd9e	03 0c						.byte 3, IM+NN
>cda0	a9 cd				                .word nt_asm_eor
>cda2	0d aa 12 aa					.word xt_asm_dey, z_asm_dey
>cda6	64 65 79					.text "dey"
.cda9					nt_asm_eor:
>cda9	03 0c						.byte 3, IM+NN
>cdab	b4 cd				                .word nt_asm_eor_h
>cdad	12 aa 17 aa					.word xt_asm_eor, z_asm_eor
>cdb1	65 6f 72					.text "eor"
.cdb4					nt_asm_eor_h:
>cdb4	05 0c						.byte 5, IM+NN
>cdb6	c1 cd				                .word nt_asm_eor_x
>cdb8	17 aa 1c aa					.word xt_asm_eor_h, z_asm_eor_h
>cdbc	65 6f 72 2e 23					.text "eor.#"
.cdc1					nt_asm_eor_x:
>cdc1	05 0c						.byte 5, IM+NN
>cdc3	ce cd				                .word nt_asm_eor_y
>cdc5	1c aa 21 aa					.word xt_asm_eor_x, z_asm_eor_x
>cdc9	65 6f 72 2e 78					.text "eor.x"
.cdce					nt_asm_eor_y:
>cdce	05 0c						.byte 5, IM+NN
>cdd0	db cd				                .word nt_asm_eor_z
>cdd2	21 aa 26 aa					.word xt_asm_eor_y, z_asm_eor_y
>cdd6	65 6f 72 2e 79					.text "eor.y"
.cddb					nt_asm_eor_z:
>cddb	05 0c						.byte 5, IM+NN
>cddd	e8 cd				                .word nt_asm_eor_zi
>cddf	26 aa 2b aa					.word xt_asm_eor_z, z_asm_eor_z
>cde3	65 6f 72 2e 7a					.text "eor.z"
.cde8					nt_asm_eor_zi:
>cde8	06 0c						.byte 6, IM+NN
>cdea	f6 cd				                .word nt_asm_eor_ziy
>cdec	2b aa 30 aa					.word xt_asm_eor_zi, z_asm_eor_zi
>cdf0	65 6f 72 2e 7a 69				.text "eor.zi"
.cdf6					nt_asm_eor_ziy:
>cdf6	07 0c						.byte 7, IM+NN
>cdf8	05 ce				                .word nt_asm_eor_zx
>cdfa	30 aa 35 aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cdfe	65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce05					nt_asm_eor_zx:
>ce05	06 0c						.byte 6, IM+NN
>ce07	13 ce				                .word nt_asm_eor_zxi
>ce09	35 aa 3a aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce0d	65 6f 72 2e 7a 78				.text "eor.zx"
.ce13					nt_asm_eor_zxi:
>ce13	07 0c						.byte 7, IM+NN
>ce15	22 ce				                .word nt_asm_inc
>ce17	3a aa 3f aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce1b	65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce22					nt_asm_inc:
>ce22	03 0c						.byte 3, IM+NN
>ce24	2d ce				                .word nt_asm_inc_a
>ce26	3f aa 44 aa					.word xt_asm_inc, z_asm_inc
>ce2a	69 6e 63					.text "inc"
.ce2d					nt_asm_inc_a:
>ce2d	05 0c						.byte 5, IM+NN
>ce2f	3a ce				                .word nt_asm_inc_x
>ce31	44 aa 49 aa					.word xt_asm_inc_a, z_asm_inc_a
>ce35	69 6e 63 2e 61					.text "inc.a"
.ce3a					nt_asm_inc_x:
>ce3a	05 0c						.byte 5, IM+NN
>ce3c	47 ce				                .word nt_asm_inc_z
>ce3e	49 aa 4e aa					.word xt_asm_inc_x, z_asm_inc_x
>ce42	69 6e 63 2e 78					.text "inc.x"
.ce47					nt_asm_inc_z:
>ce47	05 0c						.byte 5, IM+NN
>ce49	54 ce				                .word nt_asm_inc_zx
>ce4b	4e aa 53 aa					.word xt_asm_inc_z, z_asm_inc_z
>ce4f	69 6e 63 2e 7a					.text "inc.z"
.ce54					nt_asm_inc_zx:
>ce54	06 0c						.byte 6, IM+NN
>ce56	62 ce				                .word nt_asm_inx
>ce58	53 aa 58 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>ce5c	69 6e 63 2e 7a 78				.text "inc.zx"
.ce62					nt_asm_inx:
>ce62	03 0c						.byte 3, IM+NN
>ce64	6d ce				                .word nt_asm_iny
>ce66	58 aa 5d aa					.word xt_asm_inx, z_asm_inx
>ce6a	69 6e 78					.text "inx"
.ce6d					nt_asm_iny:
>ce6d	03 0c						.byte 3, IM+NN
>ce6f	78 ce				                .word nt_asm_jmp
>ce71	5d aa 62 aa					.word xt_asm_iny, z_asm_iny
>ce75	69 6e 79					.text "iny"
.ce78					nt_asm_jmp:
>ce78	03 0c						.byte 3, IM+NN
>ce7a	83 ce				                .word nt_asm_jmp_i
>ce7c	62 aa 67 aa					.word xt_asm_jmp, z_asm_jmp
>ce80	6a 6d 70					.text "jmp"
.ce83					nt_asm_jmp_i:
>ce83	05 0c						.byte 5, IM+NN
>ce85	90 ce				                .word nt_asm_jmp_xi
>ce87	67 aa 6c aa					.word xt_asm_jmp_i, z_asm_jmp_i
>ce8b	6a 6d 70 2e 69					.text "jmp.i"
.ce90					nt_asm_jmp_xi:
>ce90	06 0c						.byte 6, IM+NN
>ce92	9e ce				                .word nt_asm_jsr
>ce94	6c aa 71 aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>ce98	6a 6d 70 2e 78 69				.text "jmp.xi"
.ce9e					nt_asm_jsr:
>ce9e	03 0c						.byte 3, IM+NN
>cea0	a9 ce				                .word nt_asm_lda
>cea2	71 aa 76 aa					.word xt_asm_jsr, z_asm_jsr
>cea6	6a 73 72					.text "jsr"
.cea9					nt_asm_lda:
>cea9	03 0c						.byte 3, IM+NN
>ceab	b4 ce				                .word nt_asm_lda_h
>cead	76 aa 7b aa					.word xt_asm_lda, z_asm_lda
>ceb1	6c 64 61					.text "lda"
.ceb4					nt_asm_lda_h:
>ceb4	05 0c						.byte 5, IM+NN
>ceb6	c1 ce				                .word nt_asm_lda_x
>ceb8	7b aa 80 aa					.word xt_asm_lda_h, z_asm_lda_h
>cebc	6c 64 61 2e 23					.text "lda.#"
.cec1					nt_asm_lda_x:
>cec1	05 0c						.byte 5, IM+NN
>cec3	ce ce				                .word nt_asm_lda_y
>cec5	80 aa 85 aa					.word xt_asm_lda_x, z_asm_lda_x
>cec9	6c 64 61 2e 78					.text "lda.x"
.cece					nt_asm_lda_y:
>cece	05 0c						.byte 5, IM+NN
>ced0	db ce				                .word nt_asm_lda_z
>ced2	85 aa 8a aa					.word xt_asm_lda_y, z_asm_lda_y
>ced6	6c 64 61 2e 79					.text "lda.y"
.cedb					nt_asm_lda_z:
>cedb	05 0c						.byte 5, IM+NN
>cedd	e8 ce				                .word nt_asm_lda_zi
>cedf	8a aa 8f aa					.word xt_asm_lda_z, z_asm_lda_z
>cee3	6c 64 61 2e 7a					.text "lda.z"
.cee8					nt_asm_lda_zi:
>cee8	06 0c						.byte 6, IM+NN
>ceea	f6 ce				                .word nt_asm_lda_ziy
>ceec	8f aa 94 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cef0	6c 64 61 2e 7a 69				.text "lda.zi"
.cef6					nt_asm_lda_ziy:
>cef6	07 0c						.byte 7, IM+NN
>cef8	05 cf				                .word nt_asm_lda_zx
>cefa	94 aa 99 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cefe	6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf05					nt_asm_lda_zx:
>cf05	06 0c						.byte 6, IM+NN
>cf07	13 cf				                .word nt_asm_lda_zxi
>cf09	99 aa 9e aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cf0d	6c 64 61 2e 7a 78				.text "lda.zx"
.cf13					nt_asm_lda_zxi:
>cf13	07 0c						.byte 7, IM+NN
>cf15	22 cf				                .word nt_asm_ldx
>cf17	9e aa a3 aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf1b	6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf22					nt_asm_ldx:
>cf22	03 0c						.byte 3, IM+NN
>cf24	2d cf				                .word nt_asm_ldx_h
>cf26	a3 aa a8 aa					.word xt_asm_ldx, z_asm_ldx
>cf2a	6c 64 78					.text "ldx"
.cf2d					nt_asm_ldx_h:
>cf2d	05 0c						.byte 5, IM+NN
>cf2f	3a cf				                .word nt_asm_ldx_y
>cf31	a8 aa ad aa					.word xt_asm_ldx_h, z_asm_ldx_h
>cf35	6c 64 78 2e 23					.text "ldx.#"
.cf3a					nt_asm_ldx_y:
>cf3a	05 0c						.byte 5, IM+NN
>cf3c	47 cf				                .word nt_asm_ldx_z
>cf3e	ad aa b2 aa					.word xt_asm_ldx_y, z_asm_ldx_y
>cf42	6c 64 78 2e 79					.text "ldx.y"
.cf47					nt_asm_ldx_z:
>cf47	05 0c						.byte 5, IM+NN
>cf49	54 cf				                .word nt_asm_ldx_zy
>cf4b	b2 aa b7 aa					.word xt_asm_ldx_z, z_asm_ldx_z
>cf4f	6c 64 78 2e 7a					.text "ldx.z"
.cf54					nt_asm_ldx_zy:
>cf54	06 0c						.byte 6, IM+NN
>cf56	62 cf				                .word nt_asm_ldy
>cf58	b7 aa bc aa					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cf5c	6c 64 78 2e 7a 79				.text "ldx.zy"
.cf62					nt_asm_ldy:
>cf62	03 0c						.byte 3, IM+NN
>cf64	6d cf				                .word nt_asm_ldy_h
>cf66	bc aa c1 aa					.word xt_asm_ldy, z_asm_ldy
>cf6a	6c 64 79					.text "ldy"
.cf6d					nt_asm_ldy_h:
>cf6d	05 0c						.byte 5, IM+NN
>cf6f	7a cf				                .word nt_asm_ldy_x
>cf71	c1 aa c6 aa					.word xt_asm_ldy_h, z_asm_ldy_h
>cf75	6c 64 79 2e 23					.text "ldy.#"
.cf7a					nt_asm_ldy_x:
>cf7a	05 0c						.byte 5, IM+NN
>cf7c	87 cf				                .word nt_asm_ldy_z
>cf7e	c6 aa cb aa					.word xt_asm_ldy_x, z_asm_ldy_x
>cf82	6c 64 79 2e 78					.text "ldy.x"
.cf87					nt_asm_ldy_z:
>cf87	05 0c						.byte 5, IM+NN
>cf89	94 cf				                .word nt_asm_ldy_zx
>cf8b	cb aa d0 aa					.word xt_asm_ldy_z, z_asm_ldy_z
>cf8f	6c 64 79 2e 7a					.text "ldy.z"
.cf94					nt_asm_ldy_zx:
>cf94	06 0c						.byte 6, IM+NN
>cf96	a2 cf				                .word nt_asm_lsr
>cf98	d0 aa d5 aa					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cf9c	6c 64 79 2e 7a 78				.text "ldy.zx"
.cfa2					nt_asm_lsr:
>cfa2	03 0c						.byte 3, IM+NN
>cfa4	ad cf				                .word nt_asm_lsr_a
>cfa6	d5 aa da aa					.word xt_asm_lsr, z_asm_lsr
>cfaa	6c 73 72					.text "lsr"
.cfad					nt_asm_lsr_a:
>cfad	05 0c						.byte 5, IM+NN
>cfaf	ba cf				                .word nt_asm_lsr_x
>cfb1	da aa df aa					.word xt_asm_lsr_a, z_asm_lsr_a
>cfb5	6c 73 72 2e 61					.text "lsr.a"
.cfba					nt_asm_lsr_x:
>cfba	05 0c						.byte 5, IM+NN
>cfbc	c7 cf				                .word nt_asm_lsr_z
>cfbe	df aa e4 aa					.word xt_asm_lsr_x, z_asm_lsr_x
>cfc2	6c 73 72 2e 78					.text "lsr.x"
.cfc7					nt_asm_lsr_z:
>cfc7	05 0c						.byte 5, IM+NN
>cfc9	d4 cf				                .word nt_asm_lsr_zx
>cfcb	e4 aa e9 aa					.word xt_asm_lsr_z, z_asm_lsr_z
>cfcf	6c 73 72 2e 7a					.text "lsr.z"
.cfd4					nt_asm_lsr_zx:
>cfd4	06 0c						.byte 6, IM+NN
>cfd6	e2 cf				                .word nt_asm_nop
>cfd8	e9 aa ee aa					.word xt_asm_lsr_zx, z_asm_lsr_zx
>cfdc	6c 73 72 2e 7a 78				.text "lsr.zx"
.cfe2					nt_asm_nop:
>cfe2	03 0c						.byte 3, IM+NN
>cfe4	ed cf				                .word nt_asm_ora
>cfe6	ee aa f3 aa					.word xt_asm_nop, z_asm_nop
>cfea	6e 6f 70					.text "nop"
.cfed					nt_asm_ora:
>cfed	03 0c						.byte 3, IM+NN
>cfef	f8 cf				                .word nt_asm_ora_h
>cff1	f3 aa f8 aa					.word xt_asm_ora, z_asm_ora
>cff5	6f 72 61					.text "ora"
.cff8					nt_asm_ora_h:
>cff8	05 0c						.byte 5, IM+NN
>cffa	05 d0				                .word nt_asm_ora_x
>cffc	f8 aa fd aa					.word xt_asm_ora_h, z_asm_ora_h
>d000	6f 72 61 2e 23					.text "ora.#"
.d005					nt_asm_ora_x:
>d005	05 0c						.byte 5, IM+NN
>d007	12 d0				                .word nt_asm_ora_y
>d009	fd aa 02 ab					.word xt_asm_ora_x, z_asm_ora_x
>d00d	6f 72 61 2e 78					.text "ora.x"
.d012					nt_asm_ora_y:
>d012	05 0c						.byte 5, IM+NN
>d014	1f d0				                .word nt_asm_ora_z
>d016	02 ab 07 ab					.word xt_asm_ora_y, z_asm_ora_y
>d01a	6f 72 61 2e 79					.text "ora.y"
.d01f					nt_asm_ora_z:
>d01f	05 0c						.byte 5, IM+NN
>d021	2c d0				                .word nt_asm_ora_zi
>d023	07 ab 0c ab					.word xt_asm_ora_z, z_asm_ora_z
>d027	6f 72 61 2e 7a					.text "ora.z"
.d02c					nt_asm_ora_zi:
>d02c	06 0c						.byte 6, IM+NN
>d02e	3a d0				                .word nt_asm_ora_ziy
>d030	0c ab 13 ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d034	6f 72 61 2e 7a 69				.text "ora.zi"
.d03a					nt_asm_ora_ziy:
>d03a	07 0c						.byte 7, IM+NN
>d03c	49 d0				                .word nt_asm_ora_zx
>d03e	13 ab 18 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d042	6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d049					nt_asm_ora_zx:
>d049	06 0c						.byte 6, IM+NN
>d04b	57 d0				                .word nt_asm_ora_zxi
>d04d	18 ab 1d ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d051	6f 72 61 2e 7a 78				.text "ora.zx"
.d057					nt_asm_ora_zxi:
>d057	07 0c						.byte 7, IM+NN
>d059	66 d0				                .word nt_asm_pha
>d05b	1d ab 22 ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d05f	6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d066					nt_asm_pha:
>d066	03 0c						.byte 3, IM+NN
>d068	71 d0				                .word nt_asm_php
>d06a	22 ab 27 ab					.word xt_asm_pha, z_asm_pha
>d06e	70 68 61					.text "pha"
.d071					nt_asm_php:
>d071	03 0c						.byte 3, IM+NN
>d073	7c d0				                .word nt_asm_phx
>d075	27 ab 2c ab					.word xt_asm_php, z_asm_php
>d079	70 68 70					.text "php"
.d07c					nt_asm_phx:
>d07c	03 0c						.byte 3, IM+NN
>d07e	87 d0				                .word nt_asm_phy
>d080	2c ab 31 ab					.word xt_asm_phx, z_asm_phx
>d084	70 68 78					.text "phx"
.d087					nt_asm_phy:
>d087	03 0c						.byte 3, IM+NN
>d089	92 d0				                .word nt_asm_pla
>d08b	31 ab 36 ab					.word xt_asm_phy, z_asm_phy
>d08f	70 68 79					.text "phy"
.d092					nt_asm_pla:
>d092	03 0c						.byte 3, IM+NN
>d094	9d d0				                .word nt_asm_plp
>d096	36 ab 3b ab					.word xt_asm_pla, z_asm_pla
>d09a	70 6c 61					.text "pla"
.d09d					nt_asm_plp:
>d09d	03 0c						.byte 3, IM+NN
>d09f	a8 d0				                .word nt_asm_plx
>d0a1	3b ab 40 ab					.word xt_asm_plp, z_asm_plp
>d0a5	70 6c 70					.text "plp"
.d0a8					nt_asm_plx:
>d0a8	03 0c						.byte 3, IM+NN
>d0aa	b3 d0				                .word nt_asm_ply
>d0ac	40 ab 45 ab					.word xt_asm_plx, z_asm_plx
>d0b0	70 6c 78					.text "plx"
.d0b3					nt_asm_ply:
>d0b3	03 0c						.byte 3, IM+NN
>d0b5	be d0				                .word nt_asm_rol
>d0b7	45 ab 4a ab					.word xt_asm_ply, z_asm_ply
>d0bb	70 6c 79					.text "ply"
.d0be					nt_asm_rol:
>d0be	03 0c						.byte 3, IM+NN
>d0c0	c9 d0				                .word nt_asm_rol_a
>d0c2	4a ab 4f ab					.word xt_asm_rol, z_asm_rol
>d0c6	72 6f 6c					.text "rol"
.d0c9					nt_asm_rol_a:
>d0c9	05 0c						.byte 5, IM+NN
>d0cb	d6 d0				                .word nt_asm_rol_x
>d0cd	4f ab 54 ab					.word xt_asm_rol_a, z_asm_rol_a
>d0d1	72 6f 6c 2e 61					.text "rol.a"
.d0d6					nt_asm_rol_x:
>d0d6	05 0c						.byte 5, IM+NN
>d0d8	e3 d0				                .word nt_asm_rol_z
>d0da	54 ab 59 ab					.word xt_asm_rol_x, z_asm_rol_x
>d0de	72 6f 6c 2e 78					.text "rol.x"
.d0e3					nt_asm_rol_z:
>d0e3	05 0c						.byte 5, IM+NN
>d0e5	f0 d0				                .word nt_asm_rol_zx
>d0e7	59 ab 5e ab					.word xt_asm_rol_z, z_asm_rol_z
>d0eb	72 6f 6c 2e 7a					.text "rol.z"
.d0f0					nt_asm_rol_zx:
>d0f0	06 0c						.byte 6, IM+NN
>d0f2	fe d0				                .word nt_asm_ror
>d0f4	5e ab 63 ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d0f8	72 6f 6c 2e 7a 78				.text "rol.zx"
.d0fe					nt_asm_ror:
>d0fe	03 0c						.byte 3, IM+NN
>d100	09 d1				                .word nt_asm_ror_a
>d102	63 ab 68 ab					.word xt_asm_ror, z_asm_ror
>d106	72 6f 72					.text "ror"
.d109					nt_asm_ror_a:
>d109	05 0c						.byte 5, IM+NN
>d10b	16 d1				                .word nt_asm_ror_x
>d10d	68 ab 6d ab					.word xt_asm_ror_a, z_asm_ror_a
>d111	72 6f 72 2e 61					.text "ror.a"
.d116					nt_asm_ror_x:
>d116	05 0c						.byte 5, IM+NN
>d118	23 d1				                .word nt_asm_ror_z
>d11a	6d ab 72 ab					.word xt_asm_ror_x, z_asm_ror_x
>d11e	72 6f 72 2e 78					.text "ror.x"
.d123					nt_asm_ror_z:
>d123	05 0c						.byte 5, IM+NN
>d125	30 d1				                .word nt_asm_ror_zx
>d127	72 ab 77 ab					.word xt_asm_ror_z, z_asm_ror_z
>d12b	72 6f 72 2e 7a					.text "ror.z"
.d130					nt_asm_ror_zx:
>d130	06 0c						.byte 6, IM+NN
>d132	3e d1				                .word nt_asm_rti
>d134	77 ab 7c ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d138	72 6f 72 2e 7a 78				.text "ror.zx"
.d13e					nt_asm_rti:
>d13e	03 0c						.byte 3, IM+NN
>d140	49 d1				                .word nt_asm_rts
>d142	7c ab 81 ab					.word xt_asm_rti, z_asm_rti
>d146	72 74 69					.text "rti"
.d149					nt_asm_rts:
>d149	03 0c						.byte 3, IM+NN
>d14b	54 d1				                .word nt_asm_sbc
>d14d	81 ab 86 ab					.word xt_asm_rts, z_asm_rts
>d151	72 74 73					.text "rts"
.d154					nt_asm_sbc:
>d154	03 0c						.byte 3, IM+NN
>d156	5f d1				                .word nt_asm_sbc_h
>d158	86 ab 8b ab					.word xt_asm_sbc, z_asm_sbc
>d15c	73 62 63					.text "sbc"
.d15f					nt_asm_sbc_h:
>d15f	05 0c						.byte 5, IM+NN
>d161	6c d1				                .word nt_asm_sbc_x
>d163	8b ab 90 ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d167	73 62 63 2e 23					.text "sbc.#"
.d16c					nt_asm_sbc_x:
>d16c	05 0c						.byte 5, IM+NN
>d16e	79 d1				                .word nt_asm_sbc_y
>d170	90 ab 95 ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d174	73 62 63 2e 78					.text "sbc.x"
.d179					nt_asm_sbc_y:
>d179	05 0c						.byte 5, IM+NN
>d17b	86 d1				                .word nt_asm_sbc_z
>d17d	95 ab 9a ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d181	73 62 63 2e 79					.text "sbc.y"
.d186					nt_asm_sbc_z:
>d186	05 0c						.byte 5, IM+NN
>d188	93 d1				                .word nt_asm_sbc_zi
>d18a	9a ab 9f ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d18e	73 62 63 2e 7a					.text "sbc.z"
.d193					nt_asm_sbc_zi:
>d193	06 0c						.byte 6, IM+NN
>d195	a1 d1				                .word nt_asm_sbc_ziy
>d197	9f ab a4 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d19b	73 62 63 2e 7a 69				.text "sbc.zi"
.d1a1					nt_asm_sbc_ziy:
>d1a1	07 0c						.byte 7, IM+NN
>d1a3	b0 d1				                .word nt_asm_sbc_zx
>d1a5	a4 ab a9 ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d1a9	73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d1b0					nt_asm_sbc_zx:
>d1b0	06 0c						.byte 6, IM+NN
>d1b2	be d1				                .word nt_asm_sbc_zxi
>d1b4	a9 ab ae ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d1b8	73 62 63 2e 7a 78				.text "sbc.zx"
.d1be					nt_asm_sbc_zxi:
>d1be	07 0c						.byte 7, IM+NN
>d1c0	cd d1				                .word nt_asm_sec
>d1c2	ae ab b2 ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d1c6	73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d1cd					nt_asm_sec:
>d1cd	03 0c						.byte 3, IM+NN
>d1cf	d8 d1				                .word nt_asm_sed
>d1d1	b2 ab b6 ab					.word xt_asm_sec, z_asm_sec
>d1d5	73 65 63					.text "sec"
.d1d8					nt_asm_sed:
>d1d8	03 0c						.byte 3, IM+NN
>d1da	e3 d1				                .word nt_asm_sei
>d1dc	b6 ab ba ab					.word xt_asm_sed, z_asm_sed
>d1e0	73 65 64					.text "sed"
.d1e3					nt_asm_sei:
>d1e3	03 0c						.byte 3, IM+NN
>d1e5	ee d1				                .word nt_asm_sta
>d1e7	ba ab be ab					.word xt_asm_sei, z_asm_sei
>d1eb	73 65 69					.text "sei"
.d1ee					nt_asm_sta:
>d1ee	03 0c						.byte 3, IM+NN
>d1f0	f9 d1				                .word nt_asm_sta_x
>d1f2	be ab c2 ab					.word xt_asm_sta, z_asm_sta
>d1f6	73 74 61					.text "sta"
.d1f9					nt_asm_sta_x:
>d1f9	05 0c						.byte 5, IM+NN
>d1fb	06 d2				                .word nt_asm_sta_y
>d1fd	c2 ab c6 ab					.word xt_asm_sta_x, z_asm_sta_x
>d201	73 74 61 2e 78					.text "sta.x"
.d206					nt_asm_sta_y:
>d206	05 0c						.byte 5, IM+NN
>d208	13 d2				                .word nt_asm_sta_z
>d20a	c6 ab ca ab					.word xt_asm_sta_y, z_asm_sta_y
>d20e	73 74 61 2e 79					.text "sta.y"
.d213					nt_asm_sta_z:
>d213	05 0c						.byte 5, IM+NN
>d215	20 d2				                .word nt_asm_sta_zi
>d217	ca ab ce ab					.word xt_asm_sta_z, z_asm_sta_z
>d21b	73 74 61 2e 7a					.text "sta.z"
.d220					nt_asm_sta_zi:
>d220	06 0c						.byte 6, IM+NN
>d222	2e d2				                .word nt_asm_sta_ziy
>d224	ce ab d2 ab					.word xt_asm_sta_zi, z_asm_sta_zi
>d228	73 74 61 2e 7a 69				.text "sta.zi"
.d22e					nt_asm_sta_ziy:
>d22e	07 0c						.byte 7, IM+NN
>d230	3d d2				                .word nt_asm_sta_zx
>d232	d2 ab d6 ab					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d236	73 74 61 2e 7a 69 79				.text "sta.ziy"
.d23d					nt_asm_sta_zx:
>d23d	06 0c						.byte 6, IM+NN
>d23f	4b d2				                .word nt_asm_sta_zxi
>d241	d6 ab da ab					.word xt_asm_sta_zx, z_asm_sta_zx
>d245	73 74 61 2e 7a 78				.text "sta.zx"
.d24b					nt_asm_sta_zxi:
>d24b	07 0c						.byte 7, IM+NN
>d24d	5a d2				                .word nt_asm_stx
>d24f	da ab de ab					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d253	73 74 61 2e 7a 78 69				.text "sta.zxi"
.d25a					nt_asm_stx:
>d25a	03 0c						.byte 3, IM+NN
>d25c	65 d2				                .word nt_asm_stx_z
>d25e	de ab e2 ab					.word xt_asm_stx, z_asm_stx
>d262	73 74 78					.text "stx"
.d265					nt_asm_stx_z:
>d265	05 0c						.byte 5, IM+NN
>d267	72 d2				                .word nt_asm_stx_zy
>d269	e2 ab e6 ab					.word xt_asm_stx_z, z_asm_stx_z
>d26d	73 74 78 2e 7a					.text "stx.z"
.d272					nt_asm_stx_zy:
>d272	06 0c						.byte 6, IM+NN
>d274	80 d2				                .word nt_asm_sty
>d276	e6 ab ea ab					.word xt_asm_stx_zy, z_asm_stx_zy
>d27a	73 74 78 2e 7a 79				.text "stx.zy"
.d280					nt_asm_sty:
>d280	03 0c						.byte 3, IM+NN
>d282	8b d2				                .word nt_asm_sty_z
>d284	ea ab ee ab					.word xt_asm_sty, z_asm_sty
>d288	73 74 79					.text "sty"
.d28b					nt_asm_sty_z:
>d28b	05 0c						.byte 5, IM+NN
>d28d	98 d2				                .word nt_asm_sty_zx
>d28f	ee ab f2 ab					.word xt_asm_sty_z, z_asm_sty_z
>d293	73 74 79 2e 7a					.text "sty.z"
.d298					nt_asm_sty_zx:
>d298	06 0c						.byte 6, IM+NN
>d29a	a6 d2				                .word nt_asm_stz
>d29c	f2 ab f6 ab					.word xt_asm_sty_zx, z_asm_sty_zx
>d2a0	73 74 79 2e 7a 78				.text "sty.zx"
.d2a6					nt_asm_stz:
>d2a6	03 0c						.byte 3, IM+NN
>d2a8	b1 d2				                .word nt_asm_stz_x
>d2aa	f6 ab fa ab					.word xt_asm_stz, z_asm_stz
>d2ae	73 74 7a					.text "stz"
.d2b1					nt_asm_stz_x:
>d2b1	05 0c						.byte 5, IM+NN
>d2b3	be d2				                .word nt_asm_stz_z
>d2b5	fa ab fe ab					.word xt_asm_stz_x, z_asm_stz_x
>d2b9	73 74 7a 2e 78					.text "stz.x"
.d2be					nt_asm_stz_z:
>d2be	05 0c						.byte 5, IM+NN
>d2c0	cb d2				                .word nt_asm_stz_zx
>d2c2	fe ab 02 ac					.word xt_asm_stz_z, z_asm_stz_z
>d2c6	73 74 7a 2e 7a					.text "stz.z"
.d2cb					nt_asm_stz_zx:
>d2cb	06 0c						.byte 6, IM+NN
>d2cd	d9 d2				                .word nt_asm_tax
>d2cf	02 ac 06 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d2d3	73 74 7a 2e 7a 78				.text "stz.zx"
.d2d9					nt_asm_tax:
>d2d9	03 0c						.byte 3, IM+NN
>d2db	e4 d2				                .word nt_asm_tay
>d2dd	06 ac 0a ac					.word xt_asm_tax, z_asm_tax
>d2e1	74 61 78					.text "tax"
.d2e4					nt_asm_tay:
>d2e4	03 0c						.byte 3, IM+NN
>d2e6	ef d2				                .word nt_asm_trb
>d2e8	0a ac 0e ac					.word xt_asm_tay, z_asm_tay
>d2ec	74 61 79					.text "tay"
.d2ef					nt_asm_trb:
>d2ef	03 0c						.byte 3, IM+NN
>d2f1	fa d2				                .word nt_asm_trb_z
>d2f3	0e ac 12 ac					.word xt_asm_trb, z_asm_trb
>d2f7	74 72 62					.text "trb"
.d2fa					nt_asm_trb_z:
>d2fa	05 0c						.byte 5, IM+NN
>d2fc	07 d3				                .word nt_asm_tsb
>d2fe	12 ac 16 ac					.word xt_asm_trb_z, z_asm_trb_z
>d302	74 72 62 2e 7a					.text "trb.z"
.d307					nt_asm_tsb:
>d307	03 0c						.byte 3, IM+NN
>d309	12 d3				                .word nt_asm_tsb_z
>d30b	16 ac 1a ac					.word xt_asm_tsb, z_asm_tsb
>d30f	74 73 62					.text "tsb"
.d312					nt_asm_tsb_z:
>d312	05 0c						.byte 5, IM+NN
>d314	1f d3				                .word nt_asm_tsx
>d316	1a ac 1e ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d31a	74 73 62 2e 7a					.text "tsb.z"
.d31f					nt_asm_tsx:
>d31f	03 0c						.byte 3, IM+NN
>d321	2a d3				                .word nt_asm_txa
>d323	1e ac 22 ac					.word xt_asm_tsx, z_asm_tsx
>d327	74 73 78					.text "tsx"
.d32a					nt_asm_txa:
>d32a	03 0c						.byte 3, IM+NN
>d32c	35 d3				                .word nt_asm_txs
>d32e	22 ac 26 ac					.word xt_asm_txa, z_asm_txa
>d332	74 78 61					.text "txa"
.d335					nt_asm_txs:
>d335	03 0c						.byte 3, IM+NN
>d337	40 d3				                .word nt_asm_tya
>d339	26 ac 2a ac					.word xt_asm_txs, z_asm_txs
>d33d	74 78 73					.text "txs"
.d340					nt_asm_tya:
>d340	03 0c						.byte 3, IM+NN
>d342	4b d3				                .word nt_asm_arrow
>d344	2a ac 2e ac					.word xt_asm_tya, z_asm_tya
>d348	74 79 61					.text "tya"
.d34b					nt_asm_arrow:
>d34b	03 04				                .byte 3, IM
>d34d	56 d3				                .word nt_asm_back_jump
>d34f	53 91 5d 91			                .word xt_asm_arrow, z_asm_arrow
>d353	2d 2d 3e			                .text "-->"
.d356					nt_asm_back_jump:
>d356	02 04				                .byte 2, IM
>d358	60 d3				                .word nt_asm_back_branch
>d35a	7f ac 7f ac			                .word xt_asm_back_jump, z_asm_back_jump
>d35e	3c 6a				                .text "<j"
.d360					nt_asm_back_branch:
>d360	02 04				                .byte 2, IM
>d362	6a d3				                .word nt_asm_push_a
>d364	80 ac 88 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d368	3c 62				                .text "<b"
.d36a					nt_asm_push_a:
>d36a	06 0c				                .byte 6, IM+NN
>d36c	00 00				                .word 0000
>d36e	68 ac 77 ac			                .word xt_asm_push_a, z_asm_push_a
>d372	70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0					str_ok             =  0
=1					str_compile        =  1
=2					str_redefined      =  2
=3					str_wid_forth      =  3
=4					str_abc_lower      =  4
=5					str_abc_upper      =  5
=6					str_wid_editor     =  6
=7					str_wid_assembler  =  7
=8					str_wid_root       =  8
=9					str_see_flags      =  9
=10					str_see_nt         = 10
=11					str_see_xt         = 11
=12					str_see_size       = 12
=13					str_disasm_lit     = 13
=14					str_disasm_sdc     = 14
=15					str_disasm_bra     = 15
.d378					string_table:
>d378	98 d3 9c d3 a6 d3 0c d4		        .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
>d380	b1 d3
>d382	d5 d3 04 d4 f9 d3 13 d4		        .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
>d38a	19 d4 35 d4 3a d4 3f d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
>d392	50 d4 59 d4 6b d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 13-15
>d398	20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d39c	20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d3a4	64 00
>d3a6	72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d3ae	64 20 00
>d3b1	30 31 32 33 34 35 36 37		s_abc_lower:  .text "0123456789abcdefghijklmnopqrstuvwxyz"
>d3b9	38 39 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e
>d3c9	6f 70 71 72 73 74 75 76 77 78 79 7a
>d3d5	30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d3dd	38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d3ed	4f 50 51 52 53 54 55 56 57 58 59 5a
>d3f9	41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d401	72 20 00
>d404	45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d40c	46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d413	52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d419	66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d421	4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d431	29 3a 20 00
>d435	6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d43a	78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d43f	73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d447	63 69 6d 61 6c 29 3a 20 00
>d450	4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d458	00
>d459	53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d461	50 54 48 20 43 48 45 43 4b 00
>d46b	42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0					err_allot        = 0
=1					err_badsource    = 1
=2					err_compileonly  = 2
=3					err_defer        = 3
=4					err_divzero      = 4
=5					err_noname       = 5
=6					err_refill       = 6
=7					err_state        = 7
=8					err_syntax       = 8
=9					err_underflow    = 9
=10					err_negallot     = 10
=11					err_wordlist     = 11
=12					err_blockwords   = 12
=13					err_returnstack  = 13
.d473					error_table:
>d473	8f d4 b0 d4 d0 d4 f1 d4		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d47b	0e d5 1f d5 2f d5 5d d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d483	75 d5 84 d5 99 d5 b5 d5		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d48b	cc d5 0b d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d48f	41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d497	69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d4a7	65 20 6d 65 6d 6f 72 79 00
>d4b0	49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d4b8	53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d4c8	20 52 45 46 49 4c 4c 00
>d4d0	49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d4d8	74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d4e8	6e 6c 79 20 77 6f 72 64 00
>d4f1	44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d4f9	77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d509	20 79 65 74 00
>d50e	44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d516	20 62 79 20 7a 65 72 6f 00
>d51f	50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d527	66 61 69 6c 75 72 65 00
>d52f	51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d537	6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d547	20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d557	64 20 2d 31 29 00
>d55d	41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d565	69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d575	55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word", 0
>d57d	64 20 77 6f 72 64 00
>d584	44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d58c	63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d599	4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d5a1	72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d5b1	4c 4f 54 00
>d5b5	4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d5bd	69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d5cc	50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d5d4	73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d5e4	4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d5f4	61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d604	56 45 43 54 4f 52 00
>d60b	52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d613	74 61 63 6b 3a 00
>d619	0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d621	44 2d 53 54 52 49 4e 47
>d629	05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d62f	04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d634	11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d63c	2d 55 4e 49 54 2d 42 49 54 53
>d646	07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d64e	08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d656	52
>d657	05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d65d	05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d663	12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d66b	53 54 41 43 4b 2d 43 45 4c 4c 53
>d676	0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d67e	45 4c 4c 53
>d682	09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d68a	54 53
>d68c	05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d692	06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d699					cmpl_subroutine:
.d699	48		pha		                pha             ; save LSB of address
.d69a	a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d69c	80 03		bra $d6a1	                bra cmpl_common
.d69e					cmpl_jump:
.d69e	48		pha		                pha             ; save LSB of address
.d69f	a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d6a1					cmpl_common:
.d6a1	20 a9 d6	jsr $d6a9	                jsr cmpl_a      ; compile opcode
.d6a4	68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d6a5					cmpl_word:
.d6a5	20 a9 d6	jsr $d6a9	                jsr cmpl_a      ; compile LSB of address
.d6a8	98		tya		                tya             ; fall thru for MSB
.d6a9					cmpl_a:
.d6a9	92 00		sta ($00)	                sta (cp)
.d6ab	e6 00		inc $00		                inc cp
.d6ad	d0 02		bne $d6b1	                bne _done
.d6af	e6 01		inc $01		                inc cp+1
.d6b1					_done:
.d6b1	60		rts		                rts
.d6b2					doconst:
.d6b2	ca		dex		                dex             ; make room for constant
.d6b3	ca		dex		                dex
.d6b4	68		pla		                pla             ; LSB of return address
.d6b5	85 24		sta $24		                sta tmp1
.d6b7	68		pla		                pla             ; MSB of return address
.d6b8	85 25		sta $25		                sta tmp1+1
.d6ba	a0 01		ldy #$01	                ldy #1
.d6bc	b1 24		lda ($24),y	                lda (tmp1),y
.d6be	95 00		sta $00,x	                sta 0,x
.d6c0	c8		iny		                iny
.d6c1	b1 24		lda ($24),y	                lda (tmp1),y
.d6c3	95 01		sta $01,x	                sta 1,x
.d6c5	60		rts		                rts
.d6c6					dodefer:
.d6c6	68		pla		                pla             ; LSB
.d6c7	85 24		sta $24		                sta tmp1
.d6c9	68		pla		                pla             ; MSB
.d6ca	85 25		sta $25		                sta tmp1+1
.d6cc	a0 01		ldy #$01	                ldy #1
.d6ce	b1 24		lda ($24),y	                lda (tmp1),y
.d6d0	85 26		sta $26		                sta tmp2
.d6d2	c8		iny		                iny
.d6d3	b1 24		lda ($24),y	                lda (tmp1),y
.d6d5	85 27		sta $27		                sta tmp2+1
.d6d7	6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d6da					defer_error:
.d6da	a9 03		lda #$03	                lda #err_defer
.d6dc	4c 0c d8	jmp $d80c	                jmp error
.d6df					dodoes:
.d6df	7a		ply		                ply             ; LSB
.d6e0	68		pla		                pla             ; MSB
.d6e1	c8		iny		                iny
.d6e2	d0 01		bne $d6e5	                bne +
.d6e4	1a		inc a		                ina
.d6e5					+
.d6e5	84 26		sty $26		                sty tmp2
.d6e7	85 27		sta $27		                sta tmp2+1
.d6e9	ca		dex		                dex
.d6ea	ca		dex		                dex
.d6eb	7a		ply		                ply
.d6ec	68		pla		                pla
.d6ed	c8		iny		                iny
.d6ee	d0 01		bne $d6f1	                bne +
.d6f0	1a		inc a		                ina
.d6f1					+
.d6f1	94 00		sty $00,x	                sty 0,x         ; LSB
.d6f3	95 01		sta $01,x	                sta 1,x         ; MSB
.d6f5	6c 26 00	jmp ($0026)	                jmp (tmp2)
.d6f8					dovar:
.d6f8	7a		ply		                ply             ; LSB
.d6f9	68		pla		                pla             ; MSB
.d6fa	c8		iny		                iny
.d6fb	d0 01		bne $d6fe	                bne +
.d6fd	1a		inc a		                ina
.d6fe					+
.d6fe	ca		dex		                dex
.d6ff	ca		dex		                dex
.d700	95 01		sta $01,x	                sta 1,x
.d702	98		tya		                tya
.d703	95 00		sta $00,x	                sta 0,x
.d705	60		rts		                rts
.d706					byte_to_ascii:
.d706	48		pha		                pha
.d707	4a		lsr a		                lsr             ; convert high nibble first
.d708	4a		lsr a		                lsr
.d709	4a		lsr a		                lsr
.d70a	4a		lsr a		                lsr
.d70b	20 0f d7	jsr $d70f	                jsr _nibble_to_ascii
.d70e	68		pla		                pla
.d70f					_nibble_to_ascii:
.d70f	29 0f		and #$0f	                and #$0F
.d711	09 30		ora #$30	                ora #'0'
.d713	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d715	90 02		bcc $d719	                bcc +
.d717	69 06		adc #$06	                adc #$06
.d719	4c d7 8d	jmp $8dd7	+               jmp emit_a
.d71c	60		rts		                rts
.d71d					compare_16bit:
.d71d	b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d71f	d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d721	f0 0a		beq $d72d	                beq _equal
.d723	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d725	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d727	09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d729	70 08		bvs $d733	                bvs _overflow
.d72b	80 08		bra $d735	                bra _not_equal
.d72d					_equal:
.d72d	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d72f	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d731	50 04		bvc $d737	                bvc _done
.d733					_overflow:
.d733	49 80		eor #$80	                eor #$80                ; complement negative flag
.d735					_not_equal:
.d735	09 01		ora #$01	                ora #1                  ; if overflow, we can't be eqal
.d737					_done:
.d737	60		rts		                rts
.d738					current_to_dp:
.d738	a0 04		ldy #$04	                ldy #current_offset
.d73a	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d73c	0a		asl a		                asl             ; turn it into an offset (in cells)
.d73d	18		clc		                clc
.d73e	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d740	a8		tay		                tay
.d741	b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d743	85 02		sta $02		                sta dp
.d745	c8		iny		                iny
.d746	b1 1e		lda ($1e),y	                lda (up),y
.d748	85 03		sta $03		                sta dp+1
.d74a	60		rts		                rts
.d74b					dp_to_current:
.d74b	a0 04		ldy #$04	                ldy #current_offset
.d74d	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d74f	0a		asl a		                asl             ; turn it into an offset (in cells)
.d750	18		clc		                clc
.d751	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d753	a8		tay		                tay
.d754	a5 02		lda $02		                lda dp
.d756	91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d758	c8		iny		                iny
.d759	a5 03		lda $03		                lda dp+1
.d75b	91 1e		sta ($1e),y	                sta (up),y
.d75d	60		rts		                rts
.d75e					interpret:
.d75e					_loop:
.d75e	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( "string" -- addr u )
.d761	b5 00		lda $00,x	                lda 0,x
.d763	15 01		ora $01,x	                ora 1,x
.d765	f0 70		beq $d7d7	                beq _line_done
.d767	20 6a a3	jsr $a36a	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d76a	20 bc 8f	jsr $8fbc	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d76d	b5 00		lda $00,x	                lda 0,x
.d76f	15 01		ora $01,x	                ora 1,x
.d771	d0 28		bne $d79b	                bne _got_name_token
.d773	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d774	e8		inx		                inx
.d775	20 6b 96	jsr $966b	                jsr xt_number           ; ( addr u -- u|d )
.d778	a5 16		lda $16		                lda state
.d77a	f0 e2		beq $d75e	                beq _loop
.d77c	a9 20		lda #$20	                lda #$20
.d77e	24 20		bit $20		                bit status
.d780	f0 0d		beq $d78f	                beq _single_number
.d782	20 60 a1	jsr $a160	                jsr xt_swap
.d785	a0 93		ldy #$93	                ldy #>literal_runtime
.d787	a9 79		lda #$79	                lda #<literal_runtime
.d789	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.d78c	20 4f 87	jsr $874f	                jsr xt_comma
.d78f					_single_number:
.d78f	a0 93		ldy #$93	                ldy #>literal_runtime
.d791	a9 79		lda #$79	                lda #<literal_runtime
.d793	20 99 d6	jsr $d699	                jsr cmpl_subroutine
.d796	20 4f 87	jsr $874f	                jsr xt_comma
.d799	80 c3		bra $d75e	                bra _loop
.d79b					_got_name_token:
.d79b	b5 00		lda $00,x	                lda 0,x
.d79d	95 04		sta $04,x	                sta 4,x
.d79f	b5 01		lda $01,x	                lda 1,x
.d7a1	95 05		sta $05,x	                sta 5,x
.d7a3	e8		inx		                inx
.d7a4	e8		inx		                inx
.d7a5	e8		inx		                inx
.d7a6	e8		inx		                inx                     ; ( nt )
.d7a7	b5 00		lda $00,x	                lda 0,x
.d7a9	85 22		sta $22		                sta tmpbranch
.d7ab	b5 01		lda $01,x	                lda 1,x
.d7ad	85 23		sta $23		                sta tmpbranch+1
.d7af	20 c2 95	jsr $95c2	                jsr xt_name_to_int      ; ( nt - xt )
.d7b2	a5 16		lda $16		                lda state
.d7b4	d0 13		bne $d7c9	                bne _compile
.d7b6	a0 01		ldy #$01	                ldy #1
.d7b8	b1 22		lda ($22),y	                lda (tmpbranch),y
.d7ba	29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d7bc	f0 05		beq $d7c3	                beq _interpret
.d7be	a9 02		lda #$02	                lda #err_compileonly
.d7c0	4c 0c d8	jmp $d80c	                jmp error
.d7c3					_interpret:
.d7c3	20 1e 8f	jsr $8f1e	                jsr xt_execute
.d7c6	4c 5e d7	jmp $d75e	                jmp _loop
.d7c9					_compile:
.d7c9	a0 01		ldy #$01	                ldy #1
.d7cb	b1 22		lda ($22),y	                lda (tmpbranch),y
.d7cd	29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d7cf	d0 f2		bne $d7c3	                bne _interpret          ; IMMEDIATE word, execute right now
.d7d1	20 ce 87	jsr $87ce	                jsr xt_compile_comma
.d7d4	4c 5e d7	jmp $d75e	                jmp _loop
.d7d7					_line_done:
.d7d7	e8		inx		                inx
.d7d8	e8		inx		                inx
.d7d9	e8		inx		                inx
.d7da	e8		inx		                inx
.d7db	60		rts		                rts
.d7dc					is_printable:
.d7dc	c9 20		cmp #$20	                cmp #AscSP              ; $20
.d7de	90 08		bcc $d7e8	                bcc _done
.d7e0	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d7e2	b0 03		bcs $d7e7	                bcs _failed
.d7e4	38		sec		                sec
.d7e5	80 01		bra $d7e8	                bra _done
.d7e7					_failed:
.d7e7	18		clc		                clc
.d7e8					_done:
.d7e8	60		rts		                rts
.d7e9					is_whitespace:
.d7e9	c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d7eb	90 08		bcc $d7f5	                bcc _done
.d7ed	c9 21		cmp #$21	                cmp #AscSP+1
.d7ef	b0 03		bcs $d7f4	                bcs _failed
.d7f1	38		sec		                sec
.d7f2	80 01		bra $d7f5	                bra _done
.d7f4					_failed:
.d7f4	18		clc		                clc
.d7f5					_done:
.d7f5	60		rts		                rts
.d7f6					underflow_1:
.d7f6	e0 77		cpx #$77	                cpx #dsp0-1
.d7f8	10 10		bpl $d80a	                bpl underflow_error
.d7fa	60		rts		                rts
.d7fb					underflow_2:
.d7fb	e0 75		cpx #$75	                cpx #dsp0-3
.d7fd	10 0b		bpl $d80a	                bpl underflow_error
.d7ff	60		rts		                rts
.d800					underflow_3:
.d800	e0 73		cpx #$73	                cpx #dsp0-5
.d802	10 06		bpl $d80a	                bpl underflow_error
.d804	60		rts		                rts
.d805					underflow_4:
.d805	e0 71		cpx #$71	                cpx #dsp0-7
.d807	10 01		bpl $d80a	                bpl underflow_error
.d809	60		rts		                rts
.d80a					underflow_error:
.d80a	a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d80c					error:
.d80c	48		pha		                pha                     ; save error
.d80d	20 4c d8	jsr $d84c	                jsr print_error
.d810	20 44 89	jsr $8944	                jsr xt_cr
.d813	68		pla		                pla
.d814	c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d816	d0 17		bne $d82f	                bne _no_underflow
.d818	a9 0d		lda #$0d	                lda #err_returnstack
.d81a	20 4c d8	jsr $d84c	                jsr print_error
.d81d	ba		tsx		                tsx
.d81e					-
.d81e	e8		inx		                inx
.d81f	f0 0b		beq $d82c	                beq +
.d821	20 d0 a0	jsr $a0d0	                jsr xt_space
.d824	bd 00 01	lda $0100,x	                lda $100,x
.d827	20 06 d7	jsr $d706	                jsr byte_to_ascii
.d82a	80 f2		bra $d81e	                bra -
.d82c					+
.d82c	20 44 89	jsr $8944	                jsr xt_cr
.d82f					_no_underflow:
.d82f	4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d832					print_string_no_lf:
.d832	0a		asl a		                asl
.d833	a8		tay		                tay
.d834	b9 78 d3	lda $d378,y	                lda string_table,y
.d837	85 28		sta $28		                sta tmp3                ; LSB
.d839	c8		iny		                iny
.d83a	b9 78 d3	lda $d378,y	                lda string_table,y
.d83d	85 29		sta $29		                sta tmp3+1              ; MSB
.d83f					print_common:
.d83f	a0 00		ldy #$00	                ldy #0
.d841					_loop:
.d841	b1 28		lda ($28),y	                lda (tmp3),y
.d843	f0 06		beq $d84b	                beq _done               ; strings are zero-terminated
.d845	20 d7 8d	jsr $8dd7	                jsr emit_a              ; allows vectoring via output
.d848	c8		iny		                iny
.d849	80 f6		bra $d841	                bra _loop
.d84b					_done:
.d84b	60		rts		                rts
.d84c					print_error:
.d84c	0a		asl a		                asl
.d84d	a8		tay		                tay
.d84e	b9 73 d4	lda $d473,y	                lda error_table,y
.d851	85 28		sta $28		                sta tmp3                ; LSB
.d853	c8		iny		                iny
.d854	b9 73 d4	lda $d473,y	                lda error_table,y
.d857	85 29		sta $29		                sta tmp3+1              ; MSB
.d859	20 3f d8	jsr $d83f	                jsr print_common
.d85c	60		rts		                rts
.d85d					print_string:
.d85d	20 32 d8	jsr $d832	                jsr print_string_no_lf
.d860	4c 44 89	jmp $8944	                jmp xt_cr               ; JSR/RTS because never compiled
.d863					print_u:
.d863	20 5a a7	jsr $a75a	                jsr xt_zero                     ; 0
.d866	20 3b 93	jsr $933b	                jsr xt_less_number_sign         ; <#
.d869	20 bf 97	jsr $97bf	                jsr xt_number_sign_s            ; #S
.d86c	20 9d 97	jsr $979d	                jsr xt_number_sign_greater      ; #>
.d86f	4c b5 a4	jmp $a4b5	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp forth
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034	74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044	6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054	28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
