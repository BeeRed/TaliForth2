
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Thu Mar 14 20:51:26 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000					ram_start = $0000          ; start of installed 32 KiB of RAM
=32767					ram_end   = $8000-1        ; end of installed RAM
=$0000					zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f					zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100					stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744					hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000					user0     = zpage            ; TaliForth2 system variables
=$ff					rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff					bsize     = $ff              ; size of input/output buffers
=512					buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768					cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744					cp_end    = hist_buff        ; Last RAM byte available for code
=$ff					padoffset = $ff              ; offset from CP to PAD (holds number strings)
=					TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]
=["lf"]					TALI_OPTION_CR_EOL := [ "lf" ]

;******  Processing file: platform/../taliforth.asm

.8000					code0:

;******  Processing file: platform/../definitions.asm

=0					cp        = user0+0   ; Compiler Pointer
=2					dp        = user0+2   ; Dictionary Pointer
=4					workword  = user0+4   ; nt (not xt!) of word being compiled, except in
=6					insrc     = user0+6   ; input Source for SOURCE-ID
=8					cib       = user0+8   ; address of current input buffer
=10					ciblen    = user0+10  ; length of current input buffer
=12					toin      = user0+12  ; pointer to CIB (>IN in Forth)
=14					ip        = user0+14  ; Instruction Pointer (current xt)
=16					output    = user0+16  ; vector for EMIT
=18					input     = user0+18  ; vector for KEY
=20					havekey   = user0+20  ; vector for KEY?
=22					state     = user0+22  ; STATE: -1 compile, 0 interpret
=24					base      = user0+24  ; number radix, default decimal
=26					nc_limit  = user0+26  ; limit for Native Compile size
=28					uf_strip  = user0+28  ; flag to strip underflow detection code
=30					up        = user0+30  ; User Pointer (Address of user variables)
=32					status    = user0+32  ; internal status information
=34					tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
=36					tmp1      = user0+36  ; temporary storage
=38					tmp2      = user0+38  ; temporary storage
=40					tmp3      = user0+40  ; temporary storage (especially for print)
=42					tmpdsp    = user0+42  ; temporary DSP (X) storage (two bytes)
=44					tmptos    = user0+44  ; temporary TOS storage
=46					editor1   = user0+46  ; temporary for editors
=48					editor2   = user0+48  ; temporary for editors
=50					editor3   = user0+50  ; temporary for editors
=52					tohold    = user0+52  ; pointer for formatted output
=54					scratch   = user0+54  ; 8 byte scratchpad (see UM/MOD)
=120					dsp0      = zpage_end-7    ; initial Data Stack Pointer
=0					blk_offset = 0        ; BLK : UP + 0
=2					scr_offset = 2        ; SCR : UP + 2
=4					current_offset = 4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
=5					num_wordlists_offset = 5
=6					wordlists_offset = 6  ; WORDLISTS (cells) : UP + 6 to UP + 29
=30					num_order_offset = 30 ; #ORDER (byte) : UP + 30
=31					search_order_offset = 31
=12					max_wordlists = 12    ; Maximum number of wordlists supported
=40					blkbuffer_offset    = 40   ; Address of buffer
=42					buffblocknum_offset = 42   ; Block number current in buffer
=44					buffstatus_offset   = 44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
=46					blockread_offset    = 46   ; Vector to block reading routine
=48					blockwrite_offset   = 48   ; Vector to block writing routine
=$03					AscCC   = $03  ; break (CTRL-c)
=$07					AscBELL = $07  ; bell sound
=$08					AscBS   = $08  ; backspace
=$0a					AscLF   = $0a  ; line feed
=$0d					AscCR   = $0d  ; carriage return
=$1b					AscESC  = $1b  ; escape
=$20					AscSP   = $20  ; space
=$7f					AscDEL  = $7f  ; delete (CTRL-h)
=$10					AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e					AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1					CO = 1  ; Compile Only
=2					AN = 2  ; Always Native Compile
=4					IM = 4  ; Immediate Word
=8					NN = 8  ; Never Native Compile
=16					UF = 16 ; Includes Underflow Check (RESERVED)
=32					HC = 32 ; Word has Code Field Area (CFA)
=79					MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm

.8000					forth:

;******  Processing file: platform/../native_words.asm

.8000					xt_cold:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 10		sta $10		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 11		sta $11		                sta output+1
.8009	a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b					_load_zp_loop:
.800b	bd ce 80	lda $80ce,x	                lda cold_zp_table,x
.800e	95 00		sta $00,x	                sta zpage,x
.8010	ca		dex		                dex
.8011	d0 f8		bne $800b	                bne _load_zp_loop
.8013	ad ce 80	lda $80ce	                lda cold_zp_table
.8016	85 00		sta $00		                sta zpage
.8018	a2 ff		ldx #$ff	                ldx #rsp0
.801a	9a		txs		                txs
.801b	a2 78		ldx #$78	                ldx #dsp0
.801d	a0 31		ldy #$31	                ldy #cold_user_table_end-cold_user_table-1
.801f	a9 00		lda #$00	                lda #0
.8021					_load_user_vars_loop:
.8021	b9 f0 80	lda $80f0,y	                lda cold_user_table,y
.8024	91 1e		sta ($1e),y	                sta (up),y
.8026	88		dey		                dey
.8027	d0 f8		bne $8021	                bne _load_user_vars_loop
.8029	ad f0 80	lda $80f0	                lda cold_user_table
.802c	92 1e		sta ($1e)	                sta (up)
.802e	20 8e 89	jsr $898e	                jsr xt_cr
.8031	ca		dex		                dex
.8032	ca		dex		                dex
.8033	ca		dex		                dex
.8034	ca		dex		                dex
.8035	a9 9c		lda #$9c	                lda #<forth_words_start
.8037	95 02		sta $02,x	                sta 2,x
.8039	a9 bb		lda #$bb	                lda #>forth_words_start
.803b	95 03		sta $03,x	                sta 3,x
.803d	a9 6d		lda #$6d	                lda #<forth_words_end
.803f	38		sec		                sec
.8040	e9 9c		sbc #$9c	                sbc #<forth_words_start
.8042	95 00		sta $00,x	                sta 0,x
.8044	a9 bc		lda #$bc	                lda #>forth_words_end
.8046	e9 bb		sbc #$bb	                sbc #>forth_words_start
.8048	95 01		sta $01,x	                sta 1,x
.804a	20 00 91	jsr $9100	                jsr xt_evaluate
.804d	ca		dex		                dex
.804e	ca		dex		                dex
.804f	ca		dex		                dex
.8050	ca		dex		                dex
.8051	a9 6d		lda #$6d	                lda #<user_words_start
.8053	95 02		sta $02,x	                sta 2,x
.8055	a9 bc		lda #$bc	                lda #>user_words_start
.8057	95 03		sta $03,x	                sta 3,x
.8059	a9 6f		lda #$6f	                lda #<user_words_end
.805b	38		sec		                sec
.805c	e9 6d		sbc #$6d	                sbc #<user_words_start
.805e	95 00		sta $00,x	                sta 0,x
.8060	a9 bc		lda #$bc	                lda #>user_words_end
.8062	e9 bc		sbc #$bc	                sbc #>user_words_start
.8064	95 01		sta $01,x	                sta 1,x
.8066	20 00 91	jsr $9100	                jsr xt_evaluate
.8069	9c 00 7c	stz $7c00	                stz hist_buff
.806c	9c 80 7c	stz $7c80	                stz hist_buff+$80
.806f	9c 00 7d	stz $7d00	                stz hist_buff+$100
.8072	9c 80 7d	stz $7d80	                stz hist_buff+$180
.8075	9c 00 7e	stz $7e00	                stz hist_buff+$200
.8078	9c 80 7e	stz $7e80	                stz hist_buff+$280
.807b	9c 00 7f	stz $7f00	                stz hist_buff+$300
.807e	9c 80 7f	stz $7f80	                stz hist_buff+$380
.8081					xt_abort:
.8081	a2 78		ldx #$78	                ldx #dsp0
.8083					xt_quit:
.8083	8a		txa		                txa             ; Save the DSP that we just defined
.8084	a2 ff		ldx #$ff	                ldx #rsp0
.8086	9a		txs		                txs
.8087	aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8088	64 0e		stz $0e		                stz ip
.808a	64 0f		stz $0f		                stz ip+1
.808c	64 06		stz $06		                stz insrc
.808e	64 07		stz $07		                stz insrc+1
.8090	a9 00		lda #$00	                lda #0
.8092	a0 00		ldy #$00	                ldy #blk_offset
.8094	91 1e		sta ($1e),y	                sta (up),y
.8096	c8		iny		                iny
.8097	91 1e		sta ($1e),y	                sta (up),y
.8099	64 16		stz $16		                stz state
.809b	64 17		stz $17		                stz state+1
.809d					_get_line:
.809d	a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.809f	85 08		sta $08		                sta cib
.80a1	a9 02		lda #$02	                lda #>buffer0
.80a3	85 09		sta $09		                sta cib+1
.80a5	64 0a		stz $0a		                stz ciblen
.80a7	64 0b		stz $0b		                stz ciblen+1
.80a9	20 23 9b	jsr $9b23	                jsr xt_refill           ; ( -- f )
.80ac	b5 00		lda $00,x	                lda 0,x
.80ae	d0 05		bne $80b5	                bne _success
.80b0	a9 06		lda #$06	                lda #err_refill
.80b2	4c 70 d8	jmp $d870	                jmp error
.80b5					_success:
.80b5	e8		inx		                inx                     ; drop
.80b6	e8		inx		                inx
.80b7	20 c2 d7	jsr $d7c2	                jsr interpret
.80ba	e0 78		cpx #$78	                cpx #dsp0
.80bc	f0 05		beq $80c3	                beq _stack_ok
.80be	90 03		bcc $80c3	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80c0	4c 6e d8	jmp $d86e	                jmp underflow_error
.80c3					_stack_ok:
.80c3	a5 16		lda $16		                lda state
.80c5	f0 02		beq $80c9	                beq _print
.80c7	a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80c9					_print:
.80c9	20 a0 d8	jsr $d8a0	                jsr print_string
.80cc	80 cf		bra $809d	                bra _get_line
.80ce					z_cold:
.80ce					z_abort:
.80ce					z_quit:
.80ce					cold_zp_table:
>80ce	00 08				        .word cp0+256+1024      ; cp moved to make room for user vars and
>80d0	6f bc				        .word dictionary_start  ; dp
>80d2	00 00				        .word 0                 ; workword
>80d4	00 00				        .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
>80d6	00 02				        .word buffer0           ; cib
>80d8	00 00				        .word 0                 ; ciblen
>80da	00 00				        .word 0                 ; toin
>80dc	00 00				        .word 0                 ; ip
>80de	27 f0				        .word kernel_putc       ; output
>80e0	21 f0				        .word kernel_getc       ; input
>80e2	00 00				        .word 0                 ; havekey
>80e4	00 00				        .word 0                 ; state (0 = interpret)
>80e6	0a 00				        .word 10                ; base
>80e8	14 00				        .word 20                ; nc-limit
>80ea	00 00				        .word 0                 ; uf_strip (off by default)
>80ec	00 03				        .word cp0               ; up (user vars put right at beginning of
>80ee	00 00				        .word 0                 ; status
.80f0					cold_zp_table_end:
.80f0					cold_user_table:
>80f0	00 00				        .word 0                         ; BLK
>80f2	00 00				        .word 0                         ; SCR
>80f4	00				        .byte 0                         ; CURRENT = FORTH-WORDLIST
>80f5	04				        .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>80f6	6f bc				        .word dictionary_start          ; FORTH-WORDLIST
>80f8	b7 ca				        .word editor_dictionary_start   ; EDITOR-WORDLIST
>80fa	07 cb				        .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
>80fc	76 ca				        .word root_dictionary_start     ; ROOT-WORDLIST
>80fe	00 00 00 00 00 00 00 00		        .word 0,0,0,0,0,0,0,0           ; User wordlists
>8106	00 00 00 00 00 00 00 00
>810e	01				        .byte 1                         ; #ORDER
>810f	00 00 00 00 00 00 00 00		        .byte 0,0,0,0,0,0,0,0,0         ; search-order
>8117	00
>8118	00 04				        .word cp0+256                   ; Address of buffer (right after USER vars)
>811a	00 00				        .word 0                         ; block in buffer
>811c	00 00				        .word 0                         ; buffer status (not in use)
>811e	86 85				        .word xt_block_word_error       ; block-read vector
>8120	86 85				        .word xt_block_word_error       ; block-write vector
.8122					cold_user_table_end:
.8122					xt_abort_quote:
.8122	20 7a 9d	jsr $9d7a	                jsr xt_s_quote          ; S"
.8125	a0 81		ldy #$81	                ldy #>abort_quote_runtime
.8127	a9 2d		lda #$2d	                lda #<abort_quote_runtime
.8129	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.812c	60		rts		z_abort_quote:  rts
.812d					abort_quote_runtime:
.812d	b5 04		lda $04,x	                lda 4,x
.812f	15 05		ora $05,x	                ora 5,x
.8131	f0 09		beq $813c	                beq _done       ; if FALSE, we're done
.8133	20 2e a5	jsr $a52e	                jsr xt_type
.8136	20 8e 89	jsr $898e	                jsr xt_cr
.8139	4c 81 80	jmp $8081	                jmp xt_abort    ; not JSR, so never come back
.813c					_done:
.813c	8a		txa		                txa
.813d	18		clc		                clc
.813e	69 06		adc #$06	                adc #6
.8140	aa		tax		                tax
.8141	60		rts		                rts
.8142					xt_abs:
.8142	20 5a d8	jsr $d85a	                jsr underflow_1
.8145	b5 01		lda $01,x	                lda 1,x
.8147	10 0d		bpl $8156	                bpl _done       ; positive number, easy money!
.8149	38		sec		                sec
.814a	a9 00		lda #$00	                lda #0
.814c	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.814e	95 00		sta $00,x	                sta 0,x
.8150	a9 00		lda #$00	                lda #0          ; MSB
.8152	f5 01		sbc $01,x	                sbc 1,x
.8154	95 01		sta $01,x	                sta 1,x
.8156					_done:
.8156	60		rts		z_abs:          rts
.8157					xt_accept:
.8157	20 5f d8	jsr $d85f	                jsr underflow_2
.815a	b5 00		lda $00,x	                lda 0,x
.815c	15 01		ora $01,x	                ora 1,x
.815e	d0 09		bne $8169	                bne _not_zero
.8160	e8		inx		                inx
.8161	e8		inx		                inx
.8162	74 00		stz $00,x	                stz 0,x
.8164	74 01		stz $01,x	                stz 1,x
.8166	4c 35 82	jmp $8235	                jmp accept_done
.8169					_not_zero:
.8169	b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.816b	85 26		sta $26		                sta tmp2
.816d	64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.816f	b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8171	85 24		sta $24		                sta tmp1
.8173	b5 03		lda $03,x	                lda 3,x
.8175	85 25		sta $25		                sta tmp1+1
.8177	e8		inx		                inx
.8178	e8		inx		                inx
.8179	a0 00		ldy #$00	                ldy #0
.817b	a5 20		lda $20		                lda status
.817d	29 f7		and #$f7	                and #$f7
.817f	1a		inc a		               ina
.8180	09 08		ora #$08	                ora #$08
.8182	85 20		sta $20		                sta status
.8184					accept_loop:
.8184	20 63 93	jsr $9363	                jsr key_a
.8187	c9 0a		cmp #$0a	                cmp #AscLF
.8189	f0 20		beq $81ab	                beq _eol
.818b	c9 0d		cmp #$0d	                cmp #AscCR
.818d	f0 1c		beq $81ab	                beq _eol
.818f	c9 08		cmp #$08	                cmp #AscBS
.8191	f0 22		beq $81b5	                beq _backspace
.8193	c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8195	f0 1e		beq $81b5	                beq _backspace
.8197	c9 10		cmp #$10	                cmp #AscCP
.8199	f0 36		beq $81d1	                beq _ctrl_p
.819b	c9 0e		cmp #$0e	                cmp #AscCN
.819d	f0 44		beq $81e3	                beq _ctrl_n
.819f	91 24		sta ($24),y	                sta (tmp1),y
.81a1	c8		iny		                iny
.81a2	20 21 8e	jsr $8e21	                jsr emit_a
.81a5	c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.81a7	d0 db		bne $8184	                bne accept_loop       ; fall through if buffer limit reached
.81a9	80 03		bra $81ae	                bra _buffer_full
.81ab					_eol:
.81ab	20 49 a1	jsr $a149	                jsr xt_space    ; print final space
.81ae					_buffer_full:
.81ae	94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.81b0	74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.81b2	4c 35 82	jmp $8235	                jmp accept_done
.81b5					_backspace:
.81b5	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.81b7	d0 06		bne $81bf	                bne +
.81b9	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.81bb	20 21 8e	jsr $8e21	                jsr emit_a
.81be	c8		iny		                iny
.81bf					+
.81bf	88		dey		                dey
.81c0	a9 08		lda #$08	                lda #AscBS      ; move back one
.81c2	20 21 8e	jsr $8e21	                jsr emit_a
.81c5	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.81c7	20 21 8e	jsr $8e21	                jsr emit_a
.81ca	a9 08		lda #$08	                lda #AscBS      ; move back over space
.81cc	20 21 8e	jsr $8e21	                jsr emit_a
.81cf	80 b3		bra $8184	                bra accept_loop
.81d1					_ctrl_p:
.81d1	a5 20		lda $20		                lda status
.81d3	29 07		and #$07	                and #7
.81d5	d0 08		bne $81df	                bne _ctrl_p_dec
.81d7	a5 20		lda $20		                lda status
.81d9	09 07		ora #$07	                ora #7
.81db	85 20		sta $20		                sta status
.81dd	80 11		bra $81f0	                bra _recall_history
.81df					_ctrl_p_dec:
.81df	c6 20		dec $20		                dec status
.81e1	80 0d		bra $81f0	                bra _recall_history
.81e3					_ctrl_n:
.81e3	a9 08		lda #$08	                lda #$8
.81e5	24 20		bit $20		                bit status
.81e7	d0 07		bne $81f0	                bne _recall_history
.81e9	a5 20		lda $20		                lda status
.81eb	29 f7		and #$f7	                and #$f7
.81ed	1a		inc a		               ina
.81ee	85 20		sta $20		                sta status
.81f0					_recall_history:
.81f0	a9 08		lda #$08	                lda #%00001000
.81f2	14 20		trb $20		                trb status
.81f4	20 50 82	jsr $8250	                jsr accept_total_recall
.81f7	a9 0d		lda #$0d	                lda #AscCR
.81f9	20 21 8e	jsr $8e21	                jsr emit_a
.81fc					input_clear:
.81fc	c0 00		cpy #$00	                cpy #0
.81fe	f0 08		beq $8208	                beq input_cleared
.8200	a9 20		lda #$20	                lda #AscSP
.8202	20 21 8e	jsr $8e21	                jsr emit_a
.8205	88		dey		                dey
.8206	80 f4		bra $81fc	                bra input_clear
.8208					input_cleared:
.8208	a9 0d		lda #$0d	                lda #AscCR
.820a	20 21 8e	jsr $8e21	                jsr emit_a
.820d	b1 28		lda ($28),y	                lda (tmp3),y
.820f	85 21		sta $21		                sta status+1
.8211	e6 28		inc $28		                inc tmp3
.8213	d0 02		bne $8217	                bne +           ; Increment the upper byte on carry.
.8215	e6 29		inc $29		                inc tmp3+1
.8217					+
.8217	a9 0d		lda #$0d	                lda #AscCR
.8219	20 21 8e	jsr $8e21	                jsr emit_a
.821c					_history_loop:
.821c	c4 21		cpy $21		                cpy status+1
.821e	d0 03		bne $8223	                bne +
.8220	4c 84 81	jmp $8184	                jmp accept_loop       ; Needs a long jump
.8223					+
.8223	c4 26		cpy $26		                cpy tmp2
.8225	f0 0a		beq $8231	                beq _hist_filled_buffer
.8227	b1 28		lda ($28),y	                lda (tmp3),y
.8229	91 24		sta ($24),y	                sta (tmp1),y
.822b	20 21 8e	jsr $8e21	                jsr emit_a
.822e	c8		iny		                iny
.822f	80 eb		bra $821c	                bra _history_loop
.8231					_hist_filled_buffer:
.8231	88		dey		                dey
.8232	4c 84 81	jmp $8184	                jmp accept_loop
.8235					accept_done:
.8235	20 50 82	jsr $8250	                jsr accept_total_recall
.8238	85 21		sta $21		                sta status+1
.823a	a0 00		ldy #$00	                ldy #0
.823c	91 28		sta ($28),y	                sta (tmp3),y
.823e	e6 28		inc $28		                inc tmp3
.8240	d0 02		bne $8244	                bne +           ; Increment the upper byte on carry.
.8242	e6 29		inc $29		                inc tmp3+1
.8244					+
.8244					_save_history_loop:
.8244	c4 21		cpy $21		                cpy status+1
.8246	f0 07		beq $824f	                beq _save_history_done
.8248	b1 24		lda ($24),y	                lda (tmp1),y
.824a	91 28		sta ($28),y	                sta (tmp3),y
.824c	c8		iny		                iny
.824d	80 f5		bra $8244	                bra _save_history_loop
.824f					_save_history_done:
.824f					z_accept:
.824f	60		rts		                rts
.8250					accept_total_recall:
.8250	a9 00		lda #$00	                lda #<hist_buff
.8252	85 28		sta $28		                sta tmp3
.8254	a9 7c		lda #$7c	                lda #>hist_buff
.8256	85 29		sta $29		                sta tmp3+1
.8258	a5 20		lda $20		                lda status
.825a	6a		ror a		                ror
.825b	29 03		and #$03	                and #3
.825d	18		clc		                clc
.825e	65 29		adc $29		                adc tmp3+1
.8260	85 29		sta $29		                sta tmp3+1
.8262	a5 20		lda $20		                lda status
.8264	6a		ror a		                ror             ; Rotate through carry into msb.
.8265	6a		ror a		                ror
.8266	29 80		and #$80	                and #$80
.8268	18		clc		                clc
.8269	65 28		adc $28		                adc tmp3
.826b	85 28		sta $28		                sta tmp3
.826d	90 02		bcc $8271	                bcc +           ; Increment the upper byte on carry.
.826f	e6 29		inc $29		                inc tmp3+1
.8271					+
.8271	98		tya		                tya
.8272	c9 80		cmp #$80	                cmp #$80
.8274	90 02		bcc $8278	                bcc +
.8276	a9 7f		lda #$7f	                lda #$7F
.8278					+
.8278	60		rts		                rts
.8279					xt_action_of:
.8279	a5 16		lda $16		                lda state
.827b	05 17		ora $17		                ora state+1
.827d	f0 0c		beq $828b	                beq _interpreting
.827f					_compiling:
.827f	20 c9 85	jsr $85c9	                jsr xt_bracket_tick
.8282	a0 8b		ldy #$8b	                ldy #>xt_defer_fetch
.8284	a9 0a		lda #$0a	                lda #<xt_defer_fetch
.8286	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.8289	80 06		bra $8291	                bra _done
.828b					_interpreting:
.828b	20 3c a2	jsr $a23c	                jsr xt_tick
.828e	20 0a 8b	jsr $8b0a	                jsr xt_defer_fetch
.8291					_done:
.8291	60		rts		z_action_of:           rts
.8292					xt_again:
.8292	20 5a d8	jsr $d85a	                jsr underflow_1
.8295	a0 00		ldy #$00	                ldy #0
.8297	a9 4c		lda #$4c	                lda #$4C        ; JMP
.8299	91 00		sta ($00),y	                sta (cp),y
.829b	c8		iny		                iny
.829c	b5 00		lda $00,x	                lda 0,x         ; LSB of address
.829e	91 00		sta ($00),y	                sta (cp),y
.82a0	c8		iny		                iny
.82a1	b5 01		lda $01,x	                lda 1,x         ; MSB of address
.82a3	91 00		sta ($00),y	                sta (cp),y
.82a5	c8		iny		                iny
.82a6	98		tya		                tya
.82a7	18		clc		                clc
.82a8	65 00		adc $00		                adc cp
.82aa	85 00		sta $00		                sta cp
.82ac	90 02		bcc $82b0	                bcc _done
.82ae	e6 01		inc $01		                inc cp+1
.82b0					_done:
.82b0	e8		inx		                inx
.82b1	e8		inx		                inx
.82b2	60		rts		z_again:        rts
.82b3					xt_align:
.82b3					xt_aligned:
.82b3					z_align:
.82b3	60		rts		z_aligned:      rts             ; stripped out during native compile
.82b4					xt_allot:
.82b4	20 5a d8	jsr $d85a	                jsr underflow_1
.82b7	b5 01		lda $01,x	                lda 1,x
.82b9	30 22		bmi $82dd	                bmi _release
.82bb	18		clc		                clc
.82bc	a5 00		lda $00		                lda cp
.82be	75 00		adc $00,x	                adc 0,x
.82c0	85 00		sta $00		                sta cp
.82c2	a5 01		lda $01		                lda cp+1
.82c4	75 01		adc $01,x	                adc 1,x
.82c6	85 01		sta $01		                sta cp+1
.82c8	a0 00		ldy #$00	                ldy #<cp_end
.82ca	c4 00		cpy $00		                cpy cp
.82cc	a9 7c		lda #$7c	                lda #>cp_end
.82ce	e5 01		sbc $01		                sbc cp+1
.82d0	b0 48		bcs $831a	                bcs _done               ; we're fine.
.82d2	84 00		sty $00		                sty cp                  ; still #<cp_end
.82d4	a9 7c		lda #$7c	                lda #>cp_end
.82d6	85 01		sta $01		                sta cp+1
.82d8	a9 00		lda #$00	                lda #err_allot
.82da	4c 70 d8	jmp $d870	                jmp error
.82dd					_release:
.82dd	ca		dex		                dex
.82de	ca		dex		                dex
.82df	a5 00		lda $00		                lda cp
.82e1	95 00		sta $00,x	                sta 0,x
.82e3	a5 01		lda $01		                lda cp+1
.82e5	95 01		sta $01,x	                sta 1,x
.82e7	20 0e 9a	jsr $9a0e	                jsr xt_plus                     ; new CP is now TOS
.82ea	ca		dex		                dex
.82eb	ca		dex		                dex                             ; new CP now NOS
.82ec	a9 00		lda #$00	                lda #<cp0
.82ee	95 00		sta $00,x	                sta 0,x
.82f0	a9 03		lda #$03	                lda #>cp0
.82f2	95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.82f4	20 81 d7	jsr $d781	                jsr compare_16bit               ; still ( CP CP0 )
.82f7	f0 17		beq $8310	                beq _nega_done
.82f9	30 15		bmi $8310	                bmi _nega_done
.82fb	a9 00		lda #$00	                lda #<cp0
.82fd	85 00		sta $00		                sta cp
.82ff	a9 03		lda #$03	                lda #>cp0
.8301	85 01		sta $01		                sta cp+1
.8303	a9 6f		lda #$6f	                lda #<dictionary_start
.8305	85 02		sta $02		                sta dp
.8307	a9 bc		lda #$bc	                lda #>dictionary_start
.8309	85 03		sta $03		                sta dp+1
.830b	a9 0a		lda #$0a	                lda #err_negallot
.830d	4c 70 d8	jmp $d870	                jmp error
.8310					_nega_done:
.8310	b5 02		lda $02,x	                lda 2,x
.8312	85 00		sta $00		                sta cp
.8314	b5 03		lda $03,x	                lda 3,x
.8316	85 01		sta $01		                sta cp+1
.8318	e8		inx		                inx
.8319	e8		inx		                inx                     ; drop through to _done
.831a					_done:
.831a	e8		inx		                inx
.831b	e8		inx		                inx
.831c					z_allot:
.831c	60		rts		                rts
.831d					xt_allow_native:
.831d	20 9c d7	jsr $d79c	                jsr current_to_dp
.8320	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8322	b1 02		lda ($02),y	                lda (dp),y
.8324	29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.8326	91 02		sta ($02),y	                sta (dp),y
.8328					z_allow_native:
.8328	60		rts		                rts
.8329					xt_also:
.8329	20 5f 91	jsr $915f	                jsr xt_get_order
.832c	20 be 98	jsr $98be	                jsr xt_over
.832f	20 d9 a1	jsr $a1d9	                jsr xt_swap
.8332	20 48 98	jsr $9848	                jsr xt_one_plus
.8335	20 46 9d	jsr $9d46	                jsr xt_set_order
.8338	60		rts		z_also:         rts
.8339					xt_always_native:
.8339	20 9c d7	jsr $d79c	                jsr current_to_dp
.833c	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.833e	b1 02		lda ($02),y	                lda (dp),y
.8340	09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.8342	29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.8344	91 02		sta ($02),y	                sta (dp),y
.8346					z_always_native:
.8346	60		rts		                rts
.8347					xt_and:
.8347	20 5f d8	jsr $d85f	                jsr underflow_2
.834a	b5 00		lda $00,x	                lda 0,x
.834c	35 02		and $02,x	                and 2,x
.834e	95 02		sta $02,x	                sta 2,x
.8350	b5 01		lda $01,x	                lda 1,x
.8352	35 03		and $03,x	                and 3,x
.8354	95 03		sta $03,x	                sta 3,x
.8356	e8		inx		                inx
.8357	e8		inx		                inx
.8358	60		rts		z_and:          rts
.8359					xt_at_xy:
.8359	20 5f d8	jsr $d85f	                jsr underflow_2
.835c	a5 18		lda $18		                lda base
.835e	48		pha		                pha
.835f	a9 0a		lda #$0a	                lda #10
.8361	85 18		sta $18		                sta base
.8363	a9 1b		lda #$1b	                lda #AscESC
.8365	20 21 8e	jsr $8e21	                jsr emit_a
.8368	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.836a	20 21 8e	jsr $8e21	                jsr emit_a
.836d	20 48 98	jsr $9848	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8370	20 a6 d8	jsr $d8a6	                jsr print_u
.8373	a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8375	20 21 8e	jsr $8e21	                jsr emit_a
.8378	20 48 98	jsr $9848	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.837b	20 a6 d8	jsr $d8a6	                jsr print_u
.837e	a9 48		lda #$48	                lda #'H'
.8380	20 21 8e	jsr $8e21	                jsr emit_a
.8383	68		pla		                pla
.8384	85 18		sta $18		                sta base
.8386	60		rts		z_at_xy:        rts
.8387					xt_backslash:
.8387	a0 00		ldy #$00	                ldy #blk_offset
.8389	b1 1e		lda ($1e),y	                lda (up),y
.838b	c8		iny		                iny
.838c	11 1e		ora ($1e),y	                ora (up),y
.838e	f0 19		beq $83a9	                beq backslash_not_block
.8390	a5 0c		lda $0c		                lda toin
.8392	29 3f		and #$3f	                and #$3F
.8394	f0 1b		beq $83b1	                beq z_backslash
.8396	c9 01		cmp #$01	                cmp #$01
.8398	f0 17		beq $83b1	                beq z_backslash
.839a	a5 0c		lda $0c		                lda toin
.839c	29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.839e	18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.839f	69 40		adc #$40	                adc #$40
.83a1	85 0c		sta $0c		                sta toin
.83a3	90 0c		bcc $83b1	                bcc z_backslash
.83a5	e6 0d		inc $0d		                inc toin+1
.83a7	80 08		bra $83b1	                bra z_backslash
.83a9					backslash_not_block:
.83a9	a5 0a		lda $0a		                lda ciblen
.83ab	85 0c		sta $0c		                sta toin
.83ad	a5 0b		lda $0b		                lda ciblen+1
.83af	85 0d		sta $0d		                sta toin+1
.83b1	60		rts		z_backslash:    rts
.83b2					xt_base:
.83b2	ca		dex		                dex
.83b3	ca		dex		                dex
.83b4	a9 18		lda #$18	                lda #<base
.83b6	95 00		sta $00,x	                sta 0,x         ; LSB
.83b8	74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.83ba	60		rts		z_base:         rts
.83bb					xt_begin:
.83bb	20 9d 91	jsr $919d	                jsr xt_here
.83be	60		rts		z_begin:        rts
.83bf					xt_bell:
.83bf	a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.83c1	20 21 8e	jsr $8e21	                jsr emit_a
.83c4	60		rts		z_bell:         rts
.83c5					xt_bl:
.83c5	ca		dex		                dex
.83c6	ca		dex		                dex
.83c7	a9 20		lda #$20	                lda #AscSP
.83c9	95 00		sta $00,x	                sta 0,x
.83cb	74 01		stz $01,x	                stz 1,x
.83cd	60		rts		z_bl:           rts
.83ce					xt_blk:
.83ce	ca		dex		                dex
.83cf	ca		dex		                dex
.83d0	18		clc		                clc
.83d1	a5 1e		lda $1e		                lda up
.83d3	69 00		adc #$00	                adc #blk_offset ; Add offset
.83d5	95 00		sta $00,x	                sta 0,x
.83d7	a5 1f		lda $1f		                lda up+1
.83d9	69 00		adc #$00	                adc #0          ; Adding carry
.83db	95 01		sta $01,x	                sta 1,x
.83dd	60		rts		z_blk:          rts
.83de					xt_blkbuffer:
.83de	ca		dex		                dex
.83df	ca		dex		                dex
.83e0	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83e2	b1 1e		lda ($1e),y	                lda (up),y
.83e4	95 00		sta $00,x	                sta 0,x
.83e6	c8		iny		                iny             ; Move along to the next byte
.83e7	b1 1e		lda ($1e),y	                lda (up),y
.83e9	95 01		sta $01,x	                sta 1,x
.83eb	60		rts		z_blkbuffer:    rts
.83ec					xt_block:
.83ec	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83ee	b1 1e		lda ($1e),y	                lda (up),y
.83f0	d5 00		cmp $00,x	                cmp 0,x
.83f2	d0 0f		bne $8403	                bne _not_in_buffer
.83f4	c8		iny		                iny
.83f5	b1 1e		lda ($1e),y	                lda (up),y
.83f7	d5 01		cmp $01,x	                cmp 1,x
.83f9	d0 08		bne $8403	                bne _not_in_buffer
.83fb	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83fd	b1 1e		lda ($1e),y	                lda (up),y
.83ff	29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.8401	d0 30		bne $8433	                bne _done       ; It's already in the buffer and in use.
.8403					_not_in_buffer:
.8403	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8405	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.8407	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8409	d0 0c		bne $8417	                bne _buffer_available ; Unused or not dirty = available
.840b	20 de 83	jsr $83de	                jsr xt_blkbuffer
.840e	20 d0 85	jsr $85d0	                jsr xt_buffblocknum
.8411	20 ab 8f	jsr $8fab	                jsr xt_fetch
.8414	20 8b 85	jsr $858b	                jsr xt_block_write
.8417					_buffer_available:
.8417	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.8419	b5 00		lda $00,x	                lda 0,x
.841b	91 1e		sta ($1e),y	                sta (up),y
.841d	c8		iny		                iny
.841e	b5 01		lda $01,x	                lda 1,x
.8420	91 1e		sta ($1e),y	                sta (up),y
.8422	20 de 83	jsr $83de	                jsr xt_blkbuffer
.8425	20 d9 a1	jsr $a1d9	                jsr xt_swap
.8428	20 68 85	jsr $8568	                jsr xt_block_read
.842b	a9 01		lda #$01	                lda #1
.842d	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.842f	91 1e		sta ($1e),y	                sta (up),y
.8431	ca		dex		                dex
.8432	ca		dex		                dex
.8433					_done:
.8433	a0 28		ldy #$28	                ldy #blkbuffer_offset
.8435	b1 1e		lda ($1e),y	                lda (up),y
.8437	95 00		sta $00,x	                sta 0,x
.8439	c8		iny		                iny
.843a	b1 1e		lda ($1e),y	                lda (up),y
.843c	95 01		sta $01,x	                sta 1,x
.843e	60		rts		z_block:        rts
.843f					xt_block_ramdrive_init:
.843f	20 5a d8	jsr $d85a	                jsr underflow_1
.8442	4c 5d 85	jmp $855d	                jmp _after_ramdrive_code
.8445					_ramdrive_code:
>8445	62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>844d	77 61 70 20 64 65 63 69 6d 61 6c
>8458	20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>845f	20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>8463	20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>846b	20 72 61 6d 64 72 69 76 65
>8474	20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>847c	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>848a	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8492	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>84a2	73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>84b2	20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>84ba	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>84c9	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>84d1	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>84e1	31 30 32 34 20 6d 6f 76 65 20 3b
>84ec	20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>84f4	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>8504	6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>8514	20 21
>8516	20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>851e	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>852e	62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>853e	6f 72 20 21
>8542	20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>854a	65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>855a	65 20 21
.855d					_after_ramdrive_code:
.855d	20 d4 a0	jsr $a0d4	                jsr sliteral_runtime
>8560	45 84 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.8564	20 00 91	jsr $9100	                jsr xt_evaluate
.8567					z_block_ramdrive_init:
.8567	60		rts		                rts
.8568					xt_block_read:
.8568	a0 2e		ldy #$2e	                ldy #blockread_offset
.856a	b1 1e		lda ($1e),y	                lda (up),y
.856c	85 24		sta $24		                sta tmp1
.856e	c8		iny		                iny
.856f	b1 1e		lda ($1e),y	                lda (up),y
.8571	85 25		sta $25		                sta tmp1+1
.8573	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8576					z_block_read:
.8576					xt_block_read_vector:
.8576	ca		dex		                dex
.8577	ca		dex		                dex
.8578	18		clc		                clc
.8579	a5 1e		lda $1e		                lda up
.857b	69 2e		adc #$2e	                adc #blockread_offset
.857d	95 00		sta $00,x	                sta 0,x
.857f	a5 1f		lda $1f		                lda up+1
.8581	69 00		adc #$00	                adc #0          ; Add carry
.8583	95 01		sta $01,x	                sta 1,x
.8585					z_block_read_vector:
.8585	60		rts		                rts
.8586					xt_block_word_error:
.8586	a9 0c		lda #$0c	                lda #err_blockwords
.8588	4c 70 d8	jmp $d870	                jmp error       ; no RTS needed
.858b					z_block_word_error:
.858b					xt_block_write:
.858b	a0 30		ldy #$30	                ldy #blockwrite_offset
.858d	b1 1e		lda ($1e),y	                lda (up),y
.858f	85 24		sta $24		                sta tmp1
.8591	c8		iny		                iny
.8592	b1 1e		lda ($1e),y	                lda (up),y
.8594	85 25		sta $25		                sta tmp1+1
.8596	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8599					z_block_write:
.8599					xt_block_write_vector:
.8599	ca		dex		                dex
.859a	ca		dex		                dex
.859b	18		clc		                clc
.859c	a5 1e		lda $1e		                lda up
.859e	69 30		adc #$30	                adc #blockwrite_offset
.85a0	95 00		sta $00,x	                sta 0,x
.85a2	a5 1f		lda $1f		                lda up+1
.85a4	69 00		adc #$00	                adc #0          ; Add carry
.85a6	95 01		sta $01,x	                sta 1,x
.85a8					z_block_write_vector:
.85a8	60		rts		                rts
.85a9					xt_bounds:
.85a9	20 5f d8	jsr $d85f	                jsr underflow_2
.85ac	18		clc		                clc
.85ad	b5 00		lda $00,x	                lda 0,x                 ; LSB u
.85af	b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.85b1	75 02		adc $02,x	                adc 2,x
.85b3	95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.85b5	94 00		sty $00,x	                sty 0,x
.85b7	b5 01		lda $01,x	                lda 1,x                 ; MSB u
.85b9	b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.85bb	75 03		adc $03,x	                adc 3,x
.85bd	95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.85bf	94 01		sty $01,x	                sty 1,x
.85c1	60		rts		z_bounds:       rts
.85c2					xt_bracket_char:
.85c2	20 5c 86	jsr $865c	                jsr xt_char
.85c5	20 b5 93	jsr $93b5	                jsr xt_literal
.85c8	60		rts		z_bracket_char: rts
.85c9					xt_bracket_tick:
.85c9	20 3c a2	jsr $a23c	                jsr xt_tick
.85cc	20 b5 93	jsr $93b5	                jsr xt_literal
.85cf	60		rts		z_bracket_tick: rts
.85d0					xt_buffblocknum:
.85d0	ca		dex		                dex
.85d1	ca		dex		                dex
.85d2	18		clc		                clc
.85d3	a5 1e		lda $1e		                lda up
.85d5	69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.85d7	95 00		sta $00,x	                sta 0,x
.85d9	a5 1f		lda $1f		                lda up+1
.85db	69 00		adc #$00	                adc #0                          ; Adding carry
.85dd	95 01		sta $01,x	                sta 1,x
.85df	60		rts		z_buffblocknum: rts
.85e0					xt_buffer:
.85e0	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85e2	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.85e4	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.85e6	d0 0c		bne $85f4	                bne _buffer_available ; Unused or not dirty = available
.85e8	20 de 83	jsr $83de	                jsr xt_blkbuffer
.85eb	20 d0 85	jsr $85d0	                jsr xt_buffblocknum
.85ee	20 ab 8f	jsr $8fab	                jsr xt_fetch
.85f1	20 8b 85	jsr $858b	                jsr xt_block_write
.85f4					_buffer_available:
.85f4	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.85f6	b5 00		lda $00,x	                lda 0,x
.85f8	91 1e		sta ($1e),y	                sta (up),y
.85fa	c8		iny		                iny
.85fb	b5 01		lda $01,x	                lda 1,x
.85fd	91 1e		sta ($1e),y	                sta (up),y
.85ff	a9 01		lda #$01	                lda #1
.8601	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8603	91 1e		sta ($1e),y	                sta (up),y
.8605					_done:
.8605	a0 28		ldy #$28	                ldy #blkbuffer_offset
.8607	b1 1e		lda ($1e),y	                lda (up),y
.8609	95 00		sta $00,x	                sta 0,x
.860b	c8		iny		                iny
.860c	b1 1e		lda ($1e),y	                lda (up),y
.860e	95 01		sta $01,x	                sta 1,x
.8610	60		rts		z_buffer:       rts
.8611					xt_buffer_colon:
.8611	20 94 89	jsr $8994	                jsr xt_create
.8614	20 b4 82	jsr $82b4	                jsr xt_allot
.8617	60		rts		z_buffer_colon: rts
.8618					xt_buffstatus:
.8618	ca		dex		                dex
.8619	ca		dex		                dex
.861a	18		clc		                clc
.861b	a5 1e		lda $1e		                lda up
.861d	69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.861f	95 00		sta $00,x	                sta 0,x
.8621	a5 1f		lda $1f		                lda up+1
.8623	69 00		adc #$00	                adc #0                  ; Adding carry
.8625	95 01		sta $01,x	                sta 1,x
.8627	60		rts		z_buffstatus:   rts
.8628					xt_bye:
.8628	4c 2b f0	jmp $f02b	                jmp platform_bye
.862b					z_bye:
.862b					xt_c_comma:
.862b	20 5a d8	jsr $d85a	                jsr underflow_1
.862e	b5 00		lda $00,x	                lda 0,x
.8630	20 0d d7	jsr $d70d	                jsr cmpl_a
.8633	e8		inx		                inx
.8634	e8		inx		                inx
.8635	60		rts		z_c_comma:      rts
.8636					xt_c_fetch:
.8636	20 5a d8	jsr $d85a	                jsr underflow_1
.8639	a1 00		lda ($00,x)	                lda (0,x)
.863b	95 00		sta $00,x	                sta 0,x
.863d	74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.863f	60		rts		z_c_fetch:      rts
.8640					xt_c_store:
.8640	20 5f d8	jsr $d85f	                jsr underflow_2
.8643	b5 02		lda $02,x	                lda 2,x
.8645	81 00		sta ($00,x)	                sta (0,x)
.8647	e8		inx		                inx
.8648	e8		inx		                inx
.8649	e8		inx		                inx
.864a	e8		inx		                inx
.864b	60		rts		z_c_store:      rts
.864c					xt_cell_plus:
.864c	20 5a d8	jsr $d85a	                jsr underflow_1
.864f	f6 00		inc $00,x	                inc 0,x
.8651	d0 02		bne $8655	                bne +
.8653	f6 01		inc $01,x	                inc 1,x
.8655					+
.8655	f6 00		inc $00,x	                inc 0,x
.8657	d0 02		bne $865b	                bne _done
.8659	f6 01		inc $01,x	                inc 1,x
.865b					_done:
.865b	60		rts		z_cell_plus:    rts
.865c					xt_char:
.865c	20 0a 99	jsr $990a	                jsr xt_parse_name
.865f	b5 00		lda $00,x	                lda 0,x
.8661	15 01		ora $01,x	                ora 1,x
.8663	d0 05		bne $866a	                bne _not_empty
.8665	a9 05		lda #$05	                lda #err_noname
.8667	4c 70 d8	jmp $d870	                jmp error
.866a					_not_empty:
.866a	e8		inx		                inx             ; drop number of characters, leave addr
.866b	e8		inx		                inx
.866c	a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.866e	95 00		sta $00,x	                sta 0,x
.8670	74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8672	60		rts		z_char:         rts
.8673					xt_chars:
.8673	20 5a d8	jsr $d85a	                jsr underflow_1
.8676	60		rts		z_chars:        rts
.8677					xt_cleave:
.8677	20 5f d8	jsr $d85f	                jsr underflow_2
.867a	20 8e 95	jsr $958e	                jsr xt_minus_leading    ; -LEADING ( addr u )
.867d	20 8d 92	jsr $928d	                jsr xt_input_to_r       ; save old imput state
.8680	b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.8682	85 0a		sta $0a		                sta ciblen
.8684	b5 01		lda $01,x	                lda 1,x
.8686	85 0b		sta $0b		                sta ciblen+1
.8688	b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.868a	85 08		sta $08		                sta cib
.868c	b5 03		lda $03,x	                lda 3,x
.868e	85 09		sta $09		                sta cib+1
.8690	64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.8692	64 0d		stz $0d		                stz toin+1
.8694	20 0a 99	jsr $990a	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.8697	b5 00		lda $00,x	                lda 0,x
.8699	15 01		ora $01,x	                ora 1,x
.869b	f0 23		beq $86c0	                beq _done
.869d	b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.869f	38		sec		                sec
.86a0	f5 00		sbc $00,x	                sbc 0,x
.86a2	95 04		sta $04,x	                sta 4,x
.86a4	b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.86a6	f5 01		sbc $01,x	                sbc 1,x
.86a8	95 05		sta $05,x	                sta 5,x
.86aa	b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.86ac	18		clc		                clc
.86ad	75 00		adc $00,x	                adc 0,x
.86af	95 06		sta $06,x	                sta 6,x
.86b1	b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.86b3	75 01		adc $01,x	                adc 1,x
.86b5	95 07		sta $07,x	                sta 7,x
.86b7	20 a9 a4	jsr $a4a9	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.86ba	20 8e 95	jsr $958e	                jsr xt_minus_leading
.86bd	20 a9 a4	jsr $a4a9	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.86c0					_done:
.86c0	20 ce 9a	jsr $9ace	                jsr xt_r_to_input
.86c3	60		rts		z_cleave:       rts
.86c4					xt_cmove:
.86c4	20 64 d8	jsr $d864	                jsr underflow_3
.86c7	b5 02		lda $02,x	                lda 2,x
.86c9	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86cb	b5 03		lda $03,x	                lda 3,x
.86cd	85 27		sta $27		                sta tmp2+1
.86cf	b5 04		lda $04,x	                lda 4,x
.86d1	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86d3	b5 05		lda $05,x	                lda 5,x
.86d5	85 25		sta $25		                sta tmp1+1
.86d7	a0 00		ldy #$00	                ldy #0
.86d9	b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.86db	f0 0f		beq $86ec	                beq _dopartial
.86dd					_page:
.86dd	b1 24		lda ($24),y	                lda (tmp1),y
.86df	91 26		sta ($26),y	                sta (tmp2),y
.86e1	c8		iny		                iny
.86e2	d0 f9		bne $86dd	                bne _page
.86e4	e6 25		inc $25		                inc tmp1+1
.86e6	e6 27		inc $27		                inc tmp2+1
.86e8	d6 01		dec $01,x	                dec 1,x
.86ea	d0 f1		bne $86dd	                bne _page
.86ec					_dopartial:
.86ec	b5 00		lda $00,x	                lda 0,x         ; length of last page
.86ee	f0 09		beq $86f9	                beq _done
.86f0					_partial:
.86f0	b1 24		lda ($24),y	                lda (tmp1),y
.86f2	91 26		sta ($26),y	                sta (tmp2),y
.86f4	c8		iny		                iny
.86f5	d6 00		dec $00,x	                dec 0,x
.86f7	d0 f7		bne $86f0	                bne _partial
.86f9					_done:
.86f9	8a		txa		                txa
.86fa	18		clc		                clc
.86fb	69 06		adc #$06	                adc #6
.86fd	aa		tax		                tax
.86fe	60		rts		z_cmove:        rts
.86ff					xt_cmove_up:
.86ff	20 64 d8	jsr $d864	                jsr underflow_3
.8702	b5 02		lda $02,x	                lda 2,x
.8704	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.8706	b5 03		lda $03,x	                lda 3,x
.8708	18		clc		                clc
.8709	75 01		adc $01,x	                adc 1,x
.870b	85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.870d	b5 04		lda $04,x	                lda 4,x
.870f	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.8711	b5 05		lda $05,x	                lda 5,x
.8713	18		clc		                clc
.8714	75 01		adc $01,x	                adc 1,x
.8716	85 25		sta $25		                sta tmp1+1      ; point to last page of source
.8718	f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.871a	b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.871c	f0 0e		beq $872c	                beq _nopartial
.871e					_outerloop:
.871e	88		dey		                dey
.871f	f0 07		beq $8728	                beq _finishpage
.8721					_innerloop:
.8721	b1 24		lda ($24),y	                lda (tmp1),y
.8723	91 26		sta ($26),y	                sta (tmp2),y
.8725	88		dey		                dey
.8726	d0 f9		bne $8721	                bne _innerloop
.8728					_finishpage:
.8728	b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.872a	92 26		sta ($26)	                sta (tmp2)
.872c					_nopartial:
.872c	c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.872e	c6 27		dec $27		                dec tmp2+1
.8730	d6 01		dec $01,x	                dec 1,x
.8732	d0 ea		bne $871e	                bne _outerloop
.8734					_done:
.8734	8a		txa		                txa
.8735	18		clc		                clc
.8736	69 06		adc #$06	                adc #6
.8738	aa		tax		                tax
.8739	60		rts		z_cmove_up:     rts
.873a					xt_colon:
.873a	a5 16		lda $16		                lda state
.873c	05 17		ora $17		                ora state+1
.873e	f0 05		beq $8745	                beq +
.8740	a9 07		lda #$07	                lda #err_state
.8742	4c 70 d8	jmp $d870	                jmp error
.8745					+
.8745	c6 16		dec $16		                dec state
.8747	c6 17		dec $17		                dec state+1
.8749	a9 40		lda #$40	                lda #%01000000
.874b	04 20		tsb $20		                tsb status
.874d	20 9c d7	jsr $d79c	                jsr current_to_dp
.8750	a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8752	48		pha		                pha
.8753	a5 02		lda $02		                lda dp
.8755	48		pha		                pha
.8756	a9 80		lda #$80	                lda #%10000000
.8758	04 20		tsb $20		                tsb status
.875a	20 94 89	jsr $8994	                jsr xt_create
.875d	20 9c d7	jsr $d79c	                jsr current_to_dp   ; This might be able to be omitted
.8760	a5 02		lda $02		                lda dp
.8762	85 04		sta $04		                sta workword
.8764	a5 03		lda $03		                lda dp+1
.8766	85 05		sta $05		                sta workword+1
.8768	68		pla		                pla
.8769	85 02		sta $02		                sta dp
.876b	68		pla		                pla
.876c	85 03		sta $03		                sta dp+1
.876e	20 af d7	jsr $d7af	                jsr dp_to_current
.8771	a5 00		lda $00		                lda cp
.8773	38		sec		                sec
.8774	e9 03		sbc #$03	                sbc #3
.8776	85 00		sta $00		                sta cp
.8778	b0 02		bcs $877c	                bcs _done
.877a	c6 01		dec $01		                dec cp+1
.877c					_done:
.877c	60		rts		z_colon:        rts
.877d					xt_colon_noname:
.877d	a5 16		lda $16		                lda state
.877f	05 17		ora $17		                ora state+1
.8781	f0 05		beq $8788	                beq +
.8783	a9 07		lda #$07	                lda #err_state
.8785	4c 70 d8	jmp $d870	                jmp error
.8788					+
.8788	c6 16		dec $16		                dec state
.878a	c6 17		dec $17		                dec state+1
.878c	a9 40		lda #$40	                lda #%01000000
.878e	14 20		trb $20		                trb status
.8790	a5 00		lda $00		                lda cp
.8792	85 04		sta $04		                sta workword
.8794	a5 01		lda $01		                lda cp+1
.8796	85 05		sta $05		                sta workword+1
.8798					_done:
.8798	60		rts		z_colon_noname:        rts
.8799					xt_comma:
.8799	20 5a d8	jsr $d85a	                jsr underflow_1
.879c	b5 00		lda $00,x	                lda 0,x
.879e	92 00		sta ($00)	                sta (cp)
.87a0	e6 00		inc $00		                inc cp
.87a2	d0 02		bne $87a6	                bne +
.87a4	e6 01		inc $01		                inc cp+1
.87a6					+
.87a6	b5 01		lda $01,x	                lda 1,x
.87a8	92 00		sta ($00)	                sta (cp)
.87aa	e6 00		inc $00		                inc cp
.87ac	d0 02		bne $87b0	                bne _done
.87ae	e6 01		inc $01		                inc cp+1
.87b0					_done:
.87b0	e8		inx		                inx
.87b1	e8		inx		                inx
.87b2	60		rts		z_comma:        rts
.87b3					xt_compare:
.87b3	20 69 d8	jsr $d869	                jsr underflow_4
.87b6	b5 02		lda $02,x	                lda 2,x
.87b8	85 26		sta $26		                sta tmp2
.87ba	b5 03		lda $03,x	                lda 3,x
.87bc	85 27		sta $27		                sta tmp2+1
.87be	b5 06		lda $06,x	                lda 6,x
.87c0	85 24		sta $24		                sta tmp1
.87c2	b5 07		lda $07,x	                lda 7,x
.87c4	85 25		sta $25		                sta tmp1+1
.87c6					_compare_loop:
.87c6	b5 04		lda $04,x	                lda 4,x
.87c8	15 05		ora $05,x	                ora 5,x
.87ca	f0 2c		beq $87f8	                beq _str1_done
.87cc	b5 00		lda $00,x	                lda 0,x
.87ce	15 01		ora $01,x	                ora 1,x
.87d0	f0 3a		beq $880c	                beq _greater    ; Str2 empty first
.87d2					_check_letter:
.87d2	b2 24		lda ($24)	                lda (tmp1)
.87d4	d2 26		cmp ($26)	                cmp (tmp2)
.87d6	90 26		bcc $87fe	                bcc _less
.87d8	d0 32		bne $880c	                bne _greater
.87da					_next_letter:
.87da	e6 24		inc $24		                inc tmp1
.87dc	d0 02		bne $87e0	                bne +
.87de	e6 25		inc $25		                inc tmp1+1
.87e0					+
.87e0	e6 26		inc $26		                inc tmp2
.87e2	d0 02		bne $87e6	                bne +
.87e4	e6 27		inc $27		                inc tmp2+1
.87e6					+
.87e6	b5 04		lda $04,x	                lda 4,x
.87e8	d0 02		bne $87ec	                bne +
.87ea	d6 05		dec $05,x	                dec 5,x
.87ec					+
.87ec	d6 04		dec $04,x	                dec 4,x
.87ee	b5 00		lda $00,x	                lda 0,x
.87f0	d0 02		bne $87f4	                bne +
.87f2	d6 01		dec $01,x	                dec 1,x
.87f4					+
.87f4	d6 00		dec $00,x	                dec 0,x
.87f6	80 ce		bra $87c6	                bra _compare_loop
.87f8					_str1_done:
.87f8	b5 00		lda $00,x	                lda 0,x
.87fa	15 01		ora $01,x	                ora 1,x
.87fc	f0 08		beq $8806	                beq _equal      ; Both out of letters
.87fe					_less:
.87fe	a9 ff		lda #$ff	                lda #$FF
.8800	95 06		sta $06,x	                sta 6,x
.8802	95 07		sta $07,x	                sta 7,x
.8804	80 0c		bra $8812	                bra _done
.8806					_equal:
.8806	74 06		stz $06,x	                stz 6,x
.8808	74 07		stz $07,x	                stz 7,x
.880a	80 06		bra $8812	                bra _done
.880c					_greater:
.880c	a9 01		lda #$01	                lda #1
.880e	95 06		sta $06,x	                sta 6,x
.8810	74 07		stz $07,x	                stz 7,x
.8812					_done:
.8812	8a		txa		                txa
.8813	18		clc		                clc
.8814	69 06		adc #$06	                adc #6
.8816	aa		tax		                tax
.8817	60		rts		z_compare:      rts
.8818					xt_compile_comma:
.8818	20 5a d8	jsr $d85a	                jsr underflow_1
.881b	b5 01		lda $01,x	                lda 1,x                 ; MSB
.881d	48		pha		                pha
.881e	b5 00		lda $00,x	                lda 0,x
.8820	48		pha		                pha                     ; LSB
.8821	20 a3 92	jsr $92a3	                jsr xt_int_to_name      ; ( xt -- nt )
.8824	b5 00		lda $00,x	                lda 0,x
.8826	15 01		ora $01,x	                ora 1,x
.8828	d0 03		bne $882d	                bne _check_nt
.882a	4c 15 89	jmp $8915	                jmp _compile_as_jump
.882d					_check_nt:
.882d	b5 00		lda $00,x	                lda 0,x
.882f	85 2c		sta $2c		                sta tmptos
.8831	b5 01		lda $01,x	                lda 1,x
.8833	85 2d		sta $2d		                sta tmptos+1
.8835	f6 00		inc $00,x	                inc 0,x
.8837	d0 02		bne $883b	                bne +
.8839	f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.883b					+
.883b	a1 00		lda ($00,x)	                lda (0,x)
.883d	85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.883f	29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8841	f0 0d		beq $8850	                beq _compile_check
.8843	a5 2c		lda $2c		                lda tmptos
.8845	95 00		sta $00,x	                sta 0,x
.8847	a5 2d		lda $2d		                lda tmptos+1
.8849	95 01		sta $01,x	                sta 1,x
.884b	20 a0 a7	jsr $a7a0	                jsr xt_wordsize         ; ( nt -- u )
.884e	80 27		bra $8877	                bra _compile_as_code
.8850					_compile_check:
.8850	a5 28		lda $28		                lda tmp3
.8852	29 08		and #$08	                and #NN
.8854	f0 03		beq $8859	                beq _check_size_limit
.8856	4c 15 89	jmp $8915	                jmp _compile_as_jump    ; too far for BRA
.8859					_check_size_limit:
.8859	a5 2c		lda $2c		                lda tmptos
.885b	95 00		sta $00,x	                sta 0,x
.885d	a5 2d		lda $2d		                lda tmptos+1
.885f	95 01		sta $01,x	                sta 1,x
.8861	20 a0 a7	jsr $a7a0	                jsr xt_wordsize         ; ( nt -- u )
.8864	b5 01		lda $01,x	                lda 1,x
.8866	c5 1b		cmp $1b		                cmp nc_limit+1
.8868	90 0d		bcc $8877	                bcc _compile_as_code    ; user-defined limit MSB
.886a	d0 08		bne $8874	                bne _jumpto_compile_as_jump
.886c	b5 00		lda $00,x	                lda 0,x
.886e	c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.8870	90 05		bcc $8877	                bcc _compile_as_code    ; Allow native compiling for less
.8872	f0 03		beq $8877	                beq _compile_as_code    ; than or equal to the limit.
.8874					_jumpto_compile_as_jump:
.8874	4c 15 89	jmp $8915	                jmp _compile_as_jump    ; too far for BRA
.8877					_compile_as_code:
.8877	ca		dex		                dex
.8878	ca		dex		                dex                     ; ( -- u ? )
.8879	ca		dex		                dex
.887a	ca		dex		                dex                     ; ( -- u ? ? )
.887b	b5 04		lda $04,x	                lda 4,x
.887d	95 00		sta $00,x	                sta 0,x                 ; LSB of u
.887f	b5 05		lda $05,x	                lda 5,x
.8881	95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.8883	68		pla		                pla
.8884	95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8886	68		pla		                pla
.8887	95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.8889	a5 00		lda $00		                lda cp                  ; LSB of cp
.888b	95 02		sta $02,x	                sta 2,x
.888d	a5 01		lda $01		                lda cp+1
.888f	95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.8891	a0 00		ldy #$00	                ldy #0
.8893					_strip_loop:
.8893	b9 03 89	lda $8903,y	                lda _strip_table,y      ; LSB of first word
.8896	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8898	d0 07		bne $88a1	                bne _next_entry
.889a	b9 04 89	lda $8904,y	                lda _strip_table+1,y
.889d	d5 05		cmp $05,x	                cmp 5,x
.889f	f0 0c		beq $88ad	                beq _found_entry
.88a1					_next_entry:
.88a1	b9 03 89	lda $8903,y	                lda _strip_table,y      ; pointing to LSB
.88a4	19 04 89	ora $8904,y	                ora _strip_table+1,y    ; get MSB
.88a7	f0 22		beq $88cb	                beq _underflow_strip    ; table done, let's get out of here
.88a9	c8		iny		                iny
.88aa	c8		iny		                iny
.88ab	80 e6		bra $8893	                bra _strip_loop
.88ad					_found_entry:
.88ad	98		tya		                tya
.88ae	4a		lsr a		                lsr
.88af	a8		tay		                tay
.88b0	b9 0f 89	lda $890f,y	                lda _strip_size,y
.88b3	85 2c		sta $2c		                sta tmptos              ; save a copy
.88b5	18		clc		                clc
.88b6	75 04		adc $04,x	                adc 4,x
.88b8	95 04		sta $04,x	                sta 4,x
.88ba	90 02		bcc $88be	                bcc+
.88bc	f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.88be					+
.88be	06 2c		asl $2c		                asl tmptos
.88c0	38		sec		                sec
.88c1	b5 00		lda $00,x	                lda 0,x
.88c3	e5 2c		sbc $2c		                sbc tmptos
.88c5	95 00		sta $00,x	                sta 0,x
.88c7	b0 02		bcs $88cb	                bcs +
.88c9	d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.88cb					+
.88cb					_underflow_strip:
.88cb	a5 1c		lda $1c		                lda uf_strip
.88cd	05 1d		ora $1d		                ora uf_strip+1
.88cf	f0 1c		beq $88ed	                beq _specials_done
.88d1	a5 28		lda $28		                lda tmp3
.88d3	29 10		and #$10	                and #UF
.88d5	f0 16		beq $88ed	                beq _specials_done
.88d7	18		clc		                clc
.88d8	b5 04		lda $04,x	                lda 4,x
.88da	69 03		adc #$03	                adc #3
.88dc	95 04		sta $04,x	                sta 4,x
.88de	90 02		bcc $88e2	                bcc +
.88e0	f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.88e2					+
.88e2	38		sec		                sec
.88e3	b5 00		lda $00,x	                lda 0,x
.88e5	e9 03		sbc #$03	                sbc #3
.88e7	95 00		sta $00,x	                sta 0,x
.88e9	b0 02		bcs $88ed	                bcs +
.88eb	d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.88ed					+
.88ed					_specials_done:
.88ed	b5 01		lda $01,x	                lda 1,x                 ; MSB
.88ef	48		pha		                pha
.88f0	b5 00		lda $00,x	                lda 0,x                 ; LSB
.88f2	48		pha		                pha
.88f3	20 ed 95	jsr $95ed	                jsr xt_move
.88f6	18		clc		                clc
.88f7	68		pla		                pla                     ; LSB
.88f8	65 00		adc $00		                adc cp
.88fa	85 00		sta $00		                sta cp
.88fc	68		pla		                pla                     ; MSB
.88fd	65 01		adc $01		                adc cp+1
.88ff	85 01		sta $01		                sta cp+1
.8901	80 2c		bra $892f	                bra _done
.8903					_strip_table:
>8903	bd 9a a8 9a 9b a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>8909	cd a4 53 a4 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.890f					_strip_size:
>890f	04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.8915					_compile_as_jump:
.8915	a9 20		lda #$20	                lda #$20
.8917	92 00		sta ($00)	                sta (cp)
.8919	a0 01		ldy #$01	                ldy #1
.891b	68		pla		                pla             ; LSB
.891c	91 00		sta ($00),y	                sta (cp),y
.891e	c8		iny		                iny
.891f	68		pla		                pla             ; MSB
.8920	91 00		sta ($00),y	                sta (cp),y
.8922	a9 03		lda #$03	                lda #3
.8924	18		clc		                clc
.8925	65 00		adc $00		                adc cp
.8927	85 00		sta $00		                sta cp
.8929	90 02		bcc $892d	                bcc +
.892b	e6 01		inc $01		                inc cp+1
.892d					+
.892d	e8		inx		                inx             ; drop xt
.892e	e8		inx		                inx
.892f					_done:
.892f					z_compile_comma:
.892f	60		rts		                rts
.8930					xt_compile_only:
.8930	20 9c d7	jsr $d79c	                jsr current_to_dp
.8933	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8935	b1 02		lda ($02),y	                lda (dp),y
.8937	09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.8939	91 02		sta ($02),y	                sta (dp),y
.893b	60		rts		z_compile_only: rts
.893c					xt_value:
.893c					xt_constant:
.893c	20 5a d8	jsr $d85a	                jsr underflow_1
.893f	20 94 89	jsr $8994	                jsr xt_create
.8942	38		sec		                sec
.8943	a5 00		lda $00		                lda cp
.8945	e9 02		sbc #$02	                sbc #2
.8947	85 24		sta $24		                sta tmp1
.8949	a5 01		lda $01		                lda cp+1
.894b	e9 00		sbc #$00	                sbc #0
.894d	85 25		sta $25		                sta tmp1+1
.894f	a9 16		lda #$16	                lda #<doconst           ; LSB of DOCONST
.8951	92 24		sta ($24)	                sta (tmp1)
.8953	a0 01		ldy #$01	                ldy #1
.8955	a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.8957	91 24		sta ($24),y	                sta (tmp1),y
.8959	20 99 87	jsr $8799	                jsr xt_comma            ; drop through to adjust_z
.895c					adjust_z:
.895c	20 66 93	jsr $9366	                jsr xt_latestnt         ; gives us ( -- nt )
.895f	b5 00		lda $00,x	                lda 0,x
.8961	85 24		sta $24		                sta tmp1
.8963	b5 01		lda $01,x	                lda 1,x
.8965	85 25		sta $25		                sta tmp1+1
.8967	a0 06		ldy #$06	                ldy #6
.8969	b1 24		lda ($24),y	                lda (tmp1),y
.896b	18		clc		                clc
.896c	69 02		adc #$02	                adc #2
.896e	91 24		sta ($24),y	                sta (tmp1),y
.8970	c8		iny		                iny
.8971	b1 24		lda ($24),y	                lda (tmp1),y
.8973	69 00		adc #$00	                adc #0                  ; only need carry
.8975	91 24		sta ($24),y	                sta (tmp1),y
.8977	e8		inx		                inx
.8978	e8		inx		                inx
.8979					z_value:
.8979	60		rts		z_constant:     rts
.897a					xt_count:
.897a	20 5a d8	jsr $d85a	                jsr underflow_1
.897d	a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.897f	a8		tay		                tay
.8980	f6 00		inc $00,x	                inc 0,x         ; LSB
.8982	d0 02		bne $8986	                bne +
.8984	f6 01		inc $01,x	                inc 1,x         ; MSB
.8986	98		tya		+               tya
.8987	ca		dex		                dex
.8988	ca		dex		                dex
.8989	95 00		sta $00,x	                sta 0,x         ; LSB
.898b	74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.898d	60		rts		z_count:        rts
.898e					xt_cr:
.898e	a9 0a		lda #$0a	                lda #AscLF
.8990	20 21 8e	jsr $8e21	                jsr emit_a
.8993	60		rts		z_cr:           rts
.8994					xt_create:
.8994	20 0a 99	jsr $990a	                jsr xt_parse_name       ; ( addr u )
.8997	b5 00		lda $00,x	                lda 0,x
.8999	15 01		ora $01,x	                ora 1,x
.899b	d0 05		bne $89a2	                bne _got_name
.899d	a9 05		lda #$05	                lda #err_noname
.899f	4c 70 d8	jmp $d870	                jmp error
.89a2					_got_name:
.89a2	74 01		stz $01,x	                stz 1,x
.89a4	20 e3 a3	jsr $a3e3	                jsr xt_two_dup          ; ( addr u addr u )
.89a7	20 06 90	jsr $9006	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.89aa	b5 00		lda $00,x	                lda 0,x
.89ac	15 01		ora $01,x	                ora 1,x
.89ae	f0 1e		beq $89ce	                beq _new_name           ; We haven't seen this one before.
.89b0	e8		inx		                inx                     ; Drop flag (nt) from find-name.
.89b1	e8		inx		                inx
.89b2	24 20		bit $20		                bit status
.89b4	10 08		bpl $89be	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.89b6	a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.89b8	05 20		ora $20		                ora status
.89ba	85 20		sta $20		                sta status
.89bc	80 18		bra $89d6	                bra _process_name
.89be					_redefined_name:
.89be	a9 02		lda #$02	                lda #str_redefined
.89c0	20 86 d8	jsr $d886	                jsr print_string_no_lf
.89c3	20 e3 a3	jsr $a3e3	                jsr xt_two_dup           ; ( addr u addr u )
.89c6	20 2e a5	jsr $a52e	                jsr xt_type
.89c9	20 49 a1	jsr $a149	                jsr xt_space
.89cc	80 08		bra $89d6	                bra _process_name
.89ce					_new_name:
.89ce	e8		inx		                inx                     ; Drop flag (0) from find-name.
.89cf	e8		inx		                inx
.89d0	a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.89d2	25 20		and $20		                and status
.89d4	85 20		sta $20		                sta status
.89d6					_process_name:
.89d6	b5 00		lda $00,x	                lda 0,x
.89d8	85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.89da	a5 00		lda $00		                lda cp
.89dc	85 24		sta $24		                sta tmp1
.89de	a5 01		lda $01		                lda cp+1
.89e0	85 25		sta $25		                sta tmp1+1
.89e2	b5 00		lda $00,x	                lda 0,x
.89e4	18		clc		                clc
.89e5	69 08		adc #$08	                adc #8
.89e7	85 28		sta $28		                sta tmp3                ; total header length
.89e9	18		clc		                clc
.89ea	69 03		adc #$03	                adc #3
.89ec	95 00		sta $00,x	                sta 0,x
.89ee	74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.89f0	20 b4 82	jsr $82b4	                jsr xt_allot    ; ( addr )
.89f3	20 9c d7	jsr $d79c	                jsr current_to_dp
.89f6	a0 00		ldy #$00	                ldy #0
.89f8	a5 26		lda $26		                lda tmp2
.89fa	91 24		sta ($24),y	                sta (tmp1),y
.89fc	a9 08		lda #$08	                lda #NN
.89fe	09 20		ora #$20	                ora #HC
.8a00	c8		iny		                iny
.8a01	91 24		sta ($24),y	                sta (tmp1),y
.8a03	c8		iny		                iny
.8a04	a5 02		lda $02		                lda dp
.8a06	91 24		sta ($24),y	                sta (tmp1),y
.8a08	c8		iny		                iny
.8a09	a5 03		lda $03		                lda dp+1
.8a0b	91 24		sta ($24),y	                sta (tmp1),y
.8a0d	c8		iny		                iny
.8a0e	a5 25		lda $25		                lda tmp1+1
.8a10	85 03		sta $03		                sta dp+1
.8a12	a5 24		lda $24		                lda tmp1
.8a14	85 02		sta $02		                sta dp
.8a16	18		clc		                clc
.8a17	65 28		adc $28		                adc tmp3        ; add total header length
.8a19	91 24		sta ($24),y	                sta (tmp1),y
.8a1b	48		pha		                pha             ; we need this in the next step
.8a1c	c8		iny		                iny
.8a1d	a5 25		lda $25		                lda tmp1+1
.8a1f	69 00		adc #$00	                adc #0          ; only need the carry
.8a21	91 24		sta ($24),y	                sta (tmp1),y
.8a23	c8		iny		                iny
.8a24	68		pla		                pla             ; LSB of "z_" address
.8a25	18		clc		                clc
.8a26	69 03		adc #$03	                adc #3
.8a28	91 24		sta ($24),y	                sta (tmp1),y
.8a2a	88		dey		                dey             ; get the MSB of xt back
.8a2b	b1 24		lda ($24),y	                lda (tmp1),y
.8a2d	69 00		adc #$00	                adc #0          ; only need the carry
.8a2f	c8		iny		                iny
.8a30	c8		iny		                iny
.8a31	91 24		sta ($24),y	                sta (tmp1),y
.8a33	c8		iny		                iny
.8a34	b5 00		lda $00,x	                lda 0,x
.8a36	38		sec		                sec
.8a37	e9 08		sbc #$08	                sbc #8
.8a39	85 2c		sta $2c		                sta tmptos
.8a3b	b5 01		lda $01,x	                lda 1,x
.8a3d	e9 00		sbc #$00	                sbc #0          ; only need carry
.8a3f	85 2d		sta $2d		                sta tmptos+1
.8a41					_name_loop:
.8a41	b1 2c		lda ($2c),y	                lda (tmptos),y
.8a43	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8a45	b0 07		bcs $8a4e	                bcs _store_name
.8a47	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8a49	90 03		bcc $8a4e	                bcc _store_name
.8a4b	18		clc		                clc
.8a4c	69 20		adc #$20	                adc #$20
.8a4e					_store_name:
.8a4e	91 24		sta ($24),y	                sta (tmp1),y
.8a50	c8		iny		                iny
.8a51	c6 26		dec $26		                dec tmp2
.8a53	d0 ec		bne $8a41	                bne _name_loop
.8a55	a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a57	91 24		sta ($24),y	                sta (tmp1),y
.8a59	c8		iny		                iny
.8a5a	a9 5c		lda #$5c	                lda #<dovar
.8a5c	91 24		sta ($24),y	                sta (tmp1),y
.8a5e	c8		iny		                iny
.8a5f	a9 d7		lda #$d7	                lda #>dovar
.8a61	91 24		sta ($24),y	                sta (tmp1),y
.8a63	20 af d7	jsr $d7af	                jsr dp_to_current
.8a66	e8		inx		                inx
.8a67	e8		inx		                inx
.8a68	60		rts		z_create:       rts
.8a69					xt_d_minus:
.8a69	20 69 d8	jsr $d869	                jsr underflow_4 ; two double numbers
.8a6c	38		sec		                sec
.8a6d	b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a6f	f5 02		sbc $02,x	                sbc 2,x
.8a71	95 06		sta $06,x	                sta 6,x
.8a73	b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a75	f5 03		sbc $03,x	                sbc 3,x
.8a77	95 07		sta $07,x	                sta 7,x
.8a79	b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a7b	f5 00		sbc $00,x	                sbc 0,x
.8a7d	95 04		sta $04,x	                sta 4,x
.8a7f	b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a81	f5 01		sbc $01,x	                sbc 1,x
.8a83	95 05		sta $05,x	                sta 5,x
.8a85	e8		inx		                inx
.8a86	e8		inx		                inx
.8a87	e8		inx		                inx
.8a88	e8		inx		                inx
.8a89	60		rts		z_d_minus:      rts
.8a8a					xt_d_plus:
.8a8a	20 69 d8	jsr $d869	                jsr underflow_4 ; two double numbers
.8a8d	18		clc		                clc
.8a8e	b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a90	75 06		adc $06,x	                adc 6,x
.8a92	95 06		sta $06,x	                sta 6,x
.8a94	b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a96	75 07		adc $07,x	                adc 7,x
.8a98	95 07		sta $07,x	                sta 7,x
.8a9a	b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a9c	75 04		adc $04,x	                adc 4,x
.8a9e	95 04		sta $04,x	                sta 4,x
.8aa0	b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8aa2	75 05		adc $05,x	                adc 5,x
.8aa4	95 05		sta $05,x	                sta 5,x
.8aa6	e8		inx		                inx
.8aa7	e8		inx		                inx
.8aa8	e8		inx		                inx
.8aa9	e8		inx		                inx
.8aaa	60		rts		z_d_plus:       rts
.8aab					xt_d_to_s:
.8aab	20 5f d8	jsr $d85f	                jsr underflow_2
.8aae	e8		inx		                inx
.8aaf	e8		inx		                inx
.8ab0	60		rts		z_d_to_s:       rts
.8ab1					xt_dabs:
.8ab1	20 5f d8	jsr $d85f	                jsr underflow_2 ; double number
.8ab4	b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8ab6	10 17		bpl $8acf	                bpl _done       ; positive, we get off light
.8ab8	a0 00		ldy #$00	                ldy #0
.8aba	38		sec		                sec
.8abb	98		tya		                tya
.8abc	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8abe	95 02		sta $02,x	                sta 2,x
.8ac0	98		tya		                tya
.8ac1	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8ac3	95 03		sta $03,x	                sta 3,x
.8ac5	98		tya		                tya
.8ac6	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8ac8	95 00		sta $00,x	                sta 0,x
.8aca	98		tya		                tya
.8acb	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8acd	95 01		sta $01,x	                sta 1,x
.8acf					_done:
.8acf	60		rts		z_dabs:         rts
.8ad0					xt_decimal:
.8ad0	a9 0a		lda #$0a	                lda #10
.8ad2	85 18		sta $18		                sta base
.8ad4	64 19		stz $19		                stz base+1              ; paranoid
.8ad6	60		rts		z_decimal:      rts
.8ad7					xt_defer:
.8ad7	20 94 89	jsr $8994	                jsr xt_create
.8ada	a5 00		lda $00		                lda cp          ; LSB
.8adc	38		sec		                sec
.8add	e9 02		sbc #$02	                sbc #2
.8adf	85 24		sta $24		                sta tmp1
.8ae1	a5 01		lda $01		                lda cp+1        ; MSB
.8ae3	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8ae5	85 25		sta $25		                sta tmp1+1
.8ae7	a0 00		ldy #$00	                ldy #0
.8ae9	a9 2a		lda #$2a	                lda #<dodefer   ; LSB
.8aeb	91 24		sta ($24),y	                sta (tmp1),y
.8aed	c8		iny		                iny
.8aee	a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8af0	91 24		sta ($24),y	                sta (tmp1),y
.8af2	a9 3e		lda #$3e	                lda #<defer_error
.8af4	92 00		sta ($00)	                sta (cp)
.8af6	e6 00		inc $00		                inc cp
.8af8	d0 02		bne $8afc	                bne +
.8afa	e6 01		inc $01		                inc cp+1
.8afc					+
.8afc	a9 d7		lda #$d7	                lda #>defer_error
.8afe	92 00		sta ($00)	                sta (cp)
.8b00	e6 00		inc $00		                inc cp
.8b02	d0 02		bne $8b06	                bne +
.8b04	e6 01		inc $01		                inc cp+1
.8b06					+
.8b06	20 5c 89	jsr $895c	                jsr adjust_z    ; adjust header to correct length
.8b09	60		rts		z_defer:        rts
.8b0a					xt_defer_fetch:
.8b0a	20 b8 a2	jsr $a2b8	                jsr xt_to_body
.8b0d	20 ab 8f	jsr $8fab	                jsr xt_fetch
.8b10	60		rts		z_defer_fetch:  rts
.8b11					xt_defer_store:
.8b11	20 b8 a2	jsr $a2b8	                jsr xt_to_body
.8b14	20 b8 a1	jsr $a1b8	                jsr xt_store
.8b17	60		rts		z_defer_store:  rts
.8b18					xt_definitions:
.8b18	a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8b1a	b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8b1c	a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8b1e	91 1e		sta ($1e),y	                sta (up),y
.8b20	60		rts		z_definitions:  rts
.8b21					xt_depth:
.8b21	a9 78		lda #$78	                lda #dsp0
.8b23	86 2a		stx $2a		                stx tmpdsp
.8b25	38		sec		                sec
.8b26	e5 2a		sbc $2a		                sbc tmpdsp
.8b28	4a		lsr a		                lsr
.8b29	ca		dex		                dex
.8b2a	ca		dex		                dex
.8b2b	95 00		sta $00,x	                sta 0,x
.8b2d	74 01		stz $01,x	                stz 1,x
.8b2f	60		rts		z_depth:        rts
.8b30					xt_digit_question:
.8b30	20 5a d8	jsr $d85a	                jsr underflow_1
.8b33	ca		dex		                dex
.8b34	ca		dex		                dex
.8b35	74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8b37	74 01		stz $01,x	                stz 1,x
.8b39	74 03		stz $03,x	                stz 3,x                 ; paranoid
.8b3b	b5 02		lda $02,x	                lda 2,x
.8b3d	c9 30		cmp #$30	                cmp #'0'
.8b3f	90 23		bcc $8b64	                bcc _done               ; failure flag already set
.8b41	c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8b43	90 12		bcc $8b57	                bcc _checkbase
.8b45	c9 41		cmp #$41	                cmp #'A'
.8b47	90 1b		bcc $8b64	                bcc _done               ; failure flag is already set
.8b49	c9 61		cmp #$61	                cmp #'a'
.8b4b	90 07		bcc $8b54	                bcc _case_done          ; not lower case, too low
.8b4d	c9 7b		cmp #$7b	                cmp #'z'+1
.8b4f	b0 03		bcs $8b54	                bcs _case_done          ; not lower case, too high
.8b51	18		clc		                clc                     ; just right
.8b52	69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b54					_case_done:
.8b54	38		sec		                sec
.8b55	e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b57					_checkbase:
.8b57	38		sec		                sec
.8b58	e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b5a	c5 18		cmp $18		                cmp base
.8b5c	b0 06		bcs $8b64	                bcs _done               ; already have false flag
.8b5e	95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b60	d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b62	d6 01		dec $01,x	                dec 1,x
.8b64					_done:
.8b64					z_digit_question:
.8b64	60		rts		                rts
.8b65					xt_disasm:
.8b65	20 5f d8	jsr $d85f	                jsr underflow_2
.8b68	20 02 ad	jsr $ad02	                jsr disassembler
.8b6b	60		rts		z_disasm:       rts
.8b6c					xt_dnegate:
.8b6c	20 5f d8	jsr $d85f	                jsr underflow_2 ; double number
.8b6f	a0 00		ldy #$00	     		ldy #0
.8b71	38		sec		                sec
.8b72	98		tya		                tya
.8b73	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b75	95 02		sta $02,x	                sta 2,x
.8b77	98		tya		                tya
.8b78	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b7a	95 03		sta $03,x	                sta 3,x
.8b7c	98		tya		                tya
.8b7d	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b7f	95 00		sta $00,x	                sta 0,x
.8b81	98		tya		                tya
.8b82	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b84	95 01		sta $01,x	                sta 1,x
.8b86	60		rts		z_dnegate:      rts
.8b87					xt_question_do:
.8b87	a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b89	85 24		sta $24		                sta tmp1
.8b8b	80 02		bra $8b8f	                bra do_common           ; skip flag for DO
.8b8d					xt_do:
.8b8d	64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b8f					do_common:
.8b8f	ca		dex		                dex
.8b90	ca		dex		                dex
.8b91	a5 00		lda $00		                lda cp
.8b93	95 00		sta $00,x	                sta 0,x                 ; LSB
.8b95	a5 01		lda $01		                lda cp+1
.8b97	95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b99	a9 05		lda #$05	                lda #5                  ; we don't really care about the value,
.8b9b	a8		tay		                tay                     ; so we use 5 to be tricky
.8b9c					_loop:
.8b9c	91 00		sta ($00),y	                sta (CP),y
.8b9e	88		dey		                dey
.8b9f	10 fb		bpl $8b9c	                bpl _loop
.8ba1	1a		inc a		                ina             ; we used 5 as a dummy value, this is why
.8ba2	18		clc		                clc
.8ba3	65 00		adc $00		                adc CP
.8ba5	85 00		sta $00		                sta CP
.8ba7	90 02		bcc $8bab	                bcc +
.8ba9	e6 01		inc $01		                inc CP+1
.8bab					+
.8bab	a5 24		lda $24		                lda tmp1
.8bad	f0 17		beq $8bc6	                beq _compile_do
.8baf	a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8bb1	5a		phy		                phy             ; save counter to calculate new CP
.8bb2					-
.8bb2	b9 0c 8c	lda $8c0c,y	                lda question_do_runtime,y
.8bb5	91 00		sta ($00),y	                sta (cp),y
.8bb7	88		dey		                dey
.8bb8	10 f8		bpl $8bb2	                bpl -
.8bba	68		pla		                pla             ; retrieve counter
.8bbb	18		clc		                clc
.8bbc	65 00		adc $00		                adc cp
.8bbe	85 00		sta $00		                sta cp
.8bc0	a5 01		lda $01		                lda cp+1
.8bc2	69 00		adc #$00	                adc #0          ; only care about carry
.8bc4	85 01		sta $01		                sta cp+1        ; fall through to _compile_do
.8bc6					_compile_do:
.8bc6	a0 24		ldy #$24	                ldy #do_runtime_end-do_runtime  ; counter
.8bc8	5a		phy		                phy             ; save counter to calculate new CP
.8bc9					-
.8bc9	b9 e8 8b	lda $8be8,y	                lda do_runtime,y
.8bcc	91 00		sta ($00),y	                sta (cp),y
.8bce	88		dey		                dey
.8bcf	10 f8		bpl $8bc9	                bpl -
.8bd1	68		pla		                pla             ; retrieve counter
.8bd2	18		clc		                clc
.8bd3	65 00		adc $00		                adc cp
.8bd5	85 00		sta $00		                sta cp
.8bd7	a5 01		lda $01		                lda cp+1
.8bd9	69 00		adc #$00	                adc #0          ; only care about carry
.8bdb	85 01		sta $01		                sta cp+1
.8bdd	ca		dex		                dex
.8bde	ca		dex		                dex
.8bdf	a5 00		lda $00		                lda CP          ; LSB
.8be1	95 00		sta $00,x	                sta 0,x
.8be3	a5 01		lda $01		                lda CP+1        ; MSB
.8be5	95 01		sta $01,x	                sta 1,x
.8be7					z_question_do:
.8be7	60		rts		z_do:           rts
.8be8					do_runtime:
.8be8	38		sec		                sec
.8be9	a9 00		lda #$00	                lda #0
.8beb	f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8bed	95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8bef	a9 80		lda #$80	                lda #$80
.8bf1	f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8bf3	95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8bf5	48		pha		                pha             ; FUFA replaces limit on R stack
.8bf6	b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8bf8	48		pha		                pha
.8bf9	18		clc		                clc
.8bfa	b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8bfc	75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8bfe	95 00		sta $00,x	                sta 0,x
.8c00	b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8c02	75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8c04	48		pha		                pha
.8c05	b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8c07	48		pha		                pha
.8c08	e8		inx		                inx
.8c09	e8		inx		                inx
.8c0a	e8		inx		                inx
.8c0b	e8		inx		                inx             ; no RTS because this is copied into code
.8c0c					do_runtime_end:
.8c0c					question_do_runtime:
.8c0c	20 e3 a3	jsr $a3e3	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8c0f	20 f9 8e	jsr $8ef9	                jsr xt_equal            ; ( -- n1 n2 f )
.8c12	b5 00		lda $00,x	                lda 0,x
.8c14	15 01		ora $01,x	                ora 1,x
.8c16	f0 06		beq $8c1e	                beq _do_do
.8c18	8a		txa		                txa
.8c19	18		clc		                clc
.8c1a	69 06		adc #$06	                adc #6
.8c1c	aa		tax		                tax
.8c1d	60		rts		                rts
.8c1e					_do_do:
.8c1e	e8		inx		                inx             ; clear flag from EQUAL off stack
.8c1f	e8		inx		                inx             ; no RTS because this is copied into code
.8c20					question_do_runtime_end:
.8c20					xt_does:
.8c20	a0 8c		ldy #$8c	                ldy #>does_runtime
.8c22	a9 2f		lda #$2f	                lda #<does_runtime
.8c24	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.8c27	a0 d7		ldy #$d7	                ldy #>dodoes
.8c29	a9 43		lda #$43	                lda #<dodoes
.8c2b	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.8c2e	60		rts		z_does:         rts
.8c2f					does_runtime:
.8c2f	7a		ply		                ply             ; LSB
.8c30	68		pla		                pla             ; MSB
.8c31	c8		iny		                iny
.8c32	d0 01		bne $8c35	                bne +
.8c34	1a		inc a		                ina
.8c35					+
.8c35	84 24		sty $24		                sty tmp1
.8c37	85 25		sta $25		                sta tmp1+1
.8c39	20 9c d7	jsr $d79c	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8c3c	a5 02		lda $02		                lda dp
.8c3e	18		clc		                clc
.8c3f	69 04		adc #$04	                adc #4
.8c41	85 26		sta $26		                sta tmp2
.8c43	a5 03		lda $03		                lda dp+1
.8c45	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c47	85 27		sta $27		                sta tmp2+1
.8c49	b2 26		lda ($26)	                lda (tmp2)
.8c4b	18		clc		                clc
.8c4c	69 01		adc #$01	                adc #1
.8c4e	85 28		sta $28		                sta tmp3
.8c50	a0 01		ldy #$01	                ldy #1
.8c52	b1 26		lda ($26),y	                lda (tmp2),y
.8c54	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c56	85 29		sta $29		                sta tmp3+1
.8c58	a5 24		lda $24		                lda tmp1        ; LSB
.8c5a	92 28		sta ($28)	                sta (tmp3)
.8c5c	a5 25		lda $25		                lda tmp1+1
.8c5e	91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8c60	60		rts		                rts
.8c61					xt_dot:
.8c61	20 5a d8	jsr $d85a	                jsr underflow_1
.8c64	20 da 8d	jsr $8dda	                jsr xt_dup                      ; ( n n )
.8c67	20 42 81	jsr $8142	                jsr xt_abs                      ; ( n u )
.8c6a	20 d3 a7	jsr $a7d3	                jsr xt_zero                     ; ( n u 0 )
.8c6d	20 85 93	jsr $9385	                jsr xt_less_number_sign         ; ( n u 0 )
.8c70	20 09 98	jsr $9809	                jsr xt_number_sign_s            ; ( n ud )
.8c73	20 82 9b	jsr $9b82	                jsr xt_rot                      ; ( ud n )
.8c76	20 12 a0	jsr $a012	                jsr xt_sign                     ; ( ud )
.8c79	20 e7 97	jsr $97e7	                jsr xt_number_sign_greater      ; ( addr u )
.8c7c	20 2e a5	jsr $a52e	                jsr xt_type
.8c7f	20 49 a1	jsr $a149	                jsr xt_space
.8c82	60		rts		z_dot:          rts
.8c83					xt_dot_paren:
.8c83	ca		dex		                dex
.8c84	ca		dex		                dex
.8c85	a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c87	95 00		sta $00,x	                sta 0,x
.8c89	74 01		stz $01,x	                stz 1,x
.8c8b	20 65 99	jsr $9965	                jsr xt_parse
.8c8e	20 2e a5	jsr $a52e	                jsr xt_type
.8c91	60		rts		z_dot_paren:    rts
.8c92					xt_dot_quote:
.8c92	20 7a 9d	jsr $9d7a	                jsr xt_s_quote
.8c95	a0 a5		ldy #$a5	                ldy #>xt_type
.8c97	a9 2e		lda #$2e	                lda #<xt_type
.8c99	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.8c9c	60		rts		z_dot_quote:    rts
.8c9d					xt_dot_r:
.8c9d	20 5f d8	jsr $d85f	                jsr underflow_2
.8ca0	20 9b a3	jsr $a39b	                jsr xt_to_r
.8ca3	20 da 8d	jsr $8dda	                jsr xt_dup
.8ca6	20 42 81	jsr $8142	                jsr xt_abs
.8ca9	20 d3 a7	jsr $a7d3	                jsr xt_zero
.8cac	20 85 93	jsr $9385	                jsr xt_less_number_sign
.8caf	20 09 98	jsr $9809	                jsr xt_number_sign_s
.8cb2	20 82 9b	jsr $9b82	                jsr xt_rot
.8cb5	20 12 a0	jsr $a012	                jsr xt_sign
.8cb8	20 e7 97	jsr $97e7	                jsr xt_number_sign_greater
.8cbb	20 bd 9a	jsr $9abd	                jsr xt_r_from
.8cbe	20 be 98	jsr $98be	                jsr xt_over
.8cc1	20 7b 95	jsr $957b	                jsr xt_minus
.8cc4	20 4f a1	jsr $a14f	                jsr xt_spaces
.8cc7	20 2e a5	jsr $a52e	                jsr xt_type
.8cca	60		rts		z_dot_r:        rts
.8ccb					xt_dot_s:
.8ccb	20 21 8b	jsr $8b21	                jsr xt_depth    ; ( -- u )
.8cce	a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8cd0	20 21 8e	jsr $8e21	                jsr emit_a
.8cd3	b5 00		lda $00,x	                lda 0,x
.8cd5	48		pha		                pha
.8cd6	ca		dex		                dex             ; DUP
.8cd7	ca		dex		                dex
.8cd8	95 00		sta $00,x	                sta 0,x
.8cda	74 01		stz $01,x	                stz 1,x
.8cdc	20 a6 d8	jsr $d8a6	                jsr print_u
.8cdf	a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8ce1	20 21 8e	jsr $8e21	                jsr emit_a
.8ce4	a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8ce6	20 21 8e	jsr $8e21	                jsr emit_a
.8ce9	e8		inx		                inx
.8cea	e8		inx		                inx
.8ceb	e0 78		cpx #$78	                cpx #dsp0
.8ced	f0 1e		beq $8d0d	                beq _done
.8cef					_have_stack:
.8cef	7a		ply		                ply
.8cf0	a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8cf2	85 28		sta $28		                sta tmp3
.8cf4	64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8cf6					_loop:
.8cf6	ca		dex		                dex
.8cf7	ca		dex		                dex
.8cf8	b2 28		lda ($28)	                lda (tmp3)
.8cfa	95 01		sta $01,x	                sta 1,x
.8cfc	c6 28		dec $28		                dec tmp3
.8cfe	b2 28		lda ($28)	                lda (tmp3)
.8d00	95 00		sta $00,x	                sta 0,x
.8d02	c6 28		dec $28		                dec tmp3
.8d04	5a		phy		                phy
.8d05	20 61 8c	jsr $8c61	                jsr xt_dot
.8d08	7a		ply		                ply
.8d09	88		dey		                dey
.8d0a	d0 ea		bne $8cf6	                bne _loop
.8d0c	48		pha		                pha             ; dummy to balance stack
.8d0d					_done:
.8d0d	68		pla		                pla
.8d0e	60		rts		z_dot_s:        rts
.8d0f					xt_d_dot:
.8d0f	20 5f d8	jsr $d85f	                jsr underflow_2
.8d12	20 b8 a3	jsr $a3b8	                jsr xt_tuck
.8d15	20 b1 8a	jsr $8ab1	                jsr xt_dabs
.8d18	20 85 93	jsr $9385	                jsr xt_less_number_sign
.8d1b	20 09 98	jsr $9809	                jsr xt_number_sign_s
.8d1e	20 82 9b	jsr $9b82	                jsr xt_rot
.8d21	20 12 a0	jsr $a012	                jsr xt_sign
.8d24	20 e7 97	jsr $97e7	                jsr xt_number_sign_greater
.8d27	20 2e a5	jsr $a52e	                jsr xt_type
.8d2a	20 49 a1	jsr $a149	                jsr xt_space
.8d2d	60		rts		z_d_dot:        rts
.8d2e					xt_d_dot_r:
.8d2e	20 64 d8	jsr $d864	                jsr underflow_3
.8d31	20 9b a3	jsr $a39b	                jsr xt_to_r
.8d34	20 b8 a3	jsr $a3b8	                jsr xt_tuck
.8d37	20 b1 8a	jsr $8ab1	                jsr xt_dabs
.8d3a	20 85 93	jsr $9385	                jsr xt_less_number_sign
.8d3d	20 09 98	jsr $9809	                jsr xt_number_sign_s
.8d40	20 82 9b	jsr $9b82	                jsr xt_rot
.8d43	20 12 a0	jsr $a012	                jsr xt_sign
.8d46	20 e7 97	jsr $97e7	                jsr xt_number_sign_greater
.8d49	20 bd 9a	jsr $9abd	                jsr xt_r_from
.8d4c	20 be 98	jsr $98be	                jsr xt_over
.8d4f	20 7b 95	jsr $957b	                jsr xt_minus
.8d52	20 4f a1	jsr $a14f	                jsr xt_spaces
.8d55	20 2e a5	jsr $a52e	                jsr xt_type
.8d58	60		rts		z_d_dot_r:      rts
.8d59					xt_drop:
.8d59	20 5a d8	jsr $d85a	                jsr underflow_1
.8d5c	e8		inx		                inx
.8d5d	e8		inx		                inx
.8d5e	60		rts		z_drop:         rts
.8d5f					xt_dump:
.8d5f	20 5f d8	jsr $d85f	                jsr underflow_2
.8d62					_row:
.8d62	a0 10		ldy #$10	                ldy #16
.8d64	64 26		stz $26		                stz tmp2
.8d66	20 8e 89	jsr $898e	                jsr xt_cr
.8d69	b5 03		lda $03,x	                lda 3,x
.8d6b	20 6a d7	jsr $d76a	                jsr byte_to_ascii
.8d6e	b5 02		lda $02,x	                lda 2,x
.8d70	20 6a d7	jsr $d76a	                jsr byte_to_ascii
.8d73	20 49 a1	jsr $a149	                jsr xt_space
.8d76	20 49 a1	jsr $a149	                jsr xt_space
.8d79					_loop:
.8d79	b5 00		lda $00,x	                lda 0,x
.8d7b	15 01		ora $01,x	                ora 1,x
.8d7d	f0 39		beq $8db8	                beq _all_printed
.8d7f	a1 02		lda ($02,x)	                lda (2,x)
.8d81	48		pha		                pha                     ; byte_to_ascii destroys A
.8d82	20 6a d7	jsr $d76a	                jsr byte_to_ascii
.8d85	20 49 a1	jsr $a149	                jsr xt_space
.8d88	68		pla		                pla
.8d89	20 40 d8	jsr $d840	                jsr is_printable
.8d8c	b0 02		bcs $8d90	                bcs _printable
.8d8e	a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d90					_printable:
.8d90	5a		phy		                phy                     ; save counter
.8d91	a4 26		ldy $26		                ldy tmp2
.8d93	91 00		sta ($00),y	                sta (cp),y
.8d95	e6 26		inc $26		                inc tmp2
.8d97	7a		ply		                ply
.8d98	c0 09		cpy #$09	                cpy #9
.8d9a	d0 03		bne $8d9f	                bne _next_char
.8d9c	20 49 a1	jsr $a149	                jsr xt_space
.8d9f					_next_char:
.8d9f	f6 02		inc $02,x	                inc 2,x
.8da1	d0 02		bne $8da5	                bne _counter
.8da3	f6 03		inc $03,x	                inc 3,x
.8da5					_counter:
.8da5	b5 00		lda $00,x	                lda 0,x
.8da7	d0 02		bne $8dab	                bne +
.8da9	d6 01		dec $01,x	                dec 1,x
.8dab					+
.8dab	d6 00		dec $00,x	                dec 0,x
.8dad	88		dey		                dey
.8dae	d0 c9		bne $8d79	                bne _loop               ; next byte
.8db0	20 49 a1	jsr $a149	                jsr xt_space
.8db3	20 c6 8d	jsr $8dc6	                jsr dump_print_ascii
.8db6	80 aa		bra $8d62	                bra _row                ; new row
.8db8					_all_printed:
.8db8	a5 26		lda $26		                lda tmp2
.8dba	f0 06		beq $8dc2	                beq _done
.8dbc	20 49 a1	jsr $a149	                jsr xt_space
.8dbf	20 c6 8d	jsr $8dc6	                jsr dump_print_ascii
.8dc2					_done:
.8dc2	20 db a3	jsr $a3db	                jsr xt_two_drop         ; one byte less than 4x INX
.8dc5	60		rts		z_dump:         rts
.8dc6					dump_print_ascii:
.8dc6	a0 00		ldy #$00	                ldy #0
.8dc8					_ascii_loop:
.8dc8	b1 00		lda ($00),y	                lda (cp),y
.8dca	20 21 8e	jsr $8e21	                jsr emit_a
.8dcd	c8		iny		                iny
.8dce	c0 08		cpy #$08	                cpy #8
.8dd0	d0 03		bne $8dd5	                bne +
.8dd2	20 49 a1	jsr $a149	                jsr xt_space
.8dd5					+
.8dd5	c6 26		dec $26		                dec tmp2
.8dd7	d0 ef		bne $8dc8	                bne _ascii_loop
.8dd9	60		rts		                rts
.8dda					xt_dup:
.8dda	20 5a d8	jsr $d85a	                jsr underflow_1
.8ddd	ca		dex		                dex
.8dde	ca		dex		                dex
.8ddf	b5 02		lda $02,x	                lda 2,x         ; LSB
.8de1	95 00		sta $00,x	                sta 0,x
.8de3	b5 03		lda $03,x	                lda 3,x         ; MSB
.8de5	95 01		sta $01,x	                sta 1,x
.8de7	60		rts		z_dup:          rts
.8de8					xt_ed:
.8de8	20 ad b5	jsr $b5ad	                jsr ed6502      ; kept in separate file
.8deb	60		rts		z_ed:           rts
.8dec					xt_else:
.8dec					xt_endof:
.8dec	a0 8e		ldy #$8e	                ldy #>branch_runtime
.8dee	a9 06		lda #$06	                lda #<branch_runtime
.8df0	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.8df3	20 9d 91	jsr $919d	                jsr xt_here
.8df6	20 d3 a7	jsr $a7d3	                jsr xt_zero
.8df9	20 99 87	jsr $8799	                jsr xt_comma
.8dfc	20 9d 91	jsr $919d	                jsr xt_here
.8dff	20 82 9b	jsr $9b82	                jsr xt_rot
.8e02	20 b8 a1	jsr $a1b8	                jsr xt_store
.8e05					z_else:
.8e05					z_endof:
.8e05	60		rts		                rts
.8e06					branch_runtime:
.8e06	68		pla		                pla
.8e07	85 22		sta $22		                sta tmpbranch
.8e09	68		pla		                pla
.8e0a	85 23		sta $23		                sta tmpbranch+1
.8e0c	a0 01		ldy #$01	                ldy #1
.8e0e	b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8e10	85 24		sta $24		                sta tmp1
.8e12	c8		iny		                iny
.8e13	b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8e15	85 25		sta $25		                sta tmp1+1
.8e17	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8e1a					xt_emit:
.8e1a	20 5a d8	jsr $d85a	                jsr underflow_1
.8e1d	b5 00		lda $00,x	                lda 0,x
.8e1f	e8		inx		                inx
.8e20	e8		inx		                inx
.8e21					emit_a:
.8e21	6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8e24					z_emit:
.8e24					xt_empty_buffers:
.8e24	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8e26	a9 00		lda #$00	                lda #0
.8e28	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8e2a					z_empty_buffers:
.8e2a	60		rts		                rts
.8e2b					xt_endcase:
.8e2b	a0 8d		ldy #$8d	                ldy #>xt_drop
.8e2d	a9 59		lda #$59	                lda #<xt_drop
.8e2f	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.8e32					_endcase_loop:
.8e32	b5 00		lda $00,x	                lda 0,x
.8e34	15 01		ora $01,x	                ora 1,x
.8e36	f0 05		beq $8e3d	                beq _done
.8e38	20 ed a1	jsr $a1ed	                jsr xt_then
.8e3b	80 f5		bra $8e32	                bra _endcase_loop
.8e3d					_done:
.8e3d	e8		inx		                inx
.8e3e	e8		inx		                inx
.8e3f	60		rts		z_endcase:      rts
.8e40					xt_environment_q:
.8e40	20 5a d8	jsr $d85a	                jsr underflow_1
.8e43	a0 00		ldy #$00	                ldy #00                 ; counter for table
.8e45	5a		phy		                phy
.8e46					_table_loop:
.8e46	20 e3 a3	jsr $a3e3	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e49	ca		dex		                dex
.8e4a	ca		dex		                dex                     ; ( addr u addr u ? )
.8e4b	b9 bd 8e	lda $8ebd,y	                lda env_table_single,y
.8e4e	95 00		sta $00,x	                sta 0,x
.8e50	c8		iny		                iny
.8e51	b9 bd 8e	lda $8ebd,y	                lda env_table_single,y
.8e54	95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e56	c8		iny		                iny
.8e57	15 00		ora $00,x	                ora 0,x
.8e59	f0 4d		beq $8ea8	                beq _table_done
.8e5b	5a		phy		                phy                     ; save Y, which is used by COUNT
.8e5c	20 7a 89	jsr $897a	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e5f	20 b3 87	jsr $87b3	                jsr xt_compare          ; ( addr u f )
.8e62	7a		ply		                ply
.8e63	b5 00		lda $00,x	                lda 0,x
.8e65	15 01		ora $01,x	                ora 1,x
.8e67	f0 04		beq $8e6d	                beq _got_result
.8e69	e8		inx		                inx                     ; DROP, now ( addr u )
.8e6a	e8		inx		                inx
.8e6b	80 d9		bra $8e46	                bra _table_loop
.8e6d					_got_result:
.8e6d	e8		inx		                inx                     ; drop flag, now ( addr u )
.8e6e	e8		inx		                inx
.8e6f	88		dey		                dey                     ; go back to index we had
.8e70	88		dey		                dey
.8e71	68		pla		                pla
.8e72	d0 0d		bne $8e81	                bne _double_result
.8e74	b9 db 8e	lda $8edb,y	                lda env_results_single,y
.8e77	95 02		sta $02,x	                sta 2,x
.8e79	c8		iny		                iny
.8e7a	b9 db 8e	lda $8edb,y	                lda env_results_single,y
.8e7d	95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e7f	80 1f		bra $8ea0	                bra _set_flag
.8e81					_double_result:
.8e81	ca		dex		                dex                     ; ( addr u ? )
.8e82	ca		dex		                dex
.8e83	98		tya		                tya
.8e84	38		sec		                sec
.8e85	e9 18		sbc #$18	                sbc #24
.8e87	0a		asl a		                asl
.8e88	a8		tay		                tay
.8e89	b9 f1 8e	lda $8ef1,y	                lda env_results_double,y
.8e8c	95 02		sta $02,x	                sta 2,x
.8e8e	c8		iny		                iny
.8e8f	b9 f1 8e	lda $8ef1,y	                lda env_results_double,y
.8e92	95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e94	c8		iny		                iny
.8e95	b9 f1 8e	lda $8ef1,y	                lda env_results_double,y
.8e98	95 04		sta $04,x	                sta 4,x
.8e9a	c8		iny		                iny
.8e9b	b9 f1 8e	lda $8ef1,y	                lda env_results_double,y
.8e9e	95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8ea0					_set_flag:
.8ea0	a9 ff		lda #$ff	                lda #$ff
.8ea2	95 00		sta $00,x	                sta 0,x
.8ea4	95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8ea6	80 14		bra $8ebc	                bra _done
.8ea8					_table_done:
.8ea8	68		pla		                pla
.8ea9	d0 09		bne $8eb4	                bne _no_match
.8eab	1a		inc a		                ina
.8eac	48		pha		                pha
.8ead	8a		txa		                txa
.8eae	18		clc		                clc
.8eaf	69 06		adc #$06	                adc #6                  ; skip six bytes
.8eb1	aa		tax		                tax                     ; ( addr u )
.8eb2	80 92		bra $8e46	                bra _table_loop
.8eb4					_no_match:
.8eb4	8a		txa		                txa
.8eb5	18		clc		                clc
.8eb6	69 0a		adc #$0a	                adc #10
.8eb8	aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8eb9	20 a4 8f	jsr $8fa4	                jsr xt_false
.8ebc					_done:
.8ebc					z_environment_q:
.8ebc	60		rts		                rts
.8ebd					env_table_single:
>8ebd	7d d6 8d d6 93 d6 98 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8ec5	aa d6
>8ec7	b2 d6 bb d6 c1 d6 c7 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8ecf	da d6 e6 d6 00 00		        .word envs_sc, envs_wl, 0000
.8ed5					env_table_double:
>8ed5	f0 d6 f6 d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8edb					env_results_single:
>8edb	ff 7f				        .word $7FFF     ; /COUNTED-STRING
>8edd	ff 00				        .word $00FF     ; /HOLD
>8edf	54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8ee1	08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8ee3	00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8ee5	ff 00				        .word $00FF     ; MAX-CHAR
>8ee7	ff 7f				        .word $7FFF     ; MAX-N
>8ee9	ff ff				        .word $FFFF     ; MAX-U
>8eeb	80 00				        .word $0080     ; RETURN-STACK-CELLS
>8eed	20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8eef	09 00				        .word $0009     ; WORDLISTS
.8ef1					env_results_double:
>8ef1	ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8ef5	ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8ef9					xt_equal:
.8ef9	20 5f d8	jsr $d85f	                jsr underflow_2
.8efc	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8efe	d5 02		cmp $02,x	                cmp 2,x
.8f00	d0 0a		bne $8f0c	                bne _false
.8f02	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f04	d5 03		cmp $03,x	                cmp 3,x
.8f06	d0 04		bne $8f0c	                bne _false
.8f08	a9 ff		lda #$ff	                lda #$ff
.8f0a	80 02		bra $8f0e	                bra _done
.8f0c	a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8f0e	95 02		sta $02,x	_done:          sta 2,x
.8f10	95 03		sta $03,x	                sta 3,x
.8f12	e8		inx		                inx
.8f13	e8		inx		                inx
.8f14	60		rts		z_equal:        rts
.8f15					xt_blank:
.8f15	ca		dex		                dex
.8f16	ca		dex		                dex
.8f17	a9 20		lda #$20	                lda #AscSP
.8f19	95 00		sta $00,x	                sta 0,x
.8f1b	74 01		stz $01,x	                stz 1,x
.8f1d	80 06		bra $8f25	                bra xt_fill     ; skip over code for ERASE
.8f1f					xt_erase:
.8f1f	ca		dex		                dex
.8f20	ca		dex		                dex
.8f21	74 00		stz $00,x	                stz 0,x
.8f23	74 01		stz $01,x	                stz 1,x
.8f25					xt_fill:
.8f25	20 64 d8	jsr $d864	                jsr underflow_3
.8f28	b5 04		lda $04,x	                lda 4,x         ; LSB
.8f2a	85 24		sta $24		                sta tmp1
.8f2c	b5 05		lda $05,x	                lda 5,x
.8f2e	85 25		sta $25		                sta tmp1+1
.8f30	b5 02		lda $02,x	                lda 2,x
.8f32	85 26		sta $26		                sta tmp2
.8f34	b5 03		lda $03,x	                lda 3,x
.8f36	85 27		sta $27		                sta tmp2+1
.8f38	b5 00		lda $00,x	                lda 0,x
.8f3a	a8		tay		                tay
.8f3b					_loop:
.8f3b	a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8f3d	c5 25		cmp $25		                cmp tmp1+1
.8f3f	90 21		bcc $8f62	                bcc _done               ; RAM_END < TMP1, so leave
.8f41	d0 06		bne $8f49	                bne _check_counter      ; RAM_END is not smaller and not equal
.8f43	a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8f45	c5 24		cmp $24		                cmp tmp1
.8f47	90 19		bcc $8f62	                bcc _done               ; RAM_END < TMP1, so leave
.8f49					_check_counter:
.8f49	a5 26		lda $26		                lda tmp2
.8f4b	05 27		ora $27		                ora tmp2+1
.8f4d	f0 13		beq $8f62	                beq _done
.8f4f	98		tya		                tya
.8f50	92 24		sta ($24)	                sta (tmp1)
.8f52	a5 26		lda $26		                lda tmp2
.8f54	d0 02		bne $8f58	                bne +
.8f56	c6 27		dec $27		                dec tmp2+1
.8f58	c6 26		dec $26		+               dec tmp2
.8f5a	e6 24		inc $24		                inc tmp1
.8f5c	d0 dd		bne $8f3b	                bne _loop
.8f5e	e6 25		inc $25		                inc tmp1+1
.8f60	80 d9		bra $8f3b	                bra _loop
.8f62					_done:
.8f62	8a		txa		                txa
.8f63	18		clc		                clc
.8f64	69 06		adc #$06	                adc #6
.8f66	aa		tax		                tax
.8f67					z_blank:
.8f67					z_erase:
.8f67	60		rts		z_fill:         rts
.8f68					xt_execute:
.8f68	20 5a d8	jsr $d85a	                jsr underflow_1
.8f6b	20 6f 8f	jsr $8f6f	                jsr doexecute   ; do not combine to JMP (native coding)
.8f6e	60		rts		z_execute:      rts
.8f6f					doexecute:
.8f6f	b5 00		lda $00,x	                lda 0,x
.8f71	85 0e		sta $0e		                sta ip
.8f73	b5 01		lda $01,x	                lda 1,x
.8f75	85 0f		sta $0f		                sta ip+1
.8f77	e8		inx		                inx
.8f78	e8		inx		                inx
.8f79	6c 0e 00	jmp ($000e)	                jmp (ip)
.8f7c					xt_execute_parsing:
.8f7c	20 64 d8	jsr $d864	                jsr underflow_3
.8f7f	20 8d 92	jsr $928d	                jsr xt_input_to_r       ; save normal input for later
.8f82	20 99 96	jsr $9699	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f85	b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f87	85 0a		sta $0a		                sta ciblen
.8f89	b5 01		lda $01,x	                lda 1,x
.8f8b	85 0b		sta $0b		                sta ciblen+1
.8f8d	b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f8f	85 08		sta $08		                sta cib
.8f91	b5 03		lda $03,x	                lda 3,x
.8f93	85 09		sta $09		                sta cib+1
.8f95	64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f97	64 0d		stz $0d		                stz toin+1
.8f99	20 db a3	jsr $a3db	                jsr xt_two_drop         ; 2DROP ( xt )
.8f9c	20 68 8f	jsr $8f68	                jsr xt_execute
.8f9f	20 ce 9a	jsr $9ace	                jsr xt_r_to_input
.8fa2					z_execute_parsing:
.8fa2	60		rts		                rts
.8fa3					xt_exit:
.8fa3	60		rts		                rts             ; keep before z_exit
.8fa4					z_exit:
.8fa4					xt_false:
.8fa4	ca		dex		                dex
.8fa5	ca		dex		                dex
.8fa6	74 00		stz $00,x	                stz 0,x
.8fa8	74 01		stz $01,x	                stz 1,x
.8faa	60		rts		z_false:        rts
.8fab					xt_fetch:
.8fab	20 5a d8	jsr $d85a	                jsr underflow_1
.8fae	a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8fb0	a8		tay		                tay
.8fb1	f6 00		inc $00,x	                inc 0,x
.8fb3	d0 02		bne $8fb7	                bne +
.8fb5	f6 01		inc $01,x	                inc 1,x
.8fb7					+
.8fb7	a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8fb9	95 01		sta $01,x	                sta 1,x
.8fbb	94 00		sty $00,x	                sty 0,x
.8fbd	60		rts		z_fetch:        rts
.8fbe					xt_find:
.8fbe	20 5a d8	jsr $d85a	                jsr underflow_1
.8fc1	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8fc3	48		pha		                pha
.8fc4	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8fc6	48		pha		                pha
.8fc7	20 7a 89	jsr $897a	                jsr xt_count            ; ( caddr -- addr u )
.8fca	20 06 90	jsr $9006	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8fcd	b5 00		lda $00,x	                lda 0,x
.8fcf	15 01		ora $01,x	                ora 1,x
.8fd1	d0 0b		bne $8fde	                bne _found_word
.8fd3	20 a4 8f	jsr $8fa4	                jsr xt_false            ; ( 0 0 )
.8fd6	68		pla		                pla                     ; LSB of address
.8fd7	95 02		sta $02,x	                sta 2,x
.8fd9	68		pla		                pla
.8fda	95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8fdc	80 27		bra $9005	                bra _done               ; ( addr 0 )
.8fde					_found_word:
.8fde	68		pla		                pla
.8fdf	68		pla		                pla
.8fe0	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( nt nt )
.8fe3	20 0c 96	jsr $960c	                jsr xt_name_to_int      ; ( nt xt )
.8fe6	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; ( xt nt )
.8fe9	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8feb	f6 00		inc $00,x	                inc 0,x
.8fed	d0 02		bne $8ff1	                bne +
.8fef	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8ff1					+
.8ff1	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8ff3	29 04		and #$04	                and #IM
.8ff5	d0 08		bne $8fff	                bne _immediate          ; bit set, we're immediate
.8ff7	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8ff9	95 00		sta $00,x	                sta 0,x
.8ffb	95 01		sta $01,x	                sta 1,x
.8ffd	80 06		bra $9005	                bra _done
.8fff					_immediate:
.8fff	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9001	95 00		sta $00,x	                sta 0,x
.9003	74 01		stz $01,x	                stz 1,x
.9005					_done:
.9005	60		rts		z_find:         rts
.9006					xt_find_name:
.9006	20 5f d8	jsr $d85f	                jsr underflow_2
.9009	b5 00		lda $00,x	                lda 0,x
.900b	15 01		ora $01,x	                ora 1,x
.900d	d0 03		bne $9012	                bne _nonempty
.900f	4c ab 90	jmp $90ab	                jmp _fail_done
.9012					_nonempty:
.9012	64 28		stz $28		                stz tmp3                ; Start at the beginning
.9014					_wordlist_loop:
.9014	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9016	a5 28		lda $28		                lda tmp3
.9018	d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.901a	d0 03		bne $901f	                bne _have_string
.901c	4c ab 90	jmp $90ab	                jmp _fail_done
.901f					_have_string:
.901f	18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9020	69 1f		adc #$1f	                adc #search_order_offset
.9022	a8		tay		                tay
.9023	b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.9025	0a		asl a		                asl                     ; Turn offset into cells offset.
.9026	18		clc		                clc
.9027	69 06		adc #$06	                adc #wordlists_offset
.9029	a8		tay		                tay
.902a	b1 1e		lda ($1e),y	                lda (up),y
.902c	85 24		sta $24		                sta tmp1
.902e	c8		iny		                iny
.902f	b1 1e		lda ($1e),y	                lda (up),y
.9031	85 25		sta $25		                sta tmp1+1
.9033	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9035	85 26		sta $26		                sta tmp2
.9037	b5 03		lda $03,x	                lda 3,x
.9039	85 27		sta $27		                sta tmp2+1
.903b					_loop:
.903b	b2 24		lda ($24)	                lda (tmp1)
.903d	d5 00		cmp $00,x	                cmp 0,x
.903f	d0 54		bne $9095	                bne _next_entry
.9041					_compare_string:
.9041	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9043	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9045	b0 07		bcs $904e	                bcs _compare_first
.9047	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9049	90 03		bcc $904e	                bcc _compare_first
.904b	18		clc		                clc
.904c	69 20		adc #$20	                adc #$20
.904e					_compare_first:
.904e	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9050	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9052	d0 41		bne $9095	                bne _next_entry
.9054	b5 00		lda $00,x	                lda 0,x
.9056	3a		dec a		                dea
.9057	f0 2c		beq $9085	                beq _success
.9059	a5 24		lda $24		                lda tmp1
.905b	48		pha		                pha             ; Preserve tmp1 on the return stack.
.905c	18		clc		                clc
.905d	69 08		adc #$08	                adc #8
.905f	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9061	a5 25		lda $25		                lda tmp1+1
.9063	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9064	69 00		adc #$00	                adc #0          ; we only need the carry
.9066	85 25		sta $25		                sta tmp1+1
.9068	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.906a	88		dey		                dey
.906b					_string_loop:
.906b	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.906d	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.906f	b0 07		bcs $9078	                bcs _check_char
.9071	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9073	90 03		bcc $9078	                bcc _check_char
.9075	18		clc		                clc
.9076	69 20		adc #$20	                adc #$20
.9078					_check_char:
.9078	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.907a	d0 13		bne $908f	                bne _next_entry_tmp1
.907c	88		dey		                dey
.907d	d0 ec		bne $906b	                bne _string_loop
.907f					_success_tmp1:
.907f	68		pla		                pla             ; Restore tmp1 from the return stack.
.9080	85 25		sta $25		                sta tmp1+1
.9082	68		pla		                pla
.9083	85 24		sta $24		                sta tmp1
.9085					_success:
.9085	a5 24		lda $24		                lda tmp1
.9087	95 02		sta $02,x	                sta 2,x
.9089	a5 25		lda $25		                lda tmp1+1
.908b	95 03		sta $03,x	                sta 3,x
.908d	80 20		bra $90af	                bra _done
.908f					_next_entry_tmp1:
.908f	68		pla		                pla             ; Restore tmp1 from the return stack.
.9090	85 25		sta $25		                sta tmp1+1
.9092	68		pla		                pla
.9093	85 24		sta $24		                sta tmp1
.9095					_next_entry:
.9095	a0 02		ldy #$02	                ldy #2
.9097	b1 24		lda ($24),y	                lda (tmp1),y
.9099	48		pha		                pha
.909a	c8		iny		                iny
.909b	b1 24		lda ($24),y	                lda (tmp1),y
.909d	85 25		sta $25		                sta tmp1+1
.909f	68		pla		                pla
.90a0	85 24		sta $24		                sta tmp1
.90a2	05 25		ora $25		                ora tmp1+1
.90a4	d0 95		bne $903b	                bne _loop
.90a6	e6 28		inc $28		                inc tmp3
.90a8	4c 14 90	jmp $9014	                jmp _wordlist_loop
.90ab					_fail_done:
.90ab	74 02		stz $02,x	                stz 2,x         ; failure flag
.90ad	74 03		stz $03,x	                stz 3,x
.90af					_done:
.90af	e8		inx		                inx
.90b0	e8		inx		                inx
.90b1	60		rts		z_find_name:    rts
.90b2					xt_flush:
.90b2	20 e9 9e	jsr $9ee9	                jsr xt_save_buffers
.90b5	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.90b7	a9 00		lda #$00	                lda #0
.90b9	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.90bb					z_flush:
.90bb	60		rts		                rts
.90bc					xt_fm_slash_mod:
.90bc	20 64 d8	jsr $d864	                jsr underflow_3
.90bf	64 26		stz $26		                stz tmp2        ; default: n is positive
.90c1	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90c3	10 0e		bpl $90d3	                bpl _check_d
.90c5	e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.90c7	20 4e 96	jsr $964e	                jsr xt_negate   ; NEGATE
.90ca	20 9b a3	jsr $a39b	                jsr xt_to_r     ; >R
.90cd	20 6c 8b	jsr $8b6c	                jsr xt_dnegate  ; DNEGATE
.90d0	20 bd 9a	jsr $9abd	                jsr xt_r_from   ; R>
.90d3					_check_d:
.90d3	b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.90d5	10 0d		bpl $90e4	                bpl _multiply
.90d7	18		clc		                clc
.90d8	b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.90da	75 02		adc $02,x	                adc 2,x         ; LSB of dh
.90dc	95 02		sta $02,x	                sta 2,x
.90de	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90e0	75 03		adc $03,x	                adc 3,x         ; MSB of dh
.90e2	95 03		sta $03,x	                sta 3,x
.90e4					_multiply:
.90e4	20 e5 a5	jsr $a5e5	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90e7	a5 26		lda $26		                lda tmp2
.90e9	f0 07		beq $90f2	                beq _done
.90eb	e8		inx		                inx             ; pretend that we SWAP
.90ec	e8		inx		                inx
.90ed	20 4e 96	jsr $964e	                jsr xt_negate
.90f0	ca		dex		                dex
.90f1	ca		dex		                dex
.90f2					_done:
.90f2	60		rts		z_fm_slash_mod: rts
.90f3					xt_forth:
.90f3	a0 1f		ldy #$1f	                ldy #search_order_offset
.90f5	a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90f7	91 1e		sta ($1e),y	                sta (up),y
.90f9					z_forth:
.90f9	60		rts		                rts
.90fa					load_evaluate:
.90fa	a9 ff		lda #$ff	                lda #$FF
.90fc	85 24		sta $24		                sta tmp1
.90fe	80 11		bra $9111	                bra load_evaluate_start
.9100					xt_evaluate:
.9100	20 5f d8	jsr $d85f	                jsr underflow_2
.9103	64 24		stz $24		                stz tmp1
.9105	b5 00		lda $00,x	                lda 0,x
.9107	15 01		ora $01,x	                ora 1,x
.9109	d0 06		bne $9111	                bne evaluate_got_work
.910b	e8		inx		                inx
.910c	e8		inx		                inx
.910d	e8		inx		                inx
.910e	e8		inx		                inx
.910f	80 42		bra $9153	                bra evaluate_done
.9111					load_evaluate_start:
.9111					evaluate_got_work:
.9111	a0 01		ldy #$01	                ldy #blk_offset+1
.9113	b1 1e		lda ($1e),y	                lda (up),y
.9115	48		pha		                pha
.9116	88		dey		                dey
.9117	b1 1e		lda ($1e),y	                lda (up),y
.9119	48		pha		                pha
.911a	a5 24		lda $24		                lda tmp1
.911c	d0 05		bne $9123	                bne _nozero
.911e	91 1e		sta ($1e),y	                sta (up),y
.9120	c8		iny		                iny
.9121	91 1e		sta ($1e),y	                sta (up),y
.9123					_nozero:
.9123	20 8d 92	jsr $928d	                jsr xt_input_to_r
.9126	a9 ff		lda #$ff	                lda #$ff
.9128	85 06		sta $06		                sta insrc
.912a	85 07		sta $07		                sta insrc+1
.912c	64 0c		stz $0c		                stz toin
.912e	64 0d		stz $0d		                stz toin+1
.9130	b5 00		lda $00,x	                lda 0,x
.9132	85 0a		sta $0a		                sta ciblen
.9134	b5 01		lda $01,x	                lda 1,x
.9136	85 0b		sta $0b		                sta ciblen+1
.9138	b5 02		lda $02,x	                lda 2,x
.913a	85 08		sta $08		                sta cib
.913c	b5 03		lda $03,x	                lda 3,x
.913e	85 09		sta $09		                sta cib+1
.9140	e8		inx		                inx             ; A clean stack is a clean mind
.9141	e8		inx		                inx
.9142	e8		inx		                inx
.9143	e8		inx		                inx
.9144	20 c2 d7	jsr $d7c2	                jsr interpret   ; ( -- )
.9147	20 ce 9a	jsr $9ace	                jsr xt_r_to_input
.914a	a0 00		ldy #$00	                ldy #blk_offset
.914c	68		pla		                pla
.914d	91 1e		sta ($1e),y	                sta (up),y
.914f	c8		iny		                iny
.9150	68		pla		                pla
.9151	91 1e		sta ($1e),y	                sta (up),y
.9153					evaluate_done:
.9153	60		rts		z_evaluate:     rts
.9154					xt_get_current:
.9154	ca		dex		                dex
.9155	ca		dex		                dex
.9156	a0 04		ldy #$04	                ldy #current_offset
.9158	b1 1e		lda ($1e),y	                lda (up),y
.915a	95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.915c	74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.915e	60		rts		z_get_current:  rts
.915f					xt_get_order:
.915f	a0 1e		ldy #$1e	                ldy #num_order_offset
.9161	b1 1e		lda ($1e),y	                lda (up),y
.9163	85 24		sta $24		                sta tmp1
.9165	f0 16		beq $917d	                beq _done       ; If zero, there are no wordlists.
.9167					_loop:
.9167	c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.9169	a9 1f		lda #$1f	                lda #search_order_offset
.916b	18		clc		                clc
.916c	65 24		adc $24		                adc tmp1
.916e	a8		tay		                tay
.916f	ca		dex		                dex
.9170	ca		dex		                dex
.9171	b1 1e		lda ($1e),y	                lda (up),y
.9173	95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.9175	74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.9177	a9 00		lda #$00	                lda #0
.9179	c5 24		cmp $24		                cmp tmp1
.917b	d0 ea		bne $9167	                bne _loop
.917d					_done:
.917d	ca		dex		                dex
.917e	ca		dex		                dex
.917f	a0 1e		ldy #$1e	                ldy #num_order_offset
.9181	b1 1e		lda ($1e),y	                lda (up),y
.9183	95 00		sta $00,x	                sta 0,x
.9185	74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.9187	60		rts		z_get_order:    rts
.9188					xt_greater_than:
.9188	20 5f d8	jsr $d85f	                jsr underflow_2
.918b	a0 00		ldy #$00	                ldy #0          ; default false
.918d	20 81 d7	jsr $d781	                jsr compare_16bit
.9190	f0 03		beq $9195	                beq _false
.9192	10 01		bpl $9195	                bpl _false
.9194	88		dey		                dey
.9195					_false:
.9195	98		tya		                tya
.9196	e8		inx		                inx
.9197	e8		inx		                inx
.9198	95 00		sta $00,x	                sta 0,x
.919a	95 01		sta $01,x	                sta 1,x
.919c	60		rts		z_greater_than: rts
.919d					xt_here:
.919d					xt_asm_arrow:
.919d	ca		dex		                dex
.919e	ca		dex		                dex
.919f	a5 00		lda $00		                lda cp
.91a1	95 00		sta $00,x	                sta 0,x
.91a3	a5 01		lda $01		                lda cp+1
.91a5	95 01		sta $01,x	                sta 1,x
.91a7					z_asm_arrow:
.91a7	60		rts		z_here:         rts
.91a8					xt_hex:
.91a8	a9 10		lda #$10	                lda #16
.91aa	85 18		sta $18		                sta base
.91ac	64 19		stz $19		                stz base+1              ; paranoid
.91ae	60		rts		z_hex:          rts
.91af					xt_hexstore:
.91af	20 64 d8	jsr $d864	                jsr underflow_3
.91b2	20 da 8d	jsr $8dda	                jsr xt_dup              ; Save copy of original address
.91b5	20 cd a4	jsr $a4cd	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.91b8					_loop:
.91b8	b5 00		lda $00,x	                lda 0,x
.91ba	15 01		ora $01,x	                ora 1,x
.91bc	f0 36		beq $91f4	                beq _done
.91be	20 77 86	jsr $8677	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.91c1	20 cd a4	jsr $a4cd	                jsr xt_two_to_r
.91c4	20 d3 a7	jsr $a7d3	                jsr xt_zero
.91c7	20 d3 a7	jsr $a7d3	                jsr xt_zero
.91ca	20 53 a4	jsr $a453	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.91cd	20 e8 a2	jsr $a2e8	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.91d0	b5 00		lda $00,x	                lda 0,x
.91d2	15 01		ora $01,x	                ora 1,x
.91d4	d0 17		bne $91ed	                bne _have_chars_left
.91d6	20 db a3	jsr $a3db	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.91d9	20 ab 8a	jsr $8aab	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.91dc	20 a8 9a	jsr $9aa8	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.91df	20 40 86	jsr $8640	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.91e2	20 bd 9a	jsr $9abd	                jsr xt_r_from           ; R>
.91e5	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+
.91e8	20 9b a3	jsr $a39b	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91eb	80 cb		bra $91b8	                bra _loop
.91ed					_have_chars_left:
.91ed	8a		txa		                txa
.91ee	18		clc		                clc
.91ef	69 08		adc #$08	                adc #8
.91f1	aa		tax		                tax
.91f2	80 c4		bra $91b8	                bra _loop
.91f4					_done:
.91f4	e8		inx		                inx
.91f5	e8		inx		                inx
.91f6	e8		inx		                inx
.91f7	e8		inx		                inx                     ; 2DROP
.91f8	20 53 a4	jsr $a453	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91fb	20 d9 a1	jsr $a1d9	                jsr xt_swap
.91fe	20 7b 95	jsr $957b	                jsr xt_minus            ; ( n )
.9201	60		rts		z_hexstore:     rts
.9202					xt_hold:
.9202	20 5a d8	jsr $d85a	                jsr underflow_1
.9205	a5 34		lda $34		                lda tohold
.9207	d0 02		bne $920b	                bne +
.9209	c6 35		dec $35		                dec tohold+1
.920b					+
.920b	c6 34		dec $34		                dec tohold
.920d	b5 00		lda $00,x	                lda 0,x
.920f	92 34		sta ($34)	                sta (tohold)
.9211	e8		inx		                inx
.9212	e8		inx		                inx
.9213	60		rts		z_hold:         rts
.9214					xt_i:
.9214	ca		dex		                dex
.9215	ca		dex		                dex
.9216	86 2a		stx $2a		                stx tmpdsp
.9218	ba		tsx		                tsx
.9219	38		sec		                sec
.921a	bd 01 01	lda $0101,x	                lda $0101,x     ; LSB
.921d	fd 03 01	sbc $0103,x	                sbc $0103,x
.9220	a8		tay		                tay
.9221	bd 02 01	lda $0102,x	                lda $0102,x     ; MSB
.9224	fd 04 01	sbc $0104,x	                sbc $0104,x
.9227	a6 2a		ldx $2a		                ldx tmpdsp
.9229	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.922b	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.922d	60		rts		z_i:            rts
.922e					xt_if:
.922e	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.9230	a9 3f		lda #$3f	                lda #<zero_branch_runtime
.9232	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.9235	20 9d 91	jsr $919d	                jsr xt_here
.9238	20 d3 a7	jsr $a7d3	                jsr xt_zero
.923b	20 99 87	jsr $8799	                jsr xt_comma
.923e	60		rts		z_if:           rts
.923f					zero_branch_runtime:
.923f	68		pla		                pla
.9240	85 22		sta $22		                sta tmpbranch
.9242	68		pla		                pla
.9243	85 23		sta $23		                sta tmpbranch+1
.9245	b5 00		lda $00,x	                lda 0,x
.9247	15 01		ora $01,x	                ora 1,x
.9249	f0 0f		beq $925a	                beq _zero
.924b	a5 22		lda $22		                lda tmpbranch   ; LSB
.924d	18		clc		                clc
.924e	69 02		adc #$02	                adc #2
.9250	85 24		sta $24		                sta tmp1
.9252	a5 23		lda $23		                lda tmpbranch+1 ; MSB
.9254	69 00		adc #$00	                adc #0          ; For carry
.9256	85 25		sta $25		                sta tmp1+1
.9258	80 13		bra $926d	                bra _done
.925a					_zero:
.925a	a0 01		ldy #$01	                ldy #1
.925c	b1 22		lda ($22),y	                lda (tmpbranch),y
.925e	85 24		sta $24		                sta tmp1
.9260	c8		iny		                iny
.9261	b1 22		lda ($22),y	                lda (tmpbranch),y
.9263	85 25		sta $25		                sta tmp1+1
.9265	a5 24		lda $24		                lda tmp1
.9267	d0 02		bne $926b	                bne +
.9269	c6 25		dec $25		                dec tmp1+1
.926b					+
.926b	c6 24		dec $24		                dec tmp1
.926d					_done:
.926d	a5 25		lda $25		                lda tmp1+1
.926f	48		pha		                pha             ; MSB first
.9270	a5 24		lda $24		                lda tmp1
.9272	48		pha		                pha
.9273	e8		inx		                inx
.9274	e8		inx		                inx
.9275	60		rts		                rts
.9276					xt_immediate:
.9276	20 9c d7	jsr $d79c	                jsr current_to_dp
.9279	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.927b	b1 02		lda ($02),y	                lda (dp),y
.927d	09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.927f	91 02		sta ($02),y	                sta (dp),y
.9281	60		rts		z_immediate:    rts
.9282					xt_input:
.9282	ca		dex		                dex
.9283	ca		dex		                dex
.9284	a9 12		lda #$12	                lda #<input
.9286	95 00		sta $00,x	                sta 0,x
.9288	a9 00		lda #$00	                lda #>input
.928a	95 01		sta $01,x	                sta 1,x
.928c	60		rts		z_input:        rts
.928d					xt_input_to_r:
.928d	68		pla		                pla
.928e	85 24		sta $24		                sta tmp1
.9290	68		pla		                pla
.9291	85 25		sta $25		                sta tmp1+1
.9293	a0 07		ldy #$07	                ldy #7
.9295					_loop:
.9295	b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.9298	48		pha		                pha
.9299	88		dey		                dey
.929a	10 f9		bpl $9295	                bpl _loop
.929c	a5 25		lda $25		                lda tmp1+1
.929e	48		pha		                pha
.929f	a5 24		lda $24		                lda tmp1
.92a1	48		pha		                pha
.92a2	60		rts		z_input_to_r: 	rts
.92a3					xt_int_to_name:
.92a3	20 5a d8	jsr $d85a	                jsr underflow_1
.92a6	ca		dex		                dex
.92a7	ca		dex		                dex
.92a8	74 00		stz $00,x	                stz 0,x
.92aa	74 01		stz $01,x	                stz 1,x
.92ac					_wordlist_loop:
.92ac	b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.92ae	0a		asl a		                asl                     ; Turn offset into cells offset.
.92af	18		clc		                clc
.92b0	69 06		adc #$06	                adc #wordlists_offset
.92b2	a8		tay		                tay
.92b3	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.92b5	85 26		sta $26		                sta tmp2                ; into tmp2
.92b7	c8		iny		                iny
.92b8	b1 1e		lda ($1e),y	                lda (up),y
.92ba	85 27		sta $27		                sta tmp2+1
.92bc	a5 26		lda $26		                lda tmp2
.92be	05 27		ora $27		                ora tmp2+1
.92c0	f0 38		beq $92fa	                beq _next_wordlist
.92c2	b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.92c4	85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.92c6	b5 03		lda $03,x	                lda 3,x
.92c8	85 29		sta $29		                sta tmp3+1
.92ca					_loop:
.92ca	a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.92cc	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.92ce	c5 28		cmp $28		                cmp tmp3
.92d0	d0 07		bne $92d9	                bne _no_match
.92d2	c8		iny		                iny
.92d3	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.92d5	c5 29		cmp $29		                cmp tmp3+1
.92d7	f0 32		beq $930b	                beq _match
.92d9					_no_match:
.92d9	18		clc		                clc
.92da	a5 26		lda $26		                lda tmp2
.92dc	69 02		adc #$02	                adc #2
.92de	85 26		sta $26		                sta tmp2
.92e0	a5 27		lda $27		                lda tmp2+1
.92e2	69 00		adc #$00	                adc #0          ; only care about carry
.92e4	85 27		sta $27		                sta tmp2+1
.92e6	a0 00		ldy #$00	                ldy #0
.92e8	b1 26		lda ($26),y	                lda (tmp2),y
.92ea	48		pha		                pha
.92eb	c8		iny		                iny
.92ec	11 26		ora ($26),y	                ora (tmp2),y
.92ee	f0 09		beq $92f9	                beq _zero
.92f0	b1 26		lda ($26),y	                lda (tmp2),y
.92f2	85 27		sta $27		                sta tmp2+1
.92f4	68		pla		                pla
.92f5	85 26		sta $26		                sta tmp2
.92f7	80 d1		bra $92ca	                bra _loop
.92f9					_zero:
.92f9	68		pla		                pla             ; Leftover from above loop
.92fa					_next_wordlist:
.92fa	b5 00		lda $00,x	                lda 0,x
.92fc	1a		inc a		                ina
.92fd	95 00		sta $00,x	                sta 0,x
.92ff	c9 0c		cmp #$0c	                cmp #max_wordlists
.9301	d0 a9		bne $92ac	                bne _wordlist_loop
.9303	e8		inx		                inx
.9304	e8		inx		                inx
.9305	74 00		stz $00,x	                stz 0,x
.9307	74 01		stz $01,x	                stz 1,x
.9309	80 0a		bra $9315	                bra z_int_to_name
.930b					_match:
.930b	e8		inx		                inx
.930c	e8		inx		                inx
.930d	a5 26		lda $26		                lda tmp2
.930f	95 00		sta $00,x	                sta 0,x
.9311	a5 27		lda $27		                lda tmp2+1
.9313	95 01		sta $01,x	                sta 1,x
.9315	60		rts		z_int_to_name:  rts
.9316					xt_invert:
.9316	20 5a d8	jsr $d85a	                jsr underflow_1
.9319	a9 ff		lda #$ff	                lda #$FF
.931b	55 00		eor $00,x	                eor 0,x         ; LSB
.931d	95 00		sta $00,x	                sta 0,x
.931f	a9 ff		lda #$ff	                lda #$FF
.9321	55 01		eor $01,x	                eor 1,x         ; MSB
.9323	95 01		sta $01,x	                sta 1,x
.9325	60		rts		z_invert:       rts
.9326					xt_is:
.9326	a5 16		lda $16		                lda state
.9328	05 17		ora $17		                ora state+1
.932a	f0 0c		beq $9338	                beq _interpreting
.932c					_compiling:
.932c	20 c9 85	jsr $85c9	                jsr xt_bracket_tick
.932f	a0 8b		ldy #$8b	                ldy #>xt_defer_store
.9331	a9 11		lda #$11	                lda #<xt_defer_store
.9333	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.9336	80 06		bra $933e	                bra _done
.9338					_interpreting:
.9338	20 3c a2	jsr $a23c	                jsr xt_tick
.933b	20 11 8b	jsr $8b11	                jsr xt_defer_store
.933e					_done:
.933e	60		rts		z_is:           rts
.933f					xt_j:
.933f	ca		dex		                dex
.9340	ca		dex		                dex
.9341	86 2a		stx $2a		                stx tmpdsp
.9343	ba		tsx		                tsx
.9344	38		sec		                sec
.9345	bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.9348	fd 09 01	sbc $0109,x	                sbc $0109,x
.934b	a8		tay		                tay
.934c	bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.934f	fd 0a 01	sbc $010a,x	                sbc $010A,x
.9352	a6 2a		ldx $2a		                ldx tmpdsp
.9354	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.9356	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.9358	60		rts		z_j:            rts
.9359					xt_key:
.9359	20 63 93	jsr $9363	                jsr key_a               ; returns char in A
.935c	ca		dex		                dex
.935d	ca		dex		                dex
.935e	95 00		sta $00,x	                sta 0,x
.9360	74 01		stz $01,x	                stz 1,x
.9362	60		rts		z_key:          rts
.9363					key_a:
.9363	6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.9366					xt_latestnt:
.9366	ca		dex		                dex
.9367	ca		dex		                dex
.9368	20 9c d7	jsr $d79c	                jsr current_to_dp
.936b	a5 02		lda $02		                lda dp
.936d	95 00		sta $00,x	                sta 0,x
.936f	a5 03		lda $03		                lda dp+1
.9371	95 01		sta $01,x	                sta 1,x
.9373	60		rts		z_latestnt:     rts
.9374					xt_latestxt:
.9374	20 66 93	jsr $9366	                jsr xt_latestnt         ; ( nt )
.9377	20 0c 96	jsr $960c	                jsr xt_name_to_int      ; ( xt )
.937a	60		rts		z_latestxt:     rts
.937b					xt_leave:
.937b	68		pla		                pla
.937c	68		pla		                pla
.937d	68		pla		                pla
.937e	68		pla		                pla
.937f	60		rts		                rts             ; this must be compiled, so keep before z_leave
.9380					z_leave:
.9380					xt_left_bracket:
.9380	64 16		stz $16		                stz state
.9382	64 17		stz $17		                stz state+1
.9384	60		rts		z_left_bracket: rts
.9385					xt_less_number_sign:
.9385	20 cc 98	jsr $98cc	                jsr xt_pad      ; ( addr )
.9388	b5 00		lda $00,x	                lda 0,x
.938a	85 34		sta $34		                sta tohold
.938c	b5 01		lda $01,x	                lda 1,x
.938e	85 35		sta $35		                sta tohold+1
.9390	e8		inx		                inx
.9391	e8		inx		                inx
.9392					z_less_number_sign:
.9392	60		rts		                rts
.9393					xt_less_than:
.9393	20 5f d8	jsr $d85f	                jsr underflow_2
.9396	a0 00		ldy #$00	                ldy #0          ; default false
.9398	20 81 d7	jsr $d781	                jsr compare_16bit
.939b	f0 03		beq $93a0	                beq _false
.939d	30 01		bmi $93a0	                bmi _false
.939f	88		dey		                dey
.93a0					_false:
.93a0	98		tya		                tya
.93a1	e8		inx		                inx
.93a2	e8		inx		                inx
.93a3	95 00		sta $00,x	                sta 0,x
.93a5	95 01		sta $01,x	                sta 1,x
.93a7	60		rts		z_less_than:    rts
.93a8					xt_list:
.93a8	20 5a d8	jsr $d85a	                jsr underflow_1
.93ab	20 04 9f	jsr $9f04	                jsr xt_scr
.93ae	20 b8 a1	jsr $a1b8	                jsr xt_store
.93b1	20 71 a8	jsr $a871	                jsr xt_editor_l
.93b4	60		rts		z_list:         rts
.93b5					xt_literal:
.93b5	20 5a d8	jsr $d85a	                jsr underflow_1
.93b8	a0 93		ldy #$93	                ldy #>literal_runtime
.93ba	a9 c3		lda #$c3	                lda #<literal_runtime
.93bc	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.93bf	20 99 87	jsr $8799	                jsr xt_comma
.93c2	60		rts		z_literal:      rts
.93c3					literal_runtime:
.93c3	ca		dex		                dex
.93c4	ca		dex		                dex
.93c5	68		pla		                pla             ; LSB
.93c6	85 24		sta $24		                sta tmp1
.93c8	68		pla		                pla             ; MSB
.93c9	85 25		sta $25		                sta tmp1+1
.93cb	a0 01		ldy #$01	                ldy #1
.93cd	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.93cf	95 00		sta $00,x	                sta 0,x
.93d1	c8		iny		                iny
.93d2	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.93d4	95 01		sta $01,x	                sta 1,x
.93d6	98		tya		                tya
.93d7	18		clc		                clc
.93d8	65 24		adc $24		                adc tmp1
.93da	a8		tay		                tay
.93db	a5 25		lda $25		                lda tmp1+1
.93dd	69 00		adc #$00	                adc #0
.93df	48		pha		                pha
.93e0	5a		phy		                phy
.93e1	60		rts		                rts
.93e2					xt_load:
.93e2	20 5a d8	jsr $d85a	                jsr underflow_1
.93e5	a0 01		ldy #$01	                ldy #blk_offset+1
.93e7	b1 1e		lda ($1e),y	                lda (up),y
.93e9	48		pha		                pha
.93ea	88		dey		                dey
.93eb	b1 1e		lda ($1e),y	                lda (up),y
.93ed	48		pha		                pha
.93ee	b5 00		lda $00,x	                lda 0,x
.93f0	91 1e		sta ($1e),y	                sta (up),y
.93f2	c8		iny		                iny
.93f3	b5 01		lda $01,x	                lda 1,x
.93f5	91 1e		sta ($1e),y	                sta (up),y
.93f7	20 ec 83	jsr $83ec	                jsr xt_block
.93fa	ca		dex		                dex
.93fb	ca		dex		                dex
.93fc	a9 04		lda #$04	                lda #4
.93fe	95 01		sta $01,x	                sta 1,x
.9400	74 00		stz $00,x	                stz 0,x
.9402	20 fa 90	jsr $90fa	                jsr load_evaluate
.9405	a0 00		ldy #$00	                ldy #blk_offset
.9407	68		pla		                pla
.9408	91 1e		sta ($1e),y	                sta (up),y
.940a	c8		iny		                iny
.940b	68		pla		                pla
.940c	91 1e		sta ($1e),y	                sta (up),y
.940e	88		dey		                dey
.940f	11 1e		ora ($1e),y	                ora (up),y
.9411	f0 12		beq $9425	                beq _done
.9413	ca		dex		                dex
.9414	ca		dex		                dex
.9415	a0 00		ldy #$00	                ldy #blk_offset
.9417	b1 1e		lda ($1e),y	                lda (up),y
.9419	95 00		sta $00,x	                sta 0,x
.941b	c8		iny		                iny
.941c	b1 1e		lda ($1e),y	                lda (up),y
.941e	95 01		sta $01,x	                sta 1,x
.9420	20 ec 83	jsr $83ec	                jsr xt_block
.9423	e8		inx		                inx
.9424	e8		inx		                inx
.9425					_done:
.9425	60		rts		z_load:         rts
.9426					xt_loop:
.9426	a0 98		ldy #$98	                ldy #>xt_one
.9428	a9 33		lda #$33	                lda #<xt_one
.942a	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine     ; drop through to +LOOP
.942d					xt_plus_loop:
.942d	a0 11		ldy #$11	                ldy #plus_loop_runtime_end-plus_loop_runtime
.942f	5a		phy		                phy             ; save counter to adjust CP
.9430					-
.9430	b9 94 94	lda $9494,y	                lda plus_loop_runtime,y
.9433	91 00		sta ($00),y	                sta (cp),y
.9435	88		dey		                dey
.9436	10 f8		bpl $9430	                bpl -
.9438	68		pla		                pla
.9439	18		clc		                clc
.943a	65 00		adc $00		                adc cp
.943c	85 00		sta $00		                sta cp
.943e	a5 01		lda $01		                lda cp+1
.9440	69 00		adc #$00	                adc #0          ; only need carry
.9442	85 01		sta $01		                sta cp+1
.9444	20 99 87	jsr $8799	                jsr xt_comma
.9447	a9 68		lda #$68	                lda #$68                ; opcode for PLA
.9449	a0 06		ldy #$06	                ldy #6
.944b					-
.944b	91 00		sta ($00),y	                sta (cp),y
.944d	88		dey		                dey
.944e	10 fb		bpl $944b	                bpl -
.9450	a9 06		lda #$06	                lda #6
.9452	18		clc		                clc
.9453	65 00		adc $00		                adc cp
.9455	85 00		sta $00		                sta cp
.9457	a5 01		lda $01		                lda cp+1
.9459	69 00		adc #$00	                adc #0                  ; only need carry
.945b	85 01		sta $01		                sta cp+1
.945d	b5 00		lda $00,x	                lda 0,x
.945f	85 24		sta $24		                sta tmp1
.9461	b5 01		lda $01,x	                lda 1,x
.9463	85 25		sta $25		                sta tmp1+1
.9465	e8		inx		                inx
.9466	e8		inx		                inx
.9467	a5 00		lda $00		                lda cp
.9469	38		sec		                sec
.946a	e9 01		sbc #$01	                sbc #1
.946c	85 26		sta $26		                sta tmp2
.946e	a5 01		lda $01		                lda cp+1
.9470	e9 00		sbc #$00	                sbc #0
.9472	85 27		sta $27		                sta tmp2+1
.9474	a0 00		ldy #$00	                ldy #0
.9476	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.9478	91 24		sta ($24),y	                sta (tmp1),y
.947a	c8		iny		                iny
.947b	a5 27		lda $27		                lda tmp2+1      ; MSB
.947d	91 24		sta ($24),y	                sta (tmp1),y
.947f	c8		iny		                iny
.9480	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9482	91 24		sta ($24),y	                sta (tmp1),y
.9484	c8		iny		                iny
.9485	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.9487	91 24		sta ($24),y	                sta (tmp1),y
.9489	c8		iny		                iny
.948a	a5 26		lda $26		                lda tmp2        ; LSB
.948c	91 24		sta ($24),y	                sta (tmp1),y
.948e	c8		iny		                iny
.948f	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9491	91 24		sta ($24),y	                sta (tmp1),y
.9493					z_loop:
.9493	60		rts		z_plus_loop:    rts
.9494					plus_loop_runtime:
.9494	18		clc		                clc
.9495	68		pla		                pla             ; LSB of index
.9496	75 00		adc $00,x	                adc 0,x         ; LSB of step
.9498	a8		tay		                tay             ; temporary storage of LSB
.9499	b8		clv		                clv
.949a	68		pla		                pla             ; MSB of index
.949b	75 01		adc $01,x	                adc 1,x         ; MSB of step
.949d	48		pha		                pha             ; put MSB of index back on stack
.949e	98		tya		                tya             ; put LSB of index back on stack
.949f	48		pha		                pha
.94a0	e8		inx		                inx             ; dump step from TOS
.94a1	e8		inx		                inx
.94a2	70 03		bvs $94a7	                bvs _hack+3     ; skip over JMP instruction
.94a4					_hack:
>94a4	4c				                .byte $4C
.94a5					plus_loop_runtime_end:
.94a5					xt_lshift:
.94a5	20 5f d8	jsr $d85f	                jsr underflow_2
.94a8	b5 00		lda $00,x	                lda 0,x
.94aa	29 0f		and #$0f	                and #%00001111
.94ac	f0 08		beq $94b6	                beq _done
.94ae	a8		tay		                tay
.94af					_loop:
.94af	16 02		asl $02,x	                asl 2,x
.94b1	36 03		rol $03,x	                rol 3,x
.94b3	88		dey		                dey
.94b4	d0 f9		bne $94af	                bne _loop
.94b6					_done:
.94b6	e8		inx		                inx
.94b7	e8		inx		                inx
.94b8	60		rts		z_lshift:       rts
.94b9					xt_m_star:
.94b9	20 5f d8	jsr $d85f	                jsr underflow_2
.94bc	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.94be	55 03		eor $03,x	                eor 3,x         ; MSB of n2
.94c0	48		pha		                pha
.94c1	20 42 81	jsr $8142	                jsr xt_abs
.94c4	20 d9 a1	jsr $a1d9	                jsr xt_swap
.94c7	20 42 81	jsr $8142	                jsr xt_abs
.94ca	20 27 a6	jsr $a627	                jsr xt_um_star          ; ( d )
.94cd	68		pla		                pla
.94ce	10 03		bpl $94d3	                bpl _done
.94d0	20 6c 8b	jsr $8b6c	                jsr xt_dnegate
.94d3					_done:
.94d3	60		rts		z_m_star:       rts
.94d4					xt_marker:
.94d4	20 9c d7	jsr $d79c	                jsr current_to_dp
.94d7	a5 02		lda $02		                lda dp
.94d9	48		pha		                pha
.94da	a5 03		lda $03		                lda dp+1
.94dc	48		pha		                pha
.94dd	a5 00		lda $00		                lda cp
.94df	48		pha		                pha
.94e0	a5 01		lda $01		                lda cp+1
.94e2	48		pha		                pha
.94e3	20 94 89	jsr $8994	                jsr xt_create
.94e6	a5 00		lda $00		                lda cp          ; LSB
.94e8	38		sec		                sec
.94e9	e9 02		sbc #$02	                sbc #2
.94eb	85 00		sta $00		                sta cp
.94ed	a5 01		lda $01		                lda cp+1        ; MSB
.94ef	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94f1	85 01		sta $01		                sta cp+1
.94f3	a0 95		ldy #$95	                ldy #>marker_runtime
.94f5	a9 12		lda #$12	                lda #<marker_runtime
.94f7	20 09 d7	jsr $d709	                jsr cmpl_word
.94fa	7a		ply		                ply                     ; MSB
.94fb	68		pla		                pla                     ; LSB
.94fc	20 09 d7	jsr $d709	                jsr cmpl_word
.94ff	7a		ply		                ply                     ; MSB
.9500	68		pla		                pla                     ; LSB
.9501	20 09 d7	jsr $d709	                jsr cmpl_word
.9504	a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.9506					_marker_loop:
.9506	b1 1e		lda ($1e),y	                lda (up),y
.9508	20 0d d7	jsr $d70d	                jsr cmpl_a
.950b	c8		iny		                iny
.950c	98		tya		                tya
.950d	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.950f	d0 f5		bne $9506	                bne _marker_loop
.9511	60		rts		z_marker:       rts
.9512					marker_runtime:
.9512	68		pla		                pla
.9513	85 24		sta $24		                sta tmp1        ; LSB of address
.9515	68		pla		                pla
.9516	85 25		sta $25		                sta tmp1+1      ; MSB of address
.9518	e6 24		inc $24		                inc tmp1
.951a	d0 02		bne $951e	                bne +
.951c	e6 25		inc $25		                inc tmp1+1
.951e					+
.951e	a0 00		ldy #$00	                ldy #0
.9520	b1 24		lda ($24),y	                lda (tmp1),y
.9522	85 00		sta $00		                sta cp
.9524	c8		iny		                iny
.9525	b1 24		lda ($24),y	                lda (tmp1),y
.9527	85 01		sta $01		                sta cp+1
.9529	c8		iny		                iny
.952a	b1 24		lda ($24),y	                lda (tmp1),y
.952c	85 02		sta $02		                sta dp
.952e	c8		iny		                iny
.952f	b1 24		lda ($24),y	                lda (tmp1),y
.9531	85 03		sta $03		                sta dp+1
.9533	a0 04		ldy #$04	                ldy #4
.9535					_marker_restore_loop:
.9535	b1 24		lda ($24),y	                lda (tmp1), y
.9537	91 1e		sta ($1e),y	                sta (up), y
.9539	c8		iny		                iny
.953a	98		tya		                tya
.953b	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.953d	d0 f6		bne $9535	                bne _marker_restore_loop
.953f	20 af d7	jsr $d7af	                jsr dp_to_current       ; Move the CURRENT DP back.
.9542	60		rts		                rts
.9543					xt_max:
.9543	20 5f d8	jsr $d85f	                jsr underflow_2
.9546	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9548	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.954a	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.954c	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.954e	50 02		bvc $9552	                bvc _no_overflow
.9550	49 80		eor #$80	                eor #$80        ; complement negative flag
.9552					_no_overflow:
.9552	30 08		bmi $955c	                bmi _keep_nos
.9554	b5 00		lda $00,x	                lda 0,x
.9556	95 02		sta $02,x	                sta 2,x
.9558	b5 01		lda $01,x	                lda 1,x
.955a	95 03		sta $03,x	                sta 3,x
.955c					_keep_nos:
.955c	e8		inx		                inx
.955d	e8		inx		                inx
.955e	60		rts		z_max:          rts
.955f					xt_min:
.955f	20 5f d8	jsr $d85f	                jsr underflow_2
.9562	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9564	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.9566	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9568	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.956a	50 02		bvc $956e	                bvc _no_overflow
.956c	49 80		eor #$80	                eor #$80
.956e					_no_overflow:
.956e	10 08		bpl $9578	                bpl _keep_nos
.9570	b5 00		lda $00,x	                lda 0,x
.9572	95 02		sta $02,x	                sta 2,x
.9574	b5 01		lda $01,x	                lda 1,x
.9576	95 03		sta $03,x	                sta 3,x
.9578					_keep_nos:
.9578	e8		inx		                inx
.9579	e8		inx		                inx
.957a	60		rts		z_min:          rts
.957b					xt_minus:
.957b	20 5f d8	jsr $d85f	                jsr underflow_2
.957e	38		sec		                sec
.957f	b5 02		lda $02,x	                lda 2,x         ; LSB
.9581	f5 00		sbc $00,x	                sbc 0,x
.9583	95 02		sta $02,x	                sta 2,x
.9585	b5 03		lda $03,x	                lda 3,x         ; MSB
.9587	f5 01		sbc $01,x	                sbc 1,x
.9589	95 03		sta $03,x	                sta 3,x
.958b	e8		inx		                inx
.958c	e8		inx		                inx
.958d	60		rts		z_minus:        rts
.958e					xt_minus_leading:
.958e	20 5f d8	jsr $d85f	                jsr underflow_2
.9591					_loop:
.9591	b5 00		lda $00,x	                lda 0,x
.9593	15 01		ora $01,x	                ora 1,x
.9595	f0 0f		beq $95a6	                beq _done
.9597	a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.9599	20 4d d8	jsr $d84d	                jsr is_whitespace
.959c	90 08		bcc $95a6	                bcc _done
.959e	20 33 98	jsr $9833	                jsr xt_one              ; ( addr u 1 )
.95a1	20 44 a0	jsr $a044	                jsr xt_slash_string     ; ( addr+ u-1 )
.95a4	80 eb		bra $9591	                bra _loop
.95a6					_done:
.95a6					z_minus_leading:
.95a6	60		rts		                rts
.95a7					xt_minus_trailing:
.95a7	20 5f d8	jsr $d85f	                jsr underflow_2
.95aa	b5 00		lda $00,x	                lda 0,x         ; LSB of n
.95ac	15 01		ora $01,x	                ora 1,x         ; MSB of n
.95ae	f0 33		beq $95e3	                beq _done
.95b0	18		clc		                clc
.95b1	b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.95b3	75 00		adc $00,x	                adc 0,x
.95b5	85 24		sta $24		                sta tmp1
.95b7	b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.95b9	75 01		adc $01,x	                adc 1,x
.95bb	85 25		sta $25		                sta tmp1+1
.95bd	a5 24		lda $24		                lda tmp1
.95bf	d0 02		bne $95c3	                bne +
.95c1	c6 25		dec $25		                dec tmp1+1
.95c3					+
.95c3	c6 24		dec $24		                dec tmp1
.95c5					_loop:
.95c5	b2 24		lda ($24)	                lda (tmp1)
.95c7	c9 20		cmp #$20	                cmp #AscSP
.95c9	d0 18		bne $95e3	                bne _done
.95cb	a5 24		lda $24		                lda tmp1
.95cd	d0 02		bne $95d1	                bne +
.95cf	c6 25		dec $25		                dec tmp1+1
.95d1					+
.95d1	c6 24		dec $24		                dec tmp1
.95d3	b5 00		lda $00,x	                lda 0,x
.95d5	d0 02		bne $95d9	                bne +
.95d7	d6 01		dec $01,x	                dec 1,x
.95d9					+
.95d9	d6 00		dec $00,x	                dec 0,x
.95db	b5 00		lda $00,x	                lda 0,x
.95dd	15 01		ora $01,x	                ora 1,x
.95df	f0 02		beq $95e3	                beq _done       ; Count has reached zero - we're done!
.95e1	80 e2		bra $95c5	                bra _loop
.95e3					_done:
.95e3					z_minus_trailing:
.95e3	60		rts		                rts
.95e4					xt_mod:
.95e4	20 5f d8	jsr $d85f	                jsr underflow_2
.95e7	20 2c a0	jsr $a02c	                jsr xt_slash_mod
.95ea	e8		inx		                inx             ; DROP
.95eb	e8		inx		                inx
.95ec					z_mod:
.95ec	60		rts		                rts
.95ed					xt_move:
.95ed	b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95ef	d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95f1	f0 05		beq $95f8	                beq _lsb                ; wasn't helpful, move to LSB
.95f3	b0 0e		bcs $9603	                bcs _to_move_up         ; we want CMOVE>
.95f5	4c c4 86	jmp $86c4	                jmp xt_cmove            ; JSR/RTS
.95f8					_lsb:
.95f8	b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95fa	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95fc	f0 08		beq $9606	                beq _equal              ; LSB is equal as well
.95fe	b0 03		bcs $9603	                bcs _to_move_up         ; we want CMOVE>
.9600	4c c4 86	jmp $86c4	                jmp xt_cmove            ; JSR/RTS
.9603					_to_move_up:
.9603	4c ff 86	jmp $86ff	                jmp xt_cmove_up         ; JSR/RTS
.9606					_equal:
.9606	8a		txa		                txa
.9607	18		clc		                clc
.9608	69 06		adc #$06	                adc #6
.960a	aa		tax		                tax
.960b	60		rts		z_move:         rts
.960c					xt_name_to_int:
.960c	20 5a d8	jsr $d85a	                jsr underflow_1
.960f	b5 00		lda $00,x	                lda 0,x
.9611	18		clc		                clc
.9612	69 04		adc #$04	                adc #4
.9614	85 28		sta $28		                sta tmp3
.9616	b5 01		lda $01,x	                lda 1,x
.9618	90 01		bcc $961b	                bcc _done
.961a	1a		inc a		                ina
.961b					_done:
.961b	85 29		sta $29		                sta tmp3+1
.961d	a0 00		ldy #$00	                ldy #0
.961f	b1 28		lda ($28),y	                lda (tmp3),y
.9621	95 00		sta $00,x	                sta 0,x
.9623	c8		iny		                iny
.9624	b1 28		lda ($28),y	                lda (tmp3),y
.9626	95 01		sta $01,x	                sta 1,x
.9628	60		rts		z_name_to_int:  rts
.9629					xt_name_to_string:
.9629	20 5a d8	jsr $d85a	                jsr underflow_1
.962c	ca		dex		                dex
.962d	ca		dex		                dex
.962e	a1 02		lda ($02,x)	                lda (2,x)
.9630	95 00		sta $00,x	                sta 0,x
.9632	74 01		stz $01,x	                stz 1,x
.9634	b5 02		lda $02,x	                lda 2,x         ; LSB
.9636	18		clc		                clc
.9637	69 08		adc #$08	                adc #8
.9639	a8		tay		                tay
.963a	b5 03		lda $03,x	                lda 3,x         ; MSB
.963c	69 00		adc #$00	                adc #0          ; just need carry
.963e	95 03		sta $03,x	                sta 3,x
.9640	94 02		sty $02,x	                sty 2,x
.9642					z_name_to_string:
.9642	60		rts		                rts
.9643					xt_nc_limit:
.9643	ca		dex		                dex
.9644	ca		dex		                dex
.9645	a9 1a		lda #$1a	                lda #<nc_limit
.9647	95 00		sta $00,x	                sta 0,x
.9649	a9 00		lda #$00	                lda #>nc_limit
.964b	95 01		sta $01,x	                sta 1,x
.964d	60		rts		z_nc_limit:     rts
.964e					xt_negate:
.964e	20 5a d8	jsr $d85a	                jsr underflow_1
.9651	a9 00		lda #$00	        	lda #0
.9653	38		sec		                sec
.9654	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.9656	95 00		sta $00,x	                sta 0,x
.9658	a9 00		lda #$00	                lda #0
.965a	f5 01		sbc $01,x	                sbc 1,x         ; MSB
.965c	95 01		sta $01,x	                sta 1,x
.965e	60		rts		z_negate:       rts
.965f					xt_never_native:
.965f	20 9c d7	jsr $d79c	                jsr current_to_dp
.9662	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9664	b1 02		lda ($02),y	                lda (dp),y
.9666	09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9668	29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.966a	91 02		sta ($02),y	                sta (dp),y
.966c					z_never_native:
.966c	60		rts		                rts
.966d					xt_nip:
.966d	20 5f d8	jsr $d85f	                jsr underflow_2
.9670	b5 00		lda $00,x	                lda 0,x         ; LSB
.9672	95 02		sta $02,x	                sta 2,x
.9674	b5 01		lda $01,x	                lda 1,x         ; MSB
.9676	95 03		sta $03,x	                sta 3,x
.9678	e8		inx		                inx
.9679	e8		inx		                inx
.967a	60		rts		z_nip:          rts
.967b					xt_not_equals:
.967b	20 5f d8	jsr $d85f	                jsr underflow_2
.967e	a0 00		ldy #$00	                ldy #0                  ; default is true
.9680	b5 00		lda $00,x	                lda 0,x                 ; LSB
.9682	d5 02		cmp $02,x	                cmp 2,x
.9684	d0 0a		bne $9690	                bne _not_equal
.9686	b5 01		lda $01,x	                lda 1,x                 ; MSB
.9688	d5 03		cmp $03,x	                cmp 3,x
.968a	d0 04		bne $9690	                bne _not_equal
.968c	a9 ff		lda #$ff	                lda #$FF
.968e	80 01		bra $9691	                bra _done
.9690					_not_equal:
.9690	88		dey		                dey                     ; drop thru to done
.9691					_done:
.9691	98		tya		                tya
.9692	e8		inx		                inx
.9693	e8		inx		                inx
.9694	95 00		sta $00,x	                sta 0,x
.9696	95 01		sta $01,x	                sta 1,x
.9698	60		rts		z_not_equals:   rts
.9699					xt_not_rote:
.9699	20 64 d8	jsr $d864	                jsr underflow_3
.969c	b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.969e	b5 03		lda $03,x	                lda 3,x
.96a0	95 01		sta $01,x	                sta 1,x
.96a2	b5 05		lda $05,x	                lda 5,x
.96a4	95 03		sta $03,x	                sta 3,x
.96a6	94 05		sty $05,x	                sty 5,x
.96a8	b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.96aa	b5 02		lda $02,x	                lda 2,x
.96ac	95 00		sta $00,x	                sta 0,x
.96ae	b5 04		lda $04,x	                lda 4,x
.96b0	95 02		sta $02,x	                sta 2,x
.96b2	94 04		sty $04,x	                sty 4,x
.96b4	60		rts		z_not_rote:     rts
.96b5					xt_number:
.96b5	20 5f d8	jsr $d85f	                jsr underflow_2
.96b8	64 2a		stz $2a		                stz tmpdsp      ; flag for double
.96ba	64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.96bc	a5 18		lda $18		                lda base
.96be	48		pha		                pha
.96bf	20 e3 a3	jsr $a3e3	                jsr xt_two_dup
.96c2	a1 02		lda ($02,x)	                lda (2,x)
.96c4					_check_dec:
.96c4	c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.96c6	d0 04		bne $96cc	                bne _check_hex
.96c8	a9 0a		lda #$0a	                lda #$0A
.96ca	80 42		bra $970e	                bra _base_changed
.96cc					_check_hex:
.96cc	c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.96ce	d0 04		bne $96d4	                bne _check_binary
.96d0	a9 10		lda #$10	                lda #$10
.96d2	80 3a		bra $970e	                bra _base_changed
.96d4					_check_binary:
.96d4	c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.96d6	d0 04		bne $96dc	                bne _check_char
.96d8	a9 02		lda #$02	                lda #$02
.96da	80 32		bra $970e	                bra _base_changed
.96dc					_check_char:
.96dc	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96de	d0 3a		bne $971a	                bne _check_minus
.96e0	b5 00		lda $00,x	                lda 0,x         ; Get the length
.96e2	c9 03		cmp #$03	                cmp #$03
.96e4	d0 26		bne $970c	                bne _not_a_char
.96e6	b5 01		lda $01,x	                lda 1,x
.96e8	d0 22		bne $970c	                bne _not_a_char ; No compare needed to check for non-zero.
.96ea	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96ec	18		clc		                clc
.96ed	69 02		adc #$02	                adc #2          ; length of string
.96ef	85 2c		sta $2c		                sta tmptos
.96f1	b5 03		lda $03,x	                lda 3,x
.96f3	69 00		adc #$00	                adc #0          ; only need carry
.96f5	85 2d		sta $2d		                sta tmptos+1
.96f7	b2 2c		lda ($2c)	                lda (tmptos)
.96f9	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96fb	d0 0f		bne $970c	                bne _not_a_char
.96fd	f6 02		inc $02,x	                inc 2,x
.96ff	d0 02		bne $9703	                bne +
.9701	f6 03		inc $03,x	                inc 3,x
.9703					+
.9703	a1 02		lda ($02,x)	                lda (2,x)
.9705	95 02		sta $02,x	                sta 2,x
.9707	74 03		stz $03,x	                stz 3,x
.9709	4c 8a 97	jmp $978a	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.970c					_not_a_char:
.970c	80 5a		bra $9768	                bra _number_error
.970e					_base_changed:
.970e	85 18		sta $18		                sta base        ; Switch to the new base
.9710	f6 02		inc $02,x	                inc 2,x         ; start one character later
.9712	d0 02		bne $9716	                bne +
.9714	f6 03		inc $03,x	                inc 3,x
.9716					+
.9716	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9718	a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.971a					_check_minus:
.971a	c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.971c	d0 0a		bne $9728	                bne _check_dot
.971e	c6 2b		dec $2b		                dec tmpdsp+1
.9720	f6 02		inc $02,x	                inc 2,x         ; start one character later
.9722	d0 02		bne $9726	                bne +
.9724	f6 03		inc $03,x	                inc 3,x
.9726					+
.9726	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9728					_check_dot:
.9728	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.972a	18		clc		                clc
.972b	75 00		adc $00,x	                adc 0,x         ; length of string
.972d	85 2c		sta $2c		                sta tmptos
.972f	b5 03		lda $03,x	                lda 3,x
.9731	69 00		adc #$00	                adc #0          ; only need carry
.9733	85 2d		sta $2d		                sta tmptos+1
.9735	a5 2c		lda $2c		                lda tmptos
.9737	d0 02		bne $973b	                bne +
.9739	c6 2d		dec $2d		                dec tmptos+1
.973b					+
.973b	c6 2c		dec $2c		                dec tmptos
.973d	b2 2c		lda ($2c)	                lda (tmptos)
.973f	c9 2e		cmp #$2e	                cmp #'.'
.9741	d0 04		bne $9747	                bne _main
.9743	c6 2a		dec $2a		                dec tmpdsp
.9745	d6 00		dec $00,x	                dec 0,x
.9747					_main:
.9747	ca		dex		                dex
.9748	ca		dex		                dex
.9749	ca		dex		                dex
.974a	ca		dex		                dex
.974b	b5 04		lda $04,x	                lda 4,x         ; LSB of length
.974d	95 00		sta $00,x	                sta 0,x
.974f	74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9751	b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9753	95 02		sta $02,x	                sta 2,x
.9755	b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9757	95 03		sta $03,x	                sta 3,x
.9759	74 04		stz $04,x	                stz 4,x         ; clear space for ud
.975b	74 05		stz $05,x	                stz 5,x
.975d	74 06		stz $06,x	                stz 6,x
.975f	74 07		stz $07,x	                stz 7,x
.9761	20 e8 a2	jsr $a2e8	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9764	b5 00		lda $00,x	                lda 0,x
.9766	f0 1e		beq $9786	                beq _all_converted
.9768					_number_error:
.9768	20 db a3	jsr $a3db	                jsr xt_two_drop ; >NUMBER modified addr u
.976b	20 db a3	jsr $a3db	                jsr xt_two_drop ; ud   (partially converted number)
.976e	a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9770	20 21 8e	jsr $8e21	                jsr emit_a
.9773	20 2e a5	jsr $a52e	                jsr xt_type
.9776	a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.9778	20 21 8e	jsr $8e21	                jsr emit_a
.977b	20 49 a1	jsr $a149	                jsr xt_space
.977e	68		pla		                pla
.977f	85 18		sta $18		                sta base
.9781	a9 08		lda #$08	                lda #err_syntax
.9783	4c 70 d8	jmp $d870	                jmp error
.9786					_all_converted:
.9786	e8		inx		                inx ; Drop the current addr u
.9787	e8		inx		                inx
.9788	e8		inx		                inx
.9789	e8		inx		                inx
.978a					_drop_original_string:
.978a	20 a9 a4	jsr $a4a9	                jsr xt_two_swap  ; Drop the original addr u
.978d	20 db a3	jsr $a3db	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9790	a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9792	f0 0d		beq $97a1	                beq _single
.9794	a9 20		lda #$20	                lda #%00100000
.9796	04 20		tsb $20		                tsb status
.9798	a5 2b		lda $2b		                lda tmpdsp+1
.979a	f0 12		beq $97ae	                beq _done       ; no minus, all done
.979c	20 6c 8b	jsr $8b6c	                jsr xt_dnegate
.979f	80 0d		bra $97ae	                bra _done
.97a1					_single:
.97a1	e8		inx		                inx
.97a2	e8		inx		                inx
.97a3	a9 20		lda #$20	                lda #%00100000
.97a5	14 20		trb $20		                trb status
.97a7	a5 2b		lda $2b		                lda tmpdsp+1
.97a9	f0 03		beq $97ae	                beq _done       ; no minus, all done
.97ab	20 4e 96	jsr $964e	                jsr xt_negate
.97ae					_done:
.97ae	68		pla		                pla
.97af	85 18		sta $18		                sta base
.97b1	60		rts		z_number:       rts
.97b2					xt_number_sign:
.97b2	20 5f d8	jsr $d85f	                jsr underflow_2         ; double number
.97b5	20 b2 83	jsr $83b2	                jsr xt_base
.97b8	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; ( ud1 base )
.97bb	20 9b a3	jsr $a39b	                jsr xt_to_r             ; >r
.97be	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; 0
.97c1	20 a8 9a	jsr $9aa8	                jsr xt_r_fetch          ; r@
.97c4	20 e5 a5	jsr $a5e5	                jsr xt_um_slash_mod     ; um/mod
.97c7	20 82 9b	jsr $9b82	                jsr xt_rot              ; rot
.97ca	20 82 9b	jsr $9b82	                jsr xt_rot              ; rot
.97cd	20 bd 9a	jsr $9abd	                jsr xt_r_from           ; r>
.97d0	20 e5 a5	jsr $a5e5	                jsr xt_um_slash_mod     ; um/mod
.97d3	20 82 9b	jsr $9b82	                jsr xt_rot              ; rot
.97d6	20 82 9b	jsr $9b82	                jsr xt_rot              ; ( ud rem )
.97d9	b5 00		lda $00,x	                lda 0,x
.97db	a8		tay		                tay
.97dc	b9 4e d4	lda $d44e,y	                lda s_abc_upper,y
.97df	95 00		sta $00,x	                sta 0,x
.97e1	74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.97e3	20 02 92	jsr $9202	                jsr xt_hold
.97e6					z_number_sign:
.97e6	60		rts		                rts
.97e7					xt_number_sign_greater:
.97e7	20 5f d8	jsr $d85f	                jsr underflow_2         ; double number
.97ea	a5 34		lda $34		                lda tohold
.97ec	95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97ee	95 02		sta $02,x	                sta 2,x
.97f0	a5 35		lda $35		                lda tohold+1
.97f2	95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97f4	95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97f6	20 cc 98	jsr $98cc	                jsr xt_pad      ; ( addr addr pad )
.97f9	38		sec		                sec
.97fa	b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97fc	f5 02		sbc $02,x	                sbc 2,x
.97fe	95 02		sta $02,x	                sta 2,x
.9800	b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.9802	f5 03		sbc $03,x	                sbc 3,x
.9804	95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.9806	e8		inx		                inx
.9807	e8		inx		                inx
.9808					z_number_sign_greater:
.9808	60		rts		                rts
.9809					xt_number_sign_s:
.9809	20 5f d8	jsr $d85f	                jsr underflow_2
.980c					_loop:
.980c	20 b2 97	jsr $97b2	                jsr xt_number_sign
.980f	b5 00		lda $00,x	                lda 0,x
.9811	15 01		ora $01,x	                ora 1,x
.9813	15 02		ora $02,x	                ora 2,x
.9815	15 03		ora $03,x	                ora 3,x
.9817	d0 f3		bne $980c	                bne _loop
.9819					z_number_sign_s:
.9819	60		rts		                rts
.981a					xt_of:
.981a	a0 98		ldy #$98	                ldy #>xt_over
.981c	a9 be		lda #$be	                lda #<xt_over
.981e	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.9821	a0 8e		ldy #$8e	                ldy #>xt_equal
.9823	a9 f9		lda #$f9	                lda #<xt_equal
.9825	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.9828	20 2e 92	jsr $922e	                jsr xt_if
.982b	a0 8d		ldy #$8d	                ldy #>xt_drop
.982d	a9 59		lda #$59	                lda #<xt_drop
.982f	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.9832	60		rts		z_of:           rts
.9833					xt_editor_wordlist:
.9833					xt_one:
.9833	ca		dex		                dex
.9834	ca		dex		                dex
.9835	a9 01		lda #$01	                lda #1
.9837	95 00		sta $00,x	                sta 0,x
.9839	74 01		stz $01,x	                stz 1,x
.983b					z_editor_wordlist:
.983b					z_one:
.983b	60		rts		                rts
.983c					xt_one_minus:
.983c	20 5a d8	jsr $d85a	                jsr underflow_1
.983f	b5 00		lda $00,x	                lda 0,x
.9841	d0 02		bne $9845	                bne +
.9843	d6 01		dec $01,x	                dec 1,x
.9845					+
.9845	d6 00		dec $00,x	                dec 0,x
.9847	60		rts		z_one_minus:    rts
.9848					xt_char_plus:
.9848					xt_one_plus:
.9848	20 5a d8	jsr $d85a	                jsr underflow_1
.984b	f6 00		inc $00,x	                inc 0,x
.984d	d0 02		bne $9851	                bne _done
.984f	f6 01		inc $01,x	                inc 1,x
.9851					_done:
.9851					z_char_plus:
.9851	60		rts		z_one_plus:     rts
.9852					xt_only:
.9852	ca		dex		                dex
.9853	ca		dex		                dex
.9854	a9 ff		lda #$ff	                lda #$FF
.9856	95 00		sta $00,x	                sta 0,x
.9858	95 01		sta $01,x	                sta 1,x
.985a	20 46 9d	jsr $9d46	                jsr xt_set_order
.985d	60		rts		z_only:         rts
.985e					xt_or:
.985e	20 5f d8	jsr $d85f	                jsr underflow_2
.9861	b5 00		lda $00,x	                lda 0,x
.9863	15 02		ora $02,x	                ora 2,x
.9865	95 02		sta $02,x	                sta 2,x
.9867	b5 01		lda $01,x	                lda 1,x
.9869	15 03		ora $03,x	                ora 3,x
.986b	95 03		sta $03,x	                sta 3,x
.986d	e8		inx		                inx
.986e	e8		inx		                inx
.986f	60		rts		z_or:           rts
.9870					xt_order:
.9870	20 8e 89	jsr $898e	                jsr xt_cr
.9873	20 5f 91	jsr $915f	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.9876	b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9878	f0 1e		beq $9898	                beq _drop_done
.987a					_have_wordlists:
.987a	a8		tay		                tay
.987b					_loop:
.987b	e8		inx		                inx
.987c	e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.987d	b5 00		lda $00,x	                lda 0,x
.987f	5a		phy		                phy
.9880	20 9b 98	jsr $989b	                jsr order_print_wid_string   ; internal helper function
.9883	7a		ply		                ply
.9884	88		dey		                dey
.9885	d0 f4		bne $987b	                bne _loop
.9887	20 49 a1	jsr $a149	                jsr xt_space
.988a	20 49 a1	jsr $a149	                jsr xt_space
.988d	20 54 91	jsr $9154	                jsr xt_get_current      ; ( wid )
.9890	b5 00		lda $00,x	                lda 0,x
.9892	20 9b 98	jsr $989b	                jsr order_print_wid_string
.9895	20 8e 89	jsr $898e	                jsr xt_cr
.9898					_drop_done:
.9898	e8		inx		                inx
.9899	e8		inx		                inx
.989a					z_order:
.989a	60		rts		                rts
.989b					order_print_wid_string:
.989b	c9 04		cmp #$04	                cmp #4
.989d	90 09		bcc $98a8	                bcc _output_string      ; less than 4, print a real string
.989f	ca		dex		                dex
.98a0	ca		dex		                dex
.98a1	95 00		sta $00,x	                sta 0,x
.98a3	74 01		stz $01,x	                stz 1,x
.98a5	4c 59 a5	jmp $a559	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.98a8					_output_string:
.98a8	a8		tay		                tay
.98a9	b9 af 98	lda $98af,y	                lda _wid_data,y
.98ac	4c 86 d8	jmp $d886	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.98af					_wid_data:
>98af	03				        .byte str_wid_forth            ; WID 0: "Forth"
>98b0	06				        .byte str_wid_editor           ; WID 1: "Editor"
>98b1	07				        .byte str_wid_assembler        ; WID 2: "Assembler"
>98b2	08				        .byte str_wid_root             ; WID 3: "Root"
.98b3					xt_output:
.98b3	ca		dex		                dex
.98b4	ca		dex		                dex
.98b5	a9 10		lda #$10	                lda #<output
.98b7	95 00		sta $00,x	                sta 0,x
.98b9	a9 00		lda #$00	                lda #>output
.98bb	95 01		sta $01,x	                sta 1,x
.98bd	60		rts		z_output:       rts
.98be					xt_over:
.98be	20 5f d8	jsr $d85f	                jsr underflow_2
.98c1	ca		dex		                dex
.98c2	ca		dex		                dex
.98c3	b5 04		lda $04,x	                lda 4,x         ; LSB
.98c5	95 00		sta $00,x	                sta 0,x
.98c7	b5 05		lda $05,x	                lda 5,x         ; MSB
.98c9	95 01		sta $01,x	                sta 1,x
.98cb	60		rts		z_over:         rts
.98cc					xt_pad:
.98cc	ca		dex		                dex
.98cd	ca		dex		                dex
.98ce	a5 00		lda $00		                lda cp
.98d0	18		clc		                clc
.98d1	69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.98d3	95 00		sta $00,x	                sta 0,x
.98d5	a5 01		lda $01		                lda cp+1
.98d7	69 00		adc #$00	                adc #0          ; only need carry
.98d9	95 01		sta $01,x	                sta 1,x
.98db	60		rts		z_pad:          rts
.98dc					xt_page:
.98dc	a9 1b		lda #$1b	                lda #AscESC
.98de	20 21 8e	jsr $8e21	                jsr emit_a
.98e1	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.98e3	20 21 8e	jsr $8e21	                jsr emit_a
.98e6	a9 32		lda #$32	                lda #'2'
.98e8	20 21 8e	jsr $8e21	                jsr emit_a
.98eb	a9 4a		lda #$4a	                lda #'J'
.98ed	20 21 8e	jsr $8e21	                jsr emit_a
.98f0	20 d3 a7	jsr $a7d3	                jsr xt_zero
.98f3	20 d3 a7	jsr $a7d3	                jsr xt_zero
.98f6	20 59 83	jsr $8359	                jsr xt_at_xy
.98f9	60		rts		z_page:         rts
.98fa					xt_paren:
.98fa	ca		dex		                dex
.98fb	ca		dex		                dex
.98fc	a9 29		lda #$29	                lda #41     ; Right parenthesis
.98fe	95 00		sta $00,x	                sta 0,x
.9900	74 01		stz $01,x	                stz 1,x
.9902	20 65 99	jsr $9965	                jsr xt_parse
.9905	e8		inx		                inx
.9906	e8		inx		                inx
.9907	e8		inx		                inx
.9908	e8		inx		                inx
.9909	60		rts		z_paren:        rts
.990a					xt_parse_name:
.990a	a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.990c	38		sec		                sec
.990d	e5 0c		sbc $0c		                sbc toin
.990f	85 24		sta $24		                sta tmp1
.9911	a5 0b		lda $0b		                lda ciblen+1            ; MSB
.9913	e5 0d		sbc $0d		                sbc toin+1
.9915	85 25		sta $25		                sta tmp1+1
.9917	a5 24		lda $24		                lda tmp1
.9919	05 25		ora $25		                ora tmp1+1
.991b	f0 28		beq $9945	                beq _empty_line
.991d	a5 08		lda $08		                lda cib
.991f	18		clc		                clc
.9920	65 0c		adc $0c		                adc toin
.9922	85 26		sta $26		                sta tmp2                ; LSB of first character
.9924	a5 09		lda $09		                lda cib+1
.9926	65 0d		adc $0d		                adc toin+1
.9928	85 27		sta $27		                sta tmp2+1              ; MSB
.992a					_skip_loop:
.992a	b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.992c	20 4d d8	jsr $d84d	                jsr is_whitespace
.992f	90 1f		bcc $9950	                bcc _char_found
.9931	e6 26		inc $26		                inc tmp2
.9933	d0 02		bne $9937	                bne +
.9935	e6 27		inc $27		                inc tmp2+1
.9937					+
.9937	a5 24		lda $24		                lda tmp1
.9939	d0 02		bne $993d	                bne +
.993b	c6 25		dec $25		                dec tmp1+1
.993d	c6 24		dec $24		+               dec tmp1
.993f	a5 24		lda $24		                lda tmp1
.9941	05 25		ora $25		                ora tmp1+1
.9943	d0 e5		bne $992a	                bne _skip_loop          ; fall through if empty line
.9945					_empty_line:
.9945	ca		dex		                dex
.9946	ca		dex		                dex
.9947	ca		dex		                dex
.9948	ca		dex		                dex
.9949	74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.994b	74 01		stz $01,x	                stz 1,x
.994d	4c fc 99	jmp $99fc	                jmp z_parse_name        ; skip over PARSE
.9950					_char_found:
.9950	a5 26		lda $26		                lda tmp2
.9952	38		sec		                sec
.9953	e5 08		sbc $08		                sbc cib
.9955	85 0c		sta $0c		                sta toin
.9957	a5 27		lda $27		                lda tmp2+1
.9959	e5 09		sbc $09		                sbc cib+1
.995b	85 0d		sta $0d		                sta toin+1
.995d	ca		dex		                dex
.995e	ca		dex		                dex
.995f	a9 20		lda #$20	                lda #AscSP
.9961	95 00		sta $00,x	                sta 0,x
.9963	74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.9965					xt_parse:
.9965	20 5a d8	jsr $d85a	                jsr underflow_1
.9968	a5 0a		lda $0a		                lda ciblen
.996a	05 0b		ora $0b		                ora ciblen+1
.996c	f0 0c		beq $997a	                beq _abort_parse
.996e	a5 0d		lda $0d		                lda toin+1              ; MSB
.9970	c5 0b		cmp $0b		                cmp ciblen+1
.9972	90 0e		bcc $9982	                bcc _go_parse           ; unsigned comparison
.9974	a5 0c		lda $0c		                lda toin                ; LSB
.9976	c5 0a		cmp $0a		                cmp ciblen
.9978	90 08		bcc $9982	                bcc _go_parse
.997a					_abort_parse:
.997a	ca		dex		                dex
.997b	ca		dex		                dex
.997c	74 00		stz $00,x	                stz 0,x
.997e	74 01		stz $01,x	                stz 1,x
.9980	80 7a		bra $99fc	                bra _done
.9982					_go_parse:
.9982	b5 00		lda $00,x	                lda 0,x
.9984	85 2c		sta $2c		                sta tmptos
.9986	ca		dex		                dex
.9987	ca		dex		                dex
.9988	a5 08		lda $08		                lda cib
.998a	18		clc		                clc
.998b	65 0c		adc $0c		                adc toin        ; LSB
.998d	85 24		sta $24		                sta tmp1
.998f	85 26		sta $26		                sta tmp2
.9991	95 02		sta $02,x	                sta 2,x
.9993	a5 09		lda $09		                lda cib+1
.9995	65 0d		adc $0d		                adc toin+1      ; MSB
.9997	85 25		sta $25		                sta tmp1+1
.9999	85 27		sta $27		                sta tmp2+1
.999b	95 03		sta $03,x	                sta 3,x
.999d	a5 08		lda $08		                lda cib
.999f	18		clc		                clc
.99a0	65 0a		adc $0a		                adc ciblen
.99a2	85 28		sta $28		                sta tmp3
.99a4	a5 09		lda $09		                lda cib+1
.99a6	65 0b		adc $0b		                adc ciblen+1
.99a8	85 29		sta $29		                sta tmp3+1
.99aa	64 2d		stz $2d		                stz tmptos+1
.99ac					_loop:
.99ac	a5 26		lda $26		                lda tmp2
.99ae	c5 28		cmp $28		                cmp tmp3
.99b0	d0 06		bne $99b8	                bne _not_empty
.99b2	a5 27		lda $27		                lda tmp2+1
.99b4	c5 29		cmp $29		                cmp tmp3+1
.99b6	f0 1d		beq $99d5	                beq _eol
.99b8					_not_empty:
.99b8	b2 26		lda ($26)	                lda (tmp2)
.99ba	a4 2c		ldy $2c		                ldy tmptos
.99bc	c0 20		cpy #$20	                cpy #AscSP
.99be	d0 07		bne $99c7	                bne _not_whitespace
.99c0	20 4d d8	jsr $d84d	                jsr is_whitespace
.99c3	90 02		bcc $99c7	                bcc _not_whitespace
.99c5	80 0c		bra $99d3	                bra _found_delimiter
.99c7					_not_whitespace:
.99c7	c5 2c		cmp $2c		                cmp tmptos
.99c9	f0 08		beq $99d3	                beq _found_delimiter
.99cb	e6 26		inc $26		                inc tmp2
.99cd	d0 dd		bne $99ac	                bne _loop
.99cf	e6 27		inc $27		                inc tmp2+1
.99d1	80 d9		bra $99ac	                bra _loop
.99d3					_found_delimiter:
.99d3	e6 2d		inc $2d		                inc tmptos+1
.99d5					_eol:
.99d5	a5 26		lda $26		                lda tmp2
.99d7	38		sec		                sec
.99d8	e5 24		sbc $24		                sbc tmp1
.99da	95 00		sta $00,x	                sta 0,x
.99dc	a5 27		lda $27		                lda tmp2+1
.99de	e5 25		sbc $25		                sbc tmp1+1
.99e0	95 01		sta $01,x	                sta 1,x
.99e2	a5 26		lda $26		                lda tmp2
.99e4	38		sec		                sec
.99e5	e5 08		sbc $08		                sbc cib
.99e7	85 0c		sta $0c		                sta toin
.99e9	a5 27		lda $27		                lda tmp2+1
.99eb	e5 09		sbc $09		                sbc cib+1
.99ed	85 0d		sta $0d		                sta toin+1
.99ef	a5 0c		lda $0c		                lda toin
.99f1	18		clc		                clc
.99f2	65 2d		adc $2d		                adc tmptos+1
.99f4	85 0c		sta $0c		                sta toin
.99f6	a5 0d		lda $0d		                lda toin+1
.99f8	69 00		adc #$00	                adc #0          ; we only need the carry
.99fa	85 0d		sta $0d		                sta toin+1
.99fc					_done:
.99fc					z_parse_name:
.99fc	60		rts		z_parse:        rts
.99fd					xt_pick:
.99fd	16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99ff	8a		txa		                txa
.9a00	75 00		adc $00,x	                adc 0,x
.9a02	a8		tay		                tay
.9a03	b9 02 00	lda $0002,y	                lda 0002,y
.9a06	95 00		sta $00,x	                sta 0,x
.9a08	b9 03 00	lda $0003,y	                lda 0003,y
.9a0b	95 01		sta $01,x	                sta 1,x
.9a0d	60		rts		z_pick:         rts
.9a0e					xt_plus:
.9a0e	20 5f d8	jsr $d85f	                jsr underflow_2
.9a11	18		clc		                clc
.9a12	b5 00		lda $00,x	                lda 0,x         ; LSB
.9a14	75 02		adc $02,x	                adc 2,x
.9a16	95 02		sta $02,x	                sta 2,x
.9a18	b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.9a1a	75 03		adc $03,x	                adc 3,x
.9a1c	95 03		sta $03,x	                sta 3,x
.9a1e	e8		inx		                inx
.9a1f	e8		inx		                inx
.9a20	60		rts		z_plus:         rts
.9a21					xt_plus_store:
.9a21	20 5f d8	jsr $d85f	                jsr underflow_2
.9a24	b5 00		lda $00,x	                lda 0,x
.9a26	85 24		sta $24		                sta tmp1
.9a28	b5 01		lda $01,x	                lda 1,x
.9a2a	85 25		sta $25		                sta tmp1+1
.9a2c	a0 00		ldy #$00	                ldy #0          ; LSB
.9a2e	b1 24		lda ($24),y	                lda (tmp1),y
.9a30	18		clc		                clc
.9a31	75 02		adc $02,x	                adc 2,x
.9a33	91 24		sta ($24),y	                sta (tmp1),y
.9a35	c8		iny		                iny             ; MSB
.9a36	b1 24		lda ($24),y	                lda (tmp1),y
.9a38	75 03		adc $03,x	                adc 3,x
.9a3a	91 24		sta ($24),y	                sta (tmp1),y
.9a3c	e8		inx		                inx
.9a3d	e8		inx		                inx
.9a3e	e8		inx		                inx
.9a3f	e8		inx		                inx
.9a40	60		rts		z_plus_store:   rts
.9a41					xt_postpone:
.9a41	20 0a 99	jsr $990a	                jsr xt_parse_name               ; ( -- addr n )
.9a44	b5 00		lda $00,x	                lda 0,x
.9a46	15 01		ora $01,x	                ora 1,x
.9a48	d0 05		bne $9a4f	                bne +
.9a4a	a9 05		lda #$05	                lda #err_noname
.9a4c	4c 70 d8	jmp $d870	                jmp error
.9a4f					+
.9a4f	20 06 90	jsr $9006	                jsr xt_find_name                ; ( -- nt | 0 )
.9a52	d0 05		bne $9a59	                bne +
.9a54	a9 05		lda #$05	                lda #err_noname
.9a56	4c 70 d8	jmp $d870	                jmp error
.9a59					+
.9a59	b5 00		lda $00,x	                lda 0,x
.9a5b	85 24		sta $24		                sta tmp1
.9a5d	b5 01		lda $01,x	                lda 1,x
.9a5f	85 25		sta $25		                sta tmp1+1
.9a61	20 0c 96	jsr $960c	                jsr xt_name_to_int              ; ( nt -- xt )
.9a64	e6 24		inc $24		                inc tmp1
.9a66	d0 02		bne $9a6a	                bne +
.9a68	e6 25		inc $25		                inc tmp1+1
.9a6a					+
.9a6a	b2 24		lda ($24)	                lda (tmp1)
.9a6c	29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a6e	f0 05		beq $9a75	                beq _not_immediate
.9a70	20 18 88	jsr $8818	                jsr xt_compile_comma
.9a73	80 0a		bra $9a7f	                bra _done
.9a75					_not_immediate:
.9a75	20 b5 93	jsr $93b5	                jsr xt_literal
.9a78	a0 88		ldy #$88	                ldy #>xt_compile_comma
.9a7a	a9 18		lda #$18	                lda #<xt_compile_comma
.9a7c	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.9a7f					_done:
.9a7f	60		rts		z_postpone:     rts
.9a80					xt_previous:
.9a80	20 5f 91	jsr $915f	                jsr xt_get_order
.9a83	20 6d 96	jsr $966d	                jsr xt_nip
.9a86	20 3c 98	jsr $983c	                jsr xt_one_minus
.9a89	20 46 9d	jsr $9d46	                jsr xt_set_order
.9a8c	60		rts		z_previous:     rts
.9a8d					xt_question:
.9a8d	20 ab 8f	jsr $8fab	                jsr xt_fetch
.9a90	20 61 8c	jsr $8c61	                jsr xt_dot
.9a93	60		rts		z_question:     rts
.9a94					xt_question_dup:
.9a94	20 5a d8	jsr $d85a	                jsr underflow_1
.9a97	b5 00		lda $00,x	                lda 0,x
.9a99	15 01		ora $01,x	                ora 1,x
.9a9b	f0 0a		beq $9aa7	                beq _done
.9a9d	ca		dex		                dex
.9a9e	ca		dex		                dex
.9a9f	b5 02		lda $02,x	                lda 2,x
.9aa1	95 00		sta $00,x	                sta 0,x
.9aa3	b5 03		lda $03,x	                lda 3,x
.9aa5	95 01		sta $01,x	                sta 1,x
.9aa7					_done:
.9aa7	60		rts		z_question_dup: rts
.9aa8					xt_r_fetch:
.9aa8	7a		ply		                ply             ; LSB
.9aa9	84 24		sty $24		                sty tmp1
.9aab	7a		ply		                ply             ; MSB
.9aac	ca		dex		                dex
.9aad	ca		dex		                dex
.9aae	68		pla		                pla             ; LSB
.9aaf	95 00		sta $00,x	                sta 0,x
.9ab1	68		pla		                pla             ; MSB
.9ab2	95 01		sta $01,x	                sta 1,x
.9ab4	48		pha		                pha
.9ab5	b5 00		lda $00,x	                lda 0,x
.9ab7	48		pha		                pha
.9ab8	5a		phy		                phy             ; MSB
.9ab9	a4 24		ldy $24		                ldy tmp1
.9abb	5a		phy		                phy             ; LSB
.9abc	60		rts		z_r_fetch:      rts
.9abd					xt_r_from:
.9abd	68		pla		                pla             ; LSB
.9abe	85 2c		sta $2c		                sta tmptos
.9ac0	7a		ply		                ply             ; MSB
.9ac1	ca		dex		                dex
.9ac2	ca		dex		                dex
.9ac3	68		pla		                pla             ; LSB
.9ac4	95 00		sta $00,x	                sta 0,x
.9ac6	68		pla		                pla             ; MSB
.9ac7	95 01		sta $01,x	                sta 1,x
.9ac9	5a		phy		                phy             ; MSB
.9aca	a5 2c		lda $2c		                lda tmptos
.9acc	48		pha		                pha             ; LSB
.9acd	60		rts		z_r_from:       rts
.9ace					xt_r_to_input:
.9ace	68		pla		                pla
.9acf	85 24		sta $24		                sta tmp1
.9ad1	68		pla		                pla
.9ad2	85 25		sta $25		                sta tmp1+1
.9ad4	a0 00		ldy #$00	                ldy #0
.9ad6					_loop:
.9ad6	68		pla		                pla
.9ad7	99 06 00	sta $0006,y	                sta insrc,y
.9ada	c8		iny		                iny
.9adb	c0 08		cpy #$08	                cpy #8
.9add	d0 f7		bne $9ad6	                bne _loop
.9adf	a5 25		lda $25		                lda tmp1+1
.9ae1	48		pha		                pha
.9ae2	a5 24		lda $24		                lda tmp1
.9ae4	48		pha		                pha
.9ae5	60		rts		z_r_to_input: 	rts
.9ae6					xt_recurse:
.9ae6	a0 00		ldy #$00	                ldy #0
.9ae8	a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9aea	91 00		sta ($00),y	                sta (cp),y
.9aec	c8		iny		                iny
.9aed	24 20		bit $20		                bit status
.9aef	70 0c		bvs $9afd	                bvs _nt_in_workword
.9af1	a5 04		lda $04		                lda workword
.9af3	91 00		sta ($00),y	                sta (cp),y
.9af5	c8		iny		                iny
.9af6	a5 05		lda $05		                lda workword+1
.9af8	91 00		sta ($00),y	                sta (cp),y
.9afa	c8		iny		                iny
.9afb	80 1b		bra $9b18	                bra _update_cp
.9afd					_nt_in_workword:
.9afd	a5 04		lda $04		                lda workword            ; LSB
.9aff	18		clc		                clc
.9b00	69 04		adc #$04	                adc #4
.9b02	85 24		sta $24		                sta tmp1
.9b04	a5 05		lda $05		                lda workword+1          ; MSB
.9b06	69 00		adc #$00	                adc #0
.9b08	85 25		sta $25		                sta tmp1+1
.9b0a	b2 24		lda ($24)	                lda (tmp1)
.9b0c	91 00		sta ($00),y	                sta (cp),y
.9b0e	5a		phy		                phy
.9b0f	a0 01		ldy #$01	                ldy #1
.9b11	b1 24		lda ($24),y	                lda (tmp1),y
.9b13	7a		ply		                ply
.9b14	c8		iny		                iny
.9b15	91 00		sta ($00),y	                sta (cp),y
.9b17	c8		iny		                iny
.9b18					_update_cp:
.9b18	98		tya		                tya
.9b19	18		clc		                clc
.9b1a	65 00		adc $00		                adc cp
.9b1c	85 00		sta $00		                sta cp
.9b1e	90 02		bcc $9b22	                bcc _done
.9b20	e6 01		inc $01		                inc cp+1
.9b22					_done:
.9b22	60		rts		z_recurse:      rts
.9b23					xt_refill:
.9b23	a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9b25	d0 2d		bne $9b54	                bne _src_not_kbd
.9b27	ca		dex		                dex
.9b28	ca		dex		                dex
.9b29	ca		dex		                dex
.9b2a	ca		dex		                dex
.9b2b	a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9b2d	95 02		sta $02,x	                sta 2,x
.9b2f	a5 09		lda $09		                lda cib+1
.9b31	95 03		sta $03,x	                sta 3,x
.9b33	64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9b35	64 0b		stz $0b		                stz ciblen+1
.9b37	a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9b39	95 00		sta $00,x	                sta 0,x
.9b3b	74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9b3d	20 57 81	jsr $8157	                jsr xt_accept           ; ( addr n1 -- n2)
.9b40	b5 00		lda $00,x	                lda 0,x
.9b42	85 0a		sta $0a		                sta ciblen
.9b44	b5 01		lda $01,x	                lda 1,x
.9b46	85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9b48	64 0c		stz $0c		                stz toin
.9b4a	64 0d		stz $0d		                stz toin+1
.9b4c	a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b4e	95 00		sta $00,x	                sta 0,x
.9b50	95 01		sta $01,x	                sta 1,x
.9b52	80 10		bra $9b64	                bra _done
.9b54					_src_not_kbd:
.9b54	1a		inc a		                ina
.9b55	d0 08		bne $9b5f	                bne _src_not_string
.9b57	ca		dex		                dex
.9b58	ca		dex		                dex
.9b59	74 00		stz $00,x	                stz 0,x
.9b5b	74 01		stz $01,x	                stz 1,x
.9b5d	80 05		bra $9b64	                bra z_refill
.9b5f					_src_not_string:
.9b5f	a9 01		lda #$01	                lda #err_badsource
.9b61	4c 70 d8	jmp $d870	                jmp error
.9b64					_done:
.9b64	60		rts		z_refill:       rts
.9b65					xt_repeat:
.9b65	20 92 82	jsr $8292	                jsr xt_again
.9b68	20 9d 91	jsr $919d	                jsr xt_here
.9b6b	20 d9 a1	jsr $a1d9	                jsr xt_swap
.9b6e	20 b8 a1	jsr $a1b8	                jsr xt_store
.9b71	60		rts		z_repeat:       rts
.9b72					xt_right_bracket:
.9b72	a9 ff		lda #$ff	                lda #$FF
.9b74	85 16		sta $16		                sta state
.9b76	85 17		sta $17		                sta state+1
.9b78					z_right_bracket:
.9b78	60		rts		                rts
.9b79					xt_root_wordlist:
.9b79	ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b7a	ca		dex		                dex
.9b7b	a9 03		lda #$03	                lda #3
.9b7d	95 00		sta $00,x	                sta 0,x
.9b7f	74 01		stz $01,x	                stz 1,x
.9b81					z_root_wordlist:
.9b81	60		rts		                rts
.9b82					xt_rot:
.9b82	20 64 d8	jsr $d864	                jsr underflow_3
.9b85	b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b87	b5 03		lda $03,x	                lda 3,x
.9b89	95 05		sta $05,x	                sta 5,x
.9b8b	b5 01		lda $01,x	                lda 1,x
.9b8d	95 03		sta $03,x	                sta 3,x
.9b8f	94 01		sty $01,x	                sty 1,x
.9b91	b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b93	b5 02		lda $02,x	                lda 2,x
.9b95	95 04		sta $04,x	                sta 4,x
.9b97	b5 00		lda $00,x	                lda 0,x
.9b99	95 02		sta $02,x	                sta 2,x
.9b9b	94 00		sty $00,x	                sty 0,x
.9b9d	60		rts		z_rot:          rts
.9b9e					xt_rshift:
.9b9e	20 5f d8	jsr $d85f	                jsr underflow_2
.9ba1	b5 00		lda $00,x	                lda 0,x
.9ba3	29 0f		and #$0f	                and #%00001111
.9ba5	f0 08		beq $9baf	                beq _done               ; if 0 shifts, quit
.9ba7	a8		tay		                tay
.9ba8					_loop:
.9ba8	56 03		lsr $03,x	                lsr 3,x
.9baa	76 02		ror $02,x	                ror 2,x
.9bac	88		dey		                dey
.9bad	d0 f9		bne $9ba8	                bne _loop
.9baf					_done:
.9baf	e8		inx		                inx
.9bb0	e8		inx		                inx
.9bb1	60		rts		z_rshift:       rts
.9bb2					xt_s_backslash_quote:
.9bb2	a9 ff		lda #$ff	                lda #$FF
.9bb4	85 26		sta $26		                sta tmp2
.9bb6	64 27		stz $27		                stz tmp2+1
.9bb8	20 7e 9d	jsr $9d7e	                jsr s_quote_start
.9bbb					_done:
.9bbb					z_s_backslash_quote:
.9bbb	60		rts		                rts
.9bbc					convert_hex_value:
.9bbc	c9 41		cmp #$41	        cmp #'A'
.9bbe	90 07		bcc $9bc7	        bcc _digit
.9bc0	29 df		and #$df	        and #$DF                ; Make it uppercase.
.9bc2	38		sec		        sec
.9bc3	e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9bc5	80 03		bra $9bca	        bra _done
.9bc7					_digit:
.9bc7	38		sec		        sec
.9bc8	e9 30		sbc #$30	        sbc #'0'
.9bca					_done:
.9bca	60		rts		        rts
.9bcb					xt_search_wordlist:
.9bcb	20 64 d8	jsr $d864	                jsr underflow_3
.9bce	a5 1e		lda $1e		                lda up
.9bd0	18		clc		                clc
.9bd1	69 06		adc #$06	                adc #wordlists_offset
.9bd3	85 26		sta $26		                sta tmp2
.9bd5	a5 1f		lda $1f		                lda up+1
.9bd7	69 00		adc #$00	                adc #0          ; Adding carry
.9bd9	85 27		sta $27		                sta tmp2+1
.9bdb	b5 00		lda $00,x	                lda 0,x
.9bdd	0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9bde	65 26		adc $26		                adc tmp2
.9be0	85 26		sta $26		                sta tmp2
.9be2	90 02		bcc $9be6	                bcc +
.9be4	e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9be6					+
.9be6	e8		inx		                inx
.9be7	e8		inx		                inx
.9be8	b5 00		lda $00,x	                lda 0,x
.9bea	15 01		ora $01,x	                ora 1,x
.9bec	d0 03		bne $9bf1	                bne _check_wordlist
.9bee	4c a9 9c	jmp $9ca9	                jmp _done
.9bf1					_check_wordlist:
.9bf1	a5 26		lda $26		                lda tmp2
.9bf3	05 27		ora $27		                ora tmp2+1
.9bf5	d0 03		bne $9bfa	                bne _have_string
.9bf7	4c a9 9c	jmp $9ca9	                jmp _done
.9bfa					_have_string:
.9bfa	b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9bfc	85 24		sta $24		                sta tmp1
.9bfe	e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9c00	d0 02		bne $9c04	                bne +
.9c02	e6 27		inc $27		                inc tmp2+1
.9c04					+
.9c04	b2 26		lda ($26)	                lda (tmp2)
.9c06	85 25		sta $25		                sta tmp1+1
.9c08	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9c0a	85 26		sta $26		                sta tmp2
.9c0c	b5 03		lda $03,x	                lda 3,x
.9c0e	85 27		sta $27		                sta tmp2+1
.9c10					_loop:
.9c10	b2 24		lda ($24)	                lda (tmp1)
.9c12	d5 00		cmp $00,x	                cmp 0,x
.9c14	d0 7b		bne $9c91	                bne _next_entry
.9c16					_compare_string:
.9c16	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9c18	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9c1a	b0 07		bcs $9c23	                bcs _compare_first
.9c1c	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9c1e	90 03		bcc $9c23	                bcc _compare_first
.9c20	18		clc		                clc
.9c21	69 20		adc #$20	                adc #$20
.9c23					_compare_first:
.9c23	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9c25	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9c27	d0 68		bne $9c91	                bne _next_entry
.9c29	b5 00		lda $00,x	                lda 0,x
.9c2b	3a		dec a		                dea
.9c2c	f0 2c		beq $9c5a	                beq _success
.9c2e	a5 24		lda $24		                lda tmp1
.9c30	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9c31	18		clc		                clc
.9c32	69 08		adc #$08	                adc #8
.9c34	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9c36	a5 25		lda $25		                lda tmp1+1
.9c38	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9c39	69 00		adc #$00	                adc #0          ; we only need the carry
.9c3b	85 25		sta $25		                sta tmp1+1
.9c3d	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9c3f	88		dey		                dey
.9c40					_string_loop:
.9c40	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9c42	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9c44	b0 07		bcs $9c4d	                bcs _check_char
.9c46	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9c48	90 03		bcc $9c4d	                bcc _check_char
.9c4a	18		clc		                clc
.9c4b	69 20		adc #$20	                adc #$20
.9c4d					_check_char:
.9c4d	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c4f	d0 3a		bne $9c8b	                bne _next_entry_tmp1
.9c51	88		dey		                dey
.9c52	d0 ec		bne $9c40	                bne _string_loop
.9c54					_success_tmp1:
.9c54	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c55	85 25		sta $25		                sta tmp1+1
.9c57	68		pla		                pla
.9c58	85 24		sta $24		                sta tmp1
.9c5a					_success:
.9c5a	e8		inx		                inx
.9c5b	e8		inx		                inx
.9c5c	a5 24		lda $24		                lda tmp1
.9c5e	95 00		sta $00,x	                sta 0,x
.9c60	a5 25		lda $25		                lda tmp1+1
.9c62	95 01		sta $01,x	                sta 1,x
.9c64	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( nt nt )
.9c67	20 0c 96	jsr $960c	                jsr xt_name_to_int      ; ( nt xt )
.9c6a	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; ( xt nt )
.9c6d	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c6f	f6 00		inc $00,x	                inc 0,x
.9c71	d0 02		bne $9c75	                bne +
.9c73	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c75					+
.9c75	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c77	29 04		and #$04	                and #IM
.9c79	d0 08		bne $9c83	                bne _immediate          ; bit set, we're immediate
.9c7b	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c7d	95 00		sta $00,x	                sta 0,x
.9c7f	95 01		sta $01,x	                sta 1,x
.9c81	80 28		bra $9cab	                bra _done_nodrop
.9c83					_immediate:
.9c83	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c85	95 00		sta $00,x	                sta 0,x
.9c87	74 01		stz $01,x	                stz 1,x
.9c89	80 20		bra $9cab	                bra _done_nodrop
.9c8b					_next_entry_tmp1:
.9c8b	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c8c	85 25		sta $25		                sta tmp1+1
.9c8e	68		pla		                pla
.9c8f	85 24		sta $24		                sta tmp1
.9c91					_next_entry:
.9c91	a0 02		ldy #$02	                ldy #2
.9c93	b1 24		lda ($24),y	                lda (tmp1),y
.9c95	48		pha		                pha
.9c96	c8		iny		                iny
.9c97	b1 24		lda ($24),y	                lda (tmp1),y
.9c99	85 25		sta $25		                sta tmp1+1
.9c9b	68		pla		                pla
.9c9c	85 24		sta $24		                sta tmp1
.9c9e	05 25		ora $25		                ora tmp1+1
.9ca0	f0 03		beq $9ca5	                beq _fail_done
.9ca2	4c 10 9c	jmp $9c10	                jmp _loop
.9ca5					_fail_done:
.9ca5	74 02		stz $02,x	                stz 2,x         ; failure flag
.9ca7	74 03		stz $03,x	                stz 3,x
.9ca9					_done:
.9ca9	e8		inx		                inx
.9caa	e8		inx		                inx
.9cab					_done_nodrop:
.9cab					z_search_wordlist:
.9cab	60		rts		                rts
.9cac					xt_see:
.9cac	20 0a 99	jsr $990a	                jsr xt_parse_name       ; ( addr u )
.9caf	20 06 90	jsr $9006	                jsr xt_find_name        ; ( nt | 0 )
.9cb2	b5 00		lda $00,x	                lda 0,x
.9cb4	15 01		ora $01,x	                ora 1,x
.9cb6	d0 05		bne $9cbd	                bne +
.9cb8	a9 05		lda #$05	                lda #err_noname
.9cba	4c 70 d8	jmp $d870	                jmp error
.9cbd					+
.9cbd	20 8e 89	jsr $898e	                jsr xt_cr
.9cc0	a5 18		lda $18		                lda base
.9cc2	48		pha		                pha
.9cc3	20 a8 91	jsr $91a8	                jsr xt_hex
.9cc6	a9 0a		lda #$0a	                lda #str_see_nt
.9cc8	20 86 d8	jsr $d886	                jsr print_string_no_lf
.9ccb	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( nt nt )
.9cce	20 59 a5	jsr $a559	                jsr xt_u_dot
.9cd1	20 49 a1	jsr $a149	                jsr xt_space            ; ( nt )
.9cd4	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( nt nt )
.9cd7	20 0c 96	jsr $960c	                jsr xt_name_to_int      ; ( nt xt )
.9cda	a9 0b		lda #$0b	                lda #str_see_xt
.9cdc	20 86 d8	jsr $d886	                jsr print_string_no_lf
.9cdf	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( nt xt xt )
.9ce2	20 59 a5	jsr $a559	                jsr xt_u_dot
.9ce5	20 8e 89	jsr $898e	                jsr xt_cr               ; ( nt xt )
.9ce8	a9 09		lda #$09	                lda #str_see_flags
.9cea	20 86 d8	jsr $d886	                jsr print_string_no_lf
.9ced	20 be 98	jsr $98be	                jsr xt_over             ; ( nt xt nt )
.9cf0	20 48 98	jsr $9848	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9cf3	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; ( nt xt flags )
.9cf6	b5 00		lda $00,x	                lda 0,x
.9cf8	a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9cfa					_flag_loop:
.9cfa	48		pha		                pha
.9cfb	29 01		and #$01	                and #%00000001
.9cfd	18		clc		                clc
.9cfe	69 30		adc #$30	                adc #$30                ; ASCII "0"
.9d00	20 21 8e	jsr $8e21	                jsr emit_a
.9d03	20 49 a1	jsr $a149	                jsr xt_space
.9d06	68		pla		                pla
.9d07	6a		ror a		                ror                     ; Next flag
.9d08	88		dey		                dey
.9d09	d0 ef		bne $9cfa	                bne _flag_loop
.9d0b	20 8e 89	jsr $898e	                jsr xt_cr
.9d0e	e8		inx		                inx
.9d0f	e8		inx		                inx                     ; ( nt xt )
.9d10	a9 0c		lda #$0c	                lda #str_see_size
.9d12	20 86 d8	jsr $d886	                jsr print_string_no_lf
.9d15	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; ( xt nt )
.9d18	20 a0 a7	jsr $a7a0	                jsr xt_wordsize         ; ( xt u )
.9d1b	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9d1e	20 d0 8a	jsr $8ad0	                jsr xt_decimal
.9d21	20 59 a5	jsr $a559	                jsr xt_u_dot            ; ( xt u )
.9d24	20 a8 91	jsr $91a8	                jsr xt_hex
.9d27	20 8e 89	jsr $898e	                jsr xt_cr
.9d2a	20 e3 a3	jsr $a3e3	                jsr xt_two_dup          ; ( xt u xt u )
.9d2d	20 5f 8d	jsr $8d5f	                jsr xt_dump
.9d30	20 8e 89	jsr $898e	                jsr xt_cr
.9d33	20 65 8b	jsr $8b65	                jsr xt_disasm
.9d36	68		pla		                pla
.9d37	85 18		sta $18		                sta base
.9d39	60		rts		z_see:          rts
.9d3a					xt_set_current:
.9d3a	20 5a d8	jsr $d85a	                jsr underflow_1
.9d3d	a0 04		ldy #$04	                ldy #current_offset
.9d3f	b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9d41	91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9d43	e8		inx		                inx
.9d44	e8		inx		                inx
.9d45	60		rts		z_set_current:  rts
.9d46					xt_set_order:
.9d46	a9 ff		lda #$ff	                lda #$FF
.9d48	d5 01		cmp $01,x	                cmp 1,x
.9d4a	d0 12		bne $9d5e	                bne _start
.9d4c	d5 00		cmp $00,x	                cmp 0,x
.9d4e	d0 0e		bne $9d5e	                bne _start
.9d50	ca		dex		                dex             ; Make room for the count.
.9d51	ca		dex		                dex
.9d52	74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d54	a9 03		lda #$03	                lda #3
.9d56	95 02		sta $02,x	                sta 2,x
.9d58	74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d5a	a9 01		lda #$01	                lda #1
.9d5c	95 00		sta $00,x	                sta 0,x
.9d5e					_start:
.9d5e	a0 1e		ldy #$1e	                ldy #num_order_offset
.9d60	b5 00		lda $00,x	                lda 0,x
.9d62	91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d64	85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d66	e8		inx		                inx             ; Drop the count off the data stack.
.9d67	e8		inx		                inx
.9d68	a5 24		lda $24		                lda tmp1
.9d6a	f0 0d		beq $9d79	                beq _done       ; If zero, there are no wordlists.
.9d6c	a0 1f		ldy #$1f	                ldy #search_order_offset
.9d6e					_loop:
.9d6e	b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d70	91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d72	c8		iny		                iny
.9d73	e8		inx		                inx
.9d74	e8		inx		                inx
.9d75	c6 24		dec $24		                dec tmp1
.9d77	d0 f5		bne $9d6e	                bne _loop
.9d79					_done:
.9d79	60		rts		z_set_order:    rts
.9d7a					xt_s_quote:
.9d7a	64 26		stz $26		                stz tmp2
.9d7c	64 27		stz $27		                stz tmp2+1
.9d7e					s_quote_start:
.9d7e	ca		dex		                dex
.9d7f	ca		dex		                dex
.9d80	ca		dex		                dex
.9d81	ca		dex		                dex
.9d82	a9 4c		lda #$4c	                lda #$4C
.9d84	20 0d d7	jsr $d70d	                jsr cmpl_a
.9d87	20 0d d7	jsr $d70d	                jsr cmpl_a
.9d8a	20 0d d7	jsr $d70d	                jsr cmpl_a
.9d8d	a5 00		lda $00		                lda cp
.9d8f	95 02		sta $02,x	                sta 2,x
.9d91	a5 01		lda $01		                lda cp+1
.9d93	95 03		sta $03,x	                sta 3,x
.9d95					_savechars_loop:
.9d95	a5 0d		lda $0d		                lda toin+1              ; MSB
.9d97	c5 0b		cmp $0b		                cmp ciblen+1
.9d99	90 2a		bcc $9dc5	                bcc _input_fine         ; unsigned comparison
.9d9b	a5 0c		lda $0c		                lda toin                ; LSB
.9d9d	c5 0a		cmp $0a		                cmp ciblen
.9d9f	90 24		bcc $9dc5	                bcc _input_fine
.9da1	a5 26		lda $26		                lda tmp2
.9da3	48		pha		                pha
.9da4	a5 27		lda $27		                lda tmp2+1
.9da6	48		pha		                pha
.9da7	a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9da9	48		pha		                pha
.9daa	20 23 9b	jsr $9b23	                jsr xt_refill           ; ( -- f )
.9dad	68		pla		                pla
.9dae	85 28		sta $28		                sta tmp3
.9db0	68		pla		                pla
.9db1	85 27		sta $27		                sta tmp2+1
.9db3	68		pla		                pla
.9db4	85 26		sta $26		                sta tmp2
.9db6	b5 00		lda $00,x	                lda 0,x
.9db8	15 01		ora $01,x	                ora 1,x
.9dba	d0 05		bne $9dc1	                bne _refill_ok
.9dbc	a9 06		lda #$06	                lda #err_refill
.9dbe	4c 70 d8	jmp $d870	                jmp error
.9dc1					_refill_ok:
.9dc1	e8		inx		                inx
.9dc2	e8		inx		                inx
.9dc3	80 d0		bra $9d95	                bra _savechars_loop
.9dc5					_input_fine:
.9dc5	a5 08		lda $08		                lda cib
.9dc7	18		clc		                clc
.9dc8	65 0c		adc $0c		                adc toin        ; LSB
.9dca	85 24		sta $24		                sta tmp1
.9dcc	a5 09		lda $09		                lda cib+1
.9dce	65 0d		adc $0d		                adc toin+1      ; MSB
.9dd0	85 25		sta $25		                sta tmp1+1
.9dd2	b2 24		lda ($24)	                lda (tmp1)
.9dd4	24 26		bit $26		                bit tmp2
.9dd6	30 03		bmi $9ddb	                bmi _handle_escapes    ; Only checking bit 7
.9dd8	4c 93 9e	jmp $9e93	                jmp _regular_char
.9ddb					_handle_escapes:
.9ddb	24 27		bit $27		                bit tmp2+1
.9ddd	30 03		bmi $9de2	                bmi _escaped
.9ddf	4c 89 9e	jmp $9e89	                jmp _not_escaped
.9de2					_escaped:
.9de2	70 22		bvs $9e06	                bvs _check_esc_chars
.9de4	a9 01		lda #$01	                lda #1
.9de6	24 27		bit $27		                bit tmp2+1
.9de8	d0 10		bne $9dfa	                bne _esc_x_second_digit
.9dea	e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9dec	b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9dee	20 bc 9b	jsr $9bbc	                jsr convert_hex_value
.9df1	0a		asl a		                asl
.9df2	0a		asl a		                asl
.9df3	0a		asl a		                asl
.9df4	0a		asl a		                asl
.9df5	85 28		sta $28		                sta tmp3    ; Save it for later.
.9df7	4c 9a 9e	jmp $9e9a	                jmp _next_character
.9dfa					_esc_x_second_digit:
.9dfa	64 27		stz $27		                stz tmp2+1
.9dfc	b2 24		lda ($24)	                lda (tmp1)
.9dfe	20 bc 9b	jsr $9bbc	                jsr convert_hex_value
.9e01	05 28		ora $28		                ora tmp3
.9e03	4c 97 9e	jmp $9e97	                jmp _save_character
.9e06					_check_esc_chars:
.9e06	64 27		stz $27		                stz tmp2+1
.9e08					_check_esc_a:
.9e08	c9 61		cmp #$61	                cmp #'a'
.9e0a	d0 05		bne $9e11	                bne _check_esc_b
.9e0c	a9 07		lda #$07	                lda #7
.9e0e	4c 97 9e	jmp $9e97	                jmp _save_character
.9e11					_check_esc_b:
.9e11	c9 62		cmp #$62	                cmp #'b'
.9e13	d0 05		bne $9e1a	                bne _check_esc_e
.9e15	a9 08		lda #$08	                lda #8
.9e17	4c 97 9e	jmp $9e97	                jmp _save_character
.9e1a					_check_esc_e:
.9e1a	c9 65		cmp #$65	                cmp #'e'
.9e1c	d0 04		bne $9e22	                bne _check_esc_f
.9e1e	a9 1b		lda #$1b	                lda #27
.9e20	80 75		bra $9e97	                bra _save_character
.9e22					_check_esc_f:
.9e22	c9 66		cmp #$66	                cmp #'f'
.9e24	d0 04		bne $9e2a	                bne _check_esc_l
.9e26	a9 0c		lda #$0c	                lda #12
.9e28	80 6d		bra $9e97	                bra _save_character
.9e2a					_check_esc_l:
.9e2a	c9 6c		cmp #$6c	                cmp #'l'
.9e2c	d0 04		bne $9e32	                bne _check_esc_m
.9e2e	a9 0a		lda #$0a	                lda #10
.9e30	80 65		bra $9e97	                bra _save_character
.9e32					_check_esc_m:
.9e32	c9 6d		cmp #$6d	                cmp #'m'
.9e34	d0 09		bne $9e3f	                bne _check_esc_n
.9e36	a9 0d		lda #$0d	                lda #13
.9e38	20 0d d7	jsr $d70d	                jsr cmpl_a
.9e3b	a9 0a		lda #$0a	                lda #10
.9e3d	80 58		bra $9e97	                bra _save_character
.9e3f					_check_esc_n:
.9e3f	c9 6e		cmp #$6e	                cmp #'n'
.9e41	d0 04		bne $9e47	                bne _check_esc_q
.9e43	a9 0a		lda #$0a	                lda #10
.9e45	80 50		bra $9e97	                bra _save_character
.9e47					_check_esc_q:
.9e47	c9 71		cmp #$71	                cmp #'q'
.9e49	d0 04		bne $9e4f	                bne _check_esc_r
.9e4b	a9 22		lda #$22	                lda #34
.9e4d	80 48		bra $9e97	                bra _save_character
.9e4f					_check_esc_r:
.9e4f	c9 72		cmp #$72	                cmp #'r'
.9e51	d0 04		bne $9e57	                bne _check_esc_t
.9e53	a9 0d		lda #$0d	                lda #13
.9e55	80 40		bra $9e97	                bra _save_character
.9e57					_check_esc_t:
.9e57	c9 74		cmp #$74	                cmp #'t'
.9e59	d0 04		bne $9e5f	                bne _check_esc_v
.9e5b	a9 09		lda #$09	                lda #9
.9e5d	80 38		bra $9e97	                bra _save_character
.9e5f					_check_esc_v:
.9e5f	c9 76		cmp #$76	                cmp #'v'
.9e61	d0 04		bne $9e67	                bne _check_esc_z
.9e63	a9 0b		lda #$0b	                lda #11
.9e65	80 30		bra $9e97	                bra _save_character
.9e67					_check_esc_z:
.9e67	c9 7a		cmp #$7a	                cmp #'z'
.9e69	d0 04		bne $9e6f	                bne _check_esc_quote
.9e6b	a9 00		lda #$00	                lda #0
.9e6d	80 28		bra $9e97	                bra _save_character
.9e6f					_check_esc_quote:
.9e6f	c9 22		cmp #$22	                cmp #$22
.9e71	d0 04		bne $9e77	                bne _check_esc_x
.9e73	a9 22		lda #$22	                lda #34
.9e75	80 20		bra $9e97	                bra _save_character
.9e77					_check_esc_x:
.9e77	c9 78		cmp #$78	                cmp #'x'
.9e79	d0 06		bne $9e81	                bne _check_esc_backslash
.9e7b	a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e7d	85 27		sta $27		                sta tmp2+1
.9e7f	80 19		bra $9e9a	                bra _next_character
.9e81					_check_esc_backslash:
.9e81	c9 5c		cmp #$5c	                cmp #$5C
.9e83	d0 04		bne $9e89	                bne _not_escaped
.9e85	a9 5c		lda #$5c	                lda #92
.9e87	80 0e		bra $9e97	                bra _save_character
.9e89					_not_escaped:
.9e89	c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e8b	d0 06		bne $9e93	                bne _regular_char
.9e8d	a9 ff		lda #$ff	                lda #$FF
.9e8f	85 27		sta $27		                sta tmp2+1
.9e91	80 07		bra $9e9a	                bra _next_character
.9e93					_regular_char:
.9e93	c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e95	f0 0c		beq $9ea3	                beq _found_string_end
.9e97					_save_character:
.9e97	20 0d d7	jsr $d70d	                jsr cmpl_a
.9e9a					_next_character:
.9e9a	e6 0c		inc $0c		                inc toin
.9e9c	d0 02		bne $9ea0	                bne _savechars_loop_longjump
.9e9e	e6 0d		inc $0d		                inc toin+1
.9ea0					_savechars_loop_longjump:
.9ea0	4c 95 9d	jmp $9d95	                jmp _savechars_loop
.9ea3					_found_string_end:
.9ea3	e6 0c		inc $0c		                inc toin
.9ea5	d0 02		bne $9ea9	                bne +
.9ea7	e6 0d		inc $0d		                inc toin+1
.9ea9					+
.9ea9	a5 00		lda $00		                lda cp
.9eab	38		sec		                sec
.9eac	f5 02		sbc $02,x	                sbc 2,x
.9eae	95 00		sta $00,x	                sta 0,x         ; LSB
.9eb0	a5 01		lda $01		                lda cp+1
.9eb2	f5 03		sbc $03,x	                sbc 3,x
.9eb4	95 01		sta $01,x	                sta 1,x         ; MSB
.9eb6	b5 02		lda $02,x	                lda 2,x
.9eb8	38		sec		                sec
.9eb9	e9 02		sbc #$02	                sbc #2
.9ebb	85 24		sta $24		                sta tmp1
.9ebd	b5 03		lda $03,x	                lda 3,x
.9ebf	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9ec1	85 25		sta $25		                sta tmp1+1
.9ec3	a5 00		lda $00		                lda cp
.9ec5	92 24		sta ($24)	                sta (tmp1)
.9ec7	a0 01		ldy #$01	                ldy #1
.9ec9	a5 01		lda $01		                lda cp+1
.9ecb	91 24		sta ($24),y	                sta (tmp1),y
.9ecd	a5 16		lda $16		                lda state
.9ecf	05 17		ora $17		                ora state+1             ; paranoid
.9ed1	f0 03		beq $9ed6	                beq _done
.9ed3	20 ba a0	jsr $a0ba	                jsr sliteral_const_str         ; ( addr u -- )
.9ed6					_done:
.9ed6	60		rts		z_s_quote:      rts
.9ed7					xt_s_to_d:
.9ed7	20 5a d8	jsr $d85a	                jsr underflow_1
.9eda	ca		dex		                dex
.9edb	ca		dex		                dex
.9edc	74 00		stz $00,x	                stz 0,x
.9ede	74 01		stz $01,x	                stz 1,x
.9ee0	b5 03		lda $03,x	                lda 3,x
.9ee2	10 04		bpl $9ee8	                bpl _done
.9ee4	d6 00		dec $00,x	                dec 0,x
.9ee6	d6 01		dec $01,x	                dec 1,x
.9ee8					_done:
.9ee8	60		rts		z_s_to_d:       rts
.9ee9					xt_save_buffers:
.9ee9	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9eeb	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9eed	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9eef	d0 12		bne $9f03	                bne _done       ; Either not used or not dirty = done!
.9ef1	20 de 83	jsr $83de	                jsr xt_blkbuffer
.9ef4	20 d0 85	jsr $85d0	                jsr xt_buffblocknum
.9ef7	20 ab 8f	jsr $8fab	                jsr xt_fetch
.9efa	20 8b 85	jsr $858b	                jsr xt_block_write
.9efd	a9 01		lda #$01	                lda #1
.9eff	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9f01	91 1e		sta ($1e),y	                sta (up),y
.9f03					_done:
.9f03	60		rts		z_save_buffers: rts
.9f04					xt_scr:
.9f04	ca		dex		                dex
.9f05	ca		dex		                dex
.9f06	18		clc		                clc
.9f07	a5 1e		lda $1e		                lda up
.9f09	69 02		adc #$02	                adc #scr_offset ; Add offset
.9f0b	95 00		sta $00,x	                sta 0,x
.9f0d	a5 1f		lda $1f		                lda up+1
.9f0f	69 00		adc #$00	                adc #0          ; Adding carry
.9f11	95 01		sta $01,x	                sta 1,x
.9f13	60		rts		z_scr:          rts
.9f14					xt_search:
.9f14	20 69 d8	jsr $d869	                jsr underflow_4
.9f17	b5 00		lda $00,x	                lda 0,x
.9f19	15 01		ora $01,x	                ora 1,x
.9f1b	d0 0b		bne $9f28	                bne _start_search
.9f1d	e8		inx		                inx             ; Remove u2
.9f1e	e8		inx		                inx
.9f1f	a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9f21	95 00		sta $00,x	                sta 0,x
.9f23	95 01		sta $01,x	                sta 1,x
.9f25	4c b2 9f	jmp $9fb2	                jmp z_search
.9f28					_start_search:
.9f28	20 d3 a7	jsr $a7d3	                jsr xt_zero
.9f2b					_search_loop:
.9f2b	18		clc		                clc
.9f2c	b5 00		lda $00,x	                lda 0,x
.9f2e	75 02		adc $02,x	                adc 2,x
.9f30	85 24		sta $24		                sta tmp1
.9f32	b5 01		lda $01,x	                lda 1,x
.9f34	75 03		adc $03,x	                adc 3,x
.9f36	d5 07		cmp $07,x	                cmp 7,x
.9f38	90 12		bcc $9f4c	                bcc _init_comparison ; Obviously less
.9f3a	d0 06		bne $9f42	                bne _not_found
.9f3c	b5 06		lda $06,x	                lda 6,x
.9f3e	c5 24		cmp $24		                cmp tmp1
.9f40	b0 0a		bcs $9f4c	                bcs _init_comparison
.9f42					_not_found:
.9f42	e8		inx		                inx             ; Remove offset
.9f43	e8		inx		                inx
.9f44	e8		inx		                inx             ; Remove u2
.9f45	e8		inx		                inx
.9f46	74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9f48	74 01		stz $01,x	                stz 1,x
.9f4a	80 66		bra $9fb2	                bra z_search
.9f4c					_init_comparison:
.9f4c	18		clc		                clc
.9f4d	b5 08		lda $08,x	                lda 8,x
.9f4f	75 00		adc $00,x	                adc 0,x
.9f51	85 24		sta $24		                sta tmp1
.9f53	b5 09		lda $09,x	                lda 9,x
.9f55	75 01		adc $01,x	                adc 1,x
.9f57	85 25		sta $25		                sta tmp1+1
.9f59	b5 04		lda $04,x	                lda 4,x
.9f5b	85 26		sta $26		                sta tmp2
.9f5d	b5 05		lda $05,x	                lda 5,x
.9f5f	85 27		sta $27		                sta tmp2+1
.9f61	b5 02		lda $02,x	                lda 2,x
.9f63	85 28		sta $28		                sta tmp3
.9f65	b5 03		lda $03,x	                lda 3,x
.9f67	85 29		sta $29		                sta tmp3+1
.9f69					_comparison_loop:
.9f69	b2 24		lda ($24)	                lda (tmp1)
.9f6b	d2 26		cmp ($26)	                cmp (tmp2)
.9f6d	f0 05		beq $9f74	                beq _letters_match
.9f6f	20 48 98	jsr $9848	                jsr xt_one_plus
.9f72	80 b7		bra $9f2b	                bra _search_loop
.9f74					_letters_match:
.9f74	e6 24		inc $24		                inc tmp1
.9f76	d0 02		bne $9f7a	                bne +
.9f78	e6 25		inc $25		                inc tmp1+1
.9f7a					+
.9f7a	e6 26		inc $26		                inc tmp2
.9f7c	d0 02		bne $9f80	                bne +
.9f7e	e6 27		inc $27		                inc tmp2+1
.9f80					+
.9f80	a5 28		lda $28		                lda tmp3
.9f82	d0 02		bne $9f86	                bne +
.9f84	c6 29		dec $29		                dec tmp3+1
.9f86					+
.9f86	c6 28		dec $28		                dec tmp3
.9f88	a5 28		lda $28		                lda tmp3
.9f8a	05 29		ora $29		                ora tmp3+1
.9f8c	d0 db		bne $9f69	                bne _comparison_loop ; Check the next letter
.9f8e	18		clc		                clc
.9f8f	b5 00		lda $00,x	                lda 0,x
.9f91	75 08		adc $08,x	                adc 8,x
.9f93	95 08		sta $08,x	                sta 8,x
.9f95	b5 01		lda $01,x	                lda 1,x
.9f97	75 09		adc $09,x	                adc 9,x
.9f99	95 09		sta $09,x	                sta 9,x
.9f9b	38		sec		                sec
.9f9c	b5 06		lda $06,x	                lda 6,x
.9f9e	f5 00		sbc $00,x	                sbc 0,x
.9fa0	95 06		sta $06,x	                sta 6,x
.9fa2	b5 07		lda $07,x	                lda 7,x
.9fa4	f5 01		sbc $01,x	                sbc 1,x
.9fa6	95 07		sta $07,x	                sta 7,x
.9fa8	e8		inx		                inx             ; drop offset
.9fa9	e8		inx		                inx
.9faa	e8		inx		                inx             ; drop u2
.9fab	e8		inx		                inx
.9fac	a9 ff		lda #$ff	                lda #$FF
.9fae	95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9fb0	95 01		sta $01,x	                sta 1,x
.9fb2	60		rts		z_search:       rts
.9fb3					xt_semicolon:
.9fb3	24 20		bit $20		                bit status
.9fb5	70 11		bvs $9fc8	                bvs _colonword
.9fb7	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9fb9	20 0d d7	jsr $d70d	                jsr cmpl_a
.9fbc	ca		dex		                dex
.9fbd	ca		dex		                dex
.9fbe	a5 04		lda $04		                lda workword
.9fc0	95 00		sta $00,x	                sta 0,x
.9fc2	a5 05		lda $05		                lda workword+1
.9fc4	95 01		sta $01,x	                sta 1,x
.9fc6	80 45		bra $a00d	                bra _semicolon_done
.9fc8					_colonword:
.9fc8	a0 06		ldy #$06	                ldy #6
.9fca	a5 00		lda $00		                lda cp
.9fcc	91 04		sta ($04),y	                sta (workword),y
.9fce	c8		iny		                iny
.9fcf	a5 01		lda $01		                lda cp+1
.9fd1	91 04		sta ($04),y	                sta (workword),y
.9fd3	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9fd5	20 0d d7	jsr $d70d	                jsr cmpl_a
.9fd8	24 20		bit $20		                bit status
.9fda	10 26		bpl $a002	                bpl _new_word   ; Bit 7 is clear = new word
.9fdc	ca		dex		                dex
.9fdd	ca		dex		                dex
.9fde	ca		dex		                dex
.9fdf	ca		dex		                dex
.9fe0	b2 04		lda ($04)	                lda (workword)
.9fe2	95 00		sta $00,x	                sta 0,x
.9fe4	74 01		stz $01,x	                stz 1,x
.9fe6	a5 04		lda $04		                lda workword
.9fe8	18		clc		                clc
.9fe9	69 08		adc #$08	                adc #8
.9feb	95 02		sta $02,x	                sta 2,x
.9fed	a5 05		lda $05		                lda workword+1
.9fef	69 00		adc #$00	                adc #0                  ; only want carry
.9ff1	95 03		sta $03,x	                sta 3,x
.9ff3	a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9ff5	20 86 d8	jsr $d886	                jsr print_string_no_lf
.9ff8	20 2e a5	jsr $a52e	                jsr xt_type
.9ffb	20 49 a1	jsr $a149	                jsr xt_space
.9ffe	a9 80		lda #$80	                lda #%10000000
.a000	14 20		trb $20		                trb status
.a002					_new_word:
.a002	a5 04		lda $04		                lda workword
.a004	85 02		sta $02		                sta dp
.a006	a5 05		lda $05		                lda workword+1
.a008	85 03		sta $03		                sta dp+1
.a00a	20 af d7	jsr $d7af	                jsr dp_to_current       ; Save the updated DP to the
.a00d					_semicolon_done:
.a00d	64 16		stz $16		                stz state
.a00f	64 17		stz $17		                stz state+1
.a011	60		rts		z_semicolon:    rts
.a012					xt_sign:
.a012	20 5a d8	jsr $d85a	                jsr underflow_1
.a015	b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.a017	30 04		bmi $a01d	                bmi _minus
.a019	e8		inx		                inx
.a01a	e8		inx		                inx
.a01b	80 09		bra $a026	                bra _done
.a01d					_minus:
.a01d	a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.a01f	95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.a021	74 01		stz $01,x	                stz 1,x         ; paranoid
.a023	20 02 92	jsr $9202	                jsr xt_hold
.a026					_done:
.a026	60		rts		z_sign:         rts
.a027					xt_slash:
.a027	a9 00		lda #$00	                lda #0
.a029	48		pha		                pha
.a02a	80 03		bra $a02f	                bra slashmod_common
.a02c					xt_slash_mod:
.a02c	a9 ff		lda #$ff	                lda #$FF
.a02e	48		pha		                pha             ; falls through to _common
.a02f					slashmod_common:
.a02f	20 9b a3	jsr $a39b	                jsr xt_to_r             ; >R
.a032	20 d7 9e	jsr $9ed7	                jsr xt_s_to_d           ; S>D
.a035	20 bd 9a	jsr $9abd	                jsr xt_r_from           ; R>
.a038	20 00 a1	jsr $a100	                jsr xt_sm_slash_rem     ; SM/REM
.a03b	68		pla		                pla
.a03c	d0 05		bne $a043	                bne _done
.a03e	20 d9 a1	jsr $a1d9	                jsr xt_swap
.a041	e8		inx		                inx             ; DROP
.a042	e8		inx		                inx
.a043					_done:
.a043					z_slash_mod:
.a043	60		rts		z_slash:        rts
.a044					xt_slash_string:
.a044	20 64 d8	jsr $d864	                jsr underflow_3
.a047	18		clc		                clc             ; 3OS+TOS
.a048	b5 00		lda $00,x	                lda 0,x
.a04a	75 04		adc $04,x	                adc 4,x
.a04c	95 04		sta $04,x	                sta 4,x
.a04e	b5 01		lda $01,x	                lda 1,x
.a050	75 05		adc $05,x	                adc 5,x
.a052	95 05		sta $05,x	                sta 5,x
.a054	38		sec		                sec             ; NOS-TOS
.a055	b5 02		lda $02,x	                lda 2,x
.a057	f5 00		sbc $00,x	                sbc 0,x
.a059	95 02		sta $02,x	                sta 2,x
.a05b	b5 03		lda $03,x	                lda 3,x
.a05d	f5 01		sbc $01,x	                sbc 1,x
.a05f	95 03		sta $03,x	                sta 3,x
.a061	e8		inx		                inx
.a062	e8		inx		                inx
.a063	60		rts		z_slash_string: rts
.a064					xt_sliteral:
.a064	20 5f d8	jsr $d85f	                jsr underflow_2
.a067	a9 4c		lda #$4c	                lda #$4C
.a069	20 0d d7	jsr $d70d	                jsr cmpl_a
.a06c	20 0d d7	jsr $d70d	                jsr cmpl_a
.a06f	20 0d d7	jsr $d70d	                jsr cmpl_a
.a072	8a		txa		                txa
.a073	38		sec		                sec
.a074	e9 06		sbc #$06	                sbc #6
.a076	aa		tax		                tax
.a077	b5 08		lda $08,x	                lda 8,x
.a079	95 04		sta $04,x	                sta 4,x
.a07b	b5 09		lda $09,x	                lda 9,x
.a07d	95 05		sta $05,x	                sta 5,x
.a07f	b5 06		lda $06,x	                lda 6,x
.a081	95 00		sta $00,x	                sta 0,x
.a083	b5 07		lda $07,x	                lda 7,x
.a085	95 01		sta $01,x	                sta 1,x
.a087	a5 00		lda $00		                lda cp
.a089	95 08		sta $08,x	                sta 8,x
.a08b	95 02		sta $02,x	                sta 2,x
.a08d	a5 01		lda $01		                lda cp+1
.a08f	95 09		sta $09,x	                sta 9,x
.a091	95 03		sta $03,x	                sta 3,x
.a093	20 ed 95	jsr $95ed	                jsr xt_move
.a096	18		clc		                clc
.a097	a5 00		lda $00		                lda cp
.a099	75 00		adc $00,x	                adc 0,x
.a09b	85 00		sta $00		                sta cp
.a09d	a5 01		lda $01		                lda cp+1
.a09f	75 01		adc $01,x	                adc 1,x
.a0a1	85 01		sta $01		                sta cp+1
.a0a3	b5 02		lda $02,x	                lda 2,x
.a0a5	38		sec		                sec
.a0a6	e9 02		sbc #$02	                sbc #2
.a0a8	85 24		sta $24		                sta tmp1
.a0aa	b5 03		lda $03,x	                lda 3,x
.a0ac	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a0ae	85 25		sta $25		                sta tmp1+1
.a0b0	a5 00		lda $00		                lda cp
.a0b2	92 24		sta ($24)	                sta (tmp1)
.a0b4	a0 01		ldy #$01	                ldy #1
.a0b6	a5 01		lda $01		                lda cp+1
.a0b8	91 24		sta ($24),y	                sta (tmp1),y
.a0ba					sliteral_const_str:
.a0ba	a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a0bc	a9 d4		lda #$d4	                lda #<sliteral_runtime
.a0be	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.a0c1	b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a0c3	b5 02		lda $02,x	                lda 2,x                ; address LSB
.a0c5	20 09 d7	jsr $d709	                jsr cmpl_word
.a0c8	b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a0ca	b5 00		lda $00,x	                lda 0,x                ; length LSB
.a0cc	20 09 d7	jsr $d709	                jsr cmpl_word
.a0cf	e8		inx		                inx
.a0d0	e8		inx		                inx
.a0d1	e8		inx		                inx
.a0d2	e8		inx		                inx
.a0d3	60		rts		z_sliteral:     rts
.a0d4					sliteral_runtime:
.a0d4	ca		dex		                dex
.a0d5	ca		dex		                dex
.a0d6	ca		dex		                dex
.a0d7	ca		dex		                dex
.a0d8	68		pla		                pla
.a0d9	85 24		sta $24		                sta tmp1        ; LSB of address
.a0db	68		pla		                pla
.a0dc	85 25		sta $25		                sta tmp1+1      ; MSB of address
.a0de	a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a0e0	b1 24		lda ($24),y	                lda (tmp1),y
.a0e2	95 02		sta $02,x	                sta 2,x         ; LSB of address
.a0e4	c8		iny		                iny
.a0e5	b1 24		lda ($24),y	                lda (tmp1),y
.a0e7	95 03		sta $03,x	                sta 3,x         ; MSB of address
.a0e9	c8		iny		                iny
.a0ea	b1 24		lda ($24),y	                lda (tmp1),y
.a0ec	95 00		sta $00,x	                sta 0,x         ; LSB of length
.a0ee	c8		iny		                iny
.a0ef	b1 24		lda ($24),y	                lda (tmp1),y
.a0f1	95 01		sta $01,x	                sta 1,x         ; MSB of length
.a0f3	18		clc		                clc
.a0f4	a5 24		lda $24		                lda tmp1
.a0f6	69 04		adc #$04	                adc #4
.a0f8	a8		tay		                tay             ; LSB
.a0f9	a5 25		lda $25		                lda tmp1+1
.a0fb	69 00		adc #$00	                adc #0          ; we only need carry
.a0fd	48		pha		                pha             ; MSB
.a0fe	5a		phy		                phy
.a0ff	60		rts		                rts
.a100					xt_sm_slash_rem:
.a100	20 64 d8	jsr $d864	                jsr underflow_3 ; contains double number
.a103	b5 03		lda $03,x	                lda 3,x
.a105	48		pha		                pha
.a106	b5 01		lda $01,x	                lda 1,x
.a108	55 03		eor $03,x	                eor 3,x
.a10a	48		pha		                pha
.a10b	20 42 81	jsr $8142	                jsr xt_abs
.a10e	e8		inx		                inx             ; pretend we pushed n1 to R
.a10f	e8		inx		                inx
.a110	20 b1 8a	jsr $8ab1	                jsr xt_dabs
.a113	ca		dex		                dex
.a114	ca		dex		                dex
.a115	20 e5 a5	jsr $a5e5	                jsr xt_um_slash_mod     ; UM/MOD
.a118	68		pla		                pla
.a119	10 03		bpl $a11e	                bpl +
.a11b	20 4e 96	jsr $964e	                jsr xt_negate
.a11e					+
.a11e	68		pla		                pla
.a11f	10 07		bpl $a128	                bpl _done
.a121	e8		inx		                inx             ; pretend we pushed quotient to R
.a122	e8		inx		                inx
.a123	20 4e 96	jsr $964e	                jsr xt_negate
.a126	ca		dex		                dex
.a127	ca		dex		                dex
.a128					_done:
.a128	60		rts		z_sm_slash_rem: rts
.a129					xt_source:
.a129	ca		dex		                dex
.a12a	ca		dex		                dex
.a12b	a5 08		lda $08		                lda cib
.a12d	95 00		sta $00,x	                sta 0,x
.a12f	a5 09		lda $09		                lda cib+1
.a131	95 01		sta $01,x	                sta 1,x
.a133	ca		dex		                dex
.a134	ca		dex		                dex
.a135	a5 0a		lda $0a		                lda ciblen
.a137	95 00		sta $00,x	                sta 0,x
.a139	a5 0b		lda $0b		                lda ciblen+1
.a13b	95 01		sta $01,x	                sta 1,x
.a13d	60		rts		z_source:       rts
.a13e					xt_source_id:
.a13e	ca		dex		                dex
.a13f	ca		dex		                dex
.a140	a5 06		lda $06		                lda insrc
.a142	95 00		sta $00,x	                sta 0,x
.a144	a5 07		lda $07		                lda insrc+1
.a146	95 01		sta $01,x	                sta 1,x
.a148	60		rts		z_source_id:    rts
.a149					xt_space:
.a149	a9 20		lda #$20	                lda #AscSP
.a14b	20 21 8e	jsr $8e21	                jsr emit_a
.a14e	60		rts		z_space:        rts
.a14f					xt_spaces:
.a14f	20 5a d8	jsr $d85a	                jsr underflow_1
.a152	20 d3 a7	jsr $a7d3	                jsr xt_zero
.a155	20 43 95	jsr $9543	                jsr xt_max
.a158	b5 00		lda $00,x	                lda 0,x
.a15a	15 01		ora $01,x	                ora 1,x
.a15c	f0 2a		beq $a188	                beq _done
.a15e	b4 01		ldy $01,x	                ldy 1,x
.a160	d0 0c		bne $a16e	                bne _lots_of_spaces
.a162	b4 00		ldy $00,x	                ldy 0,x
.a164					_quick_loop:
.a164	a9 20		lda #$20	                lda #AscSP
.a166	20 21 8e	jsr $8e21	                jsr emit_a
.a169	88		dey		                dey
.a16a	f0 1c		beq $a188	                beq _done
.a16c	80 f6		bra $a164	                bra _quick_loop
.a16e					_lots_of_spaces:
.a16e	b4 00		ldy $00,x	                ldy 0,x
.a170					_first_slow_loop:
.a170	f0 08		beq $a17a	                beq _slow_outer_loop
.a172	a9 20		lda #$20	                lda #AscSP
.a174	20 21 8e	jsr $8e21	                jsr emit_a
.a177	88		dey		                dey
.a178	80 f6		bra $a170	                bra _first_slow_loop
.a17a					_slow_outer_loop:
.a17a	a0 00		ldy #$00	                ldy #00
.a17c					_slow_inner_loop:
.a17c	a9 20		lda #$20	                lda #AscSP
.a17e	20 21 8e	jsr $8e21	                jsr emit_a
.a181	88		dey		                dey
.a182	d0 f8		bne $a17c	                bne _slow_inner_loop
.a184	d6 01		dec $01,x	                dec 1,x
.a186	d0 f2		bne $a17a	                bne _slow_outer_loop
.a188					_done:
.a188	e8		inx		                inx             ; drop
.a189	e8		inx		                inx
.a18a	60		rts		z_spaces:       rts
.a18b					xt_star:
.a18b	20 5f d8	jsr $d85f	                jsr underflow_2
.a18e	20 27 a6	jsr $a627	                jsr xt_um_star
.a191	e8		inx		                inx
.a192	e8		inx		                inx
.a193	60		rts		z_star:         rts
.a194					xt_star_slash:
.a194	20 9d a1	jsr $a19d	                jsr xt_star_slash_mod
.a197	20 d9 a1	jsr $a1d9	                jsr xt_swap
.a19a	e8		inx		                inx
.a19b	e8		inx		                inx
.a19c					z_star_slash:
.a19c	60		rts		                rts
.a19d					xt_star_slash_mod:
.a19d	20 64 d8	jsr $d864	                jsr underflow_3
.a1a0	20 9b a3	jsr $a39b	                jsr xt_to_r
.a1a3	20 b9 94	jsr $94b9	                jsr xt_m_star
.a1a6	20 bd 9a	jsr $9abd	                jsr xt_r_from
.a1a9	20 00 a1	jsr $a100	                jsr xt_sm_slash_rem
.a1ac					z_star_slash_mod:
.a1ac	60		rts		                rts
.a1ad					xt_state:
.a1ad	ca		dex		                dex
.a1ae	ca		dex		                dex
.a1af	a9 16		lda #$16	                lda #<state
.a1b1	95 00		sta $00,x	                sta 0,x
.a1b3	a9 00		lda #$00	                lda #>state
.a1b5	95 01		sta $01,x	                sta 1,x
.a1b7	60		rts		z_state:        rts
.a1b8					xt_store:
.a1b8	20 5f d8	jsr $d85f	                jsr underflow_2
.a1bb	b5 02		lda $02,x	                lda 2,x         ; LSB
.a1bd	81 00		sta ($00,x)	                sta (0,x)
.a1bf	f6 00		inc $00,x	                inc 0,x
.a1c1	d0 02		bne $a1c5	                bne +
.a1c3	f6 01		inc $01,x	                inc 1,x
.a1c5					+
.a1c5	b5 03		lda $03,x	                lda 3,x         ; MSB
.a1c7	81 00		sta ($00,x)	                sta (0,x)
.a1c9	e8		inx		                inx             ; 2DROP
.a1ca	e8		inx		                inx
.a1cb	e8		inx		                inx
.a1cc	e8		inx		                inx
.a1cd	60		rts		z_store:        rts
.a1ce					xt_strip_underflow:
.a1ce	ca		dex		                dex
.a1cf	ca		dex		                dex
.a1d0	a9 1c		lda #$1c	                lda #<uf_strip
.a1d2	95 00		sta $00,x	                sta 0,x
.a1d4	a9 00		lda #$00	                lda #>uf_strip
.a1d6	95 01		sta $01,x	                sta 1,x
.a1d8					z_strip_underflow:
.a1d8	60		rts		                rts
.a1d9					xt_swap:
.a1d9	20 5f d8	jsr $d85f	                jsr underflow_2
.a1dc	b5 00		lda $00,x	                lda 0,x         ; LSB
.a1de	b4 02		ldy $02,x	                ldy 2,x
.a1e0	95 02		sta $02,x	                sta 2,x
.a1e2	94 00		sty $00,x	                sty 0,x
.a1e4	b5 01		lda $01,x	                lda 1,x         ; MSB
.a1e6	b4 03		ldy $03,x	                ldy 3,x
.a1e8	95 03		sta $03,x	                sta 3,x
.a1ea	94 01		sty $01,x	                sty 1,x
.a1ec	60		rts		z_swap:         rts
.a1ed					xt_then:
.a1ed	20 9d 91	jsr $919d	                jsr xt_here
.a1f0	20 d9 a1	jsr $a1d9	                jsr xt_swap
.a1f3	20 b8 a1	jsr $a1b8	                jsr xt_store
.a1f6	60		rts		z_then:         rts
.a1f7					xt_thru:
.a1f7	20 5f d8	jsr $d85f	                jsr underflow_2
.a1fa	b5 01		lda $01,x	                lda 1,x
.a1fc	48		pha		                pha
.a1fd	b5 00		lda $00,x	                lda 0,x
.a1ff	48		pha		                pha
.a200	e8		inx		                inx
.a201	e8		inx		                inx
.a202					_thru_loop:
.a202	b5 01		lda $01,x	                lda 1,x
.a204	48		pha		                pha
.a205	b5 00		lda $00,x	                lda 0,x
.a207	48		pha		                pha
.a208	20 e2 93	jsr $93e2	                jsr xt_load
.a20b	68		pla		                pla
.a20c	85 24		sta $24		                sta tmp1
.a20e	68		pla		                pla
.a20f	85 25		sta $25		                sta tmp1+1
.a211	68		pla		                pla
.a212	85 26		sta $26		                sta tmp2
.a214	68		pla		                pla
.a215	85 27		sta $27		                sta tmp2+1
.a217	c5 25		cmp $25		                cmp tmp1+1
.a219	d0 08		bne $a223	                bne _next_screen
.a21b	a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a21d	c5 24		cmp $24		                cmp tmp1
.a21f	d0 02		bne $a223	                bne _next_screen
.a221	80 18		bra $a23b	                bra _done       ; We just did the last screen.
.a223					_next_screen:
.a223	a5 27		lda $27		                lda tmp2+1
.a225	48		pha		                pha
.a226	a5 26		lda $26		                lda tmp2
.a228	48		pha		                pha
.a229	e6 24		inc $24		                inc tmp1
.a22b	d0 02		bne $a22f	                bne +
.a22d	e6 25		inc $25		                inc tmp1+1
.a22f					+
.a22f	ca		dex		                dex
.a230	ca		dex		                dex
.a231	a5 24		lda $24		                lda tmp1
.a233	95 00		sta $00,x	                sta 0,x
.a235	a5 25		lda $25		                lda tmp1+1
.a237	95 01		sta $01,x	                sta 1,x
.a239	80 c7		bra $a202	                bra _thru_loop
.a23b					_done:
.a23b	60		rts		z_thru:         rts
.a23c					xt_tick:
.a23c	20 0a 99	jsr $990a	                jsr xt_parse_name       ; ( -- addr u )
.a23f	b5 00		lda $00,x	                lda 0,x
.a241	15 01		ora $01,x	                ora 1,x
.a243	d0 05		bne $a24a	                bne +
.a245	a9 05		lda #$05	                lda #err_noname
.a247	4c 70 d8	jmp $d870	                jmp error
.a24a					+
.a24a	20 06 90	jsr $9006	                jsr xt_find_name        ; ( addr u -- nt )
.a24d	b5 00		lda $00,x	                lda 0,x
.a24f	15 01		ora $01,x	                ora 1,x
.a251	d0 05		bne $a258	                bne +
.a253	a9 08		lda #$08	                lda #err_syntax
.a255	4c 70 d8	jmp $d870	                jmp error
.a258					+
.a258	20 0c 96	jsr $960c	                jsr xt_name_to_int      ; ( nt -- xt )
.a25b	60		rts		z_tick:         rts
.a25c					xt_to:
.a25c	20 3c a2	jsr $a23c	                jsr xt_tick             ; ( [n] xt )
.a25f	b5 00		lda $00,x	                lda 0,x                 ; LSB
.a261	18		clc		                clc
.a262	69 03		adc #$03	                adc #3
.a264	85 24		sta $24		                sta tmp1
.a266	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a268	69 00		adc #$00	                adc #0                  ; we just want the carry
.a26a	85 25		sta $25		                sta tmp1+1
.a26c	e8		inx		                inx
.a26d	e8		inx		                inx                     ; ( [n] )
.a26e	a5 16		lda $16		                lda state
.a270	05 17		ora $17		                ora state+1
.a272	f0 34		beq $a2a8	                beq _interpret
.a274	a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a276	a9 b5		lda #$b5	                lda #$B5
.a278	20 09 d7	jsr $d709	                jsr cmpl_word
.a27b	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a27d	20 0d d7	jsr $d70d	                jsr cmpl_a
.a280	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a282	a5 24		lda $24		                lda tmp1
.a284	20 09 d7	jsr $d709	                jsr cmpl_word
.a287	a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a289	a9 b5		lda #$b5	                lda #$B5
.a28b	20 09 d7	jsr $d709	                jsr cmpl_word
.a28e	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a290	20 0d d7	jsr $d70d	                jsr cmpl_a
.a293	e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a295	d0 02		bne $a299	                bne +
.a297	e6 25		inc $25		                inc tmp1+1
.a299					+
.a299	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a29b	a5 24		lda $24		                lda tmp1
.a29d	20 09 d7	jsr $d709	                jsr cmpl_word
.a2a0	a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a2a2	98		tya		                tya
.a2a3	20 09 d7	jsr $d709	                jsr cmpl_word
.a2a6	80 0f		bra $a2b7	                bra _done
.a2a8					_interpret:
.a2a8	20 5a d8	jsr $d85a	                jsr underflow_1
.a2ab	b5 00		lda $00,x	                lda 0,x
.a2ad	92 24		sta ($24)	                sta (tmp1)              ; LSB
.a2af	a0 01		ldy #$01	                ldy #1
.a2b1	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a2b3	91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a2b5	e8		inx		                inx                     ; DROP
.a2b6	e8		inx		                inx
.a2b7					_done:
.a2b7	60		rts		z_to:           rts
.a2b8					xt_to_body:
.a2b8	20 5a d8	jsr $d85a	                jsr underflow_1
.a2bb	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( xt xt )
.a2be	20 a3 92	jsr $92a3	                jsr xt_int_to_name      ; ( xt nt )
.a2c1	f6 00		inc $00,x	                inc 0,x
.a2c3	d0 02		bne $a2c7	                bne +
.a2c5	f6 01		inc $01,x	                inc 1,x
.a2c7					+
.a2c7	a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a2c9	29 20		and #$20	                and #HC
.a2cb	f0 0d		beq $a2da	                beq _no_cfa
.a2cd	18		clc		                clc
.a2ce	b5 02		lda $02,x	                lda 2,x         ; LSB
.a2d0	69 03		adc #$03	                adc #3
.a2d2	95 02		sta $02,x	                sta 2,x
.a2d4	b5 03		lda $03,x	                lda 3,x         ; MSB
.a2d6	69 00		adc #$00	                adc #0          ; we conly care about the carry
.a2d8	95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a2da					_no_cfa:
.a2da	e8		inx		                inx             ; get rid of the nt
.a2db	e8		inx		                inx
.a2dc					_done:
.a2dc	60		rts		z_to_body:      rts
.a2dd					xt_to_in:
.a2dd	ca		dex		                dex
.a2de	ca		dex		                dex
.a2df	a9 0c		lda #$0c	                lda #<toin
.a2e1	95 00		sta $00,x	                sta 0,x
.a2e3	a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a2e5	95 01		sta $01,x	                sta 1,x
.a2e7	60		rts		z_to_in:        rts
.a2e8					xt_to_number:
.a2e8	20 69 d8	jsr $d869	                jsr underflow_4
.a2eb	b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a2ed	85 36		sta $36		                sta scratch
.a2ef	b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a2f1	85 37		sta $37		                sta scratch+1
.a2f3	b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a2f5	85 38		sta $38		                sta scratch+2
.a2f7	b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a2f9	85 39		sta $39		                sta scratch+3
.a2fb	ca		dex		                dex
.a2fc	ca		dex		                dex
.a2fd					_loop:
.a2fd	a1 04		lda ($04,x)	                lda (4,x)
.a2ff	95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a301	74 01		stz $01,x	                stz 1,x                 ; paranoid
.a303	20 30 8b	jsr $8b30	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a306	b5 00		lda $00,x	                lda 0,x
.a308	d0 04		bne $a30e	                bne _digit_ok
.a30a	e8		inx		                inx
.a30b	e8		inx		                inx
.a30c	80 67		bra $a375	                bra _done       ; ( ud-lo ud-hi addr u char )
.a30e					_digit_ok:
.a30e	b5 02		lda $02,x	                lda 2,x
.a310	85 3a		sta $3a		                sta scratch+4
.a312	b5 03		lda $03,x	                lda 3,x
.a314	85 3b		sta $3b		                sta scratch+5
.a316	a5 38		lda $38		                lda scratch+2
.a318	95 02		sta $02,x	                sta 2,x         ; NOS
.a31a	a5 39		lda $39		                lda scratch+3
.a31c	95 03		sta $03,x	                sta 3,x
.a31e	a5 18		lda $18		                lda base
.a320	95 00		sta $00,x	                sta 0,x         ; TOS
.a322	74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a324	20 27 a6	jsr $a627	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a327	b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a329	85 3c		sta $3c		                sta scratch+6
.a32b	b5 03		lda $03,x	                lda 3,x
.a32d	85 3d		sta $3d		                sta scratch+7
.a32f	a5 36		lda $36		                lda scratch
.a331	95 02		sta $02,x	                sta 2,x
.a333	a5 37		lda $37		                lda scratch+1
.a335	95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a337	a5 18		lda $18		                lda base
.a339	95 00		sta $00,x	                sta 0,x
.a33b	74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a33d	20 27 a6	jsr $a627	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a340	b5 00		lda $00,x	                lda 0,x
.a342	85 38		sta $38		                sta scratch+2
.a344	b5 01		lda $01,x	                lda 1,x
.a346	85 39		sta $39		                sta scratch+3
.a348	b5 02		lda $02,x	                lda 2,x
.a34a	85 36		sta $36		                sta scratch
.a34c	b5 03		lda $03,x	                lda 3,x
.a34e	85 37		sta $37		                sta scratch+1
.a350	18		clc		                clc
.a351	a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a353	65 3a		adc $3a		                adc scratch+4   ; n LSB
.a355	85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a357	a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a359	65 3b		adc $3b		                adc scratch+5   ; n MSB
.a35b	85 37		sta $37		                sta scratch+1
.a35d	a5 38		lda $38		                lda scratch+2   ; LSB
.a35f	65 3c		adc $3c		                adc scratch+6
.a361	85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a363	a5 39		lda $39		                lda scratch+3   ; MSB
.a365	65 3d		adc $3d		                adc scratch+7
.a367	85 39		sta $39		                sta scratch+3
.a369	e8		inx		                inx
.a36a	e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a36b	f6 04		inc $04,x	                inc 4,x
.a36d	d0 02		bne $a371	                bne +
.a36f	f6 05		inc $05,x	                inc 5,x
.a371					+
.a371	d6 02		dec $02,x	                dec 2,x
.a373	d0 88		bne $a2fd	                bne _loop
.a375					_done:
.a375	e8		inx		                inx
.a376	e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a377	a5 36		lda $36		                lda scratch     ; new ud-lo
.a379	95 06		sta $06,x	                sta 6,x
.a37b	a5 37		lda $37		                lda scratch+1
.a37d	95 07		sta $07,x	                sta 7,x
.a37f	a5 38		lda $38		                lda scratch+2
.a381	95 04		sta $04,x	                sta 4,x
.a383	a5 39		lda $39		                lda scratch+3
.a385	95 05		sta $05,x	                sta 5,x
.a387	60		rts		z_to_number:    rts
.a388					xt_to_order:
.a388	20 9b a3	jsr $a39b	                jsr xt_to_r
.a38b	20 5f 91	jsr $915f	                jsr xt_get_order
.a38e	20 bd 9a	jsr $9abd	                jsr xt_r_from
.a391	20 d9 a1	jsr $a1d9	                jsr xt_swap
.a394	20 48 98	jsr $9848	                jsr xt_one_plus
.a397	20 46 9d	jsr $9d46	                jsr xt_set_order
.a39a	60		rts		z_to_order:     rts
.a39b					xt_to_r:
.a39b	68		pla		                pla             ; LSB
.a39c	85 2c		sta $2c		                sta tmptos
.a39e	7a		ply		                ply             ; MSB
.a39f	20 5a d8	jsr $d85a	                jsr underflow_1
.a3a2	b5 01		lda $01,x	                lda 1,x         ; MSB
.a3a4	48		pha		                pha
.a3a5	b5 00		lda $00,x	                lda 0,x         ; LSB
.a3a7	48		pha		                pha
.a3a8	e8		inx		                inx
.a3a9	e8		inx		                inx
.a3aa	5a		phy		                phy             ; MSB
.a3ab	a5 2c		lda $2c		                lda tmptos
.a3ad	48		pha		                pha             ; LSB
.a3ae	60		rts		z_to_r:         rts
.a3af					xt_true:
.a3af	ca		dex		                dex
.a3b0	ca		dex		                dex
.a3b1	a9 ff		lda #$ff	                lda #$FF
.a3b3	95 00		sta $00,x	                sta 0,x
.a3b5	95 01		sta $01,x	                sta 1,x
.a3b7	60		rts		z_true:         rts
.a3b8					xt_tuck:
.a3b8	20 5f d8	jsr $d85f	                jsr underflow_2
.a3bb	ca		dex		                dex
.a3bc	ca		dex		                dex
.a3bd	b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a3bf	b5 02		lda $02,x	                lda 2,x
.a3c1	95 04		sta $04,x	                sta 4,x
.a3c3	94 02		sty $02,x	                sty 2,x
.a3c5	95 00		sta $00,x	                sta 0,x
.a3c7	b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a3c9	b5 03		lda $03,x	                lda 3,x
.a3cb	95 05		sta $05,x	                sta 5,x
.a3cd	94 03		sty $03,x	                sty 3,x         ; bba
.a3cf	95 01		sta $01,x	                sta 1,x         ; baa
.a3d1	60		rts		z_tuck:         rts
.a3d2					xt_assembler_wordlist:
.a3d2					xt_two:
.a3d2	ca		dex		                dex
.a3d3	ca		dex		                dex
.a3d4	a9 02		lda #$02	                lda #2
.a3d6	95 00		sta $00,x	                sta 0,x
.a3d8	74 01		stz $01,x	                stz 1,x
.a3da					z_assembler_wordlist:
.a3da	60		rts		z_two:          rts
.a3db					xt_two_drop:
.a3db	20 5f d8	jsr $d85f	                jsr underflow_2
.a3de	e8		inx		                inx
.a3df	e8		inx		                inx
.a3e0	e8		inx		                inx
.a3e1	e8		inx		                inx
.a3e2	60		rts		z_two_drop:     rts
.a3e3					xt_two_dup:
.a3e3	20 5f d8	jsr $d85f	                jsr underflow_2
.a3e6	ca		dex		                dex
.a3e7	ca		dex		                dex
.a3e8	ca		dex		                dex
.a3e9	ca		dex		                dex
.a3ea	b5 04		lda $04,x	                lda 4,x         ; TOS
.a3ec	95 00		sta $00,x	                sta 0,x
.a3ee	b5 05		lda $05,x	                lda 5,x
.a3f0	95 01		sta $01,x	                sta 1,x
.a3f2	b5 06		lda $06,x	                lda 6,x         ; NOS
.a3f4	95 02		sta $02,x	                sta 2,x
.a3f6	b5 07		lda $07,x	                lda 7,x
.a3f8	95 03		sta $03,x	                sta 3,x
.a3fa	60		rts		z_two_dup:      rts
.a3fb					xt_two_fetch:
.a3fb	20 5a d8	jsr $d85a	                jsr underflow_1
.a3fe	b5 00		lda $00,x	                lda 0,x
.a400	85 24		sta $24		                sta tmp1
.a402	b4 01		ldy $01,x	                ldy 1,x
.a404	84 25		sty $25		                sty tmp1+1
.a406	ca		dex		                dex             ; reuse one stack element
.a407	ca		dex		                dex
.a408	b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a40a	95 00		sta $00,x	                sta 0,x
.a40c	a0 01		ldy #$01	                ldy #1          ; copy next
.a40e	b1 24		lda ($24),y	                lda (tmp1),y
.a410	95 01		sta $01,x	                sta 1,x
.a412	c8		iny		                iny             ; copy next
.a413	b1 24		lda ($24),y	                lda (tmp1),y
.a415	95 02		sta $02,x	                sta 2,x
.a417	c8		iny		                iny             ; copy next
.a418	b1 24		lda ($24),y	                lda (tmp1),y
.a41a	95 03		sta $03,x	                sta 3,x
.a41c	60		rts		z_two_fetch:    rts
.a41d					xt_two_over:
.a41d	20 69 d8	jsr $d869	                jsr underflow_4
.a420	ca		dex		                dex
.a421	ca		dex		                dex
.a422	ca		dex		                dex
.a423	ca		dex		                dex
.a424	b5 08		lda $08,x	                lda 8,x
.a426	95 00		sta $00,x	                sta 0,x
.a428	b5 09		lda $09,x	                lda 9,x
.a42a	95 01		sta $01,x	                sta 1,x
.a42c	b5 0a		lda $0a,x	                lda 10,x
.a42e	95 02		sta $02,x	                sta 2,x
.a430	b5 0b		lda $0b,x	                lda 11,x
.a432	95 03		sta $03,x	                sta 3,x
.a434	60		rts		z_two_over:     rts
.a435					xt_two_r_fetch:
.a435	ca		dex		                dex
.a436	ca		dex		                dex
.a437	ca		dex		                dex
.a438	ca		dex		                dex
.a439	8a		txa		                txa
.a43a	ba		tsx		                tsx
.a43b	da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a43c	7a		ply		                ply
.a43d	aa		tax		                tax
.a43e	b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a441	95 00		sta $00,x	                sta 0,x
.a443	b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a446	95 01		sta $01,x	                sta 1,x
.a448	b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a44b	95 02		sta $02,x	                sta 2,x
.a44d	b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a450	95 03		sta $03,x	                sta 3,x
.a452	60		rts		z_two_r_fetch:  rts
.a453					xt_two_r_from:
.a453	68		pla		                pla                     ; LSB
.a454	85 24		sta $24		                sta tmp1
.a456	68		pla		                pla                     ; MSB
.a457	85 25		sta $25		                sta tmp1+1
.a459	ca		dex		                dex
.a45a	ca		dex		                dex
.a45b	ca		dex		                dex
.a45c	ca		dex		                dex
.a45d	68		pla		                pla                     ; LSB
.a45e	95 00		sta $00,x	                sta 0,x
.a460	68		pla		                pla                     ; MSB
.a461	95 01		sta $01,x	                sta 1,x
.a463	68		pla		                pla                     ; LSB
.a464	95 02		sta $02,x	                sta 2,x
.a466	68		pla		                pla                     ; MSB
.a467	95 03		sta $03,x	                sta 3,x
.a469	a5 25		lda $25		                lda tmp1+1              ; MSB
.a46b	48		pha		                pha
.a46c	a5 24		lda $24		                lda tmp1                ; LSB
.a46e	48		pha		                pha
.a46f	60		rts		z_two_r_from:   rts
.a470					xt_two_slash:
.a470	20 5a d8	jsr $d85a	                jsr underflow_1
.a473	b5 01		lda $01,x	                lda 1,x
.a475	0a		asl a		                asl                     ; save the sign
.a476	76 01		ror $01,x	                ror 1,x
.a478	76 00		ror $00,x	                ror 0,x
.a47a	60		rts		z_two_slash:    rts
.a47b					xt_two_star:
.a47b					xt_cells:
.a47b	20 5a d8	jsr $d85a	                jsr underflow_1
.a47e	16 00		asl $00,x	                asl 0,x
.a480	36 01		rol $01,x	                rol 1,x
.a482					z_cells:
.a482	60		rts		z_two_star:     rts
.a483					xt_two_store:
.a483	20 64 d8	jsr $d864	                jsr underflow_3
.a486	b5 00		lda $00,x	                lda 0,x
.a488	85 24		sta $24		                sta tmp1
.a48a	b4 01		ldy $01,x	                ldy 1,x
.a48c	84 25		sty $25		                sty tmp1+1
.a48e	e8		inx		                inx
.a48f	e8		inx		                inx
.a490	b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a492	92 24		sta ($24)	                sta (tmp1)
.a494	b5 01		lda $01,x	                lda 1,x         ; copy next
.a496	a0 01		ldy #$01	                ldy #1
.a498	91 24		sta ($24),y	                sta (tmp1),y
.a49a	b5 02		lda $02,x	                lda 2,x         ; copy next
.a49c	c8		iny		                iny
.a49d	91 24		sta ($24),y	                sta (tmp1),y
.a49f	b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a4a1	c8		iny		                iny
.a4a2	91 24		sta ($24),y	                sta (tmp1),y
.a4a4	e8		inx		                inx             ; 2DROP
.a4a5	e8		inx		                inx
.a4a6	e8		inx		                inx
.a4a7	e8		inx		                inx
.a4a8	60		rts		z_two_store:    rts
.a4a9					xt_two_swap:
.a4a9	20 69 d8	jsr $d869	                jsr underflow_4
.a4ac	b5 00		lda $00,x	                lda 0,x
.a4ae	b4 04		ldy $04,x	                ldy 4,x
.a4b0	95 04		sta $04,x	                sta 4,x
.a4b2	94 00		sty $00,x	                sty 0,x
.a4b4	b5 01		lda $01,x	                lda 1,x
.a4b6	b4 05		ldy $05,x	                ldy 5,x
.a4b8	95 05		sta $05,x	                sta 5,x
.a4ba	94 01		sty $01,x	                sty 1,x
.a4bc	b5 02		lda $02,x	                lda 2,x
.a4be	b4 06		ldy $06,x	                ldy 6,x
.a4c0	95 06		sta $06,x	                sta 6,x
.a4c2	94 02		sty $02,x	                sty 2,x
.a4c4	b5 03		lda $03,x	                lda 3,x
.a4c6	b4 07		ldy $07,x	                ldy 7,x
.a4c8	95 07		sta $07,x	                sta 7,x
.a4ca	94 03		sty $03,x	                sty 3,x
.a4cc	60		rts		z_two_swap:     rts
.a4cd					xt_two_to_r:
.a4cd	68		pla		                pla             ; LSB
.a4ce	85 24		sta $24		                sta tmp1
.a4d0	68		pla		                pla             ; MSB
.a4d1	85 25		sta $25		                sta tmp1+1
.a4d3	20 5f d8	jsr $d85f	                jsr underflow_2
.a4d6	b5 03		lda $03,x	                lda 3,x         ; MSB
.a4d8	48		pha		                pha
.a4d9	b5 02		lda $02,x	                lda 2,x         ; LSB
.a4db	48		pha		                pha
.a4dc	b5 01		lda $01,x	                lda 1,x         ; MSB
.a4de	48		pha		                pha
.a4df	b5 00		lda $00,x	                lda 0,x         ; LSB
.a4e1	48		pha		                pha
.a4e2	e8		inx		                inx
.a4e3	e8		inx		                inx
.a4e4	e8		inx		                inx
.a4e5	e8		inx		                inx
.a4e6	a5 25		lda $25		                lda tmp1+1      ; MSB
.a4e8	48		pha		                pha
.a4e9	a5 24		lda $24		                lda tmp1        ; LSB
.a4eb	48		pha		                pha
.a4ec	60		rts		z_two_to_r:     rts
.a4ed					xt_two_constant:
.a4ed	20 5f d8	jsr $d85f	                jsr underflow_2
.a4f0	20 94 89	jsr $8994	                jsr xt_create
.a4f3	20 d9 a1	jsr $a1d9	                jsr xt_swap
.a4f6	20 99 87	jsr $8799	                jsr xt_comma
.a4f9	20 99 87	jsr $8799	                jsr xt_comma
.a4fc	20 2f 8c	jsr $8c2f	                jsr does_runtime    ; does> turns into these two routines.
.a4ff	20 43 d7	jsr $d743	                jsr dodoes
.a502	20 da 8d	jsr $8dda	                jsr xt_dup
.a505	20 ab 8f	jsr $8fab	                jsr xt_fetch
.a508	20 d9 a1	jsr $a1d9	                jsr xt_swap
.a50b	20 4c 86	jsr $864c	                jsr xt_cell_plus
.a50e	20 ab 8f	jsr $8fab	                jsr xt_fetch
.a511	60		rts		z_two_constant: rts
.a512					xt_two_literal:
.a512	20 5f d8	jsr $d85f	                jsr underflow_2 ; double number
.a515	20 d9 a1	jsr $a1d9	                jsr xt_swap
.a518	20 b5 93	jsr $93b5	                jsr xt_literal
.a51b	20 b5 93	jsr $93b5	                jsr xt_literal
.a51e	60		rts		z_two_literal:  rts
.a51f					xt_two_variable:
.a51f	20 94 89	jsr $8994	                jsr xt_create
.a522	ca		dex		                dex
.a523	ca		dex		                dex
.a524	a9 04		lda #$04	                lda #4
.a526	95 00		sta $00,x	                sta 0,x
.a528	74 01		stz $01,x	                stz 1,x
.a52a	20 b4 82	jsr $82b4	                jsr xt_allot
.a52d	60		rts		z_two_variable: rts
.a52e					xt_type:
.a52e	20 5f d8	jsr $d85f	                jsr underflow_2
.a531	b5 02		lda $02,x	                lda 2,x
.a533	85 24		sta $24		                sta tmp1
.a535	b5 03		lda $03,x	                lda 3,x
.a537	85 25		sta $25		                sta tmp1+1
.a539					_loop:
.a539	b5 00		lda $00,x	                lda 0,x
.a53b	15 01		ora $01,x	                ora 1,x
.a53d	f0 15		beq $a554	                beq _done
.a53f	b2 24		lda ($24)	                lda (tmp1)
.a541	20 21 8e	jsr $8e21	                jsr emit_a      ; avoids stack foolery
.a544	e6 24		inc $24		                inc tmp1
.a546	d0 02		bne $a54a	                bne +
.a548	e6 25		inc $25		                inc tmp1+1
.a54a					+
.a54a	b5 00		lda $00,x	                lda 0,x
.a54c	d0 02		bne $a550	                bne +
.a54e	d6 01		dec $01,x	                dec 1,x
.a550					+
.a550	d6 00		dec $00,x	                dec 0,x
.a552	80 e5		bra $a539	                bra _loop
.a554					_done:
.a554	e8		inx		                inx
.a555	e8		inx		                inx
.a556	e8		inx		                inx
.a557	e8		inx		                inx
.a558	60		rts		z_type:         rts
.a559					xt_u_dot:
.a559	20 5a d8	jsr $d85a	                jsr underflow_1
.a55c	20 a6 d8	jsr $d8a6	                jsr print_u
.a55f	a9 20		lda #$20	                lda #AscSP
.a561	20 21 8e	jsr $8e21	                jsr emit_a
.a564	60		rts		z_u_dot:        rts
.a565					xt_u_dot_r:
.a565	20 5f d8	jsr $d85f	                jsr underflow_2
.a568	20 9b a3	jsr $a39b	                jsr xt_to_r
.a56b	20 d3 a7	jsr $a7d3	                jsr xt_zero
.a56e	20 85 93	jsr $9385	                jsr xt_less_number_sign
.a571	20 09 98	jsr $9809	                jsr xt_number_sign_s
.a574	20 e7 97	jsr $97e7	                jsr xt_number_sign_greater
.a577	20 bd 9a	jsr $9abd	                jsr xt_r_from
.a57a	20 be 98	jsr $98be	                jsr xt_over
.a57d	20 7b 95	jsr $957b	                jsr xt_minus
.a580	20 4f a1	jsr $a14f	                jsr xt_spaces
.a583	20 2e a5	jsr $a52e	                jsr xt_type
.a586	60		rts		z_u_dot_r:      rts
.a587					xt_u_greater_than:
.a587	20 5f d8	jsr $d85f	                jsr underflow_2
.a58a	b5 00		lda $00,x	                lda 0,x
.a58c	d5 02		cmp $02,x	                cmp 2,x
.a58e	b5 01		lda $01,x	                lda 1,x
.a590	f5 03		sbc $03,x	                sbc 3,x
.a592	e8		inx		                inx
.a593	e8		inx		                inx
.a594	a9 00		lda #$00	                lda #0
.a596	69 ff		adc #$ff	                adc #$ff
.a598	95 00		sta $00,x	                sta 0,x         ; store flag
.a59a	95 01		sta $01,x	                sta 1,x
.a59c	60		rts		z_u_greater_than:    rts
.a59d					xt_u_less_than:
.a59d	20 5f d8	jsr $d85f	                jsr underflow_2
.a5a0	b5 02		lda $02,x	                lda 2,x
.a5a2	d5 00		cmp $00,x	                cmp 0,x
.a5a4	b5 03		lda $03,x	                lda 3,x
.a5a6	f5 01		sbc $01,x	                sbc 1,x
.a5a8	e8		inx		                inx
.a5a9	e8		inx		                inx
.a5aa	a9 00		lda #$00	                lda #0
.a5ac	69 ff		adc #$ff	                adc #$ff
.a5ae	95 00		sta $00,x	                sta 0,x         ; store flag
.a5b0	95 01		sta $01,x	                sta 1,x
.a5b2	60		rts		z_u_less_than:    rts
.a5b3					xt_ud_dot:
.a5b3	20 5f d8	jsr $d85f	                jsr underflow_2 ; double number
.a5b6	20 85 93	jsr $9385	                jsr xt_less_number_sign
.a5b9	20 09 98	jsr $9809	                jsr xt_number_sign_s
.a5bc	20 e7 97	jsr $97e7	                jsr xt_number_sign_greater
.a5bf	20 2e a5	jsr $a52e	                jsr xt_type
.a5c2	20 49 a1	jsr $a149	                jsr xt_space
.a5c5	60		rts		z_ud_dot:        rts
.a5c6					xt_ud_dot_r:
.a5c6	20 64 d8	jsr $d864	                jsr underflow_3
.a5c9	20 9b a3	jsr $a39b	                jsr xt_to_r
.a5cc	20 85 93	jsr $9385	                jsr xt_less_number_sign
.a5cf	20 09 98	jsr $9809	                jsr xt_number_sign_s
.a5d2	20 e7 97	jsr $97e7	                jsr xt_number_sign_greater
.a5d5	20 bd 9a	jsr $9abd	                jsr xt_r_from
.a5d8	20 be 98	jsr $98be	                jsr xt_over
.a5db	20 7b 95	jsr $957b	                jsr xt_minus
.a5de	20 4f a1	jsr $a14f	                jsr xt_spaces
.a5e1	20 2e a5	jsr $a52e	                jsr xt_type
.a5e4	60		rts		z_ud_dot_r:      rts
.a5e5					xt_um_slash_mod:
.a5e5	20 64 d8	jsr $d864	                jsr underflow_3
.a5e8	b5 00		lda $00,x	                lda 0,x
.a5ea	15 01		ora $01,x	                ora 1,x
.a5ec	d0 05		bne $a5f3	                bne _not_zero
.a5ee	a9 04		lda #$04	                lda #err_divzero
.a5f0	4c 70 d8	jmp $d870	                jmp error
.a5f3					_not_zero:
.a5f3	a9 11		lda #$11	                lda #17
.a5f5	85 2c		sta $2c		                sta tmptos
.a5f7					_loop:
.a5f7	36 04		rol $04,x	                rol 4,x
.a5f9	36 05		rol $05,x	                rol 5,x
.a5fb	c6 2c		dec $2c		                dec tmptos
.a5fd	f0 22		beq $a621	                beq _done
.a5ff	36 02		rol $02,x	                rol 2,x
.a601	36 03		rol $03,x	                rol 3,x
.a603	64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a605	26 24		rol $24		                rol tmp1
.a607	38		sec		                sec
.a608	b5 02		lda $02,x	                lda 2,x
.a60a	f5 00		sbc $00,x	                sbc 0,x
.a60c	85 25		sta $25		                sta tmp1+1
.a60e	b5 03		lda $03,x	                lda 3,x
.a610	f5 01		sbc $01,x	                sbc 1,x
.a612	a8		tay		                tay
.a613	a5 24		lda $24		                lda tmp1
.a615	e9 00		sbc #$00	                sbc #0
.a617	90 de		bcc $a5f7	                bcc _loop
.a619	a5 25		lda $25		                lda tmp1+1
.a61b	95 02		sta $02,x	                sta 2,x
.a61d	94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a61f	80 d6		bra $a5f7	                bra _loop
.a621					_done:
.a621	e8		inx		                inx
.a622	e8		inx		                inx
.a623	20 d9 a1	jsr $a1d9	                jsr xt_swap
.a626	60		rts		z_um_slash_mod: rts
.a627					xt_um_star:
.a627	20 5f d8	jsr $d85f	                jsr underflow_2
.a62a	18		clc		                clc
.a62b	b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a62d	e9 00		sbc #$00	                sbc #0
.a62f	85 26		sta $26		                sta tmp2
.a631	b5 01		lda $01,x	                lda 1,x
.a633	e9 00		sbc #$00	                sbc #0
.a635	90 31		bcc $a668	                bcc _zero       ; is TOS zero?
.a637	85 27		sta $27		                sta tmp2+1
.a639	a9 00		lda #$00	                lda #0
.a63b	85 24		sta $24		                sta tmp1
.a63d	86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a63f	ca		dex		                dex
.a640	ca		dex		                dex
.a641					_outer_loop:
.a641	a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a643	56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a645					_inner_loop:
.a645	90 0c		bcc $a653	                bcc _no_add
.a647	85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a649	a5 24		lda $24		                lda tmp1
.a64b	65 26		adc $26		                adc tmp2
.a64d	85 24		sta $24		                sta tmp1
.a64f	a5 25		lda $25		                lda tmp1+1
.a651	65 27		adc $27		                adc tmp2+1
.a653					_no_add:
.a653	6a		ror a		                ror
.a654	66 24		ror $24		                ror tmp1
.a656	76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a658	88		dey		                dey
.a659	d0 ea		bne $a645	                bne _inner_loop ; go back for one more shift?
.a65b	e8		inx		                inx
.a65c	e4 28		cpx $28		                cpx tmp3
.a65e	d0 e1		bne $a641	                bne _outer_loop ; go back for eight more shifts?
.a660	95 01		sta $01,x	                sta 1,x
.a662	a5 24		lda $24		                lda tmp1
.a664	95 00		sta $00,x	                sta 0,x
.a666	80 04		bra $a66c	                bra _done
.a668					_zero:
.a668	74 02		stz $02,x	                stz 2,x
.a66a	74 03		stz $03,x	                stz 3,x
.a66c					_done:
.a66c	60		rts		z_um_star:      rts
.a66d					xt_unloop:
.a66d	68		pla		                pla
.a66e	68		pla		                pla
.a66f	68		pla		                pla
.a670	68		pla		                pla
.a671	68		pla		                pla
.a672	68		pla		                pla
.a673	60		rts		z_unloop:       rts
.a674					xt_until:
.a674	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a676	a9 3f		lda #$3f	                lda #<zero_branch_runtime
.a678	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.a67b	20 99 87	jsr $8799	                jsr xt_comma
.a67e	60		rts		z_until:        rts
.a67f					xt_unused:
.a67f	ca		dex		                dex
.a680	ca		dex		                dex
.a681	a9 00		lda #$00	                lda #<cp_end
.a683	38		sec		                sec
.a684	e5 00		sbc $00		                sbc cp
.a686	95 00		sta $00,x	                sta 0,x
.a688	a9 7c		lda #$7c	                lda #>cp_end
.a68a	e5 01		sbc $01		                sbc cp+1
.a68c	95 01		sta $01,x	                sta 1,x
.a68e	60		rts		z_unused:       rts
.a68f					xt_update:
.a68f	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a691	b1 1e		lda ($1e),y	                lda (up),y
.a693	09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a695	91 1e		sta ($1e),y	                sta (up),y
.a697	60		rts		z_update:       rts
.a698					xt_useraddr:
.a698	ca		dex		                dex
.a699	ca		dex		                dex
.a69a	a9 1e		lda #$1e	                lda #<up
.a69c	95 00		sta $00,x	                sta 0,x
.a69e	a9 00		lda #$00	                lda #>up
.a6a0	95 01		sta $01,x	                sta 1,x
.a6a2	60		rts		z_useraddr:     rts
.a6a3					xt_variable:
.a6a3	20 94 89	jsr $8994	                jsr xt_create
.a6a6	a9 00		lda #$00	                lda #0
.a6a8	92 00		sta ($00)	                sta (cp)
.a6aa	e6 00		inc $00		                inc cp
.a6ac	d0 02		bne $a6b0	                bne +
.a6ae	e6 01		inc $01		                inc cp+1
.a6b0					+
.a6b0	92 00		sta ($00)	                sta (cp)
.a6b2	e6 00		inc $00		                inc cp
.a6b4	d0 02		bne $a6b8	                bne +
.a6b6	e6 01		inc $01		                inc cp+1
.a6b8					+
.a6b8	20 5c 89	jsr $895c	                jsr adjust_z
.a6bb	60		rts		z_variable:     rts
.a6bc					xt_while:
.a6bc	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a6be	a9 3f		lda #$3f	                lda #<zero_branch_runtime
.a6c0	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.a6c3	20 9d 91	jsr $919d	                jsr xt_here
.a6c6	20 d3 a7	jsr $a7d3	                jsr xt_zero
.a6c9	20 99 87	jsr $8799	                jsr xt_comma
.a6cc	20 d9 a1	jsr $a1d9	                jsr xt_swap
.a6cf	60		rts		z_while:        rts
.a6d0					xt_within:
.a6d0	20 64 d8	jsr $d864	                jsr underflow_3
.a6d3	20 be 98	jsr $98be	                jsr xt_over
.a6d6	20 7b 95	jsr $957b	                jsr xt_minus
.a6d9	20 9b a3	jsr $a39b	                jsr xt_to_r
.a6dc	20 7b 95	jsr $957b	                jsr xt_minus
.a6df	20 bd 9a	jsr $9abd	                jsr xt_r_from
.a6e2	20 9d a5	jsr $a59d	                jsr xt_u_less_than
.a6e5	60		rts		z_within:       rts
.a6e6					xt_word:
.a6e6	20 5a d8	jsr $d85a	                jsr underflow_1
.a6e9	a4 0c		ldy $0c		                ldy toin                ; >IN
.a6eb					_loop:
.a6eb	c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a6ed	f0 09		beq $a6f8	                beq _found_char
.a6ef	b1 08		lda ($08),y	                lda (cib),y
.a6f1	d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a6f3	d0 03		bne $a6f8	                bne _found_char
.a6f5	c8		iny		                iny
.a6f6	80 f3		bra $a6eb	                bra _loop
.a6f8					_found_char:
.a6f8	84 0c		sty $0c		                sty toin
.a6fa	20 65 99	jsr $9965	                jsr xt_parse            ; Returns ( addr u )
.a6fd	b5 00		lda $00,x	                lda 0,x
.a6ff	92 00		sta ($00)	                sta (cp)                ; Save length of string
.a701	48		pha		                pha                     ; Keep copy of length for later
.a702	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( addr u u )
.a705	a5 00		lda $00		                lda cp
.a707	18		clc		                clc
.a708	69 01		adc #$01	                adc #1
.a70a	95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a70c	a5 01		lda $01		                lda cp+1
.a70e	69 00		adc #$00	                adc #0
.a710	95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a712	20 ed 95	jsr $95ed	                jsr xt_move
.a715	ca		dex		                dex
.a716	ca		dex		                dex
.a717	a5 00		lda $00		                lda cp
.a719	95 00		sta $00,x	                sta 0,x
.a71b	a5 01		lda $01		                lda cp+1
.a71d	95 01		sta $01,x	                sta 1,x
.a71f	68		pla		                pla                     ; length of string
.a720	18		clc		                clc
.a721	65 00		adc $00		                adc cp
.a723	85 00		sta $00		                sta cp
.a725	a5 01		lda $01		                lda cp+1
.a727	69 00		adc #$00	                adc #0                  ; we only need the carry
.a729	85 01		sta $01		                sta cp+1
.a72b	60		rts		z_word:         rts
.a72c					xt_wordlist:
.a72c	a0 05		ldy #$05	                ldy #num_wordlists_offset
.a72e	b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a730	c9 0c		cmp #$0c	                cmp #max_wordlists
.a732	d0 05		bne $a739	                bne _ok
.a734	a9 0b		lda #$0b	                lda #err_wordlist
.a736	4c 70 d8	jmp $d870	                jmp error
.a739					_ok:
.a739	1a		inc a		                ina             ; Increment the wordlist#
.a73a	91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a73c	ca		dex		                dex             ; and put it on the stack.
.a73d	ca		dex		                dex
.a73e	95 00		sta $00,x	                sta 0,x
.a740	74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a742	60		rts		z_wordlist:     rts
.a743					xt_words:
.a743	20 8e 89	jsr $898e	                jsr xt_cr
.a746	a9 00		lda #$00	                lda #0
.a748	48		pha		                pha
.a749	ca		dex		                dex                     ; Make room on the stack for
.a74a	ca		dex		                dex                     ; a dictionary pointer.
.a74b	64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a74d					_wordlist_loop:
.a74d	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a74f	a5 28		lda $28		                lda tmp3
.a751	d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a753	d0 02		bne $a757	                bne _have_wordlist
.a755	80 45		bra $a79c	                bra _words_done
.a757					_have_wordlist:
.a757	18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a758	69 1f		adc #$1f	                adc #search_order_offset
.a75a	a8		tay		                tay
.a75b	b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a75d	0a		asl a		                asl                     ; Turn offset into cells offset.
.a75e	18		clc		                clc
.a75f	69 06		adc #$06	                adc #wordlists_offset
.a761	a8		tay		                tay
.a762	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a764	95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a766	c8		iny		                iny
.a767	b1 1e		lda ($1e),y	                lda (up),y
.a769	95 01		sta $01,x	                sta 1,x
.a76b					_loop:
.a76b	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( nt nt )
.a76e	20 29 96	jsr $9629	                jsr xt_name_to_string   ; ( nt addr u )
.a771	68		pla		                pla
.a772	18		clc		                clc
.a773	75 00		adc $00,x	                adc 0,x
.a775	1a		inc a		                ina                     ; don't forget the space between words
.a776	c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a778	90 06		bcc $a780	                bcc +
.a77a	20 8e 89	jsr $898e	                jsr xt_cr
.a77d	b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a77f	1a		inc a		                ina                     ; with length of this word.
.a780					+
.a780	48		pha		                pha
.a781	20 2e a5	jsr $a52e	                jsr xt_type             ; ( nt )
.a784	a9 20		lda #$20	                lda #AscSP
.a786	20 21 8e	jsr $8e21	                jsr emit_a
.a789	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+
.a78c	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+
.a78f	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; @ ( nt+1 )
.a792	b5 00		lda $00,x	                lda 0,x
.a794	15 01		ora $01,x	                ora 1,x
.a796	d0 d3		bne $a76b	                bne _loop
.a798	e6 28		inc $28		                inc tmp3
.a79a	80 b1		bra $a74d	                bra _wordlist_loop
.a79c					_words_done:
.a79c	68		pla		                pla                     ; dump counter
.a79d	e8		inx		                inx
.a79e	e8		inx		                inx
.a79f	60		rts		z_words:        rts
.a7a0					xt_wordsize:
.a7a0	20 5a d8	jsr $d85a	                jsr underflow_1
.a7a3	b5 00		lda $00,x	                lda 0,x
.a7a5	85 24		sta $24		                sta tmp1
.a7a7	b5 01		lda $01,x	                lda 1,x
.a7a9	85 25		sta $25		                sta tmp1+1
.a7ab	a0 06		ldy #$06	                ldy #6
.a7ad	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a7af	88		dey		                dey
.a7b0	88		dey		                dey
.a7b1	38		sec		                sec
.a7b2	f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a7b4	95 00		sta $00,x	                sta 0,x
.a7b6	a0 07		ldy #$07	                ldy #7
.a7b8	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a7ba	88		dey		                dey
.a7bb	88		dey		                dey
.a7bc	f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a7be	95 01		sta $01,x	                sta 1,x
.a7c0	60		rts		z_wordsize:     rts
.a7c1					xt_xor:
.a7c1	20 5f d8	jsr $d85f	                jsr underflow_2
.a7c4	b5 00		lda $00,x	                lda 0,x
.a7c6	55 02		eor $02,x	                eor 2,x
.a7c8	95 02		sta $02,x	                sta 2,x
.a7ca	b5 01		lda $01,x	                lda 1,x
.a7cc	55 03		eor $03,x	                eor 3,x
.a7ce	95 03		sta $03,x	                sta 3,x
.a7d0	e8		inx		                inx
.a7d1	e8		inx		                inx
.a7d2	60		rts		z_xor:          rts
.a7d3					xt_case:
.a7d3					xt_forth_wordlist:
.a7d3					xt_zero:
.a7d3	ca		dex		                dex             ; push
.a7d4	ca		dex		                dex
.a7d5	74 00		stz $00,x	                stz 0,x
.a7d7	74 01		stz $01,x	                stz 1,x
.a7d9					z_case:
.a7d9					z_forth_wordlist:
.a7d9					z_zero:
.a7d9	60		rts		                rts
.a7da					xt_zero_equal:
.a7da	20 5a d8	jsr $d85a	                jsr underflow_1
.a7dd	b5 00		lda $00,x	                lda 0,x
.a7df	15 01		ora $01,x	                ora 1,x
.a7e1	f0 04		beq $a7e7	                beq _zero
.a7e3	a9 00		lda #$00	                lda #0
.a7e5	80 02		bra $a7e9	                bra _store
.a7e7					_zero:
.a7e7	a9 ff		lda #$ff	                lda #$ff
.a7e9					_store:
.a7e9	95 00		sta $00,x	                sta 0,x
.a7eb	95 01		sta $01,x	                sta 1,x
.a7ed	60		rts		z_zero_equal:   rts
.a7ee					xt_zero_greater:
.a7ee	20 5a d8	jsr $d85a	                jsr underflow_1
.a7f1	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a7f3	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7f5	30 05		bmi $a7fc	                bmi _done       ; TOS is negative, keep FLASE
.a7f7	15 00		ora $00,x	                ora 0,x
.a7f9	f0 01		beq $a7fc	                beq _done       ; TOS is zero, keep FALSE
.a7fb	88		dey		                dey             ; TOS is postive, make true
.a7fc					_done:
.a7fc	98		tya		                tya
.a7fd	95 00		sta $00,x	                sta 0,x
.a7ff	95 01		sta $01,x	                sta 1,x
.a801	60		rts		z_zero_greater: rts
.a802					xt_zero_less:
.a802	20 5a d8	jsr $d85a	                jsr underflow_1
.a805	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a807	b5 01		lda $01,x	                lda 1,x         ; MSB
.a809	10 01		bpl $a80c	                bpl _done       ; TOS is positive, so keep FALSE
.a80b	88		dey		                dey             ; TOS is negative, make TRUE
.a80c					_done:
.a80c	98		tya		                tya
.a80d	95 00		sta $00,x	                sta 0,x
.a80f	95 01		sta $01,x	                sta 1,x
.a811	60		rts		z_zero_less:    rts
.a812					xt_zero_unequal:
.a812	20 5a d8	jsr $d85a	                jsr underflow_1
.a815	a0 00		ldy #$00	                ldy #0          ; default false
.a817	b5 00		lda $00,x	                lda 0,x
.a819	15 01		ora $01,x	                ora 1,x
.a81b	f0 01		beq $a81e	                beq _got_zero
.a81d	88		dey		                dey
.a81e					_got_zero:
.a81e	98		tya		                tya
.a81f	95 00		sta $00,x	                sta 0,x
.a821	95 01		sta $01,x	                sta 1,x
.a823	60		rts		z_zero_unequal: rts
.a824					xt_editor_screen_helper:
.a824	20 da 8d	jsr $8dda	                jsr xt_dup
.a827	20 04 9f	jsr $9f04	                jsr xt_scr
.a82a	20 b8 a1	jsr $a1b8	                jsr xt_store
.a82d	20 e0 85	jsr $85e0	                jsr xt_buffer
.a830					z_editor_screen_helper:
.a830	60		rts		                rts
.a831					xt_editor_enter_screen:
.a831	20 24 a8	jsr $a824	                jsr xt_editor_screen_helper
.a834	20 59 8d	jsr $8d59	                jsr xt_drop
.a837	64 2e		stz $2e		                stz editor1
.a839					_prompt_loop:
.a839	ca		dex		                dex
.a83a	ca		dex		                dex
.a83b	a5 2e		lda $2e		                lda editor1
.a83d	95 00		sta $00,x	                sta 0,x
.a83f	74 01		stz $01,x	                stz 1,x
.a841	20 06 a9	jsr $a906	                jsr xt_editor_o
.a844	e6 2e		inc $2e		                inc editor1
.a846	a9 10		lda #$10	                lda #16
.a848	c5 2e		cmp $2e		                cmp editor1
.a84a	d0 ed		bne $a839	                bne _prompt_loop
.a84c					z_editor_enter_screen:
.a84c	60		rts		                rts
.a84d					xt_editor_erase_screen:
.a84d	20 24 a8	jsr $a824	                jsr xt_editor_screen_helper
.a850	ca		dex		                dex
.a851	ca		dex		                dex
.a852	74 00		stz $00,x	                stz 0,x
.a854	a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a856	95 01		sta $01,x	                sta 1,x
.a858	20 15 8f	jsr $8f15	                jsr xt_blank
.a85b	20 8f a6	jsr $a68f	                jsr xt_update
.a85e					z_editor_erase_screen:
.a85e	60		rts		                rts
.a85f					xt_editor_el:
.a85f	20 ed a8	jsr $a8ed	                jsr xt_editor_line
.a862	ca		dex		                dex
.a863	ca		dex		                dex
.a864	a9 40		lda #$40	                lda #64
.a866	95 00		sta $00,x	                sta 0,x
.a868	74 01		stz $01,x	                stz 1,x
.a86a	20 15 8f	jsr $8f15	                jsr xt_blank
.a86d	20 8f a6	jsr $a68f	                jsr xt_update
.a870	60		rts		z_editor_el:    rts
.a871					xt_editor_l:
.a871	ca		dex		                dex             ; Put SCR on the stack.
.a872	ca		dex		                dex
.a873	a0 02		ldy #$02	                ldy #scr_offset
.a875	b1 1e		lda ($1e),y	                lda (up),y
.a877	95 00		sta $00,x	                sta 0,x
.a879	c8		iny		                iny
.a87a	b1 1e		lda ($1e),y	                lda (up),y
.a87c	95 01		sta $01,x	                sta 1,x
.a87e	20 ec 83	jsr $83ec	                jsr xt_block    ; Get the current screen.
.a881	20 8e 89	jsr $898e	                jsr xt_cr
.a884	80 08		bra $a88e	                bra _after_screen_msg
.a886					_screen_msg:
>a886	53 63 72 65 65 6e 20 23		                .text "Screen #"
.a88e					_after_screen_msg:
.a88e	20 d4 a0	jsr $a0d4	                jsr sliteral_runtime
>a891	86 a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a895	20 2e a5	jsr $a52e	                jsr xt_type
.a898	20 04 9f	jsr $9f04	                jsr xt_scr
.a89b	20 ab 8f	jsr $8fab	                jsr xt_fetch
.a89e	ca		dex		                dex
.a89f	ca		dex		                dex
.a8a0	a9 04		lda #$04	                lda #4          ; four spaces
.a8a2	95 00		sta $00,x	                sta 0,x
.a8a4	74 01		stz $01,x	                stz 1,x
.a8a6	20 65 a5	jsr $a565	                jsr xt_u_dot_r
.a8a9	64 28		stz $28		                stz tmp3
.a8ab					_line_loop:
.a8ab	20 8e 89	jsr $898e	                jsr xt_cr
.a8ae	ca		dex		                dex
.a8af	ca		dex		                dex
.a8b0	ca		dex		                dex
.a8b1	ca		dex		                dex
.a8b2	74 03		stz $03,x	                stz 3,x
.a8b4	a5 28		lda $28		                lda tmp3
.a8b6	95 02		sta $02,x	                sta 2,x
.a8b8	74 01		stz $01,x	                stz 1,x
.a8ba	a9 02		lda #$02	                lda #2
.a8bc	95 00		sta $00,x	                sta 0,x
.a8be	20 65 a5	jsr $a565	                jsr xt_u_dot_r
.a8c1	20 49 a1	jsr $a149	                jsr xt_space
.a8c4	20 da 8d	jsr $8dda	                jsr xt_dup
.a8c7	ca		dex		                dex
.a8c8	ca		dex		                dex
.a8c9	a9 40		lda #$40	                lda #64
.a8cb	95 00		sta $00,x	                sta 0,x
.a8cd	74 01		stz $01,x	                stz 1,x
.a8cf	20 2e a5	jsr $a52e	                jsr xt_type
.a8d2	18		clc		                clc
.a8d3	a9 40		lda #$40	                lda #64
.a8d5	75 00		adc $00,x	                adc 0,x
.a8d7	95 00		sta $00,x	                sta 0,x
.a8d9	b5 01		lda $01,x	                lda 1,x
.a8db	69 00		adc #$00	                adc #0      ; Add carry
.a8dd	95 01		sta $01,x	                sta 1,x
.a8df	e6 28		inc $28		                inc tmp3
.a8e1	a5 28		lda $28		                lda tmp3
.a8e3	c9 10		cmp #$10	                cmp #16
.a8e5	d0 c4		bne $a8ab	                bne _line_loop
.a8e7	20 8e 89	jsr $898e	                jsr xt_cr
.a8ea	e8		inx		                inx
.a8eb	e8		inx		                inx
.a8ec	60		rts		z_editor_l:            rts
.a8ed					xt_editor_line:
.a8ed	20 5a d8	jsr $d85a	                jsr underflow_1
.a8f0	a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a8f2					_shift_tos_left:
.a8f2	16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a8f4	36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a8f6	88		dey		                dey
.a8f7	d0 f9		bne $a8f2	                bne _shift_tos_left
.a8f9	20 04 9f	jsr $9f04	                jsr xt_scr
.a8fc	20 ab 8f	jsr $8fab	                jsr xt_fetch
.a8ff	20 ec 83	jsr $83ec	                jsr xt_block
.a902	20 0e 9a	jsr $9a0e	                jsr xt_plus
.a905	60		rts		z_editor_line:  rts
.a906					xt_editor_o:
.a906	20 8e 89	jsr $898e	                jsr xt_cr
.a909	20 da 8d	jsr $8dda	                jsr xt_dup
.a90c	20 d2 a3	jsr $a3d2	                jsr xt_two
.a90f	20 65 a5	jsr $a565	                jsr xt_u_dot_r
.a912	20 49 a1	jsr $a149	                jsr xt_space
.a915	a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a917	20 21 8e	jsr $8e21	                jsr emit_a
.a91a	20 49 a1	jsr $a149	                jsr xt_space
.a91d	20 ed a8	jsr $a8ed	                jsr xt_editor_line
.a920	20 da 8d	jsr $8dda	                jsr xt_dup      ; Save a copy of the line address for later.
.a923	ca		dex		                dex
.a924	ca		dex		                dex
.a925	a9 40		lda #$40	                lda #64         ; chars/line
.a927	95 00		sta $00,x	                sta 0,x
.a929	74 01		stz $01,x	                stz 1,x
.a92b	20 57 81	jsr $8157	                jsr xt_accept
.a92e	20 da 8d	jsr $8dda	                jsr xt_dup
.a931	20 99 96	jsr $9699	                jsr xt_not_rote ; -rot
.a934	20 0e 9a	jsr $9a0e	                jsr xt_plus
.a937	ca		dex		                dex
.a938	ca		dex		                dex
.a939	a9 40		lda #$40	                lda #64         ; chars/line
.a93b	95 00		sta $00,x	                sta 0,x
.a93d	74 01		stz $01,x	                stz 1,x
.a93f	20 82 9b	jsr $9b82	                jsr xt_rot
.a942	20 7b 95	jsr $957b	                jsr xt_minus
.a945	20 15 8f	jsr $8f15	                jsr xt_blank
.a948	20 8f a6	jsr $a68f	                jsr xt_update
.a94b	60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a94c					assembler:
.a94c					xt_asm_adc_h:
.a94c	a9 69		lda #$69	                lda #$69
.a94e	4c a7 ac	jmp $aca7	                jmp asm_common
.a951					z_asm_adc_h:
.a951					xt_asm_adc_x:
.a951	a9 7d		lda #$7d	                lda #$7D
.a953	4c a7 ac	jmp $aca7	                jmp asm_common
.a956					z_asm_adc_x:
.a956					xt_asm_adc_y:
.a956	a9 79		lda #$79	                lda #$79
.a958	4c a7 ac	jmp $aca7	                jmp asm_common
.a95b					z_asm_adc_y:
.a95b					xt_asm_adc_z:
.a95b	a9 65		lda #$65	                lda #$65
.a95d	4c a7 ac	jmp $aca7	                jmp asm_common
.a960					z_asm_adc_z:
.a960					xt_asm_adc_zi:
.a960	a9 72		lda #$72	                lda #$72
.a962	4c a7 ac	jmp $aca7	                jmp asm_common
.a965					z_asm_adc_zi:
.a965					xt_asm_adc_ziy:
.a965	a9 71		lda #$71	                lda #$71
.a967	4c a7 ac	jmp $aca7	                jmp asm_common
.a96a					z_asm_adc_ziy:
.a96a					xt_asm_adc_zx:
.a96a	a9 75		lda #$75	                lda #$75
.a96c	4c a7 ac	jmp $aca7	                jmp asm_common
.a96f					z_asm_adc_zx:
.a96f					xt_asm_adc_zxi:
.a96f	a9 61		lda #$61	                lda #$61
.a971	4c a7 ac	jmp $aca7	                jmp asm_common
.a974					z_asm_adc_zxi:
.a974					xt_asm_and:
.a974	a9 2d		lda #$2d	                lda #$2D
.a976	4c a7 ac	jmp $aca7	                jmp asm_common
.a979					z_asm_and:
.a979					xt_asm_and_h:
.a979	a9 29		lda #$29	                lda #$29
.a97b	4c a7 ac	jmp $aca7	                jmp asm_common
.a97e					z_asm_and_h:
.a97e					xt_asm_and_x:
.a97e	a9 3d		lda #$3d	                lda #$3D
.a980	4c a7 ac	jmp $aca7	                jmp asm_common
.a983					z_asm_and_x:
.a983					xt_asm_and_y:
.a983	a9 39		lda #$39	                lda #$39
.a985	4c a7 ac	jmp $aca7	                jmp asm_common
.a988					z_asm_and_y:
.a988					xt_asm_and_z:
.a988	a9 25		lda #$25	                lda #$25
.a98a	4c a7 ac	jmp $aca7	                jmp asm_common
.a98d					z_asm_and_z:
.a98d					xt_asm_and_zi:
.a98d	a9 32		lda #$32	                lda #$32
.a98f	4c a7 ac	jmp $aca7	                jmp asm_common
.a992					z_asm_and_zi:
.a992					xt_asm_and_ziy:
.a992	a9 31		lda #$31	                lda #$31
.a994	4c a7 ac	jmp $aca7	                jmp asm_common
.a997					z_asm_and_ziy:
.a997					xt_asm_and_zx:
.a997	a9 35		lda #$35	                lda #$35
.a999	4c a7 ac	jmp $aca7	                jmp asm_common
.a99c					z_asm_and_zx:
.a99c					xt_asm_and_zxi:
.a99c	a9 21		lda #$21	                lda #$21
.a99e	4c a7 ac	jmp $aca7	                jmp asm_common
.a9a1					z_asm_and_zxi:
.a9a1					xt_asm_asl:
.a9a1	a9 0e		lda #$0e	                lda #$0E
.a9a3	4c a7 ac	jmp $aca7	                jmp asm_common
.a9a6					z_asm_asl:
.a9a6					xt_asm_asl_a:
.a9a6	a9 0a		lda #$0a	                lda #$0A
.a9a8	4c a7 ac	jmp $aca7	                jmp asm_common
.a9ab					z_asm_asl_a:
.a9ab					xt_asm_asl_x:
.a9ab	a9 1e		lda #$1e	                lda #$1E
.a9ad	4c a7 ac	jmp $aca7	                jmp asm_common
.a9b0					z_asm_asl_x:
.a9b0					xt_asm_asl_z:
.a9b0	a9 06		lda #$06	                lda #$06
.a9b2	4c a7 ac	jmp $aca7	                jmp asm_common
.a9b5					z_asm_asl_z:
.a9b5					xt_asm_asl_zx:
.a9b5	a9 16		lda #$16	                lda #$16
.a9b7	4c a7 ac	jmp $aca7	                jmp asm_common
.a9ba					z_asm_asl_zx:
.a9ba					xt_asm_bcc:
.a9ba	a9 90		lda #$90	                lda #$90
.a9bc	4c a7 ac	jmp $aca7	                jmp asm_common
.a9bf					z_asm_bcc:
.a9bf					xt_asm_bcs:
.a9bf	a9 b0		lda #$b0	                lda #$B0
.a9c1	a0 02		ldy #$02	                ldy #2
.a9c3	4c a7 ac	jmp $aca7	                jmp asm_common
.a9c6					z_asm_bcs:
.a9c6					xt_asm_beq:
.a9c6	a9 f0		lda #$f0	                lda #$F0
.a9c8	4c a7 ac	jmp $aca7	                jmp asm_common
.a9cb					z_asm_beq:
.a9cb					xt_asm_bit:
.a9cb	a9 2c		lda #$2c	                lda #$2C
.a9cd	4c a7 ac	jmp $aca7	                jmp asm_common
.a9d0					z_asm_bit:
.a9d0					xt_asm_bit_h:
.a9d0	a9 89		lda #$89	                lda #$89
.a9d2	4c a7 ac	jmp $aca7	                jmp asm_common
.a9d5					z_asm_bit_h:
.a9d5					xt_asm_bit_x:
.a9d5	a9 3c		lda #$3c	                lda #$3C
.a9d7	4c a7 ac	jmp $aca7	                jmp asm_common
.a9da					z_asm_bit_x:
.a9da					xt_asm_bit_z:
.a9da	a9 24		lda #$24	                lda #$24
.a9dc	4c a7 ac	jmp $aca7	                jmp asm_common
.a9df					z_asm_bit_z:
.a9df					xt_asm_bit_zx:
.a9df	a9 34		lda #$34	                lda #$34
.a9e1	4c a7 ac	jmp $aca7	                jmp asm_common
.a9e4					z_asm_bit_zx:
.a9e4					xt_asm_bmi:
.a9e4	a9 30		lda #$30	                lda #$30
.a9e6	4c a7 ac	jmp $aca7	                jmp asm_common
.a9e9					z_asm_bmi:
.a9e9					xt_asm_bne:
.a9e9	a9 d0		lda #$d0	                lda #$D0
.a9eb	4c a7 ac	jmp $aca7	                jmp asm_common
.a9ee					z_asm_bne:
.a9ee					xt_asm_bpl:
.a9ee	a9 10		lda #$10	                lda #$10
.a9f0	4c a7 ac	jmp $aca7	                jmp asm_common
.a9f3					z_asm_bpl:
.a9f3					xt_asm_bra:
.a9f3	a9 80		lda #$80	                lda #$80
.a9f5	4c a7 ac	jmp $aca7	                jmp asm_common
.a9f8					z_asm_bra:
.a9f8					xt_asm_brk:
.a9f8	a9 00		lda #$00	                lda #$00
.a9fa	4c a7 ac	jmp $aca7	                jmp asm_common
.a9fd					z_asm_brk:
.a9fd					xt_asm_bvc:
.a9fd	a9 50		lda #$50	                lda #$50
.a9ff	4c a7 ac	jmp $aca7	                jmp asm_common
.aa02					z_asm_bvc:
.aa02					xt_asm_bvs:
.aa02	a9 70		lda #$70	                lda #$70
.aa04	4c a7 ac	jmp $aca7	                jmp asm_common
.aa07					z_asm_bvs:
.aa07					xt_asm_clc:
.aa07	a9 18		lda #$18	                lda #$18
.aa09	4c a7 ac	jmp $aca7	                jmp asm_common
.aa0c					z_asm_clc:
.aa0c					xt_asm_cld:
.aa0c	a9 d8		lda #$d8	                lda #$D8
.aa0e	4c a7 ac	jmp $aca7	                jmp asm_common
.aa11					z_asm_cld:
.aa11					xt_asm_cli:
.aa11	a9 58		lda #$58	                lda #$58
.aa13	4c a7 ac	jmp $aca7	                jmp asm_common
.aa16					z_asm_cli:
.aa16					xt_asm_clv:
.aa16	a9 b8		lda #$b8	                lda #$B8
.aa18	4c a7 ac	jmp $aca7	                jmp asm_common
.aa1b					z_asm_clv:
.aa1b					xt_asm_cmp:
.aa1b	a9 cd		lda #$cd	                lda #$CD
.aa1d	4c a7 ac	jmp $aca7	                jmp asm_common
.aa20					z_asm_cmp:
.aa20					xt_asm_cmp_h:
.aa20	a9 c9		lda #$c9	                lda #$C9
.aa22	4c a7 ac	jmp $aca7	                jmp asm_common
.aa25					z_asm_cmp_h:
.aa25					xt_asm_cmp_x:
.aa25	a9 dd		lda #$dd	                lda #$DD
.aa27	4c a7 ac	jmp $aca7	                jmp asm_common
.aa2a					z_asm_cmp_x:
.aa2a					xt_asm_cmp_y:
.aa2a	a9 d9		lda #$d9	                lda #$D9
.aa2c	4c a7 ac	jmp $aca7	                jmp asm_common
.aa2f					z_asm_cmp_y:
.aa2f					xt_asm_cmp_z:
.aa2f	a9 c5		lda #$c5	                lda #$C5
.aa31	4c a7 ac	jmp $aca7	                jmp asm_common
.aa34					z_asm_cmp_z:
.aa34					xt_asm_cmp_zi:
.aa34	a9 d2		lda #$d2	                lda #$D2
.aa36	4c a7 ac	jmp $aca7	                jmp asm_common
.aa39					z_asm_cmp_zi:
.aa39					xt_asm_cmp_ziy:
.aa39	a9 d1		lda #$d1	                lda #$D1
.aa3b	4c a7 ac	jmp $aca7	                jmp asm_common
.aa3e					z_asm_cmp_ziy:
.aa3e					xt_asm_cmp_zx:
.aa3e	a9 d5		lda #$d5	                lda #$D5
.aa40	4c a7 ac	jmp $aca7	                jmp asm_common
.aa43					z_asm_cmp_zx:
.aa43					xt_asm_cmp_zxi:
.aa43	a9 c1		lda #$c1	                lda #$C1
.aa45	4c a7 ac	jmp $aca7	                jmp asm_common
.aa48					z_asm_cmp_zxi:
.aa48					xt_asm_cpx:
.aa48	a9 ec		lda #$ec	                lda #$EC
.aa4a	4c a7 ac	jmp $aca7	                jmp asm_common
.aa4d					z_asm_cpx:
.aa4d					xt_asm_cpx_h:
.aa4d	a9 e0		lda #$e0	                lda #$E0
.aa4f	4c a7 ac	jmp $aca7	                jmp asm_common
.aa52					z_asm_cpx_h:
.aa52					xt_asm_cpx_z:
.aa52	a9 e4		lda #$e4	                lda #$E4
.aa54	4c a7 ac	jmp $aca7	                jmp asm_common
.aa57					z_asm_cpx_z:
.aa57					xt_asm_cpy:
.aa57	a9 cc		lda #$cc	                lda #$CC
.aa59	a0 03		ldy #$03	                ldy #3
.aa5b	4c a7 ac	jmp $aca7	                jmp asm_common
.aa5e					z_asm_cpy:
.aa5e					xt_asm_cpy_h:
.aa5e	a9 c0		lda #$c0	                lda #$C0
.aa60	4c a7 ac	jmp $aca7	                jmp asm_common
.aa63					z_asm_cpy_h:
.aa63					xt_asm_cpy_z:
.aa63	a9 c4		lda #$c4	                lda #$C4
.aa65	4c a7 ac	jmp $aca7	                jmp asm_common
.aa68					z_asm_cpy_z:
.aa68					xt_asm_dec:
.aa68	a9 ce		lda #$ce	                lda #$CE
.aa6a	4c a7 ac	jmp $aca7	                jmp asm_common
.aa6d					z_asm_dec:
.aa6d					xt_asm_dec_a:
.aa6d	a9 3a		lda #$3a	                lda #$3A
.aa6f	4c a7 ac	jmp $aca7	                jmp asm_common
.aa72					z_asm_dec_a:
.aa72					xt_asm_dec_x:
.aa72	a9 de		lda #$de	                lda #$DE
.aa74	4c a7 ac	jmp $aca7	                jmp asm_common
.aa77					z_asm_dec_x:
.aa77					xt_asm_dec_z:
.aa77	a9 c6		lda #$c6	                lda #$C6
.aa79	4c a7 ac	jmp $aca7	                jmp asm_common
.aa7c					z_asm_dec_z:
.aa7c					xt_asm_dec_zx:
.aa7c	a9 d6		lda #$d6	                lda #$D6
.aa7e	4c a7 ac	jmp $aca7	                jmp asm_common
.aa81					z_asm_dec_zx:
.aa81					xt_asm_dex:
.aa81	a9 ca		lda #$ca	                lda #$CA
.aa83	4c a7 ac	jmp $aca7	                jmp asm_common
.aa86					z_asm_dex:
.aa86					xt_asm_dey:
.aa86	a9 88		lda #$88	                lda #$88
.aa88	4c a7 ac	jmp $aca7	                jmp asm_common
.aa8b					z_asm_dey:
.aa8b					xt_asm_eor:
.aa8b	a9 4d		lda #$4d	                lda #$4D
.aa8d	4c a7 ac	jmp $aca7	                jmp asm_common
.aa90					z_asm_eor:
.aa90					xt_asm_eor_h:
.aa90	a9 49		lda #$49	                lda #$49
.aa92	4c a7 ac	jmp $aca7	                jmp asm_common
.aa95					z_asm_eor_h:
.aa95					xt_asm_eor_x:
.aa95	a9 5d		lda #$5d	                lda #$5D
.aa97	4c a7 ac	jmp $aca7	                jmp asm_common
.aa9a					z_asm_eor_x:
.aa9a					xt_asm_eor_y:
.aa9a	a9 59		lda #$59	                lda #$59
.aa9c	4c a7 ac	jmp $aca7	                jmp asm_common
.aa9f					z_asm_eor_y:
.aa9f					xt_asm_eor_z:
.aa9f	a9 45		lda #$45	                lda #$45
.aaa1	4c a7 ac	jmp $aca7	                jmp asm_common
.aaa4					z_asm_eor_z:
.aaa4					xt_asm_eor_zi:
.aaa4	a9 52		lda #$52	                lda #$52
.aaa6	4c a7 ac	jmp $aca7	                jmp asm_common
.aaa9					z_asm_eor_zi:
.aaa9					xt_asm_eor_ziy:
.aaa9	a9 51		lda #$51	                lda #$51
.aaab	4c a7 ac	jmp $aca7	                jmp asm_common
.aaae					z_asm_eor_ziy:
.aaae					xt_asm_eor_zx:
.aaae	a9 55		lda #$55	                lda #$55
.aab0	4c a7 ac	jmp $aca7	                jmp asm_common
.aab3					z_asm_eor_zx:
.aab3					xt_asm_eor_zxi:
.aab3	a9 41		lda #$41	                lda #$41
.aab5	4c a7 ac	jmp $aca7	                jmp asm_common
.aab8					z_asm_eor_zxi:
.aab8					xt_asm_inc:
.aab8	a9 ee		lda #$ee	                lda #$EE
.aaba	4c a7 ac	jmp $aca7	                jmp asm_common
.aabd					z_asm_inc:
.aabd					xt_asm_inc_a:
.aabd	a9 1a		lda #$1a	                lda #$1A
.aabf	4c a7 ac	jmp $aca7	                jmp asm_common
.aac2					z_asm_inc_a:
.aac2					xt_asm_inc_x:
.aac2	a9 fe		lda #$fe	                lda #$FE
.aac4	4c a7 ac	jmp $aca7	                jmp asm_common
.aac7					z_asm_inc_x:
.aac7					xt_asm_inc_z:
.aac7	a9 e6		lda #$e6	                lda #$E6
.aac9	4c a7 ac	jmp $aca7	                jmp asm_common
.aacc					z_asm_inc_z:
.aacc					xt_asm_inc_zx:
.aacc	a9 f6		lda #$f6	                lda #$F6
.aace	4c a7 ac	jmp $aca7	                jmp asm_common
.aad1					z_asm_inc_zx:
.aad1					xt_asm_inx:
.aad1	a9 e8		lda #$e8	                lda #$E8
.aad3	4c a7 ac	jmp $aca7	                jmp asm_common
.aad6					z_asm_inx:
.aad6					xt_asm_iny:
.aad6	a9 c8		lda #$c8	                lda #$C8
.aad8	4c a7 ac	jmp $aca7	                jmp asm_common
.aadb					z_asm_iny:
.aadb					xt_asm_jmp:
.aadb	a9 4c		lda #$4c	                lda #$4C
.aadd	4c a7 ac	jmp $aca7	                jmp asm_common
.aae0					z_asm_jmp:
.aae0					xt_asm_jmp_i:
.aae0	a9 6c		lda #$6c	                lda #$6C
.aae2	4c a7 ac	jmp $aca7	                jmp asm_common
.aae5					z_asm_jmp_i:
.aae5					xt_asm_jmp_xi:
.aae5	a9 7c		lda #$7c	                lda #$7C
.aae7	4c a7 ac	jmp $aca7	                jmp asm_common
.aaea					z_asm_jmp_xi:
.aaea					xt_asm_jsr:
.aaea	a9 20		lda #$20	                lda #$20
.aaec	4c a7 ac	jmp $aca7	                jmp asm_common
.aaef					z_asm_jsr:
.aaef					xt_asm_lda:
.aaef	a9 ad		lda #$ad	                lda #$AD
.aaf1	4c a7 ac	jmp $aca7	                jmp asm_common
.aaf4					z_asm_lda:
.aaf4					xt_asm_lda_h:
.aaf4	a9 a9		lda #$a9	                lda #$A9
.aaf6	4c a7 ac	jmp $aca7	                jmp asm_common
.aaf9					z_asm_lda_h:
.aaf9					xt_asm_lda_x:
.aaf9	a9 bd		lda #$bd	                lda #$BD
.aafb	4c a7 ac	jmp $aca7	                jmp asm_common
.aafe					z_asm_lda_x:
.aafe					xt_asm_lda_y:
.aafe	a9 b9		lda #$b9	                lda #$B9
.ab00	4c a7 ac	jmp $aca7	                jmp asm_common
.ab03					z_asm_lda_y:
.ab03					xt_asm_lda_z:
.ab03	a9 a5		lda #$a5	                lda #$A5
.ab05	4c a7 ac	jmp $aca7	                jmp asm_common
.ab08					z_asm_lda_z:
.ab08					xt_asm_lda_zi:
.ab08	a9 b2		lda #$b2	                lda #$B2
.ab0a	4c a7 ac	jmp $aca7	                jmp asm_common
.ab0d					z_asm_lda_zi:
.ab0d					xt_asm_lda_ziy:
.ab0d	a9 b1		lda #$b1	                lda #$B1
.ab0f	4c a7 ac	jmp $aca7	                jmp asm_common
.ab12					z_asm_lda_ziy:
.ab12					xt_asm_lda_zx:
.ab12	a9 b5		lda #$b5	                lda #$B5
.ab14	4c a7 ac	jmp $aca7	                jmp asm_common
.ab17					z_asm_lda_zx:
.ab17					xt_asm_lda_zxi:
.ab17	a9 a1		lda #$a1	                lda #$A1
.ab19	4c a7 ac	jmp $aca7	                jmp asm_common
.ab1c					z_asm_lda_zxi:
.ab1c					xt_asm_ldx:
.ab1c	a9 ae		lda #$ae	                lda #$AE
.ab1e	4c a7 ac	jmp $aca7	                jmp asm_common
.ab21					z_asm_ldx:
.ab21					xt_asm_ldx_h:
.ab21	a9 a2		lda #$a2	                lda #$A2
.ab23	4c a7 ac	jmp $aca7	                jmp asm_common
.ab26					z_asm_ldx_h:
.ab26					xt_asm_ldx_y:
.ab26	a9 be		lda #$be	                lda #$BE
.ab28	4c a7 ac	jmp $aca7	                jmp asm_common
.ab2b					z_asm_ldx_y:
.ab2b					xt_asm_ldx_z:
.ab2b	a9 a6		lda #$a6	                lda #$A6
.ab2d	4c a7 ac	jmp $aca7	                jmp asm_common
.ab30					z_asm_ldx_z:
.ab30					xt_asm_ldx_zy:
.ab30	a9 b6		lda #$b6	                lda #$B6
.ab32	4c a7 ac	jmp $aca7	                jmp asm_common
.ab35					z_asm_ldx_zy:
.ab35					xt_asm_ldy:
.ab35	a9 ac		lda #$ac	                lda #$AC
.ab37	4c a7 ac	jmp $aca7	                jmp asm_common
.ab3a					z_asm_ldy:
.ab3a					xt_asm_ldy_h:
.ab3a	a9 a0		lda #$a0	                lda #$A0
.ab3c	4c a7 ac	jmp $aca7	                jmp asm_common
.ab3f					z_asm_ldy_h:
.ab3f					xt_asm_ldy_x:
.ab3f	a9 bc		lda #$bc	                lda #$BC
.ab41	4c a7 ac	jmp $aca7	                jmp asm_common
.ab44					z_asm_ldy_x:
.ab44					xt_asm_ldy_z:
.ab44	a9 a4		lda #$a4	                lda #$A4
.ab46	4c a7 ac	jmp $aca7	                jmp asm_common
.ab49					z_asm_ldy_z:
.ab49					xt_asm_ldy_zx:
.ab49	a9 b4		lda #$b4	                lda #$B4
.ab4b	4c a7 ac	jmp $aca7	                jmp asm_common
.ab4e					z_asm_ldy_zx:
.ab4e					xt_asm_lsr:
.ab4e	a9 4e		lda #$4e	                lda #$4E
.ab50	4c a7 ac	jmp $aca7	                jmp asm_common
.ab53					z_asm_lsr:
.ab53					xt_asm_lsr_a:
.ab53	a9 4a		lda #$4a	                lda #$4A
.ab55	4c a7 ac	jmp $aca7	                jmp asm_common
.ab58					z_asm_lsr_a:
.ab58					xt_asm_lsr_x:
.ab58	a9 5e		lda #$5e	                lda #$5E
.ab5a	4c a7 ac	jmp $aca7	                jmp asm_common
.ab5d					z_asm_lsr_x:
.ab5d					xt_asm_lsr_z:
.ab5d	a9 46		lda #$46	                lda #$46
.ab5f	4c a7 ac	jmp $aca7	                jmp asm_common
.ab62					z_asm_lsr_z:
.ab62					xt_asm_lsr_zx:
.ab62	a9 56		lda #$56	                lda #$56
.ab64	4c a7 ac	jmp $aca7	                jmp asm_common
.ab67					z_asm_lsr_zx:
.ab67					xt_asm_nop:
.ab67	a9 ea		lda #$ea	                lda #$EA
.ab69	4c a7 ac	jmp $aca7	                jmp asm_common
.ab6c					z_asm_nop:
.ab6c					xt_asm_ora:
.ab6c	a9 0d		lda #$0d	                lda #$0D
.ab6e	4c a7 ac	jmp $aca7	                jmp asm_common
.ab71					z_asm_ora:
.ab71					xt_asm_ora_h:
.ab71	a9 09		lda #$09	                lda #$09
.ab73	4c a7 ac	jmp $aca7	                jmp asm_common
.ab76					z_asm_ora_h:
.ab76					xt_asm_ora_x:
.ab76	a9 1d		lda #$1d	                lda #$1D
.ab78	4c a7 ac	jmp $aca7	                jmp asm_common
.ab7b					z_asm_ora_x:
.ab7b					xt_asm_ora_y:
.ab7b	a9 19		lda #$19	                lda #$19
.ab7d	4c a7 ac	jmp $aca7	                jmp asm_common
.ab80					z_asm_ora_y:
.ab80					xt_asm_ora_z:
.ab80	a9 05		lda #$05	                lda #$05
.ab82	4c a7 ac	jmp $aca7	                jmp asm_common
.ab85					z_asm_ora_z:
.ab85					xt_asm_ora_zi:
.ab85	a9 12		lda #$12	                lda #$12
.ab87	a0 02		ldy #$02	                ldy #2
.ab89	4c a7 ac	jmp $aca7	                jmp asm_common
.ab8c					z_asm_ora_zi:
.ab8c					xt_asm_ora_ziy:
.ab8c	a9 11		lda #$11	                lda #$11
.ab8e	4c a7 ac	jmp $aca7	                jmp asm_common
.ab91					z_asm_ora_ziy:
.ab91					xt_asm_ora_zx:
.ab91	a9 15		lda #$15	                lda #$15
.ab93	4c a7 ac	jmp $aca7	                jmp asm_common
.ab96					z_asm_ora_zx:
.ab96					xt_asm_ora_zxi:
.ab96	a9 01		lda #$01	                lda #$01
.ab98	4c a7 ac	jmp $aca7	                jmp asm_common
.ab9b					z_asm_ora_zxi:
.ab9b					xt_asm_pha:
.ab9b	a9 48		lda #$48	                lda #$48
.ab9d	4c a7 ac	jmp $aca7	                jmp asm_common
.aba0					z_asm_pha:
.aba0					xt_asm_php:
.aba0	a9 08		lda #$08	                lda #$08
.aba2	4c a7 ac	jmp $aca7	                jmp asm_common
.aba5					z_asm_php:
.aba5					xt_asm_phx:
.aba5	a9 da		lda #$da	                lda #$DA
.aba7	4c a7 ac	jmp $aca7	                jmp asm_common
.abaa					z_asm_phx:
.abaa					xt_asm_phy:
.abaa	a9 5a		lda #$5a	                lda #$5A
.abac	4c a7 ac	jmp $aca7	                jmp asm_common
.abaf					z_asm_phy:
.abaf					xt_asm_pla:
.abaf	a9 68		lda #$68	                lda #$68
.abb1	4c a7 ac	jmp $aca7	                jmp asm_common
.abb4					z_asm_pla:
.abb4					xt_asm_plp:
.abb4	a9 28		lda #$28	                lda #$28
.abb6	4c a7 ac	jmp $aca7	                jmp asm_common
.abb9					z_asm_plp:
.abb9					xt_asm_plx:
.abb9	a9 fa		lda #$fa	                lda #$FA
.abbb	4c a7 ac	jmp $aca7	                jmp asm_common
.abbe					z_asm_plx:
.abbe					xt_asm_ply:
.abbe	a9 7a		lda #$7a	                lda #$7A
.abc0	4c a7 ac	jmp $aca7	                jmp asm_common
.abc3					z_asm_ply:
.abc3					xt_asm_rol:
.abc3	a9 2e		lda #$2e	                lda #$2E
.abc5	4c a7 ac	jmp $aca7	                jmp asm_common
.abc8					z_asm_rol:
.abc8					xt_asm_rol_a:
.abc8	a9 2a		lda #$2a	                lda #$2A
.abca	4c a7 ac	jmp $aca7	                jmp asm_common
.abcd					z_asm_rol_a:
.abcd					xt_asm_rol_x:
.abcd	a9 3e		lda #$3e	                lda #$3E
.abcf	4c a7 ac	jmp $aca7	                jmp asm_common
.abd2					z_asm_rol_x:
.abd2					xt_asm_rol_z:
.abd2	a9 26		lda #$26	                lda #$26
.abd4	4c a7 ac	jmp $aca7	                jmp asm_common
.abd7					z_asm_rol_z:
.abd7					xt_asm_rol_zx:
.abd7	a9 36		lda #$36	                lda #$36
.abd9	4c a7 ac	jmp $aca7	                jmp asm_common
.abdc					z_asm_rol_zx:
.abdc					xt_asm_ror:
.abdc	a9 6e		lda #$6e	                lda #$6E
.abde	4c a7 ac	jmp $aca7	                jmp asm_common
.abe1					z_asm_ror:
.abe1					xt_asm_ror_a:
.abe1	a9 6a		lda #$6a	                lda #$6A
.abe3	4c a7 ac	jmp $aca7	                jmp asm_common
.abe6					z_asm_ror_a:
.abe6					xt_asm_ror_x:
.abe6	a9 7e		lda #$7e	                lda #$7E
.abe8	4c a7 ac	jmp $aca7	                jmp asm_common
.abeb					z_asm_ror_x:
.abeb					xt_asm_ror_z:
.abeb	a9 66		lda #$66	                lda #$66
.abed	4c a7 ac	jmp $aca7	                jmp asm_common
.abf0					z_asm_ror_z:
.abf0					xt_asm_ror_zx:
.abf0	a9 76		lda #$76	                lda #$76
.abf2	4c a7 ac	jmp $aca7	                jmp asm_common
.abf5					z_asm_ror_zx:
.abf5					xt_asm_rti:
.abf5	a9 40		lda #$40	                lda #$40
.abf7	4c a7 ac	jmp $aca7	                jmp asm_common
.abfa					z_asm_rti:
.abfa					xt_asm_rts:
.abfa	a9 60		lda #$60	                lda #$60
.abfc	4c a7 ac	jmp $aca7	                jmp asm_common
.abff					z_asm_rts:
.abff					xt_asm_sbc:
.abff	a9 ed		lda #$ed	                lda #$ED
.ac01	4c a7 ac	jmp $aca7	                jmp asm_common
.ac04					z_asm_sbc:
.ac04					xt_asm_sbc_h:
.ac04	a9 e9		lda #$e9	                lda #$E9
.ac06	4c a7 ac	jmp $aca7	                jmp asm_common
.ac09					z_asm_sbc_h:
.ac09					xt_asm_sbc_x:
.ac09	a9 fd		lda #$fd	                lda #$FD
.ac0b	4c a7 ac	jmp $aca7	                jmp asm_common
.ac0e					z_asm_sbc_x:
.ac0e					xt_asm_sbc_y:
.ac0e	a9 f9		lda #$f9	                lda #$F9
.ac10	4c a7 ac	jmp $aca7	                jmp asm_common
.ac13					z_asm_sbc_y:
.ac13					xt_asm_sbc_z:
.ac13	a9 e5		lda #$e5	                lda #$E5
.ac15	4c a7 ac	jmp $aca7	                jmp asm_common
.ac18					z_asm_sbc_z:
.ac18					xt_asm_sbc_zi:
.ac18	a9 f2		lda #$f2	                lda #$F2
.ac1a	4c a7 ac	jmp $aca7	                jmp asm_common
.ac1d					z_asm_sbc_zi:
.ac1d					xt_asm_sbc_ziy:
.ac1d	a9 f1		lda #$f1	                lda #$F1
.ac1f	4c a7 ac	jmp $aca7	                jmp asm_common
.ac22					z_asm_sbc_ziy:
.ac22					xt_asm_sbc_zx:
.ac22	a9 f5		lda #$f5	                lda #$F5
.ac24	4c a7 ac	jmp $aca7	                jmp asm_common
.ac27					z_asm_sbc_zx:
.ac27					xt_asm_sbc_zxi:
.ac27	a9 e1		lda #$e1	                lda #$E1
.ac29	80 7c		bra $aca7	                bra asm_common  ; <-- limit for BRA instead of JMP
.ac2b					z_asm_sbc_zxi:
.ac2b					xt_asm_sec:
.ac2b	a9 38		lda #$38	                lda #$38
.ac2d	80 78		bra $aca7	                bra asm_common
.ac2f					z_asm_sec:
.ac2f					xt_asm_sed:
.ac2f	a9 f8		lda #$f8	                lda #$F8
.ac31	80 74		bra $aca7	                bra asm_common
.ac33					z_asm_sed:
.ac33					xt_asm_sei:
.ac33	a9 78		lda #$78	                lda #$78
.ac35	80 70		bra $aca7	                bra asm_common
.ac37					z_asm_sei:
.ac37					xt_asm_sta:
.ac37	a9 8d		lda #$8d	                lda #$8D
.ac39	80 6c		bra $aca7	                bra asm_common
.ac3b					z_asm_sta:
.ac3b					xt_asm_sta_x:
.ac3b	a9 9d		lda #$9d	                lda #$9D
.ac3d	80 68		bra $aca7	                bra asm_common
.ac3f					z_asm_sta_x:
.ac3f					xt_asm_sta_y:
.ac3f	a9 99		lda #$99	                lda #$99
.ac41	80 64		bra $aca7	                bra asm_common
.ac43					z_asm_sta_y:
.ac43					xt_asm_sta_z:
.ac43	a9 85		lda #$85	                lda #$85
.ac45	80 60		bra $aca7	                bra asm_common
.ac47					z_asm_sta_z:
.ac47					xt_asm_sta_zi:
.ac47	a9 92		lda #$92	                lda #$92
.ac49	80 5c		bra $aca7	                bra asm_common
.ac4b					z_asm_sta_zi:
.ac4b					xt_asm_sta_ziy:
.ac4b	a9 91		lda #$91	                lda #$91
.ac4d	80 58		bra $aca7	                bra asm_common
.ac4f					z_asm_sta_ziy:
.ac4f					xt_asm_sta_zx:
.ac4f	a9 95		lda #$95	                lda #$95
.ac51	80 54		bra $aca7	                bra asm_common
.ac53					z_asm_sta_zx:
.ac53					xt_asm_sta_zxi:
.ac53	a9 81		lda #$81	                lda #$81
.ac55	80 50		bra $aca7	                bra asm_common
.ac57					z_asm_sta_zxi:
.ac57					xt_asm_stx:
.ac57	a9 8e		lda #$8e	                lda #$8E
.ac59	80 4c		bra $aca7	                bra asm_common
.ac5b					z_asm_stx:
.ac5b					xt_asm_stx_z:
.ac5b	a9 86		lda #$86	                lda #$86
.ac5d	80 48		bra $aca7	                bra asm_common
.ac5f					z_asm_stx_z:
.ac5f					xt_asm_stx_zy:
.ac5f	a9 96		lda #$96	                lda #$96
.ac61	80 44		bra $aca7	                bra asm_common
.ac63					z_asm_stx_zy:
.ac63					xt_asm_sty:
.ac63	a9 8c		lda #$8c	                lda #$8C
.ac65	80 40		bra $aca7	                bra asm_common
.ac67					z_asm_sty:
.ac67					xt_asm_sty_z:
.ac67	a9 84		lda #$84	                lda #$84
.ac69	80 3c		bra $aca7	                bra asm_common
.ac6b					z_asm_sty_z:
.ac6b					xt_asm_sty_zx:
.ac6b	a9 94		lda #$94	                lda #$94
.ac6d	80 38		bra $aca7	                bra asm_common
.ac6f					z_asm_sty_zx:
.ac6f					xt_asm_stz:
.ac6f	a9 9c		lda #$9c	                lda #$9C
.ac71	80 34		bra $aca7	                bra asm_common
.ac73					z_asm_stz:
.ac73					xt_asm_stz_x:
.ac73	a9 9e		lda #$9e	                lda #$9E
.ac75	80 30		bra $aca7	                bra asm_common
.ac77					z_asm_stz_x:
.ac77					xt_asm_stz_z:
.ac77	a9 64		lda #$64	                lda #$64
.ac79	80 2c		bra $aca7	                bra asm_common
.ac7b					z_asm_stz_z:
.ac7b					xt_asm_stz_zx:
.ac7b	a9 74		lda #$74	                lda #$74
.ac7d	80 28		bra $aca7	                bra asm_common
.ac7f					z_asm_stz_zx:
.ac7f					xt_asm_tax:
.ac7f	a9 aa		lda #$aa	                lda #$AA
.ac81	80 24		bra $aca7	                bra asm_common
.ac83					z_asm_tax:
.ac83					xt_asm_tay:
.ac83	a9 a8		lda #$a8	                lda #$A8
.ac85	80 20		bra $aca7	                bra asm_common
.ac87					z_asm_tay:
.ac87					xt_asm_trb:
.ac87	a9 1c		lda #$1c	                lda #$1C
.ac89	80 1c		bra $aca7	                bra asm_common
.ac8b					z_asm_trb:
.ac8b					xt_asm_trb_z:
.ac8b	a9 14		lda #$14	                lda #$14
.ac8d	80 18		bra $aca7	                bra asm_common
.ac8f					z_asm_trb_z:
.ac8f					xt_asm_tsb:
.ac8f	a9 0c		lda #$0c	                lda #$0C
.ac91	80 14		bra $aca7	                bra asm_common
.ac93					z_asm_tsb:
.ac93					xt_asm_tsb_z:
.ac93	a9 04		lda #$04	                lda #$04
.ac95	80 10		bra $aca7	                bra asm_common
.ac97					z_asm_tsb_z:
.ac97					xt_asm_tsx:
.ac97	a9 ba		lda #$ba	                lda #$BA
.ac99	80 0c		bra $aca7	                bra asm_common
.ac9b					z_asm_tsx:
.ac9b					xt_asm_txa:
.ac9b	a9 8a		lda #$8a	                lda #$8A
.ac9d	80 08		bra $aca7	                bra asm_common
.ac9f					z_asm_txa:
.ac9f					xt_asm_txs:
.ac9f	a9 9a		lda #$9a	                lda #$9A
.aca1	80 04		bra $aca7	                bra asm_common
.aca3					z_asm_txs:
.aca3					xt_asm_tya:
.aca3	a9 98		lda #$98	                lda #$98
.aca5	80 00		bra $aca7	                bra asm_common
.aca7					z_asm_tya:
.aca7					asm_common:
.aca7	a8		tay		                tay
.aca8	20 0d d7	jsr $d70d	                jsr cmpl_a
.acab	a9 13		lda #$13	                lda #<oc_index_table
.acad	85 26		sta $26		                sta tmp2
.acaf	a9 af		lda #$af	                lda #>oc_index_table
.acb1	85 27		sta $27		                sta tmp2+1
.acb3	98		tya		                tya             ; retrieve opcode
.acb4	0a		asl a		                asl             ; times two for offset
.acb5	90 02		bcc $acb9	                bcc +
.acb7	e6 27		inc $27		                inc tmp2+1
.acb9					+
.acb9	a8		tay		                tay             ; use Y as the index
.acba	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.acbc	85 28		sta $28		                sta tmp3
.acbe	c8		iny		                iny
.acbf	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acc1	85 29		sta $29		                sta tmp3+1
.acc3	b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.acc5	2a		rol a		                rol
.acc6	2a		rol a		                rol
.acc7	2a		rol a		                rol             ; Three times because we go through Carry
.acc8	29 03		and #$03	                and #%00000011
.acca	a8		tay		                tay
.accb	88		dey		                dey
.accc	f0 12		beq $ace0	                beq _done
.acce	20 5a d8	jsr $d85a	                jsr underflow_1
.acd1	b5 00		lda $00,x	                lda 0,x
.acd3	20 0d d7	jsr $d70d	                jsr cmpl_a      ; does not use Y
.acd6	88		dey		                dey
.acd7	f0 05		beq $acde	                beq _done_drop
.acd9	b5 01		lda $01,x	                lda 1,x
.acdb	20 0d d7	jsr $d70d	                jsr cmpl_a      ; Fall through to _done_drop
.acde					_done_drop:
.acde	e8		inx		                inx
.acdf	e8		inx		                inx             ; Fall through to _done
.ace0					_done:
.ace0	60		rts		                rts             ; Returns to original caller
.ace1					xt_asm_push_a:
.ace1	a0 00		ldy #$00	                ldy #0
.ace3					_loop:
.ace3	b9 f1 ac	lda $acf1,y	                lda asm_push_a_data,y
.ace6	c9 ff		cmp #$ff	                cmp #$FF
.ace8	f0 06		beq $acf0	                beq _done
.acea	20 0d d7	jsr $d70d	                jsr cmpl_a      ; does not change Y
.aced	c8		iny		                iny
.acee	80 f3		bra $ace3	                bra _loop
.acf0					_done:
.acf0					z_asm_push_a:
.acf0	60		rts		                rts
.acf1					asm_push_a_data:
>acf1	ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>acf7	ff				        .byte $FF               ; terminator
.acf8					xt_asm_back_jump:
.acf8					z_asm_back_jump:
.acf8	60		rts		                rts
.acf9					xt_asm_back_branch:
.acf9	20 9d 91	jsr $919d	                jsr xt_here             ; ( addr-l addr-h )
.acfc	20 7b 95	jsr $957b	                jsr xt_minus            ; ( offset )
.acff	3a		dec a		                dea
.ad00	3a		dec a		                dea
.ad01					z_asm_back_branch:
.ad01	60		rts		                rts
.ad02					assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.ad02					disassembler:
.ad02	20 8e 89	jsr $898e	                jsr xt_cr       ; ( addr u )
.ad05					_byte_loop:
.ad05	20 be 98	jsr $98be	                jsr xt_over     ; ( addr u addr )
.ad08	20 59 a5	jsr $a559	                jsr xt_u_dot    ; ( addr u )
.ad0b	20 49 a1	jsr $a149	                jsr xt_space
.ad0e	a9 13		lda #$13	                lda #<oc_index_table
.ad10	85 26		sta $26		                sta tmp2
.ad12	a9 af		lda #$af	                lda #>oc_index_table
.ad14	85 27		sta $27		                sta tmp2+1
.ad16	a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.ad18	85 36		sta $36		                sta scratch     ; Save opcode
.ad1a	0a		asl a		                asl             ; multiply by two for offset
.ad1b	90 02		bcc $ad1f	                bcc +
.ad1d	e6 27		inc $27		                inc tmp2+1      ; we're on second page
.ad1f					+
.ad1f	a8		tay		                tay             ; use Y as the index
.ad20	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ad22	85 28		sta $28		                sta tmp3
.ad24	48		pha		                pha
.ad25	c8		iny		                iny
.ad26	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ad28	85 29		sta $29		                sta tmp3+1
.ad2a	48		pha		                pha
.ad2b	b2 28		lda ($28)	                lda (tmp3)
.ad2d	a8		tay		                tay                     ; save copy of lengths byte
.ad2e	10 3c		bpl $ad6c	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.ad30	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ad33	f6 04		inc $04,x	                inc 4,x
.ad35	d0 02		bne $ad39	                bne +
.ad37	f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ad39					+
.ad39	b5 02		lda $02,x	                lda 2,x
.ad3b	d0 02		bne $ad3f	                bne +
.ad3d	d6 03		dec $03,x	                dec 3,x
.ad3f					+
.ad3f	d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.ad41	a1 04		lda ($04,x)	                lda (4,x)
.ad43	95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.ad45	85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.ad47	98		tya		                tya                     ; retrieve copy of lengths byte
.ad48	2a		rol a		                rol                     ; shift bit 6 to bit 7
.ad49	10 14		bpl $ad5f	                bpl _print_operand
.ad4b	f6 04		inc $04,x	                inc 4,x
.ad4d	d0 02		bne $ad51	                bne +
.ad4f	f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad51					+
.ad51	b5 02		lda $02,x	                lda 2,x
.ad53	d0 02		bne $ad57	                bne +
.ad55	d6 03		dec $03,x	                dec 3,x
.ad57					+
.ad57	d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad59	a1 04		lda ($04,x)	                lda (4,x)
.ad5b	95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad5d	85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad5f					_print_operand:
.ad5f	ca		dex		                dex
.ad60	ca		dex		                dex
.ad61	a9 05		lda #$05	                lda #5
.ad63	95 00		sta $00,x	                sta 0,x
.ad65	74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad67	20 65 a5	jsr $a565	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad6a	80 0b		bra $ad77	                bra _print_mnemonic
.ad6c					_no_operand:
.ad6c	ca		dex		                dex
.ad6d	ca		dex		                dex
.ad6e	a9 05		lda #$05	                lda #5
.ad70	95 00		sta $00,x	                sta 0,x
.ad72	74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad74	20 4f a1	jsr $a14f	                jsr xt_spaces           ; ( addr u )
.ad77					_print_mnemonic:
.ad77	20 49 a1	jsr $a149	                jsr xt_space
.ad7a	ca		dex		                dex
.ad7b	ca		dex		                dex                     ; ( addr u ? )
.ad7c	68		pla		                pla                     ; MSB
.ad7d	95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad7f	68		pla		                pla                     ; LSB
.ad80	95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad82	20 7a 89	jsr $897a	                jsr xt_count            ; ( addr u addr-o u-o )
.ad85	74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad87	b5 00		lda $00,x	                lda 0,x
.ad89	29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad8b	95 00		sta $00,x	                sta 0,x
.ad8d	20 2e a5	jsr $a52e	                jsr xt_type             ; ( addr u )
.ad90	a5 36		lda $36		                lda scratch
.ad92	c9 20		cmp #$20	                cmp #$20
.ad94	d0 59		bne $adef	                bne _not_jsr
.ad96	ca		dex		                dex
.ad97	ca		dex		                dex
.ad98	a9 05		lda #$05	                lda #5
.ad9a	95 00		sta $00,x	                sta 0,x
.ad9c	74 01		stz $01,x	                stz 1,x
.ad9e	20 4f a1	jsr $a14f	                jsr xt_spaces
.ada1	a9 c3		lda #$c3	                lda #<literal_runtime
.ada3	c5 37		cmp $37		                cmp scratch+1
.ada5	d0 0c		bne $adb3	                bne _not_literal
.ada7	a9 93		lda #$93	                lda #>literal_runtime
.ada9	c5 38		cmp $38		                cmp scratch+2
.adab	d0 06		bne $adb3	                bne _not_literal
.adad	20 a5 ae	jsr $aea5	                jsr disasm_literal
.adb0	4c 1c ae	jmp $ae1c	                jmp _printing_done
.adb3					_not_literal:
.adb3	a9 d4		lda #$d4	                lda #<sliteral_runtime
.adb5	c5 37		cmp $37		                cmp scratch+1
.adb7	d0 0c		bne $adc5	                bne _not_sliteral
.adb9	a9 a0		lda #$a0	                lda #>sliteral_runtime
.adbb	c5 38		cmp $38		                cmp scratch+2
.adbd	d0 06		bne $adc5	                bne _not_sliteral
.adbf	20 62 ae	jsr $ae62	                jsr disasm_sliteral
.adc2	4c 1c ae	jmp $ae1c	                jmp _printing_done
.adc5					_not_sliteral:
.adc5	a9 3f		lda #$3f	                lda #<zero_branch_runtime
.adc7	c5 37		cmp $37		                cmp scratch+1
.adc9	d0 0c		bne $add7	                bne _not_0branch
.adcb	a9 92		lda #$92	                lda #>zero_branch_runtime
.adcd	c5 38		cmp $38		                cmp scratch+2
.adcf	d0 06		bne $add7	                bne _not_0branch
.add1	20 99 ae	jsr $ae99	                jsr disasm_0branch
.add4	4c 1c ae	jmp $ae1c	                jmp _printing_done
.add7					_not_0branch
.add7	a9 06		lda #$06	                lda #<branch_runtime
.add9	c5 37		cmp $37		                cmp scratch+1
.addb	d0 0c		bne $ade9	                bne _not_branch
.addd	a9 8e		lda #$8e	                lda #>branch_runtime
.addf	c5 38		cmp $38		                cmp scratch+2
.ade1	d0 06		bne $ade9	                bne _not_branch
.ade3	20 9e ae	jsr $ae9e	                jsr disasm_branch
.ade6	4c 1c ae	jmp $ae1c	                jmp _printing_done
.ade9					_not_branch
.ade9	20 c3 ae	jsr $aec3	                jsr disasm_jsr
.adec	4c 1c ae	jmp $ae1c	                jmp _printing_done
.adef					_not_jsr:
.adef	c9 4c		cmp #$4c	                cmp #$4C
.adf1	d0 29		bne $ae1c	                bne _printing_done
.adf3	a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.adf5	85 39		sta $39		                sta scratch+3
.adf7	a5 38		lda $38		                lda scratch+2
.adf9	85 3a		sta $3a		                sta scratch+4
.adfb	b2 39		lda ($39)	                lda (scratch+3)
.adfd	c9 20		cmp #$20	                cmp #$20 ; check for JSR
.adff	d0 1b		bne $ae1c	                bne _printing_done
.ae01	e6 39		inc $39		                inc scratch+3
.ae03	d0 02		bne $ae07	                bne +
.ae05	e6 3a		inc $3a		                inc scratch+4
.ae07					+
.ae07	b2 39		lda ($39)	                lda (scratch+3)
.ae09	c9 d4		cmp #$d4	                cmp #<sliteral_runtime
.ae0b	d0 0f		bne $ae1c	                bne _printing_done
.ae0d	e6 39		inc $39		                inc scratch+3
.ae0f	d0 02		bne $ae13	                bne +
.ae11	e6 3a		inc $3a		                inc scratch+4
.ae13					+
.ae13	b2 39		lda ($39)	                lda (scratch+3)
.ae15	c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.ae17	d0 03		bne $ae1c	                bne _printing_done
.ae19	20 38 ae	jsr $ae38	                jsr disasm_sliteral_jump
.ae1c					_printing_done:
.ae1c	20 8e 89	jsr $898e	                jsr xt_cr
.ae1f	f6 02		inc $02,x	                inc 2,x
.ae21	d0 02		bne $ae25	                bne +
.ae23	f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ae25					+
.ae25	20 3c 98	jsr $983c	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ae28	b5 00		lda $00,x	                lda 0,x                 ; All done?
.ae2a	15 01		ora $01,x	                ora 1,x
.ae2c	f0 07		beq $ae35	                beq _done
.ae2e	b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae30	30 03		bmi $ae35	                bmi _done
.ae32	4c 05 ad	jmp $ad05	                jmp _byte_loop          ; out of range for BRA
.ae35					_done:
.ae35	4c db a3	jmp $a3db	                jmp xt_two_drop         ; JSR/RTS
.ae38					disasm_sliteral_jump:
.ae38	20 d9 a1	jsr $a1d9	                jsr xt_swap
.ae3b	ca		dex		                dex
.ae3c	ca		dex		                dex
.ae3d	a5 37		lda $37		                lda scratch+1
.ae3f	95 00		sta $00,x	                sta 0,x
.ae41	a5 38		lda $38		                lda scratch+2
.ae43	95 01		sta $01,x	                sta 1,x
.ae45	20 d9 a1	jsr $a1d9	                jsr xt_swap
.ae48	20 7b 95	jsr $957b	                jsr xt_minus
.ae4b	20 3c 98	jsr $983c	                jsr xt_one_minus
.ae4e	20 7b 95	jsr $957b	                jsr xt_minus
.ae51	ca		dex		                dex
.ae52	ca		dex		                dex
.ae53	a5 37		lda $37		                lda scratch+1
.ae55	95 00		sta $00,x	                sta 0,x
.ae57	a5 38		lda $38		                lda scratch+2
.ae59	95 01		sta $01,x	                sta 1,x
.ae5b	20 3c 98	jsr $983c	                jsr xt_one_minus
.ae5e	20 d9 a1	jsr $a1d9	                jsr xt_swap ; ( new_addr new_n )
.ae61	60		rts		                rts
.ae62					disasm_sliteral:
.ae62	a9 53		lda #$53	                lda #'S'
.ae64	20 21 8e	jsr $8e21	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae67	a9 0d		lda #$0d	                lda #str_disasm_lit     ; "LITERAL "
.ae69	20 86 d8	jsr $d886	                jsr print_string_no_lf
.ae6c	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; switch to (u addr)
.ae6f	20 48 98	jsr $9848	                jsr xt_one_plus
.ae72	20 da 8d	jsr $8dda	                jsr xt_dup
.ae75	20 ab 8f	jsr $8fab	                jsr xt_fetch
.ae78	20 59 a5	jsr $a559	                jsr xt_u_dot            ; Print the address of the string
.ae7b	20 d2 a3	jsr $a3d2	                jsr xt_two
.ae7e	20 0e 9a	jsr $9a0e	                jsr xt_plus
.ae81	20 da 8d	jsr $8dda	                jsr xt_dup
.ae84	20 8d 9a	jsr $9a8d	                jsr xt_question         ; Print the length of the string
.ae87	20 48 98	jsr $9848	                jsr xt_one_plus
.ae8a	20 d9 a1	jsr $a1d9	                jsr xt_swap            ; ( addr+4 u )
.ae8d	ca		dex		                dex
.ae8e	ca		dex		                dex
.ae8f	a9 04		lda #$04	                lda #4
.ae91	95 00		sta $00,x	                sta 0,x
.ae93	74 01		stz $01,x	                stz 1,x
.ae95	20 7b 95	jsr $957b	                jsr xt_minus            ; ( addr+4 u-4 )
.ae98	60		rts		                rts
.ae99					disasm_0branch:
.ae99	a9 30		lda #$30	                lda #'0'
.ae9b	20 21 8e	jsr $8e21	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ae9e					disasm_branch:
.ae9e	a9 0f		lda #$0f	                lda #str_disasm_bra
.aea0	20 86 d8	jsr $d886	                jsr print_string_no_lf ; "BRANCH "
.aea3	80 05		bra $aeaa	                bra disasm_print_literal
.aea5					disasm_literal:
.aea5	a9 0d		lda #$0d	                lda #str_disasm_lit
.aea7	20 86 d8	jsr $d886	                jsr print_string_no_lf ; "LITERAL "
.aeaa					disasm_print_literal:
.aeaa	20 d9 a1	jsr $a1d9	                jsr xt_swap ; switch to (u addr)
.aead	20 48 98	jsr $9848	                jsr xt_one_plus
.aeb0	20 da 8d	jsr $8dda	                jsr xt_dup
.aeb3	20 8d 9a	jsr $9a8d	                jsr xt_question ; Print the value at the adress
.aeb6	20 48 98	jsr $9848	                jsr xt_one_plus
.aeb9	20 d9 a1	jsr $a1d9	                jsr xt_swap ; (addr+2 u)
.aebc	20 3c 98	jsr $983c	                jsr xt_one_minus
.aebf	20 3c 98	jsr $983c	                jsr xt_one_minus ; (addr+2 u-2)
.aec2	60		rts		                rts
.aec3					disasm_jsr:
.aec3	ca		dex		                dex
.aec4	ca		dex		                dex
.aec5	a5 37		lda $37		                lda scratch+1
.aec7	95 00		sta $00,x	                sta 0,x
.aec9	a5 38		lda $38		                lda scratch+2
.aecb	95 01		sta $01,x	                sta 1,x
.aecd	20 a3 92	jsr $92a3	                jsr xt_int_to_name
.aed0	b5 00		lda $00,x	                lda 0,x
.aed2	15 01		ora $01,x	                ora 1,x
.aed4	f0 07		beq $aedd	                beq _disasm_no_nt
.aed6	20 29 96	jsr $9629	                jsr xt_name_to_string
.aed9	20 2e a5	jsr $a52e	                jsr xt_type
.aedc	60		rts		                rts
.aedd					_disasm_no_nt:
.aedd	20 59 8d	jsr $8d59	                jsr xt_drop ; the 0 indicating no name token
.aee0	ca		dex		                dex
.aee1	ca		dex		                dex
.aee2	a5 37		lda $37		                lda scratch+1
.aee4	95 00		sta $00,x	                sta 0,x
.aee6	a5 38		lda $38		                lda scratch+2
.aee8	95 01		sta $01,x	                sta 1,x
.aeea	ca		dex		                dex
.aeeb	ca		dex		                dex
.aeec	a9 5a		lda #$5a	                lda #<underflow_1
.aeee	95 00		sta $00,x	                sta 0,x
.aef0	a9 d8		lda #$d8	                lda #>underflow_1
.aef2	95 01		sta $01,x	                sta 1,x
.aef4	20 81 d7	jsr $d781	                jsr compare_16bit
.aef7	f0 02		beq $aefb	                beq _disasm_jsr_uflow_check_upper
.aef9	b0 14		bcs $af0f	                bcs _disasm_jsr_unknown
.aefb					_disasm_jsr_uflow_check_upper:
.aefb	a9 69		lda #$69	                lda #<underflow_4
.aefd	95 00		sta $00,x	                sta 0,x
.aeff	a9 d8		lda #$d8	                lda #>underflow_4
.af01	95 01		sta $01,x	                sta 1,x
.af03	20 81 d7	jsr $d781	                jsr compare_16bit
.af06	f0 02		beq $af0a	                beq _disasm_jsr_soc
.af08	90 05		bcc $af0f	                bcc _disasm_jsr_unknown
.af0a					_disasm_jsr_soc:
.af0a	a9 0e		lda #$0e	                lda #str_disasm_sdc
.af0c	20 86 d8	jsr $d886	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.af0f					_disasm_jsr_unknown:
.af0f	20 db a3	jsr $a3db	                jsr xt_two_drop
.af12	60		rts		                rts
.af13					oc_index_table:
>af13	13 b1 17 b1 ab b5 ab b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>af1b	1f b1 25 b1 2b b1 ab b5
>af23	31 b1 35 b1 3b b1 ab b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af2b	41 b1 45 b1 49 b1 4d b1
>af33	52 b1 56 b1 5e b1 ab b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af3b	65 b1 6b b1 72 b1 79 b1
>af43	80 b1 84 b1 8a b1 ab b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af4b	90 b1 94 b1 ab b5 9a b1
>af53	a0 b1 a4 b1 ab b5 ab b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af5b	ac b1 b2 b1 b8 b1 be b1
>af63	c5 b1 c9 b1 cf b1 ab b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af6b	d5 b1 d9 b1 de b1 e2 b1
>af73	e7 b1 eb b1 f3 b1 ab b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af7b	fa b1 02 b2 09 b2 10 b2
>af83	17 b2 1b b2 21 b2 ab b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af8b	27 b2 2d b2 33 b2 4d b1
>af93	3e b2 42 b2 ab b5 ab b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>af9b	ab b5 4a b2 50 b2 56 b2
>afa3	5d b2 61 b2 67 b2 ab b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>afab	6d b2 71 b2 75 b2 79 b2
>afb3	7e b2 82 b2 8a b2 ab b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>afbb	ab b5 91 b2 98 b2 9f b2
>afc3	a6 b2 aa b2 b0 b2 ab b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>afcb	ab b5 ab b5 ba b2 c0 b2
>afd3	c5 b2 c9 b2 ab b5 ab b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>afdb	d1 b2 d7 b2 dd b2 e3 b2
>afe3	ea b2 ee b2 f4 b2 ab b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>afeb	fa b2 00 b3 04 b3 08 b3
>aff3	0d b3 11 b3 19 b3 ab b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>affb	20 b3 27 b3 2e b3 35 b3
>b003	3c b3 40 b3 46 b3 ab b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>b00b	4a b3 51 b3 57 b3 5d b3
>b013	62 b3 66 b3 ab b5 ab b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b01b	6e b3 74 b3 7a b3 ab b5
>b023	80 b3 84 b3 8a b3 ab b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b02b	8e b3 92 b3 96 b3 9a b3
>b033	9f b3 a3 b3 ab b3 ab b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b03b	b2 b3 b9 b3 c0 b3 c7 b3
>b043	ce b3 d2 b3 d8 b3 ab b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b04b	dc b3 e0 b3 e6 b3 ec b3
>b053	f1 b3 f7 b3 ff b3 ab b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b05b	05 b4 0b b4 11 b4 17 b4
>b063	1e b4 22 b4 28 b4 ab b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b06b	2c b4 30 b4 34 b4 38 b4
>b073	3d b4 41 b4 49 b4 ab b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b07b	50 b4 57 b4 5e b4 65 b4
>b083	6c b4 70 b4 76 b4 ab b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b08b	7a b4 80 b4 86 b4 8c b4
>b093	91 b4 97 b4 ab b5 ab b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b09b	9f b4 a5 b4 ab b4 b1 b4
>b0a3	b8 b4 bc b4 c2 b4 ab b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b0ab	c6 b4 ca b4 ce b4 d2 b4
>b0b3	d7 b4 db b4 e3 b4 ab b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b0bb	ab b5 ea b4 f1 b4 f8 b4
>b0c3	ff b4 03 b5 09 b5 ab b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0cb	ab b5 0d b5 13 b5 19 b5
>b0d3	1e b5 24 b5 ab b5 ab b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b0db	2c b5 32 b5 38 b5 3e b5
>b0e3	45 b5 49 b5 4f b5 ab b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b0eb	53 b5 57 b5 5b b5 5f b5
>b0f3	64 b5 68 b5 70 b5 ab b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b0fb	ab b5 77 b5 7e b5 85 b5
>b103	8c b5 90 b5 96 b5 ab b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b10b	ab b5 9a b5 a0 b5 a6 b5
.b113					oc_table:
>b113	83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b117	87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b11f	85 74 73 62 2e 7a		        oc04:   .text 2*64+5, "tsb.z"
>b125	85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b12b	85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b131	43 70 68 70				oc08:	.text 1*64+3, "php"
>b135	85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b13b	45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b141	c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b145	c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b149	c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b14d	c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b152	83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b156	87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b15e	86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b165	85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b16b	86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b172	86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b179	86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b180	43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b184	c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b18a	45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b190	c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b194	c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b19a	c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b1a0	c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b1a4	87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b1ac	85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b1b2	85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b1b8	85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b1be	86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b1c5	43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b1c9	85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1cf	45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b1d5	c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b1d9	c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b1de	c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b1e2	c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1e7	83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b1eb	87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b1f3	86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b1fa	87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b202	86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b209	86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b210	86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b217	43 73 65 63				oc38:	.text 1*64+3, "sec"
>b21b	c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b221	45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b227	c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b22d	c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b233	c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b239	c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b23e	43 72 74 69				oc40:	.text 1*64+3, "rti"
>b242	87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b24a	85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b250	85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b256	86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b25d	43 70 68 61				oc48:	.text 1*64+3, "pha"
>b261	85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b267	45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b26d	c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b271	c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b275	c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b279	c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b27e	83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b282	87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b28a	86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b291	86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b298	86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b29f	86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b2a6	43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b2aa	c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b2b0	43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b2b4	c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b2ba	c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b2c0	c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b2c5	43 72 74 73				oc60:	.text 1*64+3, "rts"
>b2c9	87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b2d1	85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b2d7	85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b2dd	85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b2e3	86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b2ea	43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b2ee	85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b2f4	45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b2fa	c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b300	c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b304	c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b308	c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b30d	83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b311	87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b319	86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b320	86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b327	86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b32e	86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b335	86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b33c	43 73 65 69				oc78:	.text 1*64+3, "sei"
>b340	c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b346	43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b34a	c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b351	c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b357	c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b35d	c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b362	83 62 72 61				oc80:	.text 2*64+3, "bra"
>b366	87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b36e	85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b374	85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b37a	85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b380	43 64 65 79				oc88:	.text 1*64+3, "dey"
>b384	85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b38a	43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b38e	c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b392	c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b396	c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b39a	c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b39f	83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b3a3	87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b3ab	86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b3b2	86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b3b9	86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b3c0	86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b3c7	86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3ce	43 74 79 61				oc98:	.text 1*64+3, "tya"
>b3d2	c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b3d8	43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b3dc	c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b3e0	c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3e6	c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b3ec	c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b3f1	85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b3f7	87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b3ff	85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b405	85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b40b	85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b411	85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b417	86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b41e	43 74 61 79				oca8:	.text 1*64+3, "tay"
>b422	85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b428	43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b42c	c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b430	c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b434	c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b438	c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b43d	83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b441	87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b449	86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b450	86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b457	86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b45e	86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b465	86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b46c	43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b470	c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b476	43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b47a	c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b480	c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b486	c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b48c	c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b491	85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b497	87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b49f	85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b4a5	85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b4ab	85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b4b1	86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b4b8	43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b4bc	85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b4c2	43 64 65 78				occa:	.text 1*64+3, "dex"
>b4c6	c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b4ca	c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4ce	c3 64 65 63				occe:	.text 3*64+3, "dec"
>b4d2	c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b4d7	83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b4db	87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b4e3	86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b4ea	86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b4f1	86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b4f8	86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b4ff	43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b503	c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b509	43 70 68 78				ocda:	.text 1*64+3, "phx"
>b50d	c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b513	c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b519	c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b51e	85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b524	87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b52c	85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b532	85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b538	85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b53e	86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b545	43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b549	85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b54f	43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b553	c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b557	c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b55b	c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b55f	c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b564	83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b568	87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b570	86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b577	86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b57e	86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b585	86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b58c	43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b590	c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b596	43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b59a	c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b5a0	c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b5a6	c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b5ab	01 3f					oc__:	.text 1, "?"
.b5ad					disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=46					ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=48					ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=50					ed_flags = editor3  ; Flags used by ed, where
.b5ad					ed6502:
.b5ad	a5 18		lda $18		                lda base
.b5af	85 33		sta $33		                sta editor3+1
.b5b1	a9 0a		lda #$0a	                lda #10
.b5b3	85 18		sta $18		                sta base
.b5b5	64 2e		stz $2e		                stz ed_head
.b5b7	64 2f		stz $2f		                stz ed_head+1
.b5b9	64 30		stz $30		                stz ed_cur
.b5bb	64 31		stz $31		                stz ed_cur+1
.b5bd	64 32		stz $32		                stz ed_flags
.b5bf	20 d3 a7	jsr $a7d3	                jsr xt_zero
.b5c2	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; ( addr-t u-t )
.b5c5	20 8e 89	jsr $898e	                jsr xt_cr
.b5c8					ed_input_loop:
.b5c8	a9 81		lda #$81	                lda #%10000001
.b5ca	14 32		trb $32		                trb ed_flags
.b5cc	20 a7 ba	jsr $baa7	                jsr ed_get_input
.b5cf	a5 0a		lda $0a		                lda ciblen
.b5d1	d0 1f		bne $b5f2	                bne _command_mode
.b5d3	ca		dex		                dex
.b5d4	ca		dex		                dex                     ; ( addr-t u-t ? )
.b5d5	a5 30		lda $30		                lda ed_cur
.b5d7	95 00		sta $00,x	                sta 0,x
.b5d9	a5 31		lda $31		                lda ed_cur+1
.b5db	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b5dd	a9 80		lda #$80	                lda #%10000000
.b5df	04 32		tsb $32		                tsb ed_flags
.b5e1	20 48 98	jsr $9848	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b5e4	20 c3 ba	jsr $bac3	                jsr ed_is_valid_line
.b5e7	b0 03		bcs $b5ec	                bcs +
.b5e9	4c 97 ba	jmp $ba97	                jmp ed_error_1drop
.b5ec					+
.b5ec	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b5ef	4c bd b6	jmp $b6bd	                jmp _line_number_only_from_external
.b5f2					_command_mode:
.b5f2	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b5f5	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b5f8					_prefix_dot:
.b5f8	b2 08		lda ($08)	                lda (cib)
.b5fa	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b5fc	d0 3a		bne $b638	                bne _prefix_dollar
.b5fe	20 b8 ba	jsr $bab8	                jsr ed_have_text
.b601	a5 30		lda $30		                lda ed_cur
.b603	95 02		sta $02,x	                sta 2,x
.b605	a5 31		lda $31		                lda ed_cur+1
.b607	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b609	a9 80		lda #$80	                lda #%10000000
.b60b	04 32		tsb $32		                tsb ed_flags
.b60d	a5 0a		lda $0a		                lda ciblen
.b60f	3a		dec a		                dea                     ; sets Z if A was 1
.b610	d0 03		bne $b615	                bne +
.b612	4c bd b6	jmp $b6bd	                jmp _line_number_only_from_external
.b615					+
.b615	ca		dex		                dex
.b616	ca		dex		                dex
.b617	ca		dex		                dex
.b618	ca		dex		                dex
.b619	a5 08		lda $08		                lda cib
.b61b	95 02		sta $02,x	                sta 2,x
.b61d	a5 09		lda $09		                lda cib+1
.b61f	95 03		sta $03,x	                sta 3,x
.b621	a5 0a		lda $0a		                lda ciblen
.b623	95 00		sta $00,x	                sta 0,x
.b625	a5 0b		lda $0b		                lda ciblen+1
.b627	95 01		sta $01,x	                sta 1,x
.b629	20 3c 98	jsr $983c	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b62c	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b62f	20 48 98	jsr $9848	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b632	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b635	4c 15 b7	jmp $b715	                jmp _check_for_para2
.b638					_prefix_dollar:
.b638	b2 08		lda ($08)	                lda (cib)
.b63a	c9 24		cmp #$24	                cmp #'$'
.b63c	d0 1c		bne $b65a	                bne _prefix_percent
.b63e	20 b8 ba	jsr $bab8	                jsr ed_have_text
.b641	e8		inx		                inx
.b642	e8		inx		                inx                     ; ( addr-t u-t 0 )
.b643	20 e5 ba	jsr $bae5	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b646	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b649	a9 80		lda #$80	                lda #%10000000
.b64b	04 32		tsb $32		                tsb ed_flags
.b64d	a5 0a		lda $0a		                lda ciblen
.b64f	3a		dec a		                dea                     ; sets Z if A was 1
.b650	d0 03		bne $b655	                bne +
.b652	4c bd b6	jmp $b6bd	                jmp _line_number_only_from_external
.b655					+
.b655	a0 01		ldy #$01	                ldy #01
.b657	4c 91 b7	jmp $b791	                jmp _check_command
.b65a					_prefix_percent:
.b65a	b2 08		lda ($08)	                lda (cib)
.b65c	c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b65e	f0 04		beq $b664	                beq _whole_text
.b660	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b662	d0 17		bne $b67b	                bne _prefix_semicolon
.b664					_whole_text:
.b664	20 b8 ba	jsr $bab8	                jsr ed_have_text
.b667	a9 01		lda #$01	                lda #01
.b669	95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b66b	74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b66d					_semicolon_entry:
.b66d	e8		inx		                inx
.b66e	e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b66f	20 e5 ba	jsr $bae5	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b672	a9 80		lda #$80	                lda #%10000000
.b674	04 32		tsb $32		                tsb ed_flags
.b676	a0 01		ldy #$01	                ldy #01
.b678	4c 91 b7	jmp $b791	                jmp _check_command
.b67b					_prefix_semicolon:
.b67b	b2 08		lda ($08)	                lda (cib)
.b67d	c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b67f	d0 0d		bne $b68e	                bne _prefix_number
.b681	20 b8 ba	jsr $bab8	                jsr ed_have_text
.b684	a5 30		lda $30		                lda ed_cur
.b686	95 02		sta $02,x	                sta 2,x
.b688	a5 31		lda $31		                lda ed_cur+1
.b68a	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b68c	80 df		bra $b66d	                bra _semicolon_entry
.b68e					_prefix_number:
.b68e	20 d3 a7	jsr $a7d3	                jsr xt_zero
.b691	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b694	ca		dex		                dex
.b695	ca		dex		                dex
.b696	ca		dex		                dex
.b697	ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b698	a5 08		lda $08		                lda cib
.b69a	95 02		sta $02,x	                sta 2,x
.b69c	a5 09		lda $09		                lda cib+1
.b69e	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b6a0	a5 0a		lda $0a		                lda ciblen
.b6a2	95 00		sta $00,x	                sta 0,x
.b6a4	a5 0b		lda $0b		                lda ciblen+1
.b6a6	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b6a8	20 e8 a2	jsr $a2e8	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b6ab	b5 00		lda $00,x	                lda 0,x
.b6ad	15 01		ora $01,x	                ora 1,x
.b6af	d0 24		bne $b6d5	                bne _have_unconverted_chars
.b6b1	e8		inx		                inx
.b6b2	e8		inx		                inx
.b6b3	e8		inx		                inx
.b6b4	e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b6b5	20 ab 8a	jsr $8aab	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b6b8	20 99 96	jsr $9699	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b6bb	e8		inx		                inx
.b6bc	e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b6bd					_line_number_only_from_external:
.b6bd	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b6c0	20 c3 ba	jsr $bac3	                jsr ed_is_valid_line
.b6c3	b0 03		bcs $b6c8	                bcs +
.b6c5	4c 95 ba	jmp $ba95	                jmp ed_error_2drop
.b6c8					+
.b6c8	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6cb	20 52 bb	jsr $bb52	                jsr ed_para1_to_cur
.b6ce	a9 80		lda #$80	                lda #%10000000
.b6d0	04 32		tsb $32		                tsb ed_flags
.b6d2	4c 70 b9	jmp $b970	                jmp ed_cmd_p_from_external
.b6d5					_have_unconverted_chars:
.b6d5	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b6d8	ca		dex		                dex
.b6d9	ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b6da	a5 0a		lda $0a		                lda ciblen
.b6dc	95 00		sta $00,x	                sta 0,x
.b6de	a5 0b		lda $0b		                lda ciblen+1
.b6e0	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b6e2	20 f9 8e	jsr $8ef9	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b6e5	b5 00		lda $00,x	                lda 0,x
.b6e7	15 01		ora $01,x	                ora 1,x
.b6e9	f0 0e		beq $b6f9	                beq _no_command_yet
.b6eb	8a		txa		                txa
.b6ec	18		clc		                clc
.b6ed	69 0a		adc #$0a	                adc #10
.b6ef	aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b6f0	a9 80		lda #$80	                lda #%10000000
.b6f2	14 32		trb $32		                trb ed_flags
.b6f4	a0 00		ldy #$00	                ldy #00
.b6f6	4c 91 b7	jmp $b791	                jmp _check_command
.b6f9					_no_command_yet:
.b6f9	e8		inx		                inx
.b6fa	e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b6fb	20 9b a3	jsr $a39b	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b6fe	20 99 96	jsr $9699	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b701	20 ab 8a	jsr $8aab	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b704	b5 00		lda $00,x	                lda 0,x                 ; LSB
.b706	95 06		sta $06,x	                sta 6,x
.b708	b5 01		lda $01,x	                lda 1,x                 ; MSB
.b70a	95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b70c	e8		inx		                inx
.b70d	e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b70e	20 bd 9a	jsr $9abd	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b711	a9 80		lda #$80	                lda #%10000000
.b713	04 32		tsb $32		                tsb ed_flags
.b715					_check_for_para2:
.b715	a1 02		lda ($02,x)	                lda (2,x)
.b717	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b719	f0 0d		beq $b728	                beq _got_comma
.b71b	38		sec		                sec
.b71c	a5 0a		lda $0a		                lda ciblen
.b71e	f5 00		sbc $00,x	                sbc 0,x
.b720	a8		tay		                tay
.b721	e8		inx		                inx
.b722	e8		inx		                inx
.b723	e8		inx		                inx
.b724	e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b725	4c 91 b7	jmp $b791	                jmp _check_command
.b728					_got_comma:
.b728	f6 02		inc $02,x	                inc 2,x
.b72a	d0 02		bne $b72e	                bne +
.b72c	f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b72e					+
.b72e	b5 01		lda $01,x	                lda 1,x
.b730	f0 02		beq $b734	                beq +
.b732	d6 01		dec $01,x	                dec 1,x
.b734					+
.b734	d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b736	a1 02		lda ($02,x)	                lda (2,x)
.b738	c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b73a	d0 14		bne $b750	                bne _para2_not_dollar
.b73c	38		sec		                sec
.b73d	a5 0a		lda $0a		                lda ciblen
.b73f	f5 02		sbc $02,x	                sbc 2,x
.b741	a8		tay		                tay
.b742	c8		iny		                iny
.b743	5a		phy		                phy
.b744	8a		txa		                txa
.b745	18		clc		                clc
.b746	69 06		adc #$06	                adc #06
.b748	aa		tax		                tax                     ; ( addr-t u-t para1 )
.b749	20 e5 ba	jsr $bae5	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b74c	7a		ply		                ply
.b74d	4c 91 b7	jmp $b791	                jmp _check_command
.b750					_para2_not_dollar:
.b750	20 9b a3	jsr $a39b	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b753	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b756	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b759	20 82 9b	jsr $9b82	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b75c	20 bd 9a	jsr $9abd	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b75f	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b762	20 9b a3	jsr $a39b	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b765	20 e8 a2	jsr $a2e8	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b768	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b76b	20 bd 9a	jsr $9abd	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b76e	20 f9 8e	jsr $8ef9	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b771	b5 00		lda $00,x	                lda 0,x
.b773	15 01		ora $01,x	                ora 1,x
.b775	f0 08		beq $b77f	                beq _second_number
.b777	8a		txa		                txa
.b778	18		clc		                clc
.b779	69 0c		adc #$0c	                adc #12
.b77b	aa		tax		                tax                     ; back to ( addr-t u-t )
.b77c	4c 99 ba	jmp $ba99	                jmp ed_error
.b77f					_second_number:
.b77f	e8		inx		                inx
.b780	e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b781	38		sec		                sec
.b782	a5 0a		lda $0a		                lda ciblen
.b784	f5 00		sbc $00,x	                sbc 0,x
.b786	48		pha		                pha
.b787	20 db a3	jsr $a3db	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b78a	20 ab 8a	jsr $8aab	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b78d	20 6d 96	jsr $966d	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b790	7a		ply		                ply
.b791					_check_command:
.b791	24 32		bit $32		                bit ed_flags
.b793	30 08		bmi $b79d	                bmi _check_command_have_arg
.b795	a5 30		lda $30		                lda ed_cur
.b797	95 02		sta $02,x	                sta 2,x
.b799	a5 31		lda $31		                lda ed_cur+1
.b79b	95 03		sta $03,x	                sta 3,x
.b79d					_check_command_have_arg:
.b79d	b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b79f	85 24		sta $24		                sta tmp1
.b7a1	da		phx		                phx
.b7a2	a2 00		ldx #$00	                ldx #00
.b7a4					_cmd_loop:
.b7a4	bd 7d bb	lda $bb7d,x	                lda ed_cmd_list,x
.b7a7	f0 07		beq $b7b0	                beq _illegal_command    ; zero marks end of list
.b7a9	c5 24		cmp $24		                cmp tmp1
.b7ab	f0 07		beq $b7b4	                beq _found_cmd
.b7ad	e8		inx		                inx
.b7ae	80 f4		bra $b7a4	                bra _cmd_loop
.b7b0					_illegal_command:
.b7b0	fa		plx		                plx
.b7b1	4c 95 ba	jmp $ba95	                jmp ed_error_2drop
.b7b4					_found_cmd:
.b7b4	8a		txa		                txa
.b7b5	0a		asl a		                asl
.b7b6	aa		tax		                tax                     ; X * 2 for table
.b7b7	7c 88 bb	jmp ($bb88,x)	                jmp (ed_cmd_table,x)
.b7ba					ed_next_command:
.b7ba	e8		inx		                inx
.b7bb	e8		inx		                inx
.b7bc	e8		inx		                inx
.b7bd	e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b7be					_next_command_empty:
.b7be	4c c8 b5	jmp $b5c8	                jmp ed_input_loop
.b7c1					ed_all_done:
.b7c1	64 0a		stz $0a		                stz ciblen
.b7c3	64 0b		stz $0b		                stz ciblen+1
.b7c5	20 db a3	jsr $a3db	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b7c8	a5 33		lda $33		                lda editor3+1
.b7ca	85 18		sta $18		                sta base
.b7cc	60		rts		                rts
.b7cd					ed_cmd_a:
.b7cd	fa		plx		                plx
.b7ce	e8		inx		                inx
.b7cf	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7d0					ed_entry_cmd_i:
.b7d0					ed_cmd_a_have_para:
.b7d0	20 1b bb	jsr $bb1b	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b7d3	20 8e 89	jsr $898e	                jsr xt_cr
.b7d6					_next_string_loop:
.b7d6	20 a7 ba	jsr $baa7	                jsr ed_get_input
.b7d9	b2 08		lda ($08)	                lda (cib)
.b7db	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b7dd	d0 16		bne $b7f5	                bne _add_line
.b7df	a4 0a		ldy $0a		                ldy ciblen
.b7e1	c0 01		cpy #$01	                cpy #01
.b7e3	d0 10		bne $b7f5	                bne _add_line
.b7e5	a4 0b		ldy $0b		                ldy ciblen+1
.b7e7	d0 0c		bne $b7f5	                bne _add_line
.b7e9	e8		inx		                inx
.b7ea	e8		inx		                inx
.b7eb	a9 40		lda #$40	                lda #%01000000
.b7ed	04 32		tsb $32		                tsb ed_flags
.b7ef	20 8e 89	jsr $898e	                jsr xt_cr
.b7f2	4c c8 b5	jmp $b5c8	                jmp ed_input_loop
.b7f5					_add_line:
.b7f5	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b7f8	20 9d 91	jsr $919d	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b7fb	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b7fe	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b801	20 99 87	jsr $8799	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b804	20 b8 a3	jsr $a3b8	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b807	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b80a	20 b8 a1	jsr $a1b8	                jsr xt_store            ; ! ( addr-t u-t here )
.b80d	20 9d 91	jsr $919d	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b810	a5 00		lda $00		                lda cp
.b812	18		clc		                clc
.b813	69 04		adc #$04	                adc #04
.b815	85 00		sta $00		                sta cp
.b817	90 02		bcc $b81b	                bcc +
.b819	e6 01		inc $01		                inc cp+1
.b81b					+
.b81b	e6 30		inc $30		                inc ed_cur
.b81d	d0 02		bne $b821	                bne +
.b81f	e6 31		inc $31		                inc ed_cur+1
.b821					+
.b821	20 9d 91	jsr $919d	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b824	20 da 8d	jsr $8dda	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b827	ca		dex		                dex
.b828	ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b829	a5 08		lda $08		                lda cib
.b82b	95 00		sta $00,x	                sta 0,x
.b82d	a5 09		lda $09		                lda cib+1
.b82f	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b831	20 d9 a1	jsr $a1d9	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b834	ca		dex		                dex
.b835	ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b836	a5 0a		lda $0a		                lda ciblen
.b838	95 00		sta $00,x	                sta 0,x
.b83a	a5 0b		lda $0b		                lda ciblen+1
.b83c	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b83e	20 ed 95	jsr $95ed	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b841	18		clc		                clc
.b842	a5 00		lda $00		                lda cp
.b844	65 0a		adc $0a		                adc ciblen
.b846	85 00		sta $00		                sta cp
.b848	90 06		bcc $b850	                bcc +
.b84a	a5 01		lda $01		                lda cp+1
.b84c	65 0b		adc $0b		                adc ciblen+1
.b84e	85 01		sta $01		                sta cp+1
.b850					+
.b850	20 be 98	jsr $98be	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b853	20 b8 a1	jsr $a1b8	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b856	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+
.b859	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b85c	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b85f	a5 0a		lda $0a		                lda ciblen
.b861	95 02		sta $02,x	                sta 2,x
.b863	a5 0b		lda $0b		                lda ciblen+1
.b865	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b867	20 b8 a1	jsr $a1b8	                jsr xt_store            ; ! ( addr-t u-t here )
.b86a	20 8e 89	jsr $898e	                jsr xt_cr
.b86d	4c d6 b7	jmp $b7d6	                jmp _next_string_loop
.b870					ed_cmd_d:
.b870	fa		plx		                plx
.b871	20 b8 ba	jsr $bab8	                jsr ed_have_text
.b874	20 0d bb	jsr $bb0d	                jsr ed_no_line_zero
.b877	b5 00		lda $00,x	                lda 0,x
.b879	15 01		ora $01,x	                ora 1,x
.b87b	d0 08		bne $b885	                bne +
.b87d	20 be 98	jsr $98be	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b880	20 c2 b8	jsr $b8c2	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b883	80 33		bra $b8b8	                bra _cmd_d_done
.b885					+
.b885	20 c3 ba	jsr $bac3	                jsr ed_is_valid_line      ; result is in C flag
.b888	b0 03		bcs $b88d	                bcs _cmd_d_loop
.b88a	4c 95 ba	jmp $ba95	                jmp ed_error_2drop
.b88d					_cmd_d_loop:
.b88d	20 e3 a3	jsr $a3e3	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b890	20 88 91	jsr $9188	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b893	b5 00		lda $00,x	                lda 0,x
.b895	15 01		ora $01,x	                ora 1,x
.b897	d0 0d		bne $b8a6	                bne _cmd_d_done_with_flag
.b899	e8		inx		                inx
.b89a	e8		inx		                inx                     ; Get rid of the flag from >
.b89b	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b89e	20 c2 b8	jsr $b8c2	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b8a1	20 3c 98	jsr $983c	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b8a4	80 e7		bra $b88d	                bra _cmd_d_loop
.b8a6					_cmd_d_done_with_flag:
.b8a6	e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b8a7	e8		inx		                inx
.b8a8	b5 02		lda $02,x	                lda 2,x
.b8aa	d0 02		bne $b8ae	                bne +
.b8ac	d6 03		dec $03,x	                dec 3,x
.b8ae					+
.b8ae	d6 02		dec $02,x	                dec 2,x
.b8b0	b5 02		lda $02,x	                lda 2,x
.b8b2	85 30		sta $30		                sta ed_cur
.b8b4	b5 03		lda $03,x	                lda 3,x
.b8b6	85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b8b8					_cmd_d_done:
.b8b8	a9 40		lda #$40	                lda #%01000000
.b8ba	04 32		tsb $32		                tsb ed_flags
.b8bc	20 8e 89	jsr $898e	                jsr xt_cr
.b8bf	4c ba b7	jmp $b7ba	                jmp ed_next_command
.b8c2					_cmd_d_common:
.b8c2	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b8c5	20 1b bb	jsr $bb1b	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b8c8	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8cb	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8ce	20 3c 98	jsr $983c	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b8d1	20 1b bb	jsr $bb1b	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b8d4	20 b8 a1	jsr $a1b8	                jsr xt_store            ; ! ( addr-t u-t )
.b8d7	60		rts		                rts
.b8d8					ed_cmd_equ:
.b8d8	fa		plx		                plx
.b8d9	a5 2e		lda $2e		                lda ed_head
.b8db	05 2f		ora $2f		                ora ed_head+1
.b8dd	d0 08		bne $b8e7	                bne _cmd_equ_have_text
.b8df	ca		dex		                dex
.b8e0	ca		dex		                dex
.b8e1	74 00		stz $00,x	                stz 0,x
.b8e3	74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b8e5	80 21		bra $b908	                bra _cmd_equ_done
.b8e7					_cmd_equ_have_text:
.b8e7	20 0d bb	jsr $bb0d	                jsr ed_no_line_zero
.b8ea	24 32		bit $32		                bit ed_flags
.b8ec	30 0c		bmi $b8fa	                bmi _cmd_equ_have_para
.b8ee	ca		dex		                dex
.b8ef	ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b8f0	a5 30		lda $30		                lda ed_cur
.b8f2	95 00		sta $00,x	                sta 0,x
.b8f4	a5 31		lda $31		                lda ed_cur+1
.b8f6	95 01		sta $01,x	                sta 1,x
.b8f8	80 0e		bra $b908	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b8fa					_cmd_equ_have_para:
.b8fa	b5 00		lda $00,x	                lda 0,x
.b8fc	15 01		ora $01,x	                ora 1,x
.b8fe	d0 05		bne $b905	                bne _cmd_equ_two_paras
.b900	20 be 98	jsr $98be	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b903	80 03		bra $b908	                bra _cmd_equ_done
.b905					_cmd_equ_two_paras:
.b905	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b908					_cmd_equ_done:
.b908	20 8e 89	jsr $898e	                jsr xt_cr               ; number goes on new line
.b90b	20 59 a5	jsr $a559	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b90e	20 8e 89	jsr $898e	                jsr xt_cr
.b911	4c ba b7	jmp $b7ba	                jmp ed_next_command
.b914					ed_cmd_f:
.b914	fa		plx		                plx
.b915	24 32		bit $32		                bit ed_flags
.b917	30 17		bmi $b930	                bmi _cmd_f_have_para
.b919	20 8e 89	jsr $898e	                jsr xt_cr
.b91c	20 9b a3	jsr $a39b	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b91f	20 82 9b	jsr $9b82	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b922	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b925	20 59 a5	jsr $a559	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b928	20 99 96	jsr $9699	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b92b	20 bd 9a	jsr $9abd	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b92e	80 11		bra $b941	                bra _cmd_f_done
.b930					_cmd_f_have_para:
.b930	20 be 98	jsr $98be	                jsr xt_over
.b933	20 8e 89	jsr $898e	                jsr xt_cr
.b936	20 59 a5	jsr $a559	                jsr xt_u_dot
.b939	b5 02		lda $02,x	                lda 2,x
.b93b	95 06		sta $06,x	                sta 6,x
.b93d	b5 03		lda $03,x	                lda 3,x
.b93f	95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b941					_cmd_f_done:
.b941	20 8e 89	jsr $898e	                jsr xt_cr
.b944	4c ba b7	jmp $b7ba	                jmp ed_next_command
.b947					ed_cmd_i:
.b947	fa		plx		                plx
.b948	e8		inx		                inx
.b949	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b94a	24 32		bit $32		                bit ed_flags
.b94c	30 08		bmi $b956	                bmi _cmd_i_have_para
.b94e	a5 30		lda $30		                lda ed_cur
.b950	95 00		sta $00,x	                sta 0,x
.b952	a5 31		lda $31		                lda ed_cur+1
.b954	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b956					_cmd_i_have_para:
.b956	b5 00		lda $00,x	                lda 0,x
.b958	15 01		ora $01,x	                ora 1,x
.b95a	f0 09		beq $b965	                beq _cmd_i_done
.b95c	20 3c 98	jsr $983c	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b95f	20 d3 a7	jsr $a7d3	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b962	20 43 95	jsr $9543	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b965					_cmd_i_done:
.b965	4c d0 b7	jmp $b7d0	                jmp ed_entry_cmd_i
.b968					ed_cmd_n:
.b968	fa		plx		                plx
.b969	a9 01		lda #$01	                lda #%00000001
.b96b	04 32		tsb $32		                tsb ed_flags
.b96d	80 05		bra $b974	                bra ed_cmd_p_entry_for_cmd_n
.b96f					ed_cmd_p:
.b96f	fa		plx		                plx
.b970					ed_cmd_p_from_external:
.b970	a9 01		lda #$01	                lda #%00000001
.b972	14 32		trb $32		                trb ed_flags
.b974					ed_cmd_p_entry_for_cmd_n:
.b974	20 b8 ba	jsr $bab8	                jsr ed_have_text
.b977	20 0d bb	jsr $bb0d	                jsr ed_no_line_zero
.b97a	20 8e 89	jsr $898e	                jsr xt_cr
.b97d	b5 00		lda $00,x	                lda 0,x
.b97f	15 01		ora $01,x	                ora 1,x
.b981	d0 10		bne $b993	                bne _cmd_p_loop
.b983	b5 02		lda $02,x	                lda 2,x
.b985	85 30		sta $30		                sta ed_cur
.b987	b5 03		lda $03,x	                lda 3,x
.b989	85 31		sta $31		                sta ed_cur+1
.b98b	20 be 98	jsr $98be	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b98e	20 bc b9	jsr $b9bc	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b991	80 26		bra $b9b9	                bra _cmd_p_all_done
.b993					_cmd_p_loop:
.b993	20 e3 a3	jsr $a3e3	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b996	20 88 91	jsr $9188	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b999	b5 00		lda $00,x	                lda 0,x
.b99b	15 01		ora $01,x	                ora 1,x
.b99d	d0 10		bne $b9af	                bne _cmd_p_done
.b99f	e8		inx		                inx
.b9a0	e8		inx		                inx                     ; Get rid of the flag from >
.b9a1	20 be 98	jsr $98be	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b9a4	20 bc b9	jsr $b9bc	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b9a7	f6 02		inc $02,x	                inc 2,x
.b9a9	d0 02		bne $b9ad	                bne +
.b9ab	f6 03		inc $03,x	                inc 3,x
.b9ad					+
.b9ad	80 e4		bra $b993	                bra _cmd_p_loop
.b9af					_cmd_p_done:
.b9af	e8		inx		                inx
.b9b0	e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b9b1	b5 00		lda $00,x	                lda 0,x
.b9b3	85 30		sta $30		                sta ed_cur
.b9b5	b5 01		lda $01,x	                lda 1,x
.b9b7	85 31		sta $31		                sta ed_cur+1
.b9b9					_cmd_p_all_done:
.b9b9	4c ba b7	jmp $b7ba	                jmp ed_next_command
.b9bc					_cmd_p_common:
.b9bc	a5 32		lda $32		                lda ed_flags
.b9be	4a		lsr a		                lsr                     ; bit 0 now in carry
.b9bf	90 0b		bcc $b9cc	                bcc _cmd_p_common_no_num
.b9c1	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b9c4	20 59 a5	jsr $a559	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b9c7	a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b9c9	20 21 8e	jsr $8e21	                jsr emit_a
.b9cc					_cmd_p_common_no_num:
.b9cc	20 1b bb	jsr $bb1b	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9cf	20 5b bb	jsr $bb5b	                jsr ed_print_addr
.b9d2	60		rts		                rts
.b9d3					ed_cmd_q:
.b9d3	fa		plx		                plx
.b9d4	24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b9d6	50 03		bvc $b9db	                bvc +
.b9d8	4c 95 ba	jmp $ba95	                jmp ed_error_2drop
.b9db					+
.b9db	4c c1 b7	jmp $b7c1	                jmp ed_all_done            ; can't fall thru because of PLX
.b9de					ed_cmd_qq:
.b9de	fa		plx		                plx
.b9df	4c c1 b7	jmp $b7c1	                jmp ed_all_done
.b9e2					ed_cmd_w:
.b9e2	fa		plx		                plx
.b9e3	20 b8 ba	jsr $bab8	                jsr ed_have_text
.b9e6	24 32		bit $32		                bit ed_flags
.b9e8	30 13		bmi $b9fd	                bmi _cmd_w_have_para
.b9ea	b5 06		lda $06,x	                lda 6,x
.b9ec	15 07		ora $07,x	                ora 7,x
.b9ee	d0 03		bne $b9f3	                bne +
.b9f0	4c 95 ba	jmp $ba95	                jmp ed_error_2drop
.b9f3					+
.b9f3	b5 06		lda $06,x	                lda 6,x
.b9f5	95 02		sta $02,x	                sta 2,x
.b9f7	b5 07		lda $07,x	                lda 7,x
.b9f9	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b9fb	80 08		bra $ba05	                bra _cmd_w_para_ready
.b9fd					_cmd_w_have_para:
.b9fd	b5 02		lda $02,x	                lda 2,x
.b9ff	95 06		sta $06,x	                sta 6,x
.ba01	b5 03		lda $03,x	                lda 3,x
.ba03	95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.ba05					_cmd_w_para_ready:
.ba05	a9 2e		lda #$2e	                lda #<ed_head
.ba07	95 00		sta $00,x	                sta 0,x
.ba09	a9 00		lda #$00	                lda #>ed_head
.ba0b	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ba0d	20 be 98	jsr $98be	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ba10	20 9b a3	jsr $a39b	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ba13					_cmd_w_loop:
.ba13	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ba16	b5 00		lda $00,x	                lda 0,x
.ba18	15 01		ora $01,x	                ora 1,x
.ba1a	f0 55		beq $ba71	                beq _cmd_w_eol
.ba1c	20 e3 a3	jsr $a3e3	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ba1f	20 cd a4	jsr $a4cd	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ba22	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ba25	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ba28	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba2b	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba2e	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba31	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba34	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba37	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba3a	20 99 96	jsr $9699	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba3d	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba40	20 82 9b	jsr $9b82	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba43	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba46	20 9b a3	jsr $a39b	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba49	20 ed 95	jsr $95ed	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba4c	20 bd 9a	jsr $9abd	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba4f	20 53 a4	jsr $a453	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba52	20 99 96	jsr $9699	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba55	20 0e 9a	jsr $9a0e	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba58	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba5b	ca		dex		                dex
.ba5c	ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba5d	a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba5f	95 00		sta $00,x	                sta 0,x
.ba61	74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba63	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba66	20 b8 a1	jsr $a1b8	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba69	20 48 98	jsr $9848	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba6c	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba6f	80 a2		bra $ba13	                bra _cmd_w_loop
.ba71					_cmd_w_eol:
.ba71	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba74	20 bd 9a	jsr $9abd	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba77	20 7b 95	jsr $957b	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba7a	b5 00		lda $00,x	                lda 0,x
.ba7c	95 04		sta $04,x	                sta 4,x
.ba7e	b5 01		lda $01,x	                lda 1,x
.ba80	95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba82	20 8e 89	jsr $898e	                jsr xt_cr
.ba85	20 da 8d	jsr $8dda	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba88	20 59 a5	jsr $a559	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba8b	20 8e 89	jsr $898e	                jsr xt_cr
.ba8e	a9 40		lda #$40	                lda #%01000000
.ba90	14 32		trb $32		                trb ed_flags
.ba92	4c ba b7	jmp $b7ba	                jmp ed_next_command
.ba95					ed_error_2drop:
.ba95	e8		inx		                inx
.ba96	e8		inx		                inx                     ; drop through to _error_1drop
.ba97					ed_error_1drop:
.ba97	e8		inx		                inx
.ba98	e8		inx		                inx                     ; drop through to _error
.ba99					ed_error:
.ba99	20 8e 89	jsr $898e	                jsr xt_cr
.ba9c	a9 3f		lda #$3f	                lda #'?'
.ba9e	20 21 8e	jsr $8e21	                jsr emit_a
.baa1	20 8e 89	jsr $898e	                jsr xt_cr
.baa4	4c c8 b5	jmp $b5c8	                jmp ed_input_loop
.baa7					ed_get_input:
.baa7	20 23 9b	jsr $9b23	                jsr xt_refill           ;  ( addr-t u-t f )
.baaa	b5 00		lda $00,x	                lda 0,x
.baac	15 01		ora $01,x	                ora 1,x
.baae	d0 05		bne $bab5	                bne +
.bab0	7a		ply		                ply
.bab1	7a		ply		                ply
.bab2	4c 97 ba	jmp $ba97	                jmp ed_error_1drop
.bab5					+
.bab5	e8		inx		                inx
.bab6	e8		inx		                inx
.bab7	60		rts		                rts
.bab8					ed_have_text:
.bab8	a5 2e		lda $2e		                lda ed_head
.baba	05 2f		ora $2f		                ora ed_head+1
.babc	d0 04		bne $bac2	                bne +
.babe	7a		ply		                ply
.babf	7a		ply		                ply
.bac0	80 d7		bra $ba99	                bra ed_error
.bac2					+
.bac2	60		rts		                rts
.bac3					ed_is_valid_line:
.bac3	38		sec		                sec                             ; default is legal line number
.bac4	b5 00		lda $00,x	                lda 0,x
.bac6	15 01		ora $01,x	                ora 1,x
.bac8	f0 19		beq $bae3	                beq _is_valid_line_nope_zero    ; ( n )
.baca	20 da 8d	jsr $8dda	                jsr xt_dup                      ; DUP ( n n )
.bacd	20 e5 ba	jsr $bae5	                jsr ed_last_line                  ; ( n n last )
.bad0	20 d9 a1	jsr $a1d9	                jsr xt_swap                     ; SWAP ( n last n )
.bad3	20 93 93	jsr $9393	                jsr xt_less_than                ; < ( n f )
.bad6	b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.bad8	15 01		ora $01,x	                ora 1,x
.bada	d0 05		bne $bae1	                bne _is_valid_line_too_small
.badc	e8		inx		                inx
.badd	e8		inx		                inx                     ; DROP flag ( n )
.bade	38		sec		                sec                     ; Who knows what's happened to C by now
.badf	80 03		bra $bae4	                bra _is_valid_line_done ; only one exit from this routine
.bae1					_is_valid_line_too_small:
.bae1	e8		inx		                inx
.bae2	e8		inx		                inx                     ; drop through to _is_valid_line_zero
.bae3					_is_valid_line_nope_zero:
.bae3	18		clc		                clc                     ; drop through to _is_valid_line_done
.bae4					_is_valid_line_done:
.bae4	60		rts		                rts
.bae5					ed_last_line:
.bae5	64 24		stz $24		                stz tmp1
.bae7	64 25		stz $25		                stz tmp1+1
.bae9	ca		dex		                dex
.baea	ca		dex		                dex                     ; ( ? )
.baeb	a9 2e		lda #$2e	                lda #<ed_head
.baed	95 00		sta $00,x	                sta 0,x
.baef	a9 00		lda #$00	                lda #>ed_head
.baf1	95 01		sta $01,x	                sta 1,x                 ; ( addr )
.baf3					_last_line_loop:
.baf3	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; ( addr | 0 )
.baf6	b5 00		lda $00,x	                lda 0,x
.baf8	15 01		ora $01,x	                ora 1,x
.bafa	f0 08		beq $bb04	                beq _last_line_done
.bafc	e6 24		inc $24		                inc tmp1
.bafe	d0 02		bne $bb02	                bne +
.bb00	e6 25		inc $25		                inc tmp1+1
.bb02					+
.bb02	80 ef		bra $baf3	                bra _last_line_loop
.bb04					_last_line_done:
.bb04	a5 24		lda $24		                lda tmp1
.bb06	95 00		sta $00,x	                sta 0,x
.bb08	a5 25		lda $25		                lda tmp1+1
.bb0a	95 01		sta $01,x	                sta 1,x                 ; ( u )
.bb0c	60		rts		                rts
.bb0d					ed_no_line_zero:
.bb0d	b5 02		lda $02,x	                lda 2,x
.bb0f	15 03		ora $03,x	                ora 3,x
.bb11	d0 07		bne $bb1a	                bne _no_line_zero_done
.bb13	24 32		bit $32		                bit ed_flags
.bb15	10 03		bpl $bb1a	                bpl _no_line_zero_done
.bb17	4c 95 ba	jmp $ba95	                jmp ed_error_2drop
.bb1a					_no_line_zero_done:
.bb1a	60		rts		                rts
.bb1b					ed_num_to_addr:
.bb1b	ca		dex		                dex
.bb1c	ca		dex		                dex                     ; ( u ? )
.bb1d	a9 2e		lda #$2e	                lda #<ed_head
.bb1f	95 00		sta $00,x	                sta 0,x
.bb21	a9 00		lda #$00	                lda #>ed_head
.bb23	95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bb25	b5 02		lda $02,x	                lda 2,x
.bb27	15 03		ora $03,x	                ora 3,x
.bb29	d0 05		bne $bb30	                bne _num_to_addr_loop
.bb2b	20 6d 96	jsr $966d	                jsr xt_nip              ; ( addr-h )
.bb2e	80 21		bra $bb51	                bra _num_to_addr_done
.bb30					_num_to_addr_loop:
.bb30	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; @ ( u addr1 )
.bb33	b5 00		lda $00,x	                lda 0,x
.bb35	15 01		ora $01,x	                ora 1,x
.bb37	d0 05		bne $bb3e	                bne +
.bb39	20 6d 96	jsr $966d	                jsr xt_nip              ; NIP ( addr1 )
.bb3c	80 13		bra $bb51	                bra _num_to_addr_done
.bb3e					+
.bb3e	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( addr1 u )
.bb41	20 3c 98	jsr $983c	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb44	b5 00		lda $00,x	                lda 0,x
.bb46	15 01		ora $01,x	                ora 1,x
.bb48	f0 05		beq $bb4f	                beq _num_to_addr_finished
.bb4a	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb4d	80 e1		bra $bb30	                bra _num_to_addr_loop
.bb4f					_num_to_addr_finished:
.bb4f	e8		inx		                inx
.bb50	e8		inx		                inx                     ; ( addr )
.bb51					_num_to_addr_done:
.bb51	60		rts		                rts
.bb52					ed_para1_to_cur:
.bb52	b5 02		lda $02,x	                lda 2,x
.bb54	85 30		sta $30		                sta ed_cur
.bb56	b5 03		lda $03,x	                lda 3,x
.bb58	85 31		sta $31		                sta ed_cur+1
.bb5a	60		rts		                rts
.bb5b					ed_print_addr:
.bb5b	20 48 98	jsr $9848	                jsr xt_one_plus
.bb5e	20 48 98	jsr $9848	                jsr xt_one_plus         ; ( addr+2 )
.bb61	20 da 8d	jsr $8dda	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb64	20 48 98	jsr $9848	                jsr xt_one_plus
.bb67	20 48 98	jsr $9848	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb6a	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; ( addr+2 u-s )
.bb6d	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; ( u-s addr+2 )
.bb70	20 ab 8f	jsr $8fab	                jsr xt_fetch            ; ( u-s addr-s )
.bb73	20 d9 a1	jsr $a1d9	                jsr xt_swap             ; ( addr-s u-s )
.bb76	20 2e a5	jsr $a52e	                jsr xt_type
.bb79	20 8e 89	jsr $898e	                jsr xt_cr
.bb7c	60		rts		                rts
>bb7d	61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb85	71 51 00
.bb88					ed_cmd_table:
>bb88	cd b7 14 b9 47 b9 70 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bb90	6f b9 68 b9
>bb94	d8 b8 e2 b9 d3 b9 de b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bb9c					ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bb9c					forth_words_start:
>bb9c	20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bba4	61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bbb4	74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bbc4	20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bbd4	20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bbe4	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bbf4	2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bc04	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bc14	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bc24	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bc34	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc44	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc54	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc64	65 78 69 74 29 20 63 72 20
.bc6d					forth_words_end:
.bc6d					user_words_start:
>bc6d	20 20				.binary "user_words.asc"
.bc6f					user_words_end:

;******  Processing file: platform/../headers.asm

.bc6f					dictionary_start:
.bc6f					nt_drop:
>bc6f	04 10				        .byte 4, UF
>bc71	7b bc 59 8d 5e 8d		        .word nt_dup, xt_drop, z_drop
>bc77	64 72 6f 70			        .text "drop"
.bc7b					nt_dup:
>bc7b	03 10				        .byte 3, UF
>bc7d	86 bc da 8d e7 8d		        .word nt_swap, xt_dup, z_dup
>bc83	64 75 70			        .text "dup"
.bc86					nt_swap:
>bc86	04 10				        .byte 4, UF
>bc88	92 bc d9 a1 ec a1		        .word nt_store, xt_swap, z_swap
>bc8e	73 77 61 70			        .text "swap"
.bc92					nt_store:
>bc92	01 10				        .byte 1, UF
>bc94	9b bc b8 a1 cd a1		        .word nt_fetch, xt_store, z_store
>bc9a	21				        .text "!"
.bc9b					nt_fetch:
>bc9b	01 10				        .byte 1, UF
>bc9d	a4 bc ab 8f bd 8f		        .word nt_over, xt_fetch, z_fetch
>bca3	40				        .text "@"
.bca4					nt_over:
>bca4	04 10				        .byte 4, UF
>bca6	b0 bc be 98 cb 98		        .word nt_to_r, xt_over, z_over
>bcac	6f 76 65 72			        .text "over"
.bcb0					nt_to_r:
>bcb0	02 11				        .byte 2, CO+UF ; native is special case
>bcb2	ba bc 9b a3 ae a3		        .word nt_r_from, xt_to_r, z_to_r
>bcb8	3e 72				        .text ">r"
.bcba					nt_r_from:
>bcba	02 01				        .byte 2, CO    ; native is special case
>bcbc	c4 bc bd 9a cd 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bcc2	72 3e				        .text "r>"
.bcc4					nt_r_fetch:
>bcc4	02 01				        .byte 2, CO    ; native is special case
>bcc6	ce bc a8 9a bc 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bccc	72 40				        .text "r@"
.bcce					nt_nip:
>bcce	03 10				        .byte 3, UF
>bcd0	d9 bc 6d 96 7a 96		        .word nt_rot, xt_nip, z_nip
>bcd6	6e 69 70			        .text "nip"
.bcd9					nt_rot:
>bcd9	03 10				        .byte 3, UF
>bcdb	e4 bc 82 9b 9d 9b		        .word nt_not_rote, xt_rot, z_rot
>bce1	72 6f 74			        .text "rot"
.bce4					nt_not_rote:
>bce4	04 10				        .byte 4, UF
>bce6	f0 bc 99 96 b4 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bcec	2d 72 6f 74			        .text "-rot"
.bcf0					nt_tuck:
>bcf0	04 10				        .byte 4, UF
>bcf2	fc bc b8 a3 d1 a3		        .word nt_comma, xt_tuck, z_tuck
>bcf8	74 75 63 6b			        .text "tuck"
.bcfc					nt_comma:
>bcfc	01 10				        .byte 1, UF
>bcfe	05 bd 99 87 b2 87		        .word nt_c_fetch, xt_comma, z_comma
>bd04	2c				        .text ","
.bd05					nt_c_fetch:
>bd05	02 10				        .byte 2, UF
>bd07	0f bd 36 86 3f 86		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bd0d	63 40				        .text "c@"
.bd0f					nt_c_store:
>bd0f	02 10				        .byte 2, UF
>bd11	19 bd 40 86 4b 86		        .word nt_plus_store, xt_c_store, z_c_store
>bd17	63 21				        .text "c!"
.bd19					nt_plus_store:
>bd19	02 10				        .byte 2, UF
>bd1b	23 bd 21 9a 40 9a		        .word nt_execute, xt_plus_store, z_plus_store
>bd21	2b 21				        .text "+!"
.bd23					nt_execute:
>bd23	07 10				        .byte 7, UF
>bd25	32 bd 68 8f 6e 8f		        .word nt_emit, xt_execute, z_execute
>bd2b	65 78 65 63 75 74 65		        .text "execute"
.bd32					nt_emit:
>bd32	04 18				        .byte 4, NN+UF
>bd34	3e bd 1a 8e 24 8e		        .word nt_type, xt_emit, z_emit
>bd3a	65 6d 69 74			        .text "emit"
.bd3e					nt_type:
>bd3e	04 10				        .byte 4, UF
>bd40	4a bd 2e a5 58 a5		        .word nt_dot, xt_type, z_type
>bd46	74 79 70 65			        .text "type"
.bd4a					nt_dot:
>bd4a	01 10				        .byte 1, UF
>bd4c	53 bd 61 8c 82 8c		        .word nt_u_dot, xt_dot, z_dot
>bd52	2e				        .text "."
.bd53					nt_u_dot:
>bd53	02 10				        .byte 2, UF
>bd55	5d bd 59 a5 64 a5		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd5b	75 2e				        .text "u."
.bd5d					nt_u_dot_r:
>bd5d	03 10				        .byte 3, UF
>bd5f	68 bd 65 a5 86 a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd65	75 2e 72			        .text "u.r"
.bd68					nt_dot_r:
>bd68	02 10				        .byte 2, UF
>bd6a	72 bd 9d 8c ca 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd70	2e 72				        .text ".r"
.bd72					nt_d_dot:
>bd72	02 10				        .byte 2, UF
>bd74	7c bd 0f 8d 2d 8d		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd7a	64 2e				        .text "d."
.bd7c					nt_d_dot_r:
>bd7c	03 10				        .byte 3, UF
>bd7e	87 bd 2e 8d 58 8d		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd84	64 2e 72			        .text "d.r"
.bd87					nt_ud_dot:
>bd87	03 10				        .byte 3, UF
>bd89	92 bd b3 a5 c5 a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd8f	75 64 2e			        .text "ud."
.bd92					nt_ud_dot_r:
>bd92	04 10				        .byte 4, UF
>bd94	9e bd c6 a5 e4 a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd9a	75 64 2e 72			        .text "ud.r"
.bd9e					nt_question:
>bd9e	01 00				        .byte 1, 0
>bda0	a7 bd 8d 9a 93 9a		        .word nt_false, xt_question, z_question
>bda6	3f				        .text "?"
.bda7					nt_false:
>bda7	05 00				        .byte 5, 0
>bda9	b4 bd a4 8f aa 8f		        .word nt_true, xt_false, z_false
>bdaf	66 61 6c 73 65			        .text "false"
.bdb4					nt_true:
>bdb4	04 00				        .byte 4, 0
>bdb6	c0 bd af a3 b7 a3		        .word nt_space, xt_true, z_true
>bdbc	74 72 75 65			        .text "true"
.bdc0					nt_space:
>bdc0	05 00				        .byte 5, 0
>bdc2	cd bd 49 a1 4e a1		        .word nt_zero, xt_space, z_space
>bdc8	73 70 61 63 65			        .text "space"
.bdcd					nt_zero:
>bdcd	01 00				        .byte 1, 0
>bdcf	d6 bd d3 a7 d9 a7		        .word nt_one, xt_zero, z_zero
>bdd5	30				        .text "0"
.bdd6					nt_one:
>bdd6	01 00				        .byte 1, 0
>bdd8	df bd 33 98 3b 98		        .word nt_two, xt_one, z_one
>bdde	31				        .text "1"
.bddf					nt_two:
>bddf	01 00				        .byte 1, 0
>bde1	e8 bd d2 a3 da a3		        .word nt_two_dup, xt_two, z_two
>bde7	32				        .text "2"
.bde8					nt_two_dup:
>bde8	04 10				        .byte 4, UF
>bdea	f4 bd e3 a3 fa a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bdf0	32 64 75 70			        .text "2dup"
.bdf4					nt_question_dup:
>bdf4	04 10				        .byte 4, UF
>bdf6	00 be 94 9a a7 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bdfc	3f 64 75 70			        .text "?dup"
.be00					nt_plus:
>be00	01 10				        .byte 1, UF
>be02	09 be 0e 9a 20 9a		        .word nt_minus, xt_plus, z_plus
>be08	2b				        .text "+"
.be09					nt_minus:
>be09	01 10				        .byte 1, UF
>be0b	12 be 7b 95 8d 95		        .word nt_one_minus, xt_minus, z_minus
>be11	2d				        .text "-"
.be12					nt_one_minus:
>be12	02 10				        .byte 2, UF
>be14	1c be 3c 98 47 98		        .word nt_one_plus, xt_one_minus, z_one_minus
>be1a	31 2d				        .text "1-"
.be1c					nt_one_plus:
>be1c	02 10				        .byte 2, UF
>be1e	26 be 48 98 51 98		        .word nt_two_star, xt_one_plus, z_one_plus
>be24	31 2b				        .text "1+"
.be26					nt_two_star:
>be26	02 10				        .byte 2, UF
>be28	30 be 7b a4 82 a4		        .word nt_two_slash, xt_two_star, z_two_star
>be2e	32 2a				        .text "2*"
.be30					nt_two_slash:
>be30	02 10				        .byte 2, UF
>be32	3a be 70 a4 7a a4		        .word nt_abs, xt_two_slash, z_two_slash
>be38	32 2f				        .text "2/"
.be3a					nt_abs:
>be3a	03 10				        .byte 3, UF
>be3c	45 be 42 81 56 81		        .word nt_dabs, xt_abs, z_abs
>be42	61 62 73			        .text "abs"
.be45					nt_dabs:
>be45	04 10				        .byte 4, UF
>be47	51 be b1 8a cf 8a		        .word nt_and, xt_dabs, z_dabs
>be4d	64 61 62 73			        .text "dabs"
.be51					nt_and:
>be51	03 10				        .byte 3, UF
>be53	5c be 47 83 58 83		        .word nt_or, xt_and, z_and
>be59	61 6e 64			        .text "and"
.be5c					nt_or:
>be5c	02 10				        .byte 2, UF
>be5e	66 be 5e 98 6f 98		        .word nt_xor, xt_or, z_or
>be64	6f 72				        .text "or"
.be66					nt_xor:
>be66	03 10				        .byte 3, UF
>be68	71 be c1 a7 d2 a7		        .word nt_rshift, xt_xor, z_xor
>be6e	78 6f 72			        .text "xor"
.be71					nt_rshift:
>be71	06 10				        .byte 6, UF
>be73	7f be 9e 9b b1 9b		        .word nt_lshift, xt_rshift, z_rshift
>be79	72 73 68 69 66 74		        .text "rshift"
.be7f					nt_lshift:
>be7f	06 10				        .byte 6, UF
>be81	8d be a5 94 b8 94		        .word nt_pick, xt_lshift, z_lshift
>be87	6c 73 68 69 66 74		        .text "lshift"
.be8d					nt_pick:
>be8d	04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be8f	99 be fd 99 0d 9a		        .word nt_char, xt_pick, z_pick
>be95	70 69 63 6b			        .text "pick"
.be99					nt_char:
>be99	04 00				        .byte 4, 0
>be9b	a5 be 5c 86 72 86		        .word nt_bracket_char, xt_char, z_char
>bea1	63 68 61 72			        .text "char"
.bea5					nt_bracket_char:
>bea5	06 05				        .byte 6, CO+IM
>bea7	b3 be c2 85 c8 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bead	5b 63 68 61 72 5d		        .text "[char]"
.beb3					nt_char_plus:
>beb3	05 00				        .byte 5, 0
>beb5	c0 be 48 98 51 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bebb	63 68 61 72 2b			        .text "char+"
.bec0					nt_chars:
>bec0	05 12				        .byte 5, AN+UF   ; deleted during compile
>bec2	cd be 73 86 76 86		        .word nt_cells, xt_chars, z_chars
>bec8	63 68 61 72 73			        .text "chars"
.becd					nt_cells:
>becd	05 00				        .byte 5, 0
>becf	da be 7b a4 82 a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bed5	63 65 6c 6c 73			        .text "cells"
.beda					nt_cell_plus:
>beda	05 10				        .byte 5, UF
>bedc	e7 be 4c 86 5b 86		        .word nt_here, xt_cell_plus, z_cell_plus
>bee2	63 65 6c 6c 2b			        .text "cell+"
.bee7					nt_here:
>bee7	04 00				        .byte 4, 0
>bee9	f3 be 9d 91 a7 91		        .word nt_equal, xt_here, z_here
>beef	68 65 72 65			        .text "here"
.bef3					nt_equal:
>bef3	01 10				        .byte 1, UF
>bef5	fc be f9 8e 14 8f		        .word nt_not_equals, xt_equal, z_equal
>befb	3d				        .text "="
.befc					nt_not_equals:
>befc	02 10				        .byte 2, UF
>befe	06 bf 7b 96 98 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bf04	3c 3e				        .text "<>"
.bf06					nt_less_than:
>bf06	01 10				        .byte 1, UF
>bf08	0f bf 93 93 a7 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bf0e	3c				        .text "<"
.bf0f					nt_u_less_than:
>bf0f	02 10				        .byte 2, UF
>bf11	19 bf 9d a5 b2 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bf17	75 3c				        .text "u<"
.bf19					nt_u_greater_than:
>bf19	02 10				        .byte 2, UF
>bf1b	23 bf 87 a5 9c a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bf21	75 3e				        .text "u>"
.bf23					nt_greater_than:
>bf23	01 10				        .byte 1, UF
>bf25	2c bf 88 91 9c 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bf2b	3e				        .text ">"
.bf2c					nt_zero_equal:
>bf2c	02 10				        .byte 2, UF
>bf2e	36 bf da a7 ed a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bf34	30 3d				        .text "0="
.bf36					nt_zero_unequal:
>bf36	03 10				        .byte 3, UF
>bf38	41 bf 12 a8 23 a8		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bf3e	30 3c 3e			        .text "0<>"
.bf41					nt_zero_greater:
>bf41	02 10				        .byte 2, UF
>bf43	4b bf ee a7 01 a8		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bf49	30 3e				        .text "0>"
.bf4b					nt_zero_less:
>bf4b	02 10				        .byte 2, UF
>bf4d	55 bf 02 a8 11 a8		        .word nt_min, xt_zero_less, z_zero_less
>bf53	30 3c				        .text "0<"
.bf55					nt_min:
>bf55	03 10				        .byte 3, UF
>bf57	60 bf 5f 95 7a 95		        .word nt_max, xt_min, z_min
>bf5d	6d 69 6e			        .text "min"
.bf60					nt_max:
>bf60	03 10				        .byte 3, UF
>bf62	6b bf 43 95 5e 95		        .word nt_two_drop, xt_max, z_max
>bf68	6d 61 78			        .text "max"
.bf6b					nt_two_drop:
>bf6b	05 10				        .byte 5, UF
>bf6d	78 bf db a3 e2 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf73	32 64 72 6f 70			        .text "2drop"
.bf78					nt_two_swap:
>bf78	05 10				        .byte 5, UF
>bf7a	85 bf a9 a4 cc a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf80	32 73 77 61 70			        .text "2swap"
.bf85					nt_two_over:
>bf85	05 10				        .byte 5, UF
>bf87	92 bf 1d a4 34 a4		        .word nt_two_store, xt_two_over, z_two_over
>bf8d	32 6f 76 65 72			        .text "2over"
.bf92					nt_two_store:
>bf92	02 10				        .byte 2, UF
>bf94	9c bf 83 a4 a8 a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bf9a	32 21				        .text "2!"
.bf9c					nt_two_fetch:
>bf9c	02 10				        .byte 2, UF
>bf9e	a6 bf fb a3 1c a4		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bfa4	32 40				        .text "2@"
.bfa6					nt_two_variable:
>bfa6	09 00				        .byte 9, 0
>bfa8	b7 bf 1f a5 2d a5		        .word nt_two_constant, xt_two_variable, z_two_variable
>bfae	32 76 61 72 69 61 62 6c		        .text "2variable"
>bfb6	65
.bfb7					nt_two_constant:
>bfb7	09 10				        .byte 9, UF
>bfb9	c8 bf ed a4 11 a5		        .word nt_two_literal, xt_two_constant, z_two_constant
>bfbf	32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bfc7	74
.bfc8					nt_two_literal:
>bfc8	08 14				        .byte 8, UF+IM
>bfca	d8 bf 12 a5 1e a5		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bfd0	32 6c 69 74 65 72 61 6c		        .text "2literal"
.bfd8					nt_two_r_fetch:
>bfd8	03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bfda	e3 bf 35 a4 52 a4		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bfe0	32 72 40			        .text "2r@"
.bfe3					nt_two_r_from:
>bfe3	03 01				        .byte 3, CO             ; native is special case
>bfe5	ee bf 53 a4 6f a4		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bfeb	32 72 3e			        .text "2r>"
.bfee					nt_two_to_r:
>bfee	03 11				        .byte 3, CO+UF          ; native is special case
>bff0	f9 bf cd a4 ec a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>bff6	32 3e 72			        .text "2>r"
.bff9					nt_invert:
>bff9	06 10				        .byte 6, UF
>bffb	07 c0 16 93 25 93		        .word nt_negate, xt_invert, z_invert
>c001	69 6e 76 65 72 74		        .text "invert"
.c007					nt_negate:
>c007	06 10				        .byte 6, UF
>c009	15 c0 4e 96 5e 96		        .word nt_dnegate, xt_negate, z_negate
>c00f	6e 65 67 61 74 65		        .text "negate"
.c015					nt_dnegate:
>c015	07 10				        .byte 7, UF
>c017	24 c0 6c 8b 86 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>c01d	64 6e 65 67 61 74 65		        .text "dnegate"
.c024					nt_c_comma:
>c024	02 10				        .byte 2, UF
>c026	2e c0 2b 86 35 86		        .word nt_bounds, xt_c_comma, z_c_comma
>c02c	63 2c				        .text "c,"
.c02e					nt_bounds:
>c02e	06 10				        .byte 6, UF
>c030	3c c0 a9 85 c1 85		        .word nt_spaces, xt_bounds, z_bounds
>c036	62 6f 75 6e 64 73		        .text "bounds"
.c03c					nt_spaces:
>c03c	06 10				        .byte 6, UF
>c03e	4a c0 4f a1 8a a1		        .word nt_bl, xt_spaces, z_spaces
>c044	73 70 61 63 65 73		        .text "spaces"
.c04a					nt_bl:
>c04a	02 00				        .byte 2, 0
>c04c	54 c0 c5 83 cd 83		        .word nt_minus_trailing, xt_bl, z_bl
>c052	62 6c				        .text "bl"
.c054					nt_minus_trailing:
>c054	09 10				        .byte 9, UF
>c056	65 c0 a7 95 e3 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c05c	2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c064	67
.c065					nt_minus_leading:
>c065	08 10				        .byte 8, UF
>c067	75 c0 8e 95 a6 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c06d	2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c075					nt_slash_string:
>c075	07 10				        .byte 7, UF
>c077	84 c0 44 a0 63 a0		        .word nt_refill, xt_slash_string, z_slash_string
>c07d	2f 73 74 72 69 6e 67		        .text "/string"
.c084					nt_refill:
>c084	06 00				        .byte 6, 0
>c086	92 c0 23 9b 64 9b		        .word nt_accept, xt_refill, z_refill
>c08c	72 65 66 69 6c 6c		        .text "refill"
.c092					nt_accept:
>c092	06 18				        .byte 6, UF+NN
>c094	a0 c0 57 81 4f 82		        .word nt_input_to_r, xt_accept, z_accept
>c09a	61 63 63 65 70 74		        .text "accept"
.c0a0					nt_input_to_r:
>c0a0	07 08				        .byte 7, NN
>c0a2	af c0 8d 92 a2 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c0a8	69 6e 70 75 74 3e 72		        .text "input>r"
.c0af					nt_r_to_input:
>c0af	07 08				        .byte 7, NN
>c0b1	be c0 ce 9a e5 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c0b7	72 3e 69 6e 70 75 74		        .text "r>input"
.c0be					nt_unused:
>c0be	06 00				        .byte 6, 0
>c0c0	cc c0 7f a6 8e a6		        .word nt_depth, xt_unused, z_unused
>c0c6	75 6e 75 73 65 64		        .text "unused"
.c0cc					nt_depth:
>c0cc	05 00				        .byte 5, 0
>c0ce	d9 c0 21 8b 2f 8b		        .word nt_key, xt_depth, z_depth
>c0d4	64 65 70 74 68			        .text "depth"
.c0d9					nt_key:
>c0d9	03 00				        .byte 3, 0
>c0db	e4 c0 59 93 62 93		        .word nt_allot, xt_key, z_key
>c0e1	6b 65 79			        .text "key"
.c0e4					nt_allot:
>c0e4	05 10				        .byte 5, UF
>c0e6	f1 c0 b4 82 1c 83		        .word nt_create, xt_allot, z_allot
>c0ec	61 6c 6c 6f 74			        .text "allot"
.c0f1					nt_create:
>c0f1	06 00				        .byte 6, 0
>c0f3	ff c0 94 89 68 8a		        .word nt_does, xt_create, z_create
>c0f9	63 72 65 61 74 65		        .text "create"
.c0ff					nt_does:
>c0ff	05 05				        .byte 5, CO+IM
>c101	0c c1 20 8c 2e 8c		        .word nt_variable, xt_does, z_does
>c107	64 6f 65 73 3e			        .text "does>"
.c10c					nt_variable:
>c10c	08 00				        .byte 8, 0
>c10e	1c c1 a3 a6 bb a6		        .word nt_constant, xt_variable, z_variable
>c114	76 61 72 69 61 62 6c 65		        .text "variable"
.c11c					nt_constant:
>c11c	08 10				        .byte 8, UF
>c11e	2c c1 3c 89 79 89		        .word nt_value, xt_constant, z_constant
>c124	63 6f 6e 73 74 61 6e 74		        .text "constant"
.c12c					nt_value:
>c12c	05 10				        .byte 5, UF
>c12e	39 c1 3c 89 79 89		        .word nt_to, xt_constant, z_constant
>c134	76 61 6c 75 65			        .text "value"
.c139					nt_to:
>c139	02 0c				        .byte 2, NN+IM
>c13b	43 c1 5c a2 b7 a2		        .word nt_s_to_d, xt_to, z_to
>c141	74 6f				        .text "to"
.c143					nt_s_to_d:
>c143	03 10				        .byte 3, UF
>c145	4e c1 d7 9e e8 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c14b	73 3e 64			        .text "s>d"
.c14e					nt_d_to_s:
>c14e	03 10				        .byte 3, UF
>c150	59 c1 ab 8a b0 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c156	64 3e 73			        .text "d>s"
.c159					nt_d_minus:
>c159	02 10				        .byte 2, UF
>c15b	63 c1 69 8a 89 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c161	64 2d				        .text "d-"
.c163					nt_d_plus:
>c163	02 10				        .byte 2, UF
>c165	6d c1 8a 8a aa 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c16b	64 2b				        .text "d+"
.c16d					nt_erase:
>c16d	05 00				        .byte 5, 0      ; underflow checked by FILL
>c16f	7a c1 1f 8f 67 8f		        .word nt_blank, xt_erase, z_erase
>c175	65 72 61 73 65			        .text "erase"
.c17a					nt_blank:
>c17a	05 00				        .byte 5, 0     ; underflow checked by FILL
>c17c	87 c1 15 8f 67 8f		        .word nt_fill, xt_blank, z_blank
>c182	62 6c 61 6e 6b			        .text "blank"
.c187					nt_fill:
>c187	04 10				        .byte 4, UF
>c189	93 c1 25 8f 67 8f		        .word nt_find_name, xt_fill, z_fill
>c18f	66 69 6c 6c			        .text "fill"
.c193					nt_find_name:
>c193	09 10				        .byte 9, UF
>c195	a4 c1 06 90 b1 90		        .word nt_tick, xt_find_name, z_find_name
>c19b	66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c1a3	65
.c1a4					nt_tick:
>c1a4	01 00				        .byte 1, 0
>c1a6	ad c1 3c a2 5b a2		        .word nt_bracket_tick, xt_tick, z_tick
>c1ac	27				        .text "'"
.c1ad					nt_bracket_tick:
>c1ad	03 05				        .byte 3, CO+IM
>c1af	b8 c1 c9 85 cf 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c1b5	5b 27 5d			        .text "[']"
.c1b8					nt_name_to_int:
>c1b8	08 10				        .byte 8, UF
>c1ba	c8 c1 0c 96 28 96		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c1c0	6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c1c8					nt_int_to_name:
>c1c8	08 10				        .byte 8, UF
>c1ca	d8 c1 a3 92 15 93		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c1d0	69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c1d8					nt_name_to_string:
>c1d8	0b 10				        .byte 11, UF
>c1da	eb c1 29 96 42 96		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c1e0	6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1e8	69 6e 67
.c1eb					nt_to_body:
>c1eb	05 10				        .byte 5, UF
>c1ed	f8 c1 b8 a2 dc a2		        .word nt_defer, xt_to_body, z_to_body
>c1f3	3e 62 6f 64 79			        .text ">body"
.c1f8					nt_defer:
>c1f8	05 00				        .byte 5, 0
>c1fa	05 c2 d7 8a 09 8b		        .word nt_latestxt, xt_defer, z_defer
>c200	64 65 66 65 72			        .text "defer"
.c205					nt_latestxt:
>c205	08 00				        .byte 8, 0
>c207	15 c2 74 93 7a 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c20d	6c 61 74 65 73 74 78 74		        .text "latestxt"
.c215					nt_latestnt:
>c215	08 00				        .byte 8, 0
>c217	25 c2 66 93 73 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c21d	6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c225					nt_parse_name:
>c225	0a 08				        .byte 10, NN
>c227	37 c2 0a 99 fc 99		        .word nt_parse, xt_parse_name, z_parse_name
>c22d	70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c235	6d 65
.c237					nt_parse:
>c237	05 10				        .byte 5, UF
>c239	44 c2 65 99 fc 99		        .word nt_execute_parsing, xt_parse, z_parse
>c23f	70 61 72 73 65			        .text "parse"
.c244					nt_execute_parsing:
>c244	0f 10				        .byte 15, UF
>c246	5b c2 7c 8f a2 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c24c	65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c254	70 61 72 73 69 6e 67
.c25b					nt_source:
>c25b	06 00				        .byte 6, 0
>c25d	69 c2 29 a1 3d a1		        .word nt_source_id, xt_source, z_source
>c263	73 6f 75 72 63 65		        .text "source"
.c269					nt_source_id:
>c269	09 00				        .byte 9, 0
>c26b	7a c2 3e a1 48 a1		        .word nt_colon, xt_source_id, z_source_id
>c271	73 6f 75 72 63 65 2d 69		        .text "source-id"
>c279	64
.c27a					nt_colon:
>c27a	01 00				        .byte 1, 0
>c27c	83 c2 3a 87 7c 87		        .word nt_semicolon, xt_colon, z_colon
>c282	3a				        .text ":"
.c283					nt_semicolon:
>c283	01 05				        .byte 1, CO+IM
>c285	8c c2 b3 9f 11 a0		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c28b	3b				        .text ";"
.c28c					nt_colon_noname:
>c28c	07 00				        .byte 7, 0
>c28e	9b c2 7d 87 98 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c294	3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c29b					nt_compile_comma:
>c29b	08 18				        .byte 8, UF+NN
>c29d	ab c2 18 88 2f 89		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c2a3	63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c2ab					nt_left_bracket:
>c2ab	01 05				        .byte 1, IM+CO
>c2ad	b4 c2 80 93 84 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c2b3	5b				        .text "["
.c2b4					nt_right_bracket:
>c2b4	01 04				        .byte 1, IM
>c2b6	bd c2 72 9b 78 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c2bc	5d				        .text "]"
.c2bd					nt_literal:
>c2bd	07 15				        .byte 7, IM+CO+UF
>c2bf	cc c2 b5 93 c2 93		        .word nt_sliteral, xt_literal, z_literal
>c2c5	6c 69 74 65 72 61 6c		        .text "literal"
.c2cc					nt_sliteral:
>c2cc	08 15				        .byte 8, CO+IM+UF
>c2ce	dc c2 64 a0 d3 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c2d4	73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c2dc					nt_dot_quote:
>c2dc	02 05				        .byte 2, CO+IM
>c2de	e6 c2 92 8c 9c 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c2e4	2e 22				        .text ".", $22
.c2e6					nt_s_quote:
>c2e6	02 0c				        .byte 2, IM+NN
>c2e8	f0 c2 7a 9d d6 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c2ee	73 22				        .text "s", $22
.c2f0					nt_s_backslash_quote:
>c2f0	03 04				        .byte 3, IM
>c2f2	fb c2 b2 9b bb 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c2f8	73 5c 22			        .text "s", $5C, $22
.c2fb					nt_postpone:
>c2fb	08 05				        .byte 8, IM+CO
>c2fd	0b c3 41 9a 7f 9a		        .word nt_immediate, xt_postpone, z_postpone
>c303	70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c30b					nt_immediate:
>c30b	09 00				        .byte 9, 0
>c30d	1c c3 76 92 81 92		        .word nt_compile_only, xt_immediate, z_immediate
>c313	69 6d 6d 65 64 69 61 74		        .text "immediate"
>c31b	65
.c31c					nt_compile_only:
>c31c	0c 00				        .byte 12, 0
>c31e	30 c3 30 89 3b 89		        .word nt_never_native, xt_compile_only, z_compile_only
>c324	63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c32c	6f 6e 6c 79
.c330					nt_never_native:
>c330	0c 00				        .byte 12, 0
>c332	44 c3 5f 96 6c 96		        .word nt_always_native, xt_never_native, z_never_native
>c338	6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c340	74 69 76 65
.c344					nt_always_native:
>c344	0d 00				        .byte 13, 0
>c346	59 c3 39 83 46 83		        .word nt_allow_native, xt_always_native, z_always_native
>c34c	61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c354	61 74 69 76 65
.c359					nt_allow_native:
>c359	0c 00				        .byte 12, 0
>c35b	6d c3 1d 83 28 83		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c361	61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c369	74 69 76 65
.c36d					nt_nc_limit:
>c36d	08 00				        .byte 8, 0
>c36f	7d c3 43 96 4d 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c375	6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c37d					nt_strip_underflow:
>c37d	0f 00				        .byte 15, 0
>c37f	94 c3 ce a1 d8 a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c385	73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c38d	64 65 72 66 6c 6f 77
.c394					nt_abort:
>c394	05 00				        .byte 5, 0
>c396	a1 c3 81 80 ce 80		        .word nt_abort_quote, xt_abort, z_abort
>c39c	61 62 6f 72 74			        .text "abort"
.c3a1					nt_abort_quote:
>c3a1	06 0d				        .byte 6, CO+IM+NN
>c3a3	af c3 22 81 2c 81		        .word nt_do, xt_abort_quote, z_abort_quote
>c3a9	61 62 6f 72 74 22		        .text "abort", $22
.c3af					nt_do:
>c3af	02 0d				        .byte 2, CO+IM+NN
>c3b1	b9 c3 8d 8b e7 8b		        .word nt_question_do, xt_do, z_do
>c3b7	64 6f				        .text "do"
.c3b9					nt_question_do:
>c3b9	03 0d				        .byte 3, CO+IM+NN
>c3bb	c4 c3 87 8b e7 8b		        .word nt_i, xt_question_do, z_question_do
>c3c1	3f 64 6f			        .text "?do"
.c3c4					nt_i:
>c3c4	01 03				        .byte 1, AN+CO
>c3c6	cd c3 14 92 2d 92		        .word nt_j, xt_i, z_i
>c3cc	69				        .text "i"
.c3cd					nt_j:
>c3cd	01 03				        .byte 1, AN+CO
>c3cf	d6 c3 3f 93 58 93		        .word nt_loop, xt_j, z_j
>c3d5	6a				        .text "j"
.c3d6					nt_loop:
>c3d6	04 05				        .byte 4, CO+IM
>c3d8	e2 c3 26 94 93 94		        .word nt_plus_loop, xt_loop, z_loop
>c3de	6c 6f 6f 70			        .text "loop"
.c3e2					nt_plus_loop:
>c3e2	05 05				        .byte 5, CO+IM
>c3e4	ef c3 2d 94 93 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3ea	2b 6c 6f 6f 70			        .text "+loop"
.c3ef					nt_exit:
>c3ef	04 03				        .byte 4, AN+CO
>c3f1	fb c3 a3 8f a4 8f		        .word nt_unloop, xt_exit, z_exit
>c3f7	65 78 69 74			        .text "exit"
.c3fb					nt_unloop:
>c3fb	06 03				        .byte 6, AN+CO
>c3fd	09 c4 6d a6 73 a6		        .word nt_leave, xt_unloop, z_unloop
>c403	75 6e 6c 6f 6f 70		        .text "unloop"
.c409					nt_leave:
>c409	05 03				        .byte 5, AN+CO
>c40b	16 c4 7b 93 80 93		        .word nt_recurse, xt_leave, z_leave
>c411	6c 65 61 76 65			        .text "leave"
.c416					nt_recurse:
>c416	07 0d				        .byte 7, CO+IM+NN
>c418	25 c4 e6 9a 22 9b		        .word nt_quit, xt_recurse, z_recurse
>c41e	72 65 63 75 72 73 65		        .text "recurse"
.c425					nt_quit:
>c425	04 00				        .byte 4, 0
>c427	31 c4 83 80 ce 80		        .word nt_begin, xt_quit, z_quit
>c42d	71 75 69 74			        .text "quit"
.c431					nt_begin:
>c431	05 07				        .byte 5, AN+CO+IM
>c433	3e c4 bb 83 be 83		        .word nt_again, xt_begin, z_begin
>c439	62 65 67 69 6e			        .text "begin"
.c43e					nt_again:
>c43e	05 17				        .byte 5, AN+CO+IM+UF
>c440	4b c4 92 82 b2 82		        .word nt_state, xt_again, z_again
>c446	61 67 61 69 6e			        .text "again"
.c44b					nt_state:
>c44b	05 00				        .byte 5, 0
>c44d	58 c4 ad a1 b7 a1		        .word nt_evaluate, xt_state, z_state
>c453	73 74 61 74 65			        .text "state"
.c458					nt_evaluate:
>c458	08 10				        .byte 8, UF
>c45a	68 c4 00 91 53 91		        .word nt_base, xt_evaluate, z_evaluate
>c460	65 76 61 6c 75 61 74 65		        .text "evaluate"
.c468					nt_base:
>c468	04 00				        .byte 4, 0
>c46a	74 c4 b2 83 ba 83		        .word nt_digit_question, xt_base, z_base
>c470	62 61 73 65			        .text "base"
.c474					nt_digit_question:
>c474	06 10				        .byte 6, UF
>c476	82 c4 30 8b 64 8b		        .word nt_number, xt_digit_question, z_digit_question
>c47c	64 69 67 69 74 3f		        .text "digit?"
.c482					nt_number:
>c482	06 10				        .byte 6, UF
>c484	90 c4 b5 96 b1 97		        .word nt_to_number, xt_number, z_number
>c48a	6e 75 6d 62 65 72		        .text "number"
.c490					nt_to_number:
>c490	07 10				        .byte 7, UF
>c492	9f c4 e8 a2 87 a3		        .word nt_hex, xt_to_number, z_to_number
>c498	3e 6e 75 6d 62 65 72		        .text ">number"
.c49f					nt_hex:
>c49f	03 00				        .byte 3, 0
>c4a1	aa c4 a8 91 ae 91		        .word nt_decimal, xt_hex, z_hex
>c4a7	68 65 78			        .text "hex"
.c4aa					nt_decimal:
>c4aa	07 00				        .byte 7, 0
>c4ac	b9 c4 d0 8a d6 8a		        .word nt_count, xt_decimal, z_decimal
>c4b2	64 65 63 69 6d 61 6c		        .text "decimal"
.c4b9					nt_count:
>c4b9	05 10				        .byte 5, UF
>c4bb	c6 c4 7a 89 8d 89		        .word nt_m_star, xt_count, z_count
>c4c1	63 6f 75 6e 74			        .text "count"
.c4c6					nt_m_star:
>c4c6	02 10				        .byte 2, UF
>c4c8	d0 c4 b9 94 d3 94		        .word nt_um_star, xt_m_star, z_m_star
>c4ce	6d 2a				        .text "m*"
.c4d0					nt_um_star:
>c4d0	03 10				        .byte 3, UF
>c4d2	db c4 27 a6 6c a6		        .word nt_star, xt_um_star, z_um_star
>c4d8	75 6d 2a			        .text "um*"
.c4db					nt_star:
>c4db	01 10				        .byte 1, UF
>c4dd	e4 c4 8b a1 93 a1		        .word nt_um_slash_mod, xt_star, z_star
>c4e3	2a				        .text "*"
.c4e4					nt_um_slash_mod:
>c4e4	06 10				        .byte 6, UF
>c4e6	f2 c4 e5 a5 26 a6		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c4ec	75 6d 2f 6d 6f 64		        .text "um/mod"
.c4f2					nt_sm_slash_rem:
>c4f2	06 10				        .byte 6, UF
>c4f4	00 c5 00 a1 28 a1		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c4fa	73 6d 2f 72 65 6d		        .text "sm/rem"
.c500					nt_fm_slash_mod:
>c500	06 10				        .byte 6, UF
>c502	0e c5 bc 90 f2 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c508	66 6d 2f 6d 6f 64		        .text "fm/mod"
.c50e					nt_slash:
>c50e	01 10				        .byte 1, UF
>c510	17 c5 27 a0 43 a0		        .word nt_slash_mod, xt_slash, z_slash
>c516	2f				        .text "/"
.c517					nt_slash_mod:
>c517	04 10				        .byte 4, UF
>c519	23 c5 2c a0 43 a0		        .word nt_mod, xt_slash_mod, z_slash_mod
>c51f	2f 6d 6f 64			        .text "/mod"
.c523					nt_mod:
>c523	03 10				        .byte 3, UF
>c525	2e c5 e4 95 ec 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c52b	6d 6f 64			        .text "mod"
.c52e					nt_star_slash_mod:
>c52e	05 10				        .byte 5, UF
>c530	3b c5 9d a1 ac a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c536	2a 2f 6d 6f 64			        .text "*/mod"
.c53b					nt_star_slash:
>c53b	02 10				        .byte 2, UF
>c53d	45 c5 94 a1 9c a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c543	2a 2f				        .text "*/"
.c545					nt_backslash:
>c545	01 04				        .byte 1, IM
>c547	4e c5 87 83 b1 83		        .word nt_move, xt_backslash, z_backslash
>c54d	5c				        .byte $5c
.c54e					nt_move:
>c54e	04 18				        .byte 4, NN+UF
>c550	5a c5 ed 95 0b 96		        .word nt_cmove_up, xt_move, z_move
>c556	6d 6f 76 65			        .text "move"
.c55a					nt_cmove_up:
>c55a	06 10				        .byte 6, UF
>c55c	68 c5 ff 86 39 87		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c562	63 6d 6f 76 65 3e		        .text "cmove>"
.c568					nt_cmove:
>c568	05 10				        .byte 5, UF
>c56a	75 c5 c4 86 fe 86		        .word nt_pad, xt_cmove, z_cmove
>c570	63 6d 6f 76 65			        .text "cmove"
.c575					nt_pad:
>c575	03 00				        .byte 3, 0
>c577	80 c5 cc 98 db 98		        .word nt_cleave, xt_pad, z_pad
>c57d	70 61 64			        .text "pad"
.c580					nt_cleave:
>c580	06 10				        .byte 6, UF
>c582	8e c5 77 86 c3 86		        .word nt_hexstore, xt_cleave, z_cleave
>c588	63 6c 65 61 76 65		        .text "cleave"
.c58e					nt_hexstore:
>c58e	08 10				        .byte 8, UF
>c590	9e c5 af 91 01 92		        .word nt_within, xt_hexstore, z_hexstore
>c596	68 65 78 73 74 6f 72 65		        .text "hexstore"
.c59e					nt_within:
>c59e	06 10				        .byte 6, UF
>c5a0	ac c5 d0 a6 e5 a6		        .word nt_to_in, xt_within, z_within
>c5a6	77 69 74 68 69 6e		        .text "within"
.c5ac					nt_to_in:
>c5ac	03 00				        .byte 3, 0
>c5ae	b7 c5 dd a2 e7 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c5b4	3e 69 6e			        .text ">in"
.c5b7					nt_less_number_sign:
>c5b7	02 00				        .byte 2, 0
>c5b9	c1 c5 85 93 92 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c5bf	3c 23				        .text "<#"
.c5c1					nt_number_sign:
>c5c1	01 10				        .byte 1, UF
>c5c3	ca c5 b2 97 e6 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c5c9	23				        .text "#"
.c5ca					nt_number_sign_s:
>c5ca	02 10				        .byte 2, UF
>c5cc	d4 c5 09 98 19 98		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c5d2	23 73				        .text "#s"
.c5d4					nt_number_sign_greater:
>c5d4	02 10				        .byte 2, UF
>c5d6	de c5 e7 97 08 98		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c5dc	23 3e				        .text "#>"
.c5de					nt_hold:
>c5de	04 10				        .byte 4, UF
>c5e0	ea c5 02 92 13 92		        .word nt_sign, xt_hold, z_hold
>c5e6	68 6f 6c 64			        .text "hold"
.c5ea					nt_sign:
>c5ea	04 10				        .byte 4, UF
>c5ec	f6 c5 12 a0 26 a0		        .word nt_output, xt_sign, z_sign
>c5f2	73 69 67 6e			        .text "sign"
.c5f6					nt_output:
>c5f6	06 00				        .byte 6, 0
>c5f8	04 c6 b3 98 bd 98		        .word nt_input, xt_output, z_output
>c5fe	6f 75 74 70 75 74		        .text "output"
.c604					nt_input:
>c604	05 00				        .byte 5, 0
>c606	11 c6 82 92 8c 92		        .word nt_cr, xt_input, z_input
>c60c	69 6e 70 75 74			        .text "input"
.c611					nt_cr:
>c611	02 00				        .byte 2, 0
>c613	1b c6 8e 89 93 89		        .word nt_page, xt_cr, z_cr
>c619	63 72				        .text "cr"
.c61b					nt_page:
>c61b	04 00				        .byte 4, 0
>c61d	27 c6 dc 98 f9 98		        .word nt_at_xy, xt_page, z_page
>c623	70 61 67 65			        .text "page"
.c627					nt_at_xy:
>c627	05 10				        .byte 5, UF
>c629	34 c6 59 83 86 83		        .word nt_marker, xt_at_xy, z_at_xy
>c62f	61 74 2d 78 79			        .text "at-xy"
.c634					nt_marker:
>c634	06 04				        .byte 6, IM
>c636	42 c6 d4 94 11 95		        .word nt_words, xt_marker, z_marker
>c63c	6d 61 72 6b 65 72		        .text "marker"
.c642					nt_words:
>c642	05 00				        .byte 5, 0
>c644	4f c6 43 a7 9f a7		        .word nt_wordsize, xt_words, z_words
>c64a	77 6f 72 64 73			        .text "words"
.c64f					nt_wordsize:
>c64f	08 10				        .byte 8, UF
>c651	5f c6 a0 a7 c0 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c657	77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c65f					nt_aligned:
>c65f	07 00				        .byte 7, 0
>c661	6e c6 b3 82 b3 82		        .word nt_align, xt_align, z_align
>c667	61 6c 69 67 6e 65 64		        .text "aligned"
.c66e					nt_align:
>c66e	05 00				        .byte 5, 0
>c670	7b c6 b3 82 b3 82		        .word nt_bell, xt_align, z_align
>c676	61 6c 69 67 6e			        .text "align"
.c67b					nt_bell:
>c67b	04 00				        .byte 4, 0
>c67d	87 c6 bf 83 c4 83		        .word nt_dump, xt_bell, z_bell
>c683	62 65 6c 6c			        .text "bell"
.c687					nt_dump:
>c687	04 10				        .byte 4, UF
>c689	93 c6 5f 8d c5 8d		        .word nt_dot_s, xt_dump, z_dump
>c68f	64 75 6d 70			        .text "dump"
.c693					nt_dot_s:
>c693	02 00				        .byte 2, 0
>c695	9d c6 cb 8c 0e 8d		        .word nt_disasm, xt_dot_s, z_dot_s
>c69b	2e 73				        .text ".s"
.c69d					nt_disasm:
>c69d	06 10				        .byte 6, UF
>c69f	ab c6 65 8b 6b 8b		        .word nt_compare, xt_disasm, z_disasm
>c6a5	64 69 73 61 73 6d		        .text "disasm"
.c6ab					nt_compare:
>c6ab	07 10				        .byte 7, UF
>c6ad	ba c6 b3 87 17 88		        .word nt_search, xt_compare, z_compare
>c6b3	63 6f 6d 70 61 72 65		        .text "compare"
.c6ba					nt_search:
>c6ba	06 18				        .byte 6, UF+NN
>c6bc	c8 c6 14 9f b2 9f		        .word +, xt_search, z_search
>c6c2	73 65 61 72 63 68		        .text "search"
.c6c8					+
.c6c8					nt_environment_q:
>c6c8	0c 10				        .byte 12, UF
>c6ca	dc c6 40 8e bc 8e		        .word +, xt_environment_q, z_environment_q
>c6d0	65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c6d8	65 6e 74 3f
.c6dc					+
.c6dc					nt_find:
>c6dc	04 10				        .byte 4, UF
>c6de	e8 c6 be 8f 05 90		        .word nt_word, xt_find, z_find
>c6e4	66 69 6e 64			        .text "find"
.c6e8					nt_word:
>c6e8	04 10				        .byte 4, UF
>c6ea	f4 c6 e6 a6 2b a7		        .word nt_paren, xt_word, z_word
>c6f0	77 6f 72 64			        .text "word"
.c6f4					nt_paren:
>c6f4	01 04				        .byte 1, IM
>c6f6	fd c6 fa 98 09 99		        .word nt_dot_paren, xt_paren, z_paren
>c6fc	28				        .text "("
.c6fd					nt_dot_paren:
>c6fd	02 04				        .byte 2, IM
>c6ff	07 c7 83 8c 91 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c705	2e 28				        .text ".("
.c707					nt_if:
>c707	02 0d				        .byte 2, IM+CO+NN
>c709	11 c7 2e 92 3e 92		        .word nt_then, xt_if, z_if
>c70f	69 66				        .text "if"
.c711					nt_then:
>c711	04 0d				        .byte 4, IM+CO+NN
>c713	1d c7 ed a1 f6 a1		        .word nt_else, xt_then, z_then
>c719	74 68 65 6e			        .text "then"
.c71d					nt_else:
>c71d	04 0d				        .byte 4, IM+CO+NN
>c71f	29 c7 ec 8d 05 8e		        .word nt_repeat, xt_else, z_else
>c725	65 6c 73 65			        .text "else"
.c729					nt_repeat:
>c729	06 0d				        .byte 6, IM+CO+NN
>c72b	37 c7 65 9b 71 9b		        .word nt_until, xt_repeat, z_repeat
>c731	72 65 70 65 61 74		        .text "repeat"
.c737					nt_until:
>c737	05 0d				        .byte 5, IM+CO+NN
>c739	44 c7 74 a6 7e a6		        .word nt_while, xt_until, z_until
>c73f	75 6e 74 69 6c			        .text "until"
.c744					nt_while:
>c744	05 0d				        .byte 5, IM+CO+NN
>c746	51 c7 bc a6 cf a6		        .word nt_case, xt_while, z_while
>c74c	77 68 69 6c 65			        .text "while"
.c751					nt_case:
>c751	04 0d				        .byte 4, IM+CO+NN
>c753	5d c7 d3 a7 d9 a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c759	63 61 73 65			        .text "case"
.c75d					nt_of:
>c75d	02 0d				        .byte 2, IM+CO+NN
>c75f	67 c7 1a 98 32 98		        .word nt_endof, xt_of, z_of
>c765	6f 66				        .text "of"
.c767					nt_endof:
>c767	05 0d				        .byte 5, IM+CO+NN
>c769	74 c7 ec 8d 05 8e		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c76f	65 6e 64 6f 66			        .text "endof"
.c774					nt_endcase:
>c774	07 0d				        .byte 7, IM+CO+NN
>c776	83 c7 2b 8e 3f 8e		        .word nt_defer_fetch, xt_endcase, z_endcase
>c77c	65 6e 64 63 61 73 65		        .text "endcase"
.c783					nt_defer_fetch:
>c783	06 00				        .byte 6, 0
>c785	91 c7 0a 8b 10 8b		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c78b	64 65 66 65 72 40		        .text "defer@"
.c791					nt_defer_store:
>c791	06 00				        .byte 6, 0
>c793	9f c7 11 8b 17 8b		        .word nt_is, xt_defer_store, z_defer_store
>c799	64 65 66 65 72 21		        .text "defer!"
.c79f					nt_is:
>c79f	02 04				        .byte 2, IM
>c7a1	a9 c7 26 93 3e 93		        .word nt_action_of, xt_is, z_is
>c7a7	69 73				        .text "is"
.c7a9					nt_action_of:
>c7a9	09 04				        .byte 9, IM
>c7ab	ba c7 79 82 91 82		        .word nt_useraddr, xt_action_of, z_action_of
>c7b1	61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c7b9	66
.c7ba					nt_useraddr:
>c7ba	08 00				        .byte 8, 0
>c7bc	ca c7 98 a6 a2 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c7c2	75 73 65 72 61 64 64 72		        .text "useraddr"
.c7ca					nt_buffer_colon:
>c7ca	07 00				        .byte 7, 0
>c7cc	d9 c7 11 86 17 86		        .word +, xt_buffer_colon, z_buffer_colon
>c7d2	62 75 66 66 65 72 3a		        .text "buffer:"
.c7d9					+
.c7d9					nt_buffstatus:
>c7d9	0a 00				        .byte 10, 0
>c7db	eb c7 18 86 27 86		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7e1	62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7e9	75 73
.c7eb					nt_buffblocknum:
>c7eb	0c 00				        .byte 12, 0
>c7ed	ff c7 d0 85 df 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c7f3	62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c7fb	6b 6e 75 6d
.c7ff					nt_blkbuffer:
>c7ff	09 00				        .byte 9, 0
>c801	10 c8 de 83 eb 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c807	62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c80f	72
.c810					nt_scr:
>c810	03 00				        .byte 3, 0
>c812	1b c8 04 9f 13 9f		        .word nt_blk, xt_scr, z_scr
>c818	73 63 72			        .text "scr"
.c81b					nt_blk:
>c81b	03 00				        .byte 3, 0
>c81d	26 c8 ce 83 dd 83		        .word nt_block_write, xt_blk, z_blk
>c823	62 6c 6b			        .text "blk"
.c826					nt_block_write:
>c826	0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c828	39 c8 8b 85 99 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c82e	62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c836	69 74 65
.c839					nt_block_write_vector:
>c839	12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c83b	53 c8 99 85 a8 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c841	62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c849	69 74 65 2d 76 65 63 74 6f 72
.c853					nt_block_read:
>c853	0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c855	65 c8 68 85 76 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c85b	62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c863	61 64
.c865					nt_block_read_vector:
>c865	11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c867	7e c8 76 85 85 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c86d	62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c875	61 64 2d 76 65 63 74 6f 72
.c87e					nt_save_buffers:
>c87e	0c 00				        .byte 12, 0
>c880	92 c8 e9 9e 03 9f		        .word nt_block, xt_save_buffers, z_save_buffers
>c886	73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c88e	66 65 72 73
.c892					nt_block:
>c892	05 00				        .byte 5, 0
>c894	9f c8 ec 83 3e 84		        .word nt_update, xt_block, z_block
>c89a	62 6c 6f 63 6b			        .text "block"
.c89f					nt_update:
>c89f	06 00				        .byte 6, 0
>c8a1	ad c8 8f a6 97 a6		        .word nt_buffer, xt_update, z_update
>c8a7	75 70 64 61 74 65		        .text "update"
.c8ad					nt_buffer:
>c8ad	06 00				        .byte 6, 0
>c8af	bb c8 e0 85 10 86		        .word nt_empty_buffers, xt_buffer, z_buffer
>c8b5	62 75 66 66 65 72		        .text "buffer"
.c8bb					nt_empty_buffers:
>c8bb	0d 00				        .byte 13, 0
>c8bd	d0 c8 24 8e 2a 8e		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c8c3	65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c8cb	66 66 65 72 73
.c8d0					nt_flush:
>c8d0	05 00				        .byte 5, 0
>c8d2	dd c8 b2 90 bb 90		        .word nt_load, xt_flush, z_flush
>c8d8	66 6c 75 73 68			        .text "flush"
.c8dd					nt_load:
>c8dd	04 10				        .byte 4, UF
>c8df	e9 c8 e2 93 25 94		        .word nt_thru, xt_load, z_load
>c8e5	6c 6f 61 64			        .text "load"
.c8e9					nt_thru:
>c8e9	04 10				        .byte 4, UF
>c8eb	f5 c8 f7 a1 3b a2		        .word nt_list, xt_thru, z_thru
>c8f1	74 68 72 75			        .text "thru"
.c8f5					nt_list:
>c8f5	04 10				        .byte 4, UF
>c8f7	01 c9 a8 93 b4 93		        .word +, xt_list, z_list
>c8fd	6c 69 73 74			        .text "list"
.c901					+
.c901					nt_block_ramdrive_init:
>c901	13 10				        .byte 19, UF
>c903	1c c9 3f 84 67 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c909	62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c911	6d 64 72 69 76 65 2d 69 6e 69 74
.c91c					+
.c91c					nt_definitions:
>c91c	0b 00				        .byte 11, 0
>c91e	2f c9 18 8b 20 8b		        .word nt_wordlist, xt_definitions, z_definitions
>c924	64 65 66 69 6e 69 74 69		        .text "definitions"
>c92c	6f 6e 73
.c92f					nt_wordlist:
>c92f	08 00				        .byte 8, 0
>c931	3f c9 2c a7 42 a7		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c937	77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c93f					nt_search_wordlist:
>c93f	0f 10				        .byte 15, UF
>c941	56 c9 cb 9b ab 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c947	73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c94f	6f 72 64 6c 69 73 74
.c956					nt_set_current:
>c956	0b 10				        .byte 11, UF
>c958	69 c9 3a 9d 45 9d		        .word nt_get_current, xt_set_current, z_set_current
>c95e	73 65 74 2d 63 75 72 72		        .text "set-current"
>c966	65 6e 74
.c969					nt_get_current:
>c969	0b 00				        .byte 11, 0
>c96b	7c c9 54 91 5e 91		        .word nt_set_order, xt_get_current, z_get_current
>c971	67 65 74 2d 63 75 72 72		        .text "get-current"
>c979	65 6e 74
.c97c					nt_set_order:
>c97c	09 00				        .byte 9, 0
>c97e	8d c9 46 9d 79 9d		        .word nt_get_order, xt_set_order, z_set_order
>c984	73 65 74 2d 6f 72 64 65		        .text "set-order"
>c98c	72
.c98d					nt_get_order:
>c98d	09 00				        .byte 9, 0
>c98f	9e c9 5f 91 87 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c995	67 65 74 2d 6f 72 64 65		        .text "get-order"
>c99d	72
.c99e					nt_root_wordlist:
>c99e	0d 00				        .byte 13, 0
>c9a0	b3 c9 79 9b 81 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c9a6	72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c9ae	64 6c 69 73 74
.c9b3					+
.c9b3					nt_assembler_wordlist:
>c9b3	12 00				        .byte 18, 0
>c9b5	cd c9 d2 a3 da a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c9bb	61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c9c3	72 2d 77 6f 72 64 6c 69 73 74
.c9cd					+
.c9cd					nt_editor_wordlist:
>c9cd	0f 00				        .byte 15, 0
>c9cf	e4 c9 33 98 3b 98		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9d5	65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9dd	6f 72 64 6c 69 73 74
.c9e4					+
.c9e4					nt_forth_wordlist:
>c9e4	0e 00				        .byte 14, 0
>c9e6	fa c9 d3 a7 d9 a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c9ec	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9f4	72 64 6c 69 73 74
.c9fa					nt_only:
>c9fa	04 00				        .byte 4, 0
>c9fc	06 ca 52 98 5d 98		        .word nt_also, xt_only, z_only
>ca02	6f 6e 6c 79			        .text "only"
.ca06					nt_also:
>ca06	04 00				        .byte 4, 0
>ca08	12 ca 29 83 38 83		        .word nt_previous, xt_also, z_also
>ca0e	61 6c 73 6f			        .text "also"
.ca12					nt_previous:
>ca12	08 00				        .byte 8, 0
>ca14	22 ca 80 9a 8c 9a		        .word nt_to_order, xt_previous, z_previous
>ca1a	70 72 65 76 69 6f 75 73		        .text "previous"
.ca22					nt_to_order:
>ca22	06 00				        .byte 6, 0
>ca24	30 ca 88 a3 9a a3		        .word nt_order, xt_to_order, z_to_order
>ca2a	3e 6f 72 64 65 72		        .text ">order"
.ca30					nt_order:
>ca30	05 00				        .byte 5, 0
>ca32	3d ca 70 98 9a 98		        .word nt_forth, xt_order, z_order
>ca38	6f 72 64 65 72			        .text "order"
.ca3d					nt_forth:
>ca3d	05 00				        .byte 5, 0
>ca3f	4a ca f3 90 f9 90		        .word +, xt_forth, z_forth
>ca45	66 6f 72 74 68			        .text "forth"
.ca4a					+
>ca4a	03 08				nt_see: .byte 3, NN
>ca4c	55 ca ac 9c 39 9d		        .word +, xt_see, z_see
>ca52	73 65 65			        .text "see"
.ca55					+
.ca55					nt_ed:
>ca55	02 08				        .byte 2, NN
>ca57	5f ca e8 8d eb 8d		        .word +, xt_ed, z_ed
>ca5d	65 64				        .text "ed"
.ca5f					+
.ca5f					nt_cold:
>ca5f	04 00				        .byte 4, 0
>ca61	6b ca 00 80 ce 80		        .word nt_bye, xt_cold, z_cold
>ca67	63 6f 6c 64			        .text "cold"
.ca6b					nt_bye:
>ca6b	03				        .byte 3         ; length of word strings
>ca6c	00				        .byte 0         ; status byte
>ca6d	00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca6f	28 86				        .word xt_bye    ; start of code block (xt of this word)
>ca71	2b 86				        .word z_bye     ; end of code (RTS)
>ca73	62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca76					root_dictionary_start:
.ca76					nt_root_set_order:
>ca76	09 00				        .byte 9, 0
>ca78	87 ca 46 9d 79 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca7e	73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca86	72
.ca87					nt_root_forth:
>ca87	05 00				        .byte 5, 0
>ca89	94 ca f3 90 f9 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca8f	66 6f 72 74 68			        .text "forth"
.ca94					nt_root_forth_wordlist:
>ca94	0e 00				        .byte 14, 0
>ca96	aa ca d3 a7 d9 a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca9c	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>caa4	72 64 6c 69 73 74
.caaa					nt_root_words:
>caaa	05 00				        .byte 5, 0
>caac	00 00 43 a7 9f a7		        .word 0000, xt_words, z_words
>cab2	77 6f 72 64 73			        .text "words"
.cab7					editor_dictionary_start:
.cab7					nt_editor_o:
>cab7	01 00				        .byte 1, 0
>cab9	c0 ca 06 a9 4b a9		        .word nt_editor_line, xt_editor_o, z_editor_o
>cabf	6f				        .text "o"
.cac0					nt_editor_line:
>cac0	04 10				        .byte 4, UF
>cac2	cc ca ed a8 05 a9		        .word nt_editor_l, xt_editor_line, z_editor_line
>cac8	6c 69 6e 65			        .text "line"
.cacc					nt_editor_l:
>cacc	01 00				        .byte 1, 0
>cace	d5 ca 71 a8 ec a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>cad4	6c				        .text "l"
.cad5					nt_editor_el:
>cad5	02 00				        .byte 2, 0
>cad7	df ca 5f a8 70 a8		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cadd	65 6c				        .text "el"
.cadf					nt_editor_erase_screen:
>cadf	0c 00				        .byte 12, 0
>cae1	f3 ca 4d a8 5e a8		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cae7	65 72 61 73 65 2d 73 63		        .text "erase-screen"
>caef	72 65 65 6e
.caf3					nt_editor_enter_screen:
>caf3	0c 00				        .byte 12, 0
>caf5	00 00 31 a8 4c a8		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cafb	65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cb03	72 65 65 6e
.cb07					assembler_dictionary_start:
.cb07					nt_asm_adc_h:
>cb07	05 0c						.byte 5, IM+NN
>cb09	14 cb				                .word nt_asm_adc_x
>cb0b	4c a9 51 a9					.word xt_asm_adc_h, z_asm_adc_h
>cb0f	61 64 63 2e 23					.text "adc.#"
.cb14					nt_asm_adc_x:
>cb14	05 0c						.byte 5, IM+NN
>cb16	21 cb				                .word nt_asm_adc_y
>cb18	51 a9 56 a9					.word xt_asm_adc_x, z_asm_adc_x
>cb1c	61 64 63 2e 78					.text "adc.x"
.cb21					nt_asm_adc_y:
>cb21	05 0c						.byte 5, IM+NN
>cb23	2e cb				                .word nt_asm_adc_z
>cb25	56 a9 5b a9					.word xt_asm_adc_y, z_asm_adc_y
>cb29	61 64 63 2e 79					.text "adc.y"
.cb2e					nt_asm_adc_z:
>cb2e	05 0c						.byte 5, IM+NN
>cb30	3b cb				                .word nt_asm_adc_zi
>cb32	5b a9 60 a9					.word xt_asm_adc_z, z_asm_adc_z
>cb36	61 64 63 2e 7a					.text "adc.z"
.cb3b					nt_asm_adc_zi:
>cb3b	06 0c						.byte 6, IM+NN
>cb3d	49 cb				                .word nt_asm_adc_ziy
>cb3f	60 a9 65 a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cb43	61 64 63 2e 7a 69				.text "adc.zi"
.cb49					nt_asm_adc_ziy:
>cb49	07 0c						.byte 7, IM+NN
>cb4b	58 cb				                .word nt_asm_adc_zx
>cb4d	65 a9 6a a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb51	61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb58					nt_asm_adc_zx:
>cb58	06 0c						.byte 6, IM+NN
>cb5a	66 cb				                .word nt_asm_adc_zxi
>cb5c	6a a9 6f a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cb60	61 64 63 2e 7a 78				.text "adc.zx"
.cb66					nt_asm_adc_zxi:
>cb66	07 0c						.byte 7, IM+NN
>cb68	75 cb				                .word nt_asm_and
>cb6a	6f a9 74 a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb6e	61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb75					nt_asm_and:
>cb75	04 0c						.byte 4, IM+NN
>cb77	81 cb				                .word nt_asm_and_h
>cb79	74 a9 79 a9					.word xt_asm_and, z_asm_and
>cb7d	61 6e 64 2e					.text "and."
.cb81					nt_asm_and_h:
>cb81	05 0c						.byte 5, IM+NN
>cb83	8e cb				                .word nt_asm_and_x
>cb85	79 a9 7e a9					.word xt_asm_and_h, z_asm_and_h
>cb89	61 6e 64 2e 23					.text "and.#"
.cb8e					nt_asm_and_x:
>cb8e	05 0c						.byte 5, IM+NN
>cb90	9b cb				                .word nt_asm_and_y
>cb92	7e a9 83 a9					.word xt_asm_and_x, z_asm_and_x
>cb96	61 6e 64 2e 78					.text "and.x"
.cb9b					nt_asm_and_y:
>cb9b	05 0c						.byte 5, IM+NN
>cb9d	a8 cb				                .word nt_asm_and_z
>cb9f	83 a9 88 a9					.word xt_asm_and_y, z_asm_and_y
>cba3	61 6e 64 2e 79					.text "and.y"
.cba8					nt_asm_and_z:
>cba8	05 0c						.byte 5, IM+NN
>cbaa	b5 cb				                .word nt_asm_and_zi
>cbac	88 a9 8d a9					.word xt_asm_and_z, z_asm_and_z
>cbb0	61 6e 64 2e 7a					.text "and.z"
.cbb5					nt_asm_and_zi:
>cbb5	06 0c						.byte 6, IM+NN
>cbb7	c3 cb				                .word nt_asm_and_ziy
>cbb9	8d a9 92 a9					.word xt_asm_and_zi, z_asm_and_zi
>cbbd	61 6e 64 2e 7a 69				.text "and.zi"
.cbc3					nt_asm_and_ziy:
>cbc3	07 0c						.byte 7, IM+NN
>cbc5	d2 cb				                .word nt_asm_and_zx
>cbc7	92 a9 97 a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cbcb	61 6e 64 2e 7a 69 79				.text "and.ziy"
.cbd2					nt_asm_and_zx:
>cbd2	06 0c						.byte 6, IM+NN
>cbd4	e0 cb				                .word nt_asm_and_zxi
>cbd6	97 a9 9c a9					.word xt_asm_and_zx, z_asm_and_zx
>cbda	61 6e 64 2e 7a 78				.text "and.zx"
.cbe0					nt_asm_and_zxi:
>cbe0	07 0c						.byte 7, IM+NN
>cbe2	ef cb				                .word nt_asm_asl
>cbe4	9c a9 a1 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cbe8	61 6e 64 2e 7a 78 69				.text "and.zxi"
.cbef					nt_asm_asl:
>cbef	03 0c						.byte 3, IM+NN
>cbf1	fa cb				                .word nt_asm_asl_a
>cbf3	a1 a9 a6 a9					.word xt_asm_asl, z_asm_asl
>cbf7	61 73 6c					.text "asl"
.cbfa					nt_asm_asl_a:
>cbfa	05 0c						.byte 5, IM+NN
>cbfc	07 cc				                .word nt_asm_asl_x
>cbfe	a6 a9 ab a9					.word xt_asm_asl_a, z_asm_asl_a
>cc02	61 73 6c 2e 61					.text "asl.a"
.cc07					nt_asm_asl_x:
>cc07	05 0c						.byte 5, IM+NN
>cc09	14 cc				                .word nt_asm_asl_z
>cc0b	ab a9 b0 a9					.word xt_asm_asl_x, z_asm_asl_x
>cc0f	61 73 6c 2e 78					.text "asl.x"
.cc14					nt_asm_asl_z:
>cc14	05 0c						.byte 5, IM+NN
>cc16	21 cc				                .word nt_asm_asl_zx
>cc18	b0 a9 b5 a9					.word xt_asm_asl_z, z_asm_asl_z
>cc1c	61 73 6c 2e 7a					.text "asl.z"
.cc21					nt_asm_asl_zx:
>cc21	06 0c						.byte 6, IM+NN
>cc23	2f cc				                .word nt_asm_bcc
>cc25	b5 a9 ba a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cc29	61 73 6c 2e 7a 78				.text "asl.zx"
.cc2f					nt_asm_bcc:
>cc2f	03 0c						.byte 3, IM+NN
>cc31	3a cc				                .word nt_asm_bcs
>cc33	ba a9 bf a9					.word xt_asm_bcc, z_asm_bcc
>cc37	62 63 63					.text "bcc"
.cc3a					nt_asm_bcs:
>cc3a	03 0c						.byte 3, IM+NN
>cc3c	45 cc				                .word nt_asm_beq
>cc3e	bf a9 c6 a9					.word xt_asm_bcs, z_asm_bcs
>cc42	62 63 73					.text "bcs"
.cc45					nt_asm_beq:
>cc45	03 0c						.byte 3, IM+NN
>cc47	50 cc				                .word nt_asm_bit
>cc49	c6 a9 cb a9					.word xt_asm_beq, z_asm_beq
>cc4d	62 65 71					.text "beq"
.cc50					nt_asm_bit:
>cc50	03 0c						.byte 3, IM+NN
>cc52	5b cc				                .word nt_asm_bit_h
>cc54	cb a9 d0 a9					.word xt_asm_bit, z_asm_bit
>cc58	62 69 74					.text "bit"
.cc5b					nt_asm_bit_h:
>cc5b	05 0c						.byte 5, IM+NN
>cc5d	68 cc				                .word nt_asm_bit_x
>cc5f	d0 a9 d5 a9					.word xt_asm_bit_h, z_asm_bit_h
>cc63	62 69 74 2e 23					.text "bit.#"
.cc68					nt_asm_bit_x:
>cc68	05 0c						.byte 5, IM+NN
>cc6a	75 cc				                .word nt_asm_bit_z
>cc6c	d5 a9 da a9					.word xt_asm_bit_x, z_asm_bit_x
>cc70	62 69 74 2e 78					.text "bit.x"
.cc75					nt_asm_bit_z:
>cc75	05 0c						.byte 5, IM+NN
>cc77	82 cc				                .word nt_asm_bit_zx
>cc79	da a9 df a9					.word xt_asm_bit_z, z_asm_bit_z
>cc7d	62 69 74 2e 7a					.text "bit.z"
.cc82					nt_asm_bit_zx:
>cc82	06 0c						.byte 6, IM+NN
>cc84	90 cc				                .word nt_asm_bmi
>cc86	df a9 e4 a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cc8a	62 69 74 2e 7a 78				.text "bit.zx"
.cc90					nt_asm_bmi:
>cc90	03 0c						.byte 3, IM+NN
>cc92	9b cc				                .word nt_asm_bne
>cc94	e4 a9 e9 a9					.word xt_asm_bmi, z_asm_bmi
>cc98	62 6d 69					.text "bmi"
.cc9b					nt_asm_bne:
>cc9b	03 0c						.byte 3, IM+NN
>cc9d	a6 cc				                .word nt_asm_bpl
>cc9f	e9 a9 ee a9					.word xt_asm_bne, z_asm_bne
>cca3	62 6e 65					.text "bne"
.cca6					nt_asm_bpl:
>cca6	03 0c						.byte 3, IM+NN
>cca8	b1 cc				                .word nt_asm_bra
>ccaa	ee a9 f3 a9					.word xt_asm_bpl, z_asm_bpl
>ccae	62 70 6c					.text "bpl"
.ccb1					nt_asm_bra:
>ccb1	03 0c						.byte 3, IM+NN
>ccb3	bc cc				                .word nt_asm_brk
>ccb5	f3 a9 f8 a9					.word xt_asm_bra, z_asm_bra
>ccb9	62 72 61					.text "bra"
.ccbc					nt_asm_brk:
>ccbc	03 0c						.byte 3, IM+NN
>ccbe	c7 cc				                .word nt_asm_bvc
>ccc0	f8 a9 fd a9					.word xt_asm_brk, z_asm_brk
>ccc4	62 72 6b					.text "brk"
.ccc7					nt_asm_bvc:
>ccc7	03 0c						.byte 3, IM+NN
>ccc9	d2 cc				                .word nt_asm_bvs
>cccb	fd a9 02 aa					.word xt_asm_bvc, z_asm_bvc
>cccf	62 76 63					.text "bvc"
.ccd2					nt_asm_bvs:
>ccd2	03 0c						.byte 3, IM+NN
>ccd4	dd cc				                .word nt_asm_clc
>ccd6	02 aa 07 aa					.word xt_asm_bvs, z_asm_bvs
>ccda	62 76 73					.text "bvs"
.ccdd					nt_asm_clc:
>ccdd	03 0c						.byte 3, IM+NN
>ccdf	e8 cc				                .word nt_asm_cld
>cce1	07 aa 0c aa					.word xt_asm_clc, z_asm_clc
>cce5	63 6c 63					.text "clc"
.cce8					nt_asm_cld:
>cce8	03 0c						.byte 3, IM+NN
>ccea	f3 cc				                .word nt_asm_cli
>ccec	0c aa 11 aa					.word xt_asm_cld, z_asm_cld
>ccf0	63 6c 64					.text "cld"
.ccf3					nt_asm_cli:
>ccf3	03 0c						.byte 3, IM+NN
>ccf5	fe cc				                .word nt_asm_clv
>ccf7	11 aa 16 aa					.word xt_asm_cli, z_asm_cli
>ccfb	63 6c 69					.text "cli"
.ccfe					nt_asm_clv:
>ccfe	03 0c						.byte 3, IM+NN
>cd00	09 cd				                .word nt_asm_cmp
>cd02	16 aa 1b aa					.word xt_asm_clv, z_asm_clv
>cd06	63 6c 76					.text "clv"
.cd09					nt_asm_cmp:
>cd09	03 0c						.byte 3, IM+NN
>cd0b	14 cd				                .word nt_asm_cmp_h
>cd0d	1b aa 20 aa					.word xt_asm_cmp, z_asm_cmp
>cd11	63 6d 70					.text "cmp"
.cd14					nt_asm_cmp_h:
>cd14	05 0c						.byte 5, IM+NN
>cd16	21 cd				                .word nt_asm_cmp_x
>cd18	20 aa 25 aa					.word xt_asm_cmp_h, z_asm_cmp_h
>cd1c	63 6d 70 2e 23					.text "cmp.#"
.cd21					nt_asm_cmp_x:
>cd21	05 0c						.byte 5, IM+NN
>cd23	2e cd				                .word nt_asm_cmp_y
>cd25	25 aa 2a aa					.word xt_asm_cmp_x, z_asm_cmp_x
>cd29	63 6d 70 2e 78					.text "cmp.x"
.cd2e					nt_asm_cmp_y:
>cd2e	05 0c						.byte 5, IM+NN
>cd30	3b cd				                .word nt_asm_cmp_z
>cd32	2a aa 2f aa					.word xt_asm_cmp_y, z_asm_cmp_y
>cd36	63 6d 70 2e 79					.text "cmp.y"
.cd3b					nt_asm_cmp_z:
>cd3b	05 0c						.byte 5, IM+NN
>cd3d	48 cd				                .word nt_asm_cmp_zi
>cd3f	2f aa 34 aa					.word xt_asm_cmp_z, z_asm_cmp_z
>cd43	63 6d 70 2e 7a					.text "cmp.z"
.cd48					nt_asm_cmp_zi:
>cd48	06 0c						.byte 6, IM+NN
>cd4a	56 cd				                .word nt_asm_cmp_ziy
>cd4c	34 aa 39 aa					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd50	63 6d 70 2e 7a 69				.text "cmp.zi"
.cd56					nt_asm_cmp_ziy:
>cd56	07 0c						.byte 7, IM+NN
>cd58	65 cd				                .word nt_asm_cmp_zx
>cd5a	39 aa 3e aa					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd5e	63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd65					nt_asm_cmp_zx:
>cd65	06 0c						.byte 6, IM+NN
>cd67	73 cd				                .word nt_asm_cmp_zxi
>cd69	3e aa 43 aa					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd6d	63 6d 70 2e 7a 78				.text "cmp.zx"
.cd73					nt_asm_cmp_zxi:
>cd73	07 0c						.byte 7, IM+NN
>cd75	82 cd				                .word nt_asm_cpx
>cd77	43 aa 48 aa					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd7b	63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd82					nt_asm_cpx:
>cd82	03 0c						.byte 3, IM+NN
>cd84	8d cd				                .word nt_asm_cpx_h
>cd86	48 aa 4d aa					.word xt_asm_cpx, z_asm_cpx
>cd8a	63 70 78					.text "cpx"
.cd8d					nt_asm_cpx_h:
>cd8d	05 0c						.byte 5, IM+NN
>cd8f	9a cd				                .word nt_asm_cpx_z
>cd91	4d aa 52 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>cd95	63 70 78 2e 23					.text "cpx.#"
.cd9a					nt_asm_cpx_z:
>cd9a	05 0c						.byte 5, IM+NN
>cd9c	a7 cd				                .word nt_asm_cpy
>cd9e	52 aa 57 aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cda2	63 70 78 2e 7a					.text "cpx.z"
.cda7					nt_asm_cpy:
>cda7	03 0c						.byte 3, IM+NN
>cda9	b2 cd				                .word nt_asm_cpy_h
>cdab	57 aa 5e aa					.word xt_asm_cpy, z_asm_cpy
>cdaf	63 70 79					.text "cpy"
.cdb2					nt_asm_cpy_h:
>cdb2	05 0c						.byte 5, IM+NN
>cdb4	bf cd				                .word nt_asm_cpy_z
>cdb6	5e aa 63 aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cdba	63 70 79 2e 23					.text "cpy.#"
.cdbf					nt_asm_cpy_z:
>cdbf	05 0c						.byte 5, IM+NN
>cdc1	cc cd				                .word nt_asm_dec
>cdc3	63 aa 68 aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cdc7	63 70 79 2e 7a					.text "cpy.z"
.cdcc					nt_asm_dec:
>cdcc	03 0c						.byte 3, IM+NN
>cdce	d7 cd				                .word nt_asm_dec_a
>cdd0	68 aa 6d aa					.word xt_asm_dec, z_asm_dec
>cdd4	64 65 63					.text "dec"
.cdd7					nt_asm_dec_a:
>cdd7	05 0c						.byte 5, IM+NN
>cdd9	e4 cd				                .word nt_asm_dec_x
>cddb	6d aa 72 aa					.word xt_asm_dec_a, z_asm_dec_a
>cddf	64 65 63 2e 61					.text "dec.a"
.cde4					nt_asm_dec_x:
>cde4	05 0c						.byte 5, IM+NN
>cde6	f1 cd				                .word nt_asm_dec_z
>cde8	72 aa 77 aa					.word xt_asm_dec_x, z_asm_dec_x
>cdec	64 65 63 2e 78					.text "dec.x"
.cdf1					nt_asm_dec_z:
>cdf1	05 0c						.byte 5, IM+NN
>cdf3	fe cd				                .word nt_asm_dec_zx
>cdf5	77 aa 7c aa					.word xt_asm_dec_z, z_asm_dec_z
>cdf9	64 65 63 2e 7a					.text "dec.z"
.cdfe					nt_asm_dec_zx:
>cdfe	06 0c						.byte 6, IM+NN
>ce00	0c ce				                .word nt_asm_dex
>ce02	7c aa 81 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>ce06	64 65 63 2e 7a 78				.text "dec.zx"
.ce0c					nt_asm_dex:
>ce0c	03 0c						.byte 3, IM+NN
>ce0e	17 ce				                .word nt_asm_dey
>ce10	81 aa 86 aa					.word xt_asm_dex, z_asm_dex
>ce14	64 65 78					.text "dex"
.ce17					nt_asm_dey:
>ce17	03 0c						.byte 3, IM+NN
>ce19	22 ce				                .word nt_asm_eor
>ce1b	86 aa 8b aa					.word xt_asm_dey, z_asm_dey
>ce1f	64 65 79					.text "dey"
.ce22					nt_asm_eor:
>ce22	03 0c						.byte 3, IM+NN
>ce24	2d ce				                .word nt_asm_eor_h
>ce26	8b aa 90 aa					.word xt_asm_eor, z_asm_eor
>ce2a	65 6f 72					.text "eor"
.ce2d					nt_asm_eor_h:
>ce2d	05 0c						.byte 5, IM+NN
>ce2f	3a ce				                .word nt_asm_eor_x
>ce31	90 aa 95 aa					.word xt_asm_eor_h, z_asm_eor_h
>ce35	65 6f 72 2e 23					.text "eor.#"
.ce3a					nt_asm_eor_x:
>ce3a	05 0c						.byte 5, IM+NN
>ce3c	47 ce				                .word nt_asm_eor_y
>ce3e	95 aa 9a aa					.word xt_asm_eor_x, z_asm_eor_x
>ce42	65 6f 72 2e 78					.text "eor.x"
.ce47					nt_asm_eor_y:
>ce47	05 0c						.byte 5, IM+NN
>ce49	54 ce				                .word nt_asm_eor_z
>ce4b	9a aa 9f aa					.word xt_asm_eor_y, z_asm_eor_y
>ce4f	65 6f 72 2e 79					.text "eor.y"
.ce54					nt_asm_eor_z:
>ce54	05 0c						.byte 5, IM+NN
>ce56	61 ce				                .word nt_asm_eor_zi
>ce58	9f aa a4 aa					.word xt_asm_eor_z, z_asm_eor_z
>ce5c	65 6f 72 2e 7a					.text "eor.z"
.ce61					nt_asm_eor_zi:
>ce61	06 0c						.byte 6, IM+NN
>ce63	6f ce				                .word nt_asm_eor_ziy
>ce65	a4 aa a9 aa					.word xt_asm_eor_zi, z_asm_eor_zi
>ce69	65 6f 72 2e 7a 69				.text "eor.zi"
.ce6f					nt_asm_eor_ziy:
>ce6f	07 0c						.byte 7, IM+NN
>ce71	7e ce				                .word nt_asm_eor_zx
>ce73	a9 aa ae aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce77	65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce7e					nt_asm_eor_zx:
>ce7e	06 0c						.byte 6, IM+NN
>ce80	8c ce				                .word nt_asm_eor_zxi
>ce82	ae aa b3 aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce86	65 6f 72 2e 7a 78				.text "eor.zx"
.ce8c					nt_asm_eor_zxi:
>ce8c	07 0c						.byte 7, IM+NN
>ce8e	9b ce				                .word nt_asm_inc
>ce90	b3 aa b8 aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce94	65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce9b					nt_asm_inc:
>ce9b	03 0c						.byte 3, IM+NN
>ce9d	a6 ce				                .word nt_asm_inc_a
>ce9f	b8 aa bd aa					.word xt_asm_inc, z_asm_inc
>cea3	69 6e 63					.text "inc"
.cea6					nt_asm_inc_a:
>cea6	05 0c						.byte 5, IM+NN
>cea8	b3 ce				                .word nt_asm_inc_x
>ceaa	bd aa c2 aa					.word xt_asm_inc_a, z_asm_inc_a
>ceae	69 6e 63 2e 61					.text "inc.a"
.ceb3					nt_asm_inc_x:
>ceb3	05 0c						.byte 5, IM+NN
>ceb5	c0 ce				                .word nt_asm_inc_z
>ceb7	c2 aa c7 aa					.word xt_asm_inc_x, z_asm_inc_x
>cebb	69 6e 63 2e 78					.text "inc.x"
.cec0					nt_asm_inc_z:
>cec0	05 0c						.byte 5, IM+NN
>cec2	cd ce				                .word nt_asm_inc_zx
>cec4	c7 aa cc aa					.word xt_asm_inc_z, z_asm_inc_z
>cec8	69 6e 63 2e 7a					.text "inc.z"
.cecd					nt_asm_inc_zx:
>cecd	06 0c						.byte 6, IM+NN
>cecf	db ce				                .word nt_asm_inx
>ced1	cc aa d1 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>ced5	69 6e 63 2e 7a 78				.text "inc.zx"
.cedb					nt_asm_inx:
>cedb	03 0c						.byte 3, IM+NN
>cedd	e6 ce				                .word nt_asm_iny
>cedf	d1 aa d6 aa					.word xt_asm_inx, z_asm_inx
>cee3	69 6e 78					.text "inx"
.cee6					nt_asm_iny:
>cee6	03 0c						.byte 3, IM+NN
>cee8	f1 ce				                .word nt_asm_jmp
>ceea	d6 aa db aa					.word xt_asm_iny, z_asm_iny
>ceee	69 6e 79					.text "iny"
.cef1					nt_asm_jmp:
>cef1	03 0c						.byte 3, IM+NN
>cef3	fc ce				                .word nt_asm_jmp_i
>cef5	db aa e0 aa					.word xt_asm_jmp, z_asm_jmp
>cef9	6a 6d 70					.text "jmp"
.cefc					nt_asm_jmp_i:
>cefc	05 0c						.byte 5, IM+NN
>cefe	09 cf				                .word nt_asm_jmp_xi
>cf00	e0 aa e5 aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cf04	6a 6d 70 2e 69					.text "jmp.i"
.cf09					nt_asm_jmp_xi:
>cf09	06 0c						.byte 6, IM+NN
>cf0b	17 cf				                .word nt_asm_jsr
>cf0d	e5 aa ea aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cf11	6a 6d 70 2e 78 69				.text "jmp.xi"
.cf17					nt_asm_jsr:
>cf17	03 0c						.byte 3, IM+NN
>cf19	22 cf				                .word nt_asm_lda
>cf1b	ea aa ef aa					.word xt_asm_jsr, z_asm_jsr
>cf1f	6a 73 72					.text "jsr"
.cf22					nt_asm_lda:
>cf22	03 0c						.byte 3, IM+NN
>cf24	2d cf				                .word nt_asm_lda_h
>cf26	ef aa f4 aa					.word xt_asm_lda, z_asm_lda
>cf2a	6c 64 61					.text "lda"
.cf2d					nt_asm_lda_h:
>cf2d	05 0c						.byte 5, IM+NN
>cf2f	3a cf				                .word nt_asm_lda_x
>cf31	f4 aa f9 aa					.word xt_asm_lda_h, z_asm_lda_h
>cf35	6c 64 61 2e 23					.text "lda.#"
.cf3a					nt_asm_lda_x:
>cf3a	05 0c						.byte 5, IM+NN
>cf3c	47 cf				                .word nt_asm_lda_y
>cf3e	f9 aa fe aa					.word xt_asm_lda_x, z_asm_lda_x
>cf42	6c 64 61 2e 78					.text "lda.x"
.cf47					nt_asm_lda_y:
>cf47	05 0c						.byte 5, IM+NN
>cf49	54 cf				                .word nt_asm_lda_z
>cf4b	fe aa 03 ab					.word xt_asm_lda_y, z_asm_lda_y
>cf4f	6c 64 61 2e 79					.text "lda.y"
.cf54					nt_asm_lda_z:
>cf54	05 0c						.byte 5, IM+NN
>cf56	61 cf				                .word nt_asm_lda_zi
>cf58	03 ab 08 ab					.word xt_asm_lda_z, z_asm_lda_z
>cf5c	6c 64 61 2e 7a					.text "lda.z"
.cf61					nt_asm_lda_zi:
>cf61	06 0c						.byte 6, IM+NN
>cf63	6f cf				                .word nt_asm_lda_ziy
>cf65	08 ab 0d ab					.word xt_asm_lda_zi, z_asm_lda_zi
>cf69	6c 64 61 2e 7a 69				.text "lda.zi"
.cf6f					nt_asm_lda_ziy:
>cf6f	07 0c						.byte 7, IM+NN
>cf71	7e cf				                .word nt_asm_lda_zx
>cf73	0d ab 12 ab					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf77	6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf7e					nt_asm_lda_zx:
>cf7e	06 0c						.byte 6, IM+NN
>cf80	8c cf				                .word nt_asm_lda_zxi
>cf82	12 ab 17 ab					.word xt_asm_lda_zx, z_asm_lda_zx
>cf86	6c 64 61 2e 7a 78				.text "lda.zx"
.cf8c					nt_asm_lda_zxi:
>cf8c	07 0c						.byte 7, IM+NN
>cf8e	9b cf				                .word nt_asm_ldx
>cf90	17 ab 1c ab					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf94	6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf9b					nt_asm_ldx:
>cf9b	03 0c						.byte 3, IM+NN
>cf9d	a6 cf				                .word nt_asm_ldx_h
>cf9f	1c ab 21 ab					.word xt_asm_ldx, z_asm_ldx
>cfa3	6c 64 78					.text "ldx"
.cfa6					nt_asm_ldx_h:
>cfa6	05 0c						.byte 5, IM+NN
>cfa8	b3 cf				                .word nt_asm_ldx_y
>cfaa	21 ab 26 ab					.word xt_asm_ldx_h, z_asm_ldx_h
>cfae	6c 64 78 2e 23					.text "ldx.#"
.cfb3					nt_asm_ldx_y:
>cfb3	05 0c						.byte 5, IM+NN
>cfb5	c0 cf				                .word nt_asm_ldx_z
>cfb7	26 ab 2b ab					.word xt_asm_ldx_y, z_asm_ldx_y
>cfbb	6c 64 78 2e 79					.text "ldx.y"
.cfc0					nt_asm_ldx_z:
>cfc0	05 0c						.byte 5, IM+NN
>cfc2	cd cf				                .word nt_asm_ldx_zy
>cfc4	2b ab 30 ab					.word xt_asm_ldx_z, z_asm_ldx_z
>cfc8	6c 64 78 2e 7a					.text "ldx.z"
.cfcd					nt_asm_ldx_zy:
>cfcd	06 0c						.byte 6, IM+NN
>cfcf	db cf				                .word nt_asm_ldy
>cfd1	30 ab 35 ab					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfd5	6c 64 78 2e 7a 79				.text "ldx.zy"
.cfdb					nt_asm_ldy:
>cfdb	03 0c						.byte 3, IM+NN
>cfdd	e6 cf				                .word nt_asm_ldy_h
>cfdf	35 ab 3a ab					.word xt_asm_ldy, z_asm_ldy
>cfe3	6c 64 79					.text "ldy"
.cfe6					nt_asm_ldy_h:
>cfe6	05 0c						.byte 5, IM+NN
>cfe8	f3 cf				                .word nt_asm_ldy_x
>cfea	3a ab 3f ab					.word xt_asm_ldy_h, z_asm_ldy_h
>cfee	6c 64 79 2e 23					.text "ldy.#"
.cff3					nt_asm_ldy_x:
>cff3	05 0c						.byte 5, IM+NN
>cff5	00 d0				                .word nt_asm_ldy_z
>cff7	3f ab 44 ab					.word xt_asm_ldy_x, z_asm_ldy_x
>cffb	6c 64 79 2e 78					.text "ldy.x"
.d000					nt_asm_ldy_z:
>d000	05 0c						.byte 5, IM+NN
>d002	0d d0				                .word nt_asm_ldy_zx
>d004	44 ab 49 ab					.word xt_asm_ldy_z, z_asm_ldy_z
>d008	6c 64 79 2e 7a					.text "ldy.z"
.d00d					nt_asm_ldy_zx:
>d00d	06 0c						.byte 6, IM+NN
>d00f	1b d0				                .word nt_asm_lsr
>d011	49 ab 4e ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>d015	6c 64 79 2e 7a 78				.text "ldy.zx"
.d01b					nt_asm_lsr:
>d01b	03 0c						.byte 3, IM+NN
>d01d	26 d0				                .word nt_asm_lsr_a
>d01f	4e ab 53 ab					.word xt_asm_lsr, z_asm_lsr
>d023	6c 73 72					.text "lsr"
.d026					nt_asm_lsr_a:
>d026	05 0c						.byte 5, IM+NN
>d028	33 d0				                .word nt_asm_lsr_x
>d02a	53 ab 58 ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d02e	6c 73 72 2e 61					.text "lsr.a"
.d033					nt_asm_lsr_x:
>d033	05 0c						.byte 5, IM+NN
>d035	40 d0				                .word nt_asm_lsr_z
>d037	58 ab 5d ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d03b	6c 73 72 2e 78					.text "lsr.x"
.d040					nt_asm_lsr_z:
>d040	05 0c						.byte 5, IM+NN
>d042	4d d0				                .word nt_asm_lsr_zx
>d044	5d ab 62 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d048	6c 73 72 2e 7a					.text "lsr.z"
.d04d					nt_asm_lsr_zx:
>d04d	06 0c						.byte 6, IM+NN
>d04f	5b d0				                .word nt_asm_nop
>d051	62 ab 67 ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d055	6c 73 72 2e 7a 78				.text "lsr.zx"
.d05b					nt_asm_nop:
>d05b	03 0c						.byte 3, IM+NN
>d05d	66 d0				                .word nt_asm_ora
>d05f	67 ab 6c ab					.word xt_asm_nop, z_asm_nop
>d063	6e 6f 70					.text "nop"
.d066					nt_asm_ora:
>d066	03 0c						.byte 3, IM+NN
>d068	71 d0				                .word nt_asm_ora_h
>d06a	6c ab 71 ab					.word xt_asm_ora, z_asm_ora
>d06e	6f 72 61					.text "ora"
.d071					nt_asm_ora_h:
>d071	05 0c						.byte 5, IM+NN
>d073	7e d0				                .word nt_asm_ora_x
>d075	71 ab 76 ab					.word xt_asm_ora_h, z_asm_ora_h
>d079	6f 72 61 2e 23					.text "ora.#"
.d07e					nt_asm_ora_x:
>d07e	05 0c						.byte 5, IM+NN
>d080	8b d0				                .word nt_asm_ora_y
>d082	76 ab 7b ab					.word xt_asm_ora_x, z_asm_ora_x
>d086	6f 72 61 2e 78					.text "ora.x"
.d08b					nt_asm_ora_y:
>d08b	05 0c						.byte 5, IM+NN
>d08d	98 d0				                .word nt_asm_ora_z
>d08f	7b ab 80 ab					.word xt_asm_ora_y, z_asm_ora_y
>d093	6f 72 61 2e 79					.text "ora.y"
.d098					nt_asm_ora_z:
>d098	05 0c						.byte 5, IM+NN
>d09a	a5 d0				                .word nt_asm_ora_zi
>d09c	80 ab 85 ab					.word xt_asm_ora_z, z_asm_ora_z
>d0a0	6f 72 61 2e 7a					.text "ora.z"
.d0a5					nt_asm_ora_zi:
>d0a5	06 0c						.byte 6, IM+NN
>d0a7	b3 d0				                .word nt_asm_ora_ziy
>d0a9	85 ab 8c ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d0ad	6f 72 61 2e 7a 69				.text "ora.zi"
.d0b3					nt_asm_ora_ziy:
>d0b3	07 0c						.byte 7, IM+NN
>d0b5	c2 d0				                .word nt_asm_ora_zx
>d0b7	8c ab 91 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d0bb	6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d0c2					nt_asm_ora_zx:
>d0c2	06 0c						.byte 6, IM+NN
>d0c4	d0 d0				                .word nt_asm_ora_zxi
>d0c6	91 ab 96 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d0ca	6f 72 61 2e 7a 78				.text "ora.zx"
.d0d0					nt_asm_ora_zxi:
>d0d0	07 0c						.byte 7, IM+NN
>d0d2	df d0				                .word nt_asm_pha
>d0d4	96 ab 9b ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0d8	6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0df					nt_asm_pha:
>d0df	03 0c						.byte 3, IM+NN
>d0e1	ea d0				                .word nt_asm_php
>d0e3	9b ab a0 ab					.word xt_asm_pha, z_asm_pha
>d0e7	70 68 61					.text "pha"
.d0ea					nt_asm_php:
>d0ea	03 0c						.byte 3, IM+NN
>d0ec	f5 d0				                .word nt_asm_phx
>d0ee	a0 ab a5 ab					.word xt_asm_php, z_asm_php
>d0f2	70 68 70					.text "php"
.d0f5					nt_asm_phx:
>d0f5	03 0c						.byte 3, IM+NN
>d0f7	00 d1				                .word nt_asm_phy
>d0f9	a5 ab aa ab					.word xt_asm_phx, z_asm_phx
>d0fd	70 68 78					.text "phx"
.d100					nt_asm_phy:
>d100	03 0c						.byte 3, IM+NN
>d102	0b d1				                .word nt_asm_pla
>d104	aa ab af ab					.word xt_asm_phy, z_asm_phy
>d108	70 68 79					.text "phy"
.d10b					nt_asm_pla:
>d10b	03 0c						.byte 3, IM+NN
>d10d	16 d1				                .word nt_asm_plp
>d10f	af ab b4 ab					.word xt_asm_pla, z_asm_pla
>d113	70 6c 61					.text "pla"
.d116					nt_asm_plp:
>d116	03 0c						.byte 3, IM+NN
>d118	21 d1				                .word nt_asm_plx
>d11a	b4 ab b9 ab					.word xt_asm_plp, z_asm_plp
>d11e	70 6c 70					.text "plp"
.d121					nt_asm_plx:
>d121	03 0c						.byte 3, IM+NN
>d123	2c d1				                .word nt_asm_ply
>d125	b9 ab be ab					.word xt_asm_plx, z_asm_plx
>d129	70 6c 78					.text "plx"
.d12c					nt_asm_ply:
>d12c	03 0c						.byte 3, IM+NN
>d12e	37 d1				                .word nt_asm_rol
>d130	be ab c3 ab					.word xt_asm_ply, z_asm_ply
>d134	70 6c 79					.text "ply"
.d137					nt_asm_rol:
>d137	03 0c						.byte 3, IM+NN
>d139	42 d1				                .word nt_asm_rol_a
>d13b	c3 ab c8 ab					.word xt_asm_rol, z_asm_rol
>d13f	72 6f 6c					.text "rol"
.d142					nt_asm_rol_a:
>d142	05 0c						.byte 5, IM+NN
>d144	4f d1				                .word nt_asm_rol_x
>d146	c8 ab cd ab					.word xt_asm_rol_a, z_asm_rol_a
>d14a	72 6f 6c 2e 61					.text "rol.a"
.d14f					nt_asm_rol_x:
>d14f	05 0c						.byte 5, IM+NN
>d151	5c d1				                .word nt_asm_rol_z
>d153	cd ab d2 ab					.word xt_asm_rol_x, z_asm_rol_x
>d157	72 6f 6c 2e 78					.text "rol.x"
.d15c					nt_asm_rol_z:
>d15c	05 0c						.byte 5, IM+NN
>d15e	69 d1				                .word nt_asm_rol_zx
>d160	d2 ab d7 ab					.word xt_asm_rol_z, z_asm_rol_z
>d164	72 6f 6c 2e 7a					.text "rol.z"
.d169					nt_asm_rol_zx:
>d169	06 0c						.byte 6, IM+NN
>d16b	77 d1				                .word nt_asm_ror
>d16d	d7 ab dc ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d171	72 6f 6c 2e 7a 78				.text "rol.zx"
.d177					nt_asm_ror:
>d177	03 0c						.byte 3, IM+NN
>d179	82 d1				                .word nt_asm_ror_a
>d17b	dc ab e1 ab					.word xt_asm_ror, z_asm_ror
>d17f	72 6f 72					.text "ror"
.d182					nt_asm_ror_a:
>d182	05 0c						.byte 5, IM+NN
>d184	8f d1				                .word nt_asm_ror_x
>d186	e1 ab e6 ab					.word xt_asm_ror_a, z_asm_ror_a
>d18a	72 6f 72 2e 61					.text "ror.a"
.d18f					nt_asm_ror_x:
>d18f	05 0c						.byte 5, IM+NN
>d191	9c d1				                .word nt_asm_ror_z
>d193	e6 ab eb ab					.word xt_asm_ror_x, z_asm_ror_x
>d197	72 6f 72 2e 78					.text "ror.x"
.d19c					nt_asm_ror_z:
>d19c	05 0c						.byte 5, IM+NN
>d19e	a9 d1				                .word nt_asm_ror_zx
>d1a0	eb ab f0 ab					.word xt_asm_ror_z, z_asm_ror_z
>d1a4	72 6f 72 2e 7a					.text "ror.z"
.d1a9					nt_asm_ror_zx:
>d1a9	06 0c						.byte 6, IM+NN
>d1ab	b7 d1				                .word nt_asm_rti
>d1ad	f0 ab f5 ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d1b1	72 6f 72 2e 7a 78				.text "ror.zx"
.d1b7					nt_asm_rti:
>d1b7	03 0c						.byte 3, IM+NN
>d1b9	c2 d1				                .word nt_asm_rts
>d1bb	f5 ab fa ab					.word xt_asm_rti, z_asm_rti
>d1bf	72 74 69					.text "rti"
.d1c2					nt_asm_rts:
>d1c2	03 0c						.byte 3, IM+NN
>d1c4	cd d1				                .word nt_asm_sbc
>d1c6	fa ab ff ab					.word xt_asm_rts, z_asm_rts
>d1ca	72 74 73					.text "rts"
.d1cd					nt_asm_sbc:
>d1cd	03 0c						.byte 3, IM+NN
>d1cf	d8 d1				                .word nt_asm_sbc_h
>d1d1	ff ab 04 ac					.word xt_asm_sbc, z_asm_sbc
>d1d5	73 62 63					.text "sbc"
.d1d8					nt_asm_sbc_h:
>d1d8	05 0c						.byte 5, IM+NN
>d1da	e5 d1				                .word nt_asm_sbc_x
>d1dc	04 ac 09 ac					.word xt_asm_sbc_h, z_asm_sbc_h
>d1e0	73 62 63 2e 23					.text "sbc.#"
.d1e5					nt_asm_sbc_x:
>d1e5	05 0c						.byte 5, IM+NN
>d1e7	f2 d1				                .word nt_asm_sbc_y
>d1e9	09 ac 0e ac					.word xt_asm_sbc_x, z_asm_sbc_x
>d1ed	73 62 63 2e 78					.text "sbc.x"
.d1f2					nt_asm_sbc_y:
>d1f2	05 0c						.byte 5, IM+NN
>d1f4	ff d1				                .word nt_asm_sbc_z
>d1f6	0e ac 13 ac					.word xt_asm_sbc_y, z_asm_sbc_y
>d1fa	73 62 63 2e 79					.text "sbc.y"
.d1ff					nt_asm_sbc_z:
>d1ff	05 0c						.byte 5, IM+NN
>d201	0c d2				                .word nt_asm_sbc_zi
>d203	13 ac 18 ac					.word xt_asm_sbc_z, z_asm_sbc_z
>d207	73 62 63 2e 7a					.text "sbc.z"
.d20c					nt_asm_sbc_zi:
>d20c	06 0c						.byte 6, IM+NN
>d20e	1a d2				                .word nt_asm_sbc_ziy
>d210	18 ac 1d ac					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d214	73 62 63 2e 7a 69				.text "sbc.zi"
.d21a					nt_asm_sbc_ziy:
>d21a	07 0c						.byte 7, IM+NN
>d21c	29 d2				                .word nt_asm_sbc_zx
>d21e	1d ac 22 ac					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d222	73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d229					nt_asm_sbc_zx:
>d229	06 0c						.byte 6, IM+NN
>d22b	37 d2				                .word nt_asm_sbc_zxi
>d22d	22 ac 27 ac					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d231	73 62 63 2e 7a 78				.text "sbc.zx"
.d237					nt_asm_sbc_zxi:
>d237	07 0c						.byte 7, IM+NN
>d239	46 d2				                .word nt_asm_sec
>d23b	27 ac 2b ac					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d23f	73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d246					nt_asm_sec:
>d246	03 0c						.byte 3, IM+NN
>d248	51 d2				                .word nt_asm_sed
>d24a	2b ac 2f ac					.word xt_asm_sec, z_asm_sec
>d24e	73 65 63					.text "sec"
.d251					nt_asm_sed:
>d251	03 0c						.byte 3, IM+NN
>d253	5c d2				                .word nt_asm_sei
>d255	2f ac 33 ac					.word xt_asm_sed, z_asm_sed
>d259	73 65 64					.text "sed"
.d25c					nt_asm_sei:
>d25c	03 0c						.byte 3, IM+NN
>d25e	67 d2				                .word nt_asm_sta
>d260	33 ac 37 ac					.word xt_asm_sei, z_asm_sei
>d264	73 65 69					.text "sei"
.d267					nt_asm_sta:
>d267	03 0c						.byte 3, IM+NN
>d269	72 d2				                .word nt_asm_sta_x
>d26b	37 ac 3b ac					.word xt_asm_sta, z_asm_sta
>d26f	73 74 61					.text "sta"
.d272					nt_asm_sta_x:
>d272	05 0c						.byte 5, IM+NN
>d274	7f d2				                .word nt_asm_sta_y
>d276	3b ac 3f ac					.word xt_asm_sta_x, z_asm_sta_x
>d27a	73 74 61 2e 78					.text "sta.x"
.d27f					nt_asm_sta_y:
>d27f	05 0c						.byte 5, IM+NN
>d281	8c d2				                .word nt_asm_sta_z
>d283	3f ac 43 ac					.word xt_asm_sta_y, z_asm_sta_y
>d287	73 74 61 2e 79					.text "sta.y"
.d28c					nt_asm_sta_z:
>d28c	05 0c						.byte 5, IM+NN
>d28e	99 d2				                .word nt_asm_sta_zi
>d290	43 ac 47 ac					.word xt_asm_sta_z, z_asm_sta_z
>d294	73 74 61 2e 7a					.text "sta.z"
.d299					nt_asm_sta_zi:
>d299	06 0c						.byte 6, IM+NN
>d29b	a7 d2				                .word nt_asm_sta_ziy
>d29d	47 ac 4b ac					.word xt_asm_sta_zi, z_asm_sta_zi
>d2a1	73 74 61 2e 7a 69				.text "sta.zi"
.d2a7					nt_asm_sta_ziy:
>d2a7	07 0c						.byte 7, IM+NN
>d2a9	b6 d2				                .word nt_asm_sta_zx
>d2ab	4b ac 4f ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d2af	73 74 61 2e 7a 69 79				.text "sta.ziy"
.d2b6					nt_asm_sta_zx:
>d2b6	06 0c						.byte 6, IM+NN
>d2b8	c4 d2				                .word nt_asm_sta_zxi
>d2ba	4f ac 53 ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d2be	73 74 61 2e 7a 78				.text "sta.zx"
.d2c4					nt_asm_sta_zxi:
>d2c4	07 0c						.byte 7, IM+NN
>d2c6	d3 d2				                .word nt_asm_stx
>d2c8	53 ac 57 ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2cc	73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2d3					nt_asm_stx:
>d2d3	03 0c						.byte 3, IM+NN
>d2d5	de d2				                .word nt_asm_stx_z
>d2d7	57 ac 5b ac					.word xt_asm_stx, z_asm_stx
>d2db	73 74 78					.text "stx"
.d2de					nt_asm_stx_z:
>d2de	05 0c						.byte 5, IM+NN
>d2e0	eb d2				                .word nt_asm_stx_zy
>d2e2	5b ac 5f ac					.word xt_asm_stx_z, z_asm_stx_z
>d2e6	73 74 78 2e 7a					.text "stx.z"
.d2eb					nt_asm_stx_zy:
>d2eb	06 0c						.byte 6, IM+NN
>d2ed	f9 d2				                .word nt_asm_sty
>d2ef	5f ac 63 ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d2f3	73 74 78 2e 7a 79				.text "stx.zy"
.d2f9					nt_asm_sty:
>d2f9	03 0c						.byte 3, IM+NN
>d2fb	04 d3				                .word nt_asm_sty_z
>d2fd	63 ac 67 ac					.word xt_asm_sty, z_asm_sty
>d301	73 74 79					.text "sty"
.d304					nt_asm_sty_z:
>d304	05 0c						.byte 5, IM+NN
>d306	11 d3				                .word nt_asm_sty_zx
>d308	67 ac 6b ac					.word xt_asm_sty_z, z_asm_sty_z
>d30c	73 74 79 2e 7a					.text "sty.z"
.d311					nt_asm_sty_zx:
>d311	06 0c						.byte 6, IM+NN
>d313	1f d3				                .word nt_asm_stz
>d315	6b ac 6f ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d319	73 74 79 2e 7a 78				.text "sty.zx"
.d31f					nt_asm_stz:
>d31f	03 0c						.byte 3, IM+NN
>d321	2a d3				                .word nt_asm_stz_x
>d323	6f ac 73 ac					.word xt_asm_stz, z_asm_stz
>d327	73 74 7a					.text "stz"
.d32a					nt_asm_stz_x:
>d32a	05 0c						.byte 5, IM+NN
>d32c	37 d3				                .word nt_asm_stz_z
>d32e	73 ac 77 ac					.word xt_asm_stz_x, z_asm_stz_x
>d332	73 74 7a 2e 78					.text "stz.x"
.d337					nt_asm_stz_z:
>d337	05 0c						.byte 5, IM+NN
>d339	44 d3				                .word nt_asm_stz_zx
>d33b	77 ac 7b ac					.word xt_asm_stz_z, z_asm_stz_z
>d33f	73 74 7a 2e 7a					.text "stz.z"
.d344					nt_asm_stz_zx:
>d344	06 0c						.byte 6, IM+NN
>d346	52 d3				                .word nt_asm_tax
>d348	7b ac 7f ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d34c	73 74 7a 2e 7a 78				.text "stz.zx"
.d352					nt_asm_tax:
>d352	03 0c						.byte 3, IM+NN
>d354	5d d3				                .word nt_asm_tay
>d356	7f ac 83 ac					.word xt_asm_tax, z_asm_tax
>d35a	74 61 78					.text "tax"
.d35d					nt_asm_tay:
>d35d	03 0c						.byte 3, IM+NN
>d35f	68 d3				                .word nt_asm_trb
>d361	83 ac 87 ac					.word xt_asm_tay, z_asm_tay
>d365	74 61 79					.text "tay"
.d368					nt_asm_trb:
>d368	03 0c						.byte 3, IM+NN
>d36a	73 d3				                .word nt_asm_trb_z
>d36c	87 ac 8b ac					.word xt_asm_trb, z_asm_trb
>d370	74 72 62					.text "trb"
.d373					nt_asm_trb_z:
>d373	05 0c						.byte 5, IM+NN
>d375	80 d3				                .word nt_asm_tsb
>d377	8b ac 8f ac					.word xt_asm_trb_z, z_asm_trb_z
>d37b	74 72 62 2e 7a					.text "trb.z"
.d380					nt_asm_tsb:
>d380	03 0c						.byte 3, IM+NN
>d382	8b d3				                .word nt_asm_tsb_z
>d384	8f ac 93 ac					.word xt_asm_tsb, z_asm_tsb
>d388	74 73 62					.text "tsb"
.d38b					nt_asm_tsb_z:
>d38b	05 0c						.byte 5, IM+NN
>d38d	98 d3				                .word nt_asm_tsx
>d38f	93 ac 97 ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d393	74 73 62 2e 7a					.text "tsb.z"
.d398					nt_asm_tsx:
>d398	03 0c						.byte 3, IM+NN
>d39a	a3 d3				                .word nt_asm_txa
>d39c	97 ac 9b ac					.word xt_asm_tsx, z_asm_tsx
>d3a0	74 73 78					.text "tsx"
.d3a3					nt_asm_txa:
>d3a3	03 0c						.byte 3, IM+NN
>d3a5	ae d3				                .word nt_asm_txs
>d3a7	9b ac 9f ac					.word xt_asm_txa, z_asm_txa
>d3ab	74 78 61					.text "txa"
.d3ae					nt_asm_txs:
>d3ae	03 0c						.byte 3, IM+NN
>d3b0	b9 d3				                .word nt_asm_tya
>d3b2	9f ac a3 ac					.word xt_asm_txs, z_asm_txs
>d3b6	74 78 73					.text "txs"
.d3b9					nt_asm_tya:
>d3b9	03 0c						.byte 3, IM+NN
>d3bb	c4 d3				                .word nt_asm_arrow
>d3bd	a3 ac a7 ac					.word xt_asm_tya, z_asm_tya
>d3c1	74 79 61					.text "tya"
.d3c4					nt_asm_arrow:
>d3c4	03 04				                .byte 3, IM
>d3c6	cf d3				                .word nt_asm_back_jump
>d3c8	9d 91 a7 91			                .word xt_asm_arrow, z_asm_arrow
>d3cc	2d 2d 3e			                .text "-->"
.d3cf					nt_asm_back_jump:
>d3cf	02 04				                .byte 2, IM
>d3d1	d9 d3				                .word nt_asm_back_branch
>d3d3	f8 ac f8 ac			                .word xt_asm_back_jump, z_asm_back_jump
>d3d7	3c 6a				                .text "<j"
.d3d9					nt_asm_back_branch:
>d3d9	02 04				                .byte 2, IM
>d3db	e3 d3				                .word nt_asm_push_a
>d3dd	f9 ac 01 ad			                .word xt_asm_back_branch, z_asm_back_branch
>d3e1	3c 62				                .text "<b"
.d3e3					nt_asm_push_a:
>d3e3	06 0c				                .byte 6, IM+NN
>d3e5	00 00				                .word 0000
>d3e7	e1 ac f0 ac			                .word xt_asm_push_a, z_asm_push_a
>d3eb	70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0					str_ok             =  0
=1					str_compile        =  1
=2					str_redefined      =  2
=3					str_wid_forth      =  3
=4					str_abc_lower      =  4
=5					str_abc_upper      =  5
=6					str_wid_editor     =  6
=7					str_wid_assembler  =  7
=8					str_wid_root       =  8
=9					str_see_flags      =  9
=10					str_see_nt         = 10
=11					str_see_xt         = 11
=12					str_see_size       = 12
=13					str_disasm_lit     = 13
=14					str_disasm_sdc     = 14
=15					str_disasm_bra     = 15
.d3f1					string_table:
>d3f1	11 d4 15 d4 1f d4 85 d4		        .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
>d3f9	2a d4
>d3fb	4e d4 7d d4 72 d4 8c d4		        .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
>d403	92 d4 ae d4 b3 d4 b8 d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
>d40b	c9 d4 d2 d4 e4 d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 13-15
>d411	20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d415	20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d41d	64 00
>d41f	72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d427	64 20 00
>d42a	30 31 32 33 34 35 36 37		s_abc_lower:  .text "0123456789abcdefghijklmnopqrstuvwxyz"
>d432	38 39 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e
>d442	6f 70 71 72 73 74 75 76 77 78 79 7a
>d44e	30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d456	38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d466	4f 50 51 52 53 54 55 56 57 58 59 5a
>d472	41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d47a	72 20 00
>d47d	45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d485	46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d48c	52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d492	66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d49a	4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d4aa	29 3a 20 00
>d4ae	6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d4b3	78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d4b8	73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d4c0	63 69 6d 61 6c 29 3a 20 00
>d4c9	4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d4d1	00
>d4d2	53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d4da	50 54 48 20 43 48 45 43 4b 00
>d4e4	42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0					err_allot        = 0
=1					err_badsource    = 1
=2					err_compileonly  = 2
=3					err_defer        = 3
=4					err_divzero      = 4
=5					err_noname       = 5
=6					err_refill       = 6
=7					err_state        = 7
=8					err_syntax       = 8
=9					err_underflow    = 9
=10					err_negallot     = 10
=11					err_wordlist     = 11
=12					err_blockwords   = 12
.d4ec					error_table:
>d4ec	06 d5 27 d5 47 d5 68 d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4f4	85 d5 96 d5 a6 d5 d4 d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4fc	ec d5 fb d5 0b d6 27 d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d504	3e d6				        .word es_blockwords                                    ; 12
>d506	41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d50e	69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d51e	65 20 6d 65 6d 6f 72 79 00
>d527	49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d52f	53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d53f	20 52 45 46 49 4c 4c 00
>d547	49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d54f	74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d55f	6e 6c 79 20 77 6f 72 64 00
>d568	44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d570	77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d580	20 79 65 74 00
>d585	44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d58d	20 62 79 20 7a 65 72 6f 00
>d596	50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d59e	66 61 69 6c 75 72 65 00
>d5a6	51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d5ae	6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d5be	20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d5ce	64 20 2d 31 29 00
>d5d4	41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d5dc	69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5ec	55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word", 0
>d5f4	64 20 77 6f 72 64 00
>d5fb	53 74 61 63 6b 20 75 6e		es_underflow:   .text "Stack underflow", 0
>d603	64 65 72 66 6c 6f 77 00
>d60b	4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d613	72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d623	4c 4f 54 00
>d627	4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d62f	69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d63e	50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d646	73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d656	4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d666	61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d676	56 45 43 54 4f 52 00
>d67d	0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d685	44 2d 53 54 52 49 4e 47
>d68d	05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d693	04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d698	11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d6a0	2d 55 4e 49 54 2d 42 49 54 53
>d6aa	07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d6b2	08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6ba	52
>d6bb	05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6c1	05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6c7	12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6cf	53 54 41 43 4b 2d 43 45 4c 4c 53
>d6da	0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d6e2	45 4c 4c 53
>d6e6	09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d6ee	54 53
>d6f0	05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d6f6	06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d6fd					cmpl_subroutine:
.d6fd	48		pha		                pha             ; save LSB of address
.d6fe	a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d700	80 03		bra $d705	                bra cmpl_common
.d702					cmpl_jump:
.d702	48		pha		                pha             ; save LSB of address
.d703	a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d705					cmpl_common:
.d705	20 0d d7	jsr $d70d	                jsr cmpl_a      ; compile opcode
.d708	68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d709					cmpl_word:
.d709	20 0d d7	jsr $d70d	                jsr cmpl_a      ; compile LSB of address
.d70c	98		tya		                tya             ; fall thru for MSB
.d70d					cmpl_a:
.d70d	92 00		sta ($00)	                sta (cp)
.d70f	e6 00		inc $00		                inc cp
.d711	d0 02		bne $d715	                bne _done
.d713	e6 01		inc $01		                inc cp+1
.d715					_done:
.d715	60		rts		                rts
.d716					doconst:
.d716	ca		dex		                dex             ; make room for constant
.d717	ca		dex		                dex
.d718	68		pla		                pla             ; LSB of return address
.d719	85 24		sta $24		                sta tmp1
.d71b	68		pla		                pla             ; MSB of return address
.d71c	85 25		sta $25		                sta tmp1+1
.d71e	a0 01		ldy #$01	                ldy #1
.d720	b1 24		lda ($24),y	                lda (tmp1),y
.d722	95 00		sta $00,x	                sta 0,x
.d724	c8		iny		                iny
.d725	b1 24		lda ($24),y	                lda (tmp1),y
.d727	95 01		sta $01,x	                sta 1,x
.d729	60		rts		                rts
.d72a					dodefer:
.d72a	68		pla		                pla             ; LSB
.d72b	85 24		sta $24		                sta tmp1
.d72d	68		pla		                pla             ; MSB
.d72e	85 25		sta $25		                sta tmp1+1
.d730	a0 01		ldy #$01	                ldy #1
.d732	b1 24		lda ($24),y	                lda (tmp1),y
.d734	85 26		sta $26		                sta tmp2
.d736	c8		iny		                iny
.d737	b1 24		lda ($24),y	                lda (tmp1),y
.d739	85 27		sta $27		                sta tmp2+1
.d73b	6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d73e					defer_error:
.d73e	a9 03		lda #$03	                lda #err_defer
.d740	4c 70 d8	jmp $d870	                jmp error
.d743					dodoes:
.d743	7a		ply		                ply             ; LSB
.d744	68		pla		                pla             ; MSB
.d745	c8		iny		                iny
.d746	d0 01		bne $d749	                bne +
.d748	1a		inc a		                ina
.d749					+
.d749	84 26		sty $26		                sty tmp2
.d74b	85 27		sta $27		                sta tmp2+1
.d74d	ca		dex		                dex
.d74e	ca		dex		                dex
.d74f	7a		ply		                ply
.d750	68		pla		                pla
.d751	c8		iny		                iny
.d752	d0 01		bne $d755	                bne +
.d754	1a		inc a		                ina
.d755					+
.d755	94 00		sty $00,x	                sty 0,x         ; LSB
.d757	95 01		sta $01,x	                sta 1,x         ; MSB
.d759	6c 26 00	jmp ($0026)	                jmp (tmp2)
.d75c					dovar:
.d75c	7a		ply		                ply             ; LSB
.d75d	68		pla		                pla             ; MSB
.d75e	c8		iny		                iny
.d75f	d0 01		bne $d762	                bne +
.d761	1a		inc a		                ina
.d762					+
.d762	ca		dex		                dex
.d763	ca		dex		                dex
.d764	95 01		sta $01,x	                sta 1,x
.d766	98		tya		                tya
.d767	95 00		sta $00,x	                sta 0,x
.d769	60		rts		                rts
.d76a					byte_to_ascii:
.d76a	48		pha		                pha
.d76b	4a		lsr a		                lsr             ; convert high nibble first
.d76c	4a		lsr a		                lsr
.d76d	4a		lsr a		                lsr
.d76e	4a		lsr a		                lsr
.d76f	20 73 d7	jsr $d773	                jsr _nibble_to_ascii
.d772	68		pla		                pla
.d773					_nibble_to_ascii:
.d773	29 0f		and #$0f	                and #$0F
.d775	09 30		ora #$30	                ora #'0'
.d777	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d779	90 02		bcc $d77d	                bcc +
.d77b	69 06		adc #$06	                adc #$06
.d77d	4c 21 8e	jmp $8e21	+               jmp emit_a
.d780	60		rts		                rts
.d781					compare_16bit:
.d781	b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d783	d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d785	f0 0a		beq $d791	                beq _equal
.d787	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d789	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d78b	09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d78d	70 08		bvs $d797	                bvs _overflow
.d78f	80 08		bra $d799	                bra _not_equal
.d791					_equal:
.d791	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d793	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d795	50 04		bvc $d79b	                bvc _done
.d797					_overflow:
.d797	49 80		eor #$80	                eor #$80                ; complement negative flag
.d799					_not_equal:
.d799	09 01		ora #$01	                ora #1                  ; if overflow, we can't be eqal
.d79b					_done:
.d79b	60		rts		                rts
.d79c					current_to_dp:
.d79c	a0 04		ldy #$04	                ldy #current_offset
.d79e	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d7a0	0a		asl a		                asl             ; turn it into an offset (in cells)
.d7a1	18		clc		                clc
.d7a2	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d7a4	a8		tay		                tay
.d7a5	b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d7a7	85 02		sta $02		                sta dp
.d7a9	c8		iny		                iny
.d7aa	b1 1e		lda ($1e),y	                lda (up),y
.d7ac	85 03		sta $03		                sta dp+1
.d7ae	60		rts		                rts
.d7af					dp_to_current:
.d7af	a0 04		ldy #$04	                ldy #current_offset
.d7b1	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d7b3	0a		asl a		                asl             ; turn it into an offset (in cells)
.d7b4	18		clc		                clc
.d7b5	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d7b7	a8		tay		                tay
.d7b8	a5 02		lda $02		                lda dp
.d7ba	91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d7bc	c8		iny		                iny
.d7bd	a5 03		lda $03		                lda dp+1
.d7bf	91 1e		sta ($1e),y	                sta (up),y
.d7c1	60		rts		                rts
.d7c2					interpret:
.d7c2					_loop:
.d7c2	20 0a 99	jsr $990a	                jsr xt_parse_name       ; ( "string" -- addr u )
.d7c5	b5 00		lda $00,x	                lda 0,x
.d7c7	15 01		ora $01,x	                ora 1,x
.d7c9	f0 70		beq $d83b	                beq _line_done
.d7cb	20 e3 a3	jsr $a3e3	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d7ce	20 06 90	jsr $9006	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d7d1	b5 00		lda $00,x	                lda 0,x
.d7d3	15 01		ora $01,x	                ora 1,x
.d7d5	d0 28		bne $d7ff	                bne _got_name_token
.d7d7	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d7d8	e8		inx		                inx
.d7d9	20 b5 96	jsr $96b5	                jsr xt_number           ; ( addr u -- u|d )
.d7dc	a5 16		lda $16		                lda state
.d7de	f0 e2		beq $d7c2	                beq _loop
.d7e0	a9 20		lda #$20	                lda #$20
.d7e2	24 20		bit $20		                bit status
.d7e4	f0 0d		beq $d7f3	                beq _single_number
.d7e6	20 d9 a1	jsr $a1d9	                jsr xt_swap
.d7e9	a0 93		ldy #$93	                ldy #>literal_runtime
.d7eb	a9 c3		lda #$c3	                lda #<literal_runtime
.d7ed	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.d7f0	20 99 87	jsr $8799	                jsr xt_comma
.d7f3					_single_number:
.d7f3	a0 93		ldy #$93	                ldy #>literal_runtime
.d7f5	a9 c3		lda #$c3	                lda #<literal_runtime
.d7f7	20 fd d6	jsr $d6fd	                jsr cmpl_subroutine
.d7fa	20 99 87	jsr $8799	                jsr xt_comma
.d7fd	80 c3		bra $d7c2	                bra _loop
.d7ff					_got_name_token:
.d7ff	b5 00		lda $00,x	                lda 0,x
.d801	95 04		sta $04,x	                sta 4,x
.d803	b5 01		lda $01,x	                lda 1,x
.d805	95 05		sta $05,x	                sta 5,x
.d807	e8		inx		                inx
.d808	e8		inx		                inx
.d809	e8		inx		                inx
.d80a	e8		inx		                inx                     ; ( nt )
.d80b	b5 00		lda $00,x	                lda 0,x
.d80d	85 22		sta $22		                sta tmpbranch
.d80f	b5 01		lda $01,x	                lda 1,x
.d811	85 23		sta $23		                sta tmpbranch+1
.d813	20 0c 96	jsr $960c	                jsr xt_name_to_int      ; ( nt - xt )
.d816	a5 16		lda $16		                lda state
.d818	d0 13		bne $d82d	                bne _compile
.d81a	a0 01		ldy #$01	                ldy #1
.d81c	b1 22		lda ($22),y	                lda (tmpbranch),y
.d81e	29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d820	f0 05		beq $d827	                beq _interpret
.d822	a9 02		lda #$02	                lda #err_compileonly
.d824	4c 70 d8	jmp $d870	                jmp error
.d827					_interpret:
.d827	20 68 8f	jsr $8f68	                jsr xt_execute
.d82a	4c c2 d7	jmp $d7c2	                jmp _loop
.d82d					_compile:
.d82d	a0 01		ldy #$01	                ldy #1
.d82f	b1 22		lda ($22),y	                lda (tmpbranch),y
.d831	29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d833	d0 f2		bne $d827	                bne _interpret          ; IMMEDIATE word, execute right now
.d835	20 18 88	jsr $8818	                jsr xt_compile_comma
.d838	4c c2 d7	jmp $d7c2	                jmp _loop
.d83b					_line_done:
.d83b	e8		inx		                inx
.d83c	e8		inx		                inx
.d83d	e8		inx		                inx
.d83e	e8		inx		                inx
.d83f	60		rts		                rts
.d840					is_printable:
.d840	c9 20		cmp #$20	                cmp #AscSP              ; $20
.d842	90 08		bcc $d84c	                bcc _done
.d844	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d846	b0 03		bcs $d84b	                bcs _failed
.d848	38		sec		                sec
.d849	80 01		bra $d84c	                bra _done
.d84b					_failed:
.d84b	18		clc		                clc
.d84c					_done:
.d84c	60		rts		                rts
.d84d					is_whitespace:
.d84d	c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d84f	90 08		bcc $d859	                bcc _done
.d851	c9 21		cmp #$21	                cmp #AscSP+1
.d853	b0 03		bcs $d858	                bcs _failed
.d855	38		sec		                sec
.d856	80 01		bra $d859	                bra _done
.d858					_failed:
.d858	18		clc		                clc
.d859					_done:
.d859	60		rts		                rts
.d85a					underflow_1:
.d85a	e0 77		cpx #$77	                cpx #dsp0-1
.d85c	10 10		bpl $d86e	                bpl underflow_error
.d85e	60		rts		                rts
.d85f					underflow_2:
.d85f	e0 75		cpx #$75	                cpx #dsp0-3
.d861	10 0b		bpl $d86e	                bpl underflow_error
.d863	60		rts		                rts
.d864					underflow_3:
.d864	e0 73		cpx #$73	                cpx #dsp0-5
.d866	10 06		bpl $d86e	                bpl underflow_error
.d868	60		rts		                rts
.d869					underflow_4:
.d869	e0 71		cpx #$71	                cpx #dsp0-7
.d86b	10 01		bpl $d86e	                bpl underflow_error
.d86d	60		rts		                rts
.d86e					underflow_error:
.d86e	a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d870					error:
.d870	0a		asl a		                asl
.d871	a8		tay		                tay
.d872	b9 ec d4	lda $d4ec,y	                lda error_table,y
.d875	85 28		sta $28		                sta tmp3                ; LSB
.d877	c8		iny		                iny
.d878	b9 ec d4	lda $d4ec,y	                lda error_table,y
.d87b	85 29		sta $29		                sta tmp3+1              ; MSB
.d87d	20 93 d8	jsr $d893	                jsr print_common
.d880	20 8e 89	jsr $898e	                jsr xt_cr
.d883	4c 81 80	jmp $8081	                jmp xt_abort            ; no jsr, as we clobber return stack
.d886					print_string_no_lf:
.d886	0a		asl a		                asl
.d887	a8		tay		                tay
.d888	b9 f1 d3	lda $d3f1,y	                lda string_table,y
.d88b	85 28		sta $28		                sta tmp3                ; LSB
.d88d	c8		iny		                iny
.d88e	b9 f1 d3	lda $d3f1,y	                lda string_table,y
.d891	85 29		sta $29		                sta tmp3+1              ; MSB
.d893					print_common:
.d893	a0 00		ldy #$00	                ldy #0
.d895					_loop:
.d895	b1 28		lda ($28),y	                lda (tmp3),y
.d897	f0 06		beq $d89f	                beq _done               ; strings are zero-terminated
.d899	20 21 8e	jsr $8e21	                jsr emit_a              ; allows vectoring via output
.d89c	c8		iny		                iny
.d89d	80 f6		bra $d895	                bra _loop
.d89f					_done:
.d89f	60		rts		                rts
.d8a0					print_string:
.d8a0	20 86 d8	jsr $d886	                jsr print_string_no_lf
.d8a3	4c 8e 89	jmp $898e	                jmp xt_cr               ; JSR/RTS because never compiled
.d8a6					print_u:
.d8a6	20 d3 a7	jsr $a7d3	                jsr xt_zero                     ; 0
.d8a9	20 85 93	jsr $9385	                jsr xt_less_number_sign         ; <#
.d8ac	20 09 98	jsr $9809	                jsr xt_number_sign_s            ; #S
.d8af	20 e7 97	jsr $97e7	                jsr xt_number_sign_greater      ; #>
.d8b2	4c 2e a5	jmp $a52e	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp forth
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034	74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044	6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054	28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
