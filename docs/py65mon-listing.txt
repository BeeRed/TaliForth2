
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Fri Jul  5 05:18:14 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$7fff						ram_end = $7fff
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/simulator.asm


;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000						w_cold:
.8000		d8		cld		                cld
.8001		a9 27		lda #$27	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd 32 b4	lda $b432,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad 32 b4	lda $b432	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f						_load_user_vars_loop:
.801f		b9 50 b4	lda $b450,y	                lda cold_user_table,y
.8022		91 08		sta ($08),y	                sta (up),y
.8024		88		dey		                dey
.8025		d0 f8		bne $801f	                bne _load_user_vars_loop
.8027		ad 50 b4	lda $b450	                lda cold_user_table
.802a		92 08		sta ($08)	                sta (up)
.802c		20 05 84	jsr $8405	                jsr w_cr
.802f		ca		dex		                dex
.8030		ca		dex		                dex
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		a9 33		lda #$33	                lda #<forth_words_start
.8035		95 02		sta $02,x	                sta 2,x
.8037		a9 bb		lda #$bb	                lda #>forth_words_start
.8039		95 03		sta $03,x	                sta 3,x
.803b		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803d		95 00		sta $00,x	                sta 0,x
.803f		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8041		95 01		sta $01,x	                sta 1,x
.8043		20 8e 88	jsr $888e	                jsr w_evaluate
.8046		9c 00 7c	stz $7c00	                stz hist_buff
.8049		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804c		9c 00 7d	stz $7d00	                stz hist_buff+$100
.804f		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8052		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8055		9c 80 7e	stz $7e80	                stz hist_buff+$280
.8058		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805b		9c 80 7f	stz $7f80	                stz hist_buff+$380
.805e						xt_abort:
.805e						w_abort:
.805e		a2 78		ldx #$78	                ldx #dsp0
.8060						xt_quit:
.8060						w_quit:
.8060		8a		txa		                txa             ; Save the DSP that we just defined
.8061		a2 ff		ldx #$ff	                ldx #rsp0
.8063		9a		txs		                txs
.8064		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8065		64 04		stz $04		                stz ip
.8067		64 05		stz $05		                stz ip+1
.8069		64 0a		stz $0a		                stz insrc
.806b		64 0b		stz $0b		                stz insrc+1
.806d		a9 00		lda #$00	                lda #0
.806f		a0 04		ldy #$04	                ldy #blk_offset
.8071		91 08		sta ($08),y	                sta (up),y
.8073		c8		iny		                iny
.8074		91 08		sta ($08),y	                sta (up),y
.8076		a9 fc		lda #$fc	                lda #(256-4)
.8078		85 1f		sta $1f		                sta loopctrl
.807a		64 1a		stz $1a		                stz state
.807c		64 1b		stz $1b		                stz state+1
.807e						_get_line:
.807e		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8080		85 0c		sta $0c		                sta cib
.8082		a9 02		lda #$02	                lda #>buffer0
.8084		85 0d		sta $0d		                sta cib+1
.8086		64 0e		stz $0e		                stz ciblen
.8088		64 0f		stz $0f		                stz ciblen+1
.808a		20 1e 8f	jsr $8f1e	                jsr w_refill           ; ( -- f )
.808d		b5 00		lda $00,x	                lda 0,x
.808f		d0 05		bne $8096	                bne _success
.8091		a9 06		lda #$06	                lda #err_refill
.8093		4c 9f d8	jmp $d89f	                jmp error
.8096						_success:
.8096		e8		inx		                inx                     ; drop
.8097		e8		inx		                inx
.8098		20 06 d8	jsr $d806	                jsr interpret
.809b		e0 78		cpx #$78	                cpx #dsp0
.809d		f0 05		beq $80a4	                beq _stack_ok
.809f		90 03		bcc $80a4	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a1		4c 9d d8	jmp $d89d	                jmp underflow_error
.80a4						_stack_ok:
.80a4		a5 1a		lda $1a		                lda state
.80a6		f0 02		beq $80aa	                beq _print
.80a8		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80aa						_print:
.80aa		20 ef d8	jsr $d8ef	                jsr print_string
.80ad		80 cf		bra $807e	                bra _get_line
.80af						z_cold:
.80af						z_abort:
.80af						z_quit:

;******  Processing file: platform/../words/core.asm

.80af						xt_abort_quote:
.80af						w_abort_quote:
.80af		20 b9 8f	jsr $8fb9	                jsr w_s_quote          ; S"
.80b2		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b4		a9 ba		lda #$ba	                lda #<abort_quote_runtime
.80b6		20 ad 97	jsr $97ad	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b9		60		rts		z_abort_quote:  rts
.80ba						abort_quote_runtime:
.80ba		b5 04		lda $04,x	                lda 4,x
.80bc		15 05		ora $05,x	                ora 5,x
.80be		f0 09		beq $80c9	                beq _done       ; if FALSE, we're done
.80c0		20 bb 94	jsr $94bb	                jsr w_type
.80c3		20 05 84	jsr $8405	                jsr w_cr
.80c6		4c 5e 80	jmp $805e	                jmp w_abort    ; not JSR, so never come back
.80c9						_done:
.80c9		8a		txa		                txa
.80ca		18		clc		                clc
.80cb		69 06		adc #$06	                adc #6
.80cd		aa		tax		                tax
.80ce		60		rts		                rts
.80cf						xt_abs:
.80cf		20 89 d8	jsr $d889	                jsr underflow_1
.80d2						w_abs:
.80d2		b5 01		lda $01,x	                lda 1,x
.80d4		10 0d		bpl $80e3	                bpl _done       ; positive number, easy money!
.80d6		38		sec		                sec
.80d7		a9 00		lda #$00	                lda #0
.80d9		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80db		95 00		sta $00,x	                sta 0,x
.80dd		a9 00		lda #$00	                lda #0          ; MSB
.80df		f5 01		sbc $01,x	                sbc 1,x
.80e1		95 01		sta $01,x	                sta 1,x
.80e3						_done:
.80e3		60		rts		z_abs:          rts
.80e4						xt_accept:
.80e4		20 8e d8	jsr $d88e	                jsr underflow_2
.80e7						w_accept:
.80e7		b5 00		lda $00,x	                lda 0,x
.80e9		15 01		ora $01,x	                ora 1,x
.80eb		d0 09		bne $80f6	                bne _not_zero
.80ed		e8		inx		                inx
.80ee		e8		inx		                inx
.80ef		74 00		stz $00,x	                stz 0,x
.80f1		74 01		stz $01,x	                stz 1,x
.80f3		4c c2 81	jmp $81c2	                jmp accept_done
.80f6						_not_zero:
.80f6		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f8		85 27		sta $27		                sta tmp2
.80fa		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fc		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fe		85 25		sta $25		                sta tmp1
.8100		b5 03		lda $03,x	                lda 3,x
.8102		85 26		sta $26		                sta tmp1+1
.8104		e8		inx		                inx
.8105		e8		inx		                inx
.8106		a0 00		ldy #$00	                ldy #0
.8108		a5 1c		lda $1c		                lda status
.810a		29 f7		and #$f7	                and #$F7
.810c		1a		inc a		                ina
.810d		09 08		ora #$08	                ora #%00001000
.810f		85 1c		sta $1c		                sta status
.8111						accept_loop:
.8111		20 8a 89	jsr $898a	                jsr key_a
.8114		c9 0a		cmp #$0a	                cmp #AscLF
.8116		f0 20		beq $8138	                beq _eol
.8118		c9 0d		cmp #$0d	                cmp #AscCR
.811a		f0 1c		beq $8138	                beq _eol
.811c		c9 08		cmp #$08	                cmp #AscBS
.811e		f0 22		beq $8142	                beq _backspace
.8120		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8122		f0 1e		beq $8142	                beq _backspace
.8124		c9 10		cmp #$10	                cmp #AscCP
.8126		f0 36		beq $815e	                beq _ctrl_p
.8128		c9 0e		cmp #$0e	                cmp #AscCN
.812a		f0 44		beq $8170	                beq _ctrl_n
.812c		91 25		sta ($25),y	                sta (tmp1),y
.812e		c8		iny		                iny
.812f		20 93 86	jsr $8693	                jsr emit_a
.8132		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8134		d0 db		bne $8111	                bne accept_loop       ; fall through if buffer limit reached
.8136		80 03		bra $813b	                bra _buffer_full
.8138						_eol:
.8138		20 bc 91	jsr $91bc	                jsr w_space    ; print final space
.813b						_buffer_full:
.813b		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813d		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813f		4c c2 81	jmp $81c2	                jmp accept_done
.8142						_backspace:
.8142		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8144		d0 06		bne $814c	                bne +
.8146		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8148		20 93 86	jsr $8693	                jsr emit_a
.814b		c8		iny		                iny
.814c						+
.814c		88		dey		                dey
.814d		a9 08		lda #$08	                lda #AscBS      ; move back one
.814f		20 93 86	jsr $8693	                jsr emit_a
.8152		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8154		20 93 86	jsr $8693	                jsr emit_a
.8157		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8159		20 93 86	jsr $8693	                jsr emit_a
.815c		80 b3		bra $8111	                bra accept_loop
.815e						_ctrl_p:
.815e		a5 1c		lda $1c		                lda status
.8160		29 07		and #$07	                and #7
.8162		d0 08		bne $816c	                bne _ctrl_p_dec
.8164		a5 1c		lda $1c		                lda status
.8166		09 07		ora #$07	                ora #7
.8168		85 1c		sta $1c		                sta status
.816a		80 11		bra $817d	                bra _recall_history
.816c						_ctrl_p_dec:
.816c		c6 1c		dec $1c		                dec status
.816e		80 0d		bra $817d	                bra _recall_history
.8170						_ctrl_n:
.8170		a9 08		lda #$08	                lda #$8
.8172		24 1c		bit $1c		                bit status
.8174		d0 07		bne $817d	                bne _recall_history
.8176		a5 1c		lda $1c		                lda status
.8178		29 f7		and #$f7	                and #$F7
.817a		1a		inc a		               ina
.817b		85 1c		sta $1c		                sta status
.817d						_recall_history:
.817d		a9 08		lda #$08	                lda #%00001000
.817f		14 1c		trb $1c		                trb status
.8181		20 dd 81	jsr $81dd	                jsr accept_total_recall
.8184		a9 0d		lda #$0d	                lda #AscCR
.8186		20 93 86	jsr $8693	                jsr emit_a
.8189						input_clear:
.8189		c0 00		cpy #$00	                cpy #0
.818b		f0 08		beq $8195	                beq input_cleared
.818d		a9 20		lda #$20	                lda #AscSP
.818f		20 93 86	jsr $8693	                jsr emit_a
.8192		88		dey		                dey
.8193		80 f4		bra $8189	                bra input_clear
.8195						input_cleared:
.8195		a9 0d		lda #$0d	                lda #AscCR
.8197		20 93 86	jsr $8693	                jsr emit_a
.819a		b1 29		lda ($29),y	                lda (tmp3),y
.819c		85 1d		sta $1d		                sta status+1
.819e		e6 29		inc $29		                inc tmp3
.81a0		d0 02		bne $81a4	                bne +           ; Increment the upper byte on carry.
.81a2		e6 2a		inc $2a		                inc tmp3+1
.81a4						+
.81a4		a9 0d		lda #$0d	                lda #AscCR
.81a6		20 93 86	jsr $8693	                jsr emit_a
.81a9						_history_loop:
.81a9		c4 1d		cpy $1d		                cpy status+1
.81ab		d0 03		bne $81b0	                bne +
.81ad		4c 11 81	jmp $8111	                jmp accept_loop       ; Needs a long jump
.81b0						+
.81b0		c4 27		cpy $27		                cpy tmp2
.81b2		f0 0a		beq $81be	                beq _hist_filled_buffer
.81b4		b1 29		lda ($29),y	                lda (tmp3),y
.81b6		91 25		sta ($25),y	                sta (tmp1),y
.81b8		20 93 86	jsr $8693	                jsr emit_a
.81bb		c8		iny		                iny
.81bc		80 eb		bra $81a9	                bra _history_loop
.81be						_hist_filled_buffer:
.81be		88		dey		                dey
.81bf		4c 11 81	jmp $8111	                jmp accept_loop
.81c2						accept_done:
.81c2		20 dd 81	jsr $81dd	                jsr accept_total_recall
.81c5		85 1d		sta $1d		                sta status+1
.81c7		a0 00		ldy #$00	                ldy #0
.81c9		91 29		sta ($29),y	                sta (tmp3),y
.81cb		e6 29		inc $29		                inc tmp3
.81cd		d0 02		bne $81d1	                bne +           ; Increment the upper byte on carry.
.81cf		e6 2a		inc $2a		                inc tmp3+1
.81d1						+
.81d1						_save_history_loop:
.81d1		c4 1d		cpy $1d		                cpy status+1
.81d3		f0 07		beq $81dc	                beq _save_history_done
.81d5		b1 25		lda ($25),y	                lda (tmp1),y
.81d7		91 29		sta ($29),y	                sta (tmp3),y
.81d9		c8		iny		                iny
.81da		80 f5		bra $81d1	                bra _save_history_loop
.81dc						_save_history_done:
.81dc						z_accept:
.81dc		60		rts		                rts
.81dd						accept_total_recall:
.81dd		a9 00		lda #$00	                lda #<hist_buff
.81df		85 29		sta $29		                sta tmp3
.81e1		a9 7c		lda #$7c	                lda #>hist_buff
.81e3		85 2a		sta $2a		                sta tmp3+1
.81e5		a5 1c		lda $1c		                lda status
.81e7		6a		ror a		                ror
.81e8		29 03		and #$03	                and #3
.81ea		18		clc		                clc
.81eb		65 2a		adc $2a		                adc tmp3+1
.81ed		85 2a		sta $2a		                sta tmp3+1
.81ef		a5 1c		lda $1c		                lda status
.81f1		6a		ror a		                ror             ; Rotate through carry into msb.
.81f2		6a		ror a		                ror
.81f3		29 80		and #$80	                and #$80
.81f5		18		clc		                clc
.81f6		65 29		adc $29		                adc tmp3
.81f8		85 29		sta $29		                sta tmp3
.81fa		90 02		bcc $81fe	                bcc +           ; Increment the upper byte on carry.
.81fc		e6 2a		inc $2a		                inc tmp3+1
.81fe						+
.81fe		98		tya		                tya
.81ff		c9 80		cmp #$80	                cmp #$80
.8201		90 02		bcc $8205	                bcc +
.8203		a9 7f		lda #$7f	                lda #$7F
.8205						+
.8205		60		rts		                rts
.8206						xt_action_of:
.8206						w_action_of:
.8206		a5 1a		lda $1a		                lda state
.8208		05 1b		ora $1b		                ora state+1
.820a		f0 0c		beq $8218	                beq _interpreting
.820c		20 14 83	jsr $8314	                jsr w_bracket_tick
.820f		a0 85		ldy #$85	                ldy #>w_defer_fetch
.8211		a9 07		lda #$07	                lda #<w_defer_fetch
.8213		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.8216		80 06		bra $821e	                bra _done
.8218						_interpreting:
.8218		20 36 92	jsr $9236	                jsr w_tick
.821b		20 07 85	jsr $8507	                jsr w_defer_fetch
.821e						_done:
.821e		60		rts		z_action_of:           rts
.821f						xt_again:
.821f		20 89 d8	jsr $d889	                jsr underflow_1
.8222						w_again:
.8222		20 9e 97	jsr $979e	                jsr cmpl_jump_tos
.8225		60		rts		z_again:        rts
.8226						xt_align:
.8226						xt_aligned:
.8226						w_align:
.8226						w_aligned:
.8226						z_align:
.8226						z_aligned:
.8226		60		rts		                rts             ; stripped out during native compile
.8227						xt_allot:
.8227		20 89 d8	jsr $d889	                jsr underflow_1
.822a						w_allot:
.822a		b5 01		lda $01,x	                lda 1,x
.822c		30 22		bmi $8250	                bmi _release
.822e		18		clc		                clc
.822f		a5 00		lda $00		                lda cp
.8231		75 00		adc $00,x	                adc 0,x
.8233		85 00		sta $00		                sta cp
.8235		a5 01		lda $01		                lda cp+1
.8237		75 01		adc $01,x	                adc 1,x
.8239		85 01		sta $01		                sta cp+1
.823b		a0 00		ldy #$00	                ldy #<cp_end
.823d		c4 00		cpy $00		                cpy cp
.823f		a9 7c		lda #$7c	                lda #>cp_end
.8241		e5 01		sbc $01		                sbc cp+1
.8243		b0 48		bcs $828d	                bcs _done               ; we're fine.
.8245		84 00		sty $00		                sty cp                  ; still #<cp_end
.8247		a9 7c		lda #$7c	                lda #>cp_end
.8249		85 01		sta $01		                sta cp+1
.824b		a9 00		lda #$00	                lda #err_allot
.824d		4c 9f d8	jmp $d89f	                jmp error
.8250						_release:
.8250		ca		dex		                dex
.8251		ca		dex		                dex
.8252		a5 00		lda $00		                lda cp
.8254		95 00		sta $00,x	                sta 0,x
.8256		a5 01		lda $01		                lda cp+1
.8258		95 01		sta $01,x	                sta 1,x
.825a		20 32 8e	jsr $8e32	                jsr w_plus                     ; new CP is now TOS
.825d		ca		dex		                dex
.825e		ca		dex		                dex                             ; new CP now NOS
.825f		a9 00		lda #$00	                lda #<cp0
.8261		95 00		sta $00,x	                sta 0,x
.8263		a9 03		lda #$03	                lda #>cp0
.8265		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8267		20 c7 d7	jsr $d7c7	                jsr compare_16bit               ; still ( CP CP0 )
.826a		f0 17		beq $8283	                beq _nega_done
.826c		30 15		bmi $8283	                bmi _nega_done
.826e		a9 00		lda #$00	                lda #<cp0
.8270		85 00		sta $00		                sta cp
.8272		a9 03		lda #$03	                lda #>cp0
.8274		85 01		sta $01		                sta cp+1
.8276		a9 15		lda #$15	                lda #<dictionary_start
.8278		85 02		sta $02		                sta dp
.827a		a9 bc		lda #$bc	                lda #>dictionary_start
.827c		85 03		sta $03		                sta dp+1
.827e		a9 0a		lda #$0a	                lda #err_negallot
.8280		4c 9f d8	jmp $d89f	                jmp error
.8283						_nega_done:
.8283		b5 02		lda $02,x	                lda 2,x
.8285		85 00		sta $00		                sta cp
.8287		b5 03		lda $03,x	                lda 3,x
.8289		85 01		sta $01		                sta cp+1
.828b		e8		inx		                inx
.828c		e8		inx		                inx                     ; drop through to _done
.828d						_done:
.828d		e8		inx		                inx
.828e		e8		inx		                inx
.828f						z_allot:
.828f		60		rts		                rts
.8290						xt_and:
.8290		20 8e d8	jsr $d88e	                jsr underflow_2
.8293						w_and:
.8293		b5 00		lda $00,x	                lda 0,x
.8295		35 02		and $02,x	                and 2,x
.8297		95 02		sta $02,x	                sta 2,x
.8299		b5 01		lda $01,x	                lda 1,x
.829b		35 03		and $03,x	                and 3,x
.829d		95 03		sta $03,x	                sta 3,x
.829f		e8		inx		                inx
.82a0		e8		inx		                inx
.82a1		60		rts		z_and:          rts
.82a2						xt_at_xy:
.82a2		20 8e d8	jsr $d88e	                jsr underflow_2
.82a5						w_at_xy:
.82a5		a5 18		lda $18		                lda base
.82a7		48		pha		                pha
.82a8		a9 0a		lda #$0a	                lda #10
.82aa		85 18		sta $18		                sta base
.82ac		a9 1b		lda #$1b	                lda #AscESC
.82ae		20 93 86	jsr $8693	                jsr emit_a
.82b1		a9 5b		lda #$5b	                lda #'['
.82b3		20 93 86	jsr $8693	                jsr emit_a
.82b6		20 c8 8c	jsr $8cc8	                jsr w_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82b9		20 f5 d8	jsr $d8f5	                jsr print_u
.82bc		a9 3b		lda #$3b	                lda #';'
.82be		20 93 86	jsr $8693	                jsr emit_a
.82c1		20 c8 8c	jsr $8cc8	                jsr w_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c4		20 f5 d8	jsr $d8f5	                jsr print_u
.82c7		a9 48		lda #$48	                lda #'H'
.82c9		20 93 86	jsr $8693	                jsr emit_a
.82cc		68		pla		                pla
.82cd		85 18		sta $18		                sta base
.82cf		60		rts		z_at_xy:        rts
.82d0						xt_backslash:
.82d0						w_backslash:
.82d0		a0 04		ldy #$04	                ldy #blk_offset
.82d2		b1 08		lda ($08),y	                lda (up),y
.82d4		c8		iny		                iny
.82d5		11 08		ora ($08),y	                ora (up),y
.82d7		f0 19		beq $82f2	                beq backslash_not_block
.82d9		a5 10		lda $10		                lda toin
.82db		29 3f		and #$3f	                and #$3F
.82dd		f0 1b		beq $82fa	                beq z_backslash
.82df		c9 01		cmp #$01	                cmp #$1
.82e1		f0 17		beq $82fa	                beq z_backslash
.82e3		a5 10		lda $10		                lda toin
.82e5		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82e7		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82e8		69 40		adc #$40	                adc #$40
.82ea		85 10		sta $10		                sta toin
.82ec		90 0c		bcc $82fa	                bcc z_backslash
.82ee		e6 11		inc $11		                inc toin+1
.82f0		80 08		bra $82fa	                bra z_backslash
.82f2						backslash_not_block:
.82f2		a5 0e		lda $0e		                lda ciblen
.82f4		85 10		sta $10		                sta toin
.82f6		a5 0f		lda $0f		                lda ciblen+1
.82f8		85 11		sta $11		                sta toin+1
.82fa		60		rts		z_backslash:    rts
.82fb						xt_base:
.82fb						w_base:
.82fb		ca		dex		                dex
.82fc		ca		dex		                dex
.82fd		a9 18		lda #$18	                lda #<base
.82ff		95 00		sta $00,x	                sta 0,x         ; LSB
.8301		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8303		60		rts		z_base:         rts
.8304						xt_bl:
.8304						w_bl:
.8304		ca		dex		                dex
.8305		ca		dex		                dex
.8306		a9 20		lda #$20	                lda #AscSP
.8308		95 00		sta $00,x	                sta 0,x
.830a		74 01		stz $01,x	                stz 1,x
.830c		60		rts		z_bl:           rts
.830d						xt_bracket_char:
.830d						w_bracket_char:
.830d		20 53 83	jsr $8353	                jsr w_char
.8310		20 e0 89	jsr $89e0	                jsr w_literal
.8313		60		rts		z_bracket_char: rts
.8314						xt_bracket_tick:
.8314						w_bracket_tick:
.8314		20 36 92	jsr $9236	                jsr w_tick
.8317		20 e0 89	jsr $89e0	                jsr w_literal
.831a		60		rts		z_bracket_tick: rts
.831b						xt_buffer_colon:
.831b						w_buffer_colon:
.831b		20 0b 84	jsr $840b	                jsr w_create
.831e		20 2a 82	jsr $822a	                jsr w_allot
.8321		60		rts		z_buffer_colon: rts
.8322						xt_c_comma:
.8322		20 89 d8	jsr $d889	                jsr underflow_1
.8325						w_c_comma:
.8325		b5 00		lda $00,x	                lda 0,x
.8327		20 b8 97	jsr $97b8	                jsr cmpl_a
.832a		e8		inx		                inx
.832b		e8		inx		                inx
.832c		60		rts		z_c_comma:      rts
.832d						xt_c_fetch:
.832d		20 89 d8	jsr $d889	                jsr underflow_1
.8330						w_c_fetch:
.8330		a1 00		lda ($00,x)	                lda (0,x)
.8332		95 00		sta $00,x	                sta 0,x
.8334		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8336		60		rts		z_c_fetch:      rts
.8337						xt_c_store:
.8337		20 8e d8	jsr $d88e	                jsr underflow_2
.833a						w_c_store:
.833a		b5 02		lda $02,x	                lda 2,x
.833c		81 00		sta ($00,x)	                sta (0,x)
.833e		e8		inx		                inx
.833f		e8		inx		                inx
.8340		e8		inx		                inx
.8341		e8		inx		                inx
.8342		60		rts		z_c_store:      rts
.8343						xt_cell_plus:
.8343		20 89 d8	jsr $d889	                jsr underflow_1
.8346						w_cell_plus:
.8346		f6 00		inc $00,x	                inc 0,x
.8348		d0 02		bne $834c	                bne +
.834a		f6 01		inc $01,x	                inc 1,x
.834c						+
.834c		f6 00		inc $00,x	                inc 0,x
.834e		d0 02		bne $8352	                bne _done
.8350		f6 01		inc $01,x	                inc 1,x
.8352						_done:
.8352		60		rts		z_cell_plus:    rts
.8353						xt_char:
.8353						w_char:
.8353		20 2d 8d	jsr $8d2d	                jsr w_parse_name
.8356		b5 00		lda $00,x	                lda 0,x
.8358		15 01		ora $01,x	                ora 1,x
.835a		d0 05		bne $8361	                bne _not_empty
.835c		a9 05		lda #$05	                lda #err_noname
.835e		4c 9f d8	jmp $d89f	                jmp error
.8361						_not_empty:
.8361		e8		inx		                inx             ; drop number of characters, leave addr
.8362		e8		inx		                inx
.8363		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8365		95 00		sta $00,x	                sta 0,x
.8367		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8369		60		rts		z_char:         rts
.836a						xt_chars:
.836a		20 89 d8	jsr $d889	                jsr underflow_1
.836d						w_chars:
.836d		60		rts		z_chars:        rts
.836e						xt_colon:
.836e						w_colon:
.836e		a5 1a		lda $1a		                lda state
.8370		05 1b		ora $1b		                ora state+1
.8372		f0 05		beq $8379	                beq +
.8374		a9 07		lda #$07	                lda #err_state
.8376		4c 9f d8	jmp $d89f	                jmp error
.8379						+
.8379		c6 1a		dec $1a		                dec state
.837b		c6 1b		dec $1b		                dec state+1
.837d		a9 d0		lda #$d0	                lda #%11010000
.837f		04 1c		tsb $1c		                tsb status
.8381		a5 00		lda $00		                lda cp
.8383		85 06		sta $06		                sta workword
.8385		a5 01		lda $01		                lda cp+1
.8387		85 07		sta $07		                sta workword+1
.8389		a0 00		ldy #$00	                ldy #0                  ; Tell CREATE we want neither CFA nor dictionary update
.838b		20 0f 84	jsr $840f	                jsr create_common
.838e		60		rts		z_colon:        rts
.838f						xt_colon_noname:
.838f						w_colon_noname:
.838f		a5 1a		lda $1a		                lda state
.8391		05 1b		ora $1b		                ora state+1
.8393		f0 05		beq $839a	                beq +
.8395		a9 07		lda #$07	                lda #err_state
.8397		4c 9f d8	jmp $d89f	                jmp error
.839a						+
.839a		c6 1a		dec $1a		                dec state
.839c		c6 1b		dec $1b		                dec state+1
.839e		a9 40		lda #$40	                lda #%01000000
.83a0		14 1c		trb $1c		                trb status
.83a2		a5 00		lda $00		                lda cp
.83a4		85 06		sta $06		                sta workword
.83a6		a5 01		lda $01		                lda cp+1
.83a8		85 07		sta $07		                sta workword+1
.83aa		60		rts		z_colon_noname:        rts
.83ab						xt_comma:
.83ab		20 89 d8	jsr $d889	                jsr underflow_1
.83ae						w_comma:
.83ae		a0 02		ldy #$02	                ldy #2
.83b0		b5 00		lda $00,x	_twice:         lda 0,x
.83b2		20 b8 97	jsr $97b8	                jsr cmpl_a
.83b5		e8		inx		                inx
.83b6		88		dey		                dey
.83b7		d0 f7		bne $83b0	                bne _twice
.83b9		60		rts		z_comma:        rts
.83ba						xt_compile_only:
.83ba						w_compile_only:
.83ba		20 e0 d7	jsr $d7e0	                jsr current_to_dp
.83bd		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.83bf		b1 02		lda ($02),y	                lda (dp),y
.83c1		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.83c3		91 02		sta ($02),y	                sta (dp),y
.83c5		60		rts		z_compile_only: rts
.83c6						xt_value:
.83c6						xt_constant:
.83c6		20 89 d8	jsr $d889	                jsr underflow_1
.83c9						w_value:
.83c9						w_constant:
.83c9		a9 f1		lda #$f1	                lda #<doconst           ; LSB of DOCONST
.83cb		a0 d6		ldy #$d6	                ldy #>doconst           ; MSB of DOCONST
.83cd		20 0f 84	jsr $840f	                jsr create_common
.83d0		20 ae 83	jsr $83ae	                jsr w_comma            ; drop through to adjust_z
.83d3						adjust_z:
.83d3		20 6e 9c	jsr $9c6e	                jsr w_latestnt         ; gives us ( -- nt )
.83d6		b5 00		lda $00,x	                lda 0,x
.83d8		85 25		sta $25		                sta tmp1
.83da		b5 01		lda $01,x	                lda 1,x
.83dc		85 26		sta $26		                sta tmp1+1
.83de		a0 06		ldy #$06	                ldy #6
.83e0		b1 25		lda ($25),y	                lda (tmp1),y
.83e2		18		clc		                clc
.83e3		69 02		adc #$02	                adc #2
.83e5		91 25		sta ($25),y	                sta (tmp1),y
.83e7		c8		iny		                iny
.83e8		b1 25		lda ($25),y	                lda (tmp1),y
.83ea		69 00		adc #$00	                adc #0                  ; only need carry
.83ec		91 25		sta ($25),y	                sta (tmp1),y
.83ee		e8		inx		                inx
.83ef		e8		inx		                inx
.83f0						z_value:
.83f0		60		rts		z_constant:     rts
.83f1						xt_count:
.83f1		20 89 d8	jsr $d889	                jsr underflow_1
.83f4						w_count:
.83f4		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.83f6		a8		tay		                tay
.83f7		f6 00		inc $00,x	                inc 0,x         ; LSB
.83f9		d0 02		bne $83fd	                bne +
.83fb		f6 01		inc $01,x	                inc 1,x         ; MSB
.83fd		98		tya		+               tya
.83fe		ca		dex		                dex
.83ff		ca		dex		                dex
.8400		95 00		sta $00,x	                sta 0,x         ; LSB
.8402		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8404		60		rts		z_count:        rts
.8405						xt_cr:
.8405						w_cr:
.8405		a9 0a		lda #$0a	                lda #AscLF
.8407		20 93 86	jsr $8693	                jsr emit_a
.840a		60		rts		z_cr:           rts
.840b						xt_create:
.840b						w_create:
.840b		a0 d7		ldy #$d7	                ldy #>dovar
.840d		a9 37		lda #$37	                lda #<dovar
.840f						create_common:
.840f		ca		dex		                dex
.8410		ca		dex		                dex
.8411		95 00		sta $00,x	                sta 0,x
.8413		94 01		sty $01,x	                sty 1,x
.8415		20 2d 8d	jsr $8d2d	                jsr w_parse_name        ; ( cfa addr u )
.8418		b5 00		lda $00,x	                lda 0,x
.841a		15 01		ora $01,x	                ora 1,x
.841c		d0 05		bne $8423	                bne _got_name
.841e		a9 05		lda #$05	                lda #err_noname
.8420		4c 9f d8	jmp $d89f	                jmp error
.8423						_got_name:
.8423		74 01		stz $01,x	                stz 1,x
.8425		20 a6 93	jsr $93a6	                jsr w_two_dup           ; ( cfa addr u addr u )
.8428		20 3d 9b	jsr $9b3d	                jsr w_find_name         ; ( cfa addr u flag ) (non-zero nt as flag)
.842b		e8		inx		                inx                     ; pre-drop flag (nt) from find-name.
.842c		e8		inx		                inx
.842d		b5 fe		lda $fe,x	                lda $fe,x
.842f		15 ff		ora $ff,x	                ora $ff,x
.8431		f0 1a		beq $844d	                beq _new_name           ; We haven't seen this one before.
.8433		24 1c		bit $1c		                bit status
.8435		10 06		bpl $843d	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8437		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8439		04 1c		tsb $1c		                tsb status
.843b		80 14		bra $8451	                bra _process_name
.843d						_redefined_name:
.843d		a9 02		lda #$02	                lda #str_redefined
.843f		20 c5 d8	jsr $d8c5	                jsr print_string_no_lf
.8442		20 a6 93	jsr $93a6	                jsr w_two_dup           ; ( cfa addr u addr u )
.8445		20 bb 94	jsr $94bb	                jsr w_type
.8448		20 bc 91	jsr $91bc	                jsr w_space
.844b		80 04		bra $8451	                bra _process_name
.844d						_new_name:
.844d		a9 80		lda #$80	                lda #$80                ; Clear status bit 7 to indicate new word.
.844f		14 1c		trb $1c		                trb status
.8451						_process_name:
.8451		a5 00		lda $00		                lda cp
.8453		85 25		sta $25		                sta tmp1
.8455		a5 01		lda $01		                lda cp+1
.8457		85 26		sta $26		                sta tmp1+1
.8459		b5 00		lda $00,x	                lda 0,x
.845b		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.845d		18		clc		                clc
.845e		69 08		adc #$08	                adc #8
.8460		85 28		sta $28		                sta tmp2+1               ; total header length
.8462		95 00		sta $00,x	                sta 0,x
.8464		74 01		stz $01,x	                stz 1,x                 ; max header size is 255 chars
.8466		20 2a 82	jsr $822a	                jsr w_allot
.8469		20 e0 d7	jsr $d7e0	                jsr current_to_dp
.846c		a0 00		ldy #$00	                ldy #0
.846e		a5 27		lda $27		                lda tmp2
.8470		91 25		sta ($25),y	                sta (tmp1),y
.8472		c8		iny		                iny
.8473		b5 03		lda $03,x	                lda 3,x                 ; check MSB of CFA
.8475		f0 02		beq $8479	                beq +                   ; 0 means no CFA, leave A=0
.8477		a9 10		lda #$10	                lda #HC                 ; otherwise set the HC bit
.8479						+
.8479		09 08		ora #$08	                ora #NN
.847b		91 25		sta ($25),y	                sta (tmp1),y
.847d		c8		iny		                iny
.847e		a5 02		lda $02		                lda dp
.8480		91 25		sta ($25),y	                sta (tmp1),y
.8482		c8		iny		                iny
.8483		a5 03		lda $03		                lda dp+1
.8485		91 25		sta ($25),y	                sta (tmp1),y
.8487		c8		iny		                iny
.8488		b5 03		lda $03,x	                lda 3,x
.848a		f0 08		beq $8494	                beq +
.848c		a5 26		lda $26		                lda tmp1+1
.848e		85 03		sta $03		                sta dp+1
.8490		a5 25		lda $25		                lda tmp1
.8492		85 02		sta $02		                sta dp
.8494						+
.8494		18		clc		                clc
.8495		a5 25		lda $25		                lda tmp1                ; redundant unless we skipped interlude
.8497		65 28		adc $28		                adc tmp2+1              ; add total header length
.8499		91 25		sta ($25),y	                sta (tmp1),y
.849b		85 23		sta $23		                sta tmptos              ; save result for next step
.849d		c8		iny		                iny
.849e		a5 26		lda $26		                lda tmp1+1
.84a0		69 00		adc #$00	                adc #0                  ; only need the carry
.84a2		91 25		sta ($25),y	                sta (tmp1),y
.84a4		85 24		sta $24		                sta tmptos+1
.84a6		c8		iny		                iny
.84a7		b5 03		lda $03,x	                lda 3,x
.84a9		f0 02		beq $84ad	                beq +                   ; leave A=0
.84ab		a9 03		lda #$03	                lda #3
.84ad						+
.84ad		18		clc		                clc
.84ae		65 23		adc $23		                adc tmptos              ; add LSB of xt_
.84b0		91 25		sta ($25),y	                sta (tmp1),y
.84b2		c8		iny		                iny
.84b3		a5 24		lda $24		                lda tmptos+1            ; recall MSB of xt_
.84b5		69 00		adc #$00	                adc #0                  ; only need the carry
.84b7		91 25		sta ($25),y	                sta (tmp1),y
.84b9		c8		iny		                iny
.84ba		b5 00		lda $00,x	                lda 0,x
.84bc		38		sec		                sec
.84bd		e9 08		sbc #$08	                sbc #8
.84bf		85 23		sta $23		                sta tmptos
.84c1		b5 01		lda $01,x	                lda 1,x
.84c3		e9 00		sbc #$00	                sbc #0          ; only need carry
.84c5		85 24		sta $24		                sta tmptos+1
.84c7						_name_loop:
.84c7		b1 23		lda ($23),y	                lda (tmptos),y
.84c9		c9 5b		cmp #$5b	                cmp #'Z'+1
.84cb		b0 06		bcs $84d3	                bcs _store_name
.84cd		c9 41		cmp #$41	                cmp #'A'
.84cf		90 02		bcc $84d3	                bcc _store_name
.84d1		09 20		ora #$20	                ora #$20
.84d3						_store_name:
.84d3		91 25		sta ($25),y	                sta (tmp1),y
.84d5		c8		iny		                iny
.84d6		c6 27		dec $27		                dec tmp2
.84d8		d0 ed		bne $84c7	                bne _name_loop
.84da		b4 03		ldy $03,x	                ldy 3,x
.84dc		f0 08		beq $84e6	                beq +
.84de		b5 02		lda $02,x	                lda 2,x
.84e0		20 ad 97	jsr $97ad	                jsr cmpl_subroutine             ; Add the CFA jsr
.84e3		20 f3 d7	jsr $d7f3	                jsr dp_to_current
.84e6						+
.84e6		e8		inx		                inx
.84e7		e8		inx		                inx
.84e8		e8		inx		                inx
.84e9		e8		inx		                inx
.84ea		60		rts		z_create:       rts
.84eb						xt_decimal:
.84eb						w_decimal:
.84eb		a9 0a		lda #$0a	                lda #10
.84ed		85 18		sta $18		                sta base
.84ef		64 19		stz $19		                stz base+1              ; paranoid
.84f1		60		rts		z_decimal:      rts
.84f2						xt_defer:
.84f2						w_defer:
.84f2		a9 05		lda #$05	                lda #<dodefer   ; LSB
.84f4		a0 d7		ldy #$d7	                ldy #>dodefer   ; MSB
.84f6		20 0f 84	jsr $840f	                jsr create_common
.84f9		a9 19		lda #$19	                lda #<defer_error
.84fb		a0 d7		ldy #$d7	                ldy #>defer_error
.84fd		20 b4 97	jsr $97b4	                jsr cmpl_word
.8500		20 d3 83	jsr $83d3	                jsr adjust_z    ; adjust header by two to correct length
.8503		60		rts		z_defer:        rts
.8504						xt_defer_fetch:
.8504		20 89 d8	jsr $d889	                jsr underflow_1
.8507						w_defer_fetch:
.8507		20 95 92	jsr $9295	                jsr w_to_body
.850a		20 f6 87	jsr $87f6	                jsr w_fetch
.850d		60		rts		z_defer_fetch:  rts
.850e						xt_defer_store:
.850e		20 8e d8	jsr $d88e	                jsr underflow_2
.8511						w_defer_store:
.8511		20 95 92	jsr $9295	                jsr w_to_body
.8514		20 0f 92	jsr $920f	                jsr w_store
.8517		60		rts		z_defer_store:  rts
.8518						xt_depth:
.8518						w_depth:
.8518		a9 78		lda #$78	                lda #dsp0
.851a		86 1e		stx $1e		                stx tmpdsp
.851c		38		sec		                sec
.851d		e5 1e		sbc $1e		                sbc tmpdsp
.851f		4a		lsr a		                lsr
.8520		ca		dex		                dex
.8521		ca		dex		                dex
.8522		95 00		sta $00,x	                sta 0,x
.8524		74 01		stz $01,x	                stz 1,x
.8526		60		rts		z_depth:        rts
.8527						xt_question_do:
.8527						w_question_do:
.8527		ca		dex		                dex
.8528		ca		dex		                dex
.8529		a9 6a		lda #$6a	                lda #<question_do_runtime
.852b		95 00		sta $00,x	                sta 0,x
.852d		a9 85		lda #$85	                lda #>question_do_runtime
.852f		95 01		sta $01,x	                sta 1,x
.8531		20 69 86	jsr $8669	                jsr w_dup              ; xt and xt' are the same
.8534		ca		dex		                dex
.8535		ca		dex		                dex
.8536		a9 10		lda #$10	                lda #question_do_runtime_size
.8538		95 00		sta $00,x	                sta 0,x
.853a		74 01		stz $01,x	                stz 1,x
.853c		20 2b 97	jsr $972b	                jsr cmpl_by_limit
.853f		90 0b		bcc $854c	                bcc _native
.8541		20 f4 88	jsr $88f4	                jsr w_here
.8544		20 46 9e	jsr $9e46	                jsr w_zero
.8547		20 ae 83	jsr $83ae	                jsr w_comma
.854a		80 08		bra $8554	                bra do_common
.854c						_native:
.854c		20 8d 97	jsr $978d	                jsr cmpl_jump_later
.854f		80 03		bra $8554	                bra do_common
.8551						xt_do:
.8551						w_do:
.8551		20 46 9e	jsr $9e46	                jsr w_zero             ; push 0 TOS
.8554						do_common:
.8554		ca		dex		                dex
.8555		ca		dex		                dex
.8556		a5 21		lda $21		                lda loopleave
.8558		95 00		sta $00,x	                sta 0,x
.855a		a5 22		lda $22		                lda loopleave+1
.855c		95 01		sta $01,x	                sta 1,x
.855e		64 22		stz $22		                stz loopleave+1
.8560		a0 85		ldy #$85	                ldy #>do_runtime
.8562		a9 82		lda #$82	                lda #<do_runtime
.8564		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.8567		4c f4 88	jmp $88f4	                jmp w_here
.856a						z_question_do:
.856a						z_do:
.856a						question_do_runtime:
.856a		b5 00		lda $00,x	                lda 0,x
.856c		d5 02		cmp $02,x	                cmp 2,x
.856e		d0 0d		bne $857d	                bne _begin
.8570		b5 01		lda $01,x	                lda 1,x
.8572		d5 03		cmp $03,x	                cmp 3,x
.8574		d0 07		bne $857d	                bne _begin
.8576		e8		inx		                inx                     ; drop loop limits and skip
.8577		e8		inx		                inx
.8578		e8		inx		                inx
.8579		e8		inx		                inx
=16						question_do_runtime_size = * - question_do_runtime
.857a		a9 00		lda #$00	                lda #0
>857c		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.857d		a9 01		lda #$01	_begin:         lda #1
.857f		4c 50 98	jmp $9850	                jmp zbranch_runtime
.8582						do_runtime:
.8582		a4 1f		ldy $1f		                ldy loopctrl
.8584		30 05		bmi $858b	                bmi +                   ; is this the first LCB?
.8586		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.8588		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.858b						+
.858b		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.858c		c8		iny		                iny
.858d		c8		iny		                iny
.858e		c8		iny		                iny
.858f		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.8591		38		sec		                sec
.8592		a9 00		lda #$00	                lda #0
.8594		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.8596		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.8599		a9 80		lda #$80	                lda #$80
.859b		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.859d		99 03 01	sta $0103,y	                sta loopfufa+1,y
.85a0		18		clc		                clc
.85a1		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.85a3		79 02 01	adc $0102,y	                adc loopfufa,y
.85a6		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.85a8		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.85aa		79 03 01	adc $0103,y	                adc loopfufa+1,y
.85ad		99 01 01	sta $0101,y	                sta loopindex+1,y
.85b0		e8		inx		                inx                 ; clean up the stack
.85b1		e8		inx		                inx
.85b2		e8		inx		                inx
.85b3		e8		inx		                inx
.85b4		60		rts		                rts
.85b5						xt_does:
.85b5						w_does:
.85b5		a0 85		ldy #$85	                ldy #>does_runtime
.85b7		a9 c4		lda #$c4	                lda #<does_runtime
.85b9		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.85bc		a0 d7		ldy #$d7	                ldy #>dodoes
.85be		a9 1e		lda #$1e	                lda #<dodoes
.85c0		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.85c3		60		rts		z_does:         rts
.85c4						does_runtime:
.85c4		7a		ply		                ply             ; LSB
.85c5		68		pla		                pla             ; MSB
.85c6		c8		iny		                iny
.85c7		d0 01		bne $85ca	                bne +
.85c9		1a		inc a		                ina
.85ca						+
.85ca		84 25		sty $25		                sty tmp1
.85cc		85 26		sta $26		                sta tmp1+1
.85ce		20 e0 d7	jsr $d7e0	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.85d1		a5 02		lda $02		                lda dp
.85d3		18		clc		                clc
.85d4		69 04		adc #$04	                adc #4
.85d6		85 27		sta $27		                sta tmp2
.85d8		a5 03		lda $03		                lda dp+1
.85da		69 00		adc #$00	                adc #0          ; we only care about the carry
.85dc		85 28		sta $28		                sta tmp2+1
.85de		b2 27		lda ($27)	                lda (tmp2)
.85e0		18		clc		                clc
.85e1		69 01		adc #$01	                adc #1
.85e3		85 29		sta $29		                sta tmp3
.85e5		a0 01		ldy #$01	                ldy #1
.85e7		b1 27		lda ($27),y	                lda (tmp2),y
.85e9		69 00		adc #$00	                adc #0          ; we only care about the carry
.85eb		85 2a		sta $2a		                sta tmp3+1
.85ed		a5 25		lda $25		                lda tmp1        ; LSB
.85ef		92 29		sta ($29)	                sta (tmp3)
.85f1		a5 26		lda $26		                lda tmp1+1
.85f3		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.85f5		60		rts		                rts
.85f6						xt_dot:
.85f6		20 89 d8	jsr $d889	                jsr underflow_1
.85f9						w_dot:
.85f9		20 69 86	jsr $8669	                jsr w_dup                      ; ( n n )
.85fc		20 d2 80	jsr $80d2	                jsr w_abs                      ; ( n u )
.85ff		20 46 9e	jsr $9e46	                jsr w_zero                     ; ( n u 0 )
.8602		20 ba 89	jsr $89ba	                jsr w_less_number_sign         ; ( n u 0 )
.8605		20 92 8c	jsr $8c92	                jsr w_number_sign_s            ; ( n ud )
.8608		20 73 8f	jsr $8f73	                jsr w_rot                      ; ( ud n )
.860b		20 3f 91	jsr $913f	                jsr w_sign                     ; ( ud )
.860e		20 70 8c	jsr $8c70	                jsr w_number_sign_greater      ; ( addr u )
.8611		20 bb 94	jsr $94bb	                jsr w_type
.8614		20 bc 91	jsr $91bc	                jsr w_space
.8617		60		rts		z_dot:          rts
.8618						xt_dot_paren:
.8618						w_dot_paren:
.8618		ca		dex		                dex
.8619		ca		dex		                dex
.861a		a9 29		lda #$29	                lda #41     ; Right parenthesis
.861c		95 00		sta $00,x	                sta 0,x
.861e		74 01		stz $01,x	                stz 1,x
.8620		20 8b 8d	jsr $8d8b	                jsr w_parse
.8623		20 bb 94	jsr $94bb	                jsr w_type
.8626		60		rts		z_dot_paren:    rts
.8627						xt_dot_quote:
.8627						w_dot_quote:
.8627		20 b9 8f	jsr $8fb9	                jsr w_s_quote
.862a		a0 94		ldy #$94	                ldy #>w_type
.862c		a9 bb		lda #$bb	                lda #<w_type
.862e		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.8631		60		rts		z_dot_quote:    rts
.8632						xt_dot_r:
.8632		20 8e d8	jsr $d88e	                jsr underflow_2
.8635						w_dot_r:
.8635		20 60 93	jsr $9360	                jsr w_to_r
.8638		20 69 86	jsr $8669	                jsr w_dup
.863b		20 d2 80	jsr $80d2	                jsr w_abs
.863e		20 46 9e	jsr $9e46	                jsr w_zero
.8641		20 ba 89	jsr $89ba	                jsr w_less_number_sign
.8644		20 92 8c	jsr $8c92	                jsr w_number_sign_s
.8647		20 73 8f	jsr $8f73	                jsr w_rot
.864a		20 3f 91	jsr $913f	                jsr w_sign
.864d		20 70 8c	jsr $8c70	                jsr w_number_sign_greater
.8650		20 cc 8e	jsr $8ecc	                jsr w_r_from
.8653		20 e4 8c	jsr $8ce4	                jsr w_over
.8656		20 c4 8b	jsr $8bc4	                jsr w_minus
.8659		20 c5 91	jsr $91c5	                jsr w_spaces
.865c		20 bb 94	jsr $94bb	                jsr w_type
.865f		60		rts		z_dot_r:        rts
.8660						xt_drop:
.8660		20 89 d8	jsr $d889	                jsr underflow_1
.8663						w_drop:
.8663		e8		inx		                inx
.8664		e8		inx		                inx
.8665		60		rts		z_drop:         rts
.8666						xt_dup:
.8666		20 89 d8	jsr $d889	                jsr underflow_1
.8669						w_dup:
.8669		ca		dex		                dex
.866a		ca		dex		                dex
.866b		b5 02		lda $02,x	                lda 2,x         ; LSB
.866d		95 00		sta $00,x	                sta 0,x
.866f		b5 03		lda $03,x	                lda 3,x         ; MSB
.8671		95 01		sta $01,x	                sta 1,x
.8673		60		rts		z_dup:          rts
.8674						xt_else:
.8674						xt_endof:
.8674		20 89 d8	jsr $d889	                jsr underflow_1
.8677						w_else:
.8677						w_endof:
.8677		20 8d 97	jsr $978d	                jsr cmpl_jump_later
.867a		20 25 92	jsr $9225	                jsr w_swap              ; ( target orig )
.867d		80 03		bra $8682	                bra w_then              ; fall through to then
.867f						xt_then:
.867f		20 89 d8	jsr $d889	                jsr underflow_1
.8682						w_then:
.8682		20 f4 88	jsr $88f4	                jsr w_here
.8685		20 25 92	jsr $9225	                jsr w_swap
.8688		20 0f 92	jsr $920f	                jsr w_store
.868b						z_else:
.868b						z_endof:
.868b		60		rts		z_then:         rts
.868c						xt_emit:
.868c		20 89 d8	jsr $d889	                jsr underflow_1
.868f						w_emit:
.868f		b5 00		lda $00,x	                lda 0,x
.8691		e8		inx		                inx
.8692		e8		inx		                inx
.8693						emit_a:
.8693		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.8696						z_emit:
.8696						xt_endcase:
.8696		20 89 d8	jsr $d889	                jsr underflow_1
.8699						w_endcase:
.8699		a0 86		ldy #$86	                ldy #>w_drop
.869b		a9 63		lda #$63	                lda #<w_drop
.869d		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.86a0						_endcase_loop:
.86a0		b5 00		lda $00,x	                lda 0,x
.86a2		15 01		ora $01,x	                ora 1,x
.86a4		f0 05		beq $86ab	                beq _done
.86a6		20 82 86	jsr $8682	                jsr w_then
.86a9		80 f5		bra $86a0	                bra _endcase_loop
.86ab						_done:
.86ab		e8		inx		                inx
.86ac		e8		inx		                inx
.86ad		60		rts		z_endcase:      rts
.86ae						xt_environment_q:
.86ae		20 89 d8	jsr $d889	                jsr underflow_1
.86b1						w_environment_q:
.86b1		a0 00		ldy #$00	                ldy #00                 ; counter for table
.86b3		5a		phy		                phy
.86b4						_table_loop:
.86b4		20 a6 93	jsr $93a6	                jsr w_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.86b7		ca		dex		                dex
.86b8		ca		dex		                dex                     ; ( addr u addr u ? )
.86b9		b9 2b 87	lda $872b,y	                lda env_table_single,y
.86bc		95 00		sta $00,x	                sta 0,x
.86be		c8		iny		                iny
.86bf		b9 2b 87	lda $872b,y	                lda env_table_single,y
.86c2		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.86c4		c8		iny		                iny
.86c5		15 00		ora $00,x	                ora 0,x
.86c7		f0 4d		beq $8716	                beq _table_done
.86c9		5a		phy		                phy                     ; save Y, which is used by COUNT
.86ca		20 f4 83	jsr $83f4	                jsr w_count            ; ( addr u addr u addr-s u-s )
.86cd		20 77 a0	jsr $a077	                jsr w_compare          ; ( addr u f )
.86d0		7a		ply		                ply
.86d1		b5 00		lda $00,x	                lda 0,x
.86d3		15 01		ora $01,x	                ora 1,x
.86d5		f0 04		beq $86db	                beq _got_result
.86d7		e8		inx		                inx                     ; DROP, now ( addr u )
.86d8		e8		inx		                inx
.86d9		80 d9		bra $86b4	                bra _table_loop
.86db						_got_result:
.86db		e8		inx		                inx                     ; drop flag, now ( addr u )
.86dc		e8		inx		                inx
.86dd		88		dey		                dey                     ; go back to index we had
.86de		88		dey		                dey
.86df		68		pla		                pla
.86e0		d0 0d		bne $86ef	                bne _double_result
.86e2		b9 49 87	lda $8749,y	                lda env_results_single,y
.86e5		95 02		sta $02,x	                sta 2,x
.86e7		c8		iny		                iny
.86e8		b9 49 87	lda $8749,y	                lda env_results_single,y
.86eb		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.86ed		80 1f		bra $870e	                bra _set_flag
.86ef						_double_result:
.86ef		ca		dex		                dex                     ; ( addr u ? )
.86f0		ca		dex		                dex
.86f1		98		tya		                tya
.86f2		38		sec		                sec
.86f3		e9 18		sbc #$18	                sbc #24
.86f5		0a		asl a		                asl
.86f6		a8		tay		                tay
.86f7		b9 5f 87	lda $875f,y	                lda env_results_double,y
.86fa		95 02		sta $02,x	                sta 2,x
.86fc		c8		iny		                iny
.86fd		b9 5f 87	lda $875f,y	                lda env_results_double,y
.8700		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8702		c8		iny		                iny
.8703		b9 5f 87	lda $875f,y	                lda env_results_double,y
.8706		95 04		sta $04,x	                sta 4,x
.8708		c8		iny		                iny
.8709		b9 5f 87	lda $875f,y	                lda env_results_double,y
.870c		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.870e						_set_flag:
.870e		a9 ff		lda #$ff	                lda #$FF
.8710		95 00		sta $00,x	                sta 0,x
.8712		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8714		80 14		bra $872a	                bra _done
.8716						_table_done:
.8716		68		pla		                pla
.8717		d0 09		bne $8722	                bne _no_match
.8719		1a		inc a		                ina
.871a		48		pha		                pha
.871b		8a		txa		                txa
.871c		18		clc		                clc
.871d		69 06		adc #$06	                adc #6                  ; skip six bytes
.871f		aa		tax		                tax                     ; ( addr u )
.8720		80 92		bra $86b4	                bra _table_loop
.8722						_no_match:
.8722		8a		txa		                txa
.8723		18		clc		                clc
.8724		69 0a		adc #$0a	                adc #10
.8726		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8727		20 46 9e	jsr $9e46	                jsr w_false
.872a						_done:
.872a						z_environment_q:
.872a		60		rts		                rts
.872b						env_table_single:
>872b		71 d6 81 d6 87 d6 8c d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8733		9e d6
>8735		a6 d6 af d6 b5 d6 bb d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>873d		ce d6 da d6 00 00		        .word envs_sc, envs_wl, 0000
.8743						env_table_double:
>8743		e4 d6 ea d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8749						env_results_single:
>8749		ff 00				        .word $00FF     ; /COUNTED-STRING
>874b		ff 00				        .word $00FF     ; /HOLD
>874d		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>874f		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8751		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8753		ff 00				        .word $00FF     ; MAX-CHAR
>8755		ff 7f				        .word $7FFF     ; MAX-N
>8757		ff ff				        .word $FFFF     ; MAX-U
>8759		80 00				        .word $0080     ; RETURN-STACK-CELLS
>875b		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>875d		09 00				        .word $0009     ; WORDLISTS
.875f						env_results_double:
>875f		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8763		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8767						xt_equal:
.8767		20 8e d8	jsr $d88e	                jsr underflow_2
.876a						w_equal:
.876a		b5 00		lda $00,x	                lda 0,x                 ; LSB
.876c		d5 02		cmp $02,x	                cmp 2,x
.876e		d0 0a		bne $877a	                bne _false
.8770		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8772		d5 03		cmp $03,x	                cmp 3,x
.8774		d0 04		bne $877a	                bne _false
.8776		a9 ff		lda #$ff	                lda #$FF
.8778		80 02		bra $877c	                bra _done
.877a		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.877c		95 02		sta $02,x	_done:          sta 2,x
.877e		95 03		sta $03,x	                sta 3,x
.8780		e8		inx		                inx
.8781		e8		inx		                inx
.8782		60		rts		z_equal:        rts
.8783						xt_blank:
.8783		20 8e d8	jsr $d88e	                jsr underflow_2
.8786						w_blank:
.8786		ca		dex		                dex
.8787		ca		dex		                dex
.8788		a9 20		lda #$20	                lda #AscSP
.878a		95 00		sta $00,x	                sta 0,x
.878c		74 01		stz $01,x	                stz 1,x
.878e		80 0e		bra $879e	                bra w_fill     ; skip over code for ERASE
.8790						xt_erase:
.8790		20 8e d8	jsr $d88e	                jsr underflow_2
.8793						w_erase:
.8793		ca		dex		                dex
.8794		ca		dex		                dex
.8795		74 00		stz $00,x	                stz 0,x
.8797		74 01		stz $01,x	                stz 1,x
.8799		80 03		bra $879e	                bra w_fill
.879b						xt_fill:
.879b		20 93 d8	jsr $d893	                jsr underflow_3
.879e						w_fill:
.879e		b5 04		lda $04,x	                lda 4,x         ; LSB
.87a0		85 25		sta $25		                sta tmp1
.87a2		b5 05		lda $05,x	                lda 5,x
.87a4		85 26		sta $26		                sta tmp1+1
.87a6		b5 02		lda $02,x	                lda 2,x
.87a8		85 27		sta $27		                sta tmp2
.87aa		b5 03		lda $03,x	                lda 3,x
.87ac		85 28		sta $28		                sta tmp2+1
.87ae		b5 00		lda $00,x	                lda 0,x
.87b0		a8		tay		                tay
.87b1						_loop:
.87b1		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.87b3		c5 26		cmp $26		                cmp tmp1+1
.87b5		90 21		bcc $87d8	                bcc _done               ; RAM_END < TMP1, so leave
.87b7		d0 06		bne $87bf	                bne _check_counter      ; RAM_END is not smaller and not equal
.87b9		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.87bb		c5 25		cmp $25		                cmp tmp1
.87bd		90 19		bcc $87d8	                bcc _done               ; RAM_END < TMP1, so leave
.87bf						_check_counter:
.87bf		a5 27		lda $27		                lda tmp2
.87c1		05 28		ora $28		                ora tmp2+1
.87c3		f0 13		beq $87d8	                beq _done
.87c5		98		tya		                tya
.87c6		92 25		sta ($25)	                sta (tmp1)
.87c8		a5 27		lda $27		                lda tmp2
.87ca		d0 02		bne $87ce	                bne +
.87cc		c6 28		dec $28		                dec tmp2+1
.87ce		c6 27		dec $27		+               dec tmp2
.87d0		e6 25		inc $25		                inc tmp1
.87d2		d0 dd		bne $87b1	                bne _loop
.87d4		e6 26		inc $26		                inc tmp1+1
.87d6		80 d9		bra $87b1	                bra _loop
.87d8						_done:
.87d8		8a		txa		                txa
.87d9		18		clc		                clc
.87da		69 06		adc #$06	                adc #6
.87dc		aa		tax		                tax
.87dd						z_blank:
.87dd						z_erase:
.87dd		60		rts		z_fill:         rts
.87de						xt_execute:
.87de		20 89 d8	jsr $d889	                jsr underflow_1
.87e1						w_execute:
.87e1		20 e5 87	jsr $87e5	                jsr doexecute   ; do not combine to JMP (native coding)
.87e4		60		rts		z_execute:      rts
.87e5						doexecute:
.87e5		b5 00		lda $00,x	                lda 0,x
.87e7		85 04		sta $04		                sta ip
.87e9		b5 01		lda $01,x	                lda 1,x
.87eb		85 05		sta $05		                sta ip+1
.87ed		e8		inx		                inx
.87ee		e8		inx		                inx
.87ef		6c 04 00	jmp ($0004)	                jmp (ip)
.87f2						xt_exit:
.87f2						w_exit:
.87f2		60		rts		                rts             ; keep before z_exit
.87f3						z_exit:
.87f3						xt_fetch:
.87f3		20 89 d8	jsr $d889	                jsr underflow_1
.87f6						w_fetch:
.87f6		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.87f8		a8		tay		                tay
.87f9		f6 00		inc $00,x	                inc 0,x
.87fb		d0 02		bne $87ff	                bne +
.87fd		f6 01		inc $01,x	                inc 1,x
.87ff						+
.87ff		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8801		95 01		sta $01,x	                sta 1,x
.8803		94 00		sty $00,x	                sty 0,x
.8805		60		rts		z_fetch:        rts
.8806						xt_find:
.8806		20 89 d8	jsr $d889	                jsr underflow_1
.8809						w_find:
.8809		b5 01		lda $01,x	                lda 1,x                 ; MSB
.880b		48		pha		                pha
.880c		b5 00		lda $00,x	                lda 0,x                 ; LSB
.880e		48		pha		                pha
.880f		20 f4 83	jsr $83f4	                jsr w_count            ; ( caddr -- addr u )
.8812		20 3d 9b	jsr $9b3d	                jsr w_find_name        ; ( addr u -- nt | 0 )
.8815		b5 00		lda $00,x	                lda 0,x
.8817		15 01		ora $01,x	                ora 1,x
.8819		d0 0b		bne $8826	                bne _found_word
.881b		20 46 9e	jsr $9e46	                jsr w_false            ; ( 0 0 )
.881e		68		pla		                pla                     ; LSB of address
.881f		95 02		sta $02,x	                sta 2,x
.8821		68		pla		                pla
.8822		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8824		80 27		bra $884d	                bra _done               ; ( addr 0 )
.8826						_found_word:
.8826		68		pla		                pla
.8827		68		pla		                pla
.8828		20 69 86	jsr $8669	                jsr w_dup              ; ( nt nt )
.882b		20 86 9c	jsr $9c86	                jsr w_name_to_int      ; ( nt xt )
.882e		20 25 92	jsr $9225	                jsr w_swap             ; ( xt nt )
.8831		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8833		f6 00		inc $00,x	                inc 0,x
.8835		d0 02		bne $8839	                bne +
.8837		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8839						+
.8839		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.883b		29 02		and #$02	                and #IM
.883d		d0 08		bne $8847	                bne _immediate          ; bit set, we're immediate
.883f		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8841		95 00		sta $00,x	                sta 0,x
.8843		95 01		sta $01,x	                sta 1,x
.8845		80 06		bra $884d	                bra _done
.8847						_immediate:
.8847		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8849		95 00		sta $00,x	                sta 0,x
.884b		74 01		stz $01,x	                stz 1,x
.884d						_done:
.884d		60		rts		z_find:         rts
.884e						xt_fm_slash_mod:
.884e		20 93 d8	jsr $d893	                jsr underflow_3
.8851						w_fm_slash_mod:
.8851		64 27		stz $27		                stz tmp2        ; default: n is positive
.8853		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8855		10 0e		bpl $8865	                bpl _check_d
.8857		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.8859		20 02 8c	jsr $8c02	                jsr w_negate   ; NEGATE
.885c		20 60 93	jsr $9360	                jsr w_to_r     ; >R
.885f		20 b7 9e	jsr $9eb7	                jsr w_dnegate  ; DNEGATE
.8862		20 cc 8e	jsr $8ecc	                jsr w_r_from   ; R>
.8865						_check_d:
.8865		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.8867		10 0d		bpl $8876	                bpl _multiply
.8869		18		clc		                clc
.886a		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.886c		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.886e		95 02		sta $02,x	                sta 2,x
.8870		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8872		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.8874		95 03		sta $03,x	                sta 3,x
.8876						_multiply:
.8876		20 40 95	jsr $9540	                jsr w_um_slash_mod     ; ( d n1 -- rem n2 )
.8879		a5 27		lda $27		                lda tmp2
.887b		f0 07		beq $8884	                beq _done
.887d		e8		inx		                inx             ; pretend that we SWAP
.887e		e8		inx		                inx
.887f		20 02 8c	jsr $8c02	                jsr w_negate
.8882		ca		dex		                dex
.8883		ca		dex		                dex
.8884						_done:
.8884		60		rts		z_fm_slash_mod: rts
.8885						load_evaluate:
.8885		a9 ff		lda #$ff	                lda #$FF
.8887		85 25		sta $25		                sta tmp1
.8889		80 11		bra $889c	                bra load_evaluate_start
.888b						xt_evaluate:
.888b		20 8e d8	jsr $d88e	                jsr underflow_2
.888e						w_evaluate:
.888e		64 25		stz $25		                stz tmp1
.8890		b5 00		lda $00,x	                lda 0,x
.8892		15 01		ora $01,x	                ora 1,x
.8894		d0 06		bne $889c	                bne evaluate_got_work
.8896		e8		inx		                inx
.8897		e8		inx		                inx
.8898		e8		inx		                inx
.8899		e8		inx		                inx
.889a		80 42		bra $88de	                bra evaluate_done
.889c						load_evaluate_start:
.889c						evaluate_got_work:
.889c		a0 05		ldy #$05	                ldy #blk_offset+1
.889e		b1 08		lda ($08),y	                lda (up),y
.88a0		48		pha		                pha
.88a1		88		dey		                dey
.88a2		b1 08		lda ($08),y	                lda (up),y
.88a4		48		pha		                pha
.88a5		a5 25		lda $25		                lda tmp1
.88a7		d0 05		bne $88ae	                bne _nozero
.88a9		91 08		sta ($08),y	                sta (up),y
.88ab		c8		iny		                iny
.88ac		91 08		sta ($08),y	                sta (up),y
.88ae						_nozero:
.88ae		20 e7 9b	jsr $9be7	                jsr w_input_to_r
.88b1		a9 ff		lda #$ff	                lda #$FF
.88b3		85 0a		sta $0a		                sta insrc
.88b5		85 0b		sta $0b		                sta insrc+1
.88b7		64 10		stz $10		                stz toin
.88b9		64 11		stz $11		                stz toin+1
.88bb		b5 00		lda $00,x	                lda 0,x
.88bd		85 0e		sta $0e		                sta ciblen
.88bf		b5 01		lda $01,x	                lda 1,x
.88c1		85 0f		sta $0f		                sta ciblen+1
.88c3		b5 02		lda $02,x	                lda 2,x
.88c5		85 0c		sta $0c		                sta cib
.88c7		b5 03		lda $03,x	                lda 3,x
.88c9		85 0d		sta $0d		                sta cib+1
.88cb		e8		inx		                inx             ; A clean stack is a clean mind
.88cc		e8		inx		                inx
.88cd		e8		inx		                inx
.88ce		e8		inx		                inx
.88cf		20 06 d8	jsr $d806	                jsr interpret   ; ( -- )
.88d2		20 f4 9d	jsr $9df4	                jsr w_r_to_input
.88d5		a0 04		ldy #$04	                ldy #blk_offset
.88d7		68		pla		                pla
.88d8		91 08		sta ($08),y	                sta (up),y
.88da		c8		iny		                iny
.88db		68		pla		                pla
.88dc		91 08		sta ($08),y	                sta (up),y
.88de						evaluate_done:
.88de		60		rts		z_evaluate:     rts
.88df						xt_greater_than:
.88df		20 8e d8	jsr $d88e	                jsr underflow_2
.88e2						w_greater_than:
.88e2		a0 00		ldy #$00	                ldy #0          ; default false
.88e4		20 c7 d7	jsr $d7c7	                jsr compare_16bit
.88e7		f0 03		beq $88ec	                beq _false
.88e9		10 01		bpl $88ec	                bpl _false
.88eb		88		dey		                dey
.88ec						_false:
.88ec		98		tya		                tya
.88ed		e8		inx		                inx
.88ee		e8		inx		                inx
.88ef		95 00		sta $00,x	                sta 0,x
.88f1		95 01		sta $01,x	                sta 1,x
.88f3		60		rts		z_greater_than: rts
.88f4						xt_here:
.88f4						xt_begin:
.88f4						xt_asm_arrow:
.88f4						w_here:
.88f4						w_begin:
.88f4						w_asm_arrow:
.88f4		ca		dex		                dex
.88f5		ca		dex		                dex
.88f6		a5 00		lda $00		                lda cp
.88f8		95 00		sta $00,x	                sta 0,x
.88fa		a5 01		lda $01		                lda cp+1
.88fc		95 01		sta $01,x	                sta 1,x
.88fe						z_here:
.88fe						z_begin:
.88fe						z_asm_arrow:
.88fe		60		rts		                rts
.88ff						xt_hex:
.88ff						w_hex:
.88ff		a9 10		lda #$10	                lda #16
.8901		85 18		sta $18		                sta base
.8903		64 19		stz $19		                stz base+1              ; paranoid
.8905		60		rts		z_hex:          rts
.8906						xt_hold:
.8906		20 89 d8	jsr $d889	                jsr underflow_1
.8909						w_hold:
.8909		a5 2b		lda $2b		                lda tohold
.890b		d0 02		bne $890f	                bne +
.890d		c6 2c		dec $2c		                dec tohold+1
.890f						+
.890f		c6 2b		dec $2b		                dec tohold
.8911		b5 00		lda $00,x	                lda 0,x
.8913		92 2b		sta ($2b)	                sta (tohold)
.8915		e8		inx		                inx
.8916		e8		inx		                inx
.8917		60		rts		z_hold:         rts
.8918						xt_i:
.8918						w_i:
.8918		ca		dex		                dex
.8919		ca		dex		                dex
.891a		a4 1f		ldy $1f		                ldy loopctrl
.891c		38		sec		                sec
.891d		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.891f		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8922		95 00		sta $00,x	                sta 0,x
.8924		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8927		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.892a		95 01		sta $01,x	                sta 1,x
.892c		60		rts		z_i:            rts
.892d						xt_if:
.892d						w_if:
.892d		20 d3 97	jsr $97d3	                jsr cmpl_0branch_later
.8930		60		rts		z_if:           rts
.8931						xt_immediate:
.8931						w_immediate:
.8931		20 e0 d7	jsr $d7e0	                jsr current_to_dp
.8934		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8936		b1 02		lda ($02),y	                lda (dp),y
.8938		09 02		ora #$02	                ora #IM        ; make sure bit 7 is set
.893a		91 02		sta ($02),y	                sta (dp),y
.893c		60		rts		z_immediate:    rts
.893d						xt_invert:
.893d		20 89 d8	jsr $d889	                jsr underflow_1
.8940						w_invert:
.8940		a9 ff		lda #$ff	                lda #$FF
.8942		55 00		eor $00,x	                eor 0,x         ; LSB
.8944		95 00		sta $00,x	                sta 0,x
.8946		a9 ff		lda #$ff	                lda #$FF
.8948		55 01		eor $01,x	                eor 1,x         ; MSB
.894a		95 01		sta $01,x	                sta 1,x
.894c		60		rts		z_invert:       rts
.894d						xt_is:
.894d						w_is:
.894d		a5 1a		lda $1a		                lda state
.894f		05 1b		ora $1b		                ora state+1
.8951		f0 0c		beq $895f	                beq _interpreting
.8953		20 14 83	jsr $8314	                jsr w_bracket_tick
.8956		a0 85		ldy #$85	                ldy #>w_defer_store
.8958		a9 11		lda #$11	                lda #<w_defer_store
.895a		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.895d		80 06		bra $8965	                bra _done
.895f						_interpreting:
.895f		20 36 92	jsr $9236	                jsr w_tick
.8962		20 11 85	jsr $8511	                jsr w_defer_store
.8965						_done:
.8965		60		rts		z_is:           rts
.8966						xt_j:
.8966						w_j:
.8966		ca		dex		                dex                 ; make space on the stack
.8967		ca		dex		                dex
.8968		a5 1f		lda $1f		                lda loopctrl
.896a		38		sec		                sec
.896b		e9 04		sbc #$04	                sbc #4
.896d		a8		tay		                tay
.896e		38		sec		                sec
.896f		b9 00 01	lda $0100,y	                lda loopindex,y
.8972		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8975		95 00		sta $00,x	                sta 0,x
.8977		b9 01 01	lda $0101,y	                lda loopindex+1,y
.897a		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.897d		95 01		sta $01,x	                sta 1,x
.897f		60		rts		z_j:            rts
.8980						xt_key:
.8980						w_key:
.8980		20 8a 89	jsr $898a	                jsr key_a               ; returns char in A
.8983		ca		dex		                dex
.8984		ca		dex		                dex
.8985		95 00		sta $00,x	                sta 0,x
.8987		74 01		stz $01,x	                stz 1,x
.8989		60		rts		z_key:          rts
.898a						key_a:
.898a		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.898d						xt_keyq:
.898d						w_keyq:
.898d		a0 00		ldy #$00	                ldy #0
.898f		20 9c 89	jsr $899c	                jsr keyq_a
.8992		f0 01		beq $8995	                beq +           ; A=0 => Y=0
.8994		88		dey		                dey             ; A<>0 => Y=#$ff
.8995						+
.8995		ca		dex		                dex
.8996		ca		dex		                dex
.8997		94 00		sty $00,x	                sty 0,x         ; store either $0000 or $ffff
.8999		94 01		sty $01,x	                sty 1,x
.899b		60		rts		z_keyq:         rts
.899c		6c 16 00	jmp ($0016)	keyq_a:         jmp (havekey)
.899f						xt_leave:
.899f						w_leave:
.899f		a5 21		lda $21		                lda loopleave
.89a1		a4 22		ldy $22		                ldy loopleave+1
.89a3		20 a4 97	jsr $97a4	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.89a6		38		sec		                sec
.89a7		a5 00		lda $00		                lda cp
.89a9		e9 02		sbc #$02	                sbc #2
.89ab		85 21		sta $21		                sta loopleave
.89ad		a5 01		lda $01		                lda cp+1
.89af		b0 01		bcs $89b2	                bcs +
.89b1		3a		dec a		                dea
.89b2		85 22		sta $22		+               sta loopleave+1
.89b4						z_leave:
.89b4		60		rts		                rts
.89b5						xt_left_bracket:
.89b5						w_left_bracket:
.89b5		64 1a		stz $1a		                stz state
.89b7		64 1b		stz $1b		                stz state+1
.89b9		60		rts		z_left_bracket: rts
.89ba						xt_less_number_sign:
.89ba						w_less_number_sign:
.89ba		20 ef 8c	jsr $8cef	                jsr w_pad      ; ( addr )
.89bd		b5 00		lda $00,x	                lda 0,x
.89bf		85 2b		sta $2b		                sta tohold
.89c1		b5 01		lda $01,x	                lda 1,x
.89c3		85 2c		sta $2c		                sta tohold+1
.89c5		e8		inx		                inx
.89c6		e8		inx		                inx
.89c7						z_less_number_sign:
.89c7		60		rts		                rts
.89c8						xt_less_than:
.89c8		20 8e d8	jsr $d88e	                jsr underflow_2
.89cb						w_less_than:
.89cb		a0 00		ldy #$00	                ldy #0          ; default false
.89cd		20 c7 d7	jsr $d7c7	                jsr compare_16bit
.89d0		f0 03		beq $89d5	                beq _false
.89d2		30 01		bmi $89d5	                bmi _false
.89d4		88		dey		                dey
.89d5						_false:
.89d5		98		tya		                tya
.89d6		e8		inx		                inx
.89d7		e8		inx		                inx
.89d8		95 00		sta $00,x	                sta 0,x
.89da		95 01		sta $01,x	                sta 1,x
.89dc		60		rts		z_less_than:    rts
.89dd						xt_literal:
.89dd		20 89 d8	jsr $d889	                jsr underflow_1
.89e0						w_literal:
.89e0		a9 0a		lda #$0a	                lda #template_push_tos_size
.89e2		20 c1 97	jsr $97c1	                jsr check_nc_limit
.89e5		90 0c		bcc $89f3	                bcc _inline
.89e7		a0 8a		ldy #$8a	                ldy #>literal_runtime
.89e9		a9 25		lda #$25	                lda #<literal_runtime
.89eb		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.89ee		20 ae 83	jsr $83ae	                jsr w_comma
.89f1		80 27		bra $8a1a	                bra z_literal
.89f3						_inline:
.89f3		a0 94		ldy #$94	                ldy #$94        ; STY opcode
.89f5		b5 01		lda $01,x	                lda 1,x         ; MSB
.89f7		d0 02		bne $89fb	                bne +
.89f9		a0 74		ldy #$74	                ldy #$74        ; STZ opcode
.89fb		5a		phy		+               phy
.89fc		b5 00		lda $00,x	                lda 0,x         ; LSB
.89fe		48		pha		                pha
.89ff		a0 02		ldy #$02	                ldy #2
.8a01		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a03		f0 03		beq $8a08	                beq _copy
.8a05		a0 00		ldy #$00	                ldy #0
.8a07		48		pha		                pha
.8a08		b9 1b 8a	lda $8a1b,y	_copy:          lda template_push_tos,y
.8a0b		c9 ff		cmp #$ff	                cmp #$ff        ; is it a placeholder?
.8a0d		d0 01		bne $8a10	                bne +
.8a0f		68		pla		                pla
.8a10		20 b8 97	jsr $97b8	+               jsr cmpl_a
.8a13		c8		iny		                iny
.8a14		c0 0a		cpy #$0a	                cpy #template_push_tos_size
.8a16		d0 f0		bne $8a08	                bne _copy
.8a18		e8		inx		                inx             ; drop the literal
.8a19		e8		inx		                inx
.8a1a		60		rts		z_literal:      rts
.8a1b						template_push_tos:
.8a1b		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8a1d		a9 ff		lda #$ff	                lda #$ff
.8a1f		ca		dex		                dex
.8a20		ca		dex		                dex
.8a21		95 00		sta $00,x	                sta 0,x
>8a23		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
=10						template_push_tos_size = * - template_push_tos
.8a25						literal_runtime:
.8a25		ca		dex		                dex
.8a26		ca		dex		                dex
.8a27		68		pla		                pla             ; LSB
.8a28		85 25		sta $25		                sta tmp1
.8a2a		68		pla		                pla             ; MSB
.8a2b		85 26		sta $26		                sta tmp1+1
.8a2d		a0 01		ldy #$01	                ldy #1
.8a2f		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8a31		95 00		sta $00,x	                sta 0,x
.8a33		c8		iny		                iny
.8a34		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8a36		95 01		sta $01,x	                sta 1,x
.8a38		98		tya		                tya
.8a39		18		clc		                clc
.8a3a		65 25		adc $25		                adc tmp1
.8a3c		a8		tay		                tay
.8a3d		a5 26		lda $26		                lda tmp1+1
.8a3f		69 00		adc #$00	                adc #0
.8a41		48		pha		                pha
.8a42		5a		phy		                phy
.8a43		60		rts		                rts
.8a44						xt_loop:
.8a44						w_loop:
.8a44		ca		dex		                dex
.8a45		ca		dex		                dex
.8a46		ca		dex		                dex
.8a47		ca		dex		                dex
.8a48		a9 bd		lda #$bd	                lda #<loop_runtime
.8a4a		95 02		sta $02,x	                sta 2,x
.8a4c		a9 8a		lda #$8a	                lda #>loop_runtime
.8a4e		95 03		sta $03,x	                sta 3,x
.8a50		a9 11		lda #$11	                lda #loop_runtime_size
.8a52		95 00		sta $00,x	                sta 0,x
.8a54		74 01		stz $01,x	                stz 1,x
.8a56		80 12		bra $8a6a	                bra loop_common
.8a58						xt_plus_loop:
.8a58						w_plus_loop:
.8a58		ca		dex		                dex
.8a59		ca		dex		                dex
.8a5a		ca		dex		                dex
.8a5b		ca		dex		                dex
.8a5c		a9 d6		lda #$d6	                lda #<plus_loop_runtime
.8a5e		95 02		sta $02,x	                sta 2,x
.8a60		a9 8a		lda #$8a	                lda #>plus_loop_runtime
.8a62		95 03		sta $03,x	                sta 3,x
.8a64		a9 1a		lda #$1a	                lda #plus_loop_runtime_size
.8a66		95 00		sta $00,x	                sta 0,x
.8a68		74 01		stz $01,x	                stz 1,x
.8a6a						loop_common:
.8a6a		20 e4 8c	jsr $8ce4	                jsr w_over
.8a6d		20 25 92	jsr $9225	                jsr w_swap             ; xt and xt' are the same
.8a70		20 2b 97	jsr $972b	                jsr cmpl_by_limit
.8a73		90 05		bcc $8a7a	                bcc _native
.8a75		20 ae 83	jsr $83ae	                jsr w_comma
.8a78		80 03		bra $8a7d	                bra +
.8a7a						_native:
.8a7a		20 9e 97	jsr $979e	                jsr cmpl_jump_tos
.8a7d						+
.8a7d		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8a7f		f0 19		beq $8a9a	                beq _noleave
.8a81						_next:
.8a81		a0 01		ldy #$01	                ldy #1
.8a83		b1 21		lda ($21),y	                lda (loopleave),y
.8a85		48		pha		                pha
.8a86		a5 01		lda $01		                lda cp+1
.8a88		91 21		sta ($21),y	                sta (loopleave),y
.8a8a		88		dey		                dey
.8a8b		b1 21		lda ($21),y	                lda (loopleave),y
.8a8d		48		pha		                pha
.8a8e		a5 00		lda $00		                lda cp
.8a90		91 21		sta ($21),y	                sta (loopleave),y
.8a92		68		pla		                pla
.8a93		85 21		sta $21		                sta loopleave
.8a95		68		pla		                pla
.8a96		85 22		sta $22		                sta loopleave+1
.8a98		d0 e7		bne $8a81	                bne _next
.8a9a						_noleave:
.8a9a		b5 00		lda $00,x	                lda 0,x
.8a9c		85 21		sta $21		                sta loopleave
.8a9e		b5 01		lda $01,x	                lda 1,x
.8aa0		85 22		sta $22		                sta loopleave+1
.8aa2		a9 c5		lda #$c5	                lda #<w_unloop
.8aa4		95 00		sta $00,x	                sta 0,x
.8aa6		a9 95		lda #$95	                lda #>w_unloop
.8aa8		95 01		sta $01,x	                sta 1,x
.8aaa		20 ba 96	jsr $96ba	                jsr w_compile_comma
.8aad		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8aaf		f0 09		beq $8aba	                beq +
.8ab1		20 f4 88	jsr $88f4	                jsr w_here
.8ab4		20 25 92	jsr $9225	                jsr w_swap
.8ab7		4c 0f 92	jmp $920f	                jmp w_store            ; write here as ?DO jmp target and return
.8aba		e8		inx		+               inx                     ; drop the ignored word for DO
.8abb		e8		inx		                inx
.8abc						z_loop:
.8abc		60		rts		z_plus_loop:    rts
.8abd						loop_runtime:
.8abd		e6 20		inc $20		                inc loopidx0            ; increment the LSB of loopindex
.8abf		d0 0d		bne $8ace	                bne _repeat             ; avoid expensive test most of the time
.8ac1		a4 1f		ldy $1f		                ldy loopctrl
.8ac3		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8ac6		1a		inc a		                ina
.8ac7		c9 80		cmp #$80	                cmp #$80
.8ac9		f0 06		beq $8ad1	                beq _done
.8acb		99 01 01	sta $0101,y	                sta loopindex+1,y
=17						loop_runtime_size = * - loop_runtime
.8ace						_repeat:
.8ace		a9 00		lda #$00	                lda #0
>8ad0		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8ad1		a9 01		lda #$01	_done:          lda #1
.8ad3		4c 50 98	jmp $9850	                jmp zbranch_runtime
.8ad6						plus_loop_runtime:
.8ad6		18		clc		                clc
.8ad7		b5 00		lda $00,x	                lda 0,x                 ; LSB of step
.8ad9		65 20		adc $20		                adc loopidx0
.8adb		85 20		sta $20		                sta loopidx0
.8add		e8		inx		                inx                     ; dump step from TOS before MSB test
.8ade		e8		inx		                inx                     ; since we might skip it
.8adf		b5 ff		lda $ff,x	                lda $FF,x               ; MSB of step since 1,x == -1,x+2
.8ae1		d0 02		bne $8ae5	                bne _chkv               ; if it's non-zero we have to check
.8ae3		90 0b		bcc $8af0	                bcc _repeat             ; but if 0 and no carry, we're good
.8ae5		b8		clv		_chkv:          clv
.8ae6		a4 1f		ldy $1f		                ldy loopctrl            ; get LCB offset
.8ae8		79 01 01	adc $0101,y	                adc loopindex+1,y       ; MSB of index
.8aeb		99 01 01	sta $0101,y	                sta loopindex+1,y       ; put MSB of index back on stack
.8aee		70 03		bvs $8af3	                bvs _done               ; skip over JMP instruction
=26						plus_loop_runtime_size = * - plus_loop_runtime
.8af0						_repeat:
.8af0		a9 00		lda #$00	                lda #0
>8af2		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8af3		a9 01		lda #$01	_done:          lda #1
.8af5		4c 50 98	jmp $9850	                jmp zbranch_runtime
.8af8						xt_lshift:
.8af8		20 8e d8	jsr $d88e	                jsr underflow_2
.8afb						w_lshift:
.8afb		b5 00		lda $00,x	                lda 0,x
.8afd		29 0f		and #$0f	                and #%00001111
.8aff		f0 08		beq $8b09	                beq _done
.8b01		a8		tay		                tay
.8b02						_loop:
.8b02		16 02		asl $02,x	                asl 2,x
.8b04		36 03		rol $03,x	                rol 3,x
.8b06		88		dey		                dey
.8b07		d0 f9		bne $8b02	                bne _loop
.8b09						_done:
.8b09		e8		inx		                inx
.8b0a		e8		inx		                inx
.8b0b		60		rts		z_lshift:       rts
.8b0c						xt_m_star:
.8b0c		20 8e d8	jsr $d88e	                jsr underflow_2
.8b0f						w_m_star:
.8b0f		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8b11		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8b13		48		pha		                pha
.8b14		20 d2 80	jsr $80d2	                jsr w_abs
.8b17		20 25 92	jsr $9225	                jsr w_swap
.8b1a		20 d2 80	jsr $80d2	                jsr w_abs
.8b1d		20 82 95	jsr $9582	                jsr w_um_star          ; ( d )
.8b20		68		pla		                pla
.8b21		10 03		bpl $8b26	                bpl _done
.8b23		20 b7 9e	jsr $9eb7	                jsr w_dnegate
.8b26						_done:
.8b26		60		rts		z_m_star:       rts
.8b27						xt_marker:
.8b27						w_marker:
.8b27		20 e0 d7	jsr $d7e0	                jsr current_to_dp
.8b2a		a5 02		lda $02		                lda dp
.8b2c		48		pha		                pha
.8b2d		a5 03		lda $03		                lda dp+1
.8b2f		48		pha		                pha
.8b30		a5 00		lda $00		                lda cp
.8b32		48		pha		                pha
.8b33		a5 01		lda $01		                lda cp+1
.8b35		48		pha		                pha
.8b36		a9 54		lda #$54	                lda #<marker_runtime
.8b38		a0 8b		ldy #$8b	                ldy #>marker_runtime
.8b3a		20 0f 84	jsr $840f	                jsr create_common
.8b3d		7a		ply		                ply                     ; MSB
.8b3e		68		pla		                pla                     ; LSB
.8b3f		20 b4 97	jsr $97b4	                jsr cmpl_word
.8b42		7a		ply		                ply                     ; MSB
.8b43		68		pla		                pla                     ; LSB
.8b44		20 b4 97	jsr $97b4	                jsr cmpl_word
.8b47		a0 08		ldy #$08	                ldy #marker_start_offset
.8b49						-
.8b49		b1 08		lda ($08),y	                lda (up),y
.8b4b		20 b8 97	jsr $97b8	                jsr cmpl_a
.8b4e		c8		iny		                iny
.8b4f		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b51		d0 f6		bne $8b49	                bne -
.8b53		60		rts		z_marker:       rts
.8b54						marker_runtime:
.8b54		68		pla		                pla
.8b55		85 25		sta $25		                sta tmp1        ; LSB of address
.8b57		68		pla		                pla
.8b58		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8b5a		a0 01		ldy #$01	                ldy #1          ; start at 1 due to RTS mechanics
.8b5c		b1 25		lda ($25),y	                lda (tmp1),y
.8b5e		85 00		sta $00		                sta cp
.8b60		c8		iny		                iny
.8b61		b1 25		lda ($25),y	                lda (tmp1),y
.8b63		85 01		sta $01		                sta cp+1
.8b65		c8		iny		                iny
.8b66		b1 25		lda ($25),y	                lda (tmp1),y
.8b68		85 02		sta $02		                sta dp
.8b6a		c8		iny		                iny
.8b6b		b1 25		lda ($25),y	                lda (tmp1),y
.8b6d		85 03		sta $03		                sta dp+1
.8b6f		38		sec		                sec
.8b70		a5 25		lda $25		                lda tmp1
.8b72		e9 03		sbc #$03	                sbc #marker_start_offset - 5
.8b74		85 25		sta $25		                sta tmp1
.8b76		b0 02		bcs $8b7a	                bcs +
.8b78		c6 26		dec $26		                dec tmp1+1
.8b7a						+
.8b7a		a0 08		ldy #$08	                ldy #marker_start_offset
.8b7c						-
.8b7c		b1 25		lda ($25),y	                lda (tmp1),y
.8b7e		91 08		sta ($08),y	                sta (up),y
.8b80		c8		iny		                iny
.8b81		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b83		d0 f7		bne $8b7c	                bne -
.8b85		20 f3 d7	jsr $d7f3	                jsr dp_to_current       ; Move the CURRENT DP back.
.8b88		60		rts		                rts
.8b89						xt_max:
.8b89		20 8e d8	jsr $d88e	                jsr underflow_2
.8b8c						w_max:
.8b8c		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8b8e		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8b90		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8b92		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8b94		50 02		bvc $8b98	                bvc _no_overflow
.8b96		49 80		eor #$80	                eor #$80        ; complement negative flag
.8b98						_no_overflow:
.8b98		30 08		bmi $8ba2	                bmi _keep_nos
.8b9a		b5 00		lda $00,x	                lda 0,x
.8b9c		95 02		sta $02,x	                sta 2,x
.8b9e		b5 01		lda $01,x	                lda 1,x
.8ba0		95 03		sta $03,x	                sta 3,x
.8ba2						_keep_nos:
.8ba2		e8		inx		                inx
.8ba3		e8		inx		                inx
.8ba4		60		rts		z_max:          rts
.8ba5						xt_min:
.8ba5		20 8e d8	jsr $d88e	                jsr underflow_2
.8ba8						w_min:
.8ba8		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8baa		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8bac		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bae		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bb0		50 02		bvc $8bb4	                bvc _no_overflow
.8bb2		49 80		eor #$80	                eor #$80
.8bb4						_no_overflow:
.8bb4		10 08		bpl $8bbe	                bpl _keep_nos
.8bb6		b5 00		lda $00,x	                lda 0,x
.8bb8		95 02		sta $02,x	                sta 2,x
.8bba		b5 01		lda $01,x	                lda 1,x
.8bbc		95 03		sta $03,x	                sta 3,x
.8bbe						_keep_nos:
.8bbe		e8		inx		                inx
.8bbf		e8		inx		                inx
.8bc0		60		rts		z_min:          rts
.8bc1						xt_minus:
.8bc1		20 8e d8	jsr $d88e	                jsr underflow_2
.8bc4						w_minus:
.8bc4		38		sec		                sec
.8bc5		b5 02		lda $02,x	                lda 2,x         ; LSB
.8bc7		f5 00		sbc $00,x	                sbc 0,x
.8bc9		95 02		sta $02,x	                sta 2,x
.8bcb		b5 03		lda $03,x	                lda 3,x         ; MSB
.8bcd		f5 01		sbc $01,x	                sbc 1,x
.8bcf		95 03		sta $03,x	                sta 3,x
.8bd1		e8		inx		                inx
.8bd2		e8		inx		                inx
.8bd3		60		rts		z_minus:        rts
.8bd4						xt_mod:
.8bd4		20 8e d8	jsr $d88e	                jsr underflow_2
.8bd7						w_mod:
.8bd7		20 5b 91	jsr $915b	                jsr w_slash_mod
.8bda		e8		inx		                inx             ; DROP
.8bdb		e8		inx		                inx
.8bdc						z_mod:
.8bdc		60		rts		                rts
.8bdd						xt_move:
.8bdd		20 93 d8	jsr $d893	                jsr underflow_3
.8be0						w_move:
.8be0		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8be2		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8be4		f0 05		beq $8beb	                beq _lsb                ; wasn't helpful, move to LSB
.8be6		b0 0e		bcs $8bf6	                bcs _to_move_up         ; we want CMOVE>
.8be8		4c 01 a0	jmp $a001	                jmp w_cmove            ; JSR/RTS
.8beb						_lsb:
.8beb		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8bed		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8bef		f0 08		beq $8bf9	                beq _equal              ; LSB is equal as well
.8bf1		b0 03		bcs $8bf6	                bcs _to_move_up         ; we want CMOVE>
.8bf3		4c 01 a0	jmp $a001	                jmp w_cmove            ; JSR/RTS
.8bf6						_to_move_up:
.8bf6		4c 3c a0	jmp $a03c	                jmp w_cmove_up         ; JSR/RTS
.8bf9						_equal:
.8bf9		8a		txa		                txa
.8bfa		18		clc		                clc
.8bfb		69 06		adc #$06	                adc #6
.8bfd		aa		tax		                tax
.8bfe		60		rts		z_move:         rts
.8bff						xt_negate:
.8bff		20 89 d8	jsr $d889	                jsr underflow_1
.8c02						w_negate:
.8c02		a9 00		lda #$00	        	lda #0
.8c04		38		sec		                sec
.8c05		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8c07		95 00		sta $00,x	                sta 0,x
.8c09		a9 00		lda #$00	                lda #0
.8c0b		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8c0d		95 01		sta $01,x	                sta 1,x
.8c0f		60		rts		z_negate:       rts
.8c10						xt_nip:
.8c10		20 8e d8	jsr $d88e	                jsr underflow_2
.8c13						w_nip:
.8c13		b5 00		lda $00,x	                lda 0,x         ; LSB
.8c15		95 02		sta $02,x	                sta 2,x
.8c17		b5 01		lda $01,x	                lda 1,x         ; MSB
.8c19		95 03		sta $03,x	                sta 3,x
.8c1b		e8		inx		                inx
.8c1c		e8		inx		                inx
.8c1d		60		rts		z_nip:          rts
.8c1e						xt_not_equals:
.8c1e		20 8e d8	jsr $d88e	                jsr underflow_2
.8c21						w_not_equals:
.8c21		a0 00		ldy #$00	                ldy #0                  ; default is true
.8c23		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8c25		d5 02		cmp $02,x	                cmp 2,x
.8c27		d0 0a		bne $8c33	                bne _not_equal
.8c29		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8c2b		d5 03		cmp $03,x	                cmp 3,x
.8c2d		d0 04		bne $8c33	                bne _not_equal
.8c2f		a9 ff		lda #$ff	                lda #$FF
.8c31		80 01		bra $8c34	                bra _done
.8c33						_not_equal:
.8c33		88		dey		                dey                     ; drop thru to done
.8c34						_done:
.8c34		98		tya		                tya
.8c35		e8		inx		                inx
.8c36		e8		inx		                inx
.8c37		95 00		sta $00,x	                sta 0,x
.8c39		95 01		sta $01,x	                sta 1,x
.8c3b		60		rts		z_not_equals:   rts
.8c3c						xt_number_sign:
.8c3c		20 8e d8	jsr $d88e	                jsr underflow_2         ; double number
.8c3f						w_number_sign:
.8c3f		ca		dex		                dex                     ; inline w_zero
.8c40		ca		dex		                dex
.8c41		74 00		stz $00,x	                stz 0,x
.8c43		74 01		stz $01,x	                stz 1,x
.8c45		e6 19		inc $19		                inc base+1
.8c47		b5 02		lda $02,x	                lda 2,x                 ; if msw is 0 we can skip the first pass
.8c49		15 03		ora $03,x	                ora 3,x
.8c4b		f0 0b		beq $8c58	                beq _skip               ; enter with ( v 0 0 -rot -- 0 v 0 )
.8c4d						_loop:
.8c4d		ca		dex		                dex                     ; inline `base @`
.8c4e		ca		dex		                dex
.8c4f		a5 18		lda $18		                lda base                ; base <= 36
.8c51		95 00		sta $00,x	                sta 0,x
.8c53		74 01		stz $01,x	                stz 1,x
.8c55		20 40 95	jsr $9540	                jsr w_um_slash_mod      ; ( v u 0 base -- v ru qu )
.8c58		20 cd 9c	jsr $9ccd	_skip:          jsr w_not_rot           ; ( qu v ru )
.8c5b		46 19		lsr $19		                lsr base+1              ; 1 => 0 + C=1 => 0 + C=0
.8c5d		b0 ee		bcs $8c4d	                bcs _loop               ; run two passes
.8c5f		b5 00		lda $00,x	                lda 0,x
.8c61		a8		tay		                tay
.8c62		b9 0d d4	lda $d40d,y	                lda s_abc_upper,y       ; upper case 0-9A-Z
.8c65		95 00		sta $00,x	                sta 0,x
.8c67		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8c69		20 09 89	jsr $8909	                jsr w_hold
.8c6c						z_number_sign:
.8c6c		60		rts		                rts
.8c6d						xt_number_sign_greater:
.8c6d		20 8e d8	jsr $d88e	                jsr underflow_2         ; double number
.8c70						w_number_sign_greater:
.8c70		a5 2b		lda $2b		                lda tohold
.8c72		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8c74		95 02		sta $02,x	                sta 2,x
.8c76		a5 2c		lda $2c		                lda tohold+1
.8c78		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8c7a		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8c7c		20 ef 8c	jsr $8cef	                jsr w_pad      ; ( addr addr pad )
.8c7f		38		sec		                sec
.8c80		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8c82		f5 02		sbc $02,x	                sbc 2,x
.8c84		95 02		sta $02,x	                sta 2,x
.8c86		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8c88		f5 03		sbc $03,x	                sbc 3,x
.8c8a		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8c8c		e8		inx		                inx
.8c8d		e8		inx		                inx
.8c8e						z_number_sign_greater:
.8c8e		60		rts		                rts
.8c8f						xt_number_sign_s:
.8c8f		20 8e d8	jsr $d88e	                jsr underflow_2
.8c92						w_number_sign_s:
.8c92						_loop:
.8c92		20 3f 8c	jsr $8c3f	                jsr w_number_sign
.8c95		b5 00		lda $00,x	                lda 0,x
.8c97		15 01		ora $01,x	                ora 1,x
.8c99		15 02		ora $02,x	                ora 2,x
.8c9b		15 03		ora $03,x	                ora 3,x
.8c9d		d0 f3		bne $8c92	                bne _loop
.8c9f						z_number_sign_s:
.8c9f		60		rts		                rts
.8ca0						xt_of:
.8ca0						w_of:
.8ca0		a0 8c		ldy #$8c	                ldy #>w_over
.8ca2		a9 e4		lda #$e4	                lda #<w_over
.8ca4		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.8ca7		a0 87		ldy #$87	                ldy #>w_equal
.8ca9		a9 6a		lda #$6a	                lda #<w_equal
.8cab		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.8cae		20 2d 89	jsr $892d	                jsr w_if
.8cb1		a0 86		ldy #$86	                ldy #>w_drop
.8cb3		a9 63		lda #$63	                lda #<w_drop
.8cb5		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.8cb8		60		rts		z_of:           rts
.8cb9						xt_one_minus:
.8cb9		20 89 d8	jsr $d889	                jsr underflow_1
.8cbc						w_one_minus:
.8cbc		b5 00		lda $00,x	                lda 0,x
.8cbe		d0 02		bne $8cc2	                bne +
.8cc0		d6 01		dec $01,x	                dec 1,x
.8cc2						+
.8cc2		d6 00		dec $00,x	                dec 0,x
.8cc4		60		rts		z_one_minus:    rts
.8cc5						xt_char_plus:
.8cc5						xt_one_plus:
.8cc5		20 89 d8	jsr $d889	                jsr underflow_1
.8cc8						w_char_plus:
.8cc8						w_one_plus:
.8cc8		f6 00		inc $00,x	                inc 0,x
.8cca		d0 02		bne $8cce	                bne _done
.8ccc		f6 01		inc $01,x	                inc 1,x
.8cce						_done:
.8cce						z_char_plus:
.8cce		60		rts		z_one_plus:     rts
.8ccf						xt_or:
.8ccf		20 8e d8	jsr $d88e	                jsr underflow_2
.8cd2						w_or:
.8cd2		b5 00		lda $00,x	                lda 0,x
.8cd4		15 02		ora $02,x	                ora 2,x
.8cd6		95 02		sta $02,x	                sta 2,x
.8cd8		b5 01		lda $01,x	                lda 1,x
.8cda		15 03		ora $03,x	                ora 3,x
.8cdc		95 03		sta $03,x	                sta 3,x
.8cde		e8		inx		                inx
.8cdf		e8		inx		                inx
.8ce0		60		rts		z_or:           rts
.8ce1						xt_over:
.8ce1		20 8e d8	jsr $d88e	                jsr underflow_2
.8ce4						w_over:
.8ce4		ca		dex		                dex
.8ce5		ca		dex		                dex
.8ce6		b5 04		lda $04,x	                lda 4,x         ; LSB
.8ce8		95 00		sta $00,x	                sta 0,x
.8cea		b5 05		lda $05,x	                lda 5,x         ; MSB
.8cec		95 01		sta $01,x	                sta 1,x
.8cee		60		rts		z_over:         rts
.8cef						xt_pad:
.8cef						w_pad:
.8cef		ca		dex		                dex
.8cf0		ca		dex		                dex
.8cf1		a5 00		lda $00		                lda cp
.8cf3		18		clc		                clc
.8cf4		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8cf6		95 00		sta $00,x	                sta 0,x
.8cf8		a5 01		lda $01		                lda cp+1
.8cfa		69 00		adc #$00	                adc #0          ; only need carry
.8cfc		95 01		sta $01,x	                sta 1,x
.8cfe		60		rts		z_pad:          rts
.8cff						xt_page:
.8cff						w_page:
.8cff		a9 1b		lda #$1b	                lda #AscESC
.8d01		20 93 86	jsr $8693	                jsr emit_a
.8d04		a9 5b		lda #$5b	                lda #'['
.8d06		20 93 86	jsr $8693	                jsr emit_a
.8d09		a9 32		lda #$32	                lda #'2'
.8d0b		20 93 86	jsr $8693	                jsr emit_a
.8d0e		a9 4a		lda #$4a	                lda #'J'
.8d10		20 93 86	jsr $8693	                jsr emit_a
.8d13		20 46 9e	jsr $9e46	                jsr w_zero
.8d16		20 46 9e	jsr $9e46	                jsr w_zero
.8d19		20 a5 82	jsr $82a5	                jsr w_at_xy
.8d1c		60		rts		z_page:         rts
.8d1d						xt_paren:
.8d1d						w_paren:
.8d1d		ca		dex		                dex
.8d1e		ca		dex		                dex
.8d1f		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8d21		95 00		sta $00,x	                sta 0,x
.8d23		74 01		stz $01,x	                stz 1,x
.8d25		20 8b 8d	jsr $8d8b	                jsr w_parse
.8d28		e8		inx		                inx
.8d29		e8		inx		                inx
.8d2a		e8		inx		                inx
.8d2b		e8		inx		                inx
.8d2c		60		rts		z_paren:        rts
.8d2d						xt_parse_name:
.8d2d						w_parse_name:
.8d2d		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8d2f		38		sec		                sec
.8d30		e5 10		sbc $10		                sbc toin
.8d32		85 25		sta $25		                sta tmp1
.8d34		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8d36		e5 11		sbc $11		                sbc toin+1
.8d38		85 26		sta $26		                sta tmp1+1
.8d3a		a5 25		lda $25		                lda tmp1
.8d3c		05 26		ora $26		                ora tmp1+1
.8d3e		f0 28		beq $8d68	                beq _empty_line
.8d40		a5 0c		lda $0c		                lda cib
.8d42		18		clc		                clc
.8d43		65 10		adc $10		                adc toin
.8d45		85 27		sta $27		                sta tmp2                ; LSB of first character
.8d47		a5 0d		lda $0d		                lda cib+1
.8d49		65 11		adc $11		                adc toin+1
.8d4b		85 28		sta $28		                sta tmp2+1              ; MSB
.8d4d						_skip_loop:
.8d4d		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8d4f		20 7c d8	jsr $d87c	                jsr is_whitespace
.8d52		90 1f		bcc $8d73	                bcc _char_found
.8d54		e6 27		inc $27		                inc tmp2
.8d56		d0 02		bne $8d5a	                bne +
.8d58		e6 28		inc $28		                inc tmp2+1
.8d5a						+
.8d5a		a5 25		lda $25		                lda tmp1
.8d5c		d0 02		bne $8d60	                bne +
.8d5e		c6 26		dec $26		                dec tmp1+1
.8d60		c6 25		dec $25		+               dec tmp1
.8d62		a5 25		lda $25		                lda tmp1
.8d64		05 26		ora $26		                ora tmp1+1
.8d66		d0 e5		bne $8d4d	                bne _skip_loop          ; fall through if empty line
.8d68						_empty_line:
.8d68		ca		dex		                dex
.8d69		ca		dex		                dex
.8d6a		ca		dex		                dex
.8d6b		ca		dex		                dex
.8d6c		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8d6e		74 01		stz $01,x	                stz 1,x
.8d70		4c 1d 8e	jmp $8e1d	                jmp z_parse_name        ; skip over PARSE
.8d73						_char_found:
.8d73		a5 27		lda $27		                lda tmp2
.8d75		38		sec		                sec
.8d76		e5 0c		sbc $0c		                sbc cib
.8d78		85 10		sta $10		                sta toin
.8d7a		a5 28		lda $28		                lda tmp2+1
.8d7c		e5 0d		sbc $0d		                sbc cib+1
.8d7e		85 11		sta $11		                sta toin+1
.8d80		ca		dex		                dex
.8d81		ca		dex		                dex
.8d82		a9 20		lda #$20	                lda #AscSP
.8d84		95 00		sta $00,x	                sta 0,x
.8d86		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8d88						xt_parse:
.8d88		20 89 d8	jsr $d889	                jsr underflow_1
.8d8b						w_parse:
.8d8b		a5 0e		lda $0e		                lda ciblen
.8d8d		05 0f		ora $0f		                ora ciblen+1
.8d8f		f0 0c		beq $8d9d	                beq _abort_parse
.8d91		a5 11		lda $11		                lda toin+1              ; MSB
.8d93		c5 0f		cmp $0f		                cmp ciblen+1
.8d95		90 0e		bcc $8da5	                bcc _go_parse           ; unsigned comparison
.8d97		a5 10		lda $10		                lda toin                ; LSB
.8d99		c5 0e		cmp $0e		                cmp ciblen
.8d9b		90 08		bcc $8da5	                bcc _go_parse
.8d9d						_abort_parse:
.8d9d		ca		dex		                dex
.8d9e		ca		dex		                dex
.8d9f		74 00		stz $00,x	                stz 0,x
.8da1		74 01		stz $01,x	                stz 1,x
.8da3		80 78		bra $8e1d	                bra _done
.8da5						_go_parse:
.8da5		b5 00		lda $00,x	                lda 0,x
.8da7		85 23		sta $23		                sta tmptos
.8da9		ca		dex		                dex
.8daa		ca		dex		                dex
.8dab		a5 0c		lda $0c		                lda cib
.8dad		18		clc		                clc
.8dae		65 10		adc $10		                adc toin        ; LSB
.8db0		85 25		sta $25		                sta tmp1
.8db2		85 27		sta $27		                sta tmp2
.8db4		95 02		sta $02,x	                sta 2,x
.8db6		a5 0d		lda $0d		                lda cib+1
.8db8		65 11		adc $11		                adc toin+1      ; MSB
.8dba		85 26		sta $26		                sta tmp1+1
.8dbc		85 28		sta $28		                sta tmp2+1
.8dbe		95 03		sta $03,x	                sta 3,x
.8dc0		a5 0c		lda $0c		                lda cib
.8dc2		18		clc		                clc
.8dc3		65 0e		adc $0e		                adc ciblen
.8dc5		85 29		sta $29		                sta tmp3
.8dc7		a5 0d		lda $0d		                lda cib+1
.8dc9		65 0f		adc $0f		                adc ciblen+1
.8dcb		85 2a		sta $2a		                sta tmp3+1
.8dcd		64 24		stz $24		                stz tmptos+1
.8dcf						_loop:
.8dcf		a5 27		lda $27		                lda tmp2
.8dd1		c5 29		cmp $29		                cmp tmp3
.8dd3		d0 06		bne $8ddb	                bne _not_empty
.8dd5		a5 28		lda $28		                lda tmp2+1
.8dd7		c5 2a		cmp $2a		                cmp tmp3+1
.8dd9		f0 1d		beq $8df8	                beq _eol
.8ddb						_not_empty:
.8ddb		b2 27		lda ($27)	                lda (tmp2)
.8ddd		a4 23		ldy $23		                ldy tmptos
.8ddf		c0 20		cpy #$20	                cpy #AscSP
.8de1		d0 07		bne $8dea	                bne _not_whitespace
.8de3		20 7c d8	jsr $d87c	                jsr is_whitespace
.8de6		90 02		bcc $8dea	                bcc _not_whitespace
.8de8		80 0c		bra $8df6	                bra _found_delimiter
.8dea						_not_whitespace:
.8dea		c5 23		cmp $23		                cmp tmptos
.8dec		f0 08		beq $8df6	                beq _found_delimiter
.8dee		e6 27		inc $27		                inc tmp2
.8df0		d0 dd		bne $8dcf	                bne _loop
.8df2		e6 28		inc $28		                inc tmp2+1
.8df4		80 d9		bra $8dcf	                bra _loop
.8df6						_found_delimiter:
.8df6		e6 24		inc $24		                inc tmptos+1
.8df8						_eol:
.8df8		a5 27		lda $27		                lda tmp2
.8dfa		38		sec		                sec
.8dfb		e5 25		sbc $25		                sbc tmp1
.8dfd		95 00		sta $00,x	                sta 0,x
.8dff		a5 28		lda $28		                lda tmp2+1
.8e01		e5 26		sbc $26		                sbc tmp1+1
.8e03		95 01		sta $01,x	                sta 1,x
.8e05		a5 27		lda $27		                lda tmp2
.8e07		38		sec		                sec
.8e08		e5 0c		sbc $0c		                sbc cib
.8e0a		85 10		sta $10		                sta toin
.8e0c		a5 28		lda $28		                lda tmp2+1
.8e0e		e5 0d		sbc $0d		                sbc cib+1
.8e10		85 11		sta $11		                sta toin+1
.8e12		a5 10		lda $10		                lda toin
.8e14		18		clc		                clc
.8e15		65 24		adc $24		                adc tmptos+1
.8e17		85 10		sta $10		                sta toin
.8e19		90 02		bcc $8e1d	                bcc +
.8e1b		e6 11		inc $11		                inc toin+1
.8e1d						+
.8e1d						_done:
.8e1d						z_parse_name:
.8e1d		60		rts		z_parse:        rts
.8e1e						xt_pick:
.8e1e						w_pick:
.8e1e		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8e20		8a		txa		                txa
.8e21		75 00		adc $00,x	                adc 0,x
.8e23		a8		tay		                tay
.8e24		b9 02 00	lda $0002,y	                lda 0002,y
.8e27		95 00		sta $00,x	                sta 0,x
.8e29		b9 03 00	lda $0003,y	                lda 0003,y
.8e2c		95 01		sta $01,x	                sta 1,x
.8e2e		60		rts		z_pick:         rts
.8e2f						xt_plus:
.8e2f		20 8e d8	jsr $d88e	                jsr underflow_2
.8e32						w_plus:
.8e32		18		clc		                clc
.8e33		b5 00		lda $00,x	                lda 0,x         ; LSB
.8e35		75 02		adc $02,x	                adc 2,x
.8e37		95 02		sta $02,x	                sta 2,x
.8e39		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8e3b		75 03		adc $03,x	                adc 3,x
.8e3d		95 03		sta $03,x	                sta 3,x
.8e3f		e8		inx		                inx
.8e40		e8		inx		                inx
.8e41		60		rts		z_plus:         rts
.8e42						xt_plus_store:
.8e42		20 8e d8	jsr $d88e	                jsr underflow_2
.8e45						w_plus_store:
.8e45		b5 00		lda $00,x	                lda 0,x
.8e47		85 25		sta $25		                sta tmp1
.8e49		b5 01		lda $01,x	                lda 1,x
.8e4b		85 26		sta $26		                sta tmp1+1
.8e4d		a0 00		ldy #$00	                ldy #0          ; LSB
.8e4f		b1 25		lda ($25),y	                lda (tmp1),y
.8e51		18		clc		                clc
.8e52		75 02		adc $02,x	                adc 2,x
.8e54		91 25		sta ($25),y	                sta (tmp1),y
.8e56		c8		iny		                iny             ; MSB
.8e57		b1 25		lda ($25),y	                lda (tmp1),y
.8e59		75 03		adc $03,x	                adc 3,x
.8e5b		91 25		sta ($25),y	                sta (tmp1),y
.8e5d		e8		inx		                inx
.8e5e		e8		inx		                inx
.8e5f		e8		inx		                inx
.8e60		e8		inx		                inx
.8e61		60		rts		z_plus_store:   rts
.8e62						xt_postpone:
.8e62						w_postpone:
.8e62		20 2d 8d	jsr $8d2d	                jsr w_parse_name               ; ( -- addr n )
.8e65		b5 00		lda $00,x	                lda 0,x
.8e67		15 01		ora $01,x	                ora 1,x
.8e69		d0 05		bne $8e70	                bne +
.8e6b		a9 05		lda #$05	                lda #err_noname
.8e6d		4c 9f d8	jmp $d89f	                jmp error
.8e70						+
.8e70		20 3d 9b	jsr $9b3d	                jsr w_find_name                ; ( -- nt | 0 )
.8e73		d0 05		bne $8e7a	                bne +
.8e75		a9 05		lda #$05	                lda #err_noname
.8e77		4c 9f d8	jmp $d89f	                jmp error
.8e7a						+
.8e7a		b5 00		lda $00,x	                lda 0,x
.8e7c		85 25		sta $25		                sta tmp1
.8e7e		b5 01		lda $01,x	                lda 1,x
.8e80		85 26		sta $26		                sta tmp1+1
.8e82		20 86 9c	jsr $9c86	                jsr w_name_to_int              ; ( nt -- xt )
.8e85		e6 25		inc $25		                inc tmp1
.8e87		d0 02		bne $8e8b	                bne +
.8e89		e6 26		inc $26		                inc tmp1+1
.8e8b						+
.8e8b		b2 25		lda ($25)	                lda (tmp1)
.8e8d		29 02		and #$02	                and #IM         ; mask all but Intermediate flag
.8e8f		f0 05		beq $8e96	                beq _not_immediate
.8e91		20 ba 96	jsr $96ba	                jsr w_compile_comma
.8e94		80 0a		bra $8ea0	                bra _done
.8e96						_not_immediate:
.8e96		20 e0 89	jsr $89e0	                jsr w_literal
.8e99		a0 96		ldy #$96	                ldy #>w_compile_comma
.8e9b		a9 ba		lda #$ba	                lda #<w_compile_comma
.8e9d		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.8ea0						_done:
.8ea0		60		rts		z_postpone:     rts
.8ea1						xt_question_dup:
.8ea1		20 89 d8	jsr $d889	                jsr underflow_1
.8ea4						w_question_dup:
.8ea4		b5 00		lda $00,x	                lda 0,x
.8ea6		15 01		ora $01,x	                ora 1,x
.8ea8		f0 0a		beq $8eb4	                beq _done
.8eaa		ca		dex		                dex
.8eab		ca		dex		                dex
.8eac		b5 02		lda $02,x	                lda 2,x
.8eae		95 00		sta $00,x	                sta 0,x
.8eb0		b5 03		lda $03,x	                lda 3,x
.8eb2		95 01		sta $01,x	                sta 1,x
.8eb4						_done:
.8eb4		60		rts		z_question_dup: rts
.8eb5						xt_r_fetch:
.8eb5						w_r_fetch:
.8eb5		68		pla		                pla                     ; LSB
.8eb6		7a		ply		                ply                     ; MSB
.8eb7		1a		inc a		                inc a
.8eb8		85 25		sta $25		                sta tmp1                ; LSB
.8eba		d0 01		bne $8ebd	                bne +
.8ebc		c8		iny		                iny
.8ebd						+
.8ebd		84 26		sty $26		                sty tmp1+1              ; MSB
.8ebf		ca		dex		                dex
.8ec0		ca		dex		                dex
.8ec1		7a		ply		                ply             ; LSB
.8ec2		94 00		sty $00,x	                sty 0,x
.8ec4		68		pla		                pla             ; MSB
.8ec5		95 01		sta $01,x	                sta 1,x
.8ec7		48		pha		                pha
.8ec8		5a		phy		                phy
.8ec9		6c 25 00	jmp ($0025)	z_r_fetch:      jmp (tmp1)
.8ecc						xt_r_from:
.8ecc						w_r_from:
.8ecc		68		pla		                pla                     ; LSB
.8ecd		7a		ply		                ply                     ; MSB
.8ece		1a		inc a		                inc a
.8ecf		85 25		sta $25		                sta tmp1                ; LSB
.8ed1		d0 01		bne $8ed4	                bne +
.8ed3		c8		iny		                iny
.8ed4						+
.8ed4		84 26		sty $26		                sty tmp1+1              ; MSB
.8ed6		ca		dex		                dex
.8ed7		ca		dex		                dex
.8ed8		68		pla		                pla             ; LSB
.8ed9		95 00		sta $00,x	                sta 0,x
.8edb		68		pla		                pla             ; MSB
.8edc		95 01		sta $01,x	                sta 1,x
.8ede		6c 25 00	jmp ($0025)	z_r_from:       jmp (tmp1)
.8ee1						xt_recurse:
.8ee1						w_recurse:
.8ee1		a0 00		ldy #$00	                ldy #0
.8ee3		a9 20		lda #$20	                lda #OpJSR
.8ee5		91 00		sta ($00),y	                sta (cp),y
.8ee7		c8		iny		                iny
.8ee8		24 1c		bit $1c		                bit status
.8eea		70 0c		bvs $8ef8	                bvs _nt_in_workword
.8eec		a5 06		lda $06		                lda workword
.8eee		91 00		sta ($00),y	                sta (cp),y
.8ef0		c8		iny		                iny
.8ef1		a5 07		lda $07		                lda workword+1
.8ef3		91 00		sta ($00),y	                sta (cp),y
.8ef5		c8		iny		                iny
.8ef6		80 1b		bra $8f13	                bra _update_cp
.8ef8						_nt_in_workword:
.8ef8		a5 06		lda $06		                lda workword            ; LSB
.8efa		18		clc		                clc
.8efb		69 04		adc #$04	                adc #4
.8efd		85 25		sta $25		                sta tmp1
.8eff		a5 07		lda $07		                lda workword+1          ; MSB
.8f01		69 00		adc #$00	                adc #0
.8f03		85 26		sta $26		                sta tmp1+1
.8f05		b2 25		lda ($25)	                lda (tmp1)
.8f07		91 00		sta ($00),y	                sta (cp),y
.8f09		5a		phy		                phy
.8f0a		a0 01		ldy #$01	                ldy #1
.8f0c		b1 25		lda ($25),y	                lda (tmp1),y
.8f0e		7a		ply		                ply
.8f0f		c8		iny		                iny
.8f10		91 00		sta ($00),y	                sta (cp),y
.8f12		c8		iny		                iny
.8f13						_update_cp:
.8f13		98		tya		                tya
.8f14		18		clc		                clc
.8f15		65 00		adc $00		                adc cp
.8f17		85 00		sta $00		                sta cp
.8f19		90 02		bcc $8f1d	                bcc _done
.8f1b		e6 01		inc $01		                inc cp+1
.8f1d						_done:
.8f1d		60		rts		z_recurse:      rts
.8f1e						xt_refill:
.8f1e						w_refill:
.8f1e		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.8f20		d0 2d		bne $8f4f	                bne _src_not_kbd
.8f22		ca		dex		                dex
.8f23		ca		dex		                dex
.8f24		ca		dex		                dex
.8f25		ca		dex		                dex
.8f26		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.8f28		95 02		sta $02,x	                sta 2,x
.8f2a		a5 0d		lda $0d		                lda cib+1
.8f2c		95 03		sta $03,x	                sta 3,x
.8f2e		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.8f30		64 0f		stz $0f		                stz ciblen+1
.8f32		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.8f34		95 00		sta $00,x	                sta 0,x
.8f36		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.8f38		20 e7 80	jsr $80e7	                jsr w_accept           ; ( addr n1 -- n2)
.8f3b		b5 00		lda $00,x	                lda 0,x
.8f3d		85 0e		sta $0e		                sta ciblen
.8f3f		b5 01		lda $01,x	                lda 1,x
.8f41		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.8f43		64 10		stz $10		                stz toin
.8f45		64 11		stz $11		                stz toin+1
.8f47		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.8f49		95 00		sta $00,x	                sta 0,x
.8f4b		95 01		sta $01,x	                sta 1,x
.8f4d		80 10		bra $8f5f	                bra _done
.8f4f						_src_not_kbd:
.8f4f		1a		inc a		                ina
.8f50		d0 08		bne $8f5a	                bne _src_not_string
.8f52		ca		dex		                dex
.8f53		ca		dex		                dex
.8f54		74 00		stz $00,x	                stz 0,x
.8f56		74 01		stz $01,x	                stz 1,x
.8f58		80 05		bra $8f5f	                bra z_refill
.8f5a						_src_not_string:
.8f5a		a9 01		lda #$01	                lda #err_badsource
.8f5c		4c 9f d8	jmp $d89f	                jmp error
.8f5f						_done:
.8f5f		60		rts		z_refill:       rts
.8f60						xt_repeat:
.8f60		20 8e d8	jsr $d88e	                jsr underflow_2
.8f63						w_repeat:
.8f63		20 22 82	jsr $8222	                jsr w_again
.8f66		4c 82 86	jmp $8682	                jmp w_then
.8f69						z_repeat:
.8f69						xt_right_bracket:
.8f69						w_right_bracket:
.8f69		a9 ff		lda #$ff	                lda #$FF
.8f6b		85 1a		sta $1a		                sta state
.8f6d		85 1b		sta $1b		                sta state+1
.8f6f						z_right_bracket:
.8f6f		60		rts		                rts
.8f70						xt_rot:
.8f70		20 93 d8	jsr $d893	                jsr underflow_3
.8f73						w_rot:
.8f73		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.8f75		b5 03		lda $03,x	                lda 3,x
.8f77		95 05		sta $05,x	                sta 5,x
.8f79		b5 01		lda $01,x	                lda 1,x
.8f7b		95 03		sta $03,x	                sta 3,x
.8f7d		94 01		sty $01,x	                sty 1,x
.8f7f		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.8f81		b5 02		lda $02,x	                lda 2,x
.8f83		95 04		sta $04,x	                sta 4,x
.8f85		b5 00		lda $00,x	                lda 0,x
.8f87		95 02		sta $02,x	                sta 2,x
.8f89		94 00		sty $00,x	                sty 0,x
.8f8b		60		rts		z_rot:          rts
.8f8c						xt_rshift:
.8f8c		20 8e d8	jsr $d88e	                jsr underflow_2
.8f8f						w_rshift:
.8f8f		b5 00		lda $00,x	                lda 0,x
.8f91		29 0f		and #$0f	                and #%00001111
.8f93		f0 08		beq $8f9d	                beq _done               ; if 0 shifts, quit
.8f95		a8		tay		                tay
.8f96						_loop:
.8f96		56 03		lsr $03,x	                lsr 3,x
.8f98		76 02		ror $02,x	                ror 2,x
.8f9a		88		dey		                dey
.8f9b		d0 f9		bne $8f96	                bne _loop
.8f9d						_done:
.8f9d		e8		inx		                inx
.8f9e		e8		inx		                inx
.8f9f		60		rts		z_rshift:       rts
.8fa0						xt_s_backslash_quote:
.8fa0						w_s_backslash_quote:
.8fa0		a9 ff		lda #$ff	                lda #$FF
.8fa2		85 27		sta $27		                sta tmp2
.8fa4		64 28		stz $28		                stz tmp2+1
.8fa6		20 bd 8f	jsr $8fbd	                jsr s_quote_start
.8fa9						z_s_backslash_quote:
.8fa9		60		rts		                rts
.8faa						convert_hex_value:
.8faa		c9 41		cmp #$41	        cmp #'A'
.8fac		90 07		bcc $8fb5	        bcc _digit
.8fae		29 df		and #$df	        and #$DF                ; Make it uppercase.
.8fb0		38		sec		        sec
.8fb1		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.8fb3		80 03		bra $8fb8	        bra _done
.8fb5						_digit:
.8fb5		38		sec		        sec
.8fb6		e9 30		sbc #$30	        sbc #'0'
.8fb8						_done:
.8fb8		60		rts		        rts
.8fb9						xt_s_quote:
.8fb9						w_s_quote:
.8fb9		64 27		stz $27		                stz tmp2
.8fbb		64 28		stz $28		                stz tmp2+1
.8fbd						s_quote_start:
.8fbd		20 8d 97	jsr $978d	                jsr cmpl_jump_later
.8fc0		20 f4 88	jsr $88f4	                jsr w_here             ; the start of the string
.8fc3						_savechars_loop:
.8fc3		a5 11		lda $11		                lda toin+1              ; MSB
.8fc5		c5 0f		cmp $0f		                cmp ciblen+1
.8fc7		90 2a		bcc $8ff3	                bcc _input_fine         ; unsigned comparison
.8fc9		a5 10		lda $10		                lda toin                ; LSB
.8fcb		c5 0e		cmp $0e		                cmp ciblen
.8fcd		90 24		bcc $8ff3	                bcc _input_fine
.8fcf		a5 27		lda $27		                lda tmp2
.8fd1		48		pha		                pha
.8fd2		a5 28		lda $28		                lda tmp2+1
.8fd4		48		pha		                pha
.8fd5		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.8fd7		48		pha		                pha
.8fd8		20 1e 8f	jsr $8f1e	                jsr w_refill           ; ( -- f )
.8fdb		68		pla		                pla
.8fdc		85 29		sta $29		                sta tmp3
.8fde		68		pla		                pla
.8fdf		85 28		sta $28		                sta tmp2+1
.8fe1		68		pla		                pla
.8fe2		85 27		sta $27		                sta tmp2
.8fe4		b5 00		lda $00,x	                lda 0,x
.8fe6		15 01		ora $01,x	                ora 1,x
.8fe8		d0 05		bne $8fef	                bne _refill_ok
.8fea		a9 06		lda #$06	                lda #err_refill
.8fec		4c 9f d8	jmp $d89f	                jmp error
.8fef						_refill_ok:
.8fef		e8		inx		                inx
.8ff0		e8		inx		                inx
.8ff1		80 d0		bra $8fc3	                bra _savechars_loop
.8ff3						_input_fine:
.8ff3		a5 0c		lda $0c		                lda cib
.8ff5		18		clc		                clc
.8ff6		65 10		adc $10		                adc toin        ; LSB
.8ff8		85 25		sta $25		                sta tmp1
.8ffa		a5 0d		lda $0d		                lda cib+1
.8ffc		65 11		adc $11		                adc toin+1      ; MSB
.8ffe		85 26		sta $26		                sta tmp1+1
.9000		b2 25		lda ($25)	                lda (tmp1)
.9002		24 27		bit $27		                bit tmp2
.9004		30 03		bmi $9009	                bmi _handle_escapes    ; Only checking bit 7
.9006		4c 71 90	jmp $9071	                jmp _regular_char
.9009						_handle_escapes:
.9009		24 28		bit $28		                bit tmp2+1
.900b		30 03		bmi $9010	                bmi _escaped
.900d		4c 67 90	jmp $9067	                jmp _not_escaped
.9010						_escaped:
.9010		70 21		bvs $9033	                bvs _check_esc_chars
.9012		a9 01		lda #$01	                lda #1
.9014		24 28		bit $28		                bit tmp2+1
.9016		d0 10		bne $9028	                bne _esc_x_second_digit
.9018		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.901a		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.901c		20 aa 8f	jsr $8faa	                jsr convert_hex_value
.901f		0a		asl a		                asl
.9020		0a		asl a		                asl
.9021		0a		asl a		                asl
.9022		0a		asl a		                asl
.9023		85 29		sta $29		                sta tmp3    ; Save it for later.
.9025		4c 78 90	jmp $9078	                jmp _next_character
.9028						_esc_x_second_digit:
.9028		64 28		stz $28		                stz tmp2+1
.902a		b2 25		lda ($25)	                lda (tmp1)
.902c		20 aa 8f	jsr $8faa	                jsr convert_hex_value
.902f		05 29		ora $29		                ora tmp3
.9031		80 42		bra $9075	                bra _save_character
.9033						_check_esc_chars:
.9033		64 28		stz $28		                stz tmp2+1
.9035		c9 61		cmp #$61	                cmp #'a'
.9037		30 1a		bmi $9053	                bmi _check_esc_quote
.9039		c9 7b		cmp #$7b	                cmp #'z'+1
.903b		10 16		bpl $9053	                bpl _check_esc_quote
.903d		a8		tay		                tay
.903e		b9 42 90	lda $9042,y	                lda escape_tr_table - 'a',y   ; fake base address to index with a-z directly
.9041		d0 03		bne $9046	                bne _esc_replace
.9043		98		tya		                tya                     ; revert if no translation
.9044		80 0d		bra $9053	                bra _check_esc_quote
.9046		10 2d		bpl $9075	_esc_replace:   bpl _save_character     ; simple replacement
.9048		29 7f		and #$7f	                and #$7F                ; clear hi bit
.904a		f0 29		beq $9075	                beq _save_character     ; NUL we can just output
.904c		20 b8 97	jsr $97b8	                jsr cmpl_a              ; else output first char (CR)
.904f		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9051		80 22		bra $9075	                bra _save_character
.9053						_check_esc_quote:
.9053		c9 22		cmp #$22	                cmp #'"'
.9055		f0 1e		beq $9075	                beq _save_character
.9057		c9 78		cmp #$78	                cmp #'x'
.9059		d0 06		bne $9061	                bne _check_esc_backslash
.905b		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.905d		85 28		sta $28		                sta tmp2+1
.905f		80 17		bra $9078	                bra _next_character
.9061						_check_esc_backslash:
.9061		c9 5c		cmp #$5c	                cmp #'\'
.9063		d0 0c		bne $9071	                bne _regular_char
.9065		80 0e		bra $9075	                bra _save_character
.9067						_not_escaped:
.9067		c9 5c		cmp #$5c	                cmp #'\'
.9069		d0 06		bne $9071	                bne _regular_char
.906b		a9 ff		lda #$ff	                lda #$FF
.906d		85 28		sta $28		                sta tmp2+1
.906f		80 07		bra $9078	                bra _next_character
.9071						_regular_char:
.9071		c9 22		cmp #$22	                cmp #'"'
.9073		f0 0c		beq $9081	                beq _found_string_end
.9075						_save_character:
.9075		20 b8 97	jsr $97b8	                jsr cmpl_a
.9078						_next_character:
.9078		e6 10		inc $10		                inc toin
.907a		d0 02		bne $907e	                bne _savechars_loop_longjump
.907c		e6 11		inc $11		                inc toin+1
.907e						_savechars_loop_longjump:
.907e		4c c3 8f	jmp $8fc3	                jmp _savechars_loop
.9081						_found_string_end:
.9081		e6 10		inc $10		                inc toin
.9083		d0 02		bne $9087	                bne +
.9085		e6 11		inc $11		                inc toin+1
.9087						+
.9087		20 f4 88	jsr $88f4	                jsr w_here
.908a		20 73 8f	jsr $8f73	                jsr w_rot
.908d		20 0f 92	jsr $920f	                jsr w_store    ; Update the jmp target
.9090		20 f4 88	jsr $88f4	                jsr w_here
.9093		20 e4 8c	jsr $8ce4	                jsr w_over
.9096		20 c4 8b	jsr $8bc4	                jsr w_minus    ; HERE - addr gives string length
.9099		a5 1a		lda $1a		                lda state
.909b		05 1b		ora $1b		                ora state+1             ; paranoid
.909d		f0 03		beq $90a2	                beq _done
.909f		20 18 a2	jsr $a218	                jsr cmpl_sliteral         ; ( addr u -- )
.90a2						_done:
.90a2		60		rts		z_s_quote:      rts
.90a3						escape_tr_table:
>90a3		07				    .byte   7               ; a -> BEL (ASCII value 7)
>90a4		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>90a5		00 00				    .byte   0,0             ; c, d no escape
>90a7		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>90a8		0c				    .byte   12              ; f -> FF (ASCII value 12)
>90a9		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>90ae		0a				    .byte   10              ; l -> LF (ASCII value 10)
>90af		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>90b0		0a				    .byte   10              ; n behaves like l --> lf
>90b1		00 00				    .byte   0,0             ; o,p
>90b3		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>90b4		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>90b5		00				    .byte   0               ; s
>90b6		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>90b7		00				    .byte   0               ; u
>90b8		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>90b9		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>90bc		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.90bd						xt_s_to_d:
.90bd		20 89 d8	jsr $d889	                jsr underflow_1
.90c0						w_s_to_d:
.90c0		ca		dex		                dex
.90c1		ca		dex		                dex
.90c2		74 00		stz $00,x	                stz 0,x
.90c4		74 01		stz $01,x	                stz 1,x
.90c6		b5 03		lda $03,x	                lda 3,x
.90c8		10 04		bpl $90ce	                bpl _done
.90ca		d6 00		dec $00,x	                dec 0,x
.90cc		d6 01		dec $01,x	                dec 1,x
.90ce						_done:
.90ce		60		rts		z_s_to_d:       rts
.90cf						xt_semicolon:
.90cf						w_semicolon:
.90cf		24 1c		bit $1c		                bit status              ; check bit 6 (overflow flag)
.90d1		70 11		bvs $90e4	                bvs _colonword
.90d3		a9 60		lda #$60	                lda #OpRTS
.90d5		20 b8 97	jsr $97b8	                jsr cmpl_a
.90d8		ca		dex		                dex
.90d9		ca		dex		                dex
.90da		a5 06		lda $06		                lda workword
.90dc		95 00		sta $00,x	                sta 0,x
.90de		a5 07		lda $07		                lda workword+1
.90e0		95 01		sta $01,x	                sta 1,x
.90e2		80 53		bra $9137	                bra _semicolon_done
.90e4						_colonword:
.90e4		a9 10		lda #$10	                lda #%00010000
.90e6		25 1c		and $1c		                and status
.90e8		f0 08		beq $90f2	                beq +
.90ea		a0 01		ldy #$01	                ldy #1
.90ec		b1 06		lda ($06),y	                lda (workword),y
.90ee		29 f7		and #$f7	                and #255-NN
.90f0		91 06		sta ($06),y	                sta (workword),y
.90f2						+
.90f2		a0 06		ldy #$06	                ldy #6
.90f4		a5 00		lda $00		                lda cp
.90f6		91 06		sta ($06),y	                sta (workword),y
.90f8		c8		iny		                iny
.90f9		a5 01		lda $01		                lda cp+1
.90fb		91 06		sta ($06),y	                sta (workword),y
.90fd		a9 60		lda #$60	                lda #OpRTS
.90ff		20 b8 97	jsr $97b8	                jsr cmpl_a
.9102		24 1c		bit $1c		                bit status
.9104		10 26		bpl $912c	                bpl _new_word   ; Bit 7 is clear = new word
.9106		ca		dex		                dex
.9107		ca		dex		                dex
.9108		ca		dex		                dex
.9109		ca		dex		                dex
.910a		b2 06		lda ($06)	                lda (workword)
.910c		95 00		sta $00,x	                sta 0,x
.910e		74 01		stz $01,x	                stz 1,x
.9110		a5 06		lda $06		                lda workword
.9112		18		clc		                clc
.9113		69 08		adc #$08	                adc #8
.9115		95 02		sta $02,x	                sta 2,x
.9117		a5 07		lda $07		                lda workword+1
.9119		69 00		adc #$00	                adc #0                  ; only want carry
.911b		95 03		sta $03,x	                sta 3,x
.911d		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.911f		20 c5 d8	jsr $d8c5	                jsr print_string_no_lf
.9122		20 bb 94	jsr $94bb	                jsr w_type
.9125		20 bc 91	jsr $91bc	                jsr w_space
.9128		a9 80		lda #$80	                lda #%10000000
.912a		14 1c		trb $1c		                trb status
.912c						_new_word:
.912c		a5 06		lda $06		                lda workword
.912e		85 02		sta $02		                sta dp
.9130		a5 07		lda $07		                lda workword+1
.9132		85 03		sta $03		                sta dp+1
.9134		20 f3 d7	jsr $d7f3	                jsr dp_to_current       ; Save the updated DP to the
.9137						_semicolon_done:
.9137		64 1a		stz $1a		                stz state
.9139		64 1b		stz $1b		                stz state+1
.913b		60		rts		z_semicolon:    rts
.913c						xt_sign:
.913c		20 89 d8	jsr $d889	                jsr underflow_1
.913f						w_sign:
.913f		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9141		30 04		bmi $9147	                bmi _minus
.9143		e8		inx		                inx
.9144		e8		inx		                inx
.9145		80 09		bra $9150	                bra _done
.9147						_minus:
.9147		a9 2d		lda #$2d	                lda #'-'
.9149		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.914b		74 01		stz $01,x	                stz 1,x         ; paranoid
.914d		20 09 89	jsr $8909	                jsr w_hold
.9150						_done:
.9150		60		rts		z_sign:         rts
.9151						xt_slash:
.9151		20 8e d8	jsr $d88e	                jsr underflow_2
.9154						w_slash:
.9154		a9 00		lda #$00	                lda #0
.9156		80 05		bra $915d	                bra slashmod_common
.9158						xt_slash_mod:
.9158		20 8e d8	jsr $d88e	                jsr underflow_2
.915b						w_slash_mod:
.915b		a9 ff		lda #$ff	                lda #$FF                ; falls through to _common
.915d						slashmod_common:
.915d		48		pha		                pha
.915e		20 60 93	jsr $9360	                jsr w_to_r             ; >R
.9161		20 c0 90	jsr $90c0	                jsr w_s_to_d           ; S>D
.9164		20 cc 8e	jsr $8ecc	                jsr w_r_from           ; R>
.9167		20 76 91	jsr $9176	                jsr w_sm_slash_rem     ; SM/REM
.916a		68		pla		                pla
.916b		d0 05		bne $9172	                bne _done
.916d		20 25 92	jsr $9225	                jsr w_swap
.9170		e8		inx		                inx             ; DROP
.9171		e8		inx		                inx
.9172						_done:
.9172						z_slash_mod:
.9172		60		rts		z_slash:        rts
.9173						xt_sm_slash_rem:
.9173		20 93 d8	jsr $d893	                jsr underflow_3 ; contains double number
.9176						w_sm_slash_rem:
.9176		b5 03		lda $03,x	                lda 3,x
.9178		48		pha		                pha
.9179		b5 01		lda $01,x	                lda 1,x
.917b		55 03		eor $03,x	                eor 3,x
.917d		48		pha		                pha
.917e		20 d2 80	jsr $80d2	                jsr w_abs
.9181		e8		inx		                inx             ; pretend we pushed n1 to R
.9182		e8		inx		                inx
.9183		20 98 9e	jsr $9e98	                jsr w_dabs
.9186		ca		dex		                dex
.9187		ca		dex		                dex
.9188		20 40 95	jsr $9540	                jsr w_um_slash_mod     ; UM/MOD
.918b		68		pla		                pla
.918c		10 03		bpl $9191	                bpl +
.918e		20 02 8c	jsr $8c02	                jsr w_negate
.9191						+
.9191		68		pla		                pla
.9192		10 07		bpl $919b	                bpl _done
.9194		e8		inx		                inx             ; pretend we pushed quotient to R
.9195		e8		inx		                inx
.9196		20 02 8c	jsr $8c02	                jsr w_negate
.9199		ca		dex		                dex
.919a		ca		dex		                dex
.919b						_done:
.919b		60		rts		z_sm_slash_rem: rts
.919c						xt_source:
.919c						w_source:
.919c		ca		dex		                dex
.919d		ca		dex		                dex
.919e		a5 0c		lda $0c		                lda cib
.91a0		95 00		sta $00,x	                sta 0,x
.91a2		a5 0d		lda $0d		                lda cib+1
.91a4		95 01		sta $01,x	                sta 1,x
.91a6		ca		dex		                dex
.91a7		ca		dex		                dex
.91a8		a5 0e		lda $0e		                lda ciblen
.91aa		95 00		sta $00,x	                sta 0,x
.91ac		a5 0f		lda $0f		                lda ciblen+1
.91ae		95 01		sta $01,x	                sta 1,x
.91b0		60		rts		z_source:       rts
.91b1						xt_source_id:
.91b1						w_source_id:
.91b1		ca		dex		                dex
.91b2		ca		dex		                dex
.91b3		a5 0a		lda $0a		                lda insrc
.91b5		95 00		sta $00,x	                sta 0,x
.91b7		a5 0b		lda $0b		                lda insrc+1
.91b9		95 01		sta $01,x	                sta 1,x
.91bb		60		rts		z_source_id:    rts
.91bc						xt_space:
.91bc						w_space:
.91bc		a9 20		lda #$20	                lda #AscSP
.91be		20 93 86	jsr $8693	                jsr emit_a
.91c1		60		rts		z_space:        rts
.91c2						xt_spaces:
.91c2		20 89 d8	jsr $d889	                jsr underflow_1
.91c5						w_spaces:
.91c5		b5 01		lda $01,x	                lda 1,x         ; ANS says this word takes a signed value
.91c7		30 10		bmi $91d9	                bmi _done       ; but prints no spaces for negative values.
.91c9		b4 00		ldy $00,x	                ldy 0,x
.91cb		f0 08		beq $91d5	                beq _msb
.91cd						_loop:
.91cd		a9 20		lda #$20	                lda #AscSP
.91cf		20 93 86	jsr $8693	                jsr emit_a      ; user routine preserves X and Y
.91d2		88		dey		                dey
.91d3		d0 f8		bne $91cd	                bne _loop       ; Y is zero on exit so looping again emits 256 more spaces
.91d5						_msb:
.91d5		d6 01		dec $01,x	                dec 1,x         ; when decrementing MSB goes negative, it was zero so we're done
.91d7		10 f4		bpl $91cd	                bpl _loop       ; otherwise emit another 256 spaces
.91d9		e8		inx		_done:          inx
.91da		e8		inx		                inx
.91db		60		rts		z_spaces:       rts
.91dc						xt_star:
.91dc		20 8e d8	jsr $d88e	                jsr underflow_2
.91df						w_star:
.91df		20 82 95	jsr $9582	                jsr w_um_star
.91e2		e8		inx		                inx
.91e3		e8		inx		                inx
.91e4		60		rts		z_star:         rts
.91e5						xt_star_slash:
.91e5		20 93 d8	jsr $d893	                jsr underflow_3
.91e8						w_star_slash:
.91e8		20 f4 91	jsr $91f4	                jsr w_star_slash_mod
.91eb		20 25 92	jsr $9225	                jsr w_swap
.91ee		e8		inx		                inx
.91ef		e8		inx		                inx
.91f0						z_star_slash:
.91f0		60		rts		                rts
.91f1						xt_star_slash_mod:
.91f1		20 93 d8	jsr $d893	                jsr underflow_3
.91f4						w_star_slash_mod:
.91f4		20 60 93	jsr $9360	                jsr w_to_r
.91f7		20 0f 8b	jsr $8b0f	                jsr w_m_star
.91fa		20 cc 8e	jsr $8ecc	                jsr w_r_from
.91fd		20 76 91	jsr $9176	                jsr w_sm_slash_rem
.9200						z_star_slash_mod:
.9200		60		rts		                rts
.9201						xt_state:
.9201						w_state:
.9201		ca		dex		                dex
.9202		ca		dex		                dex
.9203		a9 1a		lda #$1a	                lda #<state
.9205		95 00		sta $00,x	                sta 0,x
.9207		a9 00		lda #$00	                lda #>state
.9209		95 01		sta $01,x	                sta 1,x
.920b		60		rts		z_state:        rts
.920c						xt_store:
.920c		20 8e d8	jsr $d88e	                jsr underflow_2
.920f						w_store:
.920f		b5 02		lda $02,x	                lda 2,x         ; LSB
.9211		81 00		sta ($00,x)	                sta (0,x)
.9213		f6 00		inc $00,x	                inc 0,x
.9215		d0 02		bne $9219	                bne +
.9217		f6 01		inc $01,x	                inc 1,x
.9219						+
.9219		b5 03		lda $03,x	                lda 3,x         ; MSB
.921b		81 00		sta ($00,x)	                sta (0,x)
.921d		e8		inx		                inx             ; 2DROP
.921e		e8		inx		                inx
.921f		e8		inx		                inx
.9220		e8		inx		                inx
.9221		60		rts		z_store:        rts
.9222						xt_swap:
.9222		20 8e d8	jsr $d88e	                jsr underflow_2
.9225						w_swap:
.9225		b5 00		lda $00,x	                lda 0,x         ; LSB
.9227		b4 02		ldy $02,x	                ldy 2,x
.9229		95 02		sta $02,x	                sta 2,x
.922b		94 00		sty $00,x	                sty 0,x
.922d		b5 01		lda $01,x	                lda 1,x         ; MSB
.922f		b4 03		ldy $03,x	                ldy 3,x
.9231		95 03		sta $03,x	                sta 3,x
.9233		94 01		sty $01,x	                sty 1,x
.9235		60		rts		z_swap:         rts
.9236						xt_tick:
.9236						w_tick:
.9236		20 2d 8d	jsr $8d2d	                jsr w_parse_name       ; ( -- addr u )
.9239		b5 00		lda $00,x	                lda 0,x
.923b		15 01		ora $01,x	                ora 1,x
.923d		d0 05		bne $9244	                bne +
.923f		a9 05		lda #$05	                lda #err_noname
.9241		4c 9f d8	jmp $d89f	                jmp error
.9244						+
.9244		20 3d 9b	jsr $9b3d	                jsr w_find_name        ; ( addr u -- nt )
.9247		b5 00		lda $00,x	                lda 0,x
.9249		15 01		ora $01,x	                ora 1,x
.924b		d0 05		bne $9252	                bne +
.924d		a9 08		lda #$08	                lda #err_syntax
.924f		4c 9f d8	jmp $d89f	                jmp error
.9252						+
.9252		20 86 9c	jsr $9c86	                jsr w_name_to_int      ; ( nt -- xt )
.9255		60		rts		z_tick:         rts
.9256						xt_to:
.9256						w_to:
.9256		20 36 92	jsr $9236	                jsr w_tick             ; ( [n] xt )
.9259		b5 00		lda $00,x	                lda 0,x                 ; LSB
.925b		18		clc		                clc
.925c		69 03		adc #$03	                adc #3
.925e		85 25		sta $25		                sta tmp1
.9260		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9262		69 00		adc #$00	                adc #0                  ; we just want the carry
.9264		85 26		sta $26		                sta tmp1+1
.9266		a5 1a		lda $1a		                lda state
.9268		05 1b		ora $1b		                ora state+1
.926a		f0 14		beq $9280	                beq _interpret
.926c		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.926e		95 00		sta $00,x	                sta 0,x
.9270		a5 26		lda $26		                lda tmp1+1
.9272		95 01		sta $01,x	                sta 1,x
.9274		20 e0 89	jsr $89e0	                jsr w_literal      ; generate the runtime for LITERAL tmp1
.9277		a0 92		ldy #$92	                ldy #>w_store      ; write the runtime for !
.9279		a9 0f		lda #$0f	                lda #<w_store
.927b		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.927e		80 11		bra $9291	                bra _done
.9280						_interpret:
.9280		20 8e d8	jsr $d88e	                jsr underflow_2
.9283		e8		inx		                inx
.9284		e8		inx		                inx                     ; leaving just ( n )
.9285		b5 00		lda $00,x	                lda 0,x
.9287		92 25		sta ($25)	                sta (tmp1)              ; LSB
.9289		a0 01		ldy #$01	                ldy #1
.928b		b5 01		lda $01,x	                lda 1,x                 ; MSB
.928d		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.928f		e8		inx		                inx                     ; DROP
.9290		e8		inx		                inx
.9291						_done:
.9291		60		rts		z_to:           rts
.9292						xt_to_body:
.9292		20 89 d8	jsr $d889	                jsr underflow_1
.9295						w_to_body:
.9295		20 69 86	jsr $8669	                jsr w_dup              ; ( xt xt )
.9298		20 00 9c	jsr $9c00	                jsr w_int_to_name      ; ( xt nt )
.929b		f6 00		inc $00,x	                inc 0,x
.929d		d0 02		bne $92a1	                bne +
.929f		f6 01		inc $01,x	                inc 1,x
.92a1						+
.92a1		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.92a3		29 10		and #$10	                and #HC
.92a5		f0 0b		beq $92b2	                beq _no_cfa
.92a7		18		clc		                clc
.92a8		b5 02		lda $02,x	                lda 2,x         ; LSB
.92aa		69 03		adc #$03	                adc #3
.92ac		95 02		sta $02,x	                sta 2,x
.92ae		90 02		bcc $92b2	                bcc _no_cfa
.92b0		f6 03		inc $03,x	                inc 3,x         ; MSB
.92b2						_no_cfa:
.92b2		e8		inx		                inx             ; get rid of the nt
.92b3		e8		inx		                inx
.92b4		60		rts		z_to_body:      rts
.92b5						xt_to_in:
.92b5						w_to_in:
.92b5		ca		dex		                dex
.92b6		ca		dex		                dex
.92b7		a9 10		lda #$10	                lda #<toin
.92b9		95 00		sta $00,x	                sta 0,x
.92bb		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.92bd		95 01		sta $01,x	                sta 1,x
.92bf		60		rts		z_to_in:        rts
.92c0						xt_to_number:
.92c0		20 98 d8	jsr $d898	                jsr underflow_4
.92c3						w_to_number:
.92c3		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.92c5		85 2d		sta $2d		                sta scratch
.92c7		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.92c9		85 2e		sta $2e		                sta scratch+1
.92cb		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.92cd		85 2f		sta $2f		                sta scratch+2
.92cf		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.92d1		85 30		sta $30		                sta scratch+3
.92d3		ca		dex		                dex
.92d4		ca		dex		                dex
.92d5						_loop:
.92d5		a1 04		lda ($04,x)	                lda (4,x)
.92d7		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.92d9		74 01		stz $01,x	                stz 1,x                 ; paranoid
.92db		20 e1 9a	jsr $9ae1	                jsr w_digit_question   ; ( char -- n -1 | char 0 )
.92de		b5 00		lda $00,x	                lda 0,x
.92e0		d0 04		bne $92e6	                bne _digit_ok
.92e2		e8		inx		                inx
.92e3		e8		inx		                inx
.92e4		80 67		bra $934d	                bra _done       ; ( ud-lo ud-hi addr u char )
.92e6						_digit_ok:
.92e6		b5 02		lda $02,x	                lda 2,x
.92e8		85 31		sta $31		                sta scratch+4
.92ea		b5 03		lda $03,x	                lda 3,x
.92ec		85 32		sta $32		                sta scratch+5
.92ee		a5 2f		lda $2f		                lda scratch+2
.92f0		95 02		sta $02,x	                sta 2,x         ; NOS
.92f2		a5 30		lda $30		                lda scratch+3
.92f4		95 03		sta $03,x	                sta 3,x
.92f6		a5 18		lda $18		                lda base
.92f8		95 00		sta $00,x	                sta 0,x         ; TOS
.92fa		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.92fc		20 82 95	jsr $9582	                jsr w_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.92ff		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.9301		85 33		sta $33		                sta scratch+6
.9303		b5 03		lda $03,x	                lda 3,x
.9305		85 34		sta $34		                sta scratch+7
.9307		a5 2d		lda $2d		                lda scratch
.9309		95 02		sta $02,x	                sta 2,x
.930b		a5 2e		lda $2e		                lda scratch+1
.930d		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.930f		a5 18		lda $18		                lda base
.9311		95 00		sta $00,x	                sta 0,x
.9313		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.9315		20 82 95	jsr $9582	                jsr w_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9318		b5 00		lda $00,x	                lda 0,x
.931a		85 2f		sta $2f		                sta scratch+2
.931c		b5 01		lda $01,x	                lda 1,x
.931e		85 30		sta $30		                sta scratch+3
.9320		b5 02		lda $02,x	                lda 2,x
.9322		85 2d		sta $2d		                sta scratch
.9324		b5 03		lda $03,x	                lda 3,x
.9326		85 2e		sta $2e		                sta scratch+1
.9328		18		clc		                clc
.9329		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.932b		65 31		adc $31		                adc scratch+4   ; n LSB
.932d		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.932f		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.9331		65 32		adc $32		                adc scratch+5   ; n MSB
.9333		85 2e		sta $2e		                sta scratch+1
.9335		a5 2f		lda $2f		                lda scratch+2   ; LSB
.9337		65 33		adc $33		                adc scratch+6
.9339		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.933b		a5 30		lda $30		                lda scratch+3   ; MSB
.933d		65 34		adc $34		                adc scratch+7
.933f		85 30		sta $30		                sta scratch+3
.9341		e8		inx		                inx
.9342		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.9343		f6 04		inc $04,x	                inc 4,x
.9345		d0 02		bne $9349	                bne +
.9347		f6 05		inc $05,x	                inc 5,x
.9349						+
.9349		d6 02		dec $02,x	                dec 2,x
.934b		d0 88		bne $92d5	                bne _loop
.934d						_done:
.934d		e8		inx		                inx
.934e		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.934f		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.9351		95 06		sta $06,x	                sta 6,x
.9353		a5 2e		lda $2e		                lda scratch+1
.9355		95 07		sta $07,x	                sta 7,x
.9357		a5 2f		lda $2f		                lda scratch+2
.9359		95 04		sta $04,x	                sta 4,x
.935b		a5 30		lda $30		                lda scratch+3
.935d		95 05		sta $05,x	                sta 5,x
.935f		60		rts		z_to_number:    rts
.9360						xt_to_r:
.9360						w_to_r:
.9360		68		pla		                pla                     ; LSB
.9361		7a		ply		                ply                     ; MSB
.9362		1a		inc a		                inc a
.9363		85 25		sta $25		                sta tmp1                ; LSB
.9365		d0 01		bne $9368	                bne +
.9367		c8		iny		                iny
.9368						+
.9368		84 26		sty $26		                sty tmp1+1              ; MSB
.936a		20 89 d8	jsr $d889	                jsr underflow_1
.936d		b5 01		lda $01,x	                lda 1,x         ; MSB
.936f		48		pha		                pha
.9370		b5 00		lda $00,x	                lda 0,x         ; LSB
.9372		48		pha		                pha
.9373		e8		inx		                inx
.9374		e8		inx		                inx
.9375		6c 25 00	jmp ($0025)	z_to_r:         jmp (tmp1)
.9378						xt_true:
.9378						w_true:
.9378		ca		dex		                dex
.9379		ca		dex		                dex
.937a		a9 ff		lda #$ff	                lda #$FF
.937c		95 00		sta $00,x	                sta 0,x
.937e		95 01		sta $01,x	                sta 1,x
.9380		60		rts		z_true:         rts
.9381						xt_tuck:
.9381		20 8e d8	jsr $d88e	                jsr underflow_2
.9384						w_tuck:
.9384		ca		dex		                dex
.9385		ca		dex		                dex
.9386		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.9388		b5 02		lda $02,x	                lda 2,x
.938a		95 04		sta $04,x	                sta 4,x
.938c		94 02		sty $02,x	                sty 2,x
.938e		95 00		sta $00,x	                sta 0,x
.9390		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.9392		b5 03		lda $03,x	                lda 3,x
.9394		95 05		sta $05,x	                sta 5,x
.9396		94 03		sty $03,x	                sty 3,x         ; bba
.9398		95 01		sta $01,x	                sta 1,x         ; baa
.939a		60		rts		z_tuck:         rts
.939b						xt_two_drop:
.939b		20 8e d8	jsr $d88e	                jsr underflow_2
.939e						w_two_drop:
.939e		e8		inx		                inx
.939f		e8		inx		                inx
.93a0		e8		inx		                inx
.93a1		e8		inx		                inx
.93a2		60		rts		z_two_drop:     rts
.93a3						xt_two_dup:
.93a3		20 8e d8	jsr $d88e	                jsr underflow_2
.93a6						w_two_dup:
.93a6		ca		dex		                dex
.93a7		ca		dex		                dex
.93a8		ca		dex		                dex
.93a9		ca		dex		                dex
.93aa		b5 04		lda $04,x	                lda 4,x         ; TOS
.93ac		95 00		sta $00,x	                sta 0,x
.93ae		b5 05		lda $05,x	                lda 5,x
.93b0		95 01		sta $01,x	                sta 1,x
.93b2		b5 06		lda $06,x	                lda 6,x         ; NOS
.93b4		95 02		sta $02,x	                sta 2,x
.93b6		b5 07		lda $07,x	                lda 7,x
.93b8		95 03		sta $03,x	                sta 3,x
.93ba		60		rts		z_two_dup:      rts
.93bb						xt_two_fetch:
.93bb		20 89 d8	jsr $d889	                jsr underflow_1
.93be						w_two_fetch:
.93be		b5 00		lda $00,x	                lda 0,x
.93c0		85 25		sta $25		                sta tmp1
.93c2		b4 01		ldy $01,x	                ldy 1,x
.93c4		84 26		sty $26		                sty tmp1+1
.93c6		ca		dex		                dex             ; reuse one stack element
.93c7		ca		dex		                dex
.93c8		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.93ca		95 00		sta $00,x	                sta 0,x
.93cc		a0 01		ldy #$01	                ldy #1          ; copy next
.93ce		b1 25		lda ($25),y	                lda (tmp1),y
.93d0		95 01		sta $01,x	                sta 1,x
.93d2		c8		iny		                iny             ; copy next
.93d3		b1 25		lda ($25),y	                lda (tmp1),y
.93d5		95 02		sta $02,x	                sta 2,x
.93d7		c8		iny		                iny             ; copy next
.93d8		b1 25		lda ($25),y	                lda (tmp1),y
.93da		95 03		sta $03,x	                sta 3,x
.93dc		60		rts		z_two_fetch:    rts
.93dd						xt_two_over:
.93dd		20 98 d8	jsr $d898	                jsr underflow_4
.93e0						w_two_over:
.93e0		ca		dex		                dex
.93e1		ca		dex		                dex
.93e2		ca		dex		                dex
.93e3		ca		dex		                dex
.93e4		b5 08		lda $08,x	                lda 8,x
.93e6		95 00		sta $00,x	                sta 0,x
.93e8		b5 09		lda $09,x	                lda 9,x
.93ea		95 01		sta $01,x	                sta 1,x
.93ec		b5 0a		lda $0a,x	                lda 10,x
.93ee		95 02		sta $02,x	                sta 2,x
.93f0		b5 0b		lda $0b,x	                lda 11,x
.93f2		95 03		sta $03,x	                sta 3,x
.93f4		60		rts		z_two_over:     rts
.93f5						xt_two_r_fetch:
.93f5						w_two_r_fetch:
.93f5		68		pla		                pla                     ; LSB
.93f6		7a		ply		                ply                     ; MSB
.93f7		1a		inc a		                inc a
.93f8		85 25		sta $25		                sta tmp1                ; LSB
.93fa		d0 01		bne $93fd	                bne +
.93fc		c8		iny		                iny
.93fd						+
.93fd		84 26		sty $26		                sty tmp1+1              ; MSB
.93ff		8a		txa		                txa             ; arrange for Y = SP; X -= 4
.9400		ba		tsx		                tsx
.9401		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.9402		7a		ply		                ply
.9403		38		sec		                sec
.9404		e9 04		sbc #$04	                sbc #4
.9406		aa		tax		                tax
.9407		b9 01 01	lda $0101,y	                lda $101,y
.940a		95 00		sta $00,x	                sta 0,x
.940c		b9 02 01	lda $0102,y	                lda $102,y
.940f		95 01		sta $01,x	                sta 1,x
.9411		b9 03 01	lda $0103,y	                lda $103,y
.9414		95 02		sta $02,x	                sta 2,x
.9416		b9 04 01	lda $0104,y	                lda $104,y
.9419		95 03		sta $03,x	                sta 3,x
.941b		6c 25 00	jmp ($0025)	z_two_r_fetch:  jmp (tmp1)
.941e						xt_two_r_from:
.941e						w_two_r_from:
.941e		68		pla		                pla
.941f		7a		ply		                ply                     ; MSB
.9420		1a		inc a		                inc a
.9421		85 25		sta $25		                sta tmp1                ; LSB
.9423		d0 01		bne $9426	                bne +
.9425		c8		iny		                iny
.9426						+
.9426		84 26		sty $26		                sty tmp1+1              ; MSB
.9428		ca		dex		                dex
.9429		ca		dex		                dex
.942a		ca		dex		                dex
.942b		ca		dex		                dex
.942c		68		pla		                pla                     ; LSB
.942d		95 00		sta $00,x	                sta 0,x
.942f		68		pla		                pla                     ; MSB
.9430		95 01		sta $01,x	                sta 1,x
.9432		68		pla		                pla                     ; LSB
.9433		95 02		sta $02,x	                sta 2,x
.9435		68		pla		                pla                     ; MSB
.9436		95 03		sta $03,x	                sta 3,x
.9438		6c 25 00	jmp ($0025)	z_two_r_from:   jmp (tmp1)
.943b						xt_two_slash:
.943b		20 89 d8	jsr $d889	                jsr underflow_1
.943e						w_two_slash:
.943e		b5 01		lda $01,x	                lda 1,x
.9440		0a		asl a		                asl                     ; save the sign
.9441		76 01		ror $01,x	                ror 1,x
.9443		76 00		ror $00,x	                ror 0,x
.9445		60		rts		z_two_slash:    rts
.9446						xt_two_star:
.9446						xt_cells:
.9446		20 89 d8	jsr $d889	                jsr underflow_1
.9449						w_two_star:
.9449						w_cells:
.9449		16 00		asl $00,x	                asl 0,x
.944b		36 01		rol $01,x	                rol 1,x
.944d						z_cells:
.944d		60		rts		z_two_star:     rts
.944e						xt_two_store:
.944e		20 93 d8	jsr $d893	                jsr underflow_3
.9451						w_two_store:
.9451		b5 00		lda $00,x	                lda 0,x
.9453		85 25		sta $25		                sta tmp1
.9455		b4 01		ldy $01,x	                ldy 1,x
.9457		84 26		sty $26		                sty tmp1+1
.9459		e8		inx		                inx
.945a		e8		inx		                inx
.945b		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.945d		92 25		sta ($25)	                sta (tmp1)
.945f		b5 01		lda $01,x	                lda 1,x         ; copy next
.9461		a0 01		ldy #$01	                ldy #1
.9463		91 25		sta ($25),y	                sta (tmp1),y
.9465		b5 02		lda $02,x	                lda 2,x         ; copy next
.9467		c8		iny		                iny
.9468		91 25		sta ($25),y	                sta (tmp1),y
.946a		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.946c		c8		iny		                iny
.946d		91 25		sta ($25),y	                sta (tmp1),y
.946f		e8		inx		                inx             ; 2DROP
.9470		e8		inx		                inx
.9471		e8		inx		                inx
.9472		e8		inx		                inx
.9473		60		rts		z_two_store:    rts
.9474						xt_two_swap:
.9474		20 98 d8	jsr $d898	                jsr underflow_4
.9477						w_two_swap:
.9477		b5 00		lda $00,x	                lda 0,x
.9479		b4 04		ldy $04,x	                ldy 4,x
.947b		95 04		sta $04,x	                sta 4,x
.947d		94 00		sty $00,x	                sty 0,x
.947f		b5 01		lda $01,x	                lda 1,x
.9481		b4 05		ldy $05,x	                ldy 5,x
.9483		95 05		sta $05,x	                sta 5,x
.9485		94 01		sty $01,x	                sty 1,x
.9487		b5 02		lda $02,x	                lda 2,x
.9489		b4 06		ldy $06,x	                ldy 6,x
.948b		95 06		sta $06,x	                sta 6,x
.948d		94 02		sty $02,x	                sty 2,x
.948f		b5 03		lda $03,x	                lda 3,x
.9491		b4 07		ldy $07,x	                ldy 7,x
.9493		95 07		sta $07,x	                sta 7,x
.9495		94 03		sty $03,x	                sty 3,x
.9497		60		rts		z_two_swap:     rts
.9498						xt_two_to_r:
.9498						w_two_to_r:
.9498		68		pla		                pla                     ; LSB
.9499		7a		ply		                ply                     ; MSB
.949a		1a		inc a		                inc a
.949b		85 25		sta $25		                sta tmp1                ; LSB
.949d		d0 01		bne $94a0	                bne +
.949f		c8		iny		                iny
.94a0						+
.94a0		84 26		sty $26		                sty tmp1+1              ; MSB
.94a2		20 8e d8	jsr $d88e	                jsr underflow_2
.94a5		b5 03		lda $03,x	                lda 3,x         ; MSB
.94a7		48		pha		                pha
.94a8		b5 02		lda $02,x	                lda 2,x         ; LSB
.94aa		48		pha		                pha
.94ab		b5 01		lda $01,x	                lda 1,x         ; MSB
.94ad		48		pha		                pha
.94ae		b5 00		lda $00,x	                lda 0,x         ; LSB
.94b0		48		pha		                pha
.94b1		e8		inx		                inx
.94b2		e8		inx		                inx
.94b3		e8		inx		                inx
.94b4		e8		inx		                inx
.94b5		6c 25 00	jmp ($0025)	z_two_to_r:     jmp (tmp1)
.94b8						xt_type:
.94b8		20 8e d8	jsr $d88e	                jsr underflow_2
.94bb						w_type:
.94bb		b5 02		lda $02,x	                lda 2,x
.94bd		85 25		sta $25		                sta tmp1
.94bf		b5 03		lda $03,x	                lda 3,x
.94c1		85 26		sta $26		                sta tmp1+1
.94c3						_loop:
.94c3		b5 00		lda $00,x	                lda 0,x
.94c5		15 01		ora $01,x	                ora 1,x
.94c7		f0 15		beq $94de	                beq _done
.94c9		b2 25		lda ($25)	                lda (tmp1)
.94cb		20 93 86	jsr $8693	                jsr emit_a      ; avoids stack foolery
.94ce		e6 25		inc $25		                inc tmp1
.94d0		d0 02		bne $94d4	                bne +
.94d2		e6 26		inc $26		                inc tmp1+1
.94d4						+
.94d4		b5 00		lda $00,x	                lda 0,x
.94d6		d0 02		bne $94da	                bne +
.94d8		d6 01		dec $01,x	                dec 1,x
.94da						+
.94da		d6 00		dec $00,x	                dec 0,x
.94dc		80 e5		bra $94c3	                bra _loop
.94de						_done:
.94de		e8		inx		                inx
.94df		e8		inx		                inx
.94e0		e8		inx		                inx
.94e1		e8		inx		                inx
.94e2		60		rts		z_type:         rts
.94e3						xt_u_dot:
.94e3		20 89 d8	jsr $d889	                jsr underflow_1
.94e6						w_u_dot:
.94e6		20 f5 d8	jsr $d8f5	                jsr print_u
.94e9		a9 20		lda #$20	                lda #AscSP
.94eb		20 93 86	jsr $8693	                jsr emit_a
.94ee		60		rts		z_u_dot:        rts
.94ef						xt_u_dot_r:
.94ef		20 8e d8	jsr $d88e	                jsr underflow_2
.94f2						w_u_dot_r:
.94f2		20 60 93	jsr $9360	                jsr w_to_r
.94f5		20 46 9e	jsr $9e46	                jsr w_zero
.94f8		20 ba 89	jsr $89ba	                jsr w_less_number_sign
.94fb		20 92 8c	jsr $8c92	                jsr w_number_sign_s
.94fe		20 70 8c	jsr $8c70	                jsr w_number_sign_greater
.9501		20 cc 8e	jsr $8ecc	                jsr w_r_from
.9504		20 e4 8c	jsr $8ce4	                jsr w_over
.9507		20 c4 8b	jsr $8bc4	                jsr w_minus
.950a		20 c5 91	jsr $91c5	                jsr w_spaces
.950d		20 bb 94	jsr $94bb	                jsr w_type
.9510		60		rts		z_u_dot_r:      rts
.9511						xt_u_greater_than:
.9511		20 8e d8	jsr $d88e	                jsr underflow_2
.9514						w_u_greater_than:
.9514		b5 00		lda $00,x	                lda 0,x
.9516		d5 02		cmp $02,x	                cmp 2,x
.9518		b5 01		lda $01,x	                lda 1,x
.951a		f5 03		sbc $03,x	                sbc 3,x
.951c		e8		inx		                inx
.951d		e8		inx		                inx
.951e		a9 00		lda #$00	                lda #0
.9520		69 ff		adc #$ff	                adc #$FF
.9522		95 00		sta $00,x	                sta 0,x         ; store flag
.9524		95 01		sta $01,x	                sta 1,x
.9526		60		rts		z_u_greater_than:    rts
.9527						xt_u_less_than:
.9527		20 8e d8	jsr $d88e	                jsr underflow_2
.952a						w_u_less_than:
.952a		b5 02		lda $02,x	                lda 2,x
.952c		d5 00		cmp $00,x	                cmp 0,x
.952e		b5 03		lda $03,x	                lda 3,x
.9530		f5 01		sbc $01,x	                sbc 1,x
.9532		e8		inx		                inx
.9533		e8		inx		                inx
.9534		a9 00		lda #$00	                lda #0
.9536		69 ff		adc #$ff	                adc #$FF
.9538		95 00		sta $00,x	                sta 0,x         ; store flag
.953a		95 01		sta $01,x	                sta 1,x
.953c		60		rts		z_u_less_than:    rts
.953d						xt_um_slash_mod:
.953d		20 93 d8	jsr $d893	                jsr underflow_3
.9540						w_um_slash_mod:
.9540		b5 00		lda $00,x	                lda 0,x
.9542		15 01		ora $01,x	                ora 1,x
.9544		d0 05		bne $954b	                bne _not_zero
.9546		a9 04		lda #$04	                lda #err_divzero
.9548		4c 9f d8	jmp $d89f	                jmp error
.954b						_not_zero:
.954b		a9 11		lda #$11	                lda #17
.954d		85 23		sta $23		                sta tmptos
.954f						_loop:
.954f		36 04		rol $04,x	                rol 4,x
.9551		36 05		rol $05,x	                rol 5,x
.9553		c6 23		dec $23		                dec tmptos
.9555		f0 22		beq $9579	                beq _done
.9557		36 02		rol $02,x	                rol 2,x
.9559		36 03		rol $03,x	                rol 3,x
.955b		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.955d		26 25		rol $25		                rol tmp1
.955f		38		sec		                sec
.9560		b5 02		lda $02,x	                lda 2,x
.9562		f5 00		sbc $00,x	                sbc 0,x
.9564		85 26		sta $26		                sta tmp1+1
.9566		b5 03		lda $03,x	                lda 3,x
.9568		f5 01		sbc $01,x	                sbc 1,x
.956a		a8		tay		                tay
.956b		a5 25		lda $25		                lda tmp1
.956d		e9 00		sbc #$00	                sbc #0
.956f		90 de		bcc $954f	                bcc _loop
.9571		a5 26		lda $26		                lda tmp1+1
.9573		95 02		sta $02,x	                sta 2,x
.9575		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.9577		80 d6		bra $954f	                bra _loop
.9579						_done:
.9579		e8		inx		                inx
.957a		e8		inx		                inx
.957b		20 25 92	jsr $9225	                jsr w_swap
.957e		60		rts		z_um_slash_mod: rts
.957f						xt_um_star:
.957f		20 8e d8	jsr $d88e	                jsr underflow_2
.9582						w_um_star:
.9582		18		clc		                clc
.9583		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.9585		e9 00		sbc #$00	                sbc #0
.9587		85 27		sta $27		                sta tmp2
.9589		b5 01		lda $01,x	                lda 1,x
.958b		e9 00		sbc #$00	                sbc #0
.958d		90 31		bcc $95c0	                bcc _zero       ; is TOS zero?
.958f		85 28		sta $28		                sta tmp2+1
.9591		a9 00		lda #$00	                lda #0
.9593		85 25		sta $25		                sta tmp1
.9595		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.9597		ca		dex		                dex
.9598		ca		dex		                dex
.9599						_outer_loop:
.9599		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.959b		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.959d						_inner_loop:
.959d		90 0c		bcc $95ab	                bcc _no_add
.959f		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.95a1		a5 25		lda $25		                lda tmp1
.95a3		65 27		adc $27		                adc tmp2
.95a5		85 25		sta $25		                sta tmp1
.95a7		a5 26		lda $26		                lda tmp1+1
.95a9		65 28		adc $28		                adc tmp2+1
.95ab						_no_add:
.95ab		6a		ror a		                ror
.95ac		66 25		ror $25		                ror tmp1
.95ae		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.95b0		88		dey		                dey
.95b1		d0 ea		bne $959d	                bne _inner_loop ; go back for one more shift?
.95b3		e8		inx		                inx
.95b4		e4 29		cpx $29		                cpx tmp3
.95b6		d0 e1		bne $9599	                bne _outer_loop ; go back for eight more shifts?
.95b8		95 01		sta $01,x	                sta 1,x
.95ba		a5 25		lda $25		                lda tmp1
.95bc		95 00		sta $00,x	                sta 0,x
.95be		80 04		bra $95c4	                bra _done
.95c0						_zero:
.95c0		74 02		stz $02,x	                stz 2,x
.95c2		74 03		stz $03,x	                stz 3,x
.95c4						_done:
.95c4		60		rts		z_um_star:      rts
.95c5						xt_unloop:
.95c5						w_unloop:
.95c5		a4 1f		ldy $1f		                ldy loopctrl
.95c7		88		dey		                dey
.95c8		88		dey		                dey
.95c9		88		dey		                dey
.95ca		88		dey		                dey
.95cb		84 1f		sty $1f		                sty loopctrl
.95cd		30 05		bmi $95d4	                bmi z_unloop            ; no active loops?
.95cf		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.95d2		85 20		sta $20		                sta loopidx0
.95d4		60		rts		z_unloop:       rts
.95d5						xt_until:
.95d5		20 89 d8	jsr $d889	                jsr underflow_1
.95d8						w_until:
.95d8		20 e8 97	jsr $97e8	                jsr cmpl_0branch_tos
.95db		60		rts		z_until:        rts
.95dc						xt_unused:
.95dc						w_unused:
.95dc		ca		dex		                dex
.95dd		ca		dex		                dex
.95de		a9 00		lda #$00	                lda #<cp_end
.95e0		38		sec		                sec
.95e1		e5 00		sbc $00		                sbc cp
.95e3		95 00		sta $00,x	                sta 0,x
.95e5		a9 7c		lda #$7c	                lda #>cp_end
.95e7		e5 01		sbc $01		                sbc cp+1
.95e9		95 01		sta $01,x	                sta 1,x
.95eb		60		rts		z_unused:       rts
.95ec						xt_variable:
.95ec						w_variable:
.95ec		20 0b 84	jsr $840b	                jsr w_create
.95ef		a9 00		lda #$00	                lda #0
.95f1		20 b8 97	jsr $97b8	                jsr cmpl_a
.95f4		20 b8 97	jsr $97b8	                jsr cmpl_a
.95f7		20 d3 83	jsr $83d3	                jsr adjust_z
.95fa		60		rts		z_variable:     rts
.95fb						xt_while:
.95fb		20 89 d8	jsr $d889	                jsr underflow_1
.95fe						w_while:
.95fe		20 d3 97	jsr $97d3	                jsr cmpl_0branch_later          ; branch to location we'll determine later
.9601		20 25 92	jsr $9225	                jsr w_swap
.9604		60		rts		z_while:        rts
.9605						xt_within:
.9605		20 93 d8	jsr $d893	                jsr underflow_3
.9608						w_within:
.9608		20 e4 8c	jsr $8ce4	                jsr w_over
.960b		20 c4 8b	jsr $8bc4	                jsr w_minus
.960e		20 60 93	jsr $9360	                jsr w_to_r
.9611		20 c4 8b	jsr $8bc4	                jsr w_minus
.9614		20 cc 8e	jsr $8ecc	                jsr w_r_from
.9617		20 2a 95	jsr $952a	                jsr w_u_less_than
.961a		60		rts		z_within:       rts
.961b						xt_word:
.961b		20 89 d8	jsr $d889	                jsr underflow_1
.961e						w_word:
.961e		a4 10		ldy $10		                ldy toin                ; >IN
.9620						_loop:
.9620		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.9622		f0 09		beq $962d	                beq _found_char
.9624		b1 0c		lda ($0c),y	                lda (cib),y
.9626		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.9628		d0 03		bne $962d	                bne _found_char
.962a		c8		iny		                iny
.962b		80 f3		bra $9620	                bra _loop
.962d						_found_char:
.962d		84 10		sty $10		                sty toin
.962f		20 8b 8d	jsr $8d8b	                jsr w_parse            ; Returns ( addr u )
.9632		b5 00		lda $00,x	                lda 0,x
.9634		92 00		sta ($00)	                sta (cp)                ; Save length of string
.9636		48		pha		                pha                     ; Keep copy of length for later
.9637		20 69 86	jsr $8669	                jsr w_dup              ; ( addr u u )
.963a		a5 00		lda $00		                lda cp
.963c		18		clc		                clc
.963d		69 01		adc #$01	                adc #1
.963f		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.9641		a5 01		lda $01		                lda cp+1
.9643		69 00		adc #$00	                adc #0
.9645		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.9647		20 e0 8b	jsr $8be0	                jsr w_move
.964a		ca		dex		                dex
.964b		ca		dex		                dex
.964c		a5 00		lda $00		                lda cp
.964e		95 00		sta $00,x	                sta 0,x
.9650		a5 01		lda $01		                lda cp+1
.9652		95 01		sta $01,x	                sta 1,x
.9654		68		pla		                pla                     ; length of string
.9655		18		clc		                clc
.9656		65 00		adc $00		                adc cp
.9658		85 00		sta $00		                sta cp
.965a		90 02		bcc $965e	                bcc z_word
.965c		e6 01		inc $01		                inc cp+1
.965e		60		rts		z_word:         rts
.965f						xt_xor:
.965f		20 8e d8	jsr $d88e	                jsr underflow_2
.9662						w_xor:
.9662		b5 00		lda $00,x	                lda 0,x
.9664		55 02		eor $02,x	                eor 2,x
.9666		95 02		sta $02,x	                sta 2,x
.9668		b5 01		lda $01,x	                lda 1,x
.966a		55 03		eor $03,x	                eor 3,x
.966c		95 03		sta $03,x	                sta 3,x
.966e		e8		inx		                inx
.966f		e8		inx		                inx
.9670		60		rts		z_xor:          rts
.9671						xt_zero_equal:
.9671		20 89 d8	jsr $d889	                jsr underflow_1
.9674						w_zero_equal:
.9674		b5 00		lda $00,x	                lda 0,x
.9676		15 01		ora $01,x	                ora 1,x
.9678		f0 02		beq $967c	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.967a		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.967c						_zero:
.967c		49 ff		eor #$ff	                eor #$FF        ; now just invert:
.967e		95 00		sta $00,x	                sta 0,x
.9680		95 01		sta $01,x	                sta 1,x
.9682		60		rts		z_zero_equal:   rts
.9683						xt_zero_greater:
.9683		20 89 d8	jsr $d889	                jsr underflow_1
.9686						w_zero_greater:
.9686		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.9688		b5 01		lda $01,x	                lda 1,x         ; MSB
.968a		30 05		bmi $9691	                bmi _done       ; TOS is negative, keep FLASE
.968c		15 00		ora $00,x	                ora 0,x
.968e		f0 01		beq $9691	                beq _done       ; TOS is zero, keep FALSE
.9690		88		dey		                dey             ; TOS is postive, make true
.9691						_done:
.9691		98		tya		                tya
.9692		95 00		sta $00,x	                sta 0,x
.9694		95 01		sta $01,x	                sta 1,x
.9696		60		rts		z_zero_greater: rts
.9697						xt_zero_less:
.9697		20 89 d8	jsr $d889	                jsr underflow_1
.969a						w_zero_less:
.969a		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.969c		b5 01		lda $01,x	                lda 1,x         ; MSB
.969e		10 01		bpl $96a1	                bpl _done       ; TOS is positive, so keep FALSE
.96a0		88		dey		                dey             ; TOS is negative, make TRUE
.96a1						_done:
.96a1		98		tya		                tya
.96a2		95 00		sta $00,x	                sta 0,x
.96a4		95 01		sta $01,x	                sta 1,x
.96a6		60		rts		z_zero_less:    rts
.96a7						xt_zero_unequal:
.96a7		20 89 d8	jsr $d889	                jsr underflow_1
.96aa						w_zero_unequal:
.96aa		b5 00		lda $00,x	                lda 0,x
.96ac		15 01		ora $01,x	                ora 1,x
.96ae		f0 02		beq $96b2	                beq _zero
.96b0		a9 ff		lda #$ff	                lda #$FF
.96b2						_zero:
.96b2		95 00		sta $00,x	                sta 0,x
.96b4		95 01		sta $01,x	                sta 1,x
.96b6		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/compile.asm

.96b7						xt_compile_comma:
.96b7		20 89 d8	jsr $d889	                jsr underflow_1
.96ba						w_compile_comma:
.96ba		20 69 86	jsr $8669	                jsr w_dup              ; keep an unadjusted copy of xt
.96bd		20 69 86	jsr $8669	                jsr w_dup              ; plus one to convert to nt
.96c0		20 00 9c	jsr $9c00	                jsr w_int_to_name
.96c3		b5 00		lda $00,x	                lda 0,x
.96c5		15 01		ora $01,x	                ora 1,x
.96c7		f0 73		beq $973c	                beq cmpl_as_call        ; No nt so unknown size; must compile as a JSR
.96c9		20 69 86	jsr $8669	                jsr w_dup
.96cc		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; status is at nt+1
.96cf		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.96d1		e8		inx		                inx                     ; drop pointer
.96d2		e8		inx		                inx
.96d3		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.96d5		29 0c		and #$0c	                and #AN+NN              ; check if never native (NN)
.96d7		c9 08		cmp #$08	                cmp #NN                 ; NN=1, AN=0?  i.e. not ST=AN+AN
.96d9		f0 61		beq $973c	                beq cmpl_as_call
.96db		20 28 9e	jsr $9e28	                jsr w_wordsize
.96de		a5 29		lda $29		                lda tmp3
.96e0		29 0c		and #$0c	                and #ST                 ; Check the Stack Thrash flag (ST=NN+AN)
.96e2		c9 0c		cmp #$0c	                cmp #ST
.96e4		d0 16		bne $96fc	                bne _check_uf
=10						_strip_sz = 10  ; skip the standard 10 byte header which saves return address + 1 to tmp1
.96e6		18		clc		                clc
.96e7		b5 02		lda $02,x	                lda 2,x
.96e9		69 0a		adc #$0a	                adc #_strip_sz
.96eb		95 02		sta $02,x	                sta 2,x
.96ed		90 02		bcc $96f1	                bcc +
.96ef		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.96f1						+
.96f1		38		sec		                sec
.96f2		b5 00		lda $00,x	                lda 0,x
.96f4		e9 0a		sbc #$0a	                sbc #_strip_sz
.96f6		95 00		sta $00,x	                sta 0,x
.96f8		b0 02		bcs $96fc	                bcs +
.96fa		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.96fc						+
.96fc						_check_uf:
.96fc		a0 02		ldy #$02	                ldy #uf_strip_offset
.96fe		b1 08		lda ($08),y	                lda (up),y
.9700		c8		iny		                iny
.9701		11 08		ora ($08),y	                ora (up),y
.9703		f0 1e		beq $9723	                beq _check_limit
.9705		20 e4 8c	jsr $8ce4	                jsr w_over
.9708		20 6b 97	jsr $976b	                jsr has_uf_check
.970b		90 16		bcc $9723	                bcc _check_limit        ; not an underflow check
.970d		18		clc		                clc
.970e		b5 02		lda $02,x	                lda 2,x
.9710		69 03		adc #$03	                adc #3
.9712		95 02		sta $02,x	                sta 2,x
.9714		90 02		bcc $9718	                bcc +
.9716		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.9718						+
.9718		38		sec		                sec
.9719		b5 00		lda $00,x	                lda 0,x
.971b		e9 03		sbc #$03	                sbc #3
.971d		95 00		sta $00,x	                sta 0,x
.971f		b0 02		bcs $9723	                bcs +
.9721		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.9723						+
.9723						_check_limit:
.9723		a5 29		lda $29		                lda tmp3
.9725		29 0c		and #$0c	                and #AN+NN              ; check Always Native (AN) bit
.9727		c9 04		cmp #$04	                cmp #AN                 ; AN=1, NN=0?  (i.e. not ST=AN+NN)
.9729		f0 2c		beq $9757	                beq cmpl_inline         ; always natively compile
.972b						cmpl_by_limit:
.972b		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.972d		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.972f		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.9731		90 24		bcc $9757	                bcc cmpl_inline         ; borrow (C=0) means size < limit
.9733		d0 07		bne $973c	                bne cmpl_as_call        ; else non-zero means size > limit
.9735		88		dey		                dey
.9736		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.9738		d5 00		cmp $00,x	                cmp 0,x
.973a		b0 1b		bcs $9757	                bcs cmpl_inline         ; not bigger, so good to go
.973c						cmpl_as_call:
.973c		a5 29		lda $29		                lda tmp3
.973e		29 0c		and #$0c	                and #ST
.9740		d0 08		bne $974a	                bne +
.9742		20 63 86	jsr $8663	                jsr w_drop              ; no stack juggling, use middle (xt or xt')
.9745		20 13 8c	jsr $8c13	                jsr w_nip
.9748		80 03		bra $974d	                bra _cmpl
.974a						+
.974a		20 9e 93	jsr $939e	                jsr w_two_drop          ; stack juggling, must use first (xt)
.974d						_cmpl:
.974d		a9 20		lda #$20	                lda #OpJSR
.974f		20 b8 97	jsr $97b8	                jsr cmpl_a
.9752		20 ae 83	jsr $83ae	                jsr w_comma
.9755		38		sec		                sec
.9756		60		rts		                rts
.9757						cmpl_inline:
.9757		20 f4 88	jsr $88f4	                jsr w_here
.975a		20 25 92	jsr $9225	                jsr w_swap
.975d		20 69 86	jsr $8669	                jsr w_dup
.9760		20 2a 82	jsr $822a	                jsr w_allot            ; allocate space for the word
.9763		20 e0 8b	jsr $8be0	                jsr w_move
.9766		20 63 86	jsr $8663	                jsr w_drop             ; drop original xt
.9769		18		clc		                clc
.976a						z_compile_comma:
.976a		60		rts		                rts
.976b						has_uf_check:
.976b		a1 00		lda ($00,x)	                lda (0, x)              ; fetch byte @ addr
.976d		c9 20		cmp #$20	                cmp #OpJSR
.976f		d0 18		bne $9789	                bne _not_uf             ; not a JSR
.9771		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.9774		20 f6 87	jsr $87f6	                jsr w_fetch             ; get JSR address to TOS
.9777		b5 00		lda $00,x	                lda 0, x                ; LSB of jsr address
.9779		38		sec		                sec
.977a		e9 89		sbc #$89	                sbc #<underflow_1
.977c		a8		tay		                tay                     ; stash LSB of result and finish subtraction
.977d		b5 01		lda $01,x	                lda 1, x                ; MSB of jsr address
.977f		e9 d8		sbc #$d8	                sbc #>underflow_1
.9781		d0 06		bne $9789	                bne _not_uf             ; MSB of result must be zero
.9783		c0 10		cpy #$10	                cpy #(underflow_4-underflow_1+1)
.9785		b0 02		bcs $9789	                bcs _not_uf             ; LSB is too big
.9787		38		sec		                sec                     ; C=1 means it is an UF check
>9788		24				                .byte $24               ; bit zp opcode masks the clc, with no effect on carry
.9789		18		clc		_not_uf:        clc                     ; C=0 means it isn't a UF check
.978a		e8		inx		                inx                     ; clean up stack
.978b		e8		inx		                inx
.978c		60		rts		                rts
.978d						cmpl_jump_later:
.978d		ca		dex		                dex
.978e		ca		dex		                dex
.978f		a5 01		lda $01		                lda cp+1
.9791		95 01		sta $01,x	                sta 1,x
.9793		a5 00		lda $00		                lda cp
.9795		1a		inc a		                inc a
.9796		95 00		sta $00,x	                sta 0,x
.9798		d0 0a		bne $97a4	                bne cmpl_jump
.979a		f6 01		inc $01,x	                inc 1,x
.979c		80 06		bra $97a4	                bra cmpl_jump
.979e						cmpl_jump_tos:
.979e		b5 00		lda $00,x	                lda 0,x         ; set up for cmpl_jump Y/A
.97a0		b4 01		ldy $01,x	                ldy 1,x
.97a2		e8		inx		                inx
.97a3		e8		inx		                inx
.97a4						cmpl_jump:
.97a4		48		pha		                pha             ; save LSB of address
.97a5		a9 10		lda #$10	                lda #%00010000  ; unset bit 4 to flag as never-native
.97a7		14 1c		trb $1c		                trb status
.97a9		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP
.97ab		80 03		bra $97b0	                bra +
.97ad						cmpl_subroutine:
.97ad		48		pha		                pha             ; save LSB of address
.97ae		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR and fall through
.97b0						+
.97b0		20 b8 97	jsr $97b8	                jsr cmpl_a      ; compile opcode
.97b3		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.97b4						cmpl_word:
.97b4		20 b8 97	jsr $97b8	                jsr cmpl_a      ; compile LSB of address
.97b7		98		tya		                tya             ; fall thru for MSB
.97b8						cmpl_a:
.97b8		92 00		sta ($00)	                sta (cp)
.97ba		e6 00		inc $00		                inc cp
.97bc		d0 02		bne $97c0	                bne _done
.97be		e6 01		inc $01		                inc cp+1
.97c0						_done:
.97c0		60		rts		                rts
.97c1						check_nc_limit:
.97c1		48		pha		                pha
.97c2		38		sec		                sec
.97c3		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.97c5		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're good, leave with C=0
.97c7		f0 01		beq $97ca	                beq +
.97c9		18		clc		                clc
.97ca						+
.97ca		68		pla		                pla
.97cb		90 05		bcc $97d2	                bcc _done
.97cd		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.97ce		88		dey		                dey
.97cf		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.97d1		1a		inc a		                ina                     ; restore A, preserves carry
.97d2						_done:
.97d2		60		rts		                rts
.97d3						cmpl_0branch_later:
.97d3		20 46 9e	jsr $9e46	                jsr w_zero             ; dummy placeholder, which forces long jmp in native version
.97d6		20 e8 97	jsr $97e8	                jsr cmpl_0branch_tos    ; generate native or subroutine branch code
.97d9		20 f4 88	jsr $88f4	                jsr w_here             ; either way the target address is two bytes before here
.97dc		38		sec		                sec
.97dd		b5 00		lda $00,x	                lda 0,x
.97df		e9 02		sbc #$02	                sbc #2
.97e1		95 00		sta $00,x	                sta 0,x
.97e3		b0 02		bcs $97e7	                bcs +
.97e5		d6 01		dec $01,x	                dec 1,x
.97e7						+
.97e7		60		rts		                rts
.97e8						cmpl_0branch_tos:
.97e8		a9 0b		lda #$0b	                lda #ztest_runtime_size+5       ; typical size of inline form
.97ea		20 c1 97	jsr $97c1	                jsr check_nc_limit              ; returns C=0 if we should native compile
.97ed		90 0a		bcc $97f9	                bcc _inline
.97ef		a0 98		ldy #$98	                ldy #>zero_branch_runtime
.97f1		a9 4a		lda #$4a	                lda #<zero_branch_runtime
.97f3		20 ad 97	jsr $97ad	                jsr cmpl_subroutine             ; call the 0branch runtime
.97f6		4c ae 83	jmp $83ae	                jmp w_comma                    ; add the payload and return
.97f9						_inline:
.97f9		a0 00		ldy #$00	                ldy #0
.97fb						-
.97fb		b9 4a 98	lda $984a,y	                lda ztest_runtime,y
.97fe		20 b8 97	jsr $97b8	                jsr cmpl_a
.9801		c8		iny		                iny
.9802		c0 06		cpy #$06	                cpy #ztest_runtime_size
.9804		d0 f5		bne $97fb	                bne -
.9806		b5 00		lda $00,x	                lda 0,x
.9808		15 01		ora $01,x	                ora 1,x
.980a		f0 31		beq $983d	                beq _long               ; always use the long form if target is 0
.980c		20 69 86	jsr $8669	                jsr w_dup
.980f		20 f4 88	jsr $88f4	                jsr w_here
.9812		18		clc		                clc
.9813		a9 02		lda #$02	                lda #2
.9815		75 00		adc $00,x	                adc 0,x
.9817		95 00		sta $00,x	                sta 0,x
.9819		90 02		bcc $981d	                bcc +
.981b		f6 01		inc $01,x	                inc 1,x
.981d						+
.981d		20 c4 8b	jsr $8bc4	                jsr w_minus
.9820		e8		inx		                inx             ; pre-drop offset and use wraparound indexing to preserve flags
.9821		e8		inx		                inx
.9822		b5 ff		lda $ff,x	                lda $ff,x
.9824		a8		tay		                tay             ; Y=MSB of offset
.9825		b5 fe		lda $fe,x	                lda $fe,x       ; A=LSB, setting N flag to bit 7
.9827		30 04		bmi $982d	                bmi _minus
.9829		c0 00		cpy #$00	                cpy #0          ; if LSB is positive we need MSB = 0
.982b		80 02		bra $982f	                bra +
.982d		c0 ff		cpy #$ff	_minus:         cpy #$ff        ; if LSB is negative we need MSB = ff
.982f		d0 0c		bne $983d	+               bne _long
.9831		a9 f0		lda #$f0	                lda #OpBEQ
.9833		20 b8 97	jsr $97b8	                jsr cmpl_a
.9836		b5 fe		lda $fe,x	                lda $fe,x
.9838		e8		inx		                inx             ; drop the original address we used to calc offset
.9839		e8		inx		                inx
.983a		4c b8 97	jmp $97b8	                jmp cmpl_a
.983d						_long:
.983d		a9 d0		lda #$d0	                lda #OpBNE
.983f		20 b8 97	jsr $97b8	                jsr cmpl_a
.9842		a9 03		lda #$03	                lda #3
.9844		20 b8 97	jsr $97b8	                jsr cmpl_a
.9847		4c 9e 97	jmp $979e	                jmp cmpl_jump_tos
.984a						zero_branch_runtime:
.984a						ztest_runtime:
.984a		e8		inx		                inx
.984b		e8		inx		                inx
.984c		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.984e		15 ff		ora $ff,x	                ora $FF,x
=6						ztest_runtime_size = * - ztest_runtime
.9850						zbranch_runtime:
.9850		7a		ply		                ply
.9851		84 25		sty $25		                sty tmp1
.9853		7a		ply		                ply
.9854		84 26		sty $26		                sty tmp1+1
.9856		a8		tay		                tay             ; test if A = 0 which tells us whether to branch
.9857		f0 0d		beq $9866	                beq _branch
.9859		18		clc		                clc
.985a		a5 25		lda $25		                lda tmp1        ; LSB
.985c		69 03		adc #$03	                adc #3          ; skip two bytes plus the extra for jsr/rts behavior
.985e		85 25		sta $25		                sta tmp1
.9860		90 11		bcc $9873	                bcc _jmp
.9862		e6 26		inc $26		                inc tmp1+1
.9864		80 0d		bra $9873	                bra _jmp
.9866						_branch:
.9866		a0 01		ldy #$01	                ldy #1
.9868		b1 25		lda ($25),y	                lda (tmp1),y
.986a		48		pha		                pha                     ; stash the LSB until we've read the MSB too
.986b		c8		iny		                iny
.986c		b1 25		lda ($25),y	                lda (tmp1),y
.986e		85 26		sta $26		                sta tmp1+1              ; update tmp1 with our branch target
.9870		68		pla		                pla
.9871		85 25		sta $25		                sta tmp1
.9873						_jmp:
.9873		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.9876						xt_bye:
.9876						w_bye:
.9876		4c 26 f0	jmp $f026	                jmp kernel_bye
.9879						z_bye:
.9879						xt_dot_s:
.9879						w_dot_s:
.9879		20 18 85	jsr $8518	                jsr w_depth    ; ( -- u )
.987c		a9 3c		lda #$3c	                lda #'<'
.987e		20 93 86	jsr $8693	                jsr emit_a
.9881		b5 00		lda $00,x	                lda 0,x
.9883		48		pha		                pha
.9884		ca		dex		                dex             ; DUP
.9885		ca		dex		                dex
.9886		95 00		sta $00,x	                sta 0,x
.9888		74 01		stz $01,x	                stz 1,x
.988a		20 f5 d8	jsr $d8f5	                jsr print_u
.988d		a9 3e		lda #$3e	                lda #'>'
.988f		20 93 86	jsr $8693	                jsr emit_a
.9892		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.9894		20 93 86	jsr $8693	                jsr emit_a
.9897		e8		inx		                inx
.9898		e8		inx		                inx
.9899		e0 78		cpx #$78	                cpx #dsp0
.989b		f0 1e		beq $98bb	                beq _done
.989d		7a		ply		                ply
.989e		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.98a0		85 29		sta $29		                sta tmp3
.98a2		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.98a4						_loop:
.98a4		ca		dex		                dex
.98a5		ca		dex		                dex
.98a6		b2 29		lda ($29)	                lda (tmp3)
.98a8		95 01		sta $01,x	                sta 1,x
.98aa		c6 29		dec $29		                dec tmp3
.98ac		b2 29		lda ($29)	                lda (tmp3)
.98ae		95 00		sta $00,x	                sta 0,x
.98b0		c6 29		dec $29		                dec tmp3
.98b2		5a		phy		                phy
.98b3		20 f9 85	jsr $85f9	                jsr w_dot
.98b6		7a		ply		                ply
.98b7		88		dey		                dey
.98b8		d0 ea		bne $98a4	                bne _loop
.98ba		48		pha		                pha             ; dummy to balance stack
.98bb						_done:
.98bb		68		pla		                pla
.98bc		60		rts		z_dot_s:        rts
.98bd						xt_dump:
.98bd		20 8e d8	jsr $d88e	                jsr underflow_2
.98c0						w_dump:
.98c0						_row:
.98c0		a0 10		ldy #$10	                ldy #16
.98c2		64 27		stz $27		                stz tmp2
.98c4		20 05 84	jsr $8405	                jsr w_cr
.98c7		b5 03		lda $03,x	                lda 3,x
.98c9		20 54 d7	jsr $d754	                jsr byte_to_ascii
.98cc		b5 02		lda $02,x	                lda 2,x
.98ce		20 54 d7	jsr $d754	                jsr byte_to_ascii
.98d1		20 bc 91	jsr $91bc	                jsr w_space
.98d4		20 bc 91	jsr $91bc	                jsr w_space
.98d7						_loop:
.98d7		b5 00		lda $00,x	                lda 0,x
.98d9		15 01		ora $01,x	                ora 1,x
.98db		f0 39		beq $9916	                beq _all_printed
.98dd		a1 02		lda ($02,x)	                lda (2,x)
.98df		48		pha		                pha                     ; byte_to_ascii destroys A
.98e0		20 54 d7	jsr $d754	                jsr byte_to_ascii
.98e3		20 bc 91	jsr $91bc	                jsr w_space
.98e6		68		pla		                pla
.98e7		20 6f d8	jsr $d86f	                jsr is_printable
.98ea		b0 02		bcs $98ee	                bcs _printable
.98ec		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.98ee						_printable:
.98ee		5a		phy		                phy                     ; save counter
.98ef		a4 27		ldy $27		                ldy tmp2
.98f1		91 00		sta ($00),y	                sta (cp),y
.98f3		e6 27		inc $27		                inc tmp2
.98f5		7a		ply		                ply
.98f6		c0 09		cpy #$09	                cpy #9
.98f8		d0 03		bne $98fd	                bne _next_char
.98fa		20 bc 91	jsr $91bc	                jsr w_space
.98fd						_next_char:
.98fd		f6 02		inc $02,x	                inc 2,x
.98ff		d0 02		bne $9903	                bne _counter
.9901		f6 03		inc $03,x	                inc 3,x
.9903						_counter:
.9903		b5 00		lda $00,x	                lda 0,x
.9905		d0 02		bne $9909	                bne +
.9907		d6 01		dec $01,x	                dec 1,x
.9909						+
.9909		d6 00		dec $00,x	                dec 0,x
.990b		88		dey		                dey
.990c		d0 c9		bne $98d7	                bne _loop               ; next byte
.990e		20 bc 91	jsr $91bc	                jsr w_space
.9911		20 24 99	jsr $9924	                jsr dump_print_ascii
.9914		80 aa		bra $98c0	                bra _row                ; new row
.9916						_all_printed:
.9916		a5 27		lda $27		                lda tmp2
.9918		f0 06		beq $9920	                beq _done
.991a		20 bc 91	jsr $91bc	                jsr w_space
.991d		20 24 99	jsr $9924	                jsr dump_print_ascii
.9920						_done:
.9920		20 9e 93	jsr $939e	                jsr w_two_drop         ; one byte less than 4x INX
.9923		60		rts		z_dump:         rts
.9924						dump_print_ascii:
.9924		a0 00		ldy #$00	                ldy #0
.9926						_ascii_loop:
.9926		b1 00		lda ($00),y	                lda (cp),y
.9928		20 93 86	jsr $8693	                jsr emit_a
.992b		c8		iny		                iny
.992c		c0 08		cpy #$08	                cpy #8
.992e		d0 03		bne $9933	                bne +
.9930		20 bc 91	jsr $91bc	                jsr w_space
.9933						+
.9933		c6 27		dec $27		                dec tmp2
.9935		d0 ef		bne $9926	                bne _ascii_loop
.9937		60		rts		                rts
.9938						xt_question:
.9938						w_question:
.9938		20 f6 87	jsr $87f6	                jsr w_fetch
.993b		20 f9 85	jsr $85f9	                jsr w_dot
.993e		60		rts		z_question:     rts
.993f						xt_see:
.993f						w_see:
.993f		20 2d 8d	jsr $8d2d	                jsr w_parse_name       ; ( addr u )
.9942		20 3d 9b	jsr $9b3d	                jsr w_find_name        ; ( nt | 0 )
.9945		b5 00		lda $00,x	                lda 0,x
.9947		15 01		ora $01,x	                ora 1,x
.9949		d0 05		bne $9950	                bne +
.994b		a9 05		lda #$05	                lda #err_noname
.994d		4c 9f d8	jmp $d89f	                jmp error
.9950						+
.9950		20 05 84	jsr $8405	                jsr w_cr
.9953		a5 18		lda $18		                lda base
.9955		48		pha		                pha
.9956		20 ff 88	jsr $88ff	                jsr w_hex
.9959		a9 08		lda #$08	                lda #str_see_nt
.995b		20 c5 d8	jsr $d8c5	                jsr print_string_no_lf
.995e		20 69 86	jsr $8669	                jsr w_dup              ; ( nt nt )
.9961		20 e6 94	jsr $94e6	                jsr w_u_dot
.9964		20 bc 91	jsr $91bc	                jsr w_space            ; ( nt )
.9967		20 69 86	jsr $8669	                jsr w_dup              ; ( nt nt )
.996a		20 86 9c	jsr $9c86	                jsr w_name_to_int      ; ( nt xt )
.996d		a9 09		lda #$09	                lda #str_see_xt
.996f		20 c5 d8	jsr $d8c5	                jsr print_string_no_lf
.9972		20 69 86	jsr $8669	                jsr w_dup              ; ( nt xt xt )
.9975		20 e6 94	jsr $94e6	                jsr w_u_dot
.9978		20 05 84	jsr $8405	                jsr w_cr               ; ( nt xt )
.997b		20 e4 8c	jsr $8ce4	                jsr w_over              ; ( nt xt nt )
.997e		20 c8 8c	jsr $8cc8	                jsr w_one_plus          ; ( nt xt nt+1 )
.9981		a1 00		lda ($00,x)	                lda (0, x)
.9983		95 00		sta $00,x	                sta 0,x                 ; stash status flag byte
.9985		74 01		stz $01,x	                stz 1,x                 ; placeholder for synthetic flags
.9987		29 0c		and #$0c	                and #ST                 ; calculate ST flag
.9989		c9 0c		cmp #$0c	                cmp #ST
.998b		f0 01		beq $998e	                beq +                   ; C=1 when ST set
.998d		18		clc		                clc
.998e						+
.998e		36 01		rol $01,x	                rol 1,x                 ; add to flag byte
.9990		20 e4 8c	jsr $8ce4	                jsr w_over
.9993		20 6b 97	jsr $976b	                jsr has_uf_check        ; C=1 when UF set
.9996		36 01		rol $01,x	                rol 1,x                 ; add to flag byte
.9998		a9 05		lda #$05	                lda #N_FLAGS            ; count off status byte flags
.999a		85 23		sta $23		                sta tmptos
.999c		a9 6c		lda #$6c	                lda #<see_flags_template
.999e		85 29		sta $29		                sta tmp3                ; LSB
.99a0		a9 d4		lda #$d4	                lda #>see_flags_template
.99a2		85 2a		sta $2a		                sta tmp3+1              ; MSB
.99a4		a0 00		ldy #$00	                ldy #0                  ; index the string
.99a6						_loop:
.99a6		b1 29		lda ($29),y	                lda (tmp3),y            ; next char in template
.99a8		10 04		bpl $99ae	                bpl +                   ; end of string?
.99aa		a0 ff		ldy #$ff	                ldy #$ff                ; flag end of loop
.99ac		29 7f		and #$7f	                and #$7f                ; clear high bit of A to get last character
.99ae						+
.99ae		d0 16		bne $99c6	                bne _emit               ; flag placeholder?
.99b0		20 bc 91	jsr $91bc	                jsr w_space             ; print <space>, <flag>, <space>
.99b3		c6 23		dec $23		                dec tmptos
.99b5		30 04		bmi $99bb	                bmi _synthetic          ; more core status flags?
.99b7		56 00		lsr $00,x	                lsr 0,x                 ; shift next flag bit into carry
.99b9		80 02		bra $99bd	                bra +
.99bb						_synthetic:
.99bb		56 01		lsr $01,x	                lsr 1,x                 ; show synthetic flags after core ones
.99bd						+
.99bd		a9 30		lda #$30	                lda #'0'                ; convert C=0/1 into '0' or '1'
.99bf		69 00		adc #$00	                adc #0
.99c1		20 93 86	jsr $8693	                jsr emit_a              ; write the flag digit
.99c4		a9 20		lda #$20	                lda #' '                ; fall through and add trailing space
.99c6						_emit:
.99c6		20 93 86	jsr $8693	                jsr emit_a
.99c9		c8		iny		                iny
.99ca		d0 da		bne $99a6	                bne _loop
.99cc		20 05 84	jsr $8405	                jsr w_cr
.99cf		e8		inx		                inx
.99d0		e8		inx		                inx                     ; ( nt xt )
.99d1		a9 0a		lda #$0a	                lda #str_see_size
.99d3		20 c5 d8	jsr $d8c5	                jsr print_string_no_lf
.99d6		20 25 92	jsr $9225	                jsr w_swap             ; ( xt nt )
.99d9		20 28 9e	jsr $9e28	                jsr w_wordsize         ; ( xt u )
.99dc		20 69 86	jsr $8669	                jsr w_dup              ; ( xt u u ) for DUMP and DISASM
.99df		20 eb 84	jsr $84eb	                jsr w_decimal
.99e2		20 e6 94	jsr $94e6	                jsr w_u_dot            ; ( xt u )
.99e5		20 ff 88	jsr $88ff	                jsr w_hex
.99e8		20 05 84	jsr $8405	                jsr w_cr
.99eb		20 a6 93	jsr $93a6	                jsr w_two_dup          ; ( xt u xt u )
.99ee		20 c0 98	jsr $98c0	                jsr w_dump
.99f1		20 05 84	jsr $8405	                jsr w_cr
.99f4		20 5d a2	jsr $a25d	                jsr w_disasm
.99f7		68		pla		                pla
.99f8		85 18		sta $18		                sta base
.99fa		60		rts		z_see:          rts
.99fb						xt_words:
.99fb						w_words:
.99fb		20 05 84	jsr $8405	                jsr w_cr
.99fe		a9 00		lda #$00	                lda #0
.9a00		48		pha		                pha
.9a01		ca		dex		                dex                     ; Make room on the stack for
.9a02		ca		dex		                dex                     ; a dictionary pointer.
.9a03		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.9a05						_wordlist_loop:
.9a05		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.9a07		a5 29		lda $29		                lda tmp3
.9a09		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.9a0b		d0 02		bne $9a0f	                bne _have_wordlist
.9a0d		80 45		bra $9a54	                bra _words_done
.9a0f						_have_wordlist:
.9a0f		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.9a10		69 23		adc #$23	                adc #search_order_offset
.9a12		a8		tay		                tay
.9a13		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.9a15		0a		asl a		                asl                     ; Turn offset into cells offset.
.9a16		18		clc		                clc
.9a17		69 0a		adc #$0a	                adc #wordlists_offset
.9a19		a8		tay		                tay
.9a1a		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9a1c		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.9a1e		c8		iny		                iny
.9a1f		b1 08		lda ($08),y	                lda (up),y
.9a21		95 01		sta $01,x	                sta 1,x
.9a23						_loop:
.9a23		20 69 86	jsr $8669	                jsr w_dup              ; ( nt nt )
.9a26		20 a3 9c	jsr $9ca3	                jsr w_name_to_string   ; ( nt addr u )
.9a29		68		pla		                pla
.9a2a		18		clc		                clc
.9a2b		75 00		adc $00,x	                adc 0,x
.9a2d		1a		inc a		                ina                     ; don't forget the space between words
.9a2e		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.9a30		90 06		bcc $9a38	                bcc +
.9a32		20 05 84	jsr $8405	                jsr w_cr
.9a35		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.9a37		1a		inc a		                ina                     ; with length of this word.
.9a38						+
.9a38		48		pha		                pha
.9a39		20 bb 94	jsr $94bb	                jsr w_type             ; ( nt )
.9a3c		a9 20		lda #$20	                lda #AscSP
.9a3e		20 93 86	jsr $8693	                jsr emit_a
.9a41		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+
.9a44		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+
.9a47		20 f6 87	jsr $87f6	                jsr w_fetch            ; @ ( nt+1 )
.9a4a		b5 00		lda $00,x	                lda 0,x
.9a4c		15 01		ora $01,x	                ora 1,x
.9a4e		d0 d3		bne $9a23	                bne _loop
.9a50		e6 29		inc $29		                inc tmp3
.9a52		80 b1		bra $9a05	                bra _wordlist_loop
.9a54						_words_done:
.9a54		68		pla		                pla                     ; dump counter
.9a55		e8		inx		                inx
.9a56		e8		inx		                inx
.9a57		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.9a58						xt_allow_native:
.9a58						w_allow_native:
.9a58		20 e0 d7	jsr $d7e0	                jsr current_to_dp
.9a5b		a0 01		ldy #$01	                ldy #1          ; offset for header flag byte
.9a5d		b1 02		lda ($02),y	                lda (dp),y
.9a5f		29 f3		and #$f3	                and #$FF-NN-AN  ; AN and NN flag is clear.
.9a61		91 02		sta ($02),y	                sta (dp),y
.9a63						z_allow_native:
.9a63		60		rts		                rts
.9a64						xt_always_native:
.9a64						w_always_native:
.9a64		20 e0 d7	jsr $d7e0	                jsr current_to_dp
.9a67		a0 01		ldy #$01	                ldy #1          ; offset for header flag byte
.9a69		b1 02		lda ($02),y	                lda (dp),y
.9a6b		09 04		ora #$04	                ora #AN         ; Make sure AN flag is set
.9a6d		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9a6f		91 02		sta ($02),y	                sta (dp),y
.9a71						z_always_native:
.9a71		60		rts		                rts
.9a72						xt_bell:
.9a72						w_bell:
.9a72		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.9a74		20 93 86	jsr $8693	                jsr emit_a
.9a77		60		rts		z_bell:         rts
.9a78						xt_bounds:
.9a78		20 8e d8	jsr $d88e	                jsr underflow_2
.9a7b						w_bounds:
.9a7b		18		clc		                clc
.9a7c		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9a7e		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9a80		75 02		adc $02,x	                adc 2,x
.9a82		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9a84		94 00		sty $00,x	                sty 0,x
.9a86		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9a88		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9a8a		75 03		adc $03,x	                adc 3,x
.9a8c		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9a8e		94 01		sty $01,x	                sty 1,x
.9a90		60		rts		z_bounds:       rts
.9a91						xt_cleave:
.9a91		20 8e d8	jsr $d88e	                jsr underflow_2
.9a94						w_cleave:
.9a94		20 dc a0	jsr $a0dc	                jsr w_minus_leading    ; -LEADING ( addr u )
.9a97		20 e7 9b	jsr $9be7	                jsr w_input_to_r       ; save old imput state
.9a9a		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9a9c		85 0e		sta $0e		                sta ciblen
.9a9e		b5 01		lda $01,x	                lda 1,x
.9aa0		85 0f		sta $0f		                sta ciblen+1
.9aa2		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9aa4		85 0c		sta $0c		                sta cib
.9aa6		b5 03		lda $03,x	                lda 3,x
.9aa8		85 0d		sta $0d		                sta cib+1
.9aaa		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9aac		64 11		stz $11		                stz toin+1
.9aae		20 2d 8d	jsr $8d2d	                jsr w_parse_name       ; ( addr u addr-s u-s )
.9ab1		b5 00		lda $00,x	                lda 0,x
.9ab3		15 01		ora $01,x	                ora 1,x
.9ab5		f0 23		beq $9ada	                beq _done
.9ab7		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9ab9		38		sec		                sec
.9aba		f5 00		sbc $00,x	                sbc 0,x
.9abc		95 04		sta $04,x	                sta 4,x
.9abe		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9ac0		f5 01		sbc $01,x	                sbc 1,x
.9ac2		95 05		sta $05,x	                sta 5,x
.9ac4		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9ac6		18		clc		                clc
.9ac7		75 00		adc $00,x	                adc 0,x
.9ac9		95 06		sta $06,x	                sta 6,x
.9acb		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9acd		75 01		adc $01,x	                adc 1,x
.9acf		95 07		sta $07,x	                sta 7,x
.9ad1		20 77 94	jsr $9477	                jsr w_two_swap         ; ( addr-s u-s addr u )
.9ad4		20 dc a0	jsr $a0dc	                jsr w_minus_leading
.9ad7		20 77 94	jsr $9477	                jsr w_two_swap         ; ( addr u addr-s u-s )
.9ada						_done:
.9ada		20 f4 9d	jsr $9df4	                jsr w_r_to_input
.9add		60		rts		z_cleave:       rts
.9ade						xt_digit_question:
.9ade		20 89 d8	jsr $d889	                jsr underflow_1
.9ae1						w_digit_question:
.9ae1		ca		dex		                dex
.9ae2		ca		dex		                dex
.9ae3		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9ae5		74 01		stz $01,x	                stz 1,x
.9ae7		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9ae9		b5 02		lda $02,x	                lda 2,x
.9aeb		c9 30		cmp #$30	                cmp #'0'
.9aed		90 23		bcc $9b12	                bcc _done               ; failure flag already set
.9aef		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9af1		90 12		bcc $9b05	                bcc _checkbase
.9af3		c9 41		cmp #$41	                cmp #'A'
.9af5		90 1b		bcc $9b12	                bcc _done               ; failure flag is already set
.9af7		c9 61		cmp #$61	                cmp #'a'
.9af9		90 07		bcc $9b02	                bcc _case_done          ; not lower case, too low
.9afb		c9 7b		cmp #$7b	                cmp #'z'+1
.9afd		b0 03		bcs $9b02	                bcs _case_done          ; not lower case, too high
.9aff		18		clc		                clc                     ; just right
.9b00		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9b02						_case_done:
.9b02		38		sec		                sec
.9b03		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9b05						_checkbase:
.9b05		38		sec		                sec
.9b06		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9b08		c5 18		cmp $18		                cmp base
.9b0a		b0 06		bcs $9b12	                bcs _done               ; already have false flag
.9b0c		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9b0e		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9b10		d6 01		dec $01,x	                dec 1,x
.9b12						_done:
.9b12						z_digit_question:
.9b12		60		rts		                rts
.9b13						xt_execute_parsing:
.9b13		20 93 d8	jsr $d893	                jsr underflow_3
.9b16						w_execute_parsing:
.9b16		20 e7 9b	jsr $9be7	                jsr w_input_to_r       ; save normal input for later
.9b19		20 cd 9c	jsr $9ccd	                jsr w_not_rot          ; -ROT ( xt addr u )
.9b1c		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9b1e		85 0e		sta $0e		                sta ciblen
.9b20		b5 01		lda $01,x	                lda 1,x
.9b22		85 0f		sta $0f		                sta ciblen+1
.9b24		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9b26		85 0c		sta $0c		                sta cib
.9b28		b5 03		lda $03,x	                lda 3,x
.9b2a		85 0d		sta $0d		                sta cib+1
.9b2c		64 10		stz $10		                stz toin                ; Set >IN to zero
.9b2e		64 11		stz $11		                stz toin+1
.9b30		20 9e 93	jsr $939e	                jsr w_two_drop         ; 2DROP ( xt )
.9b33		20 e1 87	jsr $87e1	                jsr w_execute
.9b36		20 f4 9d	jsr $9df4	                jsr w_r_to_input
.9b39						z_execute_parsing:
.9b39		60		rts		                rts
.9b3a						xt_find_name:
.9b3a		20 8e d8	jsr $d88e	                jsr underflow_2
.9b3d						w_find_name:
.9b3d		b5 00		lda $00,x	                lda 0,x
.9b3f		15 01		ora $01,x	                ora 1,x
.9b41		d0 03		bne $9b46	                bne _nonempty
.9b43		4c 77 9b	jmp $9b77	                jmp _fail_done
.9b46						_nonempty:
.9b46		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9b48						_wordlist_loop:
.9b48		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9b4a		a5 29		lda $29		                lda tmp3
.9b4c		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9b4e		f0 27		beq $9b77	                beq _fail_done
.9b50		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9b51		69 23		adc #$23	                adc #search_order_offset
.9b53		a8		tay		                tay
.9b54		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9b56		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b57		18		clc		                clc
.9b58		69 0a		adc #$0a	                adc #wordlists_offset
.9b5a		a8		tay		                tay
.9b5b		b1 08		lda ($08),y	                lda (up),y
.9b5d		85 25		sta $25		                sta tmp1
.9b5f		c8		iny		                iny
.9b60		b1 08		lda ($08),y	                lda (up),y
.9b62		85 26		sta $26		                sta tmp1+1
.9b64		20 6b d7	jsr $d76b	                jsr find_header_name
.9b67		d0 04		bne $9b6d	                bne _success
.9b69		e6 29		inc $29		                inc tmp3
.9b6b		80 db		bra $9b48	                bra _wordlist_loop
.9b6d						_success:
.9b6d		a5 25		lda $25		                lda tmp1
.9b6f		95 02		sta $02,x	                sta 2,x
.9b71		a5 26		lda $26		                lda tmp1+1
.9b73		95 03		sta $03,x	                sta 3,x
.9b75		80 04		bra $9b7b	                bra _done
.9b77						_fail_done:
.9b77		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b79		74 03		stz $03,x	                stz 3,x
.9b7b						_done:
.9b7b		e8		inx		                inx
.9b7c		e8		inx		                inx
.9b7d		60		rts		z_find_name:    rts
.9b7e						xt_havekey:
.9b7e						w_havekey:
.9b7e		ca		dex		                dex
.9b7f		ca		dex		                dex
.9b80		a9 16		lda #$16	                lda #<havekey
.9b82		95 00		sta $00,x	                sta 0,x
.9b84		a9 00		lda #$00	                lda #>havekey
.9b86		95 01		sta $01,x	                sta 1,x
.9b88		60		rts		z_havekey:      rts
.9b89						xt_hexstore:
.9b89		20 93 d8	jsr $d893	                jsr underflow_3
.9b8c						w_hexstore:
.9b8c		20 69 86	jsr $8669	                jsr w_dup              ; Save copy of original address
.9b8f		20 98 94	jsr $9498	                jsr w_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b92						_loop:
.9b92		b5 00		lda $00,x	                lda 0,x
.9b94		15 01		ora $01,x	                ora 1,x
.9b96		f0 36		beq $9bce	                beq _done
.9b98		20 94 9a	jsr $9a94	                jsr w_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9b9b		20 98 94	jsr $9498	                jsr w_two_to_r
.9b9e		20 46 9e	jsr $9e46	                jsr w_zero
.9ba1		20 46 9e	jsr $9e46	                jsr w_zero
.9ba4		20 1e 94	jsr $941e	                jsr w_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9ba7		20 c3 92	jsr $92c3	                jsr w_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9baa		b5 00		lda $00,x	                lda 0,x
.9bac		15 01		ora $01,x	                ora 1,x
.9bae		d0 17		bne $9bc7	                bne _have_chars_left
.9bb0		20 9e 93	jsr $939e	                jsr w_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9bb3		20 92 9e	jsr $9e92	                jsr w_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9bb6		20 b5 8e	jsr $8eb5	                jsr w_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9bb9		20 3a 83	jsr $833a	                jsr w_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9bbc		20 cc 8e	jsr $8ecc	                jsr w_r_from           ; R>
.9bbf		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+
.9bc2		20 60 93	jsr $9360	                jsr w_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9bc5		80 cb		bra $9b92	                bra _loop
.9bc7						_have_chars_left:
.9bc7		8a		txa		                txa
.9bc8		18		clc		                clc
.9bc9		69 08		adc #$08	                adc #8
.9bcb		aa		tax		                tax
.9bcc		80 c4		bra $9b92	                bra _loop
.9bce						_done:
.9bce		e8		inx		                inx
.9bcf		e8		inx		                inx
.9bd0		e8		inx		                inx
.9bd1		e8		inx		                inx                     ; 2DROP
.9bd2		20 1e 94	jsr $941e	                jsr w_two_r_from       ; ( addr2+n addr2 )
.9bd5		20 25 92	jsr $9225	                jsr w_swap
.9bd8		20 c4 8b	jsr $8bc4	                jsr w_minus            ; ( n )
.9bdb		60		rts		z_hexstore:     rts
.9bdc						xt_input:
.9bdc						w_input:
.9bdc		ca		dex		                dex
.9bdd		ca		dex		                dex
.9bde		a9 14		lda #$14	                lda #<input
.9be0		95 00		sta $00,x	                sta 0,x
.9be2		a9 00		lda #$00	                lda #>input
.9be4		95 01		sta $01,x	                sta 1,x
.9be6		60		rts		z_input:        rts
.9be7						xt_input_to_r:
.9be7						w_input_to_r:
.9be7		68		pla		                pla
.9be8		85 25		sta $25		                sta tmp1
.9bea		68		pla		                pla
.9beb		85 26		sta $26		                sta tmp1+1
.9bed		a0 07		ldy #$07	                ldy #7
.9bef						_loop:
.9bef		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9bf2		48		pha		                pha
.9bf3		88		dey		                dey
.9bf4		10 f9		bpl $9bef	                bpl _loop
.9bf6		a5 26		lda $26		                lda tmp1+1
.9bf8		48		pha		                pha
.9bf9		a5 25		lda $25		                lda tmp1
.9bfb		48		pha		                pha
.9bfc		60		rts		z_input_to_r: 	rts
.9bfd						xt_int_to_name:
.9bfd		20 89 d8	jsr $d889	                jsr underflow_1
.9c00						w_int_to_name:
.9c00		ca		dex		                dex
.9c01		ca		dex		                dex
.9c02		74 00		stz $00,x	                stz 0,x
.9c04		74 01		stz $01,x	                stz 1,x
.9c06						_wordlist_loop:
.9c06		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9c08		0a		asl a		                asl                     ; Turn offset into cells offset.
.9c09		18		clc		                clc
.9c0a		69 0a		adc #$0a	                adc #wordlists_offset
.9c0c		a8		tay		                tay
.9c0d		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9c0f		85 27		sta $27		                sta tmp2                ; into tmp2
.9c11		c8		iny		                iny
.9c12		b1 08		lda ($08),y	                lda (up),y
.9c14		85 28		sta $28		                sta tmp2+1
.9c16		a5 27		lda $27		                lda tmp2
.9c18		05 28		ora $28		                ora tmp2+1
.9c1a		f0 36		beq $9c52	                beq _next_wordlist
.9c1c		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9c1e		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9c20		b5 03		lda $03,x	                lda 3,x
.9c22		85 2a		sta $2a		                sta tmp3+1
.9c24						_loop:
.9c24		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9c26		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9c28		c5 29		cmp $29		                cmp tmp3
.9c2a		d0 07		bne $9c33	                bne _no_match
.9c2c		c8		iny		                iny
.9c2d		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9c2f		c5 2a		cmp $2a		                cmp tmp3+1
.9c31		f0 30		beq $9c63	                beq _match
.9c33						_no_match:
.9c33		18		clc		                clc
.9c34		a5 27		lda $27		                lda tmp2
.9c36		69 02		adc #$02	                adc #2
.9c38		85 27		sta $27		                sta tmp2
.9c3a		90 02		bcc $9c3e	                bcc +
.9c3c		e6 28		inc $28		                inc tmp2+1
.9c3e						+
.9c3e		a0 00		ldy #$00	                ldy #0
.9c40		b1 27		lda ($27),y	                lda (tmp2),y
.9c42		48		pha		                pha
.9c43		c8		iny		                iny
.9c44		11 27		ora ($27),y	                ora (tmp2),y
.9c46		f0 09		beq $9c51	                beq _zero
.9c48		b1 27		lda ($27),y	                lda (tmp2),y
.9c4a		85 28		sta $28		                sta tmp2+1
.9c4c		68		pla		                pla
.9c4d		85 27		sta $27		                sta tmp2
.9c4f		80 d3		bra $9c24	                bra _loop
.9c51						_zero:
.9c51		68		pla		                pla             ; Leftover from above loop
.9c52						_next_wordlist:
.9c52		b5 00		lda $00,x	                lda 0,x
.9c54		1a		inc a		                ina
.9c55		95 00		sta $00,x	                sta 0,x
.9c57		c9 0c		cmp #$0c	                cmp #max_wordlists
.9c59		d0 ab		bne $9c06	                bne _wordlist_loop
.9c5b		e8		inx		                inx
.9c5c		e8		inx		                inx
.9c5d		74 00		stz $00,x	                stz 0,x
.9c5f		74 01		stz $01,x	                stz 1,x
.9c61		80 0a		bra $9c6d	                bra z_int_to_name
.9c63						_match:
.9c63		e8		inx		                inx
.9c64		e8		inx		                inx
.9c65		a5 27		lda $27		                lda tmp2
.9c67		95 00		sta $00,x	                sta 0,x
.9c69		a5 28		lda $28		                lda tmp2+1
.9c6b		95 01		sta $01,x	                sta 1,x
.9c6d		60		rts		z_int_to_name:  rts
.9c6e						xt_latestnt:
.9c6e						w_latestnt:
.9c6e		ca		dex		                dex
.9c6f		ca		dex		                dex
.9c70		20 e0 d7	jsr $d7e0	                jsr current_to_dp
.9c73		a5 02		lda $02		                lda dp
.9c75		95 00		sta $00,x	                sta 0,x
.9c77		a5 03		lda $03		                lda dp+1
.9c79		95 01		sta $01,x	                sta 1,x
.9c7b		60		rts		z_latestnt:     rts
.9c7c						xt_latestxt:
.9c7c						w_latestxt:
.9c7c		20 6e 9c	jsr $9c6e	                jsr w_latestnt         ; ( nt )
.9c7f		20 86 9c	jsr $9c86	                jsr w_name_to_int      ; ( xt )
.9c82		60		rts		z_latestxt:     rts
.9c83						xt_name_to_int:
.9c83		20 89 d8	jsr $d889	                jsr underflow_1
.9c86						w_name_to_int:
.9c86		b5 00		lda $00,x	                lda 0,x
.9c88		18		clc		                clc
.9c89		69 04		adc #$04	                adc #4
.9c8b		85 29		sta $29		                sta tmp3
.9c8d		b5 01		lda $01,x	                lda 1,x
.9c8f		90 01		bcc $9c92	                bcc _done
.9c91		1a		inc a		                ina
.9c92						_done:
.9c92		85 2a		sta $2a		                sta tmp3+1
.9c94		a0 00		ldy #$00	                ldy #0
.9c96		b1 29		lda ($29),y	                lda (tmp3),y
.9c98		95 00		sta $00,x	                sta 0,x
.9c9a		c8		iny		                iny
.9c9b		b1 29		lda ($29),y	                lda (tmp3),y
.9c9d		95 01		sta $01,x	                sta 1,x
.9c9f		60		rts		z_name_to_int:  rts
.9ca0						xt_name_to_string:
.9ca0		20 89 d8	jsr $d889	                jsr underflow_1
.9ca3						w_name_to_string:
.9ca3		ca		dex		                dex
.9ca4		ca		dex		                dex
.9ca5		a1 02		lda ($02,x)	                lda (2,x)
.9ca7		95 00		sta $00,x	                sta 0,x
.9ca9		74 01		stz $01,x	                stz 1,x
.9cab		b5 02		lda $02,x	                lda 2,x         ; LSB
.9cad		18		clc		                clc
.9cae		69 08		adc #$08	                adc #8
.9cb0		95 02		sta $02,x	                sta 2,x
.9cb2		90 02		bcc $9cb6	                bcc z_name_to_string
.9cb4		f6 03		inc $03,x	                inc 3,x         ; MSB
.9cb6						z_name_to_string:
.9cb6		60		rts		                rts
.9cb7						xt_nc_limit:
.9cb7						w_nc_limit:
.9cb7		a9 00		lda #$00	                lda #nc_limit_offset
.9cb9		4c 45 d7	jmp $d745	                jmp push_upvar_tos
.9cbc						z_nc_limit:
.9cbc						xt_never_native:
.9cbc						w_never_native:
.9cbc		20 e0 d7	jsr $d7e0	                jsr current_to_dp
.9cbf		a0 01		ldy #$01	                ldy #1          ; offset for header flag byte
.9cc1		b1 02		lda ($02),y	                lda (dp),y
.9cc3		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9cc5		29 fb		and #$fb	                and #$FF-AN     ; and AN flag is clear.
.9cc7		91 02		sta ($02),y	                sta (dp),y
.9cc9						z_never_native:
.9cc9		60		rts		                rts
.9cca						xt_not_rot:
.9cca		20 93 d8	jsr $d893	                jsr underflow_3
.9ccd						w_not_rot:
.9ccd		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9ccf		b5 03		lda $03,x	                lda 3,x
.9cd1		95 01		sta $01,x	                sta 1,x
.9cd3		b5 05		lda $05,x	                lda 5,x
.9cd5		95 03		sta $03,x	                sta 3,x
.9cd7		94 05		sty $05,x	                sty 5,x
.9cd9		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9cdb		b5 02		lda $02,x	                lda 2,x
.9cdd		95 00		sta $00,x	                sta 0,x
.9cdf		b5 04		lda $04,x	                lda 4,x
.9ce1		95 02		sta $02,x	                sta 2,x
.9ce3		94 04		sty $04,x	                sty 4,x
.9ce5		60		rts		z_not_rot:      rts
.9ce6						xt_number:
.9ce6		20 8e d8	jsr $d88e	                jsr underflow_2
.9ce9						w_number:
.9ce9		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9ceb		a5 18		lda $18		                lda base
.9ced		48		pha		                pha
.9cee		20 a6 93	jsr $93a6	                jsr w_two_dup
.9cf1		a1 02		lda ($02,x)	                lda (2,x)
.9cf3		c9 23		cmp #$23	                cmp #'#'                ; decimal?
.9cf5		d0 04		bne $9cfb	                bne _check_hex
.9cf7		a9 0a		lda #$0a	                lda #10
.9cf9		80 42		bra $9d3d	                bra _base_changed
.9cfb						_check_hex:
.9cfb		c9 24		cmp #$24	                cmp #'$'
.9cfd		d0 04		bne $9d03	                bne _check_binary
.9cff		a9 10		lda #$10	                lda #16
.9d01		80 3a		bra $9d3d	                bra _base_changed
.9d03						_check_binary:
.9d03		c9 25		cmp #$25	                cmp #'%'
.9d05		d0 04		bne $9d0b	                bne _check_char
.9d07		a9 02		lda #$02	                lda #2
.9d09		80 32		bra $9d3d	                bra _base_changed
.9d0b						_check_char:
.9d0b		c9 27		cmp #$27	                cmp #"'"
.9d0d		d0 3a		bne $9d49	                bne _check_minus
.9d0f		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9d11		c9 03		cmp #$03	                cmp #3
.9d13		d0 26		bne $9d3b	                bne _not_a_char
.9d15		b5 01		lda $01,x	                lda 1,x
.9d17		d0 22		bne $9d3b	                bne _not_a_char ; No compare needed to check for non-zero.
.9d19		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d1b		18		clc		                clc
.9d1c		69 02		adc #$02	                adc #2          ; length of string
.9d1e		85 23		sta $23		                sta tmptos
.9d20		b5 03		lda $03,x	                lda 3,x
.9d22		69 00		adc #$00	                adc #0          ; only need carry
.9d24		85 24		sta $24		                sta tmptos+1
.9d26		b2 23		lda ($23)	                lda (tmptos)
.9d28		c9 27		cmp #$27	                cmp #"'"
.9d2a		d0 0f		bne $9d3b	                bne _not_a_char
.9d2c		f6 02		inc $02,x	                inc 2,x
.9d2e		d0 02		bne $9d32	                bne +
.9d30		f6 03		inc $03,x	                inc 3,x
.9d32						+
.9d32		a1 02		lda ($02,x)	                lda (2,x)
.9d34		95 02		sta $02,x	                sta 2,x
.9d36		74 03		stz $03,x	                stz 3,x
.9d38		4c bb 9d	jmp $9dbb	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9d3b						_not_a_char:
.9d3b		80 5c		bra $9d99	                bra _number_error
.9d3d						_base_changed:
.9d3d		85 18		sta $18		                sta base        ; Switch to the new base
.9d3f		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d41		d0 02		bne $9d45	                bne +
.9d43		f6 03		inc $03,x	                inc 3,x
.9d45						+
.9d45		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d47		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9d49						_check_minus:
.9d49		c9 2d		cmp #$2d	                cmp #'-'
.9d4b		d0 0c		bne $9d59	                bne _check_dot
.9d4d		a9 80		lda #$80	                lda #$80
.9d4f		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9d51		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d53		d0 02		bne $9d57	                bne +
.9d55		f6 03		inc $03,x	                inc 3,x
.9d57						+
.9d57		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d59						_check_dot:
.9d59		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d5b		18		clc		                clc
.9d5c		75 00		adc $00,x	                adc 0,x         ; length of string
.9d5e		85 23		sta $23		                sta tmptos
.9d60		b5 03		lda $03,x	                lda 3,x
.9d62		69 00		adc #$00	                adc #0          ; only need carry
.9d64		85 24		sta $24		                sta tmptos+1
.9d66		a5 23		lda $23		                lda tmptos
.9d68		d0 02		bne $9d6c	                bne +
.9d6a		c6 24		dec $24		                dec tmptos+1
.9d6c						+
.9d6c		c6 23		dec $23		                dec tmptos
.9d6e		b2 23		lda ($23)	                lda (tmptos)
.9d70		c9 2e		cmp #$2e	                cmp #'.'
.9d72		d0 04		bne $9d78	                bne _main
.9d74		e6 1e		inc $1e		                inc tmpdsp
.9d76		d6 00		dec $00,x	                dec 0,x
.9d78						_main:
.9d78		ca		dex		                dex
.9d79		ca		dex		                dex
.9d7a		ca		dex		                dex
.9d7b		ca		dex		                dex
.9d7c		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9d7e		95 00		sta $00,x	                sta 0,x
.9d80		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9d82		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9d84		95 02		sta $02,x	                sta 2,x
.9d86		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9d88		95 03		sta $03,x	                sta 3,x
.9d8a		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9d8c		74 05		stz $05,x	                stz 5,x
.9d8e		74 06		stz $06,x	                stz 6,x
.9d90		74 07		stz $07,x	                stz 7,x
.9d92		20 c3 92	jsr $92c3	                jsr w_to_number        ; (ud addr u -- ud addr u )
.9d95		b5 00		lda $00,x	                lda 0,x
.9d97		f0 1e		beq $9db7	                beq _all_converted
.9d99						_number_error:
.9d99		20 9e 93	jsr $939e	                jsr w_two_drop ; >NUMBER modified addr u
.9d9c		20 9e 93	jsr $939e	                jsr w_two_drop ; ud   (partially converted number)
.9d9f		a9 3e		lda #$3e	                lda #'>'
.9da1		20 93 86	jsr $8693	                jsr emit_a
.9da4		20 bb 94	jsr $94bb	                jsr w_type
.9da7		a9 3c		lda #$3c	                lda #'<'
.9da9		20 93 86	jsr $8693	                jsr emit_a
.9dac		20 bc 91	jsr $91bc	                jsr w_space
.9daf		68		pla		                pla
.9db0		85 18		sta $18		                sta base
.9db2		a9 08		lda #$08	                lda #err_syntax
.9db4		4c 9f d8	jmp $d89f	                jmp error
.9db7						_all_converted:
.9db7		e8		inx		                inx ; Drop the current addr u
.9db8		e8		inx		                inx
.9db9		e8		inx		                inx
.9dba		e8		inx		                inx
.9dbb						_drop_original_string:
.9dbb		20 77 94	jsr $9477	                jsr w_two_swap  ; Drop the original addr u
.9dbe		20 9e 93	jsr $939e	                jsr w_two_drop  ; (was saved for unknown word error message)
.9dc1		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9dc3		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9dc5		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9dc6		f0 0a		beq $9dd2	                beq _single
.9dc8		98		tya		                tya
.9dc9		04 1c		tsb $1c		                tsb status
.9dcb		90 0f		bcc $9ddc	                bcc _done       ; no minus, all done
.9dcd		20 b7 9e	jsr $9eb7	                jsr w_dnegate
.9dd0		80 0a		bra $9ddc	                bra _done
.9dd2						_single:
.9dd2		e8		inx		                inx
.9dd3		e8		inx		                inx
.9dd4		98		tya		                tya
.9dd5		14 1c		trb $1c		                trb status
.9dd7		90 03		bcc $9ddc	                bcc _done       ; no minus, all done
.9dd9		20 02 8c	jsr $8c02	                jsr w_negate
.9ddc						_done:
.9ddc		68		pla		                pla
.9ddd		85 18		sta $18		                sta base
.9ddf		60		rts		z_number:       rts
.9de0						xt_editor_wordlist:
.9de0						xt_one:
.9de0						w_editor_wordlist:
.9de0						w_one:
.9de0		ca		dex		                dex
.9de1		ca		dex		                dex
.9de2		a9 01		lda #$01	                lda #1
.9de4		95 00		sta $00,x	                sta 0,x
.9de6		74 01		stz $01,x	                stz 1,x
.9de8						z_editor_wordlist:
.9de8						z_one:
.9de8		60		rts		                rts
.9de9						xt_output:
.9de9						w_output:
.9de9		ca		dex		                dex
.9dea		ca		dex		                dex
.9deb		a9 12		lda #$12	                lda #<output
.9ded		95 00		sta $00,x	                sta 0,x
.9def		a9 00		lda #$00	                lda #>output
.9df1		95 01		sta $01,x	                sta 1,x
.9df3		60		rts		z_output:       rts
.9df4						xt_r_to_input:
.9df4						w_r_to_input:
.9df4		68		pla		                pla
.9df5		85 25		sta $25		                sta tmp1
.9df7		68		pla		                pla
.9df8		85 26		sta $26		                sta tmp1+1
.9dfa		a0 00		ldy #$00	                ldy #0
.9dfc						_loop:
.9dfc		68		pla		                pla
.9dfd		99 0a 00	sta $000a,y	                sta insrc,y
.9e00		c8		iny		                iny
.9e01		c0 08		cpy #$08	                cpy #8
.9e03		d0 f7		bne $9dfc	                bne _loop
.9e05		a5 26		lda $26		                lda tmp1+1
.9e07		48		pha		                pha
.9e08		a5 25		lda $25		                lda tmp1
.9e0a		48		pha		                pha
.9e0b		60		rts		z_r_to_input: 	rts
.9e0c						xt_strip_underflow:
.9e0c						w_strip_underflow:
.9e0c		a9 02		lda #$02	                lda #uf_strip_offset
.9e0e		4c 45 d7	jmp $d745	                jmp push_upvar_tos
.9e11						z_strip_underflow:
.9e11						xt_assembler_wordlist:
.9e11						xt_two:
.9e11						w_assembler_wordlist:
.9e11						w_two:
.9e11		ca		dex		                dex
.9e12		ca		dex		                dex
.9e13		a9 02		lda #$02	                lda #2
.9e15		95 00		sta $00,x	                sta 0,x
.9e17		74 01		stz $01,x	                stz 1,x
.9e19						z_assembler_wordlist:
.9e19		60		rts		z_two:          rts
.9e1a						xt_useraddr:
.9e1a						w_useraddr:
.9e1a		ca		dex		                dex
.9e1b		ca		dex		                dex
.9e1c		a9 08		lda #$08	                lda #<up
.9e1e		95 00		sta $00,x	                sta 0,x
.9e20		a9 00		lda #$00	                lda #>up
.9e22		95 01		sta $01,x	                sta 1,x
.9e24		60		rts		z_useraddr:     rts
.9e25						xt_wordsize:
.9e25		20 89 d8	jsr $d889	                jsr underflow_1
.9e28						w_wordsize:
.9e28		b5 00		lda $00,x	                lda 0,x
.9e2a		85 25		sta $25		                sta tmp1
.9e2c		b5 01		lda $01,x	                lda 1,x
.9e2e		85 26		sta $26		                sta tmp1+1
.9e30		a0 06		ldy #$06	                ldy #6
.9e32		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9e34		88		dey		                dey
.9e35		88		dey		                dey
.9e36		38		sec		                sec
.9e37		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9e39		95 00		sta $00,x	                sta 0,x
.9e3b		a0 07		ldy #$07	                ldy #7
.9e3d		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9e3f		88		dey		                dey
.9e40		88		dey		                dey
.9e41		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9e43		95 01		sta $01,x	                sta 1,x
.9e45		60		rts		z_wordsize:     rts
.9e46						xt_case:
.9e46						xt_false:
.9e46						xt_forth_wordlist:
.9e46						xt_zero:
.9e46						w_case:
.9e46						w_false:
.9e46						w_forth_wordlist:
.9e46						w_zero:
.9e46		ca		dex		                dex             ; push
.9e47		ca		dex		                dex
.9e48		74 00		stz $00,x	                stz 0,x
.9e4a		74 01		stz $01,x	                stz 1,x
.9e4c						z_case:
.9e4c						z_false:
.9e4c						z_forth_wordlist:
.9e4c						z_zero:
.9e4c		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9e4d						xt_d_minus:
.9e4d		20 98 d8	jsr $d898	                jsr underflow_4 ; two double numbers
.9e50						w_d_minus:
.9e50		38		sec		                sec
.9e51		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9e53		f5 02		sbc $02,x	                sbc 2,x
.9e55		95 06		sta $06,x	                sta 6,x
.9e57		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9e59		f5 03		sbc $03,x	                sbc 3,x
.9e5b		95 07		sta $07,x	                sta 7,x
.9e5d		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9e5f		f5 00		sbc $00,x	                sbc 0,x
.9e61		95 04		sta $04,x	                sta 4,x
.9e63		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9e65		f5 01		sbc $01,x	                sbc 1,x
.9e67		95 05		sta $05,x	                sta 5,x
.9e69		e8		inx		                inx
.9e6a		e8		inx		                inx
.9e6b		e8		inx		                inx
.9e6c		e8		inx		                inx
.9e6d		60		rts		z_d_minus:      rts
.9e6e						xt_d_plus:
.9e6e		20 98 d8	jsr $d898	                jsr underflow_4 ; two double numbers
.9e71						w_d_plus:
.9e71		18		clc		                clc
.9e72		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9e74		75 06		adc $06,x	                adc 6,x
.9e76		95 06		sta $06,x	                sta 6,x
.9e78		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9e7a		75 07		adc $07,x	                adc 7,x
.9e7c		95 07		sta $07,x	                sta 7,x
.9e7e		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9e80		75 04		adc $04,x	                adc 4,x
.9e82		95 04		sta $04,x	                sta 4,x
.9e84		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9e86		75 05		adc $05,x	                adc 5,x
.9e88		95 05		sta $05,x	                sta 5,x
.9e8a		e8		inx		                inx
.9e8b		e8		inx		                inx
.9e8c		e8		inx		                inx
.9e8d		e8		inx		                inx
.9e8e		60		rts		z_d_plus:       rts
.9e8f						xt_d_to_s:
.9e8f		20 8e d8	jsr $d88e	                jsr underflow_2
.9e92						w_d_to_s:
.9e92		e8		inx		                inx
.9e93		e8		inx		                inx
.9e94		60		rts		z_d_to_s:       rts
.9e95						xt_dabs:
.9e95		20 8e d8	jsr $d88e	                jsr underflow_2 ; double number
.9e98						w_dabs:
.9e98		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9e9a		10 17		bpl $9eb3	                bpl _done       ; positive, we get off light
.9e9c		a0 00		ldy #$00	                ldy #0
.9e9e		38		sec		                sec
.9e9f		98		tya		                tya
.9ea0		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9ea2		95 02		sta $02,x	                sta 2,x
.9ea4		98		tya		                tya
.9ea5		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9ea7		95 03		sta $03,x	                sta 3,x
.9ea9		98		tya		                tya
.9eaa		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9eac		95 00		sta $00,x	                sta 0,x
.9eae		98		tya		                tya
.9eaf		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9eb1		95 01		sta $01,x	                sta 1,x
.9eb3						_done:
.9eb3		60		rts		z_dabs:         rts
.9eb4						xt_dnegate:
.9eb4		20 8e d8	jsr $d88e	                jsr underflow_2 ; double number
.9eb7						w_dnegate:
.9eb7		a0 00		ldy #$00	     		ldy #0
.9eb9		38		sec		                sec
.9eba		98		tya		                tya
.9ebb		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9ebd		95 02		sta $02,x	                sta 2,x
.9ebf		98		tya		                tya
.9ec0		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9ec2		95 03		sta $03,x	                sta 3,x
.9ec4		98		tya		                tya
.9ec5		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9ec7		95 00		sta $00,x	                sta 0,x
.9ec9		98		tya		                tya
.9eca		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9ecc		95 01		sta $01,x	                sta 1,x
.9ece		60		rts		z_dnegate:      rts
.9ecf						xt_d_dot:
.9ecf		20 8e d8	jsr $d88e	                jsr underflow_2
.9ed2						w_d_dot:
.9ed2		20 84 93	jsr $9384	                jsr w_tuck
.9ed5		20 98 9e	jsr $9e98	                jsr w_dabs
.9ed8		20 ba 89	jsr $89ba	                jsr w_less_number_sign
.9edb		20 92 8c	jsr $8c92	                jsr w_number_sign_s
.9ede		20 73 8f	jsr $8f73	                jsr w_rot
.9ee1		20 3f 91	jsr $913f	                jsr w_sign
.9ee4		20 70 8c	jsr $8c70	                jsr w_number_sign_greater
.9ee7		20 bb 94	jsr $94bb	                jsr w_type
.9eea		20 bc 91	jsr $91bc	                jsr w_space
.9eed		60		rts		z_d_dot:        rts
.9eee						xt_d_dot_r:
.9eee		20 93 d8	jsr $d893	                jsr underflow_3
.9ef1						w_d_dot_r:
.9ef1		20 60 93	jsr $9360	                jsr w_to_r
.9ef4		20 84 93	jsr $9384	                jsr w_tuck
.9ef7		20 98 9e	jsr $9e98	                jsr w_dabs
.9efa		20 ba 89	jsr $89ba	                jsr w_less_number_sign
.9efd		20 92 8c	jsr $8c92	                jsr w_number_sign_s
.9f00		20 73 8f	jsr $8f73	                jsr w_rot
.9f03		20 3f 91	jsr $913f	                jsr w_sign
.9f06		20 70 8c	jsr $8c70	                jsr w_number_sign_greater
.9f09		20 cc 8e	jsr $8ecc	                jsr w_r_from
.9f0c		20 e4 8c	jsr $8ce4	                jsr w_over
.9f0f		20 c4 8b	jsr $8bc4	                jsr w_minus
.9f12		20 c5 91	jsr $91c5	                jsr w_spaces
.9f15		20 bb 94	jsr $94bb	                jsr w_type
.9f18		60		rts		z_d_dot_r:      rts
.9f19						xt_m_star_slash:
.9f19		20 98 d8	jsr $d898	                jsr underflow_4
.9f1c						w_m_star_slash:
.9f1c		20 a6 93	jsr $93a6	                jsr w_two_dup
.9f1f		20 62 96	jsr $9662	                jsr w_xor
.9f22		20 25 92	jsr $9225	                jsr w_swap
.9f25		20 d2 80	jsr $80d2	                jsr w_abs
.9f28		20 60 93	jsr $9360	                jsr w_to_r
.9f2b		20 25 92	jsr $9225	                jsr w_swap
.9f2e		20 d2 80	jsr $80d2	                jsr w_abs
.9f31		20 60 93	jsr $9360	                jsr w_to_r
.9f34		20 e4 8c	jsr $8ce4	                jsr w_over
.9f37		20 62 96	jsr $9662	                jsr w_xor
.9f3a		20 cd 9c	jsr $9ccd	                jsr w_not_rot          ; rot rot
.9f3d		20 98 9e	jsr $9e98	                jsr w_dabs
.9f40		20 25 92	jsr $9225	                jsr w_swap
.9f43		20 b5 8e	jsr $8eb5	                jsr w_r_fetch
.9f46		20 82 95	jsr $9582	                jsr w_um_star
.9f49		20 73 8f	jsr $8f73	                jsr w_rot
.9f4c		20 cc 8e	jsr $8ecc	                jsr w_r_from
.9f4f		20 82 95	jsr $9582	                jsr w_um_star
.9f52		20 73 8f	jsr $8f73	                jsr w_rot
.9f55		20 46 9e	jsr $9e46	                jsr w_zero
.9f58		20 71 9e	jsr $9e71	                jsr w_d_plus
.9f5b		20 b5 8e	jsr $8eb5	                jsr w_r_fetch
.9f5e		20 40 95	jsr $9540	                jsr w_um_slash_mod
.9f61		20 cd 9c	jsr $9ccd	                jsr w_not_rot          ; rot rot
.9f64		20 cc 8e	jsr $8ecc	                jsr w_r_from
.9f67		20 40 95	jsr $9540	                jsr w_um_slash_mod
.9f6a		20 25 92	jsr $9225	                jsr w_swap
.9f6d		20 63 86	jsr $8663	                jsr w_drop
.9f70		20 25 92	jsr $9225	                jsr w_swap
.9f73		20 73 8f	jsr $8f73	                jsr w_rot
.9f76		e8		inx		                inx                     ; drop TOS
.9f77		e8		inx		                inx
.9f78		b5 fe		lda $fe,x	                lda $fe,x               ; but keep MSB
.9f7a		10 03		bpl $9f7f	                bpl z_m_star_slash      ; ... 0< if ...
.9f7c		20 b7 9e	jsr $9eb7	                jsr w_dnegate
.9f7f		60		rts		z_m_star_slash: rts
.9f80						xt_two_constant:
.9f80		20 8e d8	jsr $d88e	                jsr underflow_2
.9f83						w_two_constant:
.9f83		20 0b 84	jsr $840b	                jsr w_create
.9f86		20 25 92	jsr $9225	                jsr w_swap
.9f89		20 ae 83	jsr $83ae	                jsr w_comma
.9f8c		20 ae 83	jsr $83ae	                jsr w_comma
.9f8f		20 c4 85	jsr $85c4	                jsr does_runtime    ; does> turns into these two routines.
.9f92		20 1e d7	jsr $d71e	                jsr dodoes
.9f95		20 69 86	jsr $8669	                jsr w_dup
.9f98		20 f6 87	jsr $87f6	                jsr w_fetch
.9f9b		20 25 92	jsr $9225	                jsr w_swap
.9f9e		20 46 83	jsr $8346	                jsr w_cell_plus
.9fa1		20 f6 87	jsr $87f6	                jsr w_fetch
.9fa4		60		rts		z_two_constant: rts
.9fa5						xt_two_literal:
.9fa5		20 8e d8	jsr $d88e	                jsr underflow_2 ; double number
.9fa8						w_two_literal:
.9fa8		a9 0a		lda #$0a	                lda #template_push_tos_size
.9faa		0a		asl a		                asl
.9fab		20 c1 97	jsr $97c1	                jsr check_nc_limit
.9fae		b0 09		bcs $9fb9	                bcs _no_inline
.9fb0		20 25 92	jsr $9225	                jsr w_swap
.9fb3		20 e0 89	jsr $89e0	                jsr w_literal
.9fb6		4c e0 89	jmp $89e0	                jmp w_literal
.9fb9						_no_inline:
.9fb9		20 18 a2	jsr $a218	                jsr cmpl_two_literal
.9fbc		60		rts		z_two_literal:  rts
.9fbd						xt_two_variable:
.9fbd		20 0b 84	jsr $840b	                jsr w_create
.9fc0						w_two_variable:
.9fc0		ca		dex		                dex
.9fc1		ca		dex		                dex
.9fc2		a9 04		lda #$04	                lda #4
.9fc4		95 00		sta $00,x	                sta 0,x
.9fc6		74 01		stz $01,x	                stz 1,x
.9fc8		20 2a 82	jsr $822a	                jsr w_allot
.9fcb		60		rts		z_two_variable: rts
.9fcc						xt_ud_dot:
.9fcc		20 8e d8	jsr $d88e	                jsr underflow_2 ; double number
.9fcf						w_ud_dot:
.9fcf		20 ba 89	jsr $89ba	                jsr w_less_number_sign
.9fd2		20 92 8c	jsr $8c92	                jsr w_number_sign_s
.9fd5		20 70 8c	jsr $8c70	                jsr w_number_sign_greater
.9fd8		20 bb 94	jsr $94bb	                jsr w_type
.9fdb		20 bc 91	jsr $91bc	                jsr w_space
.9fde		60		rts		z_ud_dot:        rts
.9fdf						xt_ud_dot_r:
.9fdf		20 93 d8	jsr $d893	                jsr underflow_3
.9fe2						w_ud_dot_r:
.9fe2		20 60 93	jsr $9360	                jsr w_to_r
.9fe5		20 ba 89	jsr $89ba	                jsr w_less_number_sign
.9fe8		20 92 8c	jsr $8c92	                jsr w_number_sign_s
.9feb		20 70 8c	jsr $8c70	                jsr w_number_sign_greater
.9fee		20 cc 8e	jsr $8ecc	                jsr w_r_from
.9ff1		20 e4 8c	jsr $8ce4	                jsr w_over
.9ff4		20 c4 8b	jsr $8bc4	                jsr w_minus
.9ff7		20 c5 91	jsr $91c5	                jsr w_spaces
.9ffa		20 bb 94	jsr $94bb	                jsr w_type
.9ffd		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.9ffe						xt_cmove:
.9ffe		20 93 d8	jsr $d893	                jsr underflow_3
.a001						w_cmove:
.a001		b5 02		lda $02,x	                lda 2,x
.a003		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.a005		b5 03		lda $03,x	                lda 3,x
.a007		85 28		sta $28		                sta tmp2+1
.a009		b5 04		lda $04,x	                lda 4,x
.a00b		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.a00d		b5 05		lda $05,x	                lda 5,x
.a00f		85 26		sta $26		                sta tmp1+1
.a011		a0 00		ldy #$00	                ldy #0
.a013		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.a015		f0 0f		beq $a026	                beq _dopartial
.a017						_page:
.a017		b1 25		lda ($25),y	                lda (tmp1),y
.a019		91 27		sta ($27),y	                sta (tmp2),y
.a01b		c8		iny		                iny
.a01c		d0 f9		bne $a017	                bne _page
.a01e		e6 26		inc $26		                inc tmp1+1
.a020		e6 28		inc $28		                inc tmp2+1
.a022		d6 01		dec $01,x	                dec 1,x
.a024		d0 f1		bne $a017	                bne _page
.a026						_dopartial:
.a026		b5 00		lda $00,x	                lda 0,x         ; length of last page
.a028		f0 09		beq $a033	                beq _done
.a02a						_partial:
.a02a		b1 25		lda ($25),y	                lda (tmp1),y
.a02c		91 27		sta ($27),y	                sta (tmp2),y
.a02e		c8		iny		                iny
.a02f		d6 00		dec $00,x	                dec 0,x
.a031		d0 f7		bne $a02a	                bne _partial
.a033						_done:
.a033		8a		txa		                txa
.a034		18		clc		                clc
.a035		69 06		adc #$06	                adc #6
.a037		aa		tax		                tax
.a038		60		rts		z_cmove:        rts
.a039						xt_cmove_up:
.a039		20 93 d8	jsr $d893	                jsr underflow_3
.a03c						w_cmove_up:
.a03c		b5 02		lda $02,x	                lda 2,x
.a03e		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.a040		b5 03		lda $03,x	                lda 3,x
.a042		18		clc		                clc
.a043		75 01		adc $01,x	                adc 1,x
.a045		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.a047		b5 04		lda $04,x	                lda 4,x
.a049		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.a04b		b5 05		lda $05,x	                lda 5,x
.a04d		18		clc		                clc
.a04e		75 01		adc $01,x	                adc 1,x
.a050		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.a052		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.a054		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.a056		f0 0e		beq $a066	                beq _nopartial
.a058						_outerloop:
.a058		88		dey		                dey
.a059		f0 07		beq $a062	                beq _finishpage
.a05b						_innerloop:
.a05b		b1 25		lda ($25),y	                lda (tmp1),y
.a05d		91 27		sta ($27),y	                sta (tmp2),y
.a05f		88		dey		                dey
.a060		d0 f9		bne $a05b	                bne _innerloop
.a062						_finishpage:
.a062		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.a064		92 27		sta ($27)	                sta (tmp2)
.a066						_nopartial:
.a066		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.a068		c6 28		dec $28		                dec tmp2+1
.a06a		d6 01		dec $01,x	                dec 1,x
.a06c		d0 ea		bne $a058	                bne _outerloop
.a06e		8a		txa		                txa
.a06f		18		clc		                clc
.a070		69 06		adc #$06	                adc #6
.a072		aa		tax		                tax
.a073		60		rts		z_cmove_up:     rts
.a074						xt_compare:
.a074		20 98 d8	jsr $d898	                jsr underflow_4
.a077						w_compare:
.a077		b5 02		lda $02,x	                lda 2,x
.a079		85 27		sta $27		                sta tmp2
.a07b		b5 03		lda $03,x	                lda 3,x
.a07d		85 28		sta $28		                sta tmp2+1
.a07f		b5 06		lda $06,x	                lda 6,x
.a081		85 25		sta $25		                sta tmp1
.a083		b5 07		lda $07,x	                lda 7,x
.a085		85 26		sta $26		                sta tmp1+1
.a087						_compare_loop:
.a087		b5 04		lda $04,x	                lda 4,x
.a089		15 05		ora $05,x	                ora 5,x
.a08b		f0 2c		beq $a0b9	                beq _str1_done
.a08d		b5 00		lda $00,x	                lda 0,x
.a08f		15 01		ora $01,x	                ora 1,x
.a091		f0 3a		beq $a0cd	                beq _greater    ; Str2 empty first
.a093		b2 25		lda ($25)	                lda (tmp1)
.a095		d2 27		cmp ($27)	                cmp (tmp2)
.a097		90 26		bcc $a0bf	                bcc _less
.a099		d0 32		bne $a0cd	                bne _greater
.a09b		e6 25		inc $25		                inc tmp1
.a09d		d0 02		bne $a0a1	                bne +
.a09f		e6 26		inc $26		                inc tmp1+1
.a0a1						+
.a0a1		e6 27		inc $27		                inc tmp2
.a0a3		d0 02		bne $a0a7	                bne +
.a0a5		e6 28		inc $28		                inc tmp2+1
.a0a7						+
.a0a7		b5 04		lda $04,x	                lda 4,x
.a0a9		d0 02		bne $a0ad	                bne +
.a0ab		d6 05		dec $05,x	                dec 5,x
.a0ad						+
.a0ad		d6 04		dec $04,x	                dec 4,x
.a0af		b5 00		lda $00,x	                lda 0,x
.a0b1		d0 02		bne $a0b5	                bne +
.a0b3		d6 01		dec $01,x	                dec 1,x
.a0b5						+
.a0b5		d6 00		dec $00,x	                dec 0,x
.a0b7		80 ce		bra $a087	                bra _compare_loop
.a0b9						_str1_done:
.a0b9		b5 00		lda $00,x	                lda 0,x
.a0bb		15 01		ora $01,x	                ora 1,x
.a0bd		f0 08		beq $a0c7	                beq _equal      ; Both out of letters
.a0bf						_less:
.a0bf		a9 ff		lda #$ff	                lda #$FF
.a0c1		95 06		sta $06,x	                sta 6,x
.a0c3		95 07		sta $07,x	                sta 7,x
.a0c5		80 0c		bra $a0d3	                bra _done
.a0c7						_equal:
.a0c7		74 06		stz $06,x	                stz 6,x
.a0c9		74 07		stz $07,x	                stz 7,x
.a0cb		80 06		bra $a0d3	                bra _done
.a0cd						_greater:
.a0cd		a9 01		lda #$01	                lda #1
.a0cf		95 06		sta $06,x	                sta 6,x
.a0d1		74 07		stz $07,x	                stz 7,x
.a0d3						_done:
.a0d3		8a		txa		                txa
.a0d4		18		clc		                clc
.a0d5		69 06		adc #$06	                adc #6
.a0d7		aa		tax		                tax
.a0d8		60		rts		z_compare:      rts
.a0d9						xt_minus_leading:
.a0d9		20 8e d8	jsr $d88e	                jsr underflow_2
.a0dc						w_minus_leading:
.a0dc						_loop:
.a0dc		b5 00		lda $00,x	                lda 0,x
.a0de		15 01		ora $01,x	                ora 1,x
.a0e0		f0 0f		beq $a0f1	                beq _done
.a0e2		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a0e4		20 7c d8	jsr $d87c	                jsr is_whitespace
.a0e7		90 08		bcc $a0f1	                bcc _done
.a0e9		20 e0 9d	jsr $9de0	                jsr w_one              ; ( addr u 1 )
.a0ec		20 d1 a1	jsr $a1d1	                jsr w_slash_string     ; ( addr+ u-1 )
.a0ef		80 eb		bra $a0dc	                bra _loop
.a0f1						_done:
.a0f1						z_minus_leading:
.a0f1		60		rts		                rts
.a0f2						xt_minus_trailing:
.a0f2		20 8e d8	jsr $d88e	                jsr underflow_2
.a0f5						w_minus_trailing:
.a0f5		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a0f7		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a0f9		f0 33		beq $a12e	                beq _done
.a0fb		18		clc		                clc
.a0fc		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a0fe		75 00		adc $00,x	                adc 0,x
.a100		85 25		sta $25		                sta tmp1
.a102		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a104		75 01		adc $01,x	                adc 1,x
.a106		85 26		sta $26		                sta tmp1+1
.a108		a5 25		lda $25		                lda tmp1
.a10a		d0 02		bne $a10e	                bne +
.a10c		c6 26		dec $26		                dec tmp1+1
.a10e						+
.a10e		c6 25		dec $25		                dec tmp1
.a110						_loop:
.a110		b2 25		lda ($25)	                lda (tmp1)
.a112		c9 20		cmp #$20	                cmp #AscSP
.a114		d0 18		bne $a12e	                bne _done
.a116		a5 25		lda $25		                lda tmp1
.a118		d0 02		bne $a11c	                bne +
.a11a		c6 26		dec $26		                dec tmp1+1
.a11c						+
.a11c		c6 25		dec $25		                dec tmp1
.a11e		b5 00		lda $00,x	                lda 0,x
.a120		d0 02		bne $a124	                bne +
.a122		d6 01		dec $01,x	                dec 1,x
.a124						+
.a124		d6 00		dec $00,x	                dec 0,x
.a126		b5 00		lda $00,x	                lda 0,x
.a128		15 01		ora $01,x	                ora 1,x
.a12a		f0 02		beq $a12e	                beq _done       ; Count has reached zero - we're done!
.a12c		80 e2		bra $a110	                bra _loop
.a12e						_done:
.a12e						z_minus_trailing:
.a12e		60		rts		                rts
.a12f						xt_search:
.a12f		20 98 d8	jsr $d898	                jsr underflow_4
.a132						w_search:
.a132		b5 00		lda $00,x	                lda 0,x
.a134		15 01		ora $01,x	                ora 1,x
.a136		d0 0b		bne $a143	                bne _start_search
.a138		e8		inx		                inx             ; Remove u2
.a139		e8		inx		                inx
.a13a		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a13c		95 00		sta $00,x	                sta 0,x
.a13e		95 01		sta $01,x	                sta 1,x
.a140		4c cd a1	jmp $a1cd	                jmp z_search
.a143						_start_search:
.a143		20 46 9e	jsr $9e46	                jsr w_zero
.a146						_search_loop:
.a146		18		clc		                clc
.a147		b5 00		lda $00,x	                lda 0,x
.a149		75 02		adc $02,x	                adc 2,x
.a14b		85 25		sta $25		                sta tmp1
.a14d		b5 01		lda $01,x	                lda 1,x
.a14f		75 03		adc $03,x	                adc 3,x
.a151		d5 07		cmp $07,x	                cmp 7,x
.a153		90 12		bcc $a167	                bcc _init_comparison ; Obviously less
.a155		d0 06		bne $a15d	                bne _not_found
.a157		b5 06		lda $06,x	                lda 6,x
.a159		c5 25		cmp $25		                cmp tmp1
.a15b		b0 0a		bcs $a167	                bcs _init_comparison
.a15d						_not_found:
.a15d		e8		inx		                inx             ; Remove offset
.a15e		e8		inx		                inx
.a15f		e8		inx		                inx             ; Remove u2
.a160		e8		inx		                inx
.a161		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a163		74 01		stz $01,x	                stz 1,x
.a165		80 66		bra $a1cd	                bra z_search
.a167						_init_comparison:
.a167		18		clc		                clc
.a168		b5 08		lda $08,x	                lda 8,x
.a16a		75 00		adc $00,x	                adc 0,x
.a16c		85 25		sta $25		                sta tmp1
.a16e		b5 09		lda $09,x	                lda 9,x
.a170		75 01		adc $01,x	                adc 1,x
.a172		85 26		sta $26		                sta tmp1+1
.a174		b5 04		lda $04,x	                lda 4,x
.a176		85 27		sta $27		                sta tmp2
.a178		b5 05		lda $05,x	                lda 5,x
.a17a		85 28		sta $28		                sta tmp2+1
.a17c		b5 02		lda $02,x	                lda 2,x
.a17e		85 29		sta $29		                sta tmp3
.a180		b5 03		lda $03,x	                lda 3,x
.a182		85 2a		sta $2a		                sta tmp3+1
.a184						_comparison_loop:
.a184		b2 25		lda ($25)	                lda (tmp1)
.a186		d2 27		cmp ($27)	                cmp (tmp2)
.a188		f0 05		beq $a18f	                beq _letters_match
.a18a		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.a18d		80 b7		bra $a146	                bra _search_loop
.a18f						_letters_match:
.a18f		e6 25		inc $25		                inc tmp1
.a191		d0 02		bne $a195	                bne +
.a193		e6 26		inc $26		                inc tmp1+1
.a195						+
.a195		e6 27		inc $27		                inc tmp2
.a197		d0 02		bne $a19b	                bne +
.a199		e6 28		inc $28		                inc tmp2+1
.a19b						+
.a19b		a5 29		lda $29		                lda tmp3
.a19d		d0 02		bne $a1a1	                bne +
.a19f		c6 2a		dec $2a		                dec tmp3+1
.a1a1						+
.a1a1		c6 29		dec $29		                dec tmp3
.a1a3		a5 29		lda $29		                lda tmp3
.a1a5		05 2a		ora $2a		                ora tmp3+1
.a1a7		d0 db		bne $a184	                bne _comparison_loop ; Check the next letter
.a1a9		18		clc		                clc
.a1aa		b5 00		lda $00,x	                lda 0,x
.a1ac		75 08		adc $08,x	                adc 8,x
.a1ae		95 08		sta $08,x	                sta 8,x
.a1b0		b5 01		lda $01,x	                lda 1,x
.a1b2		75 09		adc $09,x	                adc 9,x
.a1b4		95 09		sta $09,x	                sta 9,x
.a1b6		38		sec		                sec
.a1b7		b5 06		lda $06,x	                lda 6,x
.a1b9		f5 00		sbc $00,x	                sbc 0,x
.a1bb		95 06		sta $06,x	                sta 6,x
.a1bd		b5 07		lda $07,x	                lda 7,x
.a1bf		f5 01		sbc $01,x	                sbc 1,x
.a1c1		95 07		sta $07,x	                sta 7,x
.a1c3		e8		inx		                inx             ; drop offset
.a1c4		e8		inx		                inx
.a1c5		e8		inx		                inx             ; drop u2
.a1c6		e8		inx		                inx
.a1c7		a9 ff		lda #$ff	                lda #$FF
.a1c9		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a1cb		95 01		sta $01,x	                sta 1,x
.a1cd		60		rts		z_search:       rts
.a1ce						xt_slash_string:
.a1ce		20 93 d8	jsr $d893	                jsr underflow_3
.a1d1						w_slash_string:
.a1d1		18		clc		                clc             ; 3OS+TOS
.a1d2		b5 00		lda $00,x	                lda 0,x
.a1d4		75 04		adc $04,x	                adc 4,x
.a1d6		95 04		sta $04,x	                sta 4,x
.a1d8		b5 01		lda $01,x	                lda 1,x
.a1da		75 05		adc $05,x	                adc 5,x
.a1dc		95 05		sta $05,x	                sta 5,x
.a1de		38		sec		                sec             ; NOS-TOS
.a1df		b5 02		lda $02,x	                lda 2,x
.a1e1		f5 00		sbc $00,x	                sbc 0,x
.a1e3		95 02		sta $02,x	                sta 2,x
.a1e5		b5 03		lda $03,x	                lda 3,x
.a1e7		f5 01		sbc $01,x	                sbc 1,x
.a1e9		95 03		sta $03,x	                sta 3,x
.a1eb		e8		inx		                inx
.a1ec		e8		inx		                inx
.a1ed		60		rts		z_slash_string: rts
.a1ee						xt_sliteral:
.a1ee		20 8e d8	jsr $d88e	                jsr underflow_2
.a1f1						w_sliteral:
.a1f1		20 8d 97	jsr $978d	                jsr cmpl_jump_later
.a1f4		20 60 93	jsr $9360	                jsr w_to_r
.a1f7		20 f4 88	jsr $88f4	                jsr w_here
.a1fa		20 25 92	jsr $9225	                jsr w_swap
.a1fd		20 69 86	jsr $8669	                jsr w_dup
.a200		20 2a 82	jsr $822a	                jsr w_allot            ; reserve u bytes for string
.a203		20 f4 88	jsr $88f4	                jsr w_here
.a206		20 cc 8e	jsr $8ecc	                jsr w_r_from
.a209		20 0f 92	jsr $920f	                jsr w_store            ; point jmp past string
.a20c		20 a6 93	jsr $93a6	                jsr w_two_dup
.a20f		20 98 94	jsr $9498	                jsr w_two_to_r
.a212		20 e0 8b	jsr $8be0	                jsr w_move             ; copy u bytes from addr -> addr'
.a215		20 1e 94	jsr $941e	                jsr w_two_r_from
.a218						cmpl_sliteral:
.a218						cmpl_two_literal:
.a218		a0 a2		ldy #$a2	                ldy #>sliteral_runtime
.a21a		a9 32		lda #$32	                lda #<sliteral_runtime
.a21c		20 ad 97	jsr $97ad	                jsr cmpl_subroutine
.a21f		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a221		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a223		20 b4 97	jsr $97b4	                jsr cmpl_word
.a226		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a228		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a22a		20 b4 97	jsr $97b4	                jsr cmpl_word
.a22d		e8		inx		                inx
.a22e		e8		inx		                inx
.a22f		e8		inx		                inx
.a230		e8		inx		                inx
.a231		60		rts		z_sliteral:     rts
.a232						sliteral_runtime:
.a232		ca		dex		                dex
.a233		ca		dex		                dex
.a234		ca		dex		                dex
.a235		ca		dex		                dex
.a236		68		pla		                pla
.a237		85 25		sta $25		                sta tmp1        ; LSB of address
.a239		7a		ply		                ply
.a23a		84 26		sty $26		                sty tmp1+1      ; MSB of address
.a23c		18		clc		                clc
.a23d		69 04		adc #$04	                adc #4
.a23f		90 01		bcc $a242	                bcc +
.a241		c8		iny		                iny
.a242						+
.a242		5a		phy		                phy
.a243		48		pha		                pha
.a244		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a246		b1 25		lda ($25),y	                lda (tmp1),y
.a248		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a24a		c8		iny		                iny
.a24b		b1 25		lda ($25),y	                lda (tmp1),y
.a24d		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a24f		c8		iny		                iny
.a250		b1 25		lda ($25),y	                lda (tmp1),y
.a252		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a254		c8		iny		                iny
.a255		b1 25		lda ($25),y	                lda (tmp1),y
.a257		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a259		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a25a						xt_disasm:
.a25a		20 8e d8	jsr $d88e	                jsr underflow_2
.a25d						w_disasm:
.a25d		20 61 a2	jsr $a261	                jsr disassembler
.a260		60		rts		z_disasm:       rts
.a261						disassembler:
.a261		64 32		stz $32		                stz scratch+5   ; flag indicating whether we're arriving at sliteral (vs 2literal)
.a263		20 05 84	jsr $8405	                jsr w_cr       ; ( addr u )
.a266						_byte_loop:
.a266		20 e4 8c	jsr $8ce4	                jsr w_over     ; ( addr u addr )
.a269		20 e6 94	jsr $94e6	                jsr w_u_dot    ; ( addr u )
.a26c		20 bc 91	jsr $91bc	                jsr w_space
.a26f		a9 86		lda #$86	                lda #<oc_index_table
.a271		85 27		sta $27		                sta tmp2
.a273		a9 b4		lda #$b4	                lda #>oc_index_table
.a275		85 28		sta $28		                sta tmp2+1
.a277		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a279		85 2d		sta $2d		                sta scratch     ; Save opcode
.a27b		0a		asl a		                asl             ; multiply by two for offset
.a27c		90 02		bcc $a280	                bcc +
.a27e		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a280						+
.a280		a8		tay		                tay             ; use Y as the index
.a281		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a283		85 29		sta $29		                sta tmp3
.a285		48		pha		                pha
.a286		c8		iny		                iny
.a287		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a289		85 2a		sta $2a		                sta tmp3+1
.a28b		48		pha		                pha
.a28c		b2 29		lda ($29)	                lda (tmp3)
.a28e		a8		tay		                tay                     ; save copy of lengths byte
.a28f		10 3c		bpl $a2cd	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a291		20 46 9e	jsr $9e46	                jsr w_zero             ; ( addr u 0 ) ZERO does not use Y
.a294		f6 04		inc $04,x	                inc 4,x
.a296		d0 02		bne $a29a	                bne +
.a298		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.a29a						+
.a29a		b5 02		lda $02,x	                lda 2,x
.a29c		d0 02		bne $a2a0	                bne +
.a29e		d6 03		dec $03,x	                dec 3,x
.a2a0						+
.a2a0		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.a2a2		a1 04		lda ($04,x)	                lda (4,x)
.a2a4		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a2a6		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a2a8		98		tya		                tya                     ; retrieve copy of lengths byte
.a2a9		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a2aa		10 14		bpl $a2c0	                bpl _print_operand
.a2ac		f6 04		inc $04,x	                inc 4,x
.a2ae		d0 02		bne $a2b2	                bne +
.a2b0		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.a2b2						+
.a2b2		b5 02		lda $02,x	                lda 2,x
.a2b4		d0 02		bne $a2b8	                bne +
.a2b6		d6 03		dec $03,x	                dec 3,x
.a2b8						+
.a2b8		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.a2ba		a1 04		lda ($04,x)	                lda (4,x)
.a2bc		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a2be		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a2c0						_print_operand:
.a2c0		ca		dex		                dex
.a2c1		ca		dex		                dex
.a2c2		a9 05		lda #$05	                lda #5
.a2c4		95 00		sta $00,x	                sta 0,x
.a2c6		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.a2c8		20 f2 94	jsr $94f2	                jsr w_u_dot_r          ; U.R ( addr+n u-n )
.a2cb		80 0b		bra $a2d8	                bra _print_mnemonic
.a2cd						_no_operand:
.a2cd		ca		dex		                dex
.a2ce		ca		dex		                dex
.a2cf		a9 05		lda #$05	                lda #5
.a2d1		95 00		sta $00,x	                sta 0,x
.a2d3		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.a2d5		20 c5 91	jsr $91c5	                jsr w_spaces           ; ( addr u )
.a2d8						_print_mnemonic:
.a2d8		20 bc 91	jsr $91bc	                jsr w_space
.a2db		ca		dex		                dex
.a2dc		ca		dex		                dex                     ; ( addr u ? )
.a2dd		68		pla		                pla                     ; MSB
.a2de		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a2e0		68		pla		                pla                     ; LSB
.a2e1		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a2e3		20 f4 83	jsr $83f4	                jsr w_count            ; ( addr u addr-o u-o )
.a2e6		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2e8		b5 00		lda $00,x	                lda 0,x
.a2ea		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a2ec		95 00		sta $00,x	                sta 0,x
.a2ee		20 bb 94	jsr $94bb	                jsr w_type             ; ( addr u )
.a2f1		a5 2d		lda $2d		                lda scratch
.a2f3		c9 20		cmp #$20	                cmp #OpJSR
.a2f5		d0 15		bne $a30c	                bne _not_jsr
.a2f7		ca		dex		                dex
.a2f8		ca		dex		                dex
.a2f9		a9 05		lda #$05	                lda #5
.a2fb		95 00		sta $00,x	                sta 0,x
.a2fd		74 01		stz $01,x	                stz 1,x
.a2ff		20 c5 91	jsr $91c5	                jsr w_spaces
.a302		20 fa a3	jsr $a3fa	                jsr disasm_special
.a305		b0 70		bcs $a377	                bcs _printing_done
.a307		20 bd a3	jsr $a3bd	                jsr disasm_jsr
.a30a		b0 6b		bcs $a377	                bcs _printing_done
.a30c						_not_jsr:
.a30c		c9 4c		cmp #$4c	                cmp #OpJMP
.a30e		d0 2d		bne $a33d	                bne _not_jmp
.a310		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.a312		85 30		sta $30		                sta scratch+3
.a314		a5 2f		lda $2f		                lda scratch+2
.a316		85 31		sta $31		                sta scratch+4
.a318		b2 30		lda ($30)	                lda (scratch+3)
.a31a		c9 20		cmp #$20	                cmp #OpJSR          ; check for JSR
.a31c		d0 59		bne $a377	                bne _printing_done
.a31e		e6 30		inc $30		                inc scratch+3
.a320		d0 02		bne $a324	                bne +
.a322		e6 31		inc $31		                inc scratch+4
.a324						+
.a324		b2 30		lda ($30)	                lda (scratch+3)
.a326		c9 32		cmp #$32	                cmp #<sliteral_runtime
.a328		d0 4d		bne $a377	                bne _printing_done
.a32a		e6 30		inc $30		                inc scratch+3
.a32c		d0 02		bne $a330	                bne +
.a32e		e6 31		inc $31		                inc scratch+4
.a330						+
.a330		b2 30		lda ($30)	                lda (scratch+3)
.a332		c9 a2		cmp #$a2	                cmp #>sliteral_runtime
.a334		d0 41		bne $a377	                bne _printing_done
.a336		c6 32		dec $32		                dec scratch+5                   ; flag for next go round
.a338		20 93 a3	jsr $a393	                jsr disasm_sliteral_jump
.a33b		80 3a		bra $a377	                bra _printing_done
.a33d						_not_jmp:
.a33d		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a33f		f0 06		beq $a347	                beq _is_rel
.a341		29 1f		and #$1f	                and #$1F
.a343		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a345		d0 30		bne $a377	                bne _printing_done
.a347						_is_rel:
.a347		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a349		ca		dex		                dex
.a34a		ca		dex		                dex
.a34b		74 01		stz $01,x	                stz 1,x
.a34d		a5 2e		lda $2e		                lda scratch+1
.a34f		95 00		sta $00,x	                sta 0,x
.a351		10 04		bpl $a357	                bpl +
.a353		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a355		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a357		38		sec		+               sec                 ; start counting from address after opcode
.a358		75 04		adc $04,x	                adc 4,x
.a35a		95 00		sta $00,x	                sta 0,x
.a35c		b5 01		lda $01,x	                lda 1,x
.a35e		75 05		adc $05,x	                adc 5,x
.a360		95 01		sta $01,x	                sta 1,x
.a362		5a		phy		                phy                 ; save the direction indicator
.a363		ca		dex		                dex
.a364		ca		dex		                dex
.a365		a9 09		lda #$09	                lda #9
.a367		95 00		sta $00,x	                sta 0,x
.a369		74 01		stz $01,x	                stz 1,x
.a36b		20 f2 94	jsr $94f2	                jsr w_u_dot_r      ; print the destination with 5 leading spaces
.a36e		a9 20		lda #$20	                lda #AscSP          ; print space and branch direction indicator
.a370		20 93 86	jsr $8693	                jsr emit_a
.a373		68		pla		                pla
.a374		20 93 86	jsr $8693	                jsr emit_a
.a377						_printing_done:
.a377		20 05 84	jsr $8405	                jsr w_cr
.a37a		f6 02		inc $02,x	                inc 2,x
.a37c		d0 02		bne $a380	                bne +
.a37e		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.a380						+
.a380		20 bc 8c	jsr $8cbc	                jsr w_one_minus        ; ( addr+1 u-1 )
.a383		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a385		15 01		ora $01,x	                ora 1,x
.a387		f0 07		beq $a390	                beq _done
.a389		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a38b		30 03		bmi $a390	                bmi _done
.a38d		4c 66 a2	jmp $a266	                jmp _byte_loop          ; out of range for BRA
.a390						_done:
.a390		4c 9e 93	jmp $939e	                jmp w_two_drop         ; JSR/RTS
.a393						disasm_sliteral_jump:
.a393		20 25 92	jsr $9225	                jsr w_swap
.a396		ca		dex		                dex
.a397		ca		dex		                dex
.a398		a5 2e		lda $2e		                lda scratch+1
.a39a		95 00		sta $00,x	                sta 0,x
.a39c		a5 2f		lda $2f		                lda scratch+2
.a39e		95 01		sta $01,x	                sta 1,x
.a3a0		20 25 92	jsr $9225	                jsr w_swap
.a3a3		20 c4 8b	jsr $8bc4	                jsr w_minus
.a3a6		20 bc 8c	jsr $8cbc	                jsr w_one_minus
.a3a9		20 c4 8b	jsr $8bc4	                jsr w_minus
.a3ac		ca		dex		                dex
.a3ad		ca		dex		                dex
.a3ae		a5 2e		lda $2e		                lda scratch+1
.a3b0		95 00		sta $00,x	                sta 0,x
.a3b2		a5 2f		lda $2f		                lda scratch+2
.a3b4		95 01		sta $01,x	                sta 1,x
.a3b6		20 bc 8c	jsr $8cbc	                jsr w_one_minus
.a3b9		20 25 92	jsr $9225	                jsr w_swap ; ( new_addr new_n )
.a3bc		60		rts		                rts
.a3bd						disasm_jsr:
.a3bd		ca		dex		                dex
.a3be		ca		dex		                dex
.a3bf		a5 2e		lda $2e		                lda scratch+1
.a3c1		95 00		sta $00,x	                sta 0,x
.a3c3		a5 2f		lda $2f		                lda scratch+2
.a3c5		95 01		sta $01,x	                sta 1,x
.a3c7		20 00 9c	jsr $9c00	                jsr w_int_to_name
.a3ca		b5 00		lda $00,x	                lda 0,x
.a3cc		15 01		ora $01,x	                ora 1,x
.a3ce		d0 1e		bne $a3ee	                bne _found_nt
.a3d0		a5 2e		lda $2e		                lda scratch+1
.a3d2		38		sec		                sec
.a3d3		e9 03		sbc #$03	                sbc #3         ; Subtract 3 this time.
.a3d5		95 00		sta $00,x	                sta 0,x
.a3d7		a5 2f		lda $2f		                lda scratch+2
.a3d9		e9 00		sbc #$00	                sbc #0         ; Subtract the carry if needed.
.a3db		95 01		sta $01,x	                sta 1,x
.a3dd		20 69 86	jsr $8669	                jsr w_dup
.a3e0		20 6b 97	jsr $976b	                jsr has_uf_check
.a3e3		90 11		bcc $a3f6	                bcc _no_nt
.a3e5		20 00 9c	jsr $9c00	                jsr w_int_to_name     ; Try looking again
.a3e8		b5 00		lda $00,x	                lda 0,x
.a3ea		15 01		ora $01,x	                ora 1,x
.a3ec		f0 08		beq $a3f6	                beq _no_nt
.a3ee						_found_nt:
.a3ee		20 a3 9c	jsr $9ca3	                jsr w_name_to_string
.a3f1		20 bb 94	jsr $94bb	                jsr w_type
.a3f4		38		sec		                sec
.a3f5		60		rts		                rts
.a3f6						_no_nt:
.a3f6		e8		inx		                inx
.a3f7		e8		inx		                inx
.a3f8		18		clc		                clc
.a3f9		60		rts		                rts
.a3fa						disasm_special:
.a3fa		a0 2c		ldy #$2c	                ldy #(_end_handlers - _special_handlers - 4)
.a3fc		b9 88 a4	lda $a488,y	_check:         lda _special_handlers,y
.a3ff		c5 2e		cmp $2e		                cmp scratch+1
.a401		d0 07		bne $a40a	                bne _next
.a403		b9 89 a4	lda $a489,y	                lda _special_handlers+1,y
.a406		c5 2f		cmp $2f		                cmp scratch+2
.a408		f0 08		beq $a412	                beq _found_handler
.a40a		88		dey		_next:          dey
.a40b		88		dey		                dey
.a40c		88		dey		                dey
.a40d		88		dey		                dey
.a40e		10 ec		bpl $a3fc	                bpl _check
.a410		18		clc		                clc
.a411		60		rts		                rts
.a412						_found_handler:
.a412		a5 32		lda $32		                lda scratch+5               ; are we expecting sliteral?
.a414		f0 04		beq $a41a	                beq +
.a416		64 32		stz $32		                stz scratch+5               ; yes, skip 2literal and match again
.a418		80 f0		bra $a40a	                bra _next
.a41a						+
.a41a		b9 8b a4	lda $a48b,y	                lda _special_handlers+3,y   ; payload + prefix
.a41d		48		pha		                pha                         ; stash a copy for payload later
.a41e		4a		lsr a		                lsr
.a41f		4a		lsr a		                lsr
.a420		f0 06		beq $a428	                beq _no_prefix
.a422		18		clc		                clc
.a423		69 20		adc #$20	                adc #32
.a425		20 93 86	jsr $8693	                jsr emit_a
.a428						_no_prefix:
.a428		b9 8a a4	lda $a48a,y	                lda _special_handlers+2,y   ; string index
.a42b		20 c5 d8	jsr $d8c5	                jsr print_string_no_lf
.a42e		68		pla		                pla
.a42f		29 03		and #$03	                and #3                      ; payload is 0, 1 or 2 words
.a431		f0 0f		beq $a442	                beq _done
.a433		c9 03		cmp #$03	                cmp #3                      ; but 3 means a double-word
.a435		d0 03		bne $a43a	                bne _show_payload
.a437		4c 5c a4	jmp $a45c	                jmp _print_2literal
.a43a						_show_payload:
.a43a		48		pha		                pha
.a43b		20 44 a4	jsr $a444	                jsr _print_literal
.a43e		68		pla		                pla
.a43f		3a		dec a		                dea
.a440		d0 f8		bne $a43a	                bne _show_payload
.a442		38		sec		_done:          sec
.a443		60		rts		                rts
.a444						_print_literal:
.a444		20 25 92	jsr $9225	                jsr w_swap ; switch to (u addr)
.a447		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.a44a		20 69 86	jsr $8669	                jsr w_dup
.a44d		20 38 99	jsr $9938	                jsr w_question ; Print the value at the address
.a450		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.a453		20 25 92	jsr $9225	                jsr w_swap ; (addr+2 u)
.a456		20 bc 8c	jsr $8cbc	                jsr w_one_minus
.a459		4c bc 8c	jmp $8cbc	                jmp w_one_minus ; (addr+2 u-2)
.a45c						_print_2literal:
.a45c		20 25 92	jsr $9225	                jsr w_swap
.a45f		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.a462		20 69 86	jsr $8669	                jsr w_dup
.a465		20 be 93	jsr $93be	                jsr w_two_fetch
.a468		20 25 92	jsr $9225	                jsr w_swap             ; 2! / 2@ put MSW first; but 2literal writes LSW first
.a46b		20 d2 9e	jsr $9ed2	                jsr w_d_dot
.a46e		18		clc		                clc
.a46f		b5 00		lda $00,x	                lda 0,x
.a471		69 03		adc #$03	                adc #3
.a473		95 00		sta $00,x	                sta 0,x
.a475		90 02		bcc $a479	                bcc +
.a477		f6 01		inc $01,x	                inc 1,x
.a479						+
.a479		20 25 92	jsr $9225	                jsr w_swap ; ( addr+4 u )
.a47c		38		sec		                sec
.a47d		b5 00		lda $00,x	                lda 0,x
.a47f		e9 04		sbc #$04	                sbc #4
.a481		95 00		sta $00,x	                sta 0,x
.a483		b0 02		bcs $a487	                bcs +
.a485		d6 01		dec $01,x	                dec 1,x
.a487						+
.a487		60		rts		                rts
.a488						_special_handlers:
>a488		89 d8				    .word underflow_1
>a48a		0b 44				        .byte str_disasm_sdc, 0 + ('1'-32)*4
>a48c		8e d8				    .word underflow_2
>a48e		0b 48				        .byte str_disasm_sdc, 0 + ('2'-32)*4
>a490		93 d8				    .word underflow_3
>a492		0b 4c				        .byte str_disasm_sdc, 0 + ('3'-32)*4
>a494		98 d8				    .word underflow_4
>a496		0b 50				        .byte str_disasm_sdc, 0 + ('4'-32)*4
>a498		25 8a				    .word literal_runtime
>a49a		0c 01				        .byte str_disasm_lit, 1
>a49c		32 a2				    .word sliteral_runtime
>a49e		0c ce				        .byte str_disasm_lit, 2 + ('S'-32)*4
>a4a0		32 a2				    .word sliteral_runtime                      ; 2literal and sliteral use the same runtime
>a4a2		0c 4b				        .byte str_disasm_lit, 3 + ('2'-32)*4    ; list is searched in reverse, put 2literal first
>a4a4		4a 98				    .word zero_branch_runtime
>a4a6		0d 01				        .byte str_disasm_0bra, 1
>a4a8		bd 8a				    .word loop_runtime
>a4aa		0e 01				        .byte str_disasm_loop, 1
>a4ac		d6 8a				    .word plus_loop_runtime
>a4ae		0e 2d				        .byte str_disasm_loop, 1 + ('+'-32)*4
>a4b0		82 85				    .word do_runtime
>a4b2		0f 00				        .byte str_disasm_do, 0
>a4b4		6a 85				    .word question_do_runtime
>a4b6		0f 7d				        .byte str_disasm_do, 1 + ('?'-32)*4
.a4b8						_end_handlers:
.a4b8						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a4b8						assembler:
.a4b8						xt_asm_adc_h:
.a4b8		a9 69		lda #$69	                lda #$69
.a4ba		4c 13 a8	jmp $a813	                jmp asm_common
.a4bd						z_asm_adc_h:
.a4bd						xt_asm_adc_x:
.a4bd		a9 7d		lda #$7d	                lda #$7D
.a4bf		4c 13 a8	jmp $a813	                jmp asm_common
.a4c2						z_asm_adc_x:
.a4c2						xt_asm_adc_y:
.a4c2		a9 79		lda #$79	                lda #$79
.a4c4		4c 13 a8	jmp $a813	                jmp asm_common
.a4c7						z_asm_adc_y:
.a4c7						xt_asm_adc_z:
.a4c7		a9 65		lda #$65	                lda #$65
.a4c9		4c 13 a8	jmp $a813	                jmp asm_common
.a4cc						z_asm_adc_z:
.a4cc						xt_asm_adc_zi:
.a4cc		a9 72		lda #$72	                lda #$72
.a4ce		4c 13 a8	jmp $a813	                jmp asm_common
.a4d1						z_asm_adc_zi:
.a4d1						xt_asm_adc_ziy:
.a4d1		a9 71		lda #$71	                lda #$71
.a4d3		4c 13 a8	jmp $a813	                jmp asm_common
.a4d6						z_asm_adc_ziy:
.a4d6						xt_asm_adc_zx:
.a4d6		a9 75		lda #$75	                lda #$75
.a4d8		4c 13 a8	jmp $a813	                jmp asm_common
.a4db						z_asm_adc_zx:
.a4db						xt_asm_adc_zxi:
.a4db		a9 61		lda #$61	                lda #$61
.a4dd		4c 13 a8	jmp $a813	                jmp asm_common
.a4e0						z_asm_adc_zxi:
.a4e0						xt_asm_and:
.a4e0		a9 2d		lda #$2d	                lda #$2D
.a4e2		4c 13 a8	jmp $a813	                jmp asm_common
.a4e5						z_asm_and:
.a4e5						xt_asm_and_h:
.a4e5		a9 29		lda #$29	                lda #$29
.a4e7		4c 13 a8	jmp $a813	                jmp asm_common
.a4ea						z_asm_and_h:
.a4ea						xt_asm_and_x:
.a4ea		a9 3d		lda #$3d	                lda #$3D
.a4ec		4c 13 a8	jmp $a813	                jmp asm_common
.a4ef						z_asm_and_x:
.a4ef						xt_asm_and_y:
.a4ef		a9 39		lda #$39	                lda #$39
.a4f1		4c 13 a8	jmp $a813	                jmp asm_common
.a4f4						z_asm_and_y:
.a4f4						xt_asm_and_z:
.a4f4		a9 25		lda #$25	                lda #$25
.a4f6		4c 13 a8	jmp $a813	                jmp asm_common
.a4f9						z_asm_and_z:
.a4f9						xt_asm_and_zi:
.a4f9		a9 32		lda #$32	                lda #$32
.a4fb		4c 13 a8	jmp $a813	                jmp asm_common
.a4fe						z_asm_and_zi:
.a4fe						xt_asm_and_ziy:
.a4fe		a9 31		lda #$31	                lda #$31
.a500		4c 13 a8	jmp $a813	                jmp asm_common
.a503						z_asm_and_ziy:
.a503						xt_asm_and_zx:
.a503		a9 35		lda #$35	                lda #$35
.a505		4c 13 a8	jmp $a813	                jmp asm_common
.a508						z_asm_and_zx:
.a508						xt_asm_and_zxi:
.a508		a9 21		lda #$21	                lda #$21
.a50a		4c 13 a8	jmp $a813	                jmp asm_common
.a50d						z_asm_and_zxi:
.a50d						xt_asm_asl:
.a50d		a9 0e		lda #$0e	                lda #$0E
.a50f		4c 13 a8	jmp $a813	                jmp asm_common
.a512						z_asm_asl:
.a512						xt_asm_asl_a:
.a512		a9 0a		lda #$0a	                lda #$0A
.a514		4c 13 a8	jmp $a813	                jmp asm_common
.a517						z_asm_asl_a:
.a517						xt_asm_asl_x:
.a517		a9 1e		lda #$1e	                lda #$1E
.a519		4c 13 a8	jmp $a813	                jmp asm_common
.a51c						z_asm_asl_x:
.a51c						xt_asm_asl_z:
.a51c		a9 06		lda #$06	                lda #$06
.a51e		4c 13 a8	jmp $a813	                jmp asm_common
.a521						z_asm_asl_z:
.a521						xt_asm_asl_zx:
.a521		a9 16		lda #$16	                lda #$16
.a523		4c 13 a8	jmp $a813	                jmp asm_common
.a526						z_asm_asl_zx:
.a526						xt_asm_bcc:
.a526		a9 90		lda #$90	                lda #$90
.a528		4c 13 a8	jmp $a813	                jmp asm_common
.a52b						z_asm_bcc:
.a52b						xt_asm_bcs:
.a52b		a9 b0		lda #$b0	                lda #$B0
.a52d		a0 02		ldy #$02	                ldy #2
.a52f		4c 13 a8	jmp $a813	                jmp asm_common
.a532						z_asm_bcs:
.a532						xt_asm_beq:
.a532		a9 f0		lda #$f0	                lda #$F0
.a534		4c 13 a8	jmp $a813	                jmp asm_common
.a537						z_asm_beq:
.a537						xt_asm_bit:
.a537		a9 2c		lda #$2c	                lda #$2C
.a539		4c 13 a8	jmp $a813	                jmp asm_common
.a53c						z_asm_bit:
.a53c						xt_asm_bit_h:
.a53c		a9 89		lda #$89	                lda #$89
.a53e		4c 13 a8	jmp $a813	                jmp asm_common
.a541						z_asm_bit_h:
.a541						xt_asm_bit_x:
.a541		a9 3c		lda #$3c	                lda #$3C
.a543		4c 13 a8	jmp $a813	                jmp asm_common
.a546						z_asm_bit_x:
.a546						xt_asm_bit_z:
.a546		a9 24		lda #$24	                lda #$24
.a548		4c 13 a8	jmp $a813	                jmp asm_common
.a54b						z_asm_bit_z:
.a54b						xt_asm_bit_zx:
.a54b		a9 34		lda #$34	                lda #$34
.a54d		4c 13 a8	jmp $a813	                jmp asm_common
.a550						z_asm_bit_zx:
.a550						xt_asm_bmi:
.a550		a9 30		lda #$30	                lda #$30
.a552		4c 13 a8	jmp $a813	                jmp asm_common
.a555						z_asm_bmi:
.a555						xt_asm_bne:
.a555		a9 d0		lda #$d0	                lda #$D0
.a557		4c 13 a8	jmp $a813	                jmp asm_common
.a55a						z_asm_bne:
.a55a						xt_asm_bpl:
.a55a		a9 10		lda #$10	                lda #$10
.a55c		4c 13 a8	jmp $a813	                jmp asm_common
.a55f						z_asm_bpl:
.a55f						xt_asm_bra:
.a55f		a9 80		lda #$80	                lda #$80
.a561		4c 13 a8	jmp $a813	                jmp asm_common
.a564						z_asm_bra:
.a564						xt_asm_brk:
.a564		a9 00		lda #$00	                lda #$00
.a566		4c 13 a8	jmp $a813	                jmp asm_common
.a569						z_asm_brk:
.a569						xt_asm_bvc:
.a569		a9 50		lda #$50	                lda #$50
.a56b		4c 13 a8	jmp $a813	                jmp asm_common
.a56e						z_asm_bvc:
.a56e						xt_asm_bvs:
.a56e		a9 70		lda #$70	                lda #$70
.a570		4c 13 a8	jmp $a813	                jmp asm_common
.a573						z_asm_bvs:
.a573						xt_asm_clc:
.a573		a9 18		lda #$18	                lda #$18
.a575		4c 13 a8	jmp $a813	                jmp asm_common
.a578						z_asm_clc:
.a578						xt_asm_cld:
.a578		a9 d8		lda #$d8	                lda #$D8
.a57a		4c 13 a8	jmp $a813	                jmp asm_common
.a57d						z_asm_cld:
.a57d						xt_asm_cli:
.a57d		a9 58		lda #$58	                lda #$58
.a57f		4c 13 a8	jmp $a813	                jmp asm_common
.a582						z_asm_cli:
.a582						xt_asm_clv:
.a582		a9 b8		lda #$b8	                lda #$B8
.a584		4c 13 a8	jmp $a813	                jmp asm_common
.a587						z_asm_clv:
.a587						xt_asm_cmp:
.a587		a9 cd		lda #$cd	                lda #$CD
.a589		4c 13 a8	jmp $a813	                jmp asm_common
.a58c						z_asm_cmp:
.a58c						xt_asm_cmp_h:
.a58c		a9 c9		lda #$c9	                lda #$C9
.a58e		4c 13 a8	jmp $a813	                jmp asm_common
.a591						z_asm_cmp_h:
.a591						xt_asm_cmp_x:
.a591		a9 dd		lda #$dd	                lda #$DD
.a593		4c 13 a8	jmp $a813	                jmp asm_common
.a596						z_asm_cmp_x:
.a596						xt_asm_cmp_y:
.a596		a9 d9		lda #$d9	                lda #$D9
.a598		4c 13 a8	jmp $a813	                jmp asm_common
.a59b						z_asm_cmp_y:
.a59b						xt_asm_cmp_z:
.a59b		a9 c5		lda #$c5	                lda #$C5
.a59d		4c 13 a8	jmp $a813	                jmp asm_common
.a5a0						z_asm_cmp_z:
.a5a0						xt_asm_cmp_zi:
.a5a0		a9 d2		lda #$d2	                lda #$D2
.a5a2		4c 13 a8	jmp $a813	                jmp asm_common
.a5a5						z_asm_cmp_zi:
.a5a5						xt_asm_cmp_ziy:
.a5a5		a9 d1		lda #$d1	                lda #$D1
.a5a7		4c 13 a8	jmp $a813	                jmp asm_common
.a5aa						z_asm_cmp_ziy:
.a5aa						xt_asm_cmp_zx:
.a5aa		a9 d5		lda #$d5	                lda #$D5
.a5ac		4c 13 a8	jmp $a813	                jmp asm_common
.a5af						z_asm_cmp_zx:
.a5af						xt_asm_cmp_zxi:
.a5af		a9 c1		lda #$c1	                lda #$C1
.a5b1		4c 13 a8	jmp $a813	                jmp asm_common
.a5b4						z_asm_cmp_zxi:
.a5b4						xt_asm_cpx:
.a5b4		a9 ec		lda #$ec	                lda #$EC
.a5b6		4c 13 a8	jmp $a813	                jmp asm_common
.a5b9						z_asm_cpx:
.a5b9						xt_asm_cpx_h:
.a5b9		a9 e0		lda #$e0	                lda #$E0
.a5bb		4c 13 a8	jmp $a813	                jmp asm_common
.a5be						z_asm_cpx_h:
.a5be						xt_asm_cpx_z:
.a5be		a9 e4		lda #$e4	                lda #$E4
.a5c0		4c 13 a8	jmp $a813	                jmp asm_common
.a5c3						z_asm_cpx_z:
.a5c3						xt_asm_cpy:
.a5c3		a9 cc		lda #$cc	                lda #$CC
.a5c5		a0 03		ldy #$03	                ldy #3
.a5c7		4c 13 a8	jmp $a813	                jmp asm_common
.a5ca						z_asm_cpy:
.a5ca						xt_asm_cpy_h:
.a5ca		a9 c0		lda #$c0	                lda #$C0
.a5cc		4c 13 a8	jmp $a813	                jmp asm_common
.a5cf						z_asm_cpy_h:
.a5cf						xt_asm_cpy_z:
.a5cf		a9 c4		lda #$c4	                lda #$C4
.a5d1		4c 13 a8	jmp $a813	                jmp asm_common
.a5d4						z_asm_cpy_z:
.a5d4						xt_asm_dec:
.a5d4		a9 ce		lda #$ce	                lda #$CE
.a5d6		4c 13 a8	jmp $a813	                jmp asm_common
.a5d9						z_asm_dec:
.a5d9						xt_asm_dec_a:
.a5d9		a9 3a		lda #$3a	                lda #$3A
.a5db		4c 13 a8	jmp $a813	                jmp asm_common
.a5de						z_asm_dec_a:
.a5de						xt_asm_dec_x:
.a5de		a9 de		lda #$de	                lda #$DE
.a5e0		4c 13 a8	jmp $a813	                jmp asm_common
.a5e3						z_asm_dec_x:
.a5e3						xt_asm_dec_z:
.a5e3		a9 c6		lda #$c6	                lda #$C6
.a5e5		4c 13 a8	jmp $a813	                jmp asm_common
.a5e8						z_asm_dec_z:
.a5e8						xt_asm_dec_zx:
.a5e8		a9 d6		lda #$d6	                lda #$D6
.a5ea		4c 13 a8	jmp $a813	                jmp asm_common
.a5ed						z_asm_dec_zx:
.a5ed						xt_asm_dex:
.a5ed		a9 ca		lda #$ca	                lda #$CA
.a5ef		4c 13 a8	jmp $a813	                jmp asm_common
.a5f2						z_asm_dex:
.a5f2						xt_asm_dey:
.a5f2		a9 88		lda #$88	                lda #$88
.a5f4		4c 13 a8	jmp $a813	                jmp asm_common
.a5f7						z_asm_dey:
.a5f7						xt_asm_eor:
.a5f7		a9 4d		lda #$4d	                lda #$4D
.a5f9		4c 13 a8	jmp $a813	                jmp asm_common
.a5fc						z_asm_eor:
.a5fc						xt_asm_eor_h:
.a5fc		a9 49		lda #$49	                lda #$49
.a5fe		4c 13 a8	jmp $a813	                jmp asm_common
.a601						z_asm_eor_h:
.a601						xt_asm_eor_x:
.a601		a9 5d		lda #$5d	                lda #$5D
.a603		4c 13 a8	jmp $a813	                jmp asm_common
.a606						z_asm_eor_x:
.a606						xt_asm_eor_y:
.a606		a9 59		lda #$59	                lda #$59
.a608		4c 13 a8	jmp $a813	                jmp asm_common
.a60b						z_asm_eor_y:
.a60b						xt_asm_eor_z:
.a60b		a9 45		lda #$45	                lda #$45
.a60d		4c 13 a8	jmp $a813	                jmp asm_common
.a610						z_asm_eor_z:
.a610						xt_asm_eor_zi:
.a610		a9 52		lda #$52	                lda #$52
.a612		4c 13 a8	jmp $a813	                jmp asm_common
.a615						z_asm_eor_zi:
.a615						xt_asm_eor_ziy:
.a615		a9 51		lda #$51	                lda #$51
.a617		4c 13 a8	jmp $a813	                jmp asm_common
.a61a						z_asm_eor_ziy:
.a61a						xt_asm_eor_zx:
.a61a		a9 55		lda #$55	                lda #$55
.a61c		4c 13 a8	jmp $a813	                jmp asm_common
.a61f						z_asm_eor_zx:
.a61f						xt_asm_eor_zxi:
.a61f		a9 41		lda #$41	                lda #$41
.a621		4c 13 a8	jmp $a813	                jmp asm_common
.a624						z_asm_eor_zxi:
.a624						xt_asm_inc:
.a624		a9 ee		lda #$ee	                lda #$EE
.a626		4c 13 a8	jmp $a813	                jmp asm_common
.a629						z_asm_inc:
.a629						xt_asm_inc_a:
.a629		a9 1a		lda #$1a	                lda #$1A
.a62b		4c 13 a8	jmp $a813	                jmp asm_common
.a62e						z_asm_inc_a:
.a62e						xt_asm_inc_x:
.a62e		a9 fe		lda #$fe	                lda #$FE
.a630		4c 13 a8	jmp $a813	                jmp asm_common
.a633						z_asm_inc_x:
.a633						xt_asm_inc_z:
.a633		a9 e6		lda #$e6	                lda #$E6
.a635		4c 13 a8	jmp $a813	                jmp asm_common
.a638						z_asm_inc_z:
.a638						xt_asm_inc_zx:
.a638		a9 f6		lda #$f6	                lda #$F6
.a63a		4c 13 a8	jmp $a813	                jmp asm_common
.a63d						z_asm_inc_zx:
.a63d						xt_asm_inx:
.a63d		a9 e8		lda #$e8	                lda #$E8
.a63f		4c 13 a8	jmp $a813	                jmp asm_common
.a642						z_asm_inx:
.a642						xt_asm_iny:
.a642		a9 c8		lda #$c8	                lda #$C8
.a644		4c 13 a8	jmp $a813	                jmp asm_common
.a647						z_asm_iny:
.a647						xt_asm_jmp:
.a647		a9 4c		lda #$4c	                lda #$4C
.a649		4c 13 a8	jmp $a813	                jmp asm_common
.a64c						z_asm_jmp:
.a64c						xt_asm_jmp_i:
.a64c		a9 6c		lda #$6c	                lda #$6C
.a64e		4c 13 a8	jmp $a813	                jmp asm_common
.a651						z_asm_jmp_i:
.a651						xt_asm_jmp_xi:
.a651		a9 7c		lda #$7c	                lda #$7C
.a653		4c 13 a8	jmp $a813	                jmp asm_common
.a656						z_asm_jmp_xi:
.a656						xt_asm_jsr:
.a656		a9 20		lda #$20	                lda #$20
.a658		4c 13 a8	jmp $a813	                jmp asm_common
.a65b						z_asm_jsr:
.a65b						xt_asm_lda:
.a65b		a9 ad		lda #$ad	                lda #$AD
.a65d		4c 13 a8	jmp $a813	                jmp asm_common
.a660						z_asm_lda:
.a660						xt_asm_lda_h:
.a660		a9 a9		lda #$a9	                lda #$A9
.a662		4c 13 a8	jmp $a813	                jmp asm_common
.a665						z_asm_lda_h:
.a665						xt_asm_lda_x:
.a665		a9 bd		lda #$bd	                lda #$BD
.a667		4c 13 a8	jmp $a813	                jmp asm_common
.a66a						z_asm_lda_x:
.a66a						xt_asm_lda_y:
.a66a		a9 b9		lda #$b9	                lda #$B9
.a66c		4c 13 a8	jmp $a813	                jmp asm_common
.a66f						z_asm_lda_y:
.a66f						xt_asm_lda_z:
.a66f		a9 a5		lda #$a5	                lda #$A5
.a671		4c 13 a8	jmp $a813	                jmp asm_common
.a674						z_asm_lda_z:
.a674						xt_asm_lda_zi:
.a674		a9 b2		lda #$b2	                lda #$B2
.a676		4c 13 a8	jmp $a813	                jmp asm_common
.a679						z_asm_lda_zi:
.a679						xt_asm_lda_ziy:
.a679		a9 b1		lda #$b1	                lda #$B1
.a67b		4c 13 a8	jmp $a813	                jmp asm_common
.a67e						z_asm_lda_ziy:
.a67e						xt_asm_lda_zx:
.a67e		a9 b5		lda #$b5	                lda #$B5
.a680		4c 13 a8	jmp $a813	                jmp asm_common
.a683						z_asm_lda_zx:
.a683						xt_asm_lda_zxi:
.a683		a9 a1		lda #$a1	                lda #$A1
.a685		4c 13 a8	jmp $a813	                jmp asm_common
.a688						z_asm_lda_zxi:
.a688						xt_asm_ldx:
.a688		a9 ae		lda #$ae	                lda #$AE
.a68a		4c 13 a8	jmp $a813	                jmp asm_common
.a68d						z_asm_ldx:
.a68d						xt_asm_ldx_h:
.a68d		a9 a2		lda #$a2	                lda #$A2
.a68f		4c 13 a8	jmp $a813	                jmp asm_common
.a692						z_asm_ldx_h:
.a692						xt_asm_ldx_y:
.a692		a9 be		lda #$be	                lda #$BE
.a694		4c 13 a8	jmp $a813	                jmp asm_common
.a697						z_asm_ldx_y:
.a697						xt_asm_ldx_z:
.a697		a9 a6		lda #$a6	                lda #$A6
.a699		4c 13 a8	jmp $a813	                jmp asm_common
.a69c						z_asm_ldx_z:
.a69c						xt_asm_ldx_zy:
.a69c		a9 b6		lda #$b6	                lda #$B6
.a69e		4c 13 a8	jmp $a813	                jmp asm_common
.a6a1						z_asm_ldx_zy:
.a6a1						xt_asm_ldy:
.a6a1		a9 ac		lda #$ac	                lda #$AC
.a6a3		4c 13 a8	jmp $a813	                jmp asm_common
.a6a6						z_asm_ldy:
.a6a6						xt_asm_ldy_h:
.a6a6		a9 a0		lda #$a0	                lda #$A0
.a6a8		4c 13 a8	jmp $a813	                jmp asm_common
.a6ab						z_asm_ldy_h:
.a6ab						xt_asm_ldy_x:
.a6ab		a9 bc		lda #$bc	                lda #$BC
.a6ad		4c 13 a8	jmp $a813	                jmp asm_common
.a6b0						z_asm_ldy_x:
.a6b0						xt_asm_ldy_z:
.a6b0		a9 a4		lda #$a4	                lda #$A4
.a6b2		4c 13 a8	jmp $a813	                jmp asm_common
.a6b5						z_asm_ldy_z:
.a6b5						xt_asm_ldy_zx:
.a6b5		a9 b4		lda #$b4	                lda #$B4
.a6b7		4c 13 a8	jmp $a813	                jmp asm_common
.a6ba						z_asm_ldy_zx:
.a6ba						xt_asm_lsr:
.a6ba		a9 4e		lda #$4e	                lda #$4E
.a6bc		4c 13 a8	jmp $a813	                jmp asm_common
.a6bf						z_asm_lsr:
.a6bf						xt_asm_lsr_a:
.a6bf		a9 4a		lda #$4a	                lda #$4A
.a6c1		4c 13 a8	jmp $a813	                jmp asm_common
.a6c4						z_asm_lsr_a:
.a6c4						xt_asm_lsr_x:
.a6c4		a9 5e		lda #$5e	                lda #$5E
.a6c6		4c 13 a8	jmp $a813	                jmp asm_common
.a6c9						z_asm_lsr_x:
.a6c9						xt_asm_lsr_z:
.a6c9		a9 46		lda #$46	                lda #$46
.a6cb		4c 13 a8	jmp $a813	                jmp asm_common
.a6ce						z_asm_lsr_z:
.a6ce						xt_asm_lsr_zx:
.a6ce		a9 56		lda #$56	                lda #$56
.a6d0		4c 13 a8	jmp $a813	                jmp asm_common
.a6d3						z_asm_lsr_zx:
.a6d3						xt_asm_nop:
.a6d3		a9 ea		lda #$ea	                lda #$EA
.a6d5		4c 13 a8	jmp $a813	                jmp asm_common
.a6d8						z_asm_nop:
.a6d8						xt_asm_ora:
.a6d8		a9 0d		lda #$0d	                lda #$0D
.a6da		4c 13 a8	jmp $a813	                jmp asm_common
.a6dd						z_asm_ora:
.a6dd						xt_asm_ora_h:
.a6dd		a9 09		lda #$09	                lda #$09
.a6df		4c 13 a8	jmp $a813	                jmp asm_common
.a6e2						z_asm_ora_h:
.a6e2						xt_asm_ora_x:
.a6e2		a9 1d		lda #$1d	                lda #$1D
.a6e4		4c 13 a8	jmp $a813	                jmp asm_common
.a6e7						z_asm_ora_x:
.a6e7						xt_asm_ora_y:
.a6e7		a9 19		lda #$19	                lda #$19
.a6e9		4c 13 a8	jmp $a813	                jmp asm_common
.a6ec						z_asm_ora_y:
.a6ec						xt_asm_ora_z:
.a6ec		a9 05		lda #$05	                lda #$05
.a6ee		4c 13 a8	jmp $a813	                jmp asm_common
.a6f1						z_asm_ora_z:
.a6f1						xt_asm_ora_zi:
.a6f1		a9 12		lda #$12	                lda #$12
.a6f3		a0 02		ldy #$02	                ldy #2
.a6f5		4c 13 a8	jmp $a813	                jmp asm_common
.a6f8						z_asm_ora_zi:
.a6f8						xt_asm_ora_ziy:
.a6f8		a9 11		lda #$11	                lda #$11
.a6fa		4c 13 a8	jmp $a813	                jmp asm_common
.a6fd						z_asm_ora_ziy:
.a6fd						xt_asm_ora_zx:
.a6fd		a9 15		lda #$15	                lda #$15
.a6ff		4c 13 a8	jmp $a813	                jmp asm_common
.a702						z_asm_ora_zx:
.a702						xt_asm_ora_zxi:
.a702		a9 01		lda #$01	                lda #$01
.a704		4c 13 a8	jmp $a813	                jmp asm_common
.a707						z_asm_ora_zxi:
.a707						xt_asm_pha:
.a707		a9 48		lda #$48	                lda #$48
.a709		4c 13 a8	jmp $a813	                jmp asm_common
.a70c						z_asm_pha:
.a70c						xt_asm_php:
.a70c		a9 08		lda #$08	                lda #$08
.a70e		4c 13 a8	jmp $a813	                jmp asm_common
.a711						z_asm_php:
.a711						xt_asm_phx:
.a711		a9 da		lda #$da	                lda #$DA
.a713		4c 13 a8	jmp $a813	                jmp asm_common
.a716						z_asm_phx:
.a716						xt_asm_phy:
.a716		a9 5a		lda #$5a	                lda #$5A
.a718		4c 13 a8	jmp $a813	                jmp asm_common
.a71b						z_asm_phy:
.a71b						xt_asm_pla:
.a71b		a9 68		lda #$68	                lda #$68
.a71d		4c 13 a8	jmp $a813	                jmp asm_common
.a720						z_asm_pla:
.a720						xt_asm_plp:
.a720		a9 28		lda #$28	                lda #$28
.a722		4c 13 a8	jmp $a813	                jmp asm_common
.a725						z_asm_plp:
.a725						xt_asm_plx:
.a725		a9 fa		lda #$fa	                lda #$FA
.a727		4c 13 a8	jmp $a813	                jmp asm_common
.a72a						z_asm_plx:
.a72a						xt_asm_ply:
.a72a		a9 7a		lda #$7a	                lda #$7A
.a72c		4c 13 a8	jmp $a813	                jmp asm_common
.a72f						z_asm_ply:
.a72f						xt_asm_rol:
.a72f		a9 2e		lda #$2e	                lda #$2E
.a731		4c 13 a8	jmp $a813	                jmp asm_common
.a734						z_asm_rol:
.a734						xt_asm_rol_a:
.a734		a9 2a		lda #$2a	                lda #$2A
.a736		4c 13 a8	jmp $a813	                jmp asm_common
.a739						z_asm_rol_a:
.a739						xt_asm_rol_x:
.a739		a9 3e		lda #$3e	                lda #$3E
.a73b		4c 13 a8	jmp $a813	                jmp asm_common
.a73e						z_asm_rol_x:
.a73e						xt_asm_rol_z:
.a73e		a9 26		lda #$26	                lda #$26
.a740		4c 13 a8	jmp $a813	                jmp asm_common
.a743						z_asm_rol_z:
.a743						xt_asm_rol_zx:
.a743		a9 36		lda #$36	                lda #$36
.a745		4c 13 a8	jmp $a813	                jmp asm_common
.a748						z_asm_rol_zx:
.a748						xt_asm_ror:
.a748		a9 6e		lda #$6e	                lda #$6E
.a74a		4c 13 a8	jmp $a813	                jmp asm_common
.a74d						z_asm_ror:
.a74d						xt_asm_ror_a:
.a74d		a9 6a		lda #$6a	                lda #$6A
.a74f		4c 13 a8	jmp $a813	                jmp asm_common
.a752						z_asm_ror_a:
.a752						xt_asm_ror_x:
.a752		a9 7e		lda #$7e	                lda #$7E
.a754		4c 13 a8	jmp $a813	                jmp asm_common
.a757						z_asm_ror_x:
.a757						xt_asm_ror_z:
.a757		a9 66		lda #$66	                lda #$66
.a759		4c 13 a8	jmp $a813	                jmp asm_common
.a75c						z_asm_ror_z:
.a75c						xt_asm_ror_zx:
.a75c		a9 76		lda #$76	                lda #$76
.a75e		4c 13 a8	jmp $a813	                jmp asm_common
.a761						z_asm_ror_zx:
.a761						xt_asm_rti:
.a761		a9 40		lda #$40	                lda #$40
.a763		4c 13 a8	jmp $a813	                jmp asm_common
.a766						z_asm_rti:
.a766						xt_asm_rts:
.a766		a9 60		lda #$60	                lda #$60
.a768		4c 13 a8	jmp $a813	                jmp asm_common
.a76b						z_asm_rts:
.a76b						xt_asm_sbc:
.a76b		a9 ed		lda #$ed	                lda #$ED
.a76d		4c 13 a8	jmp $a813	                jmp asm_common
.a770						z_asm_sbc:
.a770						xt_asm_sbc_h:
.a770		a9 e9		lda #$e9	                lda #$E9
.a772		4c 13 a8	jmp $a813	                jmp asm_common
.a775						z_asm_sbc_h:
.a775						xt_asm_sbc_x:
.a775		a9 fd		lda #$fd	                lda #$FD
.a777		4c 13 a8	jmp $a813	                jmp asm_common
.a77a						z_asm_sbc_x:
.a77a						xt_asm_sbc_y:
.a77a		a9 f9		lda #$f9	                lda #$F9
.a77c		4c 13 a8	jmp $a813	                jmp asm_common
.a77f						z_asm_sbc_y:
.a77f						xt_asm_sbc_z:
.a77f		a9 e5		lda #$e5	                lda #$E5
.a781		4c 13 a8	jmp $a813	                jmp asm_common
.a784						z_asm_sbc_z:
.a784						xt_asm_sbc_zi:
.a784		a9 f2		lda #$f2	                lda #$F2
.a786		4c 13 a8	jmp $a813	                jmp asm_common
.a789						z_asm_sbc_zi:
.a789						xt_asm_sbc_ziy:
.a789		a9 f1		lda #$f1	                lda #$F1
.a78b		4c 13 a8	jmp $a813	                jmp asm_common
.a78e						z_asm_sbc_ziy:
.a78e						xt_asm_sbc_zx:
.a78e		a9 f5		lda #$f5	                lda #$F5
.a790		4c 13 a8	jmp $a813	                jmp asm_common
.a793						z_asm_sbc_zx:
.a793						xt_asm_sbc_zxi:
.a793		a9 e1		lda #$e1	                lda #$E1
.a795		80 7c		bra $a813	                bra asm_common  ; <-- limit for BRA instead of JMP
.a797						z_asm_sbc_zxi:
.a797						xt_asm_sec:
.a797		a9 38		lda #$38	                lda #$38
.a799		80 78		bra $a813	                bra asm_common
.a79b						z_asm_sec:
.a79b						xt_asm_sed:
.a79b		a9 f8		lda #$f8	                lda #$F8
.a79d		80 74		bra $a813	                bra asm_common
.a79f						z_asm_sed:
.a79f						xt_asm_sei:
.a79f		a9 78		lda #$78	                lda #$78
.a7a1		80 70		bra $a813	                bra asm_common
.a7a3						z_asm_sei:
.a7a3						xt_asm_sta:
.a7a3		a9 8d		lda #$8d	                lda #$8D
.a7a5		80 6c		bra $a813	                bra asm_common
.a7a7						z_asm_sta:
.a7a7						xt_asm_sta_x:
.a7a7		a9 9d		lda #$9d	                lda #$9D
.a7a9		80 68		bra $a813	                bra asm_common
.a7ab						z_asm_sta_x:
.a7ab						xt_asm_sta_y:
.a7ab		a9 99		lda #$99	                lda #$99
.a7ad		80 64		bra $a813	                bra asm_common
.a7af						z_asm_sta_y:
.a7af						xt_asm_sta_z:
.a7af		a9 85		lda #$85	                lda #$85
.a7b1		80 60		bra $a813	                bra asm_common
.a7b3						z_asm_sta_z:
.a7b3						xt_asm_sta_zi:
.a7b3		a9 92		lda #$92	                lda #$92
.a7b5		80 5c		bra $a813	                bra asm_common
.a7b7						z_asm_sta_zi:
.a7b7						xt_asm_sta_ziy:
.a7b7		a9 91		lda #$91	                lda #$91
.a7b9		80 58		bra $a813	                bra asm_common
.a7bb						z_asm_sta_ziy:
.a7bb						xt_asm_sta_zx:
.a7bb		a9 95		lda #$95	                lda #$95
.a7bd		80 54		bra $a813	                bra asm_common
.a7bf						z_asm_sta_zx:
.a7bf						xt_asm_sta_zxi:
.a7bf		a9 81		lda #$81	                lda #$81
.a7c1		80 50		bra $a813	                bra asm_common
.a7c3						z_asm_sta_zxi:
.a7c3						xt_asm_stx:
.a7c3		a9 8e		lda #$8e	                lda #$8E
.a7c5		80 4c		bra $a813	                bra asm_common
.a7c7						z_asm_stx:
.a7c7						xt_asm_stx_z:
.a7c7		a9 86		lda #$86	                lda #$86
.a7c9		80 48		bra $a813	                bra asm_common
.a7cb						z_asm_stx_z:
.a7cb						xt_asm_stx_zy:
.a7cb		a9 96		lda #$96	                lda #$96
.a7cd		80 44		bra $a813	                bra asm_common
.a7cf						z_asm_stx_zy:
.a7cf						xt_asm_sty:
.a7cf		a9 8c		lda #$8c	                lda #$8C
.a7d1		80 40		bra $a813	                bra asm_common
.a7d3						z_asm_sty:
.a7d3						xt_asm_sty_z:
.a7d3		a9 84		lda #$84	                lda #$84
.a7d5		80 3c		bra $a813	                bra asm_common
.a7d7						z_asm_sty_z:
.a7d7						xt_asm_sty_zx:
.a7d7		a9 94		lda #$94	                lda #$94
.a7d9		80 38		bra $a813	                bra asm_common
.a7db						z_asm_sty_zx:
.a7db						xt_asm_stz:
.a7db		a9 9c		lda #$9c	                lda #$9C
.a7dd		80 34		bra $a813	                bra asm_common
.a7df						z_asm_stz:
.a7df						xt_asm_stz_x:
.a7df		a9 9e		lda #$9e	                lda #$9E
.a7e1		80 30		bra $a813	                bra asm_common
.a7e3						z_asm_stz_x:
.a7e3						xt_asm_stz_z:
.a7e3		a9 64		lda #$64	                lda #$64
.a7e5		80 2c		bra $a813	                bra asm_common
.a7e7						z_asm_stz_z:
.a7e7						xt_asm_stz_zx:
.a7e7		a9 74		lda #$74	                lda #$74
.a7e9		80 28		bra $a813	                bra asm_common
.a7eb						z_asm_stz_zx:
.a7eb						xt_asm_tax:
.a7eb		a9 aa		lda #$aa	                lda #$AA
.a7ed		80 24		bra $a813	                bra asm_common
.a7ef						z_asm_tax:
.a7ef						xt_asm_tay:
.a7ef		a9 a8		lda #$a8	                lda #$A8
.a7f1		80 20		bra $a813	                bra asm_common
.a7f3						z_asm_tay:
.a7f3						xt_asm_trb:
.a7f3		a9 1c		lda #$1c	                lda #$1C
.a7f5		80 1c		bra $a813	                bra asm_common
.a7f7						z_asm_trb:
.a7f7						xt_asm_trb_z:
.a7f7		a9 14		lda #$14	                lda #$14
.a7f9		80 18		bra $a813	                bra asm_common
.a7fb						z_asm_trb_z:
.a7fb						xt_asm_tsb:
.a7fb		a9 0c		lda #$0c	                lda #$0C
.a7fd		80 14		bra $a813	                bra asm_common
.a7ff						z_asm_tsb:
.a7ff						xt_asm_tsb_z:
.a7ff		a9 04		lda #$04	                lda #$04
.a801		80 10		bra $a813	                bra asm_common
.a803						z_asm_tsb_z:
.a803						xt_asm_tsx:
.a803		a9 ba		lda #$ba	                lda #$BA
.a805		80 0c		bra $a813	                bra asm_common
.a807						z_asm_tsx:
.a807						xt_asm_txa:
.a807		a9 8a		lda #$8a	                lda #$8A
.a809		80 08		bra $a813	                bra asm_common
.a80b						z_asm_txa:
.a80b						xt_asm_txs:
.a80b		a9 9a		lda #$9a	                lda #$9A
.a80d		80 04		bra $a813	                bra asm_common
.a80f						z_asm_txs:
.a80f						xt_asm_tya:
.a80f		a9 98		lda #$98	                lda #$98
.a811		80 00		bra $a813	                bra asm_common
.a813						z_asm_tya:
.a813						asm_common:
.a813		a8		tay		                tay
.a814		20 b8 97	jsr $97b8	                jsr cmpl_a
.a817		a9 86		lda #$86	                lda #<oc_index_table
.a819		85 27		sta $27		                sta tmp2
.a81b		a9 b4		lda #$b4	                lda #>oc_index_table
.a81d		85 28		sta $28		                sta tmp2+1
.a81f		98		tya		                tya             ; retrieve opcode
.a820		0a		asl a		                asl             ; times two for offset
.a821		90 02		bcc $a825	                bcc +
.a823		e6 28		inc $28		                inc tmp2+1
.a825						+
.a825		a8		tay		                tay             ; use Y as the index
.a826		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a828		85 29		sta $29		                sta tmp3
.a82a		c8		iny		                iny
.a82b		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a82d		85 2a		sta $2a		                sta tmp3+1
.a82f		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a831		2a		rol a		                rol
.a832		2a		rol a		                rol
.a833		2a		rol a		                rol             ; Three times because we go through Carry
.a834		29 03		and #$03	                and #%00000011
.a836		a8		tay		                tay
.a837		88		dey		                dey
.a838		f0 12		beq $a84c	                beq _done
.a83a		20 89 d8	jsr $d889	                jsr underflow_1
.a83d		b5 00		lda $00,x	                lda 0,x
.a83f		20 b8 97	jsr $97b8	                jsr cmpl_a      ; does not use Y
.a842		88		dey		                dey
.a843		f0 05		beq $a84a	                beq _done_drop
.a845		b5 01		lda $01,x	                lda 1,x
.a847		20 b8 97	jsr $97b8	                jsr cmpl_a      ; Fall through to _done_drop
.a84a						_done_drop:
.a84a		e8		inx		                inx
.a84b		e8		inx		                inx             ; Fall through to _done
.a84c						_done:
.a84c		60		rts		                rts             ; Returns to original caller
.a84d						xt_asm_push_a:
.a84d		a0 00		ldy #$00	                ldy #0
.a84f						_loop:
.a84f		b9 5d a8	lda $a85d,y	                lda asm_push_a_data,y
.a852		c9 ff		cmp #$ff	                cmp #$FF
.a854		f0 06		beq $a85c	                beq _done
.a856		20 b8 97	jsr $97b8	                jsr cmpl_a      ; does not change Y
.a859		c8		iny		                iny
.a85a		80 f3		bra $a84f	                bra _loop
.a85c						_done:
.a85c						z_asm_push_a:
.a85c		60		rts		                rts
.a85d						asm_push_a_data:
>a85d		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>a863		ff				        .byte $FF               ; terminator
.a864						xt_asm_back_jump:
.a864						z_asm_back_jump:
.a864		60		rts		                rts
.a865						xt_asm_back_branch:
.a865		20 f4 88	jsr $88f4	                jsr w_here             ; ( addr-l addr-h )
.a868		20 c4 8b	jsr $8bc4	                jsr w_minus            ; ( offset )
.a86b		3a		dec a		                dea
.a86c		3a		dec a		                dea
.a86d						z_asm_back_branch:
.a86d		60		rts		                rts
.a86e						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a86e						xt_ed:
.a86e						w_ed:
.a86e		20 72 a8	jsr $a872	                jsr ed6502      ; kept in separate file
.a871		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a872						ed6502:
.a872		a5 18		lda $18		                lda base
.a874		85 3a		sta $3a		                sta ed_base
.a876		a9 0a		lda #$0a	                lda #10
.a878		85 18		sta $18		                sta base
.a87a		64 35		stz $35		                stz ed_head
.a87c		64 36		stz $36		                stz ed_head+1
.a87e		64 37		stz $37		                stz ed_cur
.a880		64 38		stz $38		                stz ed_cur+1
.a882		64 39		stz $39		                stz ed_flags
.a884		20 46 9e	jsr $9e46	                jsr w_zero
.a887		20 46 9e	jsr $9e46	                jsr w_zero             ; ( addr-t u-t )
.a88a		20 05 84	jsr $8405	                jsr w_cr
.a88d						ed_input_loop:
.a88d		a9 81		lda #$81	                lda #%10000001
.a88f		14 39		trb $39		                trb ed_flags
.a891		20 6c ad	jsr $ad6c	                jsr ed_get_input
.a894		a5 0e		lda $0e		                lda ciblen
.a896		d0 1f		bne $a8b7	                bne _command_mode
.a898		ca		dex		                dex
.a899		ca		dex		                dex                     ; ( addr-t u-t ? )
.a89a		a5 37		lda $37		                lda ed_cur
.a89c		95 00		sta $00,x	                sta 0,x
.a89e		a5 38		lda $38		                lda ed_cur+1
.a8a0		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a8a2		a9 80		lda #$80	                lda #%10000000
.a8a4		04 39		tsb $39		                tsb ed_flags
.a8a6		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; ( addr-t u-t u+1 )
.a8a9		20 88 ad	jsr $ad88	                jsr ed_is_valid_line
.a8ac		b0 03		bcs $a8b1	                bcs +
.a8ae		4c 5c ad	jmp $ad5c	                jmp ed_error_1drop
.a8b1						+
.a8b1		20 46 9e	jsr $9e46	                jsr w_zero             ; ( addr-t u-t u+1 0 )
.a8b4		4c 82 a9	jmp $a982	                jmp _line_number_only_from_external
.a8b7						_command_mode:
.a8b7		20 46 9e	jsr $9e46	                jsr w_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a8ba		20 46 9e	jsr $9e46	                jsr w_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a8bd		b2 0c		lda ($0c)	                lda (cib)
.a8bf		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a8c1		d0 3a		bne $a8fd	                bne _prefix_dollar
.a8c3		20 7d ad	jsr $ad7d	                jsr ed_have_text
.a8c6		a5 37		lda $37		                lda ed_cur
.a8c8		95 02		sta $02,x	                sta 2,x
.a8ca		a5 38		lda $38		                lda ed_cur+1
.a8cc		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a8ce		a9 80		lda #$80	                lda #%10000000
.a8d0		04 39		tsb $39		                tsb ed_flags
.a8d2		a5 0e		lda $0e		                lda ciblen
.a8d4		3a		dec a		                dea                     ; sets Z if A was 1
.a8d5		d0 03		bne $a8da	                bne +
.a8d7		4c 82 a9	jmp $a982	                jmp _line_number_only_from_external
.a8da						+
.a8da		ca		dex		                dex
.a8db		ca		dex		                dex
.a8dc		ca		dex		                dex
.a8dd		ca		dex		                dex
.a8de		a5 0c		lda $0c		                lda cib
.a8e0		95 02		sta $02,x	                sta 2,x
.a8e2		a5 0d		lda $0d		                lda cib+1
.a8e4		95 03		sta $03,x	                sta 3,x
.a8e6		a5 0e		lda $0e		                lda ciblen
.a8e8		95 00		sta $00,x	                sta 0,x
.a8ea		a5 0f		lda $0f		                lda ciblen+1
.a8ec		95 01		sta $01,x	                sta 1,x
.a8ee		20 bc 8c	jsr $8cbc	                jsr w_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a8f1		20 25 92	jsr $9225	                jsr w_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a8f4		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a8f7		20 25 92	jsr $9225	                jsr w_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a8fa		4c da a9	jmp $a9da	                jmp _check_for_para2
.a8fd						_prefix_dollar:
.a8fd		b2 0c		lda ($0c)	                lda (cib)
.a8ff		c9 24		cmp #$24	                cmp #'$'
.a901		d0 1c		bne $a91f	                bne _prefix_percent
.a903		20 7d ad	jsr $ad7d	                jsr ed_have_text
.a906		e8		inx		                inx
.a907		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a908		20 aa ad	jsr $adaa	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a90b		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( addr-t u-t para1 0 )
.a90e		a9 80		lda #$80	                lda #%10000000
.a910		04 39		tsb $39		                tsb ed_flags
.a912		a5 0e		lda $0e		                lda ciblen
.a914		3a		dec a		                dea                     ; sets Z if A was 1
.a915		d0 03		bne $a91a	                bne +
.a917		4c 82 a9	jmp $a982	                jmp _line_number_only_from_external
.a91a						+
.a91a		a0 01		ldy #$01	                ldy #01
.a91c		4c 56 aa	jmp $aa56	                jmp _check_command
.a91f						_prefix_percent:
.a91f		b2 0c		lda ($0c)	                lda (cib)
.a921		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a923		f0 04		beq $a929	                beq _whole_text
.a925		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a927		d0 17		bne $a940	                bne _prefix_semicolon
.a929						_whole_text:
.a929		20 7d ad	jsr $ad7d	                jsr ed_have_text
.a92c		a9 01		lda #$01	                lda #01
.a92e		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a930		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a932						_semicolon_entry:
.a932		e8		inx		                inx
.a933		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a934		20 aa ad	jsr $adaa	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a937		a9 80		lda #$80	                lda #%10000000
.a939		04 39		tsb $39		                tsb ed_flags
.a93b		a0 01		ldy #$01	                ldy #01
.a93d		4c 56 aa	jmp $aa56	                jmp _check_command
.a940						_prefix_semicolon:
.a940		b2 0c		lda ($0c)	                lda (cib)
.a942		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a944		d0 0d		bne $a953	                bne _prefix_number
.a946		20 7d ad	jsr $ad7d	                jsr ed_have_text
.a949		a5 37		lda $37		                lda ed_cur
.a94b		95 02		sta $02,x	                sta 2,x
.a94d		a5 38		lda $38		                lda ed_cur+1
.a94f		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a951		80 df		bra $a932	                bra _semicolon_entry
.a953						_prefix_number:
.a953		20 46 9e	jsr $9e46	                jsr w_zero
.a956		20 46 9e	jsr $9e46	                jsr w_zero             ; ( addr-t u-t 0 0 0 0 )
.a959		ca		dex		                dex
.a95a		ca		dex		                dex
.a95b		ca		dex		                dex
.a95c		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a95d		a5 0c		lda $0c		                lda cib
.a95f		95 02		sta $02,x	                sta 2,x
.a961		a5 0d		lda $0d		                lda cib+1
.a963		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a965		a5 0e		lda $0e		                lda ciblen
.a967		95 00		sta $00,x	                sta 0,x
.a969		a5 0f		lda $0f		                lda ciblen+1
.a96b		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a96d		20 c3 92	jsr $92c3	                jsr w_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a970		b5 00		lda $00,x	                lda 0,x
.a972		15 01		ora $01,x	                ora 1,x
.a974		d0 24		bne $a99a	                bne _have_unconverted_chars
.a976		e8		inx		                inx
.a977		e8		inx		                inx
.a978		e8		inx		                inx
.a979		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a97a		20 92 9e	jsr $9e92	                jsr w_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a97d		20 cd 9c	jsr $9ccd	                jsr w_not_rot          ; -ROT ( addr-t u-t u 0 0 )
.a980		e8		inx		                inx
.a981		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a982						_line_number_only_from_external:
.a982		20 25 92	jsr $9225	                jsr w_swap             ; ( addr-t u-t 0 u )
.a985		20 88 ad	jsr $ad88	                jsr ed_is_valid_line
.a988		b0 03		bcs $a98d	                bcs +
.a98a		4c 5a ad	jmp $ad5a	                jmp ed_error_2drop
.a98d						+
.a98d		20 25 92	jsr $9225	                jsr w_swap             ; ( addr-t u-t u 0 )
.a990		20 17 ae	jsr $ae17	                jsr ed_para1_to_cur
.a993		a9 80		lda #$80	                lda #%10000000
.a995		04 39		tsb $39		                tsb ed_flags
.a997		4c 35 ac	jmp $ac35	                jmp ed_cmd_p_from_external
.a99a						_have_unconverted_chars:
.a99a		20 69 86	jsr $8669	                jsr w_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a99d		ca		dex		                dex
.a99e		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a99f		a5 0e		lda $0e		                lda ciblen
.a9a1		95 00		sta $00,x	                sta 0,x
.a9a3		a5 0f		lda $0f		                lda ciblen+1
.a9a5		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a9a7		20 6a 87	jsr $876a	                jsr w_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a9aa		b5 00		lda $00,x	                lda 0,x
.a9ac		15 01		ora $01,x	                ora 1,x
.a9ae		f0 0e		beq $a9be	                beq _no_command_yet
.a9b0		8a		txa		                txa
.a9b1		18		clc		                clc
.a9b2		69 0a		adc #$0a	                adc #10
.a9b4		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a9b5		a9 80		lda #$80	                lda #%10000000
.a9b7		14 39		trb $39		                trb ed_flags
.a9b9		a0 00		ldy #$00	                ldy #00
.a9bb		4c 56 aa	jmp $aa56	                jmp _check_command
.a9be						_no_command_yet:
.a9be		e8		inx		                inx
.a9bf		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a9c0		20 60 93	jsr $9360	                jsr w_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a9c3		20 cd 9c	jsr $9ccd	                jsr w_not_rot          ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a9c6		20 92 9e	jsr $9e92	                jsr w_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a9c9		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a9cb		95 06		sta $06,x	                sta 6,x
.a9cd		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a9cf		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a9d1		e8		inx		                inx
.a9d2		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a9d3		20 cc 8e	jsr $8ecc	                jsr w_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a9d6		a9 80		lda #$80	                lda #%10000000
.a9d8		04 39		tsb $39		                tsb ed_flags
.a9da						_check_for_para2:
.a9da		a1 02		lda ($02,x)	                lda (2,x)
.a9dc		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a9de		f0 0d		beq $a9ed	                beq _got_comma
.a9e0		38		sec		                sec
.a9e1		a5 0e		lda $0e		                lda ciblen
.a9e3		f5 00		sbc $00,x	                sbc 0,x
.a9e5		a8		tay		                tay
.a9e6		e8		inx		                inx
.a9e7		e8		inx		                inx
.a9e8		e8		inx		                inx
.a9e9		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a9ea		4c 56 aa	jmp $aa56	                jmp _check_command
.a9ed						_got_comma:
.a9ed		f6 02		inc $02,x	                inc 2,x
.a9ef		d0 02		bne $a9f3	                bne +
.a9f1		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a9f3						+
.a9f3		b5 01		lda $01,x	                lda 1,x
.a9f5		f0 02		beq $a9f9	                beq +
.a9f7		d6 01		dec $01,x	                dec 1,x
.a9f9						+
.a9f9		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a9fb		a1 02		lda ($02,x)	                lda (2,x)
.a9fd		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a9ff		d0 14		bne $aa15	                bne _para2_not_dollar
.aa01		38		sec		                sec
.aa02		a5 0e		lda $0e		                lda ciblen
.aa04		f5 02		sbc $02,x	                sbc 2,x
.aa06		a8		tay		                tay
.aa07		c8		iny		                iny
.aa08		5a		phy		                phy
.aa09		8a		txa		                txa
.aa0a		18		clc		                clc
.aa0b		69 06		adc #$06	                adc #06
.aa0d		aa		tax		                tax                     ; ( addr-t u-t para1 )
.aa0e		20 aa ad	jsr $adaa	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.aa11		7a		ply		                ply
.aa12		4c 56 aa	jmp $aa56	                jmp _check_command
.aa15						_para2_not_dollar:
.aa15		20 60 93	jsr $9360	                jsr w_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.aa18		20 46 9e	jsr $9e46	                jsr w_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.aa1b		20 46 9e	jsr $9e46	                jsr w_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.aa1e		20 73 8f	jsr $8f73	                jsr w_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.aa21		20 cc 8e	jsr $8ecc	                jsr w_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.aa24		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.aa27		20 60 93	jsr $9360	                jsr w_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.aa2a		20 c3 92	jsr $92c3	                jsr w_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.aa2d		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.aa30		20 cc 8e	jsr $8ecc	                jsr w_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.aa33		20 6a 87	jsr $876a	                jsr w_equal            ; = ( ... para1 0 ud addr3 u3 f )
.aa36		b5 00		lda $00,x	                lda 0,x
.aa38		15 01		ora $01,x	                ora 1,x
.aa3a		f0 08		beq $aa44	                beq _second_number
.aa3c		8a		txa		                txa
.aa3d		18		clc		                clc
.aa3e		69 0c		adc #$0c	                adc #12
.aa40		aa		tax		                tax                     ; back to ( addr-t u-t )
.aa41		4c 5e ad	jmp $ad5e	                jmp ed_error
.aa44						_second_number:
.aa44		e8		inx		                inx
.aa45		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.aa46		38		sec		                sec
.aa47		a5 0e		lda $0e		                lda ciblen
.aa49		f5 00		sbc $00,x	                sbc 0,x
.aa4b		48		pha		                pha
.aa4c		20 9e 93	jsr $939e	                jsr w_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.aa4f		20 92 9e	jsr $9e92	                jsr w_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.aa52		20 13 8c	jsr $8c13	                jsr w_nip              ; NIP ( addr-t u-t para1 para2 )
.aa55		7a		ply		                ply
.aa56						_check_command:
.aa56		24 39		bit $39		                bit ed_flags
.aa58		30 08		bmi $aa62	                bmi _check_command_have_arg
.aa5a		a5 37		lda $37		                lda ed_cur
.aa5c		95 02		sta $02,x	                sta 2,x
.aa5e		a5 38		lda $38		                lda ed_cur+1
.aa60		95 03		sta $03,x	                sta 3,x
.aa62						_check_command_have_arg:
.aa62		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.aa64		85 25		sta $25		                sta tmp1
.aa66		da		phx		                phx
.aa67		a2 00		ldx #$00	                ldx #00
.aa69						_cmd_loop:
.aa69		bd 42 ae	lda $ae42,x	                lda ed_cmd_list,x
.aa6c		f0 07		beq $aa75	                beq _illegal_command    ; zero marks end of list
.aa6e		c5 25		cmp $25		                cmp tmp1
.aa70		f0 07		beq $aa79	                beq _found_cmd
.aa72		e8		inx		                inx
.aa73		80 f4		bra $aa69	                bra _cmd_loop
.aa75						_illegal_command:
.aa75		fa		plx		                plx
.aa76		4c 5a ad	jmp $ad5a	                jmp ed_error_2drop
.aa79						_found_cmd:
.aa79		8a		txa		                txa
.aa7a		0a		asl a		                asl
.aa7b		aa		tax		                tax                     ; X * 2 for table
.aa7c		7c 4d ae	jmp ($ae4d,x)	                jmp (ed_cmd_table,x)
.aa7f						ed_next_command:
.aa7f		e8		inx		                inx
.aa80		e8		inx		                inx
.aa81		e8		inx		                inx
.aa82		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.aa83		4c 8d a8	jmp $a88d	                jmp ed_input_loop
.aa86						ed_all_done:
.aa86		64 0e		stz $0e		                stz ciblen
.aa88		64 0f		stz $0f		                stz ciblen+1
.aa8a		20 9e 93	jsr $939e	                jsr w_two_drop                 ; 2DROP ( addr-t u-t )
.aa8d		a5 3a		lda $3a		                lda ed_base
.aa8f		85 18		sta $18		                sta base
.aa91		60		rts		                rts
.aa92						ed_cmd_a:
.aa92		fa		plx		                plx
.aa93		e8		inx		                inx
.aa94		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.aa95						ed_entry_cmd_i:
.aa95		20 e0 ad	jsr $ade0	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.aa98		20 05 84	jsr $8405	                jsr w_cr
.aa9b						_next_string_loop:
.aa9b		20 6c ad	jsr $ad6c	                jsr ed_get_input
.aa9e		b2 0c		lda ($0c)	                lda (cib)
.aaa0		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.aaa2		d0 16		bne $aaba	                bne _add_line
.aaa4		a4 0e		ldy $0e		                ldy ciblen
.aaa6		c0 01		cpy #$01	                cpy #01
.aaa8		d0 10		bne $aaba	                bne _add_line
.aaaa		a4 0f		ldy $0f		                ldy ciblen+1
.aaac		d0 0c		bne $aaba	                bne _add_line
.aaae		e8		inx		                inx
.aaaf		e8		inx		                inx
.aab0		a9 40		lda #$40	                lda #%01000000
.aab2		04 39		tsb $39		                tsb ed_flags
.aab4		20 05 84	jsr $8405	                jsr w_cr
.aab7		4c 8d a8	jmp $a88d	                jmp ed_input_loop
.aaba						_add_line:
.aaba		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( addr-t u-t addr1 addr1 )
.aabd		20 f4 88	jsr $88f4	                jsr w_here             ; HERE ( addr-t u-t addr1 addr1 here )
.aac0		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.aac3		20 f6 87	jsr $87f6	                jsr w_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.aac6		20 ae 83	jsr $83ae	                jsr w_comma            ; ,  ( addr-t u-t addr1 here )
.aac9		20 84 93	jsr $9384	                jsr w_tuck             ; TUCK ( addr-t u-t here addr1 here )
.aacc		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( addr-t u-t here here addr1 )
.aacf		20 0f 92	jsr $920f	                jsr w_store            ; ! ( addr-t u-t here )
.aad2		20 f4 88	jsr $88f4	                jsr w_here             ; HERE ( addr-t u-t here here2)
.aad5		a5 00		lda $00		                lda cp
.aad7		18		clc		                clc
.aad8		69 04		adc #$04	                adc #04
.aada		85 00		sta $00		                sta cp
.aadc		90 02		bcc $aae0	                bcc +
.aade		e6 01		inc $01		                inc cp+1
.aae0						+
.aae0		e6 37		inc $37		                inc ed_cur
.aae2		d0 02		bne $aae6	                bne +
.aae4		e6 38		inc $38		                inc ed_cur+1
.aae6						+
.aae6		20 f4 88	jsr $88f4	                jsr w_here     ; HERE ( addr-t u-t here here2 here3 )
.aae9		20 69 86	jsr $8669	                jsr w_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.aaec		ca		dex		                dex
.aaed		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.aaee		a5 0c		lda $0c		                lda cib
.aaf0		95 00		sta $00,x	                sta 0,x
.aaf2		a5 0d		lda $0d		                lda cib+1
.aaf4		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.aaf6		20 25 92	jsr $9225	                jsr w_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.aaf9		ca		dex		                dex
.aafa		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aafb		a5 0e		lda $0e		                lda ciblen
.aafd		95 00		sta $00,x	                sta 0,x
.aaff		a5 0f		lda $0f		                lda ciblen+1
.ab01		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.ab03		20 e0 8b	jsr $8be0	                jsr w_move     ; ( addr-t u-t here here2 here3 )
.ab06		18		clc		                clc
.ab07		a5 00		lda $00		                lda cp
.ab09		65 0e		adc $0e		                adc ciblen
.ab0b		85 00		sta $00		                sta cp
.ab0d		90 06		bcc $ab15	                bcc +
.ab0f		a5 01		lda $01		                lda cp+1
.ab11		65 0f		adc $0f		                adc ciblen+1
.ab13		85 01		sta $01		                sta cp+1
.ab15						+
.ab15		20 e4 8c	jsr $8ce4	                jsr w_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.ab18		20 0f 92	jsr $920f	                jsr w_store            ; ! ( addr-t u-t here here2 )
.ab1b		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+
.ab1e		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.ab21		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.ab24		a5 0e		lda $0e		                lda ciblen
.ab26		95 02		sta $02,x	                sta 2,x
.ab28		a5 0f		lda $0f		                lda ciblen+1
.ab2a		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.ab2c		20 0f 92	jsr $920f	                jsr w_store            ; ! ( addr-t u-t here )
.ab2f		20 05 84	jsr $8405	                jsr w_cr
.ab32		4c 9b aa	jmp $aa9b	                jmp _next_string_loop
.ab35						ed_cmd_d:
.ab35		fa		plx		                plx
.ab36		20 7d ad	jsr $ad7d	                jsr ed_have_text
.ab39		20 d2 ad	jsr $add2	                jsr ed_no_line_zero
.ab3c		b5 00		lda $00,x	                lda 0,x
.ab3e		15 01		ora $01,x	                ora 1,x
.ab40		d0 08		bne $ab4a	                bne +
.ab42		20 e4 8c	jsr $8ce4	                jsr w_over             ; ( addr-t u-t para1 0 para1 )
.ab45		20 87 ab	jsr $ab87	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.ab48		80 33		bra $ab7d	                bra _cmd_d_done
.ab4a						+
.ab4a		20 88 ad	jsr $ad88	                jsr ed_is_valid_line      ; result is in C flag
.ab4d		b0 03		bcs $ab52	                bcs _cmd_d_loop
.ab4f		4c 5a ad	jmp $ad5a	                jmp ed_error_2drop
.ab52						_cmd_d_loop:
.ab52		20 a6 93	jsr $93a6	                jsr w_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab55		20 e2 88	jsr $88e2	                jsr w_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab58		b5 00		lda $00,x	                lda 0,x
.ab5a		15 01		ora $01,x	                ora 1,x
.ab5c		d0 0d		bne $ab6b	                bne _cmd_d_done_with_flag
.ab5e		e8		inx		                inx
.ab5f		e8		inx		                inx                     ; Get rid of the flag from >
.ab60		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.ab63		20 87 ab	jsr $ab87	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.ab66		20 bc 8c	jsr $8cbc	                jsr w_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.ab69		80 e7		bra $ab52	                bra _cmd_d_loop
.ab6b						_cmd_d_done_with_flag:
.ab6b		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.ab6c		e8		inx		                inx
.ab6d		b5 02		lda $02,x	                lda 2,x
.ab6f		d0 02		bne $ab73	                bne +
.ab71		d6 03		dec $03,x	                dec 3,x
.ab73						+
.ab73		d6 02		dec $02,x	                dec 2,x
.ab75		b5 02		lda $02,x	                lda 2,x
.ab77		85 37		sta $37		                sta ed_cur
.ab79		b5 03		lda $03,x	                lda 3,x
.ab7b		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.ab7d						_cmd_d_done:
.ab7d		a9 40		lda #$40	                lda #%01000000
.ab7f		04 39		tsb $39		                tsb ed_flags
.ab81		20 05 84	jsr $8405	                jsr w_cr
.ab84		4c 7f aa	jmp $aa7f	                jmp ed_next_command
.ab87						_cmd_d_common:
.ab87		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( addr-t u-t u u )
.ab8a		20 e0 ad	jsr $ade0	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.ab8d		20 f6 87	jsr $87f6	                jsr w_fetch            ; @ ( addr-t u-t u addr1 )
.ab90		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( addr-t u-t addr1 u )
.ab93		20 bc 8c	jsr $8cbc	                jsr w_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.ab96		20 e0 ad	jsr $ade0	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.ab99		20 0f 92	jsr $920f	                jsr w_store            ; ! ( addr-t u-t )
.ab9c		60		rts		                rts
.ab9d						ed_cmd_equ:
.ab9d		fa		plx		                plx
.ab9e		a5 35		lda $35		                lda ed_head
.aba0		05 36		ora $36		                ora ed_head+1
.aba2		d0 08		bne $abac	                bne _cmd_equ_have_text
.aba4		ca		dex		                dex
.aba5		ca		dex		                dex
.aba6		74 00		stz $00,x	                stz 0,x
.aba8		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.abaa		80 21		bra $abcd	                bra _cmd_equ_done
.abac						_cmd_equ_have_text:
.abac		20 d2 ad	jsr $add2	                jsr ed_no_line_zero
.abaf		24 39		bit $39		                bit ed_flags
.abb1		30 0c		bmi $abbf	                bmi _cmd_equ_have_para
.abb3		ca		dex		                dex
.abb4		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.abb5		a5 37		lda $37		                lda ed_cur
.abb7		95 00		sta $00,x	                sta 0,x
.abb9		a5 38		lda $38		                lda ed_cur+1
.abbb		95 01		sta $01,x	                sta 1,x
.abbd		80 0e		bra $abcd	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.abbf						_cmd_equ_have_para:
.abbf		b5 00		lda $00,x	                lda 0,x
.abc1		15 01		ora $01,x	                ora 1,x
.abc3		d0 05		bne $abca	                bne _cmd_equ_two_paras
.abc5		20 e4 8c	jsr $8ce4	                jsr w_over             ; ( addr-t u-t para1 para2 para1)
.abc8		80 03		bra $abcd	                bra _cmd_equ_done
.abca						_cmd_equ_two_paras:
.abca		20 69 86	jsr $8669	                jsr w_dup              ; ( addr-t u-t para1 para2 para2) drop through
.abcd						_cmd_equ_done:
.abcd		20 05 84	jsr $8405	                jsr w_cr               ; number goes on new line
.abd0		20 e6 94	jsr $94e6	                jsr w_u_dot            ; ( addr-t u-t para1 para2 )
.abd3		20 05 84	jsr $8405	                jsr w_cr
.abd6		4c 7f aa	jmp $aa7f	                jmp ed_next_command
.abd9						ed_cmd_f:
.abd9		fa		plx		                plx
.abda		24 39		bit $39		                bit ed_flags
.abdc		30 17		bmi $abf5	                bmi _cmd_f_have_para
.abde		20 05 84	jsr $8405	                jsr w_cr
.abe1		20 60 93	jsr $9360	                jsr w_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.abe4		20 73 8f	jsr $8f73	                jsr w_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.abe7		20 69 86	jsr $8669	                jsr w_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.abea		20 e6 94	jsr $94e6	                jsr w_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.abed		20 cd 9c	jsr $9ccd	                jsr w_not_rot          ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.abf0		20 cc 8e	jsr $8ecc	                jsr w_r_from           ; R>   ( addr-t u-t 0 0 )
.abf3		80 11		bra $ac06	                bra _cmd_f_done
.abf5						_cmd_f_have_para:
.abf5		20 e4 8c	jsr $8ce4	                jsr w_over
.abf8		20 05 84	jsr $8405	                jsr w_cr
.abfb		20 e6 94	jsr $94e6	                jsr w_u_dot
.abfe		b5 02		lda $02,x	                lda 2,x
.ac00		95 06		sta $06,x	                sta 6,x
.ac02		b5 03		lda $03,x	                lda 3,x
.ac04		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.ac06						_cmd_f_done:
.ac06		20 05 84	jsr $8405	                jsr w_cr
.ac09		4c 7f aa	jmp $aa7f	                jmp ed_next_command
.ac0c						ed_cmd_i:
.ac0c		fa		plx		                plx
.ac0d		e8		inx		                inx
.ac0e		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.ac0f		24 39		bit $39		                bit ed_flags
.ac11		30 08		bmi $ac1b	                bmi _cmd_i_have_para
.ac13		a5 37		lda $37		                lda ed_cur
.ac15		95 00		sta $00,x	                sta 0,x
.ac17		a5 38		lda $38		                lda ed_cur+1
.ac19		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.ac1b						_cmd_i_have_para:
.ac1b		b5 00		lda $00,x	                lda 0,x
.ac1d		15 01		ora $01,x	                ora 1,x
.ac1f		f0 09		beq $ac2a	                beq _cmd_i_done
.ac21		20 bc 8c	jsr $8cbc	                jsr w_one_minus        ; 1-  ( addr-t u-t para1-1 )
.ac24		20 46 9e	jsr $9e46	                jsr w_zero             ; 0   ( addr-t u-t para1-1 0 )
.ac27		20 8c 8b	jsr $8b8c	                jsr w_max              ; MAX ( addr-t u-t para1-1 | 0 )
.ac2a						_cmd_i_done:
.ac2a		4c 95 aa	jmp $aa95	                jmp ed_entry_cmd_i
.ac2d						ed_cmd_n:
.ac2d		fa		plx		                plx
.ac2e		a9 01		lda #$01	                lda #%00000001
.ac30		04 39		tsb $39		                tsb ed_flags
.ac32		80 05		bra $ac39	                bra ed_cmd_p_entry_for_cmd_n
.ac34						ed_cmd_p:
.ac34		fa		plx		                plx
.ac35						ed_cmd_p_from_external:
.ac35		a9 01		lda #$01	                lda #%00000001
.ac37		14 39		trb $39		                trb ed_flags
.ac39						ed_cmd_p_entry_for_cmd_n:
.ac39		20 7d ad	jsr $ad7d	                jsr ed_have_text
.ac3c		20 d2 ad	jsr $add2	                jsr ed_no_line_zero
.ac3f		20 05 84	jsr $8405	                jsr w_cr
.ac42		b5 00		lda $00,x	                lda 0,x
.ac44		15 01		ora $01,x	                ora 1,x
.ac46		d0 10		bne $ac58	                bne _cmd_p_loop
.ac48		b5 02		lda $02,x	                lda 2,x
.ac4a		85 37		sta $37		                sta ed_cur
.ac4c		b5 03		lda $03,x	                lda 3,x
.ac4e		85 38		sta $38		                sta ed_cur+1
.ac50		20 e4 8c	jsr $8ce4	                jsr w_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ac53		20 81 ac	jsr $ac81	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac56		80 26		bra $ac7e	                bra _cmd_p_all_done
.ac58						_cmd_p_loop:
.ac58		20 a6 93	jsr $93a6	                jsr w_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ac5b		20 e2 88	jsr $88e2	                jsr w_greater_than     ; > ( addr-t u-t para1 para2 f )
.ac5e		b5 00		lda $00,x	                lda 0,x
.ac60		15 01		ora $01,x	                ora 1,x
.ac62		d0 10		bne $ac74	                bne _cmd_p_done
.ac64		e8		inx		                inx
.ac65		e8		inx		                inx                     ; Get rid of the flag from >
.ac66		20 e4 8c	jsr $8ce4	                jsr w_over             ; ( addr-t u-t para1 para2 para1 )
.ac69		20 81 ac	jsr $ac81	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac6c		f6 02		inc $02,x	                inc 2,x
.ac6e		d0 02		bne $ac72	                bne +
.ac70		f6 03		inc $03,x	                inc 3,x
.ac72						+
.ac72		80 e4		bra $ac58	                bra _cmd_p_loop
.ac74						_cmd_p_done:
.ac74		e8		inx		                inx
.ac75		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.ac76		b5 00		lda $00,x	                lda 0,x
.ac78		85 37		sta $37		                sta ed_cur
.ac7a		b5 01		lda $01,x	                lda 1,x
.ac7c		85 38		sta $38		                sta ed_cur+1
.ac7e						_cmd_p_all_done:
.ac7e		4c 7f aa	jmp $aa7f	                jmp ed_next_command
.ac81						_cmd_p_common:
.ac81		a5 39		lda $39		                lda ed_flags
.ac83		4a		lsr a		                lsr                     ; bit 0 now in carry
.ac84		90 0b		bcc $ac91	                bcc _cmd_p_common_no_num
.ac86		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( addr-t u-t para1 para1 )
.ac89		20 e6 94	jsr $94e6	                jsr w_u_dot            ; U. ( addr-t u-t para1 )
.ac8c		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.ac8e		20 93 86	jsr $8693	                jsr emit_a
.ac91						_cmd_p_common_no_num:
.ac91		20 e0 ad	jsr $ade0	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.ac94		20 20 ae	jsr $ae20	                jsr ed_print_addr
.ac97		60		rts		                rts
.ac98						ed_cmd_q:
.ac98		fa		plx		                plx
.ac99		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.ac9b		50 03		bvc $aca0	                bvc +
.ac9d		4c 5a ad	jmp $ad5a	                jmp ed_error_2drop
.aca0						+
.aca0		4c 86 aa	jmp $aa86	                jmp ed_all_done            ; can't fall thru because of PLX
.aca3						ed_cmd_qq:
.aca3		fa		plx		                plx
.aca4		4c 86 aa	jmp $aa86	                jmp ed_all_done
.aca7						ed_cmd_w:
.aca7		fa		plx		                plx
.aca8		20 7d ad	jsr $ad7d	                jsr ed_have_text
.acab		24 39		bit $39		                bit ed_flags
.acad		30 13		bmi $acc2	                bmi _cmd_w_have_para
.acaf		b5 06		lda $06,x	                lda 6,x
.acb1		15 07		ora $07,x	                ora 7,x
.acb3		d0 03		bne $acb8	                bne +
.acb5		4c 5a ad	jmp $ad5a	                jmp ed_error_2drop
.acb8						+
.acb8		b5 06		lda $06,x	                lda 6,x
.acba		95 02		sta $02,x	                sta 2,x
.acbc		b5 07		lda $07,x	                lda 7,x
.acbe		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.acc0		80 08		bra $acca	                bra _cmd_w_para_ready
.acc2						_cmd_w_have_para:
.acc2		b5 02		lda $02,x	                lda 2,x
.acc4		95 06		sta $06,x	                sta 6,x
.acc6		b5 03		lda $03,x	                lda 3,x
.acc8		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.acca						_cmd_w_para_ready:
.acca		a9 35		lda #$35	                lda #<ed_head
.accc		95 00		sta $00,x	                sta 0,x
.acce		a9 00		lda #$00	                lda #>ed_head
.acd0		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.acd2		20 e4 8c	jsr $8ce4	                jsr w_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.acd5		20 60 93	jsr $9360	                jsr w_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.acd8						_cmd_w_loop:
.acd8		20 f6 87	jsr $87f6	                jsr w_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.acdb		b5 00		lda $00,x	                lda 0,x
.acdd		15 01		ora $01,x	                ora 1,x
.acdf		f0 55		beq $ad36	                beq _cmd_w_eol
.ace1		20 a6 93	jsr $93a6	                jsr w_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ace4		20 98 94	jsr $9498	                jsr w_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ace7		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.acea		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.aced		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.acf0		20 f6 87	jsr $87f6	                jsr w_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.acf3		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.acf6		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.acf9		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.acfc		20 f6 87	jsr $87f6	                jsr w_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.acff		20 cd 9c	jsr $9ccd	                jsr w_not_rot          ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ad02		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ad05		20 73 8f	jsr $8f73	                jsr w_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ad08		20 69 86	jsr $8669	                jsr w_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ad0b		20 60 93	jsr $9360	                jsr w_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ad0e		20 e0 8b	jsr $8be0	                jsr w_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ad11		20 cc 8e	jsr $8ecc	                jsr w_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ad14		20 1e 94	jsr $941e	                jsr w_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ad17		20 cd 9c	jsr $9ccd	                jsr w_not_rot          ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ad1a		20 32 8e	jsr $8e32	                jsr w_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ad1d		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ad20		ca		dex		                dex
.ad21		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ad22		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ad24		95 00		sta $00,x	                sta 0,x
.ad26		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ad28		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ad2b		20 0f 92	jsr $920f	                jsr w_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ad2e		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ad31		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ad34		80 a2		bra $acd8	                bra _cmd_w_loop
.ad36						_cmd_w_eol:
.ad36		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ad39		20 cc 8e	jsr $8ecc	                jsr w_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ad3c		20 c4 8b	jsr $8bc4	                jsr w_minus            ; - ( addr-t u-t addr-n u )
.ad3f		b5 00		lda $00,x	                lda 0,x
.ad41		95 04		sta $04,x	                sta 4,x
.ad43		b5 01		lda $01,x	                lda 1,x
.ad45		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ad47		20 05 84	jsr $8405	                jsr w_cr
.ad4a		20 69 86	jsr $8669	                jsr w_dup              ; DUP ( addr-t u addr-n u u )
.ad4d		20 e6 94	jsr $94e6	                jsr w_u_dot            ; U. ( addr-t u addr-n u )
.ad50		20 05 84	jsr $8405	                jsr w_cr
.ad53		a9 40		lda #$40	                lda #%01000000
.ad55		14 39		trb $39		                trb ed_flags
.ad57		4c 7f aa	jmp $aa7f	                jmp ed_next_command
.ad5a						ed_error_2drop:
.ad5a		e8		inx		                inx
.ad5b		e8		inx		                inx                     ; drop through to _error_1drop
.ad5c						ed_error_1drop:
.ad5c		e8		inx		                inx
.ad5d		e8		inx		                inx                     ; drop through to _error
.ad5e						ed_error:
.ad5e		20 05 84	jsr $8405	                jsr w_cr
.ad61		a9 3f		lda #$3f	                lda #'?'
.ad63		20 93 86	jsr $8693	                jsr emit_a
.ad66		20 05 84	jsr $8405	                jsr w_cr
.ad69		4c 8d a8	jmp $a88d	                jmp ed_input_loop
.ad6c						ed_get_input:
.ad6c		20 1e 8f	jsr $8f1e	                jsr w_refill           ;  ( addr-t u-t f )
.ad6f		b5 00		lda $00,x	                lda 0,x
.ad71		15 01		ora $01,x	                ora 1,x
.ad73		d0 05		bne $ad7a	                bne +
.ad75		7a		ply		                ply
.ad76		7a		ply		                ply
.ad77		4c 5c ad	jmp $ad5c	                jmp ed_error_1drop
.ad7a						+
.ad7a		e8		inx		                inx
.ad7b		e8		inx		                inx
.ad7c		60		rts		                rts
.ad7d						ed_have_text:
.ad7d		a5 35		lda $35		                lda ed_head
.ad7f		05 36		ora $36		                ora ed_head+1
.ad81		d0 04		bne $ad87	                bne +
.ad83		7a		ply		                ply
.ad84		7a		ply		                ply
.ad85		80 d7		bra $ad5e	                bra ed_error
.ad87						+
.ad87		60		rts		                rts
.ad88						ed_is_valid_line:
.ad88		38		sec		                sec                             ; default is legal line number
.ad89		b5 00		lda $00,x	                lda 0,x
.ad8b		15 01		ora $01,x	                ora 1,x
.ad8d		f0 19		beq $ada8	                beq _is_valid_line_nope_zero    ; ( n )
.ad8f		20 69 86	jsr $8669	                jsr w_dup                      ; DUP ( n n )
.ad92		20 aa ad	jsr $adaa	                jsr ed_last_line                  ; ( n n last )
.ad95		20 25 92	jsr $9225	                jsr w_swap                     ; SWAP ( n last n )
.ad98		20 cb 89	jsr $89cb	                jsr w_less_than                ; < ( n f )
.ad9b		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ad9d		15 01		ora $01,x	                ora 1,x
.ad9f		d0 05		bne $ada6	                bne _is_valid_line_too_small
.ada1		e8		inx		                inx
.ada2		e8		inx		                inx                     ; DROP flag ( n )
.ada3		38		sec		                sec                     ; Who knows what's happened to C by now
.ada4		80 03		bra $ada9	                bra _is_valid_line_done ; only one exit from this routine
.ada6						_is_valid_line_too_small:
.ada6		e8		inx		                inx
.ada7		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ada8						_is_valid_line_nope_zero:
.ada8		18		clc		                clc                     ; drop through to _is_valid_line_done
.ada9						_is_valid_line_done:
.ada9		60		rts		                rts
.adaa						ed_last_line:
.adaa		64 25		stz $25		                stz tmp1
.adac		64 26		stz $26		                stz tmp1+1
.adae		ca		dex		                dex
.adaf		ca		dex		                dex                     ; ( ? )
.adb0		a9 35		lda #$35	                lda #<ed_head
.adb2		95 00		sta $00,x	                sta 0,x
.adb4		a9 00		lda #$00	                lda #>ed_head
.adb6		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.adb8						_last_line_loop:
.adb8		20 f6 87	jsr $87f6	                jsr w_fetch            ; ( addr | 0 )
.adbb		b5 00		lda $00,x	                lda 0,x
.adbd		15 01		ora $01,x	                ora 1,x
.adbf		f0 08		beq $adc9	                beq _last_line_done
.adc1		e6 25		inc $25		                inc tmp1
.adc3		d0 02		bne $adc7	                bne +
.adc5		e6 26		inc $26		                inc tmp1+1
.adc7						+
.adc7		80 ef		bra $adb8	                bra _last_line_loop
.adc9						_last_line_done:
.adc9		a5 25		lda $25		                lda tmp1
.adcb		95 00		sta $00,x	                sta 0,x
.adcd		a5 26		lda $26		                lda tmp1+1
.adcf		95 01		sta $01,x	                sta 1,x                 ; ( u )
.add1		60		rts		                rts
.add2						ed_no_line_zero:
.add2		b5 02		lda $02,x	                lda 2,x
.add4		15 03		ora $03,x	                ora 3,x
.add6		d0 07		bne $addf	                bne _no_line_zero_done
.add8		24 39		bit $39		                bit ed_flags
.adda		10 03		bpl $addf	                bpl _no_line_zero_done
.addc		4c 5a ad	jmp $ad5a	                jmp ed_error_2drop
.addf						_no_line_zero_done:
.addf		60		rts		                rts
.ade0						ed_num_to_addr:
.ade0		ca		dex		                dex
.ade1		ca		dex		                dex                     ; ( u ? )
.ade2		a9 35		lda #$35	                lda #<ed_head
.ade4		95 00		sta $00,x	                sta 0,x
.ade6		a9 00		lda #$00	                lda #>ed_head
.ade8		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.adea		b5 02		lda $02,x	                lda 2,x
.adec		15 03		ora $03,x	                ora 3,x
.adee		d0 05		bne $adf5	                bne _num_to_addr_loop
.adf0		20 13 8c	jsr $8c13	                jsr w_nip              ; ( addr-h )
.adf3		80 21		bra $ae16	                bra _num_to_addr_done
.adf5						_num_to_addr_loop:
.adf5		20 f6 87	jsr $87f6	                jsr w_fetch            ; @ ( u addr1 )
.adf8		b5 00		lda $00,x	                lda 0,x
.adfa		15 01		ora $01,x	                ora 1,x
.adfc		d0 05		bne $ae03	                bne +
.adfe		20 13 8c	jsr $8c13	                jsr w_nip              ; NIP ( addr1 )
.ae01		80 13		bra $ae16	                bra _num_to_addr_done
.ae03						+
.ae03		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( addr1 u )
.ae06		20 bc 8c	jsr $8cbc	                jsr w_one_minus        ; 1- ( addr1 u-1 )
.ae09		b5 00		lda $00,x	                lda 0,x
.ae0b		15 01		ora $01,x	                ora 1,x
.ae0d		f0 05		beq $ae14	                beq _num_to_addr_finished
.ae0f		20 25 92	jsr $9225	                jsr w_swap             ; SWAP ( u-1 addr1 )
.ae12		80 e1		bra $adf5	                bra _num_to_addr_loop
.ae14						_num_to_addr_finished:
.ae14		e8		inx		                inx
.ae15		e8		inx		                inx                     ; ( addr )
.ae16						_num_to_addr_done:
.ae16		60		rts		                rts
.ae17						ed_para1_to_cur:
.ae17		b5 02		lda $02,x	                lda 2,x
.ae19		85 37		sta $37		                sta ed_cur
.ae1b		b5 03		lda $03,x	                lda 3,x
.ae1d		85 38		sta $38		                sta ed_cur+1
.ae1f		60		rts		                rts
.ae20						ed_print_addr:
.ae20		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.ae23		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; ( addr+2 )
.ae26		20 69 86	jsr $8669	                jsr w_dup              ; ( addr+2 addr+2 )
.ae29		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.ae2c		20 c8 8c	jsr $8cc8	                jsr w_one_plus         ; ( addr+2 addr+4 )
.ae2f		20 f6 87	jsr $87f6	                jsr w_fetch            ; ( addr+2 u-s )
.ae32		20 25 92	jsr $9225	                jsr w_swap             ; ( u-s addr+2 )
.ae35		20 f6 87	jsr $87f6	                jsr w_fetch            ; ( u-s addr-s )
.ae38		20 25 92	jsr $9225	                jsr w_swap             ; ( addr-s u-s )
.ae3b		20 bb 94	jsr $94bb	                jsr w_type
.ae3e		20 05 84	jsr $8405	                jsr w_cr
.ae41		60		rts		                rts
>ae42		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ae4a		71 51 00
.ae4d						ed_cmd_table:
>ae4d		92 aa d9 ab 0c ac 35 ab		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ae55		34 ac 2d ac
>ae59		9d ab a7 ac 98 ac a3 ac		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ae61						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ae61						xt_blk:
.ae61						w_blk:
.ae61		a9 04		lda #$04	                lda #blk_offset
.ae63		4c 45 d7	jmp $d745	                jmp push_upvar_tos
.ae66						z_blk:
.ae66						xt_blkbuffer:
.ae66						w_blkbuffer:
.ae66		ca		dex		                dex
.ae67		ca		dex		                dex
.ae68		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ae6a		b1 08		lda ($08),y	                lda (up),y
.ae6c		95 00		sta $00,x	                sta 0,x
.ae6e		c8		iny		                iny             ; Move along to the next byte
.ae6f		b1 08		lda ($08),y	                lda (up),y
.ae71		95 01		sta $01,x	                sta 1,x
.ae73		60		rts		z_blkbuffer:    rts
.ae74						xt_block:
.ae74						w_block:
.ae74		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae76		b1 08		lda ($08),y	                lda (up),y
.ae78		d5 00		cmp $00,x	                cmp 0,x
.ae7a		d0 0f		bne $ae8b	                bne _not_in_buffer
.ae7c		c8		iny		                iny
.ae7d		b1 08		lda ($08),y	                lda (up),y
.ae7f		d5 01		cmp $01,x	                cmp 1,x
.ae81		d0 08		bne $ae8b	                bne _not_in_buffer
.ae83		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae85		b1 08		lda ($08),y	                lda (up),y
.ae87		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ae89		d0 30		bne $aebb	                bne _done       ; It's already in the buffer and in use.
.ae8b						_not_in_buffer:
.ae8b		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae8d		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ae8f		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ae91		d0 0c		bne $ae9f	                bne _buffer_available ; Unused or not dirty = available
.ae93		20 66 ae	jsr $ae66	                jsr w_blkbuffer
.ae96		20 70 b0	jsr $b070	                jsr w_buffblocknum
.ae99		20 f6 87	jsr $87f6	                jsr w_fetch
.ae9c		20 5d b0	jsr $b05d	                jsr w_block_write
.ae9f						_buffer_available:
.ae9f		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.aea1		b5 00		lda $00,x	                lda 0,x
.aea3		91 08		sta ($08),y	                sta (up),y
.aea5		c8		iny		                iny
.aea6		b5 01		lda $01,x	                lda 1,x
.aea8		91 08		sta ($08),y	                sta (up),y
.aeaa		20 66 ae	jsr $ae66	                jsr w_blkbuffer
.aead		20 25 92	jsr $9225	                jsr w_swap
.aeb0		20 45 b0	jsr $b045	                jsr w_block_read
.aeb3		a9 01		lda #$01	                lda #1
.aeb5		a0 30		ldy #$30	                ldy #buffstatus_offset
.aeb7		91 08		sta ($08),y	                sta (up),y
.aeb9		ca		dex		                dex
.aeba		ca		dex		                dex
.aebb						_done:
.aebb		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.aebd		b1 08		lda ($08),y	                lda (up),y
.aebf		95 00		sta $00,x	                sta 0,x
.aec1		c8		iny		                iny
.aec2		b1 08		lda ($08),y	                lda (up),y
.aec4		95 01		sta $01,x	                sta 1,x
.aec6		60		rts		z_block:        rts
=0						io_blk_status = 0
=0						io_blk_action = 0
=0						io_blk_number = 0
=0						io_blk_buffer = 0
.aec7						xt_block_c65_init:
.aec7						w_block_c65_init:
.aec7		a9 ff		lda #$ff	                lda #$ff
.aec9		8d 10 f0	sta $f010	                sta io_blk_status
.aecc		a9 00		lda #$00	                lda #$0
.aece		8d 0f f0	sta $f00f	                sta io_blk_action
.aed1		ad 10 f0	lda $f010	                lda io_blk_status      ; $0 if OK, $ff otherwise
.aed4		49 ff		eor #$ff	                eor #$ff            ; invert to forth true/false
.aed6		ca		dex		                dex
.aed7		ca		dex		                dex
.aed8		95 00		sta $00,x	                sta 0,x             ; true ($ff) if OK, false (0) otherwise
.aeda		95 01		sta $01,x	                sta 1,x
.aedc		ca		dex		                dex
.aedd		ca		dex		                dex
.aede		a9 01		lda #$01	                lda #<c65_blk_read
.aee0		95 00		sta $00,x	                sta 0,x
.aee2		a9 af		lda #$af	                lda #>c65_blk_read
.aee4		95 01		sta $01,x	                sta 1,x
.aee6		20 53 b0	jsr $b053	                jsr w_block_read_vector
.aee9		20 0f 92	jsr $920f	                jsr w_store
.aeec		ca		dex		                dex
.aeed		ca		dex		                dex
.aeee		a9 fd		lda #$fd	                lda #<c65_blk_write
.aef0		95 00		sta $00,x	                sta 0,x
.aef2		a9 ae		lda #$ae	                lda #>c65_blk_write
.aef4		95 01		sta $01,x	                sta 1,x
.aef6		20 6b b0	jsr $b06b	                jsr w_block_write_vector
.aef9		20 0f 92	jsr $920f	                jsr w_store
.aefc						z_block_c65_init:
.aefc		60		rts		                rts
.aefd		a0 02		ldy #$02	c65_blk_write:  ldy #2
.aeff		80 02		bra $af03	                bra c65_blk_rw
.af01		a0 01		ldy #$01	c65_blk_read:   ldy #1
.af03		b5 00		lda $00,x	c65_blk_rw:     lda 0,x                 ; ( addr blk# )
.af05		8d 11 f0	sta $f011	                sta io_blk_number
.af08		b5 01		lda $01,x	                lda 1,x
.af0a		8d 12 f0	sta $f012	                sta io_blk_number+1
.af0d		b5 02		lda $02,x	                lda 2,x
.af0f		8d 13 f0	sta $f013	                sta io_blk_buffer
.af12		b5 03		lda $03,x	                lda 3,x
.af14		8d 14 f0	sta $f014	                sta io_blk_buffer+1
.af17		8c 0f f0	sty $f00f	                sty io_blk_action       ; trigger the r/w
.af1a		e8		inx		                inx                     ; clean up stack
.af1b		e8		inx		                inx
.af1c		e8		inx		                inx
.af1d		e8		inx		                inx
.af1e		60		rts		                rts
.af1f						xt_block_ramdrive_init:
.af1f		20 89 d8	jsr $d889	                jsr underflow_1
.af22						w_block_ramdrive_init:
.af22		20 32 a2	jsr $a232	                jsr sliteral_runtime
>af25		2d af 18 01			                .word ramdrive_code, ramdrive_code_end-ramdrive_code
.af29		20 8e 88	jsr $888e	                jsr w_evaluate
.af2c						z_block_ramdrive_init:
.af2c		60		rts		                rts
.af2d						ramdrive_code:
>af2d		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>af35		77 61 70 20 64 65 63 69 6d 61 6c
>af40		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>af47		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>af4b		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>af53		20 72 61 6d 64 72 69 76 65
>af5c		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>af64		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>af72		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>af7a		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af8a		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>af9a		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>afa2		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>afb1		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>afb9		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>afc9		31 30 32 34 20 6d 6f 76 65 20 3b
>afd4		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>afdc		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>afec		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>affc		20 21
>affe		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>b006		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>b016		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>b026		6f 72 20 21
>b02a		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>b032		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>b042		65 20 21
.b045						ramdrive_code_end:
.b045						xt_block_read:
.b045						w_block_read:
.b045		a0 32		ldy #$32	                ldy #blockread_offset
.b047		b1 08		lda ($08),y	                lda (up),y
.b049		85 25		sta $25		                sta tmp1
.b04b		c8		iny		                iny
.b04c		b1 08		lda ($08),y	                lda (up),y
.b04e		85 26		sta $26		                sta tmp1+1
.b050		6c 25 00	jmp ($0025)	                jmp (tmp1)
.b053						z_block_read:
.b053						xt_block_read_vector:
.b053						w_block_read_vector:
.b053		a9 32		lda #$32	                lda #blockread_offset
.b055		4c 45 d7	jmp $d745	                jmp push_upvar_tos
.b058						z_block_read_vector:
.b058						xt_block_word_error:
.b058						w_block_word_error:
.b058		a9 0c		lda #$0c	                lda #err_blockwords
.b05a		4c 9f d8	jmp $d89f	                jmp error       ; no RTS needed
.b05d						xt_block_write:
.b05d						w_block_write:
.b05d		a0 34		ldy #$34	                ldy #blockwrite_offset
.b05f		b1 08		lda ($08),y	                lda (up),y
.b061		85 25		sta $25		                sta tmp1
.b063		c8		iny		                iny
.b064		b1 08		lda ($08),y	                lda (up),y
.b066		85 26		sta $26		                sta tmp1+1
.b068		6c 25 00	jmp ($0025)	                jmp (tmp1)
.b06b						z_block_write:
.b06b						xt_block_write_vector:
.b06b						w_block_write_vector:
.b06b		a9 34		lda #$34	                lda #blockwrite_offset
.b06d		4c 45 d7	jmp $d745	                jmp push_upvar_tos
.b070						z_block_write_vector:
.b070						xt_buffblocknum:
.b070						w_buffblocknum:
.b070		a9 2e		lda #$2e	                lda #buffblocknum_offset
.b072		4c 45 d7	jmp $d745	                jmp push_upvar_tos
.b075						z_buffblocknum:
.b075						xt_buffer:
.b075						w_buffer:
.b075		a0 30		ldy #$30	                ldy #buffstatus_offset
.b077		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b079		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b07b		d0 0c		bne $b089	                bne _buffer_available ; Unused or not dirty = available
.b07d		20 66 ae	jsr $ae66	                jsr w_blkbuffer
.b080		20 70 b0	jsr $b070	                jsr w_buffblocknum
.b083		20 f6 87	jsr $87f6	                jsr w_fetch
.b086		20 5d b0	jsr $b05d	                jsr w_block_write
.b089						_buffer_available:
.b089		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.b08b		b5 00		lda $00,x	                lda 0,x
.b08d		91 08		sta ($08),y	                sta (up),y
.b08f		c8		iny		                iny
.b090		b5 01		lda $01,x	                lda 1,x
.b092		91 08		sta ($08),y	                sta (up),y
.b094		a9 01		lda #$01	                lda #1
.b096		a0 30		ldy #$30	                ldy #buffstatus_offset
.b098		91 08		sta ($08),y	                sta (up),y
.b09a		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.b09c		b1 08		lda ($08),y	                lda (up),y
.b09e		95 00		sta $00,x	                sta 0,x
.b0a0		c8		iny		                iny
.b0a1		b1 08		lda ($08),y	                lda (up),y
.b0a3		95 01		sta $01,x	                sta 1,x
.b0a5		60		rts		z_buffer:       rts
.b0a6						xt_buffstatus:
.b0a6						w_buffstatus:
.b0a6		a9 30		lda #$30	                lda #buffstatus_offset
.b0a8		4c 45 d7	jmp $d745	                jmp push_upvar_tos
.b0ab						z_buffstatus:
.b0ab						xt_empty_buffers:
.b0ab						w_empty_buffers:
.b0ab		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0ad		a9 00		lda #$00	                lda #0
.b0af		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b0b1						z_empty_buffers:
.b0b1		60		rts		                rts
.b0b2						xt_flush:
.b0b2						w_flush:
.b0b2		20 0d b1	jsr $b10d	                jsr w_save_buffers
.b0b5		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0b7		a9 00		lda #$00	                lda #0
.b0b9		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b0bb						z_flush:
.b0bb		60		rts		                rts
.b0bc						xt_list:
.b0bc		20 89 d8	jsr $d889	                jsr underflow_1
.b0bf						w_list:
.b0bf		20 28 b1	jsr $b128	                jsr w_scr
.b0c2		20 0f 92	jsr $920f	                jsr w_store
.b0c5		20 c7 b1	jsr $b1c7	                jsr w_editor_l
.b0c8		60		rts		z_list:         rts
.b0c9						xt_load:
.b0c9		20 89 d8	jsr $d889	                jsr underflow_1
.b0cc						w_load:
.b0cc		a0 05		ldy #$05	                ldy #blk_offset+1
.b0ce		b1 08		lda ($08),y	                lda (up),y
.b0d0		48		pha		                pha
.b0d1		88		dey		                dey
.b0d2		b1 08		lda ($08),y	                lda (up),y
.b0d4		48		pha		                pha
.b0d5		b5 00		lda $00,x	                lda 0,x
.b0d7		91 08		sta ($08),y	                sta (up),y
.b0d9		c8		iny		                iny
.b0da		b5 01		lda $01,x	                lda 1,x
.b0dc		91 08		sta ($08),y	                sta (up),y
.b0de		20 74 ae	jsr $ae74	                jsr w_block
.b0e1		ca		dex		                dex
.b0e2		ca		dex		                dex
.b0e3		a9 04		lda #$04	                lda #4
.b0e5		95 01		sta $01,x	                sta 1,x
.b0e7		74 00		stz $00,x	                stz 0,x
.b0e9		20 85 88	jsr $8885	                jsr load_evaluate
.b0ec		a0 04		ldy #$04	                ldy #blk_offset
.b0ee		68		pla		                pla
.b0ef		91 08		sta ($08),y	                sta (up),y
.b0f1		c8		iny		                iny
.b0f2		68		pla		                pla
.b0f3		91 08		sta ($08),y	                sta (up),y
.b0f5		88		dey		                dey
.b0f6		11 08		ora ($08),y	                ora (up),y
.b0f8		f0 12		beq $b10c	                beq _done
.b0fa		ca		dex		                dex
.b0fb		ca		dex		                dex
.b0fc		a0 04		ldy #$04	                ldy #blk_offset
.b0fe		b1 08		lda ($08),y	                lda (up),y
.b100		95 00		sta $00,x	                sta 0,x
.b102		c8		iny		                iny
.b103		b1 08		lda ($08),y	                lda (up),y
.b105		95 01		sta $01,x	                sta 1,x
.b107		20 74 ae	jsr $ae74	                jsr w_block
.b10a		e8		inx		                inx
.b10b		e8		inx		                inx
.b10c						_done:
.b10c		60		rts		z_load:         rts
.b10d						xt_save_buffers:
.b10d						w_save_buffers:
.b10d		a0 30		ldy #$30	                ldy #buffstatus_offset
.b10f		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b111		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b113		d0 12		bne $b127	                bne _done       ; Either not used or not dirty = done!
.b115		20 66 ae	jsr $ae66	                jsr w_blkbuffer
.b118		20 70 b0	jsr $b070	                jsr w_buffblocknum
.b11b		20 f6 87	jsr $87f6	                jsr w_fetch
.b11e		20 5d b0	jsr $b05d	                jsr w_block_write
.b121		a9 01		lda #$01	                lda #1
.b123		a0 30		ldy #$30	                ldy #buffstatus_offset
.b125		91 08		sta ($08),y	                sta (up),y
.b127						_done:
.b127		60		rts		z_save_buffers: rts
.b128						xt_scr:
.b128						w_scr:
.b128		a9 06		lda #$06	                lda #scr_offset
.b12a		4c 45 d7	jmp $d745	                jmp push_upvar_tos
.b12d						z_scr:
.b12d						xt_thru:
.b12d		20 8e d8	jsr $d88e	                jsr underflow_2
.b130						w_thru:
.b130		b5 01		lda $01,x	                lda 1,x
.b132		48		pha		                pha
.b133		b5 00		lda $00,x	                lda 0,x
.b135		48		pha		                pha
.b136		e8		inx		                inx
.b137		e8		inx		                inx
.b138						_thru_loop:
.b138		b5 01		lda $01,x	                lda 1,x
.b13a		48		pha		                pha
.b13b		b5 00		lda $00,x	                lda 0,x
.b13d		48		pha		                pha
.b13e		20 cc b0	jsr $b0cc	                jsr w_load
.b141		68		pla		                pla
.b142		85 25		sta $25		                sta tmp1
.b144		68		pla		                pla
.b145		85 26		sta $26		                sta tmp1+1
.b147		68		pla		                pla
.b148		85 27		sta $27		                sta tmp2
.b14a		68		pla		                pla
.b14b		85 28		sta $28		                sta tmp2+1
.b14d		c5 26		cmp $26		                cmp tmp1+1
.b14f		d0 08		bne $b159	                bne _next_screen
.b151		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b153		c5 25		cmp $25		                cmp tmp1
.b155		d0 02		bne $b159	                bne _next_screen
.b157		80 18		bra $b171	                bra _done       ; We just did the last screen.
.b159						_next_screen:
.b159		a5 28		lda $28		                lda tmp2+1
.b15b		48		pha		                pha
.b15c		a5 27		lda $27		                lda tmp2
.b15e		48		pha		                pha
.b15f		e6 25		inc $25		                inc tmp1
.b161		d0 02		bne $b165	                bne +
.b163		e6 26		inc $26		                inc tmp1+1
.b165						+
.b165		ca		dex		                dex
.b166		ca		dex		                dex
.b167		a5 25		lda $25		                lda tmp1
.b169		95 00		sta $00,x	                sta 0,x
.b16b		a5 26		lda $26		                lda tmp1+1
.b16d		95 01		sta $01,x	                sta 1,x
.b16f		80 c7		bra $b138	                bra _thru_loop
.b171						_done:
.b171		60		rts		z_thru:         rts
.b172						xt_update:
.b172						w_update:
.b172		a0 30		ldy #$30	                ldy #buffstatus_offset
.b174		b1 08		lda ($08),y	                lda (up),y
.b176		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b178		91 08		sta ($08),y	                sta (up),y
.b17a		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b17b						xt_editor_screen_helper:
.b17b						w_editor_screen_helper:
.b17b		20 69 86	jsr $8669	                jsr w_dup
.b17e		20 28 b1	jsr $b128	                jsr w_scr
.b181		20 0f 92	jsr $920f	                jsr w_store
.b184		4c 75 b0	jmp $b075	                jmp w_buffer
.b187						xt_editor_enter_screen:
.b187						w_editor_enter_screen:
.b187		20 7b b1	jsr $b17b	                jsr w_editor_screen_helper
.b18a		20 63 86	jsr $8663	                jsr w_drop
.b18d		64 35		stz $35		                stz ed_head
.b18f						_prompt_loop:
.b18f		ca		dex		                dex
.b190		ca		dex		                dex
.b191		a5 35		lda $35		                lda ed_head
.b193		95 00		sta $00,x	                sta 0,x
.b195		74 01		stz $01,x	                stz 1,x
.b197		20 5a b2	jsr $b25a	                jsr w_editor_o
.b19a		e6 35		inc $35		                inc ed_head
.b19c		a9 10		lda #$10	                lda #16
.b19e		c5 35		cmp $35		                cmp ed_head
.b1a0		d0 ed		bne $b18f	                bne _prompt_loop
.b1a2						z_editor_enter_screen:
.b1a2		60		rts		                rts
.b1a3						xt_editor_erase_screen:
.b1a3						w_editor_erase_screen:
.b1a3		20 7b b1	jsr $b17b	                jsr w_editor_screen_helper
.b1a6		ca		dex		                dex
.b1a7		ca		dex		                dex
.b1a8		74 00		stz $00,x	                stz 0,x
.b1aa		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b1ac		95 01		sta $01,x	                sta 1,x
.b1ae		20 86 87	jsr $8786	                jsr w_blank
.b1b1		20 72 b1	jsr $b172	                jsr w_update
.b1b4						z_editor_erase_screen:
.b1b4		60		rts		                rts
.b1b5						xt_editor_el:
.b1b5						w_editor_el:
.b1b5		20 44 b2	jsr $b244	                jsr w_editor_line
.b1b8		ca		dex		                dex
.b1b9		ca		dex		                dex
.b1ba		a9 40		lda #$40	                lda #64
.b1bc		95 00		sta $00,x	                sta 0,x
.b1be		74 01		stz $01,x	                stz 1,x
.b1c0		20 86 87	jsr $8786	                jsr w_blank
.b1c3		20 72 b1	jsr $b172	                jsr w_update
.b1c6		60		rts		z_editor_el:    rts
.b1c7						xt_editor_l:
.b1c7						w_editor_l:
.b1c7		ca		dex		                dex             ; Put SCR on the stack.
.b1c8		ca		dex		                dex
.b1c9		a0 06		ldy #$06	                ldy #scr_offset
.b1cb		b1 08		lda ($08),y	                lda (up),y
.b1cd		95 00		sta $00,x	                sta 0,x
.b1cf		c8		iny		                iny
.b1d0		b1 08		lda ($08),y	                lda (up),y
.b1d2		95 01		sta $01,x	                sta 1,x
.b1d4		20 74 ae	jsr $ae74	                jsr w_block    ; Get the current screen.
.b1d7		20 05 84	jsr $8405	                jsr w_cr
.b1da		80 08		bra $b1e4	                bra _after_screen_msg
.b1dc						_screen_msg:
>b1dc		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b1e4						_after_screen_msg:
.b1e4		20 32 a2	jsr $a232	                jsr sliteral_runtime
>b1e7		dc b1 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.b1eb		20 bb 94	jsr $94bb	                jsr w_type
.b1ee		20 28 b1	jsr $b128	                jsr w_scr
.b1f1		20 f6 87	jsr $87f6	                jsr w_fetch
.b1f4		ca		dex		                dex
.b1f5		ca		dex		                dex
.b1f6		a9 04		lda #$04	                lda #4          ; four spaces
.b1f8		95 00		sta $00,x	                sta 0,x
.b1fa		74 01		stz $01,x	                stz 1,x
.b1fc		20 f2 94	jsr $94f2	                jsr w_u_dot_r
.b1ff		64 29		stz $29		                stz tmp3
.b201						_line_loop:
.b201		20 05 84	jsr $8405	                jsr w_cr
.b204		ca		dex		                dex
.b205		ca		dex		                dex
.b206		ca		dex		                dex
.b207		ca		dex		                dex
.b208		74 03		stz $03,x	                stz 3,x
.b20a		a5 29		lda $29		                lda tmp3
.b20c		95 02		sta $02,x	                sta 2,x
.b20e		74 01		stz $01,x	                stz 1,x
.b210		a9 02		lda #$02	                lda #2
.b212		95 00		sta $00,x	                sta 0,x
.b214		20 f2 94	jsr $94f2	                jsr w_u_dot_r
.b217		20 bc 91	jsr $91bc	                jsr w_space
.b21a		20 69 86	jsr $8669	                jsr w_dup
.b21d		ca		dex		                dex
.b21e		ca		dex		                dex
.b21f		a9 40		lda #$40	                lda #64
.b221		95 00		sta $00,x	                sta 0,x
.b223		74 01		stz $01,x	                stz 1,x
.b225		20 bb 94	jsr $94bb	                jsr w_type
.b228		18		clc		                clc
.b229		a9 40		lda #$40	                lda #64
.b22b		75 00		adc $00,x	                adc 0,x
.b22d		95 00		sta $00,x	                sta 0,x
.b22f		90 02		bcc $b233	                bcc +
.b231		f6 01		inc $01,x	                inc 1,x
.b233						+
.b233		e6 29		inc $29		                inc tmp3
.b235		a5 29		lda $29		                lda tmp3
.b237		c9 10		cmp #$10	                cmp #16
.b239		d0 c6		bne $b201	                bne _line_loop
.b23b		20 05 84	jsr $8405	                jsr w_cr
.b23e		e8		inx		                inx
.b23f		e8		inx		                inx
.b240		60		rts		z_editor_l:            rts
.b241						xt_editor_line:
.b241		20 89 d8	jsr $d889	                jsr underflow_1
.b244						w_editor_line:
.b244		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b246						_shift_tos_left:
.b246		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b248		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b24a		88		dey		                dey
.b24b		d0 f9		bne $b246	                bne _shift_tos_left
.b24d		20 28 b1	jsr $b128	                jsr w_scr
.b250		20 f6 87	jsr $87f6	                jsr w_fetch
.b253		20 74 ae	jsr $ae74	                jsr w_block
.b256		20 32 8e	jsr $8e32	                jsr w_plus
.b259		60		rts		z_editor_line:  rts
.b25a						xt_editor_o:
.b25a						w_editor_o:
.b25a		20 05 84	jsr $8405	                jsr w_cr
.b25d		20 69 86	jsr $8669	                jsr w_dup
.b260		20 11 9e	jsr $9e11	                jsr w_two
.b263		20 f2 94	jsr $94f2	                jsr w_u_dot_r
.b266		20 bc 91	jsr $91bc	                jsr w_space
.b269		a9 2a		lda #$2a	                lda #'*'
.b26b		20 93 86	jsr $8693	                jsr emit_a
.b26e		20 bc 91	jsr $91bc	                jsr w_space
.b271		20 44 b2	jsr $b244	                jsr w_editor_line
.b274		20 69 86	jsr $8669	                jsr w_dup      ; Save a copy of the line address for later.
.b277		ca		dex		                dex
.b278		ca		dex		                dex
.b279		a9 40		lda #$40	                lda #64         ; chars/line
.b27b		95 00		sta $00,x	                sta 0,x
.b27d		74 01		stz $01,x	                stz 1,x
.b27f		20 e7 80	jsr $80e7	                jsr w_accept
.b282		20 69 86	jsr $8669	                jsr w_dup
.b285		20 cd 9c	jsr $9ccd	                jsr w_not_rot  ; -rot
.b288		20 32 8e	jsr $8e32	                jsr w_plus
.b28b		ca		dex		                dex
.b28c		ca		dex		                dex
.b28d		a9 40		lda #$40	                lda #64         ; chars/line
.b28f		95 00		sta $00,x	                sta 0,x
.b291		74 01		stz $01,x	                stz 1,x
.b293		20 73 8f	jsr $8f73	                jsr w_rot
.b296		20 c4 8b	jsr $8bc4	                jsr w_minus
.b299		20 86 87	jsr $8786	                jsr w_blank
.b29c		20 72 b1	jsr $b172	                jsr w_update
.b29f		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b2a0						xt_also:
.b2a0						w_also:
.b2a0		20 cb b2	jsr $b2cb	                jsr w_get_order
.b2a3		20 e4 8c	jsr $8ce4	                jsr w_over
.b2a6		20 25 92	jsr $9225	                jsr w_swap
.b2a9		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.b2ac		20 d4 b3	jsr $b3d4	                jsr w_set_order
.b2af		60		rts		z_also:         rts
.b2b0						xt_definitions:
.b2b0						w_definitions:
.b2b0		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b2b2		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b2b4		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b2b6		91 08		sta ($08),y	                sta (up),y
.b2b8		60		rts		z_definitions:  rts
.b2b9						xt_forth:
.b2b9						w_forth:
.b2b9		a0 23		ldy #$23	                ldy #search_order_offset
.b2bb		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b2bd		91 08		sta ($08),y	                sta (up),y
.b2bf						z_forth:
.b2bf		60		rts		                rts
.b2c0						xt_get_current:
.b2c0						w_get_current:
.b2c0		ca		dex		                dex
.b2c1		ca		dex		                dex
.b2c2		a0 08		ldy #$08	                ldy #current_offset
.b2c4		b1 08		lda ($08),y	                lda (up),y
.b2c6		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b2c8		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b2ca		60		rts		z_get_current:  rts
.b2cb						xt_get_order:
.b2cb						w_get_order:
.b2cb		a0 22		ldy #$22	                ldy #num_order_offset
.b2cd		b1 08		lda ($08),y	                lda (up),y
.b2cf		85 25		sta $25		                sta tmp1
.b2d1		f0 16		beq $b2e9	                beq _done       ; If zero, there are no wordlists.
.b2d3						_loop:
.b2d3		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b2d5		a9 23		lda #$23	                lda #search_order_offset
.b2d7		18		clc		                clc
.b2d8		65 25		adc $25		                adc tmp1
.b2da		a8		tay		                tay
.b2db		ca		dex		                dex
.b2dc		ca		dex		                dex
.b2dd		b1 08		lda ($08),y	                lda (up),y
.b2df		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b2e1		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b2e3		a9 00		lda #$00	                lda #0
.b2e5		c5 25		cmp $25		                cmp tmp1
.b2e7		d0 ea		bne $b2d3	                bne _loop
.b2e9						_done:
.b2e9		ca		dex		                dex
.b2ea		ca		dex		                dex
.b2eb		a0 22		ldy #$22	                ldy #num_order_offset
.b2ed		b1 08		lda ($08),y	                lda (up),y
.b2ef		95 00		sta $00,x	                sta 0,x
.b2f1		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b2f3		60		rts		z_get_order:    rts
.b2f4						xt_only:
.b2f4						w_only:
.b2f4		20 78 93	jsr $9378	                jsr w_true
.b2f7		20 d4 b3	jsr $b3d4	                jsr w_set_order
.b2fa		60		rts		z_only:         rts
.b2fb						xt_order:
.b2fb						w_order:
.b2fb		20 05 84	jsr $8405	                jsr w_cr
.b2fe		20 cb b2	jsr $b2cb	                jsr w_get_order        ; ( wid_n ... wid_1 n )
.b301		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.b303		f0 1e		beq $b323	                beq _drop_done
.b305		a8		tay		                tay
.b306						_loop:
.b306		e8		inx		                inx
.b307		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.b308		b5 00		lda $00,x	                lda 0,x
.b30a		5a		phy		                phy
.b30b		20 26 b3	jsr $b326	                jsr order_print_wid_string   ; internal helper function
.b30e		7a		ply		                ply
.b30f		88		dey		                dey
.b310		d0 f4		bne $b306	                bne _loop
.b312		20 bc 91	jsr $91bc	                jsr w_space
.b315		20 bc 91	jsr $91bc	                jsr w_space
.b318		20 c0 b2	jsr $b2c0	                jsr w_get_current      ; ( wid )
.b31b		b5 00		lda $00,x	                lda 0,x
.b31d		20 26 b3	jsr $b326	                jsr order_print_wid_string
.b320		20 05 84	jsr $8405	                jsr w_cr
.b323						_drop_done:
.b323		e8		inx		                inx
.b324		e8		inx		                inx
.b325						z_order:
.b325		60		rts		                rts
.b326						order_print_wid_string:
.b326		c9 04		cmp #$04	                cmp #4
.b328		90 09		bcc $b333	                bcc _output_string      ; less than 4, print a real string
.b32a		ca		dex		                dex
.b32b		ca		dex		                dex
.b32c		95 00		sta $00,x	                sta 0,x
.b32e		74 01		stz $01,x	                stz 1,x
.b330		4c e6 94	jmp $94e6	                jmp w_u_dot            ; JSR/RTS as this routine is not compiled
.b333						_output_string:
.b333		a8		tay		                tay
.b334		b9 3a b3	lda $b33a,y	                lda _wid_data,y
.b337		4c c5 d8	jmp $d8c5	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b33a						_wid_data:
>b33a		04				        .byte str_wid_forth            ; WID 0: "Forth"
>b33b		05				        .byte str_wid_editor           ; WID 1: "Editor"
>b33c		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>b33d		07				        .byte str_wid_root             ; WID 3: "Root"
.b33e						xt_previous:
.b33e						w_previous:
.b33e		20 cb b2	jsr $b2cb	                jsr w_get_order
.b341		20 13 8c	jsr $8c13	                jsr w_nip
.b344		20 bc 8c	jsr $8cbc	                jsr w_one_minus
.b347		20 d4 b3	jsr $b3d4	                jsr w_set_order
.b34a		60		rts		z_previous:     rts
.b34b						xt_root_wordlist:
.b34b						w_root_wordlist:
.b34b		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b34c		ca		dex		                dex
.b34d		a9 03		lda #$03	                lda #3
.b34f		95 00		sta $00,x	                sta 0,x
.b351		74 01		stz $01,x	                stz 1,x
.b353						z_root_wordlist:
.b353		60		rts		                rts
.b354						xt_search_wordlist:
.b354		20 93 d8	jsr $d893	                jsr underflow_3
.b357						w_search_wordlist:
.b357		a5 08		lda $08		                lda up
.b359		18		clc		                clc
.b35a		69 0a		adc #$0a	                adc #wordlists_offset
.b35c		85 27		sta $27		                sta tmp2
.b35e		a5 09		lda $09		                lda up+1
.b360		69 00		adc #$00	                adc #0          ; Adding carry
.b362		85 28		sta $28		                sta tmp2+1
.b364		b5 00		lda $00,x	                lda 0,x
.b366		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b367		65 27		adc $27		                adc tmp2
.b369		85 27		sta $27		                sta tmp2
.b36b		90 02		bcc $b36f	                bcc +
.b36d		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b36f						+
.b36f		e8		inx		                inx
.b370		e8		inx		                inx
.b371		b5 00		lda $00,x	                lda 0,x
.b373		15 01		ora $01,x	                ora 1,x
.b375		f0 4e		beq $b3c5	                beq _done
.b377		a5 27		lda $27		                lda tmp2
.b379		05 28		ora $28		                ora tmp2+1
.b37b		f0 48		beq $b3c5	                beq _done
.b37d		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b37f		85 25		sta $25		                sta tmp1
.b381		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b383		d0 02		bne $b387	                bne +
.b385		e6 28		inc $28		                inc tmp2+1
.b387						+
.b387		b2 27		lda ($27)	                lda (tmp2)
.b389		85 26		sta $26		                sta tmp1+1
.b38b		20 6b d7	jsr $d76b	                jsr find_header_name
.b38e		f0 31		beq $b3c1	                beq _fail_done
.b390		e8		inx		                inx
.b391		e8		inx		                inx
.b392		a5 25		lda $25		                lda tmp1
.b394		95 00		sta $00,x	                sta 0,x
.b396		a5 26		lda $26		                lda tmp1+1
.b398		95 01		sta $01,x	                sta 1,x
.b39a		20 69 86	jsr $8669	                jsr w_dup              ; ( nt nt )
.b39d		20 86 9c	jsr $9c86	                jsr w_name_to_int      ; ( nt xt )
.b3a0		20 25 92	jsr $9225	                jsr w_swap             ; ( xt nt )
.b3a3		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b3a5		f6 00		inc $00,x	                inc 0,x
.b3a7		d0 02		bne $b3ab	                bne +
.b3a9		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b3ab						+
.b3ab		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b3ad		29 02		and #$02	                and #IM
.b3af		d0 08		bne $b3b9	                bne _immediate          ; bit set, we're immediate
.b3b1		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b3b3		95 00		sta $00,x	                sta 0,x
.b3b5		95 01		sta $01,x	                sta 1,x
.b3b7		80 0e		bra $b3c7	                bra _done_nodrop
.b3b9						_immediate:
.b3b9		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b3bb		95 00		sta $00,x	                sta 0,x
.b3bd		74 01		stz $01,x	                stz 1,x
.b3bf		80 06		bra $b3c7	                bra _done_nodrop
.b3c1						_fail_done:
.b3c1		74 02		stz $02,x	                stz 2,x         ; failure flag
.b3c3		74 03		stz $03,x	                stz 3,x
.b3c5						_done:
.b3c5		e8		inx		                inx
.b3c6		e8		inx		                inx
.b3c7						_done_nodrop:
.b3c7						z_search_wordlist:
.b3c7		60		rts		                rts
.b3c8						xt_set_current:
.b3c8		20 89 d8	jsr $d889	                jsr underflow_1
.b3cb						w_set_current:
.b3cb		a0 08		ldy #$08	                ldy #current_offset
.b3cd		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b3cf		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b3d1		e8		inx		                inx
.b3d2		e8		inx		                inx
.b3d3		60		rts		z_set_current:  rts
.b3d4						xt_set_order:
.b3d4						w_set_order:
.b3d4		a9 ff		lda #$ff	                lda #$FF
.b3d6		d5 01		cmp $01,x	                cmp 1,x
.b3d8		d0 12		bne $b3ec	                bne _start
.b3da		d5 00		cmp $00,x	                cmp 0,x
.b3dc		d0 0e		bne $b3ec	                bne _start
.b3de		ca		dex		                dex             ; Make room for the count.
.b3df		ca		dex		                dex
.b3e0		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b3e2		a9 03		lda #$03	                lda #3
.b3e4		95 02		sta $02,x	                sta 2,x
.b3e6		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b3e8		a9 01		lda #$01	                lda #1
.b3ea		95 00		sta $00,x	                sta 0,x
.b3ec						_start:
.b3ec		a0 22		ldy #$22	                ldy #num_order_offset
.b3ee		b5 00		lda $00,x	                lda 0,x
.b3f0		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b3f2		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b3f4		e8		inx		                inx             ; Drop the count off the data stack.
.b3f5		e8		inx		                inx
.b3f6		a5 25		lda $25		                lda tmp1
.b3f8		f0 0d		beq $b407	                beq _done       ; If zero, there are no wordlists.
.b3fa		a0 23		ldy #$23	                ldy #search_order_offset
.b3fc						_loop:
.b3fc		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b3fe		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b400		c8		iny		                iny
.b401		e8		inx		                inx
.b402		e8		inx		                inx
.b403		c6 25		dec $25		                dec tmp1
.b405		d0 f5		bne $b3fc	                bne _loop
.b407						_done:
.b407		60		rts		z_set_order:    rts
.b408						xt_to_order:
.b408						w_to_order:
.b408		20 60 93	jsr $9360	                jsr w_to_r
.b40b		20 cb b2	jsr $b2cb	                jsr w_get_order
.b40e		20 cc 8e	jsr $8ecc	                jsr w_r_from
.b411		20 25 92	jsr $9225	                jsr w_swap
.b414		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.b417		20 d4 b3	jsr $b3d4	                jsr w_set_order
.b41a		60		rts		z_to_order:     rts
.b41b						xt_wordlist:
.b41b						w_wordlist:
.b41b		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b41d		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b41f		c9 0c		cmp #$0c	                cmp #max_wordlists
.b421		d0 05		bne $b428	                bne _ok
.b423		a9 0b		lda #$0b	                lda #err_wordlist
.b425		4c 9f d8	jmp $d89f	                jmp error
.b428						_ok:
.b428		1a		inc a		                ina             ; Increment the wordlist#
.b429		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b42b		ca		dex		                dex             ; and put it on the stack.
.b42c		ca		dex		                dex
.b42d		95 00		sta $00,x	                sta 0,x
.b42f		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b431		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=$0000						ram_start = $0000          ; start of installed RAM, must include zpage
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=32767						ram_end   = $8000-1        ; end of installed RAM
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=512						buffer0   = stack0+$100      ; input buffer ($0200-$02ff)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b432						cold_zp_table:
>b432	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b434	0002	15 bc				dp:         .word dictionary_start  ; Dictionary Pointer
>b436	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b438	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b43a	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b43c	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b43e	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b440	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b442	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b444	0012	27 f0				output:     .word kernel_putc       ; vector for EMIT
>b446	0014	2b f0				input:      .word kernel_getc       ; vector for KEY
>b448	0016	39 f0				havekey:    .word kernel_kbhit      ; vector for KEY?
>b44a	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b44c	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b44e	001c	00 00				status:     .word 0                 ; internal status used by CREATE : :NONAME ; ACCEPT NUMBER
>b450	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b451	001f					loopctrl:   .byte ?         ; Offset from lcbstack0 to current loop control block for DO/LOOP/+LOOP
>b452	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$0100						lcbstack0 = stack0
=256						loopindex = lcbstack0+0     ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack0+2     ; loop control block offset for limit fudge factor
>b453	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b455	0023					tmptos:     .word ?         ; temporary TOS storage
>b457	0025					tmp1:       .word ?         ; temporary storage
>b459	0027					tmp2:       .word ?         ; temporary storage
>b45b	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b45d	002b					tohold:     .word ?         ; pointer for formatted output
>b45f	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b467	0035					tmped:      .word ?,?,?     ; temporary for editors
.b450						cold_zp_table_end:
.b450						cold_user_table:
>b450	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b452	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b454	0004	00 00				blk_offset:             .word 0         ; BLK
>b456	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
.b458	0008					marker_start_offset:
>b458	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b459	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b45a	000a					wordlists_offset:
>b45a	000a	15 bc				    .word dictionary_start              ; FORTH-WORDLIST
>b45c	000c	9a ca				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b45e	000e	ea ca				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b460	0010	59 ca				    .word root_dictionary_start         ; ROOT-WORDLIST
>b462	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b46a	001a	00 00 00 00 00 00 00 00
>b472	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b473	0023					search_order_offset:
>b473	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b47b	002b	00
.b47c	002c					marker_end_offset:
>b47c	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b47e	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b480	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b482	0032	58 b0				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b484	0034	58 b0				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b486						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$d0						OpBNE   = $D0
=$f0						OpBEQ   = $F0
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=5						N_FLAGS = 5
=1						CO = 1  ; Compile Only
=2						IM = 2  ; Immediate Word
=4						AN = 4  ; Always Native Compile
=8						NN = 8  ; Never Native Compile
=12						ST = AN+NN ; Stack juggling to be stripped for native compile
=16						HC = 16 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b486						oc_index_table:
>b486		86 b6 8a b6 31 bb 31 bb		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc07
>b48e		92 b6 98 b6 9e b6 a4 b6
>b496		ab b6 af b6 b5 b6 31 bb		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b49e		bb b6 bf b6 c3 b6 c7 b6
>b4a6		cc b6 d0 b6 d8 b6 31 bb		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b4ae		df b6 e5 b6 ec b6 f3 b6
>b4b6		fa b6 fe b6 04 b7 31 bb		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc1E, oc1F
>b4be		0a b7 0e b7 14 b7 1a b7
>b4c6		1f b7 23 b7 31 bb 31 bb		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b4ce		2b b7 31 b7 37 b7 3d b7
>b4d6		44 b7 48 b7 4e b7 31 bb		        .word oc28, oc29, oc2A, oc__, oc2C, oc2D, oc2E, oc2F
>b4de		54 b7 58 b7 5d b7 61 b7
>b4e6		66 b7 6a b7 72 b7 31 bb		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b4ee		79 b7 81 b7 88 b7 8f b7
>b4f6		96 b7 9a b7 a0 b7 31 bb		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc3F
>b4fe		a6 b7 ac b7 b2 b7 b8 b7
>b506		bd b7 c1 b7 31 bb 31 bb		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b50e		31 bb c9 b7 cf b7 d5 b7
>b516		dc b7 e0 b7 e6 b7 31 bb		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b51e		ec b7 f0 b7 f4 b7 f8 b7
>b526		fd b7 01 b8 09 b8 31 bb		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b52e		31 bb 10 b8 17 b8 1e b8
>b536		25 b8 29 b8 2f b8 31 bb		        .word oc58, oc59, oc5A, oc__, oc__, oc5D, oc5E, oc5F
>b53e		31 bb 33 b8 39 b8 3f b8
>b546		44 b8 48 b8 31 bb 31 bb		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b54e		50 b8 56 b8 5c b8 62 b8
>b556		69 b8 6d b8 73 b8 31 bb		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b55e		79 b8 7f b8 83 b8 87 b8
>b566		8c b8 90 b8 98 b8 31 bb		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b56e		9f b8 a6 b8 ad b8 b4 b8
>b576		bb b8 bf b8 c5 b8 31 bb		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b57e		c9 b8 d0 b8 d6 b8 dc b8
>b586		e1 b8 e5 b8 31 bb 31 bb		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc87
>b58e		ed b8 f3 b8 f9 b8 ff b8
>b596		06 b9 0a b9 10 b9 31 bb		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b59e		14 b9 18 b9 1c b9 20 b9
>b5a6		25 b9 29 b9 31 b9 31 bb		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b5ae		38 b9 3f b9 46 b9 4d b9
>b5b6		54 b9 58 b9 5e b9 31 bb		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b5be		62 b9 66 b9 6c b9 72 b9
>b5c6		77 b9 7d b9 85 b9 31 bb		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b5ce		8b b9 91 b9 97 b9 9d b9
>b5d6		a4 b9 a8 b9 ae b9 31 bb		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b5de		b2 b9 b6 b9 ba b9 be b9
>b5e6		c3 b9 c7 b9 cf b9 31 bb		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b5ee		d6 b9 dd b9 e4 b9 eb b9
>b5f6		f2 b9 f6 b9 fc b9 31 bb		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b5fe		00 ba 06 ba 0c ba 12 ba
>b606		17 ba 1d ba 31 bb 31 bb		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b60e		25 ba 2b ba 31 ba 37 ba
>b616		3e ba 42 ba 48 ba 31 bb		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b61e		4c ba 50 ba 54 ba 58 ba
>b626		5d ba 61 ba 69 ba 31 bb		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b62e		31 bb 70 ba 77 ba 7e ba
>b636		85 ba 89 ba 8f ba 31 bb		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b63e		31 bb 93 ba 99 ba 9f ba
>b646		a4 ba aa ba 31 bb 31 bb		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b64e		b2 ba b8 ba be ba c4 ba
>b656		cb ba cf ba d5 ba 31 bb		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b65e		d9 ba dd ba e1 ba e5 ba
>b666		ea ba ee ba f6 ba 31 bb		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b66e		31 bb fd ba 04 bb 0b bb
>b676		12 bb 16 bb 1c bb 31 bb		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b67e		31 bb 20 bb 26 bb 2c bb
>b686		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b68a		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b692		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b698		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b69e		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b6a4		86 72 6d 62 30 2e 7a			oc07:	.text 2*64+6, "rmb0.z"
>b6ab		43 70 68 70				oc08:	.text 1*64+3, "php"
>b6af		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b6b5		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b6bb		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b6bf		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b6c3		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b6c7		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b6cc		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b6d0		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b6d8		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b6df		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b6e5		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b6ec		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b6f3		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b6fa		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b6fe		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b704		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b70a		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b70e		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b714		c5 61 73 6c 2e 78			oc1E:	.text 3*64+5, "asl.x"
>b71a		c4 62 62 72 31				oc1F:	.text 3*64+4, "bbr1"
>b71f		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b723		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b72b		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b731		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b737		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b73d		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b744		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b748		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b74e		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b754		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b758		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b75d		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b761		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b766		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b76a		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b772		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b779		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b781		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b788		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b78f		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b796		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b79a		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b7a0		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b7a6		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b7ac		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b7b2		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b7b8		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b7bd		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b7c1		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b7c9		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b7cf		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b7d5		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b7dc		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b7e0		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b7e6		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b7ec		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b7f0		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b7f4		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b7f8		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b7fd		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b801		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b809		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b810		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b817		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b81e		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b825		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b829		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b82f		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b833		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b839		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b83f		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b844		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b848		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b850		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b856		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b85c		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b862		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b869		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b86d		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b873		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b879		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b87f		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b883		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b887		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b88c		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b890		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b898		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b89f		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b8a6		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b8ad		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b8b4		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b8bb		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b8bf		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b8c5		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b8c9		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b8d0		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b8d6		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b8dc		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b8e1		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b8e5		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b8ed		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b8f3		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b8f9		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b8ff		86 73 6d 62 30 2e 7a			oc87:	.text 2*64+6, "smb0.z"
>b906		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b90a		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b910		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b914		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b918		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b91c		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b920		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b925		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b929		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b931		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b938		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b93f		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b946		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b94d		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b954		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b958		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b95e		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b962		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b966		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b96c		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b972		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b977		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b97d		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b985		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b98b		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b991		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b997		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b99d		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b9a4		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b9a8		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b9ae		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b9b2		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b9b6		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b9ba		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b9be		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b9c3		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b9c7		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b9cf		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b9d6		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b9dd		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b9e4		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b9eb		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b9f2		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b9f6		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b9fc		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>ba00		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>ba06		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>ba0c		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>ba12		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>ba17		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>ba1d		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>ba25		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>ba2b		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>ba31		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>ba37		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>ba3e		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>ba42		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>ba48		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>ba4c		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>ba50		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>ba54		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>ba58		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>ba5d		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>ba61		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>ba69		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>ba70		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>ba77		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>ba7e		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>ba85		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>ba89		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>ba8f		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>ba93		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>ba99		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>ba9f		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>baa4		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>baaa		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>bab2		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>bab8		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>babe		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>bac4		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>bacb		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>bacf		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>bad5		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>bad9		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>badd		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>bae1		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>bae5		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>baea		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>baee		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>baf6		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>bafd		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>bb04		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>bb0b		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>bb12		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>bb16		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>bb1c		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>bb20		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>bb26		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>bb2c		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>bb31		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.bb33						forth_words_start:
>bb33		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb3b		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb4b		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bb5b		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>bb6b		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>bb7b		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bb8b		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>bb9b		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bbab		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bbbb		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bbcb		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bbdb		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bbeb		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bbfb		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bc0b		78 69 74 29 20 63 72 20
.bc13						forth_words_end:
.bc13						user_words_start:
>bc13		20 20				.binary "user_words.asc"
.bc15						user_words_end:

;******  Processing file: platform/../words/headers.asm

.bc15						dictionary_start:
.bc15						nt_drop:
>bc15		04 00				        .byte 4, 0
>bc17		21 bc 60 86 65 86		        .word nt_dup, xt_drop, z_drop
>bc1d		64 72 6f 70			        .text "drop"
.bc21						nt_dup:
>bc21		03 00				        .byte 3, 0
>bc23		2c bc 66 86 73 86		        .word nt_swap, xt_dup, z_dup
>bc29		64 75 70			        .text "dup"
.bc2c						nt_swap:
>bc2c		04 00				        .byte 4, 0
>bc2e		38 bc 22 92 35 92		        .word nt_store, xt_swap, z_swap
>bc34		73 77 61 70			        .text "swap"
.bc38						nt_store:
>bc38		01 00				        .byte 1, 0
>bc3a		41 bc 0c 92 21 92		        .word nt_fetch, xt_store, z_store
>bc40		21				        .text "!"
.bc41						nt_fetch:
>bc41		01 00				        .byte 1, 0
>bc43		4a bc f3 87 05 88		        .word nt_over, xt_fetch, z_fetch
>bc49		40				        .text "@"
.bc4a						nt_over:
>bc4a		04 00				        .byte 4, 0
>bc4c		56 bc e1 8c ee 8c		        .word nt_to_r, xt_over, z_over
>bc52		6f 76 65 72			        .text "over"
.bc56						nt_to_r:
>bc56		02 0d				        .byte 2, CO+ST       ; native skips stack juggling
>bc58		60 bc 60 93 75 93		        .word nt_r_from, xt_to_r, z_to_r
>bc5e		3e 72				        .text ">r"
.bc60						nt_r_from:
>bc60		02 0d				        .byte 2, CO+ST          ; native skips stack juggling
>bc62		6a bc cc 8e de 8e		        .word nt_r_fetch, xt_r_from, z_r_from
>bc68		72 3e				        .text "r>"
.bc6a						nt_r_fetch:
>bc6a		02 0d				        .byte 2, CO+ST          ; native skips stack juggling
>bc6c		74 bc b5 8e c9 8e		        .word nt_nip, xt_r_fetch, z_r_fetch
>bc72		72 40				        .text "r@"
.bc74						nt_nip:
>bc74		03 00				        .byte 3, 0
>bc76		7f bc 10 8c 1d 8c		        .word nt_rot, xt_nip, z_nip
>bc7c		6e 69 70			        .text "nip"
.bc7f						nt_rot:
>bc7f		03 00				        .byte 3, 0
>bc81		8a bc 70 8f 8b 8f		        .word nt_not_rot, xt_rot, z_rot
>bc87		72 6f 74			        .text "rot"
.bc8a						nt_not_rot:
>bc8a		04 00				        .byte 4, 0
>bc8c		96 bc ca 9c e5 9c		        .word nt_tuck, xt_not_rot, z_not_rot
>bc92		2d 72 6f 74			        .text "-rot"
.bc96						nt_tuck:
>bc96		04 00				        .byte 4, 0
>bc98		a2 bc 81 93 9a 93		        .word nt_comma, xt_tuck, z_tuck
>bc9e		74 75 63 6b			        .text "tuck"
.bca2						nt_comma:
>bca2		01 00				        .byte 1, 0
>bca4		ab bc ab 83 b9 83		        .word nt_c_fetch, xt_comma, z_comma
>bcaa		2c				        .text ","
.bcab						nt_c_fetch:
>bcab		02 00				        .byte 2, 0
>bcad		b5 bc 2d 83 36 83		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bcb3		63 40				        .text "c@"
.bcb5						nt_c_store:
>bcb5		02 00				        .byte 2, 0
>bcb7		bf bc 37 83 42 83		        .word nt_plus_store, xt_c_store, z_c_store
>bcbd		63 21				        .text "c!"
.bcbf						nt_plus_store:
>bcbf		02 00				        .byte 2, 0
>bcc1		c9 bc 42 8e 61 8e		        .word nt_zero, xt_plus_store, z_plus_store
>bcc7		2b 21				        .text "+!"
.bcc9						nt_zero:
>bcc9		01 00				        .byte 1, 0
>bccb		d2 bc 46 9e 4c 9e		        .word nt_one, xt_zero, z_zero
>bcd1		30				        .text "0"
.bcd2						nt_one:
>bcd2		01 00				        .byte 1, 0
>bcd4		db bc e0 9d e8 9d		        .word nt_two, xt_one, z_one
>bcda		31				        .text "1"
.bcdb						nt_two:
>bcdb		01 00				        .byte 1, 0
>bcdd		e4 bc 11 9e 19 9e		        .word nt_execute, xt_two, z_two
>bce3		32				        .text "2"
.bce4						nt_execute:
>bce4		07 00				        .byte 7, 0
>bce6		f3 bc de 87 e4 87		        .word nt_emit, xt_execute, z_execute
>bcec		65 78 65 63 75 74 65		        .text "execute"
.bcf3						nt_emit:
>bcf3		04 08				        .byte 4, NN
>bcf5		ff bc 8c 86 96 86		        .word nt_type, xt_emit, z_emit
>bcfb		65 6d 69 74			        .text "emit"
.bcff						nt_type:
>bcff		04 00				        .byte 4, 0
>bd01		0b bd b8 94 e2 94		        .word nt_dot, xt_type, z_type
>bd07		74 79 70 65			        .text "type"
.bd0b						nt_dot:
>bd0b		01 00				        .byte 1, 0
>bd0d		14 bd f6 85 17 86		        .word nt_u_dot, xt_dot, z_dot
>bd13		2e				        .text "."
.bd14						nt_u_dot:
>bd14		02 00				        .byte 2, 0
>bd16		1e bd e3 94 ee 94		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd1c		75 2e				        .text "u."
.bd1e						nt_u_dot_r:
>bd1e		03 00				        .byte 3, 0
>bd20		29 bd ef 94 10 95		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd26		75 2e 72			        .text "u.r"
.bd29						nt_dot_r:
>bd29		02 00				        .byte 2, 0
>bd2b		33 bd 32 86 5f 86		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd31		2e 72				        .text ".r"
.bd33						nt_d_dot:
>bd33		02 00				        .byte 2, 0
>bd35		3d bd cf 9e ed 9e		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd3b		64 2e				        .text "d."
.bd3d						nt_d_dot_r:
>bd3d		03 00				        .byte 3, 0
>bd3f		48 bd ee 9e 18 9f		        .word nt_m_star_slash, xt_d_dot_r, z_d_dot_r
>bd45		64 2e 72			        .text "d.r"
.bd48						nt_m_star_slash:
>bd48		03 00				        .byte 3, 0
>bd4a		53 bd 19 9f 7f 9f		        .word nt_ud_dot, xt_m_star_slash, z_m_star_slash
>bd50		6d 2a 2f			        .text "m*/"
.bd53						nt_ud_dot:
>bd53		03 00				        .byte 3, 0
>bd55		5e bd cc 9f de 9f		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd5b		75 64 2e			        .text "ud."
.bd5e						nt_ud_dot_r:
>bd5e		04 00				        .byte 4, 0
>bd60		6a bd df 9f fd 9f		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd66		75 64 2e 72			        .text "ud.r"
.bd6a						nt_question:
>bd6a		01 00				        .byte 1, 0
>bd6c		73 bd 38 99 3e 99		        .word nt_false, xt_question, z_question
>bd72		3f				        .text "?"
.bd73						nt_false:
>bd73		05 00				        .byte 5, 0
>bd75		80 bd 46 9e 4c 9e		        .word nt_true, xt_false, z_false
>bd7b		66 61 6c 73 65			        .text "false"
.bd80						nt_true:
>bd80		04 00				        .byte 4, 0
>bd82		8c bd 78 93 80 93		        .word nt_space, xt_true, z_true
>bd88		74 72 75 65			        .text "true"
.bd8c						nt_space:
>bd8c		05 00				        .byte 5, 0
>bd8e		99 bd bc 91 c1 91		        .word nt_two_dup, xt_space, z_space
>bd94		73 70 61 63 65			        .text "space"
.bd99						nt_two_dup:
>bd99		04 00				        .byte 4, 0
>bd9b		a5 bd a3 93 ba 93		        .word nt_question_dup, xt_two_dup, z_two_dup
>bda1		32 64 75 70			        .text "2dup"
.bda5						nt_question_dup:
>bda5		04 00				        .byte 4, 0
>bda7		b1 bd a1 8e b4 8e		        .word nt_plus, xt_question_dup, z_question_dup
>bdad		3f 64 75 70			        .text "?dup"
.bdb1						nt_plus:
>bdb1		01 00				        .byte 1, 0
>bdb3		ba bd 2f 8e 41 8e		        .word nt_minus, xt_plus, z_plus
>bdb9		2b				        .text "+"
.bdba						nt_minus:
>bdba		01 00				        .byte 1, 0
>bdbc		c3 bd c1 8b d3 8b		        .word nt_one_minus, xt_minus, z_minus
>bdc2		2d				        .text "-"
.bdc3						nt_one_minus:
>bdc3		02 00				        .byte 2, 0
>bdc5		cd bd b9 8c c4 8c		        .word nt_one_plus, xt_one_minus, z_one_minus
>bdcb		31 2d				        .text "1-"
.bdcd						nt_one_plus:
>bdcd		02 00				        .byte 2, 0
>bdcf		d7 bd c5 8c ce 8c		        .word nt_two_star, xt_one_plus, z_one_plus
>bdd5		31 2b				        .text "1+"
.bdd7						nt_two_star:
>bdd7		02 00				        .byte 2, 0
>bdd9		e1 bd 46 94 4d 94		        .word nt_two_slash, xt_two_star, z_two_star
>bddf		32 2a				        .text "2*"
.bde1						nt_two_slash:
>bde1		02 00				        .byte 2, 0
>bde3		eb bd 3b 94 45 94		        .word nt_abs, xt_two_slash, z_two_slash
>bde9		32 2f				        .text "2/"
.bdeb						nt_abs:
>bdeb		03 00				        .byte 3, 0
>bded		f6 bd cf 80 e3 80		        .word nt_dabs, xt_abs, z_abs
>bdf3		61 62 73			        .text "abs"
.bdf6						nt_dabs:
>bdf6		04 00				        .byte 4, 0
>bdf8		02 be 95 9e b3 9e		        .word nt_and, xt_dabs, z_dabs
>bdfe		64 61 62 73			        .text "dabs"
.be02						nt_and:
>be02		03 00				        .byte 3, 0
>be04		0d be 90 82 a1 82		        .word nt_or, xt_and, z_and
>be0a		61 6e 64			        .text "and"
.be0d						nt_or:
>be0d		02 00				        .byte 2, 0
>be0f		17 be cf 8c e0 8c		        .word nt_xor, xt_or, z_or
>be15		6f 72				        .text "or"
.be17						nt_xor:
>be17		03 00				        .byte 3, 0
>be19		22 be 5f 96 70 96		        .word nt_rshift, xt_xor, z_xor
>be1f		78 6f 72			        .text "xor"
.be22						nt_rshift:
>be22		06 00				        .byte 6, 0
>be24		30 be 8c 8f 9f 8f		        .word nt_lshift, xt_rshift, z_rshift
>be2a		72 73 68 69 66 74		        .text "rshift"
.be30						nt_lshift:
>be30		06 00				        .byte 6, 0
>be32		3e be f8 8a 0b 8b		        .word nt_pick, xt_lshift, z_lshift
>be38		6c 73 68 69 66 74		        .text "lshift"
.be3e						nt_pick:
>be3e		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be40		4a be 1e 8e 2e 8e		        .word nt_char, xt_pick, z_pick
>be46		70 69 63 6b			        .text "pick"
.be4a						nt_char:
>be4a		04 00				        .byte 4, 0
>be4c		56 be 53 83 69 83		        .word nt_bracket_char, xt_char, z_char
>be52		63 68 61 72			        .text "char"
.be56						nt_bracket_char:
>be56		06 03				        .byte 6, CO+IM
>be58		64 be 0d 83 13 83		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>be5e		5b 63 68 61 72 5d		        .text "[char]"
.be64						nt_char_plus:
>be64		05 00				        .byte 5, 0
>be66		71 be c5 8c ce 8c		        .word nt_chars, xt_char_plus, z_char_plus ; same as 1+
>be6c		63 68 61 72 2b			        .text "char+"
.be71						nt_chars:
>be71		05 00				        .byte 5, 0      ; deleted during compile
>be73		7e be 6a 83 6d 83		        .word nt_cells, xt_chars, z_chars
>be79		63 68 61 72 73			        .text "chars"
.be7e						nt_cells:
>be7e		05 00				        .byte 5, 0
>be80		8b be 46 94 4d 94		        .word nt_cell_plus, xt_cells, z_cells  ; same as 2*
>be86		63 65 6c 6c 73			        .text "cells"
.be8b						nt_cell_plus:
>be8b		05 00				        .byte 5, 0
>be8d		98 be 43 83 52 83		        .word nt_here, xt_cell_plus, z_cell_plus
>be93		63 65 6c 6c 2b			        .text "cell+"
.be98						nt_here:
>be98		04 00				        .byte 4, 0
>be9a		a4 be f4 88 fe 88		        .word nt_equal, xt_here, z_here
>bea0		68 65 72 65			        .text "here"
.bea4						nt_equal:
>bea4		01 00				        .byte 1, 0
>bea6		ad be 67 87 82 87		        .word nt_not_equals, xt_equal, z_equal
>beac		3d				        .text "="
.bead						nt_not_equals:
>bead		02 00				        .byte 2, 0
>beaf		b7 be 1e 8c 3b 8c		        .word nt_less_than, xt_not_equals, z_not_equals
>beb5		3c 3e				        .text "<>"
.beb7						nt_less_than:
>beb7		01 00				        .byte 1, 0
>beb9		c0 be c8 89 dc 89		        .word nt_u_less_than, xt_less_than, z_less_than
>bebf		3c				        .text "<"
.bec0						nt_u_less_than:
>bec0		02 00				        .byte 2, 0
>bec2		ca be 27 95 3c 95		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bec8		75 3c				        .text "u<"
.beca						nt_u_greater_than:
>beca		02 00				        .byte 2, 0
>becc		d4 be 11 95 26 95		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bed2		75 3e				        .text "u>"
.bed4						nt_greater_than:
>bed4		01 00				        .byte 1, 0
>bed6		dd be df 88 f3 88		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bedc		3e				        .text ">"
.bedd						nt_zero_equal:
>bedd		02 00				        .byte 2, 0
>bedf		e7 be 71 96 82 96		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bee5		30 3d				        .text "0="
.bee7						nt_zero_unequal:
>bee7		03 00				        .byte 3, 0
>bee9		f2 be a7 96 b6 96		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>beef		30 3c 3e			        .text "0<>"
.bef2						nt_zero_greater:
>bef2		02 00				        .byte 2, 0
>bef4		fc be 83 96 96 96		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>befa		30 3e				        .text "0>"
.befc						nt_zero_less:
>befc		02 00				        .byte 2, 0
>befe		06 bf 97 96 a6 96		        .word nt_min, xt_zero_less, z_zero_less
>bf04		30 3c				        .text "0<"
.bf06						nt_min:
>bf06		03 00				        .byte 3, 0
>bf08		11 bf a5 8b c0 8b		        .word nt_max, xt_min, z_min
>bf0e		6d 69 6e			        .text "min"
.bf11						nt_max:
>bf11		03 00				        .byte 3, 0
>bf13		1c bf 89 8b a4 8b		        .word nt_two_drop, xt_max, z_max
>bf19		6d 61 78			        .text "max"
.bf1c						nt_two_drop:
>bf1c		05 00				        .byte 5, 0
>bf1e		29 bf 9b 93 a2 93		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf24		32 64 72 6f 70			        .text "2drop"
.bf29						nt_two_swap:
>bf29		05 00				        .byte 5, 0
>bf2b		36 bf 74 94 97 94		        .word nt_two_over, xt_two_swap, z_two_swap
>bf31		32 73 77 61 70			        .text "2swap"
.bf36						nt_two_over:
>bf36		05 00				        .byte 5, 0
>bf38		43 bf dd 93 f4 93		        .word nt_two_store, xt_two_over, z_two_over
>bf3e		32 6f 76 65 72			        .text "2over"
.bf43						nt_two_store:
>bf43		02 00				        .byte 2, 0
>bf45		4d bf 4e 94 73 94		        .word nt_two_fetch, xt_two_store, z_two_store
>bf4b		32 21				        .text "2!"
.bf4d						nt_two_fetch:
>bf4d		02 00				        .byte 2, 0
>bf4f		57 bf bb 93 dc 93		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bf55		32 40				        .text "2@"
.bf57						nt_two_variable:
>bf57		09 00				        .byte 9, 0
>bf59		68 bf bd 9f cb 9f		        .word nt_two_constant, xt_two_variable, z_two_variable
>bf5f		32 76 61 72 69 61 62 6c		        .text "2variable"
>bf67		65
.bf68						nt_two_constant:
>bf68		09 00				        .byte 9, 0
>bf6a		79 bf 80 9f a4 9f		        .word nt_two_literal, xt_two_constant, z_two_constant
>bf70		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bf78		74
.bf79						nt_two_literal:
>bf79		08 02				        .byte 8, IM
>bf7b		89 bf a5 9f bc 9f		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bf81		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bf89						nt_two_r_fetch:
>bf89		03 0d				        .byte 3, CO+ST          ; native skips stack juggling
>bf8b		94 bf f5 93 1b 94		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bf91		32 72 40			        .text "2r@"
.bf94						nt_two_r_from:
>bf94		03 0d				        .byte 3, CO+ST          ; native skips stack juggling
>bf96		9f bf 1e 94 38 94		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bf9c		32 72 3e			        .text "2r>"
.bf9f						nt_two_to_r:
>bf9f		03 0d				        .byte 3, CO+ST       ; native skips stack juggling
>bfa1		aa bf 98 94 b5 94		        .word nt_invert, xt_two_to_r, z_two_to_r
>bfa7		32 3e 72			        .text "2>r"
.bfaa						nt_invert:
>bfaa		06 00				        .byte 6, 0
>bfac		b8 bf 3d 89 4c 89		        .word nt_negate, xt_invert, z_invert
>bfb2		69 6e 76 65 72 74		        .text "invert"
.bfb8						nt_negate:
>bfb8		06 00				        .byte 6, 0
>bfba		c6 bf ff 8b 0f 8c		        .word nt_dnegate, xt_negate, z_negate
>bfc0		6e 65 67 61 74 65		        .text "negate"
.bfc6						nt_dnegate:
>bfc6		07 00				        .byte 7, 0
>bfc8		d5 bf b4 9e ce 9e		        .word nt_c_comma, xt_dnegate, z_dnegate
>bfce		64 6e 65 67 61 74 65		        .text "dnegate"
.bfd5						nt_c_comma:
>bfd5		02 00				        .byte 2, 0
>bfd7		df bf 22 83 2c 83		        .word nt_bounds, xt_c_comma, z_c_comma
>bfdd		63 2c				        .text "c,"
.bfdf						nt_bounds:
>bfdf		06 00				        .byte 6, 0
>bfe1		ed bf 78 9a 90 9a		        .word nt_spaces, xt_bounds, z_bounds
>bfe7		62 6f 75 6e 64 73		        .text "bounds"
.bfed						nt_spaces:
>bfed		06 00				        .byte 6, 0
>bfef		fb bf c2 91 db 91		        .word nt_bl, xt_spaces, z_spaces
>bff5		73 70 61 63 65 73		        .text "spaces"
.bffb						nt_bl:
>bffb		02 00				        .byte 2, 0
>bffd		05 c0 04 83 0c 83		        .word nt_minus_trailing, xt_bl, z_bl
>c003		62 6c				        .text "bl"
.c005						nt_minus_trailing:
>c005		09 00				        .byte 9, 0
>c007		16 c0 f2 a0 2e a1		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c00d		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c015		67
.c016						nt_minus_leading:
>c016		08 00				        .byte 8, 0
>c018		26 c0 d9 a0 f1 a0		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c01e		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c026						nt_slash_string:
>c026		07 00				        .byte 7, 0
>c028		35 c0 ce a1 ed a1		        .word nt_refill, xt_slash_string, z_slash_string
>c02e		2f 73 74 72 69 6e 67		        .text "/string"
.c035						nt_refill:
>c035		06 00				        .byte 6, 0
>c037		43 c0 1e 8f 5f 8f		        .word nt_accept, xt_refill, z_refill
>c03d		72 65 66 69 6c 6c		        .text "refill"
.c043						nt_accept:
>c043		06 08				        .byte 6, NN
>c045		51 c0 e4 80 dc 81		        .word nt_input_to_r, xt_accept, z_accept
>c04b		61 63 63 65 70 74		        .text "accept"
.c051						nt_input_to_r:
>c051		07 08				        .byte 7, NN
>c053		60 c0 e7 9b fc 9b		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c059		69 6e 70 75 74 3e 72		        .text "input>r"
.c060						nt_r_to_input:
>c060		07 08				        .byte 7, NN
>c062		6f c0 f4 9d 0b 9e		        .word nt_unused, xt_r_to_input, z_r_to_input
>c068		72 3e 69 6e 70 75 74		        .text "r>input"
.c06f						nt_unused:
>c06f		06 00				        .byte 6, 0
>c071		7d c0 dc 95 eb 95		        .word nt_depth, xt_unused, z_unused
>c077		75 6e 75 73 65 64		        .text "unused"
.c07d						nt_depth:
>c07d		05 00				        .byte 5, 0
>c07f		8a c0 18 85 26 85		        .word nt_key, xt_depth, z_depth
>c085		64 65 70 74 68			        .text "depth"
.c08a						nt_key:
>c08a		03 00				        .byte 3, 0
>c08c		95 c0 80 89 89 89		        .word nt_keyq, xt_key, z_key
>c092		6b 65 79			        .text "key"
.c095						nt_keyq:
>c095		04 00				        .byte 4, 0
>c097		a1 c0 8d 89 9b 89		        .word nt_allot, xt_keyq, z_keyq
>c09d		6b 65 79 3f			        .text "key?"
.c0a1						nt_allot:
>c0a1		05 00				        .byte 5, 0
>c0a3		ae c0 27 82 8f 82		        .word nt_create, xt_allot, z_allot
>c0a9		61 6c 6c 6f 74			        .text "allot"
.c0ae						nt_create:
>c0ae		06 00				        .byte 6, 0
>c0b0		bc c0 0b 84 ea 84		        .word nt_does, xt_create, z_create
>c0b6		63 72 65 61 74 65		        .text "create"
.c0bc						nt_does:
>c0bc		05 03				        .byte 5, CO+IM
>c0be		c9 c0 b5 85 c3 85		        .word nt_variable, xt_does, z_does
>c0c4		64 6f 65 73 3e			        .text "does>"
.c0c9						nt_variable:
>c0c9		08 00				        .byte 8, 0
>c0cb		d9 c0 ec 95 fa 95		        .word nt_constant, xt_variable, z_variable
>c0d1		76 61 72 69 61 62 6c 65		        .text "variable"
.c0d9						nt_constant:
>c0d9		08 00				        .byte 8, 0
>c0db		e9 c0 c6 83 f0 83		        .word nt_value, xt_constant, z_constant
>c0e1		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c0e9						nt_value:
>c0e9		05 00				        .byte 5, 0
>c0eb		f6 c0 c6 83 f0 83		        .word nt_to, xt_value, z_value          ; same code as CONSTANT
>c0f1		76 61 6c 75 65			        .text "value"
.c0f6						nt_to:
>c0f6		02 0a				        .byte 2, NN+IM
>c0f8		00 c1 56 92 91 92		        .word nt_s_to_d, xt_to, z_to
>c0fe		74 6f				        .text "to"
.c100						nt_s_to_d:
>c100		03 00				        .byte 3, 0
>c102		0b c1 bd 90 ce 90		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c108		73 3e 64			        .text "s>d"
.c10b						nt_d_to_s:
>c10b		03 00				        .byte 3, 0
>c10d		16 c1 8f 9e 94 9e		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c113		64 3e 73			        .text "d>s"
.c116						nt_d_minus:
>c116		02 00				        .byte 2, 0
>c118		20 c1 4d 9e 6d 9e		        .word nt_d_plus, xt_d_minus, z_d_minus
>c11e		64 2d				        .text "d-"
.c120						nt_d_plus:
>c120		02 00				        .byte 2, 0
>c122		2a c1 6e 9e 8e 9e		        .word nt_erase, xt_d_plus, z_d_plus
>c128		64 2b				        .text "d+"
.c12a						nt_erase:
>c12a		05 00				        .byte 5, 0
>c12c		37 c1 90 87 dd 87		        .word nt_blank, xt_erase, z_erase
>c132		65 72 61 73 65			        .text "erase"
.c137						nt_blank:
>c137		05 00				        .byte 5, 0
>c139		44 c1 83 87 dd 87		        .word nt_fill, xt_blank, z_blank
>c13f		62 6c 61 6e 6b			        .text "blank"
.c144						nt_fill:
>c144		04 00				        .byte 4, 0
>c146		50 c1 9b 87 dd 87		        .word nt_find_name, xt_fill, z_fill
>c14c		66 69 6c 6c			        .text "fill"
.c150						nt_find_name:
>c150		09 00				        .byte 9, 0
>c152		61 c1 3a 9b 7d 9b		        .word nt_tick, xt_find_name, z_find_name
>c158		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c160		65
.c161						nt_tick:
>c161		01 00				        .byte 1, 0
>c163		6a c1 36 92 55 92		        .word nt_bracket_tick, xt_tick, z_tick
>c169		27				        .text "'"
.c16a						nt_bracket_tick:
>c16a		03 03				        .byte 3, CO+IM
>c16c		75 c1 14 83 1a 83		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c172		5b 27 5d			        .text "[']"
.c175						nt_name_to_int:
>c175		08 00				        .byte 8, 0
>c177		85 c1 83 9c 9f 9c		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c17d		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c185						nt_int_to_name:
>c185		08 00				        .byte 8, 0
>c187		95 c1 fd 9b 6d 9c		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c18d		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c195						nt_name_to_string:
>c195		0b 00				        .byte 11, 0
>c197		a8 c1 a0 9c b6 9c		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c19d		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1a5		69 6e 67
.c1a8						nt_to_body:
>c1a8		05 00				        .byte 5, 0
>c1aa		b5 c1 92 92 b4 92		        .word nt_defer, xt_to_body, z_to_body
>c1b0		3e 62 6f 64 79			        .text ">body"
.c1b5						nt_defer:
>c1b5		05 00				        .byte 5, 0
>c1b7		c2 c1 f2 84 03 85		        .word nt_latestxt, xt_defer, z_defer
>c1bd		64 65 66 65 72			        .text "defer"
.c1c2						nt_latestxt:
>c1c2		08 00				        .byte 8, 0
>c1c4		d2 c1 7c 9c 82 9c		        .word nt_latestnt, xt_latestxt, z_latestxt
>c1ca		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c1d2						nt_latestnt:
>c1d2		08 00				        .byte 8, 0
>c1d4		e2 c1 6e 9c 7b 9c		        .word nt_parse_name, xt_latestnt, z_latestnt
>c1da		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c1e2						nt_parse_name:
>c1e2		0a 08				        .byte 10, NN
>c1e4		f4 c1 2d 8d 1d 8e		        .word nt_parse, xt_parse_name, z_parse_name
>c1ea		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c1f2		6d 65
.c1f4						nt_parse:
>c1f4		05 00				        .byte 5, 0
>c1f6		01 c2 88 8d 1d 8e		        .word nt_execute_parsing, xt_parse, z_parse
>c1fc		70 61 72 73 65			        .text "parse"
.c201						nt_execute_parsing:
>c201		0f 00				        .byte 15, 0
>c203		18 c2 13 9b 39 9b		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c209		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c211		70 61 72 73 69 6e 67
.c218						nt_source:
>c218		06 00				        .byte 6, 0
>c21a		26 c2 9c 91 b0 91		        .word nt_source_id, xt_source, z_source
>c220		73 6f 75 72 63 65		        .text "source"
.c226						nt_source_id:
>c226		09 00				        .byte 9, 0
>c228		37 c2 b1 91 bb 91		        .word nt_colon, xt_source_id, z_source_id
>c22e		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c236		64
.c237						nt_colon:
>c237		01 00				        .byte 1, 0
>c239		40 c2 6e 83 8e 83		        .word nt_semicolon, xt_colon, z_colon
>c23f		3a				        .text ":"
.c240						nt_semicolon:
>c240		01 03				        .byte 1, CO+IM
>c242		49 c2 cf 90 3b 91		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c248		3b				        .text ";"
.c249						nt_colon_noname:
>c249		07 00				        .byte 7, 0
>c24b		58 c2 8f 83 aa 83		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c251		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c258						nt_compile_comma:
>c258		08 08				        .byte 8, NN
>c25a		68 c2 b7 96 6a 97		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c260		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c268						nt_left_bracket:
>c268		01 03				        .byte 1, IM+CO
>c26a		71 c2 b5 89 b9 89		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c270		5b				        .text "["
.c271						nt_right_bracket:
>c271		01 02				        .byte 1, IM
>c273		7a c2 69 8f 6f 8f		        .word nt_literal, xt_right_bracket, z_right_bracket
>c279		5d				        .text "]"
.c27a						nt_literal:
>c27a		07 03				        .byte 7, IM+CO
>c27c		89 c2 dd 89 1a 8a		        .word nt_sliteral, xt_literal, z_literal
>c282		6c 69 74 65 72 61 6c		        .text "literal"
.c289						nt_sliteral:
>c289		08 03				        .byte 8, CO+IM
>c28b		99 c2 ee a1 31 a2		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c291		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c299						nt_dot_quote:
>c299		02 03				        .byte 2, CO+IM
>c29b		a3 c2 27 86 31 86		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c2a1		2e 22				        .text ".", $22
.c2a3						nt_s_quote:
>c2a3		02 0a				        .byte 2, IM+NN
>c2a5		ad c2 b9 8f a2 90		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c2ab		73 22				        .text "s", $22
.c2ad						nt_s_backslash_quote:
>c2ad		03 02				        .byte 3, IM
>c2af		b8 c2 a0 8f a9 8f		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c2b5		73 5c 22			        .text "s", $5C, $22
.c2b8						nt_postpone:
>c2b8		08 03				        .byte 8, IM+CO
>c2ba		c8 c2 62 8e a0 8e		        .word nt_immediate, xt_postpone, z_postpone
>c2c0		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c2c8						nt_immediate:
>c2c8		09 00				        .byte 9, 0
>c2ca		d9 c2 31 89 3c 89		        .word nt_compile_only, xt_immediate, z_immediate
>c2d0		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c2d8		65
.c2d9						nt_compile_only:
>c2d9		0c 00				        .byte 12, 0
>c2db		ed c2 ba 83 c5 83		        .word nt_never_native, xt_compile_only, z_compile_only
>c2e1		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c2e9		6f 6e 6c 79
.c2ed						nt_never_native:
>c2ed		0c 00				        .byte 12, 0
>c2ef		01 c3 bc 9c c9 9c		        .word nt_always_native, xt_never_native, z_never_native
>c2f5		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c2fd		74 69 76 65
.c301						nt_always_native:
>c301		0d 00				        .byte 13, 0
>c303		16 c3 64 9a 71 9a		        .word nt_allow_native, xt_always_native, z_always_native
>c309		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c311		61 74 69 76 65
.c316						nt_allow_native:
>c316		0c 00				        .byte 12, 0
>c318		2a c3 58 9a 63 9a		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c31e		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c326		74 69 76 65
.c32a						nt_nc_limit:
>c32a		08 08				        .byte 8, NN
>c32c		3a c3 b7 9c bc 9c		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c332		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c33a						nt_strip_underflow:
>c33a		0f 08				        .byte 15, NN
>c33c		51 c3 0c 9e 11 9e		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c342		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c34a		64 65 72 66 6c 6f 77
.c351						nt_abort:
>c351		05 00				        .byte 5, 0
>c353		5e c3 5e 80 af 80		        .word nt_abort_quote, xt_abort, z_abort
>c359		61 62 6f 72 74			        .text "abort"
.c35e						nt_abort_quote:
>c35e		06 0b				        .byte 6, CO+IM+NN
>c360		6c c3 af 80 b9 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c366		61 62 6f 72 74 22		        .text "abort", $22
.c36c						nt_do:
>c36c		02 0b				        .byte 2, CO+IM+NN
>c36e		76 c3 51 85 6a 85		        .word nt_question_do, xt_do, z_do
>c374		64 6f				        .text "do"
.c376						nt_question_do:
>c376		03 0b				        .byte 3, CO+IM+NN
>c378		81 c3 27 85 6a 85		        .word nt_i, xt_question_do, z_question_do
>c37e		3f 64 6f			        .text "?do"
.c381						nt_i:
>c381		01 01				        .byte 1, CO
>c383		8a c3 18 89 2c 89		        .word nt_j, xt_i, z_i
>c389		69				        .text "i"
.c38a						nt_j:
>c38a		01 01				        .byte 1, CO
>c38c		93 c3 66 89 7f 89		        .word nt_loop, xt_j, z_j
>c392		6a				        .text "j"
.c393						nt_loop:
>c393		04 03				        .byte 4, CO+IM
>c395		9f c3 44 8a bc 8a		        .word nt_plus_loop, xt_loop, z_loop
>c39b		6c 6f 6f 70			        .text "loop"
.c39f						nt_plus_loop:
>c39f		05 03				        .byte 5, CO+IM
>c3a1		ac c3 58 8a bc 8a		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3a7		2b 6c 6f 6f 70			        .text "+loop"
.c3ac						nt_exit:
>c3ac		04 05				        .byte 4, AN+CO
>c3ae		b8 c3 f2 87 f3 87		        .word nt_unloop, xt_exit, z_exit
>c3b4		65 78 69 74			        .text "exit"
.c3b8						nt_unloop:
>c3b8		06 01				        .byte 6, CO
>c3ba		c6 c3 c5 95 d4 95		        .word nt_leave, xt_unloop, z_unloop
>c3c0		75 6e 6c 6f 6f 70		        .text "unloop"
.c3c6						nt_leave:
>c3c6		05 03				        .byte 5, CO+IM
>c3c8		d3 c3 9f 89 b4 89		        .word nt_recurse, xt_leave, z_leave
>c3ce		6c 65 61 76 65			        .text "leave"
.c3d3						nt_recurse:
>c3d3		07 0b				        .byte 7, CO+IM+NN
>c3d5		e2 c3 e1 8e 1d 8f		        .word nt_quit, xt_recurse, z_recurse
>c3db		72 65 63 75 72 73 65		        .text "recurse"
.c3e2						nt_quit:
>c3e2		04 00				        .byte 4, 0
>c3e4		ee c3 60 80 af 80		        .word nt_begin, xt_quit, z_quit
>c3ea		71 75 69 74			        .text "quit"
.c3ee						nt_begin:
>c3ee		05 03				        .byte 5, CO+IM
>c3f0		fb c3 f4 88 fe 88		        .word nt_again, xt_begin, z_begin
>c3f6		62 65 67 69 6e			        .text "begin"
.c3fb						nt_again:
>c3fb		05 03				        .byte 5, CO+IM
>c3fd		08 c4 1f 82 25 82		        .word nt_state, xt_again, z_again
>c403		61 67 61 69 6e			        .text "again"
.c408						nt_state:
>c408		05 00				        .byte 5, 0
>c40a		15 c4 01 92 0b 92		        .word nt_evaluate, xt_state, z_state
>c410		73 74 61 74 65			        .text "state"
.c415						nt_evaluate:
>c415		08 00				        .byte 8, 0
>c417		25 c4 8b 88 de 88		        .word nt_base, xt_evaluate, z_evaluate
>c41d		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c425						nt_base:
>c425		04 00				        .byte 4, 0
>c427		31 c4 fb 82 03 83		        .word nt_digit_question, xt_base, z_base
>c42d		62 61 73 65			        .text "base"
.c431						nt_digit_question:
>c431		06 00				        .byte 6, 0
>c433		3f c4 de 9a 12 9b		        .word nt_number, xt_digit_question, z_digit_question
>c439		64 69 67 69 74 3f		        .text "digit?"
.c43f						nt_number:
>c43f		06 00				        .byte 6, 0
>c441		4d c4 e6 9c df 9d		        .word nt_to_number, xt_number, z_number
>c447		6e 75 6d 62 65 72		        .text "number"
.c44d						nt_to_number:
>c44d		07 00				        .byte 7, 0
>c44f		5c c4 c0 92 5f 93		        .word nt_hex, xt_to_number, z_to_number
>c455		3e 6e 75 6d 62 65 72		        .text ">number"
.c45c						nt_hex:
>c45c		03 00				        .byte 3, 0
>c45e		67 c4 ff 88 05 89		        .word nt_decimal, xt_hex, z_hex
>c464		68 65 78			        .text "hex"
.c467						nt_decimal:
>c467		07 00				        .byte 7, 0
>c469		76 c4 eb 84 f1 84		        .word nt_count, xt_decimal, z_decimal
>c46f		64 65 63 69 6d 61 6c		        .text "decimal"
.c476						nt_count:
>c476		05 00				        .byte 5, 0
>c478		83 c4 f1 83 04 84		        .word nt_m_star, xt_count, z_count
>c47e		63 6f 75 6e 74			        .text "count"
.c483						nt_m_star:
>c483		02 00				        .byte 2, 0
>c485		8d c4 0c 8b 26 8b		        .word nt_um_star, xt_m_star, z_m_star
>c48b		6d 2a				        .text "m*"
.c48d						nt_um_star:
>c48d		03 00				        .byte 3, 0
>c48f		98 c4 7f 95 c4 95		        .word nt_star, xt_um_star, z_um_star
>c495		75 6d 2a			        .text "um*"
.c498						nt_star:
>c498		01 00				        .byte 1, 0
>c49a		a1 c4 dc 91 e4 91		        .word nt_um_slash_mod, xt_star, z_star
>c4a0		2a				        .text "*"
.c4a1						nt_um_slash_mod:
>c4a1		06 00				        .byte 6, 0
>c4a3		af c4 3d 95 7e 95		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c4a9		75 6d 2f 6d 6f 64		        .text "um/mod"
.c4af						nt_sm_slash_rem:
>c4af		06 00				        .byte 6, 0
>c4b1		bd c4 73 91 9b 91		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c4b7		73 6d 2f 72 65 6d		        .text "sm/rem"
.c4bd						nt_fm_slash_mod:
>c4bd		06 00				        .byte 6, 0
>c4bf		cb c4 4e 88 84 88		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c4c5		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c4cb						nt_slash:
>c4cb		01 00				        .byte 1, 0
>c4cd		d4 c4 51 91 72 91		        .word nt_slash_mod, xt_slash, z_slash
>c4d3		2f				        .text "/"
.c4d4						nt_slash_mod:
>c4d4		04 00				        .byte 4, 0
>c4d6		e0 c4 58 91 72 91		        .word nt_mod, xt_slash_mod, z_slash_mod
>c4dc		2f 6d 6f 64			        .text "/mod"
.c4e0						nt_mod:
>c4e0		03 00				        .byte 3, 0
>c4e2		eb c4 d4 8b dc 8b		        .word nt_star_slash_mod, xt_mod, z_mod
>c4e8		6d 6f 64			        .text "mod"
.c4eb						nt_star_slash_mod:
>c4eb		05 00				        .byte 5, 0
>c4ed		f8 c4 f1 91 00 92		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c4f3		2a 2f 6d 6f 64			        .text "*/mod"
.c4f8						nt_star_slash:
>c4f8		02 00				        .byte 2, 0
>c4fa		02 c5 e5 91 f0 91		        .word nt_backslash, xt_star_slash, z_star_slash
>c500		2a 2f				        .text "*/"
.c502						nt_backslash:
>c502		01 02				        .byte 1, IM
>c504		0b c5 d0 82 fa 82		        .word nt_move, xt_backslash, z_backslash
>c50a		5c				        .byte '\'
.c50b						nt_move:
>c50b		04 08				        .byte 4, NN
>c50d		17 c5 dd 8b fe 8b		        .word nt_cmove_up, xt_move, z_move
>c513		6d 6f 76 65			        .text "move"
.c517						nt_cmove_up:
>c517		06 00				        .byte 6, 0
>c519		25 c5 39 a0 73 a0		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c51f		63 6d 6f 76 65 3e		        .text "cmove>"
.c525						nt_cmove:
>c525		05 00				        .byte 5, 0
>c527		32 c5 fe 9f 38 a0		        .word nt_pad, xt_cmove, z_cmove
>c52d		63 6d 6f 76 65			        .text "cmove"
.c532						nt_pad:
>c532		03 00				        .byte 3, 0
>c534		3d c5 ef 8c fe 8c		        .word nt_cleave, xt_pad, z_pad
>c53a		70 61 64			        .text "pad"
.c53d						nt_cleave:
>c53d		06 00				        .byte 6, 0
>c53f		4b c5 91 9a dd 9a		        .word nt_hexstore, xt_cleave, z_cleave
>c545		63 6c 65 61 76 65		        .text "cleave"
.c54b						nt_hexstore:
>c54b		08 00				        .byte 8, 0
>c54d		5b c5 89 9b db 9b		        .word nt_within, xt_hexstore, z_hexstore
>c553		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c55b						nt_within:
>c55b		06 00				        .byte 6, 0
>c55d		69 c5 05 96 1a 96		        .word nt_to_in, xt_within, z_within
>c563		77 69 74 68 69 6e		        .text "within"
.c569						nt_to_in:
>c569		03 00				        .byte 3, 0
>c56b		74 c5 b5 92 bf 92		        .word nt_less_number_sign, xt_to_in, z_to_in
>c571		3e 69 6e			        .text ">in"
.c574						nt_less_number_sign:
>c574		02 00				        .byte 2, 0
>c576		7e c5 ba 89 c7 89		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c57c		3c 23				        .text "<#"
.c57e						nt_number_sign:
>c57e		01 00				        .byte 1, 0
>c580		87 c5 3c 8c 6c 8c		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c586		23				        .text "#"
.c587						nt_number_sign_s:
>c587		02 00				        .byte 2, 0
>c589		91 c5 8f 8c 9f 8c		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c58f		23 73				        .text "#s"
.c591						nt_number_sign_greater:
>c591		02 00				        .byte 2, 0
>c593		9b c5 6d 8c 8e 8c		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c599		23 3e				        .text "#>"
.c59b						nt_hold:
>c59b		04 00				        .byte 4, 0
>c59d		a7 c5 06 89 17 89		        .word nt_sign, xt_hold, z_hold
>c5a3		68 6f 6c 64			        .text "hold"
.c5a7						nt_sign:
>c5a7		04 00				        .byte 4, 0
>c5a9		b3 c5 3c 91 50 91		        .word nt_output, xt_sign, z_sign
>c5af		73 69 67 6e			        .text "sign"
.c5b3						nt_output:
>c5b3		06 00				        .byte 6, 0
>c5b5		c1 c5 e9 9d f3 9d		        .word nt_input, xt_output, z_output
>c5bb		6f 75 74 70 75 74		        .text "output"
.c5c1						nt_input:
>c5c1		05 00				        .byte 5, 0
>c5c3		ce c5 dc 9b e6 9b		        .word nt_havekey, xt_input, z_input
>c5c9		69 6e 70 75 74			        .text "input"
.c5ce						nt_havekey:
>c5ce		07 00				        .byte 7, 0
>c5d0		dd c5 7e 9b 88 9b		        .word nt_cr, xt_havekey, z_havekey
>c5d6		68 61 76 65 6b 65 79		        .text "havekey"
.c5dd						nt_cr:
>c5dd		02 00				        .byte 2, 0
>c5df		e7 c5 05 84 0a 84		        .word nt_page, xt_cr, z_cr
>c5e5		63 72				        .text "cr"
.c5e7						nt_page:
>c5e7		04 00				        .byte 4, 0
>c5e9		f3 c5 ff 8c 1c 8d		        .word nt_at_xy, xt_page, z_page
>c5ef		70 61 67 65			        .text "page"
.c5f3						nt_at_xy:
>c5f3		05 00				        .byte 5, 0
>c5f5		00 c6 a2 82 cf 82		        .word nt_marker, xt_at_xy, z_at_xy
>c5fb		61 74 2d 78 79			        .text "at-xy"
.c600						nt_marker:
>c600		06 02				        .byte 6, IM
>c602		0e c6 27 8b 53 8b		        .word nt_words, xt_marker, z_marker
>c608		6d 61 72 6b 65 72		        .text "marker"
.c60e						nt_words:
>c60e		05 00				        .byte 5, 0
>c610		1b c6 fb 99 57 9a		        .word nt_wordsize, xt_words, z_words
>c616		77 6f 72 64 73			        .text "words"
.c61b						nt_wordsize:
>c61b		08 00				        .byte 8, 0
>c61d		2b c6 25 9e 45 9e		        .word nt_aligned, xt_wordsize, z_wordsize
>c623		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c62b						nt_aligned:
>c62b		07 00				        .byte 7, 0
>c62d		3a c6 26 82 26 82		        .word nt_align, xt_aligned, z_aligned   ; same code as ALIGN
>c633		61 6c 69 67 6e 65 64		        .text "aligned"
.c63a						nt_align:
>c63a		05 00				        .byte 5, 0
>c63c		47 c6 26 82 26 82		        .word nt_bell, xt_align, z_align
>c642		61 6c 69 67 6e			        .text "align"
.c647						nt_bell:
>c647		04 00				        .byte 4, 0
>c649		53 c6 72 9a 77 9a		        .word nt_dump, xt_bell, z_bell
>c64f		62 65 6c 6c			        .text "bell"
.c653						nt_dump:
>c653		04 00				        .byte 4, 0
>c655		5f c6 bd 98 23 99		        .word nt_dot_s, xt_dump, z_dump
>c65b		64 75 6d 70			        .text "dump"
.c65f						nt_dot_s:
>c65f		02 00				        .byte 2, 0
>c661		69 c6 79 98 bc 98		        .word +, xt_dot_s, z_dot_s
>c667		2e 73				        .text ".s"
.c669						+
.c669						nt_disasm:
>c669		06 00				        .byte 6, 0
>c66b		77 c6 5a a2 60 a2		        .word +, xt_disasm, z_disasm
>c671		64 69 73 61 73 6d		        .text "disasm"
.c677						+
.c677						nt_compare:
>c677		07 00				        .byte 7, 0
>c679		86 c6 74 a0 d8 a0		        .word nt_search, xt_compare, z_compare
>c67f		63 6f 6d 70 61 72 65		        .text "compare"
.c686						nt_search:
>c686		06 08				        .byte 6, NN
>c688		94 c6 2f a1 cd a1		        .word +, xt_search, z_search
>c68e		73 65 61 72 63 68		        .text "search"
.c694						+
.c694						nt_environment_q:
>c694		0c 00				        .byte 12, 0
>c696		a8 c6 ae 86 2a 87		        .word +, xt_environment_q, z_environment_q
>c69c		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c6a4		65 6e 74 3f
.c6a8						+
.c6a8						nt_find:
>c6a8		04 00				        .byte 4, 0
>c6aa		b4 c6 06 88 4d 88		        .word nt_word, xt_find, z_find
>c6b0		66 69 6e 64			        .text "find"
.c6b4						nt_word:
>c6b4		04 00				        .byte 4, 0
>c6b6		c0 c6 1b 96 5e 96		        .word nt_paren, xt_word, z_word
>c6bc		77 6f 72 64			        .text "word"
.c6c0						nt_paren:
>c6c0		01 02				        .byte 1, IM
>c6c2		c9 c6 1d 8d 2c 8d		        .word nt_dot_paren, xt_paren, z_paren
>c6c8		28				        .text "("
.c6c9						nt_dot_paren:
>c6c9		02 02				        .byte 2, IM
>c6cb		d3 c6 18 86 26 86		        .word nt_if, xt_dot_paren, z_dot_paren
>c6d1		2e 28				        .text ".("
.c6d3						nt_if:
>c6d3		02 0b				        .byte 2, IM+CO+NN
>c6d5		dd c6 2d 89 30 89		        .word nt_then, xt_if, z_if
>c6db		69 66				        .text "if"
.c6dd						nt_then:
>c6dd		04 0b				        .byte 4, IM+CO+NN
>c6df		e9 c6 7f 86 8b 86		        .word nt_else, xt_then, z_then
>c6e5		74 68 65 6e			        .text "then"
.c6e9						nt_else:
>c6e9		04 0b				        .byte 4, IM+CO+NN
>c6eb		f5 c6 74 86 8b 86		        .word nt_repeat, xt_else, z_else
>c6f1		65 6c 73 65			        .text "else"
.c6f5						nt_repeat:
>c6f5		06 0b				        .byte 6, IM+CO+NN
>c6f7		03 c7 60 8f 69 8f		        .word nt_until, xt_repeat, z_repeat
>c6fd		72 65 70 65 61 74		        .text "repeat"
.c703						nt_until:
>c703		05 0b				        .byte 5, IM+CO+NN
>c705		10 c7 d5 95 db 95		        .word nt_while, xt_until, z_until
>c70b		75 6e 74 69 6c			        .text "until"
.c710						nt_while:
>c710		05 0b				        .byte 5, IM+CO+NN
>c712		1d c7 fb 95 04 96		        .word nt_case, xt_while, z_while
>c718		77 68 69 6c 65			        .text "while"
.c71d						nt_case:
>c71d		04 0b				        .byte 4, IM+CO+NN
>c71f		29 c7 46 9e 4c 9e		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c725		63 61 73 65			        .text "case"
.c729						nt_of:
>c729		02 0b				        .byte 2, IM+CO+NN
>c72b		33 c7 a0 8c b8 8c		        .word nt_endof, xt_of, z_of
>c731		6f 66				        .text "of"
.c733						nt_endof:
>c733		05 0b				        .byte 5, IM+CO+NN
>c735		40 c7 74 86 8b 86		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c73b		65 6e 64 6f 66			        .text "endof"
.c740						nt_endcase:
>c740		07 0b				        .byte 7, IM+CO+NN
>c742		4f c7 96 86 ad 86		        .word nt_defer_fetch, xt_endcase, z_endcase
>c748		65 6e 64 63 61 73 65		        .text "endcase"
.c74f						nt_defer_fetch:
>c74f		06 00				        .byte 6, 0
>c751		5d c7 04 85 0d 85		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c757		64 65 66 65 72 40		        .text "defer@"
.c75d						nt_defer_store:
>c75d		06 00				        .byte 6, 0
>c75f		6b c7 0e 85 17 85		        .word nt_is, xt_defer_store, z_defer_store
>c765		64 65 66 65 72 21		        .text "defer!"
.c76b						nt_is:
>c76b		02 02				        .byte 2, IM
>c76d		75 c7 4d 89 65 89		        .word nt_action_of, xt_is, z_is
>c773		69 73				        .text "is"
.c775						nt_action_of:
>c775		09 02				        .byte 9, IM
>c777		86 c7 06 82 1e 82		        .word nt_useraddr, xt_action_of, z_action_of
>c77d		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c785		66
.c786						nt_useraddr:
>c786		08 00				        .byte 8, 0
>c788		96 c7 1a 9e 24 9e		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c78e		75 73 65 72 61 64 64 72		        .text "useraddr"
.c796						nt_buffer_colon:
>c796		07 00				        .byte 7, 0
>c798		a5 c7 1b 83 21 83		        .word +, xt_buffer_colon, z_buffer_colon
>c79e		62 75 66 66 65 72 3a		        .text "buffer:"
.c7a5						+
.c7a5						nt_buffstatus:
>c7a5		0a 00				        .byte 10, 0
>c7a7		b7 c7 a6 b0 ab b0		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7ad		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7b5		75 73
.c7b7						nt_buffblocknum:
>c7b7		0c 00				        .byte 12, 0
>c7b9		cb c7 70 b0 75 b0		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c7bf		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c7c7		6b 6e 75 6d
.c7cb						nt_blkbuffer:
>c7cb		09 00				        .byte 9, 0
>c7cd		dc c7 66 ae 73 ae		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c7d3		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c7db		72
.c7dc						nt_scr:
>c7dc		03 08				        .byte 3, NN
>c7de		e7 c7 28 b1 2d b1		        .word nt_blk, xt_scr, z_scr
>c7e4		73 63 72			        .text "scr"
.c7e7						nt_blk:
>c7e7		03 08				        .byte 3, NN
>c7e9		f2 c7 61 ae 66 ae		        .word nt_block_write, xt_blk, z_blk
>c7ef		62 6c 6b			        .text "blk"
.c7f2						nt_block_write:
>c7f2		0b 08				        .byte 11, NN
>c7f4		05 c8 5d b0 6b b0		        .word nt_block_write_vector, xt_block_write, z_block_write
>c7fa		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c802		69 74 65
.c805						nt_block_write_vector:
>c805		12 08				        .byte 18, NN
>c807		1f c8 6b b0 70 b0		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c80d		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c815		69 74 65 2d 76 65 63 74 6f 72
.c81f						nt_block_read:
>c81f		0a 08				        .byte 10, NN
>c821		31 c8 45 b0 53 b0		        .word nt_block_read_vector, xt_block_read, z_block_read
>c827		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c82f		61 64
.c831						nt_block_read_vector:
>c831		11 08				        .byte 17, NN
>c833		4a c8 53 b0 58 b0		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c839		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c841		61 64 2d 76 65 63 74 6f 72
.c84a						nt_save_buffers:
>c84a		0c 00				        .byte 12, 0
>c84c		5e c8 0d b1 27 b1		        .word nt_block, xt_save_buffers, z_save_buffers
>c852		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c85a		66 65 72 73
.c85e						nt_block:
>c85e		05 00				        .byte 5, 0
>c860		6b c8 74 ae c6 ae		        .word nt_update, xt_block, z_block
>c866		62 6c 6f 63 6b			        .text "block"
.c86b						nt_update:
>c86b		06 00				        .byte 6, 0
>c86d		79 c8 72 b1 7a b1		        .word nt_buffer, xt_update, z_update
>c873		75 70 64 61 74 65		        .text "update"
.c879						nt_buffer:
>c879		06 00				        .byte 6, 0
>c87b		87 c8 75 b0 a5 b0		        .word nt_empty_buffers, xt_buffer, z_buffer
>c881		62 75 66 66 65 72		        .text "buffer"
.c887						nt_empty_buffers:
>c887		0d 00				        .byte 13, 0
>c889		9c c8 ab b0 b1 b0		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c88f		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c897		66 66 65 72 73
.c89c						nt_flush:
>c89c		05 00				        .byte 5, 0
>c89e		a9 c8 b2 b0 bb b0		        .word nt_load, xt_flush, z_flush
>c8a4		66 6c 75 73 68			        .text "flush"
.c8a9						nt_load:
>c8a9		04 00				        .byte 4, 0
>c8ab		b5 c8 c9 b0 0c b1		        .word nt_thru, xt_load, z_load
>c8b1		6c 6f 61 64			        .text "load"
.c8b5						nt_thru:
>c8b5		04 00				        .byte 4, 0
>c8b7		c1 c8 2d b1 71 b1		        .word +, xt_thru, z_thru
>c8bd		74 68 72 75			        .text "thru"
.c8c1						+
.c8c1						nt_list:
>c8c1		04 00				        .byte 4, 0
>c8c3		cd c8 bc b0 c8 b0		        .word nt_block_c65_init, xt_list, z_list
>c8c9		6c 69 73 74			        .text "list"
.c8cd						nt_block_c65_init:
>c8cd		0e 00				        .byte 14, 0
>c8cf		e3 c8 c7 ae fc ae		        .word +, xt_block_c65_init, z_block_c65_init
>c8d5		62 6c 6f 63 6b 2d 63 36		        .text "block-c65-init"
>c8dd		35 2d 69 6e 69 74
.c8e3						+
.c8e3						nt_block_ramdrive_init:
>c8e3		13 00				        .byte 19, 0
>c8e5		fe c8 1f af 2c af		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c8eb		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c8f3		6d 64 72 69 76 65 2d 69 6e 69 74
.c8fe						+
.c8fe						nt_definitions:
>c8fe		0b 00				        .byte 11, 0
>c900		11 c9 b0 b2 b8 b2		        .word nt_wordlist, xt_definitions, z_definitions
>c906		64 65 66 69 6e 69 74 69		        .text "definitions"
>c90e		6f 6e 73
.c911						nt_wordlist:
>c911		08 00				        .byte 8, 0
>c913		21 c9 1b b4 31 b4		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c919		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c921						nt_search_wordlist:
>c921		0f 00				        .byte 15, 0
>c923		38 c9 54 b3 c7 b3		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c929		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c931		6f 72 64 6c 69 73 74
.c938						nt_set_current:
>c938		0b 00				        .byte 11, 0
>c93a		4b c9 c8 b3 d3 b3		        .word nt_get_current, xt_set_current, z_set_current
>c940		73 65 74 2d 63 75 72 72		        .text "set-current"
>c948		65 6e 74
.c94b						nt_get_current:
>c94b		0b 00				        .byte 11, 0
>c94d		5e c9 c0 b2 ca b2		        .word nt_set_order, xt_get_current, z_get_current
>c953		67 65 74 2d 63 75 72 72		        .text "get-current"
>c95b		65 6e 74
.c95e						nt_set_order:
>c95e		09 00				        .byte 9, 0
>c960		6f c9 d4 b3 07 b4		        .word nt_get_order, xt_set_order, z_set_order
>c966		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c96e		72
.c96f						nt_get_order:
>c96f		09 00				        .byte 9, 0
>c971		80 c9 cb b2 f3 b2		        .word nt_root_wordlist, xt_get_order, z_get_order
>c977		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c97f		72
.c980						nt_root_wordlist:
>c980		0d 00				        .byte 13, 0
>c982		95 c9 4b b3 53 b3		        .word +, xt_root_wordlist, z_root_wordlist
>c988		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c990		64 6c 69 73 74
.c995						+
.c995						nt_assembler_wordlist:
>c995		12 00				        .byte 18, 0
>c997		af c9 11 9e 19 9e		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c99d		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c9a5		72 2d 77 6f 72 64 6c 69 73 74
.c9af						+
.c9af						nt_editor_wordlist:
>c9af		0f 00				        .byte 15, 0
>c9b1		c6 c9 e0 9d e8 9d		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9b7		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9bf		6f 72 64 6c 69 73 74
.c9c6						+
.c9c6						nt_forth_wordlist:
>c9c6		0e 00				        .byte 14, 0
>c9c8		dc c9 46 9e 4c 9e		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c9ce		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9d6		72 64 6c 69 73 74
.c9dc						nt_only:
>c9dc		04 00				        .byte 4, 0
>c9de		e8 c9 f4 b2 fa b2		        .word nt_also, xt_only, z_only
>c9e4		6f 6e 6c 79			        .text "only"
.c9e8						nt_also:
>c9e8		04 00				        .byte 4, 0
>c9ea		f4 c9 a0 b2 af b2		        .word nt_previous, xt_also, z_also
>c9f0		61 6c 73 6f			        .text "also"
.c9f4						nt_previous:
>c9f4		08 00				        .byte 8, 0
>c9f6		04 ca 3e b3 4a b3		        .word nt_to_order, xt_previous, z_previous
>c9fc		70 72 65 76 69 6f 75 73		        .text "previous"
.ca04						nt_to_order:
>ca04		06 00				        .byte 6, 0
>ca06		12 ca 08 b4 1a b4		        .word nt_order, xt_to_order, z_to_order
>ca0c		3e 6f 72 64 65 72		        .text ">order"
.ca12						nt_order:
>ca12		05 00				        .byte 5, 0
>ca14		1f ca fb b2 25 b3		        .word nt_forth, xt_order, z_order
>ca1a		6f 72 64 65 72			        .text "order"
.ca1f						nt_forth:
>ca1f		05 00				        .byte 5, 0
>ca21		2c ca b9 b2 bf b2		        .word +, xt_forth, z_forth
>ca27		66 6f 72 74 68			        .text "forth"
.ca2c						+
>ca2c		03 08				nt_see: .byte 3, NN
>ca2e		37 ca 3f 99 fa 99		        .word +, xt_see, z_see
>ca34		73 65 65			        .text "see"
.ca37						+
.ca37						nt_ed:
>ca37		03 08				        .byte 3, NN
>ca39		42 ca 6e a8 71 a8		        .word +, xt_ed, z_ed
>ca3f		65 64 3a			        .text "ed:"
.ca42						+
.ca42						nt_cold:
>ca42		04 00				        .byte 4, 0
>ca44		4e ca 00 80 af 80		        .word nt_bye, xt_cold, z_cold
>ca4a		63 6f 6c 64			        .text "cold"
.ca4e						nt_bye:
>ca4e		03				        .byte 3         ; length of word strings
>ca4f		00				        .byte 0         ; status byte
>ca50		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca52		76 98				        .word xt_bye    ; start of code block (xt of this word)
>ca54		79 98				        .word z_bye     ; end of code (RTS)
>ca56		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca59						root_dictionary_start:
.ca59						nt_root_set_order:
>ca59		09 00				        .byte 9, 0
>ca5b		6a ca d4 b3 07 b4		        .word nt_root_forth, xt_set_order, z_set_order
>ca61		73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca69		72
.ca6a						nt_root_forth:
>ca6a		05 00				        .byte 5, 0
>ca6c		77 ca b9 b2 bf b2		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca72		66 6f 72 74 68			        .text "forth"
.ca77						nt_root_forth_wordlist:
>ca77		0e 00				        .byte 14, 0
>ca79		8d ca 46 9e 4c 9e		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca7f		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca87		72 64 6c 69 73 74
.ca8d						nt_root_words:
>ca8d		05 00				        .byte 5, 0
>ca8f		00 00 fb 99 57 9a		        .word 0000, xt_words, z_words
>ca95		77 6f 72 64 73			        .text "words"
.ca9a						editor_dictionary_start:
.ca9a						nt_editor_o:
>ca9a		01 00				        .byte 1, 0
>ca9c		a3 ca 5a b2 9f b2		        .word nt_editor_line, xt_editor_o, z_editor_o
>caa2		6f				        .text "o"
.caa3						nt_editor_line:
>caa3		04 00				        .byte 4, 0
>caa5		af ca 41 b2 59 b2		        .word nt_editor_l, xt_editor_line, z_editor_line
>caab		6c 69 6e 65			        .text "line"
.caaf						nt_editor_l:
>caaf		01 00				        .byte 1, 0
>cab1		b8 ca c7 b1 40 b2		        .word nt_editor_el, xt_editor_l, z_editor_l
>cab7		6c				        .text "l"
.cab8						nt_editor_el:
>cab8		02 00				        .byte 2, 0
>caba		c2 ca b5 b1 c6 b1		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cac0		65 6c				        .text "el"
.cac2						nt_editor_erase_screen:
>cac2		0c 00				        .byte 12, 0
>cac4		d6 ca a3 b1 b4 b1		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>caca		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cad2		72 65 65 6e
.cad6						nt_editor_enter_screen:
>cad6		0c 00				        .byte 12, 0
>cad8		00 00 87 b1 a2 b1		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cade		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cae6		72 65 65 6e
.caea						assembler_dictionary_start:
.caea						nt_asm_adc_h:
>caea		05 0a						.byte 5, IM+NN
>caec		f7 ca				                .word nt_asm_adc_x
>caee		b8 a4 bd a4					.word xt_asm_adc_h, z_asm_adc_h
>caf2		61 64 63 2e 23					.text "adc.#"
.caf7						nt_asm_adc_x:
>caf7		05 0a						.byte 5, IM+NN
>caf9		04 cb				                .word nt_asm_adc_y
>cafb		bd a4 c2 a4					.word xt_asm_adc_x, z_asm_adc_x
>caff		61 64 63 2e 78					.text "adc.x"
.cb04						nt_asm_adc_y:
>cb04		05 0a						.byte 5, IM+NN
>cb06		11 cb				                .word nt_asm_adc_z
>cb08		c2 a4 c7 a4					.word xt_asm_adc_y, z_asm_adc_y
>cb0c		61 64 63 2e 79					.text "adc.y"
.cb11						nt_asm_adc_z:
>cb11		05 0a						.byte 5, IM+NN
>cb13		1e cb				                .word nt_asm_adc_zi
>cb15		c7 a4 cc a4					.word xt_asm_adc_z, z_asm_adc_z
>cb19		61 64 63 2e 7a					.text "adc.z"
.cb1e						nt_asm_adc_zi:
>cb1e		06 0a						.byte 6, IM+NN
>cb20		2c cb				                .word nt_asm_adc_ziy
>cb22		cc a4 d1 a4					.word xt_asm_adc_zi, z_asm_adc_zi
>cb26		61 64 63 2e 7a 69				.text "adc.zi"
.cb2c						nt_asm_adc_ziy:
>cb2c		07 0a						.byte 7, IM+NN
>cb2e		3b cb				                .word nt_asm_adc_zx
>cb30		d1 a4 d6 a4					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb34		61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb3b						nt_asm_adc_zx:
>cb3b		06 0a						.byte 6, IM+NN
>cb3d		49 cb				                .word nt_asm_adc_zxi
>cb3f		d6 a4 db a4					.word xt_asm_adc_zx, z_asm_adc_zx
>cb43		61 64 63 2e 7a 78				.text "adc.zx"
.cb49						nt_asm_adc_zxi:
>cb49		07 0a						.byte 7, IM+NN
>cb4b		58 cb				                .word nt_asm_and
>cb4d		db a4 e0 a4					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb51		61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb58						nt_asm_and:
>cb58		04 0a						.byte 4, IM+NN
>cb5a		64 cb				                .word nt_asm_and_h
>cb5c		e0 a4 e5 a4					.word xt_asm_and, z_asm_and
>cb60		61 6e 64 2e					.text "and."
.cb64						nt_asm_and_h:
>cb64		05 0a						.byte 5, IM+NN
>cb66		71 cb				                .word nt_asm_and_x
>cb68		e5 a4 ea a4					.word xt_asm_and_h, z_asm_and_h
>cb6c		61 6e 64 2e 23					.text "and.#"
.cb71						nt_asm_and_x:
>cb71		05 0a						.byte 5, IM+NN
>cb73		7e cb				                .word nt_asm_and_y
>cb75		ea a4 ef a4					.word xt_asm_and_x, z_asm_and_x
>cb79		61 6e 64 2e 78					.text "and.x"
.cb7e						nt_asm_and_y:
>cb7e		05 0a						.byte 5, IM+NN
>cb80		8b cb				                .word nt_asm_and_z
>cb82		ef a4 f4 a4					.word xt_asm_and_y, z_asm_and_y
>cb86		61 6e 64 2e 79					.text "and.y"
.cb8b						nt_asm_and_z:
>cb8b		05 0a						.byte 5, IM+NN
>cb8d		98 cb				                .word nt_asm_and_zi
>cb8f		f4 a4 f9 a4					.word xt_asm_and_z, z_asm_and_z
>cb93		61 6e 64 2e 7a					.text "and.z"
.cb98						nt_asm_and_zi:
>cb98		06 0a						.byte 6, IM+NN
>cb9a		a6 cb				                .word nt_asm_and_ziy
>cb9c		f9 a4 fe a4					.word xt_asm_and_zi, z_asm_and_zi
>cba0		61 6e 64 2e 7a 69				.text "and.zi"
.cba6						nt_asm_and_ziy:
>cba6		07 0a						.byte 7, IM+NN
>cba8		b5 cb				                .word nt_asm_and_zx
>cbaa		fe a4 03 a5					.word xt_asm_and_ziy, z_asm_and_ziy
>cbae		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cbb5						nt_asm_and_zx:
>cbb5		06 0a						.byte 6, IM+NN
>cbb7		c3 cb				                .word nt_asm_and_zxi
>cbb9		03 a5 08 a5					.word xt_asm_and_zx, z_asm_and_zx
>cbbd		61 6e 64 2e 7a 78				.text "and.zx"
.cbc3						nt_asm_and_zxi:
>cbc3		07 0a						.byte 7, IM+NN
>cbc5		d2 cb				                .word nt_asm_asl
>cbc7		08 a5 0d a5					.word xt_asm_and_zxi, z_asm_and_zxi
>cbcb		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cbd2						nt_asm_asl:
>cbd2		03 0a						.byte 3, IM+NN
>cbd4		dd cb				                .word nt_asm_asl_a
>cbd6		0d a5 12 a5					.word xt_asm_asl, z_asm_asl
>cbda		61 73 6c					.text "asl"
.cbdd						nt_asm_asl_a:
>cbdd		05 0a						.byte 5, IM+NN
>cbdf		ea cb				                .word nt_asm_asl_x
>cbe1		12 a5 17 a5					.word xt_asm_asl_a, z_asm_asl_a
>cbe5		61 73 6c 2e 61					.text "asl.a"
.cbea						nt_asm_asl_x:
>cbea		05 0a						.byte 5, IM+NN
>cbec		f7 cb				                .word nt_asm_asl_z
>cbee		17 a5 1c a5					.word xt_asm_asl_x, z_asm_asl_x
>cbf2		61 73 6c 2e 78					.text "asl.x"
.cbf7						nt_asm_asl_z:
>cbf7		05 0a						.byte 5, IM+NN
>cbf9		04 cc				                .word nt_asm_asl_zx
>cbfb		1c a5 21 a5					.word xt_asm_asl_z, z_asm_asl_z
>cbff		61 73 6c 2e 7a					.text "asl.z"
.cc04						nt_asm_asl_zx:
>cc04		06 0a						.byte 6, IM+NN
>cc06		12 cc				                .word nt_asm_bcc
>cc08		21 a5 26 a5					.word xt_asm_asl_zx, z_asm_asl_zx
>cc0c		61 73 6c 2e 7a 78				.text "asl.zx"
.cc12						nt_asm_bcc:
>cc12		03 0a						.byte 3, IM+NN
>cc14		1d cc				                .word nt_asm_bcs
>cc16		26 a5 2b a5					.word xt_asm_bcc, z_asm_bcc
>cc1a		62 63 63					.text "bcc"
.cc1d						nt_asm_bcs:
>cc1d		03 0a						.byte 3, IM+NN
>cc1f		28 cc				                .word nt_asm_beq
>cc21		2b a5 32 a5					.word xt_asm_bcs, z_asm_bcs
>cc25		62 63 73					.text "bcs"
.cc28						nt_asm_beq:
>cc28		03 0a						.byte 3, IM+NN
>cc2a		33 cc				                .word nt_asm_bit
>cc2c		32 a5 37 a5					.word xt_asm_beq, z_asm_beq
>cc30		62 65 71					.text "beq"
.cc33						nt_asm_bit:
>cc33		03 0a						.byte 3, IM+NN
>cc35		3e cc				                .word nt_asm_bit_h
>cc37		37 a5 3c a5					.word xt_asm_bit, z_asm_bit
>cc3b		62 69 74					.text "bit"
.cc3e						nt_asm_bit_h:
>cc3e		05 0a						.byte 5, IM+NN
>cc40		4b cc				                .word nt_asm_bit_x
>cc42		3c a5 41 a5					.word xt_asm_bit_h, z_asm_bit_h
>cc46		62 69 74 2e 23					.text "bit.#"
.cc4b						nt_asm_bit_x:
>cc4b		05 0a						.byte 5, IM+NN
>cc4d		58 cc				                .word nt_asm_bit_z
>cc4f		41 a5 46 a5					.word xt_asm_bit_x, z_asm_bit_x
>cc53		62 69 74 2e 78					.text "bit.x"
.cc58						nt_asm_bit_z:
>cc58		05 0a						.byte 5, IM+NN
>cc5a		65 cc				                .word nt_asm_bit_zx
>cc5c		46 a5 4b a5					.word xt_asm_bit_z, z_asm_bit_z
>cc60		62 69 74 2e 7a					.text "bit.z"
.cc65						nt_asm_bit_zx:
>cc65		06 0a						.byte 6, IM+NN
>cc67		73 cc				                .word nt_asm_bmi
>cc69		4b a5 50 a5					.word xt_asm_bit_zx, z_asm_bit_zx
>cc6d		62 69 74 2e 7a 78				.text "bit.zx"
.cc73						nt_asm_bmi:
>cc73		03 0a						.byte 3, IM+NN
>cc75		7e cc				                .word nt_asm_bne
>cc77		50 a5 55 a5					.word xt_asm_bmi, z_asm_bmi
>cc7b		62 6d 69					.text "bmi"
.cc7e						nt_asm_bne:
>cc7e		03 0a						.byte 3, IM+NN
>cc80		89 cc				                .word nt_asm_bpl
>cc82		55 a5 5a a5					.word xt_asm_bne, z_asm_bne
>cc86		62 6e 65					.text "bne"
.cc89						nt_asm_bpl:
>cc89		03 0a						.byte 3, IM+NN
>cc8b		94 cc				                .word nt_asm_bra
>cc8d		5a a5 5f a5					.word xt_asm_bpl, z_asm_bpl
>cc91		62 70 6c					.text "bpl"
.cc94						nt_asm_bra:
>cc94		03 0a						.byte 3, IM+NN
>cc96		9f cc				                .word nt_asm_brk
>cc98		5f a5 64 a5					.word xt_asm_bra, z_asm_bra
>cc9c		62 72 61					.text "bra"
.cc9f						nt_asm_brk:
>cc9f		03 0a						.byte 3, IM+NN
>cca1		aa cc				                .word nt_asm_bvc
>cca3		64 a5 69 a5					.word xt_asm_brk, z_asm_brk
>cca7		62 72 6b					.text "brk"
.ccaa						nt_asm_bvc:
>ccaa		03 0a						.byte 3, IM+NN
>ccac		b5 cc				                .word nt_asm_bvs
>ccae		69 a5 6e a5					.word xt_asm_bvc, z_asm_bvc
>ccb2		62 76 63					.text "bvc"
.ccb5						nt_asm_bvs:
>ccb5		03 0a						.byte 3, IM+NN
>ccb7		c0 cc				                .word nt_asm_clc
>ccb9		6e a5 73 a5					.word xt_asm_bvs, z_asm_bvs
>ccbd		62 76 73					.text "bvs"
.ccc0						nt_asm_clc:
>ccc0		03 0a						.byte 3, IM+NN
>ccc2		cb cc				                .word nt_asm_cld
>ccc4		73 a5 78 a5					.word xt_asm_clc, z_asm_clc
>ccc8		63 6c 63					.text "clc"
.cccb						nt_asm_cld:
>cccb		03 0a						.byte 3, IM+NN
>cccd		d6 cc				                .word nt_asm_cli
>cccf		78 a5 7d a5					.word xt_asm_cld, z_asm_cld
>ccd3		63 6c 64					.text "cld"
.ccd6						nt_asm_cli:
>ccd6		03 0a						.byte 3, IM+NN
>ccd8		e1 cc				                .word nt_asm_clv
>ccda		7d a5 82 a5					.word xt_asm_cli, z_asm_cli
>ccde		63 6c 69					.text "cli"
.cce1						nt_asm_clv:
>cce1		03 0a						.byte 3, IM+NN
>cce3		ec cc				                .word nt_asm_cmp
>cce5		82 a5 87 a5					.word xt_asm_clv, z_asm_clv
>cce9		63 6c 76					.text "clv"
.ccec						nt_asm_cmp:
>ccec		03 0a						.byte 3, IM+NN
>ccee		f7 cc				                .word nt_asm_cmp_h
>ccf0		87 a5 8c a5					.word xt_asm_cmp, z_asm_cmp
>ccf4		63 6d 70					.text "cmp"
.ccf7						nt_asm_cmp_h:
>ccf7		05 0a						.byte 5, IM+NN
>ccf9		04 cd				                .word nt_asm_cmp_x
>ccfb		8c a5 91 a5					.word xt_asm_cmp_h, z_asm_cmp_h
>ccff		63 6d 70 2e 23					.text "cmp.#"
.cd04						nt_asm_cmp_x:
>cd04		05 0a						.byte 5, IM+NN
>cd06		11 cd				                .word nt_asm_cmp_y
>cd08		91 a5 96 a5					.word xt_asm_cmp_x, z_asm_cmp_x
>cd0c		63 6d 70 2e 78					.text "cmp.x"
.cd11						nt_asm_cmp_y:
>cd11		05 0a						.byte 5, IM+NN
>cd13		1e cd				                .word nt_asm_cmp_z
>cd15		96 a5 9b a5					.word xt_asm_cmp_y, z_asm_cmp_y
>cd19		63 6d 70 2e 79					.text "cmp.y"
.cd1e						nt_asm_cmp_z:
>cd1e		05 0a						.byte 5, IM+NN
>cd20		2b cd				                .word nt_asm_cmp_zi
>cd22		9b a5 a0 a5					.word xt_asm_cmp_z, z_asm_cmp_z
>cd26		63 6d 70 2e 7a					.text "cmp.z"
.cd2b						nt_asm_cmp_zi:
>cd2b		06 0a						.byte 6, IM+NN
>cd2d		39 cd				                .word nt_asm_cmp_ziy
>cd2f		a0 a5 a5 a5					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd33		63 6d 70 2e 7a 69				.text "cmp.zi"
.cd39						nt_asm_cmp_ziy:
>cd39		07 0a						.byte 7, IM+NN
>cd3b		48 cd				                .word nt_asm_cmp_zx
>cd3d		a5 a5 aa a5					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd41		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd48						nt_asm_cmp_zx:
>cd48		06 0a						.byte 6, IM+NN
>cd4a		56 cd				                .word nt_asm_cmp_zxi
>cd4c		aa a5 af a5					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd50		63 6d 70 2e 7a 78				.text "cmp.zx"
.cd56						nt_asm_cmp_zxi:
>cd56		07 0a						.byte 7, IM+NN
>cd58		65 cd				                .word nt_asm_cpx
>cd5a		af a5 b4 a5					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd5e		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd65						nt_asm_cpx:
>cd65		03 0a						.byte 3, IM+NN
>cd67		70 cd				                .word nt_asm_cpx_h
>cd69		b4 a5 b9 a5					.word xt_asm_cpx, z_asm_cpx
>cd6d		63 70 78					.text "cpx"
.cd70						nt_asm_cpx_h:
>cd70		05 0a						.byte 5, IM+NN
>cd72		7d cd				                .word nt_asm_cpx_z
>cd74		b9 a5 be a5					.word xt_asm_cpx_h, z_asm_cpx_h
>cd78		63 70 78 2e 23					.text "cpx.#"
.cd7d						nt_asm_cpx_z:
>cd7d		05 0a						.byte 5, IM+NN
>cd7f		8a cd				                .word nt_asm_cpy
>cd81		be a5 c3 a5					.word xt_asm_cpx_z, z_asm_cpx_z
>cd85		63 70 78 2e 7a					.text "cpx.z"
.cd8a						nt_asm_cpy:
>cd8a		03 0a						.byte 3, IM+NN
>cd8c		95 cd				                .word nt_asm_cpy_h
>cd8e		c3 a5 ca a5					.word xt_asm_cpy, z_asm_cpy
>cd92		63 70 79					.text "cpy"
.cd95						nt_asm_cpy_h:
>cd95		05 0a						.byte 5, IM+NN
>cd97		a2 cd				                .word nt_asm_cpy_z
>cd99		ca a5 cf a5					.word xt_asm_cpy_h, z_asm_cpy_h
>cd9d		63 70 79 2e 23					.text "cpy.#"
.cda2						nt_asm_cpy_z:
>cda2		05 0a						.byte 5, IM+NN
>cda4		af cd				                .word nt_asm_dec
>cda6		cf a5 d4 a5					.word xt_asm_cpy_z, z_asm_cpy_z
>cdaa		63 70 79 2e 7a					.text "cpy.z"
.cdaf						nt_asm_dec:
>cdaf		03 0a						.byte 3, IM+NN
>cdb1		ba cd				                .word nt_asm_dec_a
>cdb3		d4 a5 d9 a5					.word xt_asm_dec, z_asm_dec
>cdb7		64 65 63					.text "dec"
.cdba						nt_asm_dec_a:
>cdba		05 0a						.byte 5, IM+NN
>cdbc		c7 cd				                .word nt_asm_dec_x
>cdbe		d9 a5 de a5					.word xt_asm_dec_a, z_asm_dec_a
>cdc2		64 65 63 2e 61					.text "dec.a"
.cdc7						nt_asm_dec_x:
>cdc7		05 0a						.byte 5, IM+NN
>cdc9		d4 cd				                .word nt_asm_dec_z
>cdcb		de a5 e3 a5					.word xt_asm_dec_x, z_asm_dec_x
>cdcf		64 65 63 2e 78					.text "dec.x"
.cdd4						nt_asm_dec_z:
>cdd4		05 0a						.byte 5, IM+NN
>cdd6		e1 cd				                .word nt_asm_dec_zx
>cdd8		e3 a5 e8 a5					.word xt_asm_dec_z, z_asm_dec_z
>cddc		64 65 63 2e 7a					.text "dec.z"
.cde1						nt_asm_dec_zx:
>cde1		06 0a						.byte 6, IM+NN
>cde3		ef cd				                .word nt_asm_dex
>cde5		e8 a5 ed a5					.word xt_asm_dec_zx, z_asm_dec_zx
>cde9		64 65 63 2e 7a 78				.text "dec.zx"
.cdef						nt_asm_dex:
>cdef		03 0a						.byte 3, IM+NN
>cdf1		fa cd				                .word nt_asm_dey
>cdf3		ed a5 f2 a5					.word xt_asm_dex, z_asm_dex
>cdf7		64 65 78					.text "dex"
.cdfa						nt_asm_dey:
>cdfa		03 0a						.byte 3, IM+NN
>cdfc		05 ce				                .word nt_asm_eor
>cdfe		f2 a5 f7 a5					.word xt_asm_dey, z_asm_dey
>ce02		64 65 79					.text "dey"
.ce05						nt_asm_eor:
>ce05		03 0a						.byte 3, IM+NN
>ce07		10 ce				                .word nt_asm_eor_h
>ce09		f7 a5 fc a5					.word xt_asm_eor, z_asm_eor
>ce0d		65 6f 72					.text "eor"
.ce10						nt_asm_eor_h:
>ce10		05 0a						.byte 5, IM+NN
>ce12		1d ce				                .word nt_asm_eor_x
>ce14		fc a5 01 a6					.word xt_asm_eor_h, z_asm_eor_h
>ce18		65 6f 72 2e 23					.text "eor.#"
.ce1d						nt_asm_eor_x:
>ce1d		05 0a						.byte 5, IM+NN
>ce1f		2a ce				                .word nt_asm_eor_y
>ce21		01 a6 06 a6					.word xt_asm_eor_x, z_asm_eor_x
>ce25		65 6f 72 2e 78					.text "eor.x"
.ce2a						nt_asm_eor_y:
>ce2a		05 0a						.byte 5, IM+NN
>ce2c		37 ce				                .word nt_asm_eor_z
>ce2e		06 a6 0b a6					.word xt_asm_eor_y, z_asm_eor_y
>ce32		65 6f 72 2e 79					.text "eor.y"
.ce37						nt_asm_eor_z:
>ce37		05 0a						.byte 5, IM+NN
>ce39		44 ce				                .word nt_asm_eor_zi
>ce3b		0b a6 10 a6					.word xt_asm_eor_z, z_asm_eor_z
>ce3f		65 6f 72 2e 7a					.text "eor.z"
.ce44						nt_asm_eor_zi:
>ce44		06 0a						.byte 6, IM+NN
>ce46		52 ce				                .word nt_asm_eor_ziy
>ce48		10 a6 15 a6					.word xt_asm_eor_zi, z_asm_eor_zi
>ce4c		65 6f 72 2e 7a 69				.text "eor.zi"
.ce52						nt_asm_eor_ziy:
>ce52		07 0a						.byte 7, IM+NN
>ce54		61 ce				                .word nt_asm_eor_zx
>ce56		15 a6 1a a6					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce5a		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce61						nt_asm_eor_zx:
>ce61		06 0a						.byte 6, IM+NN
>ce63		6f ce				                .word nt_asm_eor_zxi
>ce65		1a a6 1f a6					.word xt_asm_eor_zx, z_asm_eor_zx
>ce69		65 6f 72 2e 7a 78				.text "eor.zx"
.ce6f						nt_asm_eor_zxi:
>ce6f		07 0a						.byte 7, IM+NN
>ce71		7e ce				                .word nt_asm_inc
>ce73		1f a6 24 a6					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce77		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce7e						nt_asm_inc:
>ce7e		03 0a						.byte 3, IM+NN
>ce80		89 ce				                .word nt_asm_inc_a
>ce82		24 a6 29 a6					.word xt_asm_inc, z_asm_inc
>ce86		69 6e 63					.text "inc"
.ce89						nt_asm_inc_a:
>ce89		05 0a						.byte 5, IM+NN
>ce8b		96 ce				                .word nt_asm_inc_x
>ce8d		29 a6 2e a6					.word xt_asm_inc_a, z_asm_inc_a
>ce91		69 6e 63 2e 61					.text "inc.a"
.ce96						nt_asm_inc_x:
>ce96		05 0a						.byte 5, IM+NN
>ce98		a3 ce				                .word nt_asm_inc_z
>ce9a		2e a6 33 a6					.word xt_asm_inc_x, z_asm_inc_x
>ce9e		69 6e 63 2e 78					.text "inc.x"
.cea3						nt_asm_inc_z:
>cea3		05 0a						.byte 5, IM+NN
>cea5		b0 ce				                .word nt_asm_inc_zx
>cea7		33 a6 38 a6					.word xt_asm_inc_z, z_asm_inc_z
>ceab		69 6e 63 2e 7a					.text "inc.z"
.ceb0						nt_asm_inc_zx:
>ceb0		06 0a						.byte 6, IM+NN
>ceb2		be ce				                .word nt_asm_inx
>ceb4		38 a6 3d a6					.word xt_asm_inc_zx, z_asm_inc_zx
>ceb8		69 6e 63 2e 7a 78				.text "inc.zx"
.cebe						nt_asm_inx:
>cebe		03 0a						.byte 3, IM+NN
>cec0		c9 ce				                .word nt_asm_iny
>cec2		3d a6 42 a6					.word xt_asm_inx, z_asm_inx
>cec6		69 6e 78					.text "inx"
.cec9						nt_asm_iny:
>cec9		03 0a						.byte 3, IM+NN
>cecb		d4 ce				                .word nt_asm_jmp
>cecd		42 a6 47 a6					.word xt_asm_iny, z_asm_iny
>ced1		69 6e 79					.text "iny"
.ced4						nt_asm_jmp:
>ced4		03 0a						.byte 3, IM+NN
>ced6		df ce				                .word nt_asm_jmp_i
>ced8		47 a6 4c a6					.word xt_asm_jmp, z_asm_jmp
>cedc		6a 6d 70					.text "jmp"
.cedf						nt_asm_jmp_i:
>cedf		05 0a						.byte 5, IM+NN
>cee1		ec ce				                .word nt_asm_jmp_xi
>cee3		4c a6 51 a6					.word xt_asm_jmp_i, z_asm_jmp_i
>cee7		6a 6d 70 2e 69					.text "jmp.i"
.ceec						nt_asm_jmp_xi:
>ceec		06 0a						.byte 6, IM+NN
>ceee		fa ce				                .word nt_asm_jsr
>cef0		51 a6 56 a6					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cef4		6a 6d 70 2e 78 69				.text "jmp.xi"
.cefa						nt_asm_jsr:
>cefa		03 0a						.byte 3, IM+NN
>cefc		05 cf				                .word nt_asm_lda
>cefe		56 a6 5b a6					.word xt_asm_jsr, z_asm_jsr
>cf02		6a 73 72					.text "jsr"
.cf05						nt_asm_lda:
>cf05		03 0a						.byte 3, IM+NN
>cf07		10 cf				                .word nt_asm_lda_h
>cf09		5b a6 60 a6					.word xt_asm_lda, z_asm_lda
>cf0d		6c 64 61					.text "lda"
.cf10						nt_asm_lda_h:
>cf10		05 0a						.byte 5, IM+NN
>cf12		1d cf				                .word nt_asm_lda_x
>cf14		60 a6 65 a6					.word xt_asm_lda_h, z_asm_lda_h
>cf18		6c 64 61 2e 23					.text "lda.#"
.cf1d						nt_asm_lda_x:
>cf1d		05 0a						.byte 5, IM+NN
>cf1f		2a cf				                .word nt_asm_lda_y
>cf21		65 a6 6a a6					.word xt_asm_lda_x, z_asm_lda_x
>cf25		6c 64 61 2e 78					.text "lda.x"
.cf2a						nt_asm_lda_y:
>cf2a		05 0a						.byte 5, IM+NN
>cf2c		37 cf				                .word nt_asm_lda_z
>cf2e		6a a6 6f a6					.word xt_asm_lda_y, z_asm_lda_y
>cf32		6c 64 61 2e 79					.text "lda.y"
.cf37						nt_asm_lda_z:
>cf37		05 0a						.byte 5, IM+NN
>cf39		44 cf				                .word nt_asm_lda_zi
>cf3b		6f a6 74 a6					.word xt_asm_lda_z, z_asm_lda_z
>cf3f		6c 64 61 2e 7a					.text "lda.z"
.cf44						nt_asm_lda_zi:
>cf44		06 0a						.byte 6, IM+NN
>cf46		52 cf				                .word nt_asm_lda_ziy
>cf48		74 a6 79 a6					.word xt_asm_lda_zi, z_asm_lda_zi
>cf4c		6c 64 61 2e 7a 69				.text "lda.zi"
.cf52						nt_asm_lda_ziy:
>cf52		07 0a						.byte 7, IM+NN
>cf54		61 cf				                .word nt_asm_lda_zx
>cf56		79 a6 7e a6					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf5a		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf61						nt_asm_lda_zx:
>cf61		06 0a						.byte 6, IM+NN
>cf63		6f cf				                .word nt_asm_lda_zxi
>cf65		7e a6 83 a6					.word xt_asm_lda_zx, z_asm_lda_zx
>cf69		6c 64 61 2e 7a 78				.text "lda.zx"
.cf6f						nt_asm_lda_zxi:
>cf6f		07 0a						.byte 7, IM+NN
>cf71		7e cf				                .word nt_asm_ldx
>cf73		83 a6 88 a6					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf77		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf7e						nt_asm_ldx:
>cf7e		03 0a						.byte 3, IM+NN
>cf80		89 cf				                .word nt_asm_ldx_h
>cf82		88 a6 8d a6					.word xt_asm_ldx, z_asm_ldx
>cf86		6c 64 78					.text "ldx"
.cf89						nt_asm_ldx_h:
>cf89		05 0a						.byte 5, IM+NN
>cf8b		96 cf				                .word nt_asm_ldx_y
>cf8d		8d a6 92 a6					.word xt_asm_ldx_h, z_asm_ldx_h
>cf91		6c 64 78 2e 23					.text "ldx.#"
.cf96						nt_asm_ldx_y:
>cf96		05 0a						.byte 5, IM+NN
>cf98		a3 cf				                .word nt_asm_ldx_z
>cf9a		92 a6 97 a6					.word xt_asm_ldx_y, z_asm_ldx_y
>cf9e		6c 64 78 2e 79					.text "ldx.y"
.cfa3						nt_asm_ldx_z:
>cfa3		05 0a						.byte 5, IM+NN
>cfa5		b0 cf				                .word nt_asm_ldx_zy
>cfa7		97 a6 9c a6					.word xt_asm_ldx_z, z_asm_ldx_z
>cfab		6c 64 78 2e 7a					.text "ldx.z"
.cfb0						nt_asm_ldx_zy:
>cfb0		06 0a						.byte 6, IM+NN
>cfb2		be cf				                .word nt_asm_ldy
>cfb4		9c a6 a1 a6					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfb8		6c 64 78 2e 7a 79				.text "ldx.zy"
.cfbe						nt_asm_ldy:
>cfbe		03 0a						.byte 3, IM+NN
>cfc0		c9 cf				                .word nt_asm_ldy_h
>cfc2		a1 a6 a6 a6					.word xt_asm_ldy, z_asm_ldy
>cfc6		6c 64 79					.text "ldy"
.cfc9						nt_asm_ldy_h:
>cfc9		05 0a						.byte 5, IM+NN
>cfcb		d6 cf				                .word nt_asm_ldy_x
>cfcd		a6 a6 ab a6					.word xt_asm_ldy_h, z_asm_ldy_h
>cfd1		6c 64 79 2e 23					.text "ldy.#"
.cfd6						nt_asm_ldy_x:
>cfd6		05 0a						.byte 5, IM+NN
>cfd8		e3 cf				                .word nt_asm_ldy_z
>cfda		ab a6 b0 a6					.word xt_asm_ldy_x, z_asm_ldy_x
>cfde		6c 64 79 2e 78					.text "ldy.x"
.cfe3						nt_asm_ldy_z:
>cfe3		05 0a						.byte 5, IM+NN
>cfe5		f0 cf				                .word nt_asm_ldy_zx
>cfe7		b0 a6 b5 a6					.word xt_asm_ldy_z, z_asm_ldy_z
>cfeb		6c 64 79 2e 7a					.text "ldy.z"
.cff0						nt_asm_ldy_zx:
>cff0		06 0a						.byte 6, IM+NN
>cff2		fe cf				                .word nt_asm_lsr
>cff4		b5 a6 ba a6					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cff8		6c 64 79 2e 7a 78				.text "ldy.zx"
.cffe						nt_asm_lsr:
>cffe		03 0a						.byte 3, IM+NN
>d000		09 d0				                .word nt_asm_lsr_a
>d002		ba a6 bf a6					.word xt_asm_lsr, z_asm_lsr
>d006		6c 73 72					.text "lsr"
.d009						nt_asm_lsr_a:
>d009		05 0a						.byte 5, IM+NN
>d00b		16 d0				                .word nt_asm_lsr_x
>d00d		bf a6 c4 a6					.word xt_asm_lsr_a, z_asm_lsr_a
>d011		6c 73 72 2e 61					.text "lsr.a"
.d016						nt_asm_lsr_x:
>d016		05 0a						.byte 5, IM+NN
>d018		23 d0				                .word nt_asm_lsr_z
>d01a		c4 a6 c9 a6					.word xt_asm_lsr_x, z_asm_lsr_x
>d01e		6c 73 72 2e 78					.text "lsr.x"
.d023						nt_asm_lsr_z:
>d023		05 0a						.byte 5, IM+NN
>d025		30 d0				                .word nt_asm_lsr_zx
>d027		c9 a6 ce a6					.word xt_asm_lsr_z, z_asm_lsr_z
>d02b		6c 73 72 2e 7a					.text "lsr.z"
.d030						nt_asm_lsr_zx:
>d030		06 0a						.byte 6, IM+NN
>d032		3e d0				                .word nt_asm_nop
>d034		ce a6 d3 a6					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d038		6c 73 72 2e 7a 78				.text "lsr.zx"
.d03e						nt_asm_nop:
>d03e		03 0a						.byte 3, IM+NN
>d040		49 d0				                .word nt_asm_ora
>d042		d3 a6 d8 a6					.word xt_asm_nop, z_asm_nop
>d046		6e 6f 70					.text "nop"
.d049						nt_asm_ora:
>d049		03 0a						.byte 3, IM+NN
>d04b		54 d0				                .word nt_asm_ora_h
>d04d		d8 a6 dd a6					.word xt_asm_ora, z_asm_ora
>d051		6f 72 61					.text "ora"
.d054						nt_asm_ora_h:
>d054		05 0a						.byte 5, IM+NN
>d056		61 d0				                .word nt_asm_ora_x
>d058		dd a6 e2 a6					.word xt_asm_ora_h, z_asm_ora_h
>d05c		6f 72 61 2e 23					.text "ora.#"
.d061						nt_asm_ora_x:
>d061		05 0a						.byte 5, IM+NN
>d063		6e d0				                .word nt_asm_ora_y
>d065		e2 a6 e7 a6					.word xt_asm_ora_x, z_asm_ora_x
>d069		6f 72 61 2e 78					.text "ora.x"
.d06e						nt_asm_ora_y:
>d06e		05 0a						.byte 5, IM+NN
>d070		7b d0				                .word nt_asm_ora_z
>d072		e7 a6 ec a6					.word xt_asm_ora_y, z_asm_ora_y
>d076		6f 72 61 2e 79					.text "ora.y"
.d07b						nt_asm_ora_z:
>d07b		05 0a						.byte 5, IM+NN
>d07d		88 d0				                .word nt_asm_ora_zi
>d07f		ec a6 f1 a6					.word xt_asm_ora_z, z_asm_ora_z
>d083		6f 72 61 2e 7a					.text "ora.z"
.d088						nt_asm_ora_zi:
>d088		06 0a						.byte 6, IM+NN
>d08a		96 d0				                .word nt_asm_ora_ziy
>d08c		f1 a6 f8 a6					.word xt_asm_ora_zi, z_asm_ora_zi
>d090		6f 72 61 2e 7a 69				.text "ora.zi"
.d096						nt_asm_ora_ziy:
>d096		07 0a						.byte 7, IM+NN
>d098		a5 d0				                .word nt_asm_ora_zx
>d09a		f8 a6 fd a6					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d09e		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d0a5						nt_asm_ora_zx:
>d0a5		06 0a						.byte 6, IM+NN
>d0a7		b3 d0				                .word nt_asm_ora_zxi
>d0a9		fd a6 02 a7					.word xt_asm_ora_zx, z_asm_ora_zx
>d0ad		6f 72 61 2e 7a 78				.text "ora.zx"
.d0b3						nt_asm_ora_zxi:
>d0b3		07 0a						.byte 7, IM+NN
>d0b5		c2 d0				                .word nt_asm_pha
>d0b7		02 a7 07 a7					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0bb		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0c2						nt_asm_pha:
>d0c2		03 0a						.byte 3, IM+NN
>d0c4		cd d0				                .word nt_asm_php
>d0c6		07 a7 0c a7					.word xt_asm_pha, z_asm_pha
>d0ca		70 68 61					.text "pha"
.d0cd						nt_asm_php:
>d0cd		03 0a						.byte 3, IM+NN
>d0cf		d8 d0				                .word nt_asm_phx
>d0d1		0c a7 11 a7					.word xt_asm_php, z_asm_php
>d0d5		70 68 70					.text "php"
.d0d8						nt_asm_phx:
>d0d8		03 0a						.byte 3, IM+NN
>d0da		e3 d0				                .word nt_asm_phy
>d0dc		11 a7 16 a7					.word xt_asm_phx, z_asm_phx
>d0e0		70 68 78					.text "phx"
.d0e3						nt_asm_phy:
>d0e3		03 0a						.byte 3, IM+NN
>d0e5		ee d0				                .word nt_asm_pla
>d0e7		16 a7 1b a7					.word xt_asm_phy, z_asm_phy
>d0eb		70 68 79					.text "phy"
.d0ee						nt_asm_pla:
>d0ee		03 0a						.byte 3, IM+NN
>d0f0		f9 d0				                .word nt_asm_plp
>d0f2		1b a7 20 a7					.word xt_asm_pla, z_asm_pla
>d0f6		70 6c 61					.text "pla"
.d0f9						nt_asm_plp:
>d0f9		03 0a						.byte 3, IM+NN
>d0fb		04 d1				                .word nt_asm_plx
>d0fd		20 a7 25 a7					.word xt_asm_plp, z_asm_plp
>d101		70 6c 70					.text "plp"
.d104						nt_asm_plx:
>d104		03 0a						.byte 3, IM+NN
>d106		0f d1				                .word nt_asm_ply
>d108		25 a7 2a a7					.word xt_asm_plx, z_asm_plx
>d10c		70 6c 78					.text "plx"
.d10f						nt_asm_ply:
>d10f		03 0a						.byte 3, IM+NN
>d111		1a d1				                .word nt_asm_rol
>d113		2a a7 2f a7					.word xt_asm_ply, z_asm_ply
>d117		70 6c 79					.text "ply"
.d11a						nt_asm_rol:
>d11a		03 0a						.byte 3, IM+NN
>d11c		25 d1				                .word nt_asm_rol_a
>d11e		2f a7 34 a7					.word xt_asm_rol, z_asm_rol
>d122		72 6f 6c					.text "rol"
.d125						nt_asm_rol_a:
>d125		05 0a						.byte 5, IM+NN
>d127		32 d1				                .word nt_asm_rol_x
>d129		34 a7 39 a7					.word xt_asm_rol_a, z_asm_rol_a
>d12d		72 6f 6c 2e 61					.text "rol.a"
.d132						nt_asm_rol_x:
>d132		05 0a						.byte 5, IM+NN
>d134		3f d1				                .word nt_asm_rol_z
>d136		39 a7 3e a7					.word xt_asm_rol_x, z_asm_rol_x
>d13a		72 6f 6c 2e 78					.text "rol.x"
.d13f						nt_asm_rol_z:
>d13f		05 0a						.byte 5, IM+NN
>d141		4c d1				                .word nt_asm_rol_zx
>d143		3e a7 43 a7					.word xt_asm_rol_z, z_asm_rol_z
>d147		72 6f 6c 2e 7a					.text "rol.z"
.d14c						nt_asm_rol_zx:
>d14c		06 0a						.byte 6, IM+NN
>d14e		5a d1				                .word nt_asm_ror
>d150		43 a7 48 a7					.word xt_asm_rol_zx, z_asm_rol_zx
>d154		72 6f 6c 2e 7a 78				.text "rol.zx"
.d15a						nt_asm_ror:
>d15a		03 0a						.byte 3, IM+NN
>d15c		65 d1				                .word nt_asm_ror_a
>d15e		48 a7 4d a7					.word xt_asm_ror, z_asm_ror
>d162		72 6f 72					.text "ror"
.d165						nt_asm_ror_a:
>d165		05 0a						.byte 5, IM+NN
>d167		72 d1				                .word nt_asm_ror_x
>d169		4d a7 52 a7					.word xt_asm_ror_a, z_asm_ror_a
>d16d		72 6f 72 2e 61					.text "ror.a"
.d172						nt_asm_ror_x:
>d172		05 0a						.byte 5, IM+NN
>d174		7f d1				                .word nt_asm_ror_z
>d176		52 a7 57 a7					.word xt_asm_ror_x, z_asm_ror_x
>d17a		72 6f 72 2e 78					.text "ror.x"
.d17f						nt_asm_ror_z:
>d17f		05 0a						.byte 5, IM+NN
>d181		8c d1				                .word nt_asm_ror_zx
>d183		57 a7 5c a7					.word xt_asm_ror_z, z_asm_ror_z
>d187		72 6f 72 2e 7a					.text "ror.z"
.d18c						nt_asm_ror_zx:
>d18c		06 0a						.byte 6, IM+NN
>d18e		9a d1				                .word nt_asm_rti
>d190		5c a7 61 a7					.word xt_asm_ror_zx, z_asm_ror_zx
>d194		72 6f 72 2e 7a 78				.text "ror.zx"
.d19a						nt_asm_rti:
>d19a		03 0a						.byte 3, IM+NN
>d19c		a5 d1				                .word nt_asm_rts
>d19e		61 a7 66 a7					.word xt_asm_rti, z_asm_rti
>d1a2		72 74 69					.text "rti"
.d1a5						nt_asm_rts:
>d1a5		03 0a						.byte 3, IM+NN
>d1a7		b0 d1				                .word nt_asm_sbc
>d1a9		66 a7 6b a7					.word xt_asm_rts, z_asm_rts
>d1ad		72 74 73					.text "rts"
.d1b0						nt_asm_sbc:
>d1b0		03 0a						.byte 3, IM+NN
>d1b2		bb d1				                .word nt_asm_sbc_h
>d1b4		6b a7 70 a7					.word xt_asm_sbc, z_asm_sbc
>d1b8		73 62 63					.text "sbc"
.d1bb						nt_asm_sbc_h:
>d1bb		05 0a						.byte 5, IM+NN
>d1bd		c8 d1				                .word nt_asm_sbc_x
>d1bf		70 a7 75 a7					.word xt_asm_sbc_h, z_asm_sbc_h
>d1c3		73 62 63 2e 23					.text "sbc.#"
.d1c8						nt_asm_sbc_x:
>d1c8		05 0a						.byte 5, IM+NN
>d1ca		d5 d1				                .word nt_asm_sbc_y
>d1cc		75 a7 7a a7					.word xt_asm_sbc_x, z_asm_sbc_x
>d1d0		73 62 63 2e 78					.text "sbc.x"
.d1d5						nt_asm_sbc_y:
>d1d5		05 0a						.byte 5, IM+NN
>d1d7		e2 d1				                .word nt_asm_sbc_z
>d1d9		7a a7 7f a7					.word xt_asm_sbc_y, z_asm_sbc_y
>d1dd		73 62 63 2e 79					.text "sbc.y"
.d1e2						nt_asm_sbc_z:
>d1e2		05 0a						.byte 5, IM+NN
>d1e4		ef d1				                .word nt_asm_sbc_zi
>d1e6		7f a7 84 a7					.word xt_asm_sbc_z, z_asm_sbc_z
>d1ea		73 62 63 2e 7a					.text "sbc.z"
.d1ef						nt_asm_sbc_zi:
>d1ef		06 0a						.byte 6, IM+NN
>d1f1		fd d1				                .word nt_asm_sbc_ziy
>d1f3		84 a7 89 a7					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d1f7		73 62 63 2e 7a 69				.text "sbc.zi"
.d1fd						nt_asm_sbc_ziy:
>d1fd		07 0a						.byte 7, IM+NN
>d1ff		0c d2				                .word nt_asm_sbc_zx
>d201		89 a7 8e a7					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d205		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d20c						nt_asm_sbc_zx:
>d20c		06 0a						.byte 6, IM+NN
>d20e		1a d2				                .word nt_asm_sbc_zxi
>d210		8e a7 93 a7					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d214		73 62 63 2e 7a 78				.text "sbc.zx"
.d21a						nt_asm_sbc_zxi:
>d21a		07 0a						.byte 7, IM+NN
>d21c		29 d2				                .word nt_asm_sec
>d21e		93 a7 97 a7					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d222		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d229						nt_asm_sec:
>d229		03 0a						.byte 3, IM+NN
>d22b		34 d2				                .word nt_asm_sed
>d22d		97 a7 9b a7					.word xt_asm_sec, z_asm_sec
>d231		73 65 63					.text "sec"
.d234						nt_asm_sed:
>d234		03 0a						.byte 3, IM+NN
>d236		3f d2				                .word nt_asm_sei
>d238		9b a7 9f a7					.word xt_asm_sed, z_asm_sed
>d23c		73 65 64					.text "sed"
.d23f						nt_asm_sei:
>d23f		03 0a						.byte 3, IM+NN
>d241		4a d2				                .word nt_asm_sta
>d243		9f a7 a3 a7					.word xt_asm_sei, z_asm_sei
>d247		73 65 69					.text "sei"
.d24a						nt_asm_sta:
>d24a		03 0a						.byte 3, IM+NN
>d24c		55 d2				                .word nt_asm_sta_x
>d24e		a3 a7 a7 a7					.word xt_asm_sta, z_asm_sta
>d252		73 74 61					.text "sta"
.d255						nt_asm_sta_x:
>d255		05 0a						.byte 5, IM+NN
>d257		62 d2				                .word nt_asm_sta_y
>d259		a7 a7 ab a7					.word xt_asm_sta_x, z_asm_sta_x
>d25d		73 74 61 2e 78					.text "sta.x"
.d262						nt_asm_sta_y:
>d262		05 0a						.byte 5, IM+NN
>d264		6f d2				                .word nt_asm_sta_z
>d266		ab a7 af a7					.word xt_asm_sta_y, z_asm_sta_y
>d26a		73 74 61 2e 79					.text "sta.y"
.d26f						nt_asm_sta_z:
>d26f		05 0a						.byte 5, IM+NN
>d271		7c d2				                .word nt_asm_sta_zi
>d273		af a7 b3 a7					.word xt_asm_sta_z, z_asm_sta_z
>d277		73 74 61 2e 7a					.text "sta.z"
.d27c						nt_asm_sta_zi:
>d27c		06 0a						.byte 6, IM+NN
>d27e		8a d2				                .word nt_asm_sta_ziy
>d280		b3 a7 b7 a7					.word xt_asm_sta_zi, z_asm_sta_zi
>d284		73 74 61 2e 7a 69				.text "sta.zi"
.d28a						nt_asm_sta_ziy:
>d28a		07 0a						.byte 7, IM+NN
>d28c		99 d2				                .word nt_asm_sta_zx
>d28e		b7 a7 bb a7					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d292		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d299						nt_asm_sta_zx:
>d299		06 0a						.byte 6, IM+NN
>d29b		a7 d2				                .word nt_asm_sta_zxi
>d29d		bb a7 bf a7					.word xt_asm_sta_zx, z_asm_sta_zx
>d2a1		73 74 61 2e 7a 78				.text "sta.zx"
.d2a7						nt_asm_sta_zxi:
>d2a7		07 0a						.byte 7, IM+NN
>d2a9		b6 d2				                .word nt_asm_stx
>d2ab		bf a7 c3 a7					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2af		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2b6						nt_asm_stx:
>d2b6		03 0a						.byte 3, IM+NN
>d2b8		c1 d2				                .word nt_asm_stx_z
>d2ba		c3 a7 c7 a7					.word xt_asm_stx, z_asm_stx
>d2be		73 74 78					.text "stx"
.d2c1						nt_asm_stx_z:
>d2c1		05 0a						.byte 5, IM+NN
>d2c3		ce d2				                .word nt_asm_stx_zy
>d2c5		c7 a7 cb a7					.word xt_asm_stx_z, z_asm_stx_z
>d2c9		73 74 78 2e 7a					.text "stx.z"
.d2ce						nt_asm_stx_zy:
>d2ce		06 0a						.byte 6, IM+NN
>d2d0		dc d2				                .word nt_asm_sty
>d2d2		cb a7 cf a7					.word xt_asm_stx_zy, z_asm_stx_zy
>d2d6		73 74 78 2e 7a 79				.text "stx.zy"
.d2dc						nt_asm_sty:
>d2dc		03 0a						.byte 3, IM+NN
>d2de		e7 d2				                .word nt_asm_sty_z
>d2e0		cf a7 d3 a7					.word xt_asm_sty, z_asm_sty
>d2e4		73 74 79					.text "sty"
.d2e7						nt_asm_sty_z:
>d2e7		05 0a						.byte 5, IM+NN
>d2e9		f4 d2				                .word nt_asm_sty_zx
>d2eb		d3 a7 d7 a7					.word xt_asm_sty_z, z_asm_sty_z
>d2ef		73 74 79 2e 7a					.text "sty.z"
.d2f4						nt_asm_sty_zx:
>d2f4		06 0a						.byte 6, IM+NN
>d2f6		02 d3				                .word nt_asm_stz
>d2f8		d7 a7 db a7					.word xt_asm_sty_zx, z_asm_sty_zx
>d2fc		73 74 79 2e 7a 78				.text "sty.zx"
.d302						nt_asm_stz:
>d302		03 0a						.byte 3, IM+NN
>d304		0d d3				                .word nt_asm_stz_x
>d306		db a7 df a7					.word xt_asm_stz, z_asm_stz
>d30a		73 74 7a					.text "stz"
.d30d						nt_asm_stz_x:
>d30d		05 0a						.byte 5, IM+NN
>d30f		1a d3				                .word nt_asm_stz_z
>d311		df a7 e3 a7					.word xt_asm_stz_x, z_asm_stz_x
>d315		73 74 7a 2e 78					.text "stz.x"
.d31a						nt_asm_stz_z:
>d31a		05 0a						.byte 5, IM+NN
>d31c		27 d3				                .word nt_asm_stz_zx
>d31e		e3 a7 e7 a7					.word xt_asm_stz_z, z_asm_stz_z
>d322		73 74 7a 2e 7a					.text "stz.z"
.d327						nt_asm_stz_zx:
>d327		06 0a						.byte 6, IM+NN
>d329		35 d3				                .word nt_asm_tax
>d32b		e7 a7 eb a7					.word xt_asm_stz_zx, z_asm_stz_zx
>d32f		73 74 7a 2e 7a 78				.text "stz.zx"
.d335						nt_asm_tax:
>d335		03 0a						.byte 3, IM+NN
>d337		40 d3				                .word nt_asm_tay
>d339		eb a7 ef a7					.word xt_asm_tax, z_asm_tax
>d33d		74 61 78					.text "tax"
.d340						nt_asm_tay:
>d340		03 0a						.byte 3, IM+NN
>d342		4b d3				                .word nt_asm_trb
>d344		ef a7 f3 a7					.word xt_asm_tay, z_asm_tay
>d348		74 61 79					.text "tay"
.d34b						nt_asm_trb:
>d34b		03 0a						.byte 3, IM+NN
>d34d		56 d3				                .word nt_asm_trb_z
>d34f		f3 a7 f7 a7					.word xt_asm_trb, z_asm_trb
>d353		74 72 62					.text "trb"
.d356						nt_asm_trb_z:
>d356		05 0a						.byte 5, IM+NN
>d358		63 d3				                .word nt_asm_tsb
>d35a		f7 a7 fb a7					.word xt_asm_trb_z, z_asm_trb_z
>d35e		74 72 62 2e 7a					.text "trb.z"
.d363						nt_asm_tsb:
>d363		03 0a						.byte 3, IM+NN
>d365		6e d3				                .word nt_asm_tsb_z
>d367		fb a7 ff a7					.word xt_asm_tsb, z_asm_tsb
>d36b		74 73 62					.text "tsb"
.d36e						nt_asm_tsb_z:
>d36e		05 0a						.byte 5, IM+NN
>d370		7b d3				                .word nt_asm_tsx
>d372		ff a7 03 a8					.word xt_asm_tsb_z, z_asm_tsb_z
>d376		74 73 62 2e 7a					.text "tsb.z"
.d37b						nt_asm_tsx:
>d37b		03 0a						.byte 3, IM+NN
>d37d		86 d3				                .word nt_asm_txa
>d37f		03 a8 07 a8					.word xt_asm_tsx, z_asm_tsx
>d383		74 73 78					.text "tsx"
.d386						nt_asm_txa:
>d386		03 0a						.byte 3, IM+NN
>d388		91 d3				                .word nt_asm_txs
>d38a		07 a8 0b a8					.word xt_asm_txa, z_asm_txa
>d38e		74 78 61					.text "txa"
.d391						nt_asm_txs:
>d391		03 0a						.byte 3, IM+NN
>d393		9c d3				                .word nt_asm_tya
>d395		0b a8 0f a8					.word xt_asm_txs, z_asm_txs
>d399		74 78 73					.text "txs"
.d39c						nt_asm_tya:
>d39c		03 0a						.byte 3, IM+NN
>d39e		a7 d3				                .word nt_asm_arrow
>d3a0		0f a8 13 a8					.word xt_asm_tya, z_asm_tya
>d3a4		74 79 61					.text "tya"
.d3a7						nt_asm_arrow:
>d3a7		03 02				                .byte 3, IM
>d3a9		b2 d3				                .word nt_asm_back_jump
>d3ab		f4 88 fe 88			                .word xt_asm_arrow, z_asm_arrow
>d3af		2d 2d 3e			                .text "-->"
.d3b2						nt_asm_back_jump:
>d3b2		02 02				                .byte 2, IM
>d3b4		bc d3				                .word nt_asm_back_branch
>d3b6		64 a8 64 a8			                .word xt_asm_back_jump, z_asm_back_jump
>d3ba		3c 6a				                .text "<j"
.d3bc						nt_asm_back_branch:
>d3bc		02 02				                .byte 2, IM
>d3be		c6 d3				                .word nt_asm_push_a
>d3c0		65 a8 6d a8			                .word xt_asm_back_branch, z_asm_back_branch
>d3c4		3c 62				                .text "<b"
.d3c6						nt_asm_push_a:
>d3c6		06 0a				                .byte 6, IM+NN
>d3c8		00 00				                .word 0000
>d3ca		4d a8 5c a8			                .word xt_asm_push_a, z_asm_push_a
>d3ce		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix         ; unused?
=1						ix += 1
=1						str_compile        = ix         ; unused?
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix         ; unused?
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_nt         = ix
=9						ix += 1
=9						str_see_xt         = ix
=10						ix += 1
=10						str_see_size       = ix
=11						ix += 1
=11						str_disasm_sdc     = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_0bra    = ix
=14						ix += 1
=14						str_disasm_loop    = ix
=15						ix += 1
=15						str_disasm_do      = ix
=16						ix += 1
.d3d4						string_table:
>d3d4		f4 d3 f8 d3 02 d4 0d d4		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d3dc		44 d4 3c d4 31 d4 4b d4		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d3e4		51 d4 56 d4 5b d4		        .word s_see_nt, s_see_xt, s_see_size                          ; 8-10
>d3ea		8a d4 9d d4 a6 d4 af d4		        .word s_disasm_sdc, s_disasm_lit, s_disasm_0bra, s_disasm_loop, s_disasm_do ; 11-15
>d3f2		b5 d4
>d3f4		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d3f8		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d400		64 00
>d402		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d40a		64 20 00
>d40d		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d415		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d425		4f 50 51 52 53 54 55 56 57 58 59 5a
>d431		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d439		72 20 00
>d43c		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d444		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d44b		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d451		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d456		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d45b		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d463		63 69 6d 61 6c 29 3a 20 00
>d46c		66 6c 61 67 73 3a 20 43		see_flags_template:     .shift "flags: CO",0,"IM",0,"AN",0,"NN",0,"HC",0,"| UF",0,"ST",0
>d474		4f 00 49 4d 00 41 4e 00 4e 4e 00 48 43 00 7c 20
>d484		55 46 00 53 54 80
>d48a		20 53 54 41 43 4b 20 44		s_disasm_sdc: .text " STACK DEPTH CHECK", 0
>d492		45 50 54 48 20 43 48 45 43 4b 00
>d49d		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d4a5		00
>d4a6		30 42 52 41 4e 43 48 20		s_disasm_0bra: .text "0BRANCH ",0
>d4ae		00
>d4af		4c 4f 4f 50 20 00		s_disasm_loop: .text "LOOP ",0
>d4b5		44 4f 20 00			s_disasm_do: .text "DO ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d4b9						error_table:
>d4b9		d5 d4 f6 d4 16 d5 37 d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4c1		54 d5 65 d5 75 d5 a3 d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4c9		bb d5 dc d5 f1 d5 0d d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4d1		24 d6 63 d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d4d5		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d4dd		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d4ed		65 20 6d 65 6d 6f 72 79 00
>d4f6		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d4fe		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d50e		20 52 45 46 49 4c 4c 00
>d516		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d51e		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d52e		6e 6c 79 20 77 6f 72 64 00
>d537		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d53f		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d54f		20 79 65 74 00
>d554		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d55c		20 62 79 20 7a 65 72 6f 00
>d565		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d56d		66 61 69 6c 75 72 65 00
>d575		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d57d		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d58d		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d59d		64 20 2d 31 29 00
>d5a3		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d5ab		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5bb		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d5c3		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d5d3		64 20 6e 75 6d 62 65 72 00
>d5dc		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d5e4		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d5f1		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d5f9		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d609		4c 4f 54 00
>d60d		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d615		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d624		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d62c		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d63c		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d64c		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d65c		56 45 43 54 4f 52 00
>d663		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d66b		74 61 63 6b 3a 00
>d671		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d679		44 2d 53 54 52 49 4e 47
>d681		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d687		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d68c		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d694		2d 55 4e 49 54 2d 42 49 54 53
>d69e		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d6a6		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6ae		52
>d6af		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6b5		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6bb		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6c3		53 54 41 43 4b 2d 43 45 4c 4c 53
>d6ce		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d6d6		45 4c 4c 53
>d6da		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d6e2		54 53
>d6e4		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d6ea		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d6f1						doconst:
.d6f1		ca		dex		                dex             ; make room for constant
.d6f2		ca		dex		                dex
.d6f3		68		pla		                pla             ; LSB of return address
.d6f4		85 25		sta $25		                sta tmp1
.d6f6		68		pla		                pla             ; MSB of return address
.d6f7		85 26		sta $26		                sta tmp1+1
.d6f9		a0 01		ldy #$01	                ldy #1
.d6fb		b1 25		lda ($25),y	                lda (tmp1),y
.d6fd		95 00		sta $00,x	                sta 0,x
.d6ff		c8		iny		                iny
.d700		b1 25		lda ($25),y	                lda (tmp1),y
.d702		95 01		sta $01,x	                sta 1,x
.d704		60		rts		                rts
.d705						dodefer:
.d705		68		pla		                pla             ; LSB
.d706		85 25		sta $25		                sta tmp1
.d708		68		pla		                pla             ; MSB
.d709		85 26		sta $26		                sta tmp1+1
.d70b		a0 01		ldy #$01	                ldy #1
.d70d		b1 25		lda ($25),y	                lda (tmp1),y
.d70f		85 27		sta $27		                sta tmp2
.d711		c8		iny		                iny
.d712		b1 25		lda ($25),y	                lda (tmp1),y
.d714		85 28		sta $28		                sta tmp2+1
.d716		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d719						defer_error:
.d719		a9 03		lda #$03	                lda #err_defer
.d71b		4c 9f d8	jmp $d89f	                jmp error
.d71e						dodoes:
.d71e		7a		ply		                ply             ; LSB
.d71f		68		pla		                pla             ; MSB
.d720		c8		iny		                iny
.d721		d0 01		bne $d724	                bne +
.d723		1a		inc a		                ina
.d724						+
.d724		84 27		sty $27		                sty tmp2
.d726		85 28		sta $28		                sta tmp2+1
.d728		ca		dex		                dex
.d729		ca		dex		                dex
.d72a		7a		ply		                ply
.d72b		68		pla		                pla
.d72c		c8		iny		                iny
.d72d		d0 01		bne $d730	                bne +
.d72f		1a		inc a		                ina
.d730						+
.d730		94 00		sty $00,x	                sty 0,x         ; LSB
.d732		95 01		sta $01,x	                sta 1,x         ; MSB
.d734		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d737						dovar:
.d737		7a		ply		                ply             ; LSB
.d738		68		pla		                pla             ; MSB
.d739		c8		iny		                iny
.d73a		d0 01		bne $d73d	                bne +
.d73c		1a		inc a		                ina
.d73d						+
.d73d		ca		dex		                dex
.d73e		ca		dex		                dex
.d73f		95 01		sta $01,x	                sta 1,x
.d741		98		tya		                tya
.d742		95 00		sta $00,x	                sta 0,x
.d744		60		rts		                rts
.d745						push_upvar_tos:
.d745		ca		dex		                dex
.d746		ca		dex		                dex
.d747		18		clc		                clc
.d748		65 08		adc $08		                adc up
.d74a		95 00		sta $00,x	                sta 0,x
.d74c		a5 09		lda $09		                lda up+1
.d74e		90 01		bcc $d751	                bcc +
.d750		1a		inc a		                ina
.d751						+
.d751		95 01		sta $01,x	                sta 1,x
.d753		60		rts		                rts
.d754						byte_to_ascii:
.d754		48		pha		                pha
.d755		4a		lsr a		                lsr             ; convert high nibble first
.d756		4a		lsr a		                lsr
.d757		4a		lsr a		                lsr
.d758		4a		lsr a		                lsr
.d759		20 5d d7	jsr $d75d	                jsr _nibble_to_ascii
.d75c		68		pla		                pla
.d75d						_nibble_to_ascii:
.d75d		29 0f		and #$0f	                and #$F
.d75f		09 30		ora #$30	                ora #'0'
.d761		c9 3a		cmp #$3a	                cmp #'9'+1
.d763		90 02		bcc $d767	                bcc +
.d765		69 06		adc #$06	                adc #6
.d767		4c 93 86	jmp $8693	+               jmp emit_a
.d76a		60		rts		                rts
.d76b						find_header_name:
.d76b		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d76d		85 27		sta $27		                sta tmp2
.d76f		b5 03		lda $03,x	                lda 3,x
.d771		85 28		sta $28		                sta tmp2+1
.d773						_loop:
.d773		b2 25		lda ($25)	                lda (tmp1)
.d775		d5 00		cmp $00,x	                cmp 0,x
.d777		d0 3a		bne $d7b3	                bne _next_entry
.d779		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d77b		a0 08		ldy #$08	                ldy #8
.d77d		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d77f		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d781		d0 30		bne $d7b3	                bne _next_entry ; definitely not equal if any bits differ
.d783		a5 25		lda $25		                lda tmp1
.d785		48		pha		                pha             ; Save original address on the stack
.d786		18		clc		                clc
.d787		69 08		adc #$08	                adc #8
.d789		85 25		sta $25		                sta tmp1
.d78b		a5 26		lda $26		                lda tmp1+1
.d78d		48		pha		                pha
.d78e		90 03		bcc $d793	                bcc +
.d790		1a		inc a		                ina
.d791		85 26		sta $26		                sta tmp1+1
.d793						+
.d793		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d795		88		dey		                dey
.d796						_next_char:
.d796		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d798		c9 5b		cmp #$5b	                cmp #'Z'+1
.d79a		b0 06		bcs $d7a2	                bcs _check_char
.d79c		c9 41		cmp #$41	                cmp #'A'
.d79e		90 02		bcc $d7a2	                bcc _check_char
.d7a0		09 20		ora #$20	                ora #$20
.d7a2						_check_char:
.d7a2		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d7a4		d0 03		bne $d7a9	                bne _reset_tmp1
.d7a6		88		dey		                dey
.d7a7		10 ed		bpl $d796	                bpl _next_char
.d7a9						_reset_tmp1:
.d7a9		68		pla		                pla
.d7aa		85 26		sta $26		                sta tmp1+1
.d7ac		68		pla		                pla
.d7ad		85 25		sta $25		                sta tmp1
.d7af		98		tya		                tya             ; leave A = $FF on success
.d7b0		c8		iny		                iny             ; if Y was $FF, we succeeded
.d7b1		f0 11		beq $d7c4	                beq _done
.d7b3						_next_entry:
.d7b3		a0 02		ldy #$02	                ldy #2
.d7b5		b1 25		lda ($25),y	                lda (tmp1),y
.d7b7		48		pha		                pha
.d7b8		c8		iny		                iny
.d7b9		b1 25		lda ($25),y	                lda (tmp1),y
.d7bb		85 26		sta $26		                sta tmp1+1
.d7bd		68		pla		                pla
.d7be		85 25		sta $25		                sta tmp1
.d7c0		05 26		ora $26		                ora tmp1+1
.d7c2		d0 af		bne $d773	                bne _loop
.d7c4		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d7c6		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d7c7						compare_16bit:
.d7c7		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d7c9		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d7cb		f0 08		beq $d7d5	                beq _equal
.d7cd		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d7cf		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7d1		70 08		bvs $d7db	                bvs _overflow
.d7d3		80 08		bra $d7dd	                bra _not_equal
.d7d5						_equal:
.d7d5		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d7d7		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7d9		50 04		bvc $d7df	                bvc _done
.d7db						_overflow:
.d7db		49 80		eor #$80	                eor #$80                ; complement negative flag
.d7dd						_not_equal:
.d7dd		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d7df						_done:
.d7df		60		rts		                rts
.d7e0						current_to_dp:
.d7e0		a0 08		ldy #$08	                ldy #current_offset
.d7e2		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d7e4		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7e5		18		clc		                clc
.d7e6		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d7e8		a8		tay		                tay
.d7e9		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d7eb		85 02		sta $02		                sta dp
.d7ed		c8		iny		                iny
.d7ee		b1 08		lda ($08),y	                lda (up),y
.d7f0		85 03		sta $03		                sta dp+1
.d7f2		60		rts		                rts
.d7f3						dp_to_current:
.d7f3		a0 08		ldy #$08	                ldy #current_offset
.d7f5		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d7f7		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7f8		18		clc		                clc
.d7f9		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d7fb		a8		tay		                tay
.d7fc		a5 02		lda $02		                lda dp
.d7fe		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d800		c8		iny		                iny
.d801		a5 03		lda $03		                lda dp+1
.d803		91 08		sta ($08),y	                sta (up),y
.d805		60		rts		                rts
.d806						interpret:
.d806						_loop:
.d806		20 2d 8d	jsr $8d2d	                jsr w_parse_name       ; ( "string" -- addr u )
.d809		b5 00		lda $00,x	                lda 0,x
.d80b		15 01		ora $01,x	                ora 1,x
.d80d		f0 5b		beq $d86a	                beq _line_done
.d80f		20 a6 93	jsr $93a6	                jsr w_two_dup          ; ( addr u -- addr u addr u )
.d812		20 3d 9b	jsr $9b3d	                jsr w_find_name        ; ( addr u addr u -- addr u nt|0 )
.d815		b5 00		lda $00,x	                lda 0,x
.d817		15 01		ora $01,x	                ora 1,x
.d819		d0 19		bne $d834	                bne _got_name_token
.d81b		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d81c		e8		inx		                inx
.d81d		20 e9 9c	jsr $9ce9	                jsr w_number           ; ( addr u -- u|d )
.d820		a5 1a		lda $1a		                lda state
.d822		f0 e2		beq $d806	                beq _loop
.d824		a9 20		lda #$20	                lda #%00100000
.d826		24 1c		bit $1c		                bit status
.d828		d0 05		bne $d82f	                bne _double_number
.d82a		20 e0 89	jsr $89e0	                jsr w_literal
.d82d		80 d7		bra $d806	                bra _loop
.d82f						_double_number:
.d82f		20 a8 9f	jsr $9fa8	                jsr w_two_literal
.d832		80 d2		bra $d806	                bra _loop
.d834						_got_name_token:
.d834		b5 00		lda $00,x	                lda 0,x
.d836		95 04		sta $04,x	                sta 4,x
.d838		b5 01		lda $01,x	                lda 1,x
.d83a		95 05		sta $05,x	                sta 5,x
.d83c		e8		inx		                inx
.d83d		e8		inx		                inx
.d83e		e8		inx		                inx
.d83f		e8		inx		                inx                     ; ( nt )
.d840		20 c8 8c	jsr $8cc8	                jsr w_one_plus
.d843		a1 00		lda ($00,x)	                lda (0,x)
.d845		48		pha		                pha
.d846		20 bc 8c	jsr $8cbc	                jsr w_one_minus
.d849		20 86 9c	jsr $9c86	                jsr w_name_to_int      ; ( nt - xt )
.d84c		a5 1a		lda $1a		                lda state
.d84e		d0 10		bne $d860	                bne _compile
.d850		68		pla		                pla
.d851		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d853		f0 05		beq $d85a	                beq _interpret
.d855		a9 02		lda #$02	                lda #err_compileonly
.d857		4c 9f d8	jmp $d89f	                jmp error
.d85a						_interpret:
.d85a		20 e1 87	jsr $87e1	                jsr w_execute
.d85d		4c 06 d8	jmp $d806	                jmp _loop
.d860						_compile:
.d860		68		pla		                pla
.d861		29 02		and #$02	                and #IM                 ; Mask all but IM bit
.d863		d0 f5		bne $d85a	                bne _interpret          ; IMMEDIATE word, execute right now
.d865		20 ba 96	jsr $96ba	                jsr w_compile_comma
.d868		80 9c		bra $d806	                bra _loop
.d86a						_line_done:
.d86a		e8		inx		                inx
.d86b		e8		inx		                inx
.d86c		e8		inx		                inx
.d86d		e8		inx		                inx
.d86e		60		rts		                rts
.d86f						is_printable:
.d86f		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d871		90 08		bcc $d87b	                bcc _done
.d873		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d875		b0 03		bcs $d87a	                bcs _failed
.d877		38		sec		                sec
.d878		80 01		bra $d87b	                bra _done
.d87a						_failed:
.d87a		18		clc		                clc
.d87b						_done:
.d87b		60		rts		                rts
.d87c						is_whitespace:
.d87c		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d87e		90 08		bcc $d888	                bcc _done
.d880		c9 21		cmp #$21	                cmp #AscSP+1
.d882		b0 03		bcs $d887	                bcs _failed
.d884		38		sec		                sec
.d885		80 01		bra $d888	                bra _done
.d887						_failed:
.d887		18		clc		                clc
.d888						_done:
.d888		60		rts		                rts
.d889						underflow_1:
.d889		e0 77		cpx #$77	                cpx #dsp0-1
.d88b		10 10		bpl $d89d	                bpl underflow_error
.d88d		60		rts		                rts
.d88e						underflow_2:
.d88e		e0 75		cpx #$75	                cpx #dsp0-3
.d890		10 0b		bpl $d89d	                bpl underflow_error
.d892		60		rts		                rts
.d893						underflow_3:
.d893		e0 73		cpx #$73	                cpx #dsp0-5
.d895		10 06		bpl $d89d	                bpl underflow_error
.d897		60		rts		                rts
.d898						underflow_4:
.d898		e0 71		cpx #$71	                cpx #dsp0-7
.d89a		10 01		bpl $d89d	                bpl underflow_error
.d89c		60		rts		                rts
.d89d						underflow_error:
.d89d		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d89f						error:
.d89f		48		pha		                pha                     ; save error
.d8a0		20 de d8	jsr $d8de	                jsr print_error
.d8a3		20 05 84	jsr $8405	                jsr w_cr
.d8a6		68		pla		                pla
.d8a7		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d8a9		d0 17		bne $d8c2	                bne _no_underflow
.d8ab		a9 0d		lda #$0d	                lda #err_returnstack
.d8ad		20 de d8	jsr $d8de	                jsr print_error
.d8b0		ba		tsx		                tsx
.d8b1						-
.d8b1		e8		inx		                inx
.d8b2		f0 0b		beq $d8bf	                beq +
.d8b4		20 bc 91	jsr $91bc	                jsr w_space
.d8b7		bd 00 01	lda $0100,x	                lda $100,x
.d8ba		20 54 d7	jsr $d754	                jsr byte_to_ascii
.d8bd		80 f2		bra $d8b1	                bra -
.d8bf						+
.d8bf		20 05 84	jsr $8405	                jsr w_cr
.d8c2						_no_underflow:
.d8c2		4c 5e 80	jmp $805e	                jmp w_abort            ; no jsr, as we clobber return stack
.d8c5						print_string_no_lf:
.d8c5		0a		asl a		                asl
.d8c6		a8		tay		                tay
.d8c7		b9 d4 d3	lda $d3d4,y	                lda string_table,y
.d8ca		85 29		sta $29		                sta tmp3                ; LSB
.d8cc		b9 d5 d3	lda $d3d5,y	                lda string_table+1,y
.d8cf		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d8d1						print_common:
.d8d1		a0 00		ldy #$00	                ldy #0
.d8d3						_loop:
.d8d3		b1 29		lda ($29),y	                lda (tmp3),y
.d8d5		f0 06		beq $d8dd	                beq _done               ; strings are zero-terminated
.d8d7		20 93 86	jsr $8693	                jsr emit_a              ; allows vectoring via output
.d8da		c8		iny		                iny
.d8db		80 f6		bra $d8d3	                bra _loop
.d8dd						_done:
.d8dd		60		rts		                rts
.d8de						print_error:
.d8de		0a		asl a		                asl
.d8df		a8		tay		                tay
.d8e0		b9 b9 d4	lda $d4b9,y	                lda error_table,y
.d8e3		85 29		sta $29		                sta tmp3                ; LSB
.d8e5		c8		iny		                iny
.d8e6		b9 b9 d4	lda $d4b9,y	                lda error_table,y
.d8e9		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d8eb		20 d1 d8	jsr $d8d1	                jsr print_common
.d8ee		60		rts		                rts
.d8ef						print_string:
.d8ef		20 c5 d8	jsr $d8c5	                jsr print_string_no_lf
.d8f2		4c 05 84	jmp $8405	                jmp w_cr               ; JSR/RTS because never compiled
.d8f5						print_u:
.d8f5		20 46 9e	jsr $9e46	                jsr w_zero                     ; 0
.d8f8		20 ba 89	jsr $89ba	                jsr w_less_number_sign         ; <#
.d8fb		20 92 8c	jsr $8c92	                jsr w_number_sign_s            ; #S
.d8fe		20 70 8c	jsr $8c70	                jsr w_number_sign_greater      ; #>
.d901		4c bb 94	jmp $94bb	                jmp w_type                     ; JSR/RTS because never compiled
.d904						code_end:

;******  Return to file: platform/simulator.asm

=$f000						io_start = $f000                ; virtual hardware addresses for the simulators
>f000						                .byte ?
>f001						io_putc:        .byte ?         ; $f001     write byte to stdout
>f002						                .byte ?
>f003						io_kbhit:       .byte ?         ; $f003     read non-zero on key ready (c65 only)
>f004						io_getc:        .byte ?         ; $f004     non-blocking read input character (0 if no key)
>f005						io_clk_start:   .byte ?         ; $f006     *read* to start cycle counter
>f006						io_clk_stop:    .byte ?         ; $f007     *read* to stop the cycle counter
>f007						io_clk_cycles:  .word ?,?       ; $f008-b   32-bit cycle count in NUXI order
>f00b						                .word ?,?
>f00f						io_blk_action:  .byte ?     ; $f010     Write to act (status=0 read=1 write=2)
>f010						io_blk_status:  .byte ?     ; $f011     Read action result (OK=0)
>f011						io_blk_number:  .word ?     ; $f012     Little endian block number 0-ffff
>f013						io_blk_buffer:  .word ?     ; $f014     Little endian memory address
.f015						io_end:
.f015						kernel_init:
.f015		78		sei		                sei             ; Disable interrupts
.f016		a2 00		ldx #$00	                ldx #0
.f018		bd 45 f0	lda $f045,x	-               lda s_kernel_id,x
.f01b		f0 06		beq $f023	                beq _done
.f01d		20 27 f0	jsr $f027	                jsr kernel_putc
.f020		e8		inx		                inx
.f021		80 f5		bra $f018	                bra -
.f023						_done:
.f023		4c 00 80	jmp $8000	                jmp forth
.f026						kernel_bye:
.f026		00		brk #		                brk
.f027						kernel_putc:
.f027		8d 01 f0	sta $f001	                sta io_putc
.f02a		60		rts		                rts

;******  Return to file: platform/platform-py65mon.asm

=$f002						io_bufc = io_putc+1
.f02b						kernel_getc:
.f02b		ad 02 f0	lda $f002	                lda io_bufc             ; first check the buffer
.f02e		9c 02 f0	stz $f002	                stz io_bufc
.f031		d0 05		bne $f038	                bne _done
.f033						_loop:
.f033		ad 04 f0	lda $f004	                lda io_getc
.f036		f0 fb		beq $f033	                beq _loop
.f038						_done:
.f038		60		rts		                rts
.f039						kernel_kbhit:
.f039		ad 02 f0	lda $f002	                lda io_bufc             ; do we already have a character?
.f03c		d0 06		bne $f044	                bne _done
.f03e		ad 04 f0	lda $f004	                lda io_getc             ; otherwise check and buffer the result
.f041		8d 02 f0	sta $f002	                sta io_bufc
.f044						_done:
.f044		60		rts		                rts
.f045						s_kernel_id:
>f045		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f04d		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f05d		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f06d		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		15 f0				v_nmi   .word kernel_init
>fffc		15 f0				v_reset .word kernel_init
>fffe		15 f0				v_irq   .word kernel_init

;******  End of listing
