
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Sat Jun 22 08:26:34 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$7fff						ram_end = $7fff
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/simulator.asm


;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 27		lda #$27	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd e8 b3	lda $b3e8,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad e8 b3	lda $b3e8	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f						_load_user_vars_loop:
.801f		b9 06 b4	lda $b406,y	                lda cold_user_table,y
.8022		91 08		sta ($08),y	                sta (up),y
.8024		88		dey		                dey
.8025		d0 f8		bne $801f	                bne _load_user_vars_loop
.8027		ad 06 b4	lda $b406	                lda cold_user_table
.802a		92 08		sta ($08)	                sta (up)
.802c		20 3a 84	jsr $843a	                jsr xt_cr
.802f		ca		dex		                dex
.8030		ca		dex		                dex
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		a9 e9		lda #$e9	                lda #<forth_words_start
.8035		95 02		sta $02,x	                sta 2,x
.8037		a9 ba		lda #$ba	                lda #>forth_words_start
.8039		95 03		sta $03,x	                sta 3,x
.803b		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803d		95 00		sta $00,x	                sta 0,x
.803f		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8041		95 01		sta $01,x	                sta 1,x
.8043		20 b2 88	jsr $88b2	                jsr xt_evaluate
.8046		9c 00 7c	stz $7c00	                stz hist_buff
.8049		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804c		9c 00 7d	stz $7d00	                stz hist_buff+$100
.804f		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8052		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8055		9c 80 7e	stz $7e80	                stz hist_buff+$280
.8058		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805b		9c 80 7f	stz $7f80	                stz hist_buff+$380
.805e						xt_abort:
.805e		a2 78		ldx #$78	                ldx #dsp0
.8060						xt_quit:
.8060		8a		txa		                txa             ; Save the DSP that we just defined
.8061		a2 ff		ldx #$ff	                ldx #rsp0
.8063		9a		txs		                txs
.8064		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8065		64 04		stz $04		                stz ip
.8067		64 05		stz $05		                stz ip+1
.8069		64 0a		stz $0a		                stz insrc
.806b		64 0b		stz $0b		                stz insrc+1
.806d		a9 00		lda #$00	                lda #0
.806f		a0 04		ldy #$04	                ldy #blk_offset
.8071		91 08		sta ($08),y	                sta (up),y
.8073		c8		iny		                iny
.8074		91 08		sta ($08),y	                sta (up),y
.8076		a9 fc		lda #$fc	                lda #(256-4)
.8078		85 1f		sta $1f		                sta loopctrl
.807a		64 1a		stz $1a		                stz state
.807c		64 1b		stz $1b		                stz state+1
.807e						_get_line:
.807e		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8080		85 0c		sta $0c		                sta cib
.8082		a9 02		lda #$02	                lda #>buffer0
.8084		85 0d		sta $0d		                sta cib+1
.8086		64 0e		stz $0e		                stz ciblen
.8088		64 0f		stz $0f		                stz ciblen+1
.808a		20 4e 8f	jsr $8f4e	                jsr xt_refill           ; ( -- f )
.808d		b5 00		lda $00,x	                lda 0,x
.808f		d0 05		bne $8096	                bne _success
.8091		a9 06		lda #$06	                lda #err_refill
.8093		4c 55 d8	jmp $d855	                jmp error
.8096						_success:
.8096		e8		inx		                inx                     ; drop
.8097		e8		inx		                inx
.8098		20 bc d7	jsr $d7bc	                jsr interpret
.809b		e0 78		cpx #$78	                cpx #dsp0
.809d		f0 05		beq $80a4	                beq _stack_ok
.809f		90 03		bcc $80a4	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a1		4c 53 d8	jmp $d853	                jmp underflow_error
.80a4						_stack_ok:
.80a4		a5 1a		lda $1a		                lda state
.80a6		f0 02		beq $80aa	                beq _print
.80a8		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80aa						_print:
.80aa		20 a6 d8	jsr $d8a6	                jsr print_string
.80ad		80 cf		bra $807e	                bra _get_line
.80af						z_cold:
.80af						z_abort:
.80af						z_quit:

;******  Processing file: platform/../words/core.asm

.80af						xt_abort_quote:
.80af		20 e6 8f	jsr $8fe6	                jsr xt_s_quote          ; S"
.80b2		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b4		a9 ba		lda #$ba	                lda #<abort_quote_runtime
.80b6		20 74 97	jsr $9774	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b9		60		rts		z_abort_quote:  rts
.80ba						abort_quote_runtime:
.80ba		b5 04		lda $04,x	                lda 4,x
.80bc		15 05		ora $05,x	                ora 5,x
.80be		f0 09		beq $80c9	                beq _done       ; if FALSE, we're done
.80c0		20 d0 94	jsr $94d0	                jsr xt_type
.80c3		20 3a 84	jsr $843a	                jsr xt_cr
.80c6		4c 5e 80	jmp $805e	                jmp xt_abort    ; not JSR, so never come back
.80c9						_done:
.80c9		8a		txa		                txa
.80ca		18		clc		                clc
.80cb		69 06		adc #$06	                adc #6
.80cd		aa		tax		                tax
.80ce		60		rts		                rts
.80cf						xt_abs:
.80cf		20 3f d8	jsr $d83f	                jsr underflow_1
.80d2		b5 01		lda $01,x	                lda 1,x
.80d4		10 0d		bpl $80e3	                bpl _done       ; positive number, easy money!
.80d6		38		sec		                sec
.80d7		a9 00		lda #$00	                lda #0
.80d9		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80db		95 00		sta $00,x	                sta 0,x
.80dd		a9 00		lda #$00	                lda #0          ; MSB
.80df		f5 01		sbc $01,x	                sbc 1,x
.80e1		95 01		sta $01,x	                sta 1,x
.80e3						_done:
.80e3		60		rts		z_abs:          rts
.80e4						xt_accept:
.80e4		20 44 d8	jsr $d844	                jsr underflow_2
.80e7		b5 00		lda $00,x	                lda 0,x
.80e9		15 01		ora $01,x	                ora 1,x
.80eb		d0 09		bne $80f6	                bne _not_zero
.80ed		e8		inx		                inx
.80ee		e8		inx		                inx
.80ef		74 00		stz $00,x	                stz 0,x
.80f1		74 01		stz $01,x	                stz 1,x
.80f3		4c c2 81	jmp $81c2	                jmp accept_done
.80f6						_not_zero:
.80f6		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f8		85 27		sta $27		                sta tmp2
.80fa		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fc		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fe		85 25		sta $25		                sta tmp1
.8100		b5 03		lda $03,x	                lda 3,x
.8102		85 26		sta $26		                sta tmp1+1
.8104		e8		inx		                inx
.8105		e8		inx		                inx
.8106		a0 00		ldy #$00	                ldy #0
.8108		a5 1c		lda $1c		                lda status
.810a		29 f7		and #$f7	                and #$F7
.810c		1a		inc a		                ina
.810d		09 08		ora #$08	                ora #%00001000
.810f		85 1c		sta $1c		                sta status
.8111						accept_loop:
.8111		20 b1 89	jsr $89b1	                jsr key_a
.8114		c9 0a		cmp #$0a	                cmp #AscLF
.8116		f0 20		beq $8138	                beq _eol
.8118		c9 0d		cmp #$0d	                cmp #AscCR
.811a		f0 1c		beq $8138	                beq _eol
.811c		c9 08		cmp #$08	                cmp #AscBS
.811e		f0 22		beq $8142	                beq _backspace
.8120		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8122		f0 1e		beq $8142	                beq _backspace
.8124		c9 10		cmp #$10	                cmp #AscCP
.8126		f0 36		beq $815e	                beq _ctrl_p
.8128		c9 0e		cmp #$0e	                cmp #AscCN
.812a		f0 44		beq $8170	                beq _ctrl_n
.812c		91 25		sta ($25),y	                sta (tmp1),y
.812e		c8		iny		                iny
.812f		20 c5 86	jsr $86c5	                jsr emit_a
.8132		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8134		d0 db		bne $8111	                bne accept_loop       ; fall through if buffer limit reached
.8136		80 03		bra $813b	                bra _buffer_full
.8138						_eol:
.8138		20 d7 91	jsr $91d7	                jsr xt_space    ; print final space
.813b						_buffer_full:
.813b		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813d		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813f		4c c2 81	jmp $81c2	                jmp accept_done
.8142						_backspace:
.8142		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8144		d0 06		bne $814c	                bne +
.8146		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8148		20 c5 86	jsr $86c5	                jsr emit_a
.814b		c8		iny		                iny
.814c						+
.814c		88		dey		                dey
.814d		a9 08		lda #$08	                lda #AscBS      ; move back one
.814f		20 c5 86	jsr $86c5	                jsr emit_a
.8152		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8154		20 c5 86	jsr $86c5	                jsr emit_a
.8157		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8159		20 c5 86	jsr $86c5	                jsr emit_a
.815c		80 b3		bra $8111	                bra accept_loop
.815e						_ctrl_p:
.815e		a5 1c		lda $1c		                lda status
.8160		29 07		and #$07	                and #7
.8162		d0 08		bne $816c	                bne _ctrl_p_dec
.8164		a5 1c		lda $1c		                lda status
.8166		09 07		ora #$07	                ora #7
.8168		85 1c		sta $1c		                sta status
.816a		80 11		bra $817d	                bra _recall_history
.816c						_ctrl_p_dec:
.816c		c6 1c		dec $1c		                dec status
.816e		80 0d		bra $817d	                bra _recall_history
.8170						_ctrl_n:
.8170		a9 08		lda #$08	                lda #$8
.8172		24 1c		bit $1c		                bit status
.8174		d0 07		bne $817d	                bne _recall_history
.8176		a5 1c		lda $1c		                lda status
.8178		29 f7		and #$f7	                and #$F7
.817a		1a		inc a		               ina
.817b		85 1c		sta $1c		                sta status
.817d						_recall_history:
.817d		a9 08		lda #$08	                lda #%00001000
.817f		14 1c		trb $1c		                trb status
.8181		20 dd 81	jsr $81dd	                jsr accept_total_recall
.8184		a9 0d		lda #$0d	                lda #AscCR
.8186		20 c5 86	jsr $86c5	                jsr emit_a
.8189						input_clear:
.8189		c0 00		cpy #$00	                cpy #0
.818b		f0 08		beq $8195	                beq input_cleared
.818d		a9 20		lda #$20	                lda #AscSP
.818f		20 c5 86	jsr $86c5	                jsr emit_a
.8192		88		dey		                dey
.8193		80 f4		bra $8189	                bra input_clear
.8195						input_cleared:
.8195		a9 0d		lda #$0d	                lda #AscCR
.8197		20 c5 86	jsr $86c5	                jsr emit_a
.819a		b1 29		lda ($29),y	                lda (tmp3),y
.819c		85 1d		sta $1d		                sta status+1
.819e		e6 29		inc $29		                inc tmp3
.81a0		d0 02		bne $81a4	                bne +           ; Increment the upper byte on carry.
.81a2		e6 2a		inc $2a		                inc tmp3+1
.81a4						+
.81a4		a9 0d		lda #$0d	                lda #AscCR
.81a6		20 c5 86	jsr $86c5	                jsr emit_a
.81a9						_history_loop:
.81a9		c4 1d		cpy $1d		                cpy status+1
.81ab		d0 03		bne $81b0	                bne +
.81ad		4c 11 81	jmp $8111	                jmp accept_loop       ; Needs a long jump
.81b0						+
.81b0		c4 27		cpy $27		                cpy tmp2
.81b2		f0 0a		beq $81be	                beq _hist_filled_buffer
.81b4		b1 29		lda ($29),y	                lda (tmp3),y
.81b6		91 25		sta ($25),y	                sta (tmp1),y
.81b8		20 c5 86	jsr $86c5	                jsr emit_a
.81bb		c8		iny		                iny
.81bc		80 eb		bra $81a9	                bra _history_loop
.81be						_hist_filled_buffer:
.81be		88		dey		                dey
.81bf		4c 11 81	jmp $8111	                jmp accept_loop
.81c2						accept_done:
.81c2		20 dd 81	jsr $81dd	                jsr accept_total_recall
.81c5		85 1d		sta $1d		                sta status+1
.81c7		a0 00		ldy #$00	                ldy #0
.81c9		91 29		sta ($29),y	                sta (tmp3),y
.81cb		e6 29		inc $29		                inc tmp3
.81cd		d0 02		bne $81d1	                bne +           ; Increment the upper byte on carry.
.81cf		e6 2a		inc $2a		                inc tmp3+1
.81d1						+
.81d1						_save_history_loop:
.81d1		c4 1d		cpy $1d		                cpy status+1
.81d3		f0 07		beq $81dc	                beq _save_history_done
.81d5		b1 25		lda ($25),y	                lda (tmp1),y
.81d7		91 29		sta ($29),y	                sta (tmp3),y
.81d9		c8		iny		                iny
.81da		80 f5		bra $81d1	                bra _save_history_loop
.81dc						_save_history_done:
.81dc						z_accept:
.81dc		60		rts		                rts
.81dd						accept_total_recall:
.81dd		a9 00		lda #$00	                lda #<hist_buff
.81df		85 29		sta $29		                sta tmp3
.81e1		a9 7c		lda #$7c	                lda #>hist_buff
.81e3		85 2a		sta $2a		                sta tmp3+1
.81e5		a5 1c		lda $1c		                lda status
.81e7		6a		ror a		                ror
.81e8		29 03		and #$03	                and #3
.81ea		18		clc		                clc
.81eb		65 2a		adc $2a		                adc tmp3+1
.81ed		85 2a		sta $2a		                sta tmp3+1
.81ef		a5 1c		lda $1c		                lda status
.81f1		6a		ror a		                ror             ; Rotate through carry into msb.
.81f2		6a		ror a		                ror
.81f3		29 80		and #$80	                and #$80
.81f5		18		clc		                clc
.81f6		65 29		adc $29		                adc tmp3
.81f8		85 29		sta $29		                sta tmp3
.81fa		90 02		bcc $81fe	                bcc +           ; Increment the upper byte on carry.
.81fc		e6 2a		inc $2a		                inc tmp3+1
.81fe						+
.81fe		98		tya		                tya
.81ff		c9 80		cmp #$80	                cmp #$80
.8201		90 02		bcc $8205	                bcc +
.8203		a9 7f		lda #$7f	                lda #$7F
.8205						+
.8205		60		rts		                rts
.8206						xt_action_of:
.8206		a5 1a		lda $1a		                lda state
.8208		05 1b		ora $1b		                ora state+1
.820a		f0 0c		beq $8218	                beq _interpreting
.820c		20 14 83	jsr $8314	                jsr xt_bracket_tick
.820f		a0 85		ldy #$85	                ldy #>xt_defer_fetch
.8211		a9 44		lda #$44	                lda #<xt_defer_fetch
.8213		20 74 97	jsr $9774	                jsr cmpl_subroutine
.8216		80 06		bra $821e	                bra _done
.8218						_interpreting:
.8218		20 4e 92	jsr $924e	                jsr xt_tick
.821b		20 44 85	jsr $8544	                jsr xt_defer_fetch
.821e						_done:
.821e		60		rts		z_action_of:           rts
.821f						xt_again:
.821f		20 3f d8	jsr $d83f	                jsr underflow_1
.8222		20 8d 97	jsr $978d	                jsr cmpl_jump_tos
.8225		60		rts		z_again:        rts
.8226						xt_align:
.8226						xt_aligned:
.8226						z_align:
.8226						z_aligned:
.8226		60		rts		                rts             ; stripped out during native compile
.8227						xt_allot:
.8227		20 3f d8	jsr $d83f	                jsr underflow_1
.822a		b5 01		lda $01,x	                lda 1,x
.822c		30 22		bmi $8250	                bmi _release
.822e		18		clc		                clc
.822f		a5 00		lda $00		                lda cp
.8231		75 00		adc $00,x	                adc 0,x
.8233		85 00		sta $00		                sta cp
.8235		a5 01		lda $01		                lda cp+1
.8237		75 01		adc $01,x	                adc 1,x
.8239		85 01		sta $01		                sta cp+1
.823b		a0 00		ldy #$00	                ldy #<cp_end
.823d		c4 00		cpy $00		                cpy cp
.823f		a9 7c		lda #$7c	                lda #>cp_end
.8241		e5 01		sbc $01		                sbc cp+1
.8243		b0 48		bcs $828d	                bcs _done               ; we're fine.
.8245		84 00		sty $00		                sty cp                  ; still #<cp_end
.8247		a9 7c		lda #$7c	                lda #>cp_end
.8249		85 01		sta $01		                sta cp+1
.824b		a9 00		lda #$00	                lda #err_allot
.824d		4c 55 d8	jmp $d855	                jmp error
.8250						_release:
.8250		ca		dex		                dex
.8251		ca		dex		                dex
.8252		a5 00		lda $00		                lda cp
.8254		95 00		sta $00,x	                sta 0,x
.8256		a5 01		lda $01		                lda cp+1
.8258		95 01		sta $01,x	                sta 1,x
.825a		20 5f 8e	jsr $8e5f	                jsr xt_plus                     ; new CP is now TOS
.825d		ca		dex		                dex
.825e		ca		dex		                dex                             ; new CP now NOS
.825f		a9 00		lda #$00	                lda #<cp0
.8261		95 00		sta $00,x	                sta 0,x
.8263		a9 03		lda #$03	                lda #>cp0
.8265		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8267		20 7d d7	jsr $d77d	                jsr compare_16bit               ; still ( CP CP0 )
.826a		f0 17		beq $8283	                beq _nega_done
.826c		30 15		bmi $8283	                bmi _nega_done
.826e		a9 00		lda #$00	                lda #<cp0
.8270		85 00		sta $00		                sta cp
.8272		a9 03		lda #$03	                lda #>cp0
.8274		85 01		sta $01		                sta cp+1
.8276		a9 cb		lda #$cb	                lda #<dictionary_start
.8278		85 02		sta $02		                sta dp
.827a		a9 bb		lda #$bb	                lda #>dictionary_start
.827c		85 03		sta $03		                sta dp+1
.827e		a9 0a		lda #$0a	                lda #err_negallot
.8280		4c 55 d8	jmp $d855	                jmp error
.8283						_nega_done:
.8283		b5 02		lda $02,x	                lda 2,x
.8285		85 00		sta $00		                sta cp
.8287		b5 03		lda $03,x	                lda 3,x
.8289		85 01		sta $01		                sta cp+1
.828b		e8		inx		                inx
.828c		e8		inx		                inx                     ; drop through to _done
.828d						_done:
.828d		e8		inx		                inx
.828e		e8		inx		                inx
.828f						z_allot:
.828f		60		rts		                rts
.8290						xt_and:
.8290		20 44 d8	jsr $d844	                jsr underflow_2
.8293		b5 00		lda $00,x	                lda 0,x
.8295		35 02		and $02,x	                and 2,x
.8297		95 02		sta $02,x	                sta 2,x
.8299		b5 01		lda $01,x	                lda 1,x
.829b		35 03		and $03,x	                and 3,x
.829d		95 03		sta $03,x	                sta 3,x
.829f		e8		inx		                inx
.82a0		e8		inx		                inx
.82a1		60		rts		z_and:          rts
.82a2						xt_at_xy:
.82a2		20 44 d8	jsr $d844	                jsr underflow_2
.82a5		a5 18		lda $18		                lda base
.82a7		48		pha		                pha
.82a8		a9 0a		lda #$0a	                lda #10
.82aa		85 18		sta $18		                sta base
.82ac		a9 1b		lda #$1b	                lda #AscESC
.82ae		20 c5 86	jsr $86c5	                jsr emit_a
.82b1		a9 5b		lda #$5b	                lda #'['
.82b3		20 c5 86	jsr $86c5	                jsr emit_a
.82b6		20 f5 8c	jsr $8cf5	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82b9		20 ac d8	jsr $d8ac	                jsr print_u
.82bc		a9 3b		lda #$3b	                lda #';'
.82be		20 c5 86	jsr $86c5	                jsr emit_a
.82c1		20 f5 8c	jsr $8cf5	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c4		20 ac d8	jsr $d8ac	                jsr print_u
.82c7		a9 48		lda #$48	                lda #'H'
.82c9		20 c5 86	jsr $86c5	                jsr emit_a
.82cc		68		pla		                pla
.82cd		85 18		sta $18		                sta base
.82cf		60		rts		z_at_xy:        rts
.82d0						xt_backslash:
.82d0		a0 04		ldy #$04	                ldy #blk_offset
.82d2		b1 08		lda ($08),y	                lda (up),y
.82d4		c8		iny		                iny
.82d5		11 08		ora ($08),y	                ora (up),y
.82d7		f0 19		beq $82f2	                beq backslash_not_block
.82d9		a5 10		lda $10		                lda toin
.82db		29 3f		and #$3f	                and #$3F
.82dd		f0 1b		beq $82fa	                beq z_backslash
.82df		c9 01		cmp #$01	                cmp #$1
.82e1		f0 17		beq $82fa	                beq z_backslash
.82e3		a5 10		lda $10		                lda toin
.82e5		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82e7		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82e8		69 40		adc #$40	                adc #$40
.82ea		85 10		sta $10		                sta toin
.82ec		90 0c		bcc $82fa	                bcc z_backslash
.82ee		e6 11		inc $11		                inc toin+1
.82f0		80 08		bra $82fa	                bra z_backslash
.82f2						backslash_not_block:
.82f2		a5 0e		lda $0e		                lda ciblen
.82f4		85 10		sta $10		                sta toin
.82f6		a5 0f		lda $0f		                lda ciblen+1
.82f8		85 11		sta $11		                sta toin+1
.82fa		60		rts		z_backslash:    rts
.82fb						xt_base:
.82fb		ca		dex		                dex
.82fc		ca		dex		                dex
.82fd		a9 18		lda #$18	                lda #<base
.82ff		95 00		sta $00,x	                sta 0,x         ; LSB
.8301		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8303		60		rts		z_base:         rts
.8304						xt_bl:
.8304		ca		dex		                dex
.8305		ca		dex		                dex
.8306		a9 20		lda #$20	                lda #AscSP
.8308		95 00		sta $00,x	                sta 0,x
.830a		74 01		stz $01,x	                stz 1,x
.830c		60		rts		z_bl:           rts
.830d						xt_bracket_char:
.830d		20 53 83	jsr $8353	                jsr xt_char
.8310		20 04 8a	jsr $8a04	                jsr xt_literal
.8313		60		rts		z_bracket_char: rts
.8314						xt_bracket_tick:
.8314		20 4e 92	jsr $924e	                jsr xt_tick
.8317		20 04 8a	jsr $8a04	                jsr xt_literal
.831a		60		rts		z_bracket_tick: rts
.831b						xt_buffer_colon:
.831b		20 40 84	jsr $8440	                jsr xt_create
.831e		20 27 82	jsr $8227	                jsr xt_allot
.8321		60		rts		z_buffer_colon: rts
.8322						xt_c_comma:
.8322		20 3f d8	jsr $d83f	                jsr underflow_1
.8325		b5 00		lda $00,x	                lda 0,x
.8327		20 84 97	jsr $9784	                jsr cmpl_a
.832a		e8		inx		                inx
.832b		e8		inx		                inx
.832c		60		rts		z_c_comma:      rts
.832d						xt_c_fetch:
.832d		20 3f d8	jsr $d83f	                jsr underflow_1
.8330		a1 00		lda ($00,x)	                lda (0,x)
.8332		95 00		sta $00,x	                sta 0,x
.8334		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8336		60		rts		z_c_fetch:      rts
.8337						xt_c_store:
.8337		20 44 d8	jsr $d844	                jsr underflow_2
.833a		b5 02		lda $02,x	                lda 2,x
.833c		81 00		sta ($00,x)	                sta (0,x)
.833e		e8		inx		                inx
.833f		e8		inx		                inx
.8340		e8		inx		                inx
.8341		e8		inx		                inx
.8342		60		rts		z_c_store:      rts
.8343						xt_cell_plus:
.8343		20 3f d8	jsr $d83f	                jsr underflow_1
.8346		f6 00		inc $00,x	                inc 0,x
.8348		d0 02		bne $834c	                bne +
.834a		f6 01		inc $01,x	                inc 1,x
.834c						+
.834c		f6 00		inc $00,x	                inc 0,x
.834e		d0 02		bne $8352	                bne _done
.8350		f6 01		inc $01,x	                inc 1,x
.8352						_done:
.8352		60		rts		z_cell_plus:    rts
.8353						xt_char:
.8353		20 5d 8d	jsr $8d5d	                jsr xt_parse_name
.8356		b5 00		lda $00,x	                lda 0,x
.8358		15 01		ora $01,x	                ora 1,x
.835a		d0 05		bne $8361	                bne _not_empty
.835c		a9 05		lda #$05	                lda #err_noname
.835e		4c 55 d8	jmp $d855	                jmp error
.8361						_not_empty:
.8361		e8		inx		                inx             ; drop number of characters, leave addr
.8362		e8		inx		                inx
.8363		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8365		95 00		sta $00,x	                sta 0,x
.8367		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8369		60		rts		z_char:         rts
.836a						xt_chars:
.836a		20 3f d8	jsr $d83f	                jsr underflow_1
.836d		60		rts		z_chars:        rts
.836e						xt_colon:
.836e		a5 1a		lda $1a		                lda state
.8370		05 1b		ora $1b		                ora state+1
.8372		f0 05		beq $8379	                beq +
.8374		a9 07		lda #$07	                lda #err_state
.8376		4c 55 d8	jmp $d855	                jmp error
.8379						+
.8379		c6 1a		dec $1a		                dec state
.837b		c6 1b		dec $1b		                dec state+1
.837d		a9 40		lda #$40	                lda #%01000000
.837f		04 1c		tsb $1c		                tsb status
.8381		20 96 d7	jsr $d796	                jsr current_to_dp
.8384		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8386		48		pha		                pha
.8387		a5 02		lda $02		                lda dp
.8389		48		pha		                pha
.838a		a9 80		lda #$80	                lda #%10000000
.838c		04 1c		tsb $1c		                tsb status
.838e		20 40 84	jsr $8440	                jsr xt_create
.8391		20 96 d7	jsr $d796	                jsr current_to_dp   ; This might be able to be omitted
.8394		a5 02		lda $02		                lda dp
.8396		85 06		sta $06		                sta workword
.8398		a5 03		lda $03		                lda dp+1
.839a		85 07		sta $07		                sta workword+1
.839c		68		pla		                pla
.839d		85 02		sta $02		                sta dp
.839f		68		pla		                pla
.83a0		85 03		sta $03		                sta dp+1
.83a2		20 a9 d7	jsr $d7a9	                jsr dp_to_current
.83a5		a5 00		lda $00		                lda cp
.83a7		38		sec		                sec
.83a8		e9 03		sbc #$03	                sbc #3
.83aa		85 00		sta $00		                sta cp
.83ac		b0 02		bcs $83b0	                bcs _done
.83ae		c6 01		dec $01		                dec cp+1
.83b0						_done:
.83b0		60		rts		z_colon:        rts
.83b1						xt_colon_noname:
.83b1		a5 1a		lda $1a		                lda state
.83b3		05 1b		ora $1b		                ora state+1
.83b5		f0 05		beq $83bc	                beq +
.83b7		a9 07		lda #$07	                lda #err_state
.83b9		4c 55 d8	jmp $d855	                jmp error
.83bc						+
.83bc		c6 1a		dec $1a		                dec state
.83be		c6 1b		dec $1b		                dec state+1
.83c0		a9 40		lda #$40	                lda #%01000000
.83c2		14 1c		trb $1c		                trb status
.83c4		a5 00		lda $00		                lda cp
.83c6		85 06		sta $06		                sta workword
.83c8		a5 01		lda $01		                lda cp+1
.83ca		85 07		sta $07		                sta workword+1
.83cc		60		rts		z_colon_noname:        rts
.83cd						xt_comma:
.83cd		20 3f d8	jsr $d83f	                jsr underflow_1
.83d0		a0 02		ldy #$02	                ldy #2
.83d2		b5 00		lda $00,x	_twice:         lda 0,x
.83d4		20 84 97	jsr $9784	                jsr cmpl_a
.83d7		e8		inx		                inx
.83d8		88		dey		                dey
.83d9		d0 f7		bne $83d2	                bne _twice
.83db		60		rts		z_comma:        rts
.83dc						xt_compile_only:
.83dc		20 96 d7	jsr $d796	                jsr current_to_dp
.83df		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.83e1		b1 02		lda ($02),y	                lda (dp),y
.83e3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.83e5		91 02		sta ($02),y	                sta (dp),y
.83e7		60		rts		z_compile_only: rts
.83e8						xt_value:
.83e8						xt_constant:
.83e8		20 3f d8	jsr $d83f	                jsr underflow_1
.83eb		20 40 84	jsr $8440	                jsr xt_create
.83ee		38		sec		                sec
.83ef		a5 00		lda $00		                lda cp
.83f1		e9 02		sbc #$02	                sbc #2
.83f3		85 25		sta $25		                sta tmp1
.83f5		a5 01		lda $01		                lda cp+1
.83f7		e9 00		sbc #$00	                sbc #0
.83f9		85 26		sta $26		                sta tmp1+1
.83fb		a9 a7		lda #$a7	                lda #<doconst           ; LSB of DOCONST
.83fd		92 25		sta ($25)	                sta (tmp1)
.83ff		a0 01		ldy #$01	                ldy #1
.8401		a9 d6		lda #$d6	                lda #>doconst           ; MSB of DOCONST
.8403		91 25		sta ($25),y	                sta (tmp1),y
.8405		20 cd 83	jsr $83cd	                jsr xt_comma            ; drop through to adjust_z
.8408						adjust_z:
.8408		20 1e 9c	jsr $9c1e	                jsr xt_latestnt         ; gives us ( -- nt )
.840b		b5 00		lda $00,x	                lda 0,x
.840d		85 25		sta $25		                sta tmp1
.840f		b5 01		lda $01,x	                lda 1,x
.8411		85 26		sta $26		                sta tmp1+1
.8413		a0 06		ldy #$06	                ldy #6
.8415		b1 25		lda ($25),y	                lda (tmp1),y
.8417		18		clc		                clc
.8418		69 02		adc #$02	                adc #2
.841a		91 25		sta ($25),y	                sta (tmp1),y
.841c		c8		iny		                iny
.841d		b1 25		lda ($25),y	                lda (tmp1),y
.841f		69 00		adc #$00	                adc #0                  ; only need carry
.8421		91 25		sta ($25),y	                sta (tmp1),y
.8423		e8		inx		                inx
.8424		e8		inx		                inx
.8425						z_value:
.8425		60		rts		z_constant:     rts
.8426						xt_count:
.8426		20 3f d8	jsr $d83f	                jsr underflow_1
.8429		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.842b		a8		tay		                tay
.842c		f6 00		inc $00,x	                inc 0,x         ; LSB
.842e		d0 02		bne $8432	                bne +
.8430		f6 01		inc $01,x	                inc 1,x         ; MSB
.8432		98		tya		+               tya
.8433		ca		dex		                dex
.8434		ca		dex		                dex
.8435		95 00		sta $00,x	                sta 0,x         ; LSB
.8437		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8439		60		rts		z_count:        rts
.843a						xt_cr:
.843a		a9 0a		lda #$0a	                lda #AscLF
.843c		20 c5 86	jsr $86c5	                jsr emit_a
.843f		60		rts		z_cr:           rts
.8440						xt_create:
.8440		20 5d 8d	jsr $8d5d	                jsr xt_parse_name       ; ( addr u )
.8443		b5 00		lda $00,x	                lda 0,x
.8445		15 01		ora $01,x	                ora 1,x
.8447		d0 05		bne $844e	                bne _got_name
.8449		a9 05		lda #$05	                lda #err_noname
.844b		4c 55 d8	jmp $d855	                jmp error
.844e						_got_name:
.844e		74 01		stz $01,x	                stz 1,x
.8450		20 bb 93	jsr $93bb	                jsr xt_two_dup          ; ( addr u addr u )
.8453		20 ea 9a	jsr $9aea	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8456		b5 00		lda $00,x	                lda 0,x
.8458		15 01		ora $01,x	                ora 1,x
.845a		f0 1e		beq $847a	                beq _new_name           ; We haven't seen this one before.
.845c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.845d		e8		inx		                inx
.845e		24 1c		bit $1c		                bit status
.8460		10 08		bpl $846a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8462		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8464		05 1c		ora $1c		                ora status
.8466		85 1c		sta $1c		                sta status
.8468		80 18		bra $8482	                bra _process_name
.846a						_redefined_name:
.846a		a9 02		lda #$02	                lda #str_redefined
.846c		20 7b d8	jsr $d87b	                jsr print_string_no_lf
.846f		20 bb 93	jsr $93bb	                jsr xt_two_dup           ; ( addr u addr u )
.8472		20 d0 94	jsr $94d0	                jsr xt_type
.8475		20 d7 91	jsr $91d7	                jsr xt_space
.8478		80 08		bra $8482	                bra _process_name
.847a						_new_name:
.847a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.847b		e8		inx		                inx
.847c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.847e		25 1c		and $1c		                and status
.8480		85 1c		sta $1c		                sta status
.8482						_process_name:
.8482		b5 00		lda $00,x	                lda 0,x
.8484		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8486		a5 00		lda $00		                lda cp
.8488		85 25		sta $25		                sta tmp1
.848a		a5 01		lda $01		                lda cp+1
.848c		85 26		sta $26		                sta tmp1+1
.848e		b5 00		lda $00,x	                lda 0,x
.8490		18		clc		                clc
.8491		69 08		adc #$08	                adc #8
.8493		85 29		sta $29		                sta tmp3                ; total header length
.8495		95 00		sta $00,x	                sta 0,x
.8497		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.8499		20 27 82	jsr $8227	                jsr xt_allot    ; ( addr )
.849c		20 96 d7	jsr $d796	                jsr current_to_dp
.849f		a0 00		ldy #$00	                ldy #0
.84a1		a5 27		lda $27		                lda tmp2
.84a3		91 25		sta ($25),y	                sta (tmp1),y
.84a5		a9 08		lda #$08	                lda #NN
.84a7		09 20		ora #$20	                ora #HC
.84a9		c8		iny		                iny
.84aa		91 25		sta ($25),y	                sta (tmp1),y
.84ac		c8		iny		                iny
.84ad		a5 02		lda $02		                lda dp
.84af		91 25		sta ($25),y	                sta (tmp1),y
.84b1		c8		iny		                iny
.84b2		a5 03		lda $03		                lda dp+1
.84b4		91 25		sta ($25),y	                sta (tmp1),y
.84b6		c8		iny		                iny
.84b7		a5 26		lda $26		                lda tmp1+1
.84b9		85 03		sta $03		                sta dp+1
.84bb		a5 25		lda $25		                lda tmp1
.84bd		85 02		sta $02		                sta dp
.84bf		18		clc		                clc
.84c0		65 29		adc $29		                adc tmp3        ; add total header length
.84c2		91 25		sta ($25),y	                sta (tmp1),y
.84c4		48		pha		                pha             ; we need this in the next step
.84c5		c8		iny		                iny
.84c6		a5 26		lda $26		                lda tmp1+1
.84c8		69 00		adc #$00	                adc #0          ; only need the carry
.84ca		91 25		sta ($25),y	                sta (tmp1),y
.84cc		c8		iny		                iny
.84cd		68		pla		                pla             ; LSB of "z_" address
.84ce		18		clc		                clc
.84cf		69 03		adc #$03	                adc #3
.84d1		91 25		sta ($25),y	                sta (tmp1),y
.84d3		88		dey		                dey             ; get the MSB of xt back
.84d4		b1 25		lda ($25),y	                lda (tmp1),y
.84d6		69 00		adc #$00	                adc #0          ; only need the carry
.84d8		c8		iny		                iny
.84d9		c8		iny		                iny
.84da		91 25		sta ($25),y	                sta (tmp1),y
.84dc		c8		iny		                iny
.84dd		b5 00		lda $00,x	                lda 0,x
.84df		38		sec		                sec
.84e0		e9 08		sbc #$08	                sbc #8
.84e2		85 23		sta $23		                sta tmptos
.84e4		b5 01		lda $01,x	                lda 1,x
.84e6		e9 00		sbc #$00	                sbc #0          ; only need carry
.84e8		85 24		sta $24		                sta tmptos+1
.84ea						_name_loop:
.84ea		b1 23		lda ($23),y	                lda (tmptos),y
.84ec		c9 5b		cmp #$5b	                cmp #'Z'+1
.84ee		b0 06		bcs $84f6	                bcs _store_name
.84f0		c9 41		cmp #$41	                cmp #'A'
.84f2		90 02		bcc $84f6	                bcc _store_name
.84f4		09 20		ora #$20	                ora #$20
.84f6						_store_name:
.84f6		91 25		sta ($25),y	                sta (tmp1),y
.84f8		c8		iny		                iny
.84f9		c6 27		dec $27		                dec tmp2
.84fb		d0 ed		bne $84ea	                bne _name_loop
.84fd		a0 d6		ldy #$d6	                ldy #>dovar
.84ff		a9 ed		lda #$ed	                lda #<dovar
.8501		20 74 97	jsr $9774	                jsr cmpl_subroutine
.8504		20 a9 d7	jsr $d7a9	                jsr dp_to_current
.8507		e8		inx		                inx
.8508		e8		inx		                inx
.8509		60		rts		z_create:       rts
.850a						xt_decimal:
.850a		a9 0a		lda #$0a	                lda #10
.850c		85 18		sta $18		                sta base
.850e		64 19		stz $19		                stz base+1              ; paranoid
.8510		60		rts		z_decimal:      rts
.8511						xt_defer:
.8511		20 40 84	jsr $8440	                jsr xt_create
.8514		a5 00		lda $00		                lda cp          ; LSB
.8516		38		sec		                sec
.8517		e9 02		sbc #$02	                sbc #2
.8519		85 25		sta $25		                sta tmp1
.851b		a5 01		lda $01		                lda cp+1        ; MSB
.851d		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.851f		85 26		sta $26		                sta tmp1+1
.8521		a0 00		ldy #$00	                ldy #0
.8523		a9 bb		lda #$bb	                lda #<dodefer   ; LSB
.8525		91 25		sta ($25),y	                sta (tmp1),y
.8527		c8		iny		                iny
.8528		a9 d6		lda #$d6	                lda #>dodefer   ; MSB
.852a		91 25		sta ($25),y	                sta (tmp1),y
.852c		a9 cf		lda #$cf	                lda #<defer_error
.852e		92 00		sta ($00)	                sta (cp)
.8530		e6 00		inc $00		                inc cp
.8532		d0 02		bne $8536	                bne +
.8534		e6 01		inc $01		                inc cp+1
.8536						+
.8536		a9 d6		lda #$d6	                lda #>defer_error
.8538		92 00		sta ($00)	                sta (cp)
.853a		e6 00		inc $00		                inc cp
.853c		d0 02		bne $8540	                bne +
.853e		e6 01		inc $01		                inc cp+1
.8540						+
.8540		20 08 84	jsr $8408	                jsr adjust_z    ; adjust header to correct length
.8543		60		rts		z_defer:        rts
.8544						xt_defer_fetch:
.8544		20 aa 92	jsr $92aa	                jsr xt_to_body
.8547		20 1a 88	jsr $881a	                jsr xt_fetch
.854a		60		rts		z_defer_fetch:  rts
.854b						xt_defer_store:
.854b		20 aa 92	jsr $92aa	                jsr xt_to_body
.854e		20 24 92	jsr $9224	                jsr xt_store
.8551		60		rts		z_defer_store:  rts
.8552						xt_depth:
.8552		a9 78		lda #$78	                lda #dsp0
.8554		86 1e		stx $1e		                stx tmpdsp
.8556		38		sec		                sec
.8557		e5 1e		sbc $1e		                sbc tmpdsp
.8559		4a		lsr a		                lsr
.855a		ca		dex		                dex
.855b		ca		dex		                dex
.855c		95 00		sta $00,x	                sta 0,x
.855e		74 01		stz $01,x	                stz 1,x
.8560		60		rts		z_depth:        rts
.8561						xt_question_do:
.8561		ca		dex		                dex
.8562		ca		dex		                dex
.8563		a9 a4		lda #$a4	                lda #<question_do_runtime
.8565		95 00		sta $00,x	                sta 0,x
.8567		a9 85		lda #$85	                lda #>question_do_runtime
.8569		95 01		sta $01,x	                sta 1,x
.856b		20 a0 86	jsr $86a0	                jsr xt_dup              ; xt and xt' are the same
.856e		ca		dex		                dex
.856f		ca		dex		                dex
.8570		a9 10		lda #$10	                lda #question_do_runtime_size
.8572		95 00		sta $00,x	                sta 0,x
.8574		74 01		stz $01,x	                stz 1,x
.8576		20 3f 97	jsr $973f	                jsr cmpl_by_limit
.8579		90 0b		bcc $8586	                bcc _native
.857b		20 1b 89	jsr $891b	                jsr xt_here
.857e		20 f6 9d	jsr $9df6	                jsr xt_zero
.8581		20 cd 83	jsr $83cd	                jsr xt_comma
.8584		80 08		bra $858e	                bra do_common
.8586						_native:
.8586		20 95 97	jsr $9795	                jsr cmpl_jump_later
.8589		80 03		bra $858e	                bra do_common
.858b						xt_do:
.858b		20 f6 9d	jsr $9df6	                jsr xt_zero             ; push 0 TOS
.858e						do_common:
.858e		ca		dex		                dex
.858f		ca		dex		                dex
.8590		a5 21		lda $21		                lda loopleave
.8592		95 00		sta $00,x	                sta 0,x
.8594		a5 22		lda $22		                lda loopleave+1
.8596		95 01		sta $01,x	                sta 1,x
.8598		64 22		stz $22		                stz loopleave+1
.859a		a0 85		ldy #$85	                ldy #>do_runtime
.859c		a9 bc		lda #$bc	                lda #<do_runtime
.859e		20 74 97	jsr $9774	                jsr cmpl_subroutine
.85a1		4c 1b 89	jmp $891b	                jmp xt_here
.85a4						z_question_do:
.85a4						z_do:
.85a4						question_do_runtime:
.85a4		b5 00		lda $00,x	                lda 0,x
.85a6		d5 02		cmp $02,x	                cmp 2,x
.85a8		d0 0d		bne $85b7	                bne _begin
.85aa		b5 01		lda $01,x	                lda 1,x
.85ac		d5 03		cmp $03,x	                cmp 3,x
.85ae		d0 07		bne $85b7	                bne _begin
.85b0		e8		inx		                inx                     ; drop loop limits and skip
.85b1		e8		inx		                inx
.85b2		e8		inx		                inx
.85b3		e8		inx		                inx
=16						question_do_runtime_size = * - question_do_runtime
.85b4		a9 00		lda #$00	                lda #0
>85b6		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.85b7		a9 01		lda #$01	_begin:         lda #1
.85b9		4c 2e 98	jmp $982e	                jmp zbranch_runtime
.85bc						do_runtime:
.85bc		a4 1f		ldy $1f		                ldy loopctrl
.85be		30 05		bmi $85c5	                bmi +                   ; is this the first LCB?
.85c0		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.85c2		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.85c5						+
.85c5		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.85c6		c8		iny		                iny
.85c7		c8		iny		                iny
.85c8		c8		iny		                iny
.85c9		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.85cb		38		sec		                sec
.85cc		a9 00		lda #$00	                lda #0
.85ce		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.85d0		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.85d3		a9 80		lda #$80	                lda #$80
.85d5		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.85d7		99 03 01	sta $0103,y	                sta loopfufa+1,y
.85da		18		clc		                clc
.85db		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.85dd		79 02 01	adc $0102,y	                adc loopfufa,y
.85e0		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.85e2		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.85e4		79 03 01	adc $0103,y	                adc loopfufa+1,y
.85e7		99 01 01	sta $0101,y	                sta loopindex+1,y
.85ea		e8		inx		                inx                 ; clean up the stack
.85eb		e8		inx		                inx
.85ec		e8		inx		                inx
.85ed		e8		inx		                inx
.85ee		60		rts		                rts
.85ef						xt_does:
.85ef		a0 85		ldy #$85	                ldy #>does_runtime
.85f1		a9 fe		lda #$fe	                lda #<does_runtime
.85f3		20 74 97	jsr $9774	                jsr cmpl_subroutine
.85f6		a0 d6		ldy #$d6	                ldy #>dodoes
.85f8		a9 d4		lda #$d4	                lda #<dodoes
.85fa		20 74 97	jsr $9774	                jsr cmpl_subroutine
.85fd		60		rts		z_does:         rts
.85fe						does_runtime:
.85fe		7a		ply		                ply             ; LSB
.85ff		68		pla		                pla             ; MSB
.8600		c8		iny		                iny
.8601		d0 01		bne $8604	                bne +
.8603		1a		inc a		                ina
.8604						+
.8604		84 25		sty $25		                sty tmp1
.8606		85 26		sta $26		                sta tmp1+1
.8608		20 96 d7	jsr $d796	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.860b		a5 02		lda $02		                lda dp
.860d		18		clc		                clc
.860e		69 04		adc #$04	                adc #4
.8610		85 27		sta $27		                sta tmp2
.8612		a5 03		lda $03		                lda dp+1
.8614		69 00		adc #$00	                adc #0          ; we only care about the carry
.8616		85 28		sta $28		                sta tmp2+1
.8618		b2 27		lda ($27)	                lda (tmp2)
.861a		18		clc		                clc
.861b		69 01		adc #$01	                adc #1
.861d		85 29		sta $29		                sta tmp3
.861f		a0 01		ldy #$01	                ldy #1
.8621		b1 27		lda ($27),y	                lda (tmp2),y
.8623		69 00		adc #$00	                adc #0          ; we only care about the carry
.8625		85 2a		sta $2a		                sta tmp3+1
.8627		a5 25		lda $25		                lda tmp1        ; LSB
.8629		92 29		sta ($29)	                sta (tmp3)
.862b		a5 26		lda $26		                lda tmp1+1
.862d		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.862f		60		rts		                rts
.8630						xt_dot:
.8630		20 3f d8	jsr $d83f	                jsr underflow_1
.8633		20 a0 86	jsr $86a0	                jsr xt_dup                      ; ( n n )
.8636		20 cf 80	jsr $80cf	                jsr xt_abs                      ; ( n u )
.8639		20 f6 9d	jsr $9df6	                jsr xt_zero                     ; ( n u 0 )
.863c		20 e1 89	jsr $89e1	                jsr xt_less_number_sign         ; ( n u 0 )
.863f		20 bf 8c	jsr $8cbf	                jsr xt_number_sign_s            ; ( n ud )
.8642		20 9d 8f	jsr $8f9d	                jsr xt_rot                      ; ( ud n )
.8645		20 5c 91	jsr $915c	                jsr xt_sign                     ; ( ud )
.8648		20 9d 8c	jsr $8c9d	                jsr xt_number_sign_greater      ; ( addr u )
.864b		20 d0 94	jsr $94d0	                jsr xt_type
.864e		20 d7 91	jsr $91d7	                jsr xt_space
.8651		60		rts		z_dot:          rts
.8652						xt_dot_paren:
.8652		ca		dex		                dex
.8653		ca		dex		                dex
.8654		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8656		95 00		sta $00,x	                sta 0,x
.8658		74 01		stz $01,x	                stz 1,x
.865a		20 b8 8d	jsr $8db8	                jsr xt_parse
.865d		20 d0 94	jsr $94d0	                jsr xt_type
.8660		60		rts		z_dot_paren:    rts
.8661						xt_dot_quote:
.8661		20 e6 8f	jsr $8fe6	                jsr xt_s_quote
.8664		a0 94		ldy #$94	                ldy #>xt_type
.8666		a9 d0		lda #$d0	                lda #<xt_type
.8668		20 74 97	jsr $9774	                jsr cmpl_subroutine
.866b		60		rts		z_dot_quote:    rts
.866c						xt_dot_r:
.866c		20 44 d8	jsr $d844	                jsr underflow_2
.866f		20 78 93	jsr $9378	                jsr xt_to_r
.8672		20 a0 86	jsr $86a0	                jsr xt_dup
.8675		20 cf 80	jsr $80cf	                jsr xt_abs
.8678		20 f6 9d	jsr $9df6	                jsr xt_zero
.867b		20 e1 89	jsr $89e1	                jsr xt_less_number_sign
.867e		20 bf 8c	jsr $8cbf	                jsr xt_number_sign_s
.8681		20 9d 8f	jsr $8f9d	                jsr xt_rot
.8684		20 5c 91	jsr $915c	                jsr xt_sign
.8687		20 9d 8c	jsr $8c9d	                jsr xt_number_sign_greater
.868a		20 fc 8e	jsr $8efc	                jsr xt_r_from
.868d		20 11 8d	jsr $8d11	                jsr xt_over
.8690		20 f6 8b	jsr $8bf6	                jsr xt_minus
.8693		20 dd 91	jsr $91dd	                jsr xt_spaces
.8696		20 d0 94	jsr $94d0	                jsr xt_type
.8699		60		rts		z_dot_r:        rts
.869a						xt_drop:
.869a		20 3f d8	jsr $d83f	                jsr underflow_1
.869d		e8		inx		                inx
.869e		e8		inx		                inx
.869f		60		rts		z_drop:         rts
.86a0						xt_dup:
.86a0		20 3f d8	jsr $d83f	                jsr underflow_1
.86a3		ca		dex		                dex
.86a4		ca		dex		                dex
.86a5		b5 02		lda $02,x	                lda 2,x         ; LSB
.86a7		95 00		sta $00,x	                sta 0,x
.86a9		b5 03		lda $03,x	                lda 3,x         ; MSB
.86ab		95 01		sta $01,x	                sta 1,x
.86ad		60		rts		z_dup:          rts
.86ae						xt_else:
.86ae						xt_endof:
.86ae		20 95 97	jsr $9795	                jsr cmpl_jump_later
.86b1		20 3a 92	jsr $923a	                jsr xt_swap         ; ( target orig )
.86b4						xt_then:
.86b4		20 1b 89	jsr $891b	                jsr xt_here
.86b7		20 3a 92	jsr $923a	                jsr xt_swap
.86ba		20 24 92	jsr $9224	                jsr xt_store
.86bd						z_else:
.86bd						z_endof:
.86bd		60		rts		z_then:         rts
.86be						xt_emit:
.86be		20 3f d8	jsr $d83f	                jsr underflow_1
.86c1		b5 00		lda $00,x	                lda 0,x
.86c3		e8		inx		                inx
.86c4		e8		inx		                inx
.86c5						emit_a:
.86c5		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.86c8						z_emit:
.86c8						xt_endcase:
.86c8		a0 86		ldy #$86	                ldy #>xt_drop
.86ca		a9 9a		lda #$9a	                lda #<xt_drop
.86cc		20 74 97	jsr $9774	                jsr cmpl_subroutine
.86cf						_endcase_loop:
.86cf		b5 00		lda $00,x	                lda 0,x
.86d1		15 01		ora $01,x	                ora 1,x
.86d3		f0 05		beq $86da	                beq _done
.86d5		20 b4 86	jsr $86b4	                jsr xt_then
.86d8		80 f5		bra $86cf	                bra _endcase_loop
.86da						_done:
.86da		e8		inx		                inx
.86db		e8		inx		                inx
.86dc		60		rts		z_endcase:      rts
.86dd						xt_environment_q:
.86dd		20 3f d8	jsr $d83f	                jsr underflow_1
.86e0		a0 00		ldy #$00	                ldy #00                 ; counter for table
.86e2		5a		phy		                phy
.86e3						_table_loop:
.86e3		20 bb 93	jsr $93bb	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.86e6		ca		dex		                dex
.86e7		ca		dex		                dex                     ; ( addr u addr u ? )
.86e8		b9 5a 87	lda $875a,y	                lda env_table_single,y
.86eb		95 00		sta $00,x	                sta 0,x
.86ed		c8		iny		                iny
.86ee		b9 5a 87	lda $875a,y	                lda env_table_single,y
.86f1		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.86f3		c8		iny		                iny
.86f4		15 00		ora $00,x	                ora 0,x
.86f6		f0 4d		beq $8745	                beq _table_done
.86f8		5a		phy		                phy                     ; save Y, which is used by COUNT
.86f9		20 26 84	jsr $8426	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.86fc		20 24 a0	jsr $a024	                jsr xt_compare          ; ( addr u f )
.86ff		7a		ply		                ply
.8700		b5 00		lda $00,x	                lda 0,x
.8702		15 01		ora $01,x	                ora 1,x
.8704		f0 04		beq $870a	                beq _got_result
.8706		e8		inx		                inx                     ; DROP, now ( addr u )
.8707		e8		inx		                inx
.8708		80 d9		bra $86e3	                bra _table_loop
.870a						_got_result:
.870a		e8		inx		                inx                     ; drop flag, now ( addr u )
.870b		e8		inx		                inx
.870c		88		dey		                dey                     ; go back to index we had
.870d		88		dey		                dey
.870e		68		pla		                pla
.870f		d0 0d		bne $871e	                bne _double_result
.8711		b9 78 87	lda $8778,y	                lda env_results_single,y
.8714		95 02		sta $02,x	                sta 2,x
.8716		c8		iny		                iny
.8717		b9 78 87	lda $8778,y	                lda env_results_single,y
.871a		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.871c		80 1f		bra $873d	                bra _set_flag
.871e						_double_result:
.871e		ca		dex		                dex                     ; ( addr u ? )
.871f		ca		dex		                dex
.8720		98		tya		                tya
.8721		38		sec		                sec
.8722		e9 18		sbc #$18	                sbc #24
.8724		0a		asl a		                asl
.8725		a8		tay		                tay
.8726		b9 8e 87	lda $878e,y	                lda env_results_double,y
.8729		95 02		sta $02,x	                sta 2,x
.872b		c8		iny		                iny
.872c		b9 8e 87	lda $878e,y	                lda env_results_double,y
.872f		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8731		c8		iny		                iny
.8732		b9 8e 87	lda $878e,y	                lda env_results_double,y
.8735		95 04		sta $04,x	                sta 4,x
.8737		c8		iny		                iny
.8738		b9 8e 87	lda $878e,y	                lda env_results_double,y
.873b		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.873d						_set_flag:
.873d		a9 ff		lda #$ff	                lda #$FF
.873f		95 00		sta $00,x	                sta 0,x
.8741		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8743		80 14		bra $8759	                bra _done
.8745						_table_done:
.8745		68		pla		                pla
.8746		d0 09		bne $8751	                bne _no_match
.8748		1a		inc a		                ina
.8749		48		pha		                pha
.874a		8a		txa		                txa
.874b		18		clc		                clc
.874c		69 06		adc #$06	                adc #6                  ; skip six bytes
.874e		aa		tax		                tax                     ; ( addr u )
.874f		80 92		bra $86e3	                bra _table_loop
.8751						_no_match:
.8751		8a		txa		                txa
.8752		18		clc		                clc
.8753		69 0a		adc #$0a	                adc #10
.8755		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8756		20 f6 9d	jsr $9df6	                jsr xt_false
.8759						_done:
.8759						z_environment_q:
.8759		60		rts		                rts
.875a						env_table_single:
>875a		27 d6 37 d6 3d d6 42 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8762		54 d6
>8764		5c d6 65 d6 6b d6 71 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>876c		84 d6 90 d6 00 00		        .word envs_sc, envs_wl, 0000
.8772						env_table_double:
>8772		9a d6 a0 d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8778						env_results_single:
>8778		ff 00				        .word $00FF     ; /COUNTED-STRING
>877a		ff 00				        .word $00FF     ; /HOLD
>877c		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>877e		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8780		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8782		ff 00				        .word $00FF     ; MAX-CHAR
>8784		ff 7f				        .word $7FFF     ; MAX-N
>8786		ff ff				        .word $FFFF     ; MAX-U
>8788		80 00				        .word $0080     ; RETURN-STACK-CELLS
>878a		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>878c		09 00				        .word $0009     ; WORDLISTS
.878e						env_results_double:
>878e		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8792		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8796						xt_equal:
.8796		20 44 d8	jsr $d844	                jsr underflow_2
.8799		b5 00		lda $00,x	                lda 0,x                 ; LSB
.879b		d5 02		cmp $02,x	                cmp 2,x
.879d		d0 0a		bne $87a9	                bne _false
.879f		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87a1		d5 03		cmp $03,x	                cmp 3,x
.87a3		d0 04		bne $87a9	                bne _false
.87a5		a9 ff		lda #$ff	                lda #$FF
.87a7		80 02		bra $87ab	                bra _done
.87a9		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.87ab		95 02		sta $02,x	_done:          sta 2,x
.87ad		95 03		sta $03,x	                sta 3,x
.87af		e8		inx		                inx
.87b0		e8		inx		                inx
.87b1		60		rts		z_equal:        rts
.87b2						xt_blank:
.87b2		ca		dex		                dex
.87b3		ca		dex		                dex
.87b4		a9 20		lda #$20	                lda #AscSP
.87b6		95 00		sta $00,x	                sta 0,x
.87b8		74 01		stz $01,x	                stz 1,x
.87ba		80 06		bra $87c2	                bra xt_fill     ; skip over code for ERASE
.87bc						xt_erase:
.87bc		ca		dex		                dex
.87bd		ca		dex		                dex
.87be		74 00		stz $00,x	                stz 0,x
.87c0		74 01		stz $01,x	                stz 1,x
.87c2						xt_fill:
.87c2		20 49 d8	jsr $d849	                jsr underflow_3
.87c5		b5 04		lda $04,x	                lda 4,x         ; LSB
.87c7		85 25		sta $25		                sta tmp1
.87c9		b5 05		lda $05,x	                lda 5,x
.87cb		85 26		sta $26		                sta tmp1+1
.87cd		b5 02		lda $02,x	                lda 2,x
.87cf		85 27		sta $27		                sta tmp2
.87d1		b5 03		lda $03,x	                lda 3,x
.87d3		85 28		sta $28		                sta tmp2+1
.87d5		b5 00		lda $00,x	                lda 0,x
.87d7		a8		tay		                tay
.87d8						_loop:
.87d8		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.87da		c5 26		cmp $26		                cmp tmp1+1
.87dc		90 21		bcc $87ff	                bcc _done               ; RAM_END < TMP1, so leave
.87de		d0 06		bne $87e6	                bne _check_counter      ; RAM_END is not smaller and not equal
.87e0		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.87e2		c5 25		cmp $25		                cmp tmp1
.87e4		90 19		bcc $87ff	                bcc _done               ; RAM_END < TMP1, so leave
.87e6						_check_counter:
.87e6		a5 27		lda $27		                lda tmp2
.87e8		05 28		ora $28		                ora tmp2+1
.87ea		f0 13		beq $87ff	                beq _done
.87ec		98		tya		                tya
.87ed		92 25		sta ($25)	                sta (tmp1)
.87ef		a5 27		lda $27		                lda tmp2
.87f1		d0 02		bne $87f5	                bne +
.87f3		c6 28		dec $28		                dec tmp2+1
.87f5		c6 27		dec $27		+               dec tmp2
.87f7		e6 25		inc $25		                inc tmp1
.87f9		d0 dd		bne $87d8	                bne _loop
.87fb		e6 26		inc $26		                inc tmp1+1
.87fd		80 d9		bra $87d8	                bra _loop
.87ff						_done:
.87ff		8a		txa		                txa
.8800		18		clc		                clc
.8801		69 06		adc #$06	                adc #6
.8803		aa		tax		                tax
.8804						z_blank:
.8804						z_erase:
.8804		60		rts		z_fill:         rts
.8805						xt_execute:
.8805		20 3f d8	jsr $d83f	                jsr underflow_1
.8808		20 0c 88	jsr $880c	                jsr doexecute   ; do not combine to JMP (native coding)
.880b		60		rts		z_execute:      rts
.880c						doexecute:
.880c		b5 00		lda $00,x	                lda 0,x
.880e		85 04		sta $04		                sta ip
.8810		b5 01		lda $01,x	                lda 1,x
.8812		85 05		sta $05		                sta ip+1
.8814		e8		inx		                inx
.8815		e8		inx		                inx
.8816		6c 04 00	jmp ($0004)	                jmp (ip)
.8819						xt_exit:
.8819		60		rts		                rts             ; keep before z_exit
.881a						z_exit:
.881a						xt_fetch:
.881a		20 3f d8	jsr $d83f	                jsr underflow_1
.881d		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.881f		a8		tay		                tay
.8820		f6 00		inc $00,x	                inc 0,x
.8822		d0 02		bne $8826	                bne +
.8824		f6 01		inc $01,x	                inc 1,x
.8826						+
.8826		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8828		95 01		sta $01,x	                sta 1,x
.882a		94 00		sty $00,x	                sty 0,x
.882c		60		rts		z_fetch:        rts
.882d						xt_find:
.882d		20 3f d8	jsr $d83f	                jsr underflow_1
.8830		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8832		48		pha		                pha
.8833		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8835		48		pha		                pha
.8836		20 26 84	jsr $8426	                jsr xt_count            ; ( caddr -- addr u )
.8839		20 ea 9a	jsr $9aea	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.883c		b5 00		lda $00,x	                lda 0,x
.883e		15 01		ora $01,x	                ora 1,x
.8840		d0 0b		bne $884d	                bne _found_word
.8842		20 f6 9d	jsr $9df6	                jsr xt_false            ; ( 0 0 )
.8845		68		pla		                pla                     ; LSB of address
.8846		95 02		sta $02,x	                sta 2,x
.8848		68		pla		                pla
.8849		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.884b		80 27		bra $8874	                bra _done               ; ( addr 0 )
.884d						_found_word:
.884d		68		pla		                pla
.884e		68		pla		                pla
.884f		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.8852		20 33 9c	jsr $9c33	                jsr xt_name_to_int      ; ( nt xt )
.8855		20 3a 92	jsr $923a	                jsr xt_swap             ; ( xt nt )
.8858		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.885a		f6 00		inc $00,x	                inc 0,x
.885c		d0 02		bne $8860	                bne +
.885e		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8860						+
.8860		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8862		29 04		and #$04	                and #IM
.8864		d0 08		bne $886e	                bne _immediate          ; bit set, we're immediate
.8866		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8868		95 00		sta $00,x	                sta 0,x
.886a		95 01		sta $01,x	                sta 1,x
.886c		80 06		bra $8874	                bra _done
.886e						_immediate:
.886e		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8870		95 00		sta $00,x	                sta 0,x
.8872		74 01		stz $01,x	                stz 1,x
.8874						_done:
.8874		60		rts		z_find:         rts
.8875						xt_fm_slash_mod:
.8875		20 49 d8	jsr $d849	                jsr underflow_3
.8878		64 27		stz $27		                stz tmp2        ; default: n is positive
.887a		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.887c		10 0e		bpl $888c	                bpl _check_d
.887e		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.8880		20 31 8c	jsr $8c31	                jsr xt_negate   ; NEGATE
.8883		20 78 93	jsr $9378	                jsr xt_to_r     ; >R
.8886		20 64 9e	jsr $9e64	                jsr xt_dnegate  ; DNEGATE
.8889		20 fc 8e	jsr $8efc	                jsr xt_r_from   ; R>
.888c						_check_d:
.888c		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.888e		10 0d		bpl $889d	                bpl _multiply
.8890		18		clc		                clc
.8891		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.8893		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.8895		95 02		sta $02,x	                sta 2,x
.8897		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8899		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.889b		95 03		sta $03,x	                sta 3,x
.889d						_multiply:
.889d		20 55 95	jsr $9555	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.88a0		a5 27		lda $27		                lda tmp2
.88a2		f0 07		beq $88ab	                beq _done
.88a4		e8		inx		                inx             ; pretend that we SWAP
.88a5		e8		inx		                inx
.88a6		20 31 8c	jsr $8c31	                jsr xt_negate
.88a9		ca		dex		                dex
.88aa		ca		dex		                dex
.88ab						_done:
.88ab		60		rts		z_fm_slash_mod: rts
.88ac						load_evaluate:
.88ac		a9 ff		lda #$ff	                lda #$FF
.88ae		85 25		sta $25		                sta tmp1
.88b0		80 11		bra $88c3	                bra load_evaluate_start
.88b2						xt_evaluate:
.88b2		20 44 d8	jsr $d844	                jsr underflow_2
.88b5		64 25		stz $25		                stz tmp1
.88b7		b5 00		lda $00,x	                lda 0,x
.88b9		15 01		ora $01,x	                ora 1,x
.88bb		d0 06		bne $88c3	                bne evaluate_got_work
.88bd		e8		inx		                inx
.88be		e8		inx		                inx
.88bf		e8		inx		                inx
.88c0		e8		inx		                inx
.88c1		80 42		bra $8905	                bra evaluate_done
.88c3						load_evaluate_start:
.88c3						evaluate_got_work:
.88c3		a0 05		ldy #$05	                ldy #blk_offset+1
.88c5		b1 08		lda ($08),y	                lda (up),y
.88c7		48		pha		                pha
.88c8		88		dey		                dey
.88c9		b1 08		lda ($08),y	                lda (up),y
.88cb		48		pha		                pha
.88cc		a5 25		lda $25		                lda tmp1
.88ce		d0 05		bne $88d5	                bne _nozero
.88d0		91 08		sta ($08),y	                sta (up),y
.88d2		c8		iny		                iny
.88d3		91 08		sta ($08),y	                sta (up),y
.88d5						_nozero:
.88d5		20 97 9b	jsr $9b97	                jsr xt_input_to_r
.88d8		a9 ff		lda #$ff	                lda #$FF
.88da		85 0a		sta $0a		                sta insrc
.88dc		85 0b		sta $0b		                sta insrc+1
.88de		64 10		stz $10		                stz toin
.88e0		64 11		stz $11		                stz toin+1
.88e2		b5 00		lda $00,x	                lda 0,x
.88e4		85 0e		sta $0e		                sta ciblen
.88e6		b5 01		lda $01,x	                lda 1,x
.88e8		85 0f		sta $0f		                sta ciblen+1
.88ea		b5 02		lda $02,x	                lda 2,x
.88ec		85 0c		sta $0c		                sta cib
.88ee		b5 03		lda $03,x	                lda 3,x
.88f0		85 0d		sta $0d		                sta cib+1
.88f2		e8		inx		                inx             ; A clean stack is a clean mind
.88f3		e8		inx		                inx
.88f4		e8		inx		                inx
.88f5		e8		inx		                inx
.88f6		20 bc d7	jsr $d7bc	                jsr interpret   ; ( -- )
.88f9		20 a4 9d	jsr $9da4	                jsr xt_r_to_input
.88fc		a0 04		ldy #$04	                ldy #blk_offset
.88fe		68		pla		                pla
.88ff		91 08		sta ($08),y	                sta (up),y
.8901		c8		iny		                iny
.8902		68		pla		                pla
.8903		91 08		sta ($08),y	                sta (up),y
.8905						evaluate_done:
.8905		60		rts		z_evaluate:     rts
.8906						xt_greater_than:
.8906		20 44 d8	jsr $d844	                jsr underflow_2
.8909		a0 00		ldy #$00	                ldy #0          ; default false
.890b		20 7d d7	jsr $d77d	                jsr compare_16bit
.890e		f0 03		beq $8913	                beq _false
.8910		10 01		bpl $8913	                bpl _false
.8912		88		dey		                dey
.8913						_false:
.8913		98		tya		                tya
.8914		e8		inx		                inx
.8915		e8		inx		                inx
.8916		95 00		sta $00,x	                sta 0,x
.8918		95 01		sta $01,x	                sta 1,x
.891a		60		rts		z_greater_than: rts
.891b						xt_here:
.891b						xt_begin:
.891b						xt_asm_arrow:
.891b		ca		dex		                dex
.891c		ca		dex		                dex
.891d		a5 00		lda $00		                lda cp
.891f		95 00		sta $00,x	                sta 0,x
.8921		a5 01		lda $01		                lda cp+1
.8923		95 01		sta $01,x	                sta 1,x
.8925						z_here:
.8925						z_begin:
.8925						z_asm_arrow:
.8925		60		rts		                rts
.8926						xt_hex:
.8926		a9 10		lda #$10	                lda #16
.8928		85 18		sta $18		                sta base
.892a		64 19		stz $19		                stz base+1              ; paranoid
.892c		60		rts		z_hex:          rts
.892d						xt_hold:
.892d		20 3f d8	jsr $d83f	                jsr underflow_1
.8930		a5 2b		lda $2b		                lda tohold
.8932		d0 02		bne $8936	                bne +
.8934		c6 2c		dec $2c		                dec tohold+1
.8936						+
.8936		c6 2b		dec $2b		                dec tohold
.8938		b5 00		lda $00,x	                lda 0,x
.893a		92 2b		sta ($2b)	                sta (tohold)
.893c		e8		inx		                inx
.893d		e8		inx		                inx
.893e		60		rts		z_hold:         rts
.893f						xt_i:
.893f		ca		dex		                dex
.8940		ca		dex		                dex
.8941		a4 1f		ldy $1f		                ldy loopctrl
.8943		38		sec		                sec
.8944		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.8946		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8949		95 00		sta $00,x	                sta 0,x
.894b		b9 01 01	lda $0101,y	                lda loopindex+1,y
.894e		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8951		95 01		sta $01,x	                sta 1,x
.8953		60		rts		z_i:            rts
.8954						xt_if:
.8954		20 b1 97	jsr $97b1	                jsr cmpl_0branch_later
.8957		60		rts		z_if:           rts
.8958						xt_immediate:
.8958		20 96 d7	jsr $d796	                jsr current_to_dp
.895b		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.895d		b1 02		lda ($02),y	                lda (dp),y
.895f		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.8961		91 02		sta ($02),y	                sta (dp),y
.8963		60		rts		z_immediate:    rts
.8964						xt_invert:
.8964		20 3f d8	jsr $d83f	                jsr underflow_1
.8967		a9 ff		lda #$ff	                lda #$FF
.8969		55 00		eor $00,x	                eor 0,x         ; LSB
.896b		95 00		sta $00,x	                sta 0,x
.896d		a9 ff		lda #$ff	                lda #$FF
.896f		55 01		eor $01,x	                eor 1,x         ; MSB
.8971		95 01		sta $01,x	                sta 1,x
.8973		60		rts		z_invert:       rts
.8974						xt_is:
.8974		a5 1a		lda $1a		                lda state
.8976		05 1b		ora $1b		                ora state+1
.8978		f0 0c		beq $8986	                beq _interpreting
.897a		20 14 83	jsr $8314	                jsr xt_bracket_tick
.897d		a0 85		ldy #$85	                ldy #>xt_defer_store
.897f		a9 4b		lda #$4b	                lda #<xt_defer_store
.8981		20 74 97	jsr $9774	                jsr cmpl_subroutine
.8984		80 06		bra $898c	                bra _done
.8986						_interpreting:
.8986		20 4e 92	jsr $924e	                jsr xt_tick
.8989		20 4b 85	jsr $854b	                jsr xt_defer_store
.898c						_done:
.898c		60		rts		z_is:           rts
.898d						xt_j:
.898d		ca		dex		                dex                 ; make space on the stack
.898e		ca		dex		                dex
.898f		a5 1f		lda $1f		                lda loopctrl
.8991		38		sec		                sec
.8992		e9 04		sbc #$04	                sbc #4
.8994		a8		tay		                tay
.8995		38		sec		                sec
.8996		b9 00 01	lda $0100,y	                lda loopindex,y
.8999		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.899c		95 00		sta $00,x	                sta 0,x
.899e		b9 01 01	lda $0101,y	                lda loopindex+1,y
.89a1		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.89a4		95 01		sta $01,x	                sta 1,x
.89a6		60		rts		z_j:            rts
.89a7						xt_key:
.89a7		20 b1 89	jsr $89b1	                jsr key_a               ; returns char in A
.89aa		ca		dex		                dex
.89ab		ca		dex		                dex
.89ac		95 00		sta $00,x	                sta 0,x
.89ae		74 01		stz $01,x	                stz 1,x
.89b0		60		rts		z_key:          rts
.89b1						key_a:
.89b1		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.89b4						xt_keyq:
.89b4		a0 00		ldy #$00	                ldy #0
.89b6		20 c3 89	jsr $89c3	                jsr keyq_a
.89b9		f0 01		beq $89bc	                beq +           ; A=0 => Y=0
.89bb		88		dey		                dey             ; A<>0 => Y=#$ff
.89bc						+
.89bc		ca		dex		                dex
.89bd		ca		dex		                dex
.89be		94 00		sty $00,x	                sty 0,x         ; store either $0000 or $ffff
.89c0		94 01		sty $01,x	                sty 1,x
.89c2		60		rts		z_keyq:         rts
.89c3		6c 16 00	jmp ($0016)	keyq_a:         jmp (havekey)
.89c6						xt_leave:
.89c6		a5 21		lda $21		                lda loopleave
.89c8		a4 22		ldy $22		                ldy loopleave+1
.89ca		20 79 97	jsr $9779	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.89cd		38		sec		                sec
.89ce		a5 00		lda $00		                lda cp
.89d0		e9 02		sbc #$02	                sbc #2
.89d2		85 21		sta $21		                sta loopleave
.89d4		a5 01		lda $01		                lda cp+1
.89d6		b0 01		bcs $89d9	                bcs +
.89d8		3a		dec a		                dea
.89d9		85 22		sta $22		+               sta loopleave+1
.89db						z_leave:
.89db		60		rts		                rts
.89dc						xt_left_bracket:
.89dc		64 1a		stz $1a		                stz state
.89de		64 1b		stz $1b		                stz state+1
.89e0		60		rts		z_left_bracket: rts
.89e1						xt_less_number_sign:
.89e1		20 1f 8d	jsr $8d1f	                jsr xt_pad      ; ( addr )
.89e4		b5 00		lda $00,x	                lda 0,x
.89e6		85 2b		sta $2b		                sta tohold
.89e8		b5 01		lda $01,x	                lda 1,x
.89ea		85 2c		sta $2c		                sta tohold+1
.89ec		e8		inx		                inx
.89ed		e8		inx		                inx
.89ee						z_less_number_sign:
.89ee		60		rts		                rts
.89ef						xt_less_than:
.89ef		20 44 d8	jsr $d844	                jsr underflow_2
.89f2		a0 00		ldy #$00	                ldy #0          ; default false
.89f4		20 7d d7	jsr $d77d	                jsr compare_16bit
.89f7		f0 03		beq $89fc	                beq _false
.89f9		30 01		bmi $89fc	                bmi _false
.89fb		88		dey		                dey
.89fc						_false:
.89fc		98		tya		                tya
.89fd		e8		inx		                inx
.89fe		e8		inx		                inx
.89ff		95 00		sta $00,x	                sta 0,x
.8a01		95 01		sta $01,x	                sta 1,x
.8a03		60		rts		z_less_than:    rts
.8a04						xt_literal:
.8a04		20 3f d8	jsr $d83f	                jsr underflow_1
.8a07		a9 0a		lda #$0a	                lda #template_push_tos_size
.8a09		20 9f 97	jsr $979f	                jsr check_nc_limit
.8a0c		90 0c		bcc $8a1a	                bcc _inline
.8a0e		a0 8a		ldy #$8a	                ldy #>literal_runtime
.8a10		a9 4c		lda #$4c	                lda #<literal_runtime
.8a12		20 74 97	jsr $9774	                jsr cmpl_subroutine
.8a15		20 cd 83	jsr $83cd	                jsr xt_comma
.8a18		80 27		bra $8a41	                bra z_literal
.8a1a						_inline:
.8a1a		a0 94		ldy #$94	                ldy #$94        ; STY opcode
.8a1c		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a1e		d0 02		bne $8a22	                bne +
.8a20		a0 74		ldy #$74	                ldy #$74        ; STZ opcode
.8a22		5a		phy		+               phy
.8a23		b5 00		lda $00,x	                lda 0,x         ; LSB
.8a25		48		pha		                pha
.8a26		a0 02		ldy #$02	                ldy #2
.8a28		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a2a		f0 03		beq $8a2f	                beq _copy
.8a2c		a0 00		ldy #$00	                ldy #0
.8a2e		48		pha		                pha
.8a2f		b9 42 8a	lda $8a42,y	_copy:          lda template_push_tos,y
.8a32		c9 ff		cmp #$ff	                cmp #$ff        ; is it a placeholder?
.8a34		d0 01		bne $8a37	                bne +
.8a36		68		pla		                pla
.8a37		20 84 97	jsr $9784	+               jsr cmpl_a
.8a3a		c8		iny		                iny
.8a3b		c0 0a		cpy #$0a	                cpy #template_push_tos_size
.8a3d		d0 f0		bne $8a2f	                bne _copy
.8a3f		e8		inx		                inx             ; drop the literal
.8a40		e8		inx		                inx
.8a41		60		rts		z_literal:      rts
.8a42						template_push_tos:
.8a42		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8a44		a9 ff		lda #$ff	                lda #$ff
.8a46		ca		dex		                dex
.8a47		ca		dex		                dex
.8a48		95 00		sta $00,x	                sta 0,x
>8a4a		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
=10						template_push_tos_size = * - template_push_tos
.8a4c						literal_runtime:
.8a4c		ca		dex		                dex
.8a4d		ca		dex		                dex
.8a4e		68		pla		                pla             ; LSB
.8a4f		85 25		sta $25		                sta tmp1
.8a51		68		pla		                pla             ; MSB
.8a52		85 26		sta $26		                sta tmp1+1
.8a54		a0 01		ldy #$01	                ldy #1
.8a56		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8a58		95 00		sta $00,x	                sta 0,x
.8a5a		c8		iny		                iny
.8a5b		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8a5d		95 01		sta $01,x	                sta 1,x
.8a5f		98		tya		                tya
.8a60		18		clc		                clc
.8a61		65 25		adc $25		                adc tmp1
.8a63		a8		tay		                tay
.8a64		a5 26		lda $26		                lda tmp1+1
.8a66		69 00		adc #$00	                adc #0
.8a68		48		pha		                pha
.8a69		5a		phy		                phy
.8a6a		60		rts		                rts
.8a6b						xt_loop:
.8a6b		ca		dex		                dex
.8a6c		ca		dex		                dex
.8a6d		ca		dex		                dex
.8a6e		ca		dex		                dex
.8a6f		a9 e4		lda #$e4	                lda #<loop_runtime
.8a71		95 02		sta $02,x	                sta 2,x
.8a73		a9 8a		lda #$8a	                lda #>loop_runtime
.8a75		95 03		sta $03,x	                sta 3,x
.8a77		a9 11		lda #$11	                lda #loop_runtime_size
.8a79		95 00		sta $00,x	                sta 0,x
.8a7b		74 01		stz $01,x	                stz 1,x
.8a7d		80 12		bra $8a91	                bra xt_loop_common
.8a7f						xt_plus_loop:
.8a7f		ca		dex		                dex
.8a80		ca		dex		                dex
.8a81		ca		dex		                dex
.8a82		ca		dex		                dex
.8a83		a9 fd		lda #$fd	                lda #<plus_loop_runtime
.8a85		95 02		sta $02,x	                sta 2,x
.8a87		a9 8a		lda #$8a	                lda #>plus_loop_runtime
.8a89		95 03		sta $03,x	                sta 3,x
.8a8b		a9 1a		lda #$1a	                lda #plus_loop_runtime_size
.8a8d		95 00		sta $00,x	                sta 0,x
.8a8f		74 01		stz $01,x	                stz 1,x
.8a91						xt_loop_common:
.8a91		20 11 8d	jsr $8d11	                jsr xt_over
.8a94		20 3a 92	jsr $923a	                jsr xt_swap             ; xt and xt' are the same
.8a97		20 3f 97	jsr $973f	                jsr cmpl_by_limit
.8a9a		90 05		bcc $8aa1	                bcc _native
.8a9c		20 cd 83	jsr $83cd	                jsr xt_comma
.8a9f		80 03		bra $8aa4	                bra +
.8aa1						_native:
.8aa1		20 8d 97	jsr $978d	                jsr cmpl_jump_tos
.8aa4						+
.8aa4		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8aa6		f0 19		beq $8ac1	                beq _noleave
.8aa8						_next:
.8aa8		a0 01		ldy #$01	                ldy #1
.8aaa		b1 21		lda ($21),y	                lda (loopleave),y
.8aac		48		pha		                pha
.8aad		a5 01		lda $01		                lda cp+1
.8aaf		91 21		sta ($21),y	                sta (loopleave),y
.8ab1		88		dey		                dey
.8ab2		b1 21		lda ($21),y	                lda (loopleave),y
.8ab4		48		pha		                pha
.8ab5		a5 00		lda $00		                lda cp
.8ab7		91 21		sta ($21),y	                sta (loopleave),y
.8ab9		68		pla		                pla
.8aba		85 21		sta $21		                sta loopleave
.8abc		68		pla		                pla
.8abd		85 22		sta $22		                sta loopleave+1
.8abf		d0 e7		bne $8aa8	                bne _next
.8ac1						_noleave:
.8ac1		b5 00		lda $00,x	                lda 0,x
.8ac3		85 21		sta $21		                sta loopleave
.8ac5		b5 01		lda $01,x	                lda 1,x
.8ac7		85 22		sta $22		                sta loopleave+1
.8ac9		a9 dd		lda #$dd	                lda #<xt_unloop
.8acb		95 00		sta $00,x	                sta 0,x
.8acd		a9 95		lda #$95	                lda #>xt_unloop
.8acf		95 01		sta $01,x	                sta 1,x
.8ad1		20 d3 96	jsr $96d3	                jsr xt_compile_comma
.8ad4		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8ad6		f0 09		beq $8ae1	                beq +
.8ad8		20 1b 89	jsr $891b	                jsr xt_here
.8adb		20 3a 92	jsr $923a	                jsr xt_swap
.8ade		4c 24 92	jmp $9224	                jmp xt_store            ; write here as ?DO jmp target and return
.8ae1		e8		inx		+               inx                     ; drop the ignored word for DO
.8ae2		e8		inx		                inx
.8ae3						z_loop:
.8ae3		60		rts		z_plus_loop:    rts
.8ae4						loop_runtime:
.8ae4		e6 20		inc $20		                inc loopidx0            ; increment the LSB of loopindex
.8ae6		d0 0d		bne $8af5	                bne _repeat             ; avoid expensive test most of the time
.8ae8		a4 1f		ldy $1f		                ldy loopctrl
.8aea		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8aed		1a		inc a		                ina
.8aee		c9 80		cmp #$80	                cmp #$80
.8af0		f0 06		beq $8af8	                beq _done
.8af2		99 01 01	sta $0101,y	                sta loopindex+1,y
=17						loop_runtime_size = * - loop_runtime
.8af5						_repeat:
.8af5		a9 00		lda #$00	                lda #0
>8af7		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8af8		a9 01		lda #$01	_done:          lda #1
.8afa		4c 2e 98	jmp $982e	                jmp zbranch_runtime
.8afd						plus_loop_runtime:
.8afd		18		clc		                clc
.8afe		b5 00		lda $00,x	                lda 0,x                 ; LSB of step
.8b00		65 20		adc $20		                adc loopidx0
.8b02		85 20		sta $20		                sta loopidx0
.8b04		e8		inx		                inx                     ; dump step from TOS before MSB test
.8b05		e8		inx		                inx                     ; since we might skip it
.8b06		b5 ff		lda $ff,x	                lda $FF,x               ; MSB of step since 1,x == -1,x+2
.8b08		d0 02		bne $8b0c	                bne _chkv               ; if it's non-zero we have to check
.8b0a		90 0b		bcc $8b17	                bcc _repeat             ; but if 0 and no carry, we're good
.8b0c		b8		clv		_chkv:          clv
.8b0d		a4 1f		ldy $1f		                ldy loopctrl            ; get LCB offset
.8b0f		79 01 01	adc $0101,y	                adc loopindex+1,y       ; MSB of index
.8b12		99 01 01	sta $0101,y	                sta loopindex+1,y       ; put MSB of index back on stack
.8b15		70 03		bvs $8b1a	                bvs _done               ; skip over JMP instruction
=26						plus_loop_runtime_size = * - plus_loop_runtime
.8b17						_repeat:
.8b17		a9 00		lda #$00	                lda #0
>8b19		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8b1a		a9 01		lda #$01	_done:          lda #1
.8b1c		4c 2e 98	jmp $982e	                jmp zbranch_runtime
.8b1f						xt_lshift:
.8b1f		20 44 d8	jsr $d844	                jsr underflow_2
.8b22		b5 00		lda $00,x	                lda 0,x
.8b24		29 0f		and #$0f	                and #%00001111
.8b26		f0 08		beq $8b30	                beq _done
.8b28		a8		tay		                tay
.8b29						_loop:
.8b29		16 02		asl $02,x	                asl 2,x
.8b2b		36 03		rol $03,x	                rol 3,x
.8b2d		88		dey		                dey
.8b2e		d0 f9		bne $8b29	                bne _loop
.8b30						_done:
.8b30		e8		inx		                inx
.8b31		e8		inx		                inx
.8b32		60		rts		z_lshift:       rts
.8b33						xt_m_star:
.8b33		20 44 d8	jsr $d844	                jsr underflow_2
.8b36		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8b38		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8b3a		48		pha		                pha
.8b3b		20 cf 80	jsr $80cf	                jsr xt_abs
.8b3e		20 3a 92	jsr $923a	                jsr xt_swap
.8b41		20 cf 80	jsr $80cf	                jsr xt_abs
.8b44		20 97 95	jsr $9597	                jsr xt_um_star          ; ( d )
.8b47		68		pla		                pla
.8b48		10 03		bpl $8b4d	                bpl _done
.8b4a		20 64 9e	jsr $9e64	                jsr xt_dnegate
.8b4d						_done:
.8b4d		60		rts		z_m_star:       rts
.8b4e						xt_marker:
.8b4e		20 96 d7	jsr $d796	                jsr current_to_dp
.8b51		a5 02		lda $02		                lda dp
.8b53		48		pha		                pha
.8b54		a5 03		lda $03		                lda dp+1
.8b56		48		pha		                pha
.8b57		a5 00		lda $00		                lda cp
.8b59		48		pha		                pha
.8b5a		a5 01		lda $01		                lda cp+1
.8b5c		48		pha		                pha
.8b5d		20 40 84	jsr $8440	                jsr xt_create
.8b60		a5 00		lda $00		                lda cp          ; LSB
.8b62		38		sec		                sec
.8b63		e9 02		sbc #$02	                sbc #2
.8b65		85 00		sta $00		                sta cp
.8b67		b0 02		bcs $8b6b	                bcs +
.8b69		c6 01		dec $01		                dec cp+1        ; we only care about the borrow
.8b6b						+
.8b6b		a0 8b		ldy #$8b	                ldy #>marker_runtime
.8b6d		a9 89		lda #$89	                lda #<marker_runtime
.8b6f		20 80 97	jsr $9780	                jsr cmpl_word
.8b72		7a		ply		                ply                     ; MSB
.8b73		68		pla		                pla                     ; LSB
.8b74		20 80 97	jsr $9780	                jsr cmpl_word
.8b77		7a		ply		                ply                     ; MSB
.8b78		68		pla		                pla                     ; LSB
.8b79		20 80 97	jsr $9780	                jsr cmpl_word
.8b7c		a0 08		ldy #$08	                ldy #marker_start_offset
.8b7e						-
.8b7e		b1 08		lda ($08),y	                lda (up),y
.8b80		20 84 97	jsr $9784	                jsr cmpl_a
.8b83		c8		iny		                iny
.8b84		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b86		d0 f6		bne $8b7e	                bne -
.8b88		60		rts		z_marker:       rts
.8b89						marker_runtime:
.8b89		68		pla		                pla
.8b8a		85 25		sta $25		                sta tmp1        ; LSB of address
.8b8c		68		pla		                pla
.8b8d		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8b8f		a0 01		ldy #$01	                ldy #1          ; start at 1 due to RTS mechanics
.8b91		b1 25		lda ($25),y	                lda (tmp1),y
.8b93		85 00		sta $00		                sta cp
.8b95		c8		iny		                iny
.8b96		b1 25		lda ($25),y	                lda (tmp1),y
.8b98		85 01		sta $01		                sta cp+1
.8b9a		c8		iny		                iny
.8b9b		b1 25		lda ($25),y	                lda (tmp1),y
.8b9d		85 02		sta $02		                sta dp
.8b9f		c8		iny		                iny
.8ba0		b1 25		lda ($25),y	                lda (tmp1),y
.8ba2		85 03		sta $03		                sta dp+1
.8ba4		38		sec		                sec
.8ba5		a5 25		lda $25		                lda tmp1
.8ba7		e9 03		sbc #$03	                sbc #marker_start_offset - 5
.8ba9		85 25		sta $25		                sta tmp1
.8bab		b0 02		bcs $8baf	                bcs +
.8bad		c6 26		dec $26		                dec tmp1+1
.8baf						+
.8baf		a0 08		ldy #$08	                ldy #marker_start_offset
.8bb1						-
.8bb1		b1 25		lda ($25),y	                lda (tmp1),y
.8bb3		91 08		sta ($08),y	                sta (up),y
.8bb5		c8		iny		                iny
.8bb6		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8bb8		d0 f7		bne $8bb1	                bne -
.8bba		20 a9 d7	jsr $d7a9	                jsr dp_to_current       ; Move the CURRENT DP back.
.8bbd		60		rts		                rts
.8bbe						xt_max:
.8bbe		20 44 d8	jsr $d844	                jsr underflow_2
.8bc1		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bc3		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8bc5		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bc7		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bc9		50 02		bvc $8bcd	                bvc _no_overflow
.8bcb		49 80		eor #$80	                eor #$80        ; complement negative flag
.8bcd						_no_overflow:
.8bcd		30 08		bmi $8bd7	                bmi _keep_nos
.8bcf		b5 00		lda $00,x	                lda 0,x
.8bd1		95 02		sta $02,x	                sta 2,x
.8bd3		b5 01		lda $01,x	                lda 1,x
.8bd5		95 03		sta $03,x	                sta 3,x
.8bd7						_keep_nos:
.8bd7		e8		inx		                inx
.8bd8		e8		inx		                inx
.8bd9		60		rts		z_max:          rts
.8bda						xt_min:
.8bda		20 44 d8	jsr $d844	                jsr underflow_2
.8bdd		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bdf		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8be1		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8be3		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8be5		50 02		bvc $8be9	                bvc _no_overflow
.8be7		49 80		eor #$80	                eor #$80
.8be9						_no_overflow:
.8be9		10 08		bpl $8bf3	                bpl _keep_nos
.8beb		b5 00		lda $00,x	                lda 0,x
.8bed		95 02		sta $02,x	                sta 2,x
.8bef		b5 01		lda $01,x	                lda 1,x
.8bf1		95 03		sta $03,x	                sta 3,x
.8bf3						_keep_nos:
.8bf3		e8		inx		                inx
.8bf4		e8		inx		                inx
.8bf5		60		rts		z_min:          rts
.8bf6						xt_minus:
.8bf6		20 44 d8	jsr $d844	                jsr underflow_2
.8bf9		38		sec		                sec
.8bfa		b5 02		lda $02,x	                lda 2,x         ; LSB
.8bfc		f5 00		sbc $00,x	                sbc 0,x
.8bfe		95 02		sta $02,x	                sta 2,x
.8c00		b5 03		lda $03,x	                lda 3,x         ; MSB
.8c02		f5 01		sbc $01,x	                sbc 1,x
.8c04		95 03		sta $03,x	                sta 3,x
.8c06		e8		inx		                inx
.8c07		e8		inx		                inx
.8c08		60		rts		z_minus:        rts
.8c09						xt_mod:
.8c09		20 44 d8	jsr $d844	                jsr underflow_2
.8c0c		20 76 91	jsr $9176	                jsr xt_slash_mod
.8c0f		e8		inx		                inx             ; DROP
.8c10		e8		inx		                inx
.8c11						z_mod:
.8c11		60		rts		                rts
.8c12						xt_move:
.8c12		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8c14		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8c16		f0 05		beq $8c1d	                beq _lsb                ; wasn't helpful, move to LSB
.8c18		b0 0e		bcs $8c28	                bcs _to_move_up         ; we want CMOVE>
.8c1a		4c ae 9f	jmp $9fae	                jmp xt_cmove            ; JSR/RTS
.8c1d						_lsb:
.8c1d		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8c1f		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8c21		f0 08		beq $8c2b	                beq _equal              ; LSB is equal as well
.8c23		b0 03		bcs $8c28	                bcs _to_move_up         ; we want CMOVE>
.8c25		4c ae 9f	jmp $9fae	                jmp xt_cmove            ; JSR/RTS
.8c28						_to_move_up:
.8c28		4c e9 9f	jmp $9fe9	                jmp xt_cmove_up         ; JSR/RTS
.8c2b						_equal:
.8c2b		8a		txa		                txa
.8c2c		18		clc		                clc
.8c2d		69 06		adc #$06	                adc #6
.8c2f		aa		tax		                tax
.8c30		60		rts		z_move:         rts
.8c31						xt_negate:
.8c31		20 3f d8	jsr $d83f	                jsr underflow_1
.8c34		a9 00		lda #$00	        	lda #0
.8c36		38		sec		                sec
.8c37		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8c39		95 00		sta $00,x	                sta 0,x
.8c3b		a9 00		lda #$00	                lda #0
.8c3d		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8c3f		95 01		sta $01,x	                sta 1,x
.8c41		60		rts		z_negate:       rts
.8c42						xt_nip:
.8c42		20 44 d8	jsr $d844	                jsr underflow_2
.8c45		b5 00		lda $00,x	                lda 0,x         ; LSB
.8c47		95 02		sta $02,x	                sta 2,x
.8c49		b5 01		lda $01,x	                lda 1,x         ; MSB
.8c4b		95 03		sta $03,x	                sta 3,x
.8c4d		e8		inx		                inx
.8c4e		e8		inx		                inx
.8c4f		60		rts		z_nip:          rts
.8c50						xt_not_equals:
.8c50		20 44 d8	jsr $d844	                jsr underflow_2
.8c53		a0 00		ldy #$00	                ldy #0                  ; default is true
.8c55		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8c57		d5 02		cmp $02,x	                cmp 2,x
.8c59		d0 0a		bne $8c65	                bne _not_equal
.8c5b		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8c5d		d5 03		cmp $03,x	                cmp 3,x
.8c5f		d0 04		bne $8c65	                bne _not_equal
.8c61		a9 ff		lda #$ff	                lda #$FF
.8c63		80 01		bra $8c66	                bra _done
.8c65						_not_equal:
.8c65		88		dey		                dey                     ; drop thru to done
.8c66						_done:
.8c66		98		tya		                tya
.8c67		e8		inx		                inx
.8c68		e8		inx		                inx
.8c69		95 00		sta $00,x	                sta 0,x
.8c6b		95 01		sta $01,x	                sta 1,x
.8c6d		60		rts		z_not_equals:   rts
.8c6e						xt_number_sign:
.8c6e		20 44 d8	jsr $d844	                jsr underflow_2         ; double number
.8c71		20 fb 82	jsr $82fb	                jsr xt_base
.8c74		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( ud1 base )
.8c77		20 78 93	jsr $9378	                jsr xt_to_r             ; >r
.8c7a		20 f6 9d	jsr $9df6	                jsr xt_zero             ; 0
.8c7d		20 e5 8e	jsr $8ee5	                jsr xt_r_fetch          ; r@
.8c80		20 55 95	jsr $9555	                jsr xt_um_slash_mod     ; um/mod
.8c83		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; rot rot
.8c86		20 fc 8e	jsr $8efc	                jsr xt_r_from           ; r>
.8c89		20 55 95	jsr $9555	                jsr xt_um_slash_mod     ; um/mod
.8c8c		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; rot ( rem ud ) rot ( ud rem )
.8c8f		b5 00		lda $00,x	                lda 0,x
.8c91		a8		tay		                tay
.8c92		b9 c5 d3	lda $d3c5,y	                lda s_abc_upper,y
.8c95		95 00		sta $00,x	                sta 0,x
.8c97		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8c99		20 2d 89	jsr $892d	                jsr xt_hold
.8c9c						z_number_sign:
.8c9c		60		rts		                rts
.8c9d						xt_number_sign_greater:
.8c9d		20 44 d8	jsr $d844	                jsr underflow_2         ; double number
.8ca0		a5 2b		lda $2b		                lda tohold
.8ca2		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8ca4		95 02		sta $02,x	                sta 2,x
.8ca6		a5 2c		lda $2c		                lda tohold+1
.8ca8		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8caa		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8cac		20 1f 8d	jsr $8d1f	                jsr xt_pad      ; ( addr addr pad )
.8caf		38		sec		                sec
.8cb0		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8cb2		f5 02		sbc $02,x	                sbc 2,x
.8cb4		95 02		sta $02,x	                sta 2,x
.8cb6		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8cb8		f5 03		sbc $03,x	                sbc 3,x
.8cba		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8cbc		e8		inx		                inx
.8cbd		e8		inx		                inx
.8cbe						z_number_sign_greater:
.8cbe		60		rts		                rts
.8cbf						xt_number_sign_s:
.8cbf		20 44 d8	jsr $d844	                jsr underflow_2
.8cc2						_loop:
.8cc2		20 6e 8c	jsr $8c6e	                jsr xt_number_sign
.8cc5		b5 00		lda $00,x	                lda 0,x
.8cc7		15 01		ora $01,x	                ora 1,x
.8cc9		15 02		ora $02,x	                ora 2,x
.8ccb		15 03		ora $03,x	                ora 3,x
.8ccd		d0 f3		bne $8cc2	                bne _loop
.8ccf						z_number_sign_s:
.8ccf		60		rts		                rts
.8cd0						xt_of:
.8cd0		a0 8d		ldy #$8d	                ldy #>xt_over
.8cd2		a9 11		lda #$11	                lda #<xt_over
.8cd4		20 74 97	jsr $9774	                jsr cmpl_subroutine
.8cd7		a0 87		ldy #$87	                ldy #>xt_equal
.8cd9		a9 96		lda #$96	                lda #<xt_equal
.8cdb		20 74 97	jsr $9774	                jsr cmpl_subroutine
.8cde		20 54 89	jsr $8954	                jsr xt_if
.8ce1		a0 86		ldy #$86	                ldy #>xt_drop
.8ce3		a9 9a		lda #$9a	                lda #<xt_drop
.8ce5		20 74 97	jsr $9774	                jsr cmpl_subroutine
.8ce8		60		rts		z_of:           rts
.8ce9						xt_one_minus:
.8ce9		20 3f d8	jsr $d83f	                jsr underflow_1
.8cec		b5 00		lda $00,x	                lda 0,x
.8cee		d0 02		bne $8cf2	                bne +
.8cf0		d6 01		dec $01,x	                dec 1,x
.8cf2						+
.8cf2		d6 00		dec $00,x	                dec 0,x
.8cf4		60		rts		z_one_minus:    rts
.8cf5						xt_char_plus:
.8cf5						xt_one_plus:
.8cf5		20 3f d8	jsr $d83f	                jsr underflow_1
.8cf8		f6 00		inc $00,x	                inc 0,x
.8cfa		d0 02		bne $8cfe	                bne _done
.8cfc		f6 01		inc $01,x	                inc 1,x
.8cfe						_done:
.8cfe						z_char_plus:
.8cfe		60		rts		z_one_plus:     rts
.8cff						xt_or:
.8cff		20 44 d8	jsr $d844	                jsr underflow_2
.8d02		b5 00		lda $00,x	                lda 0,x
.8d04		15 02		ora $02,x	                ora 2,x
.8d06		95 02		sta $02,x	                sta 2,x
.8d08		b5 01		lda $01,x	                lda 1,x
.8d0a		15 03		ora $03,x	                ora 3,x
.8d0c		95 03		sta $03,x	                sta 3,x
.8d0e		e8		inx		                inx
.8d0f		e8		inx		                inx
.8d10		60		rts		z_or:           rts
.8d11						xt_over:
.8d11		20 44 d8	jsr $d844	                jsr underflow_2
.8d14		ca		dex		                dex
.8d15		ca		dex		                dex
.8d16		b5 04		lda $04,x	                lda 4,x         ; LSB
.8d18		95 00		sta $00,x	                sta 0,x
.8d1a		b5 05		lda $05,x	                lda 5,x         ; MSB
.8d1c		95 01		sta $01,x	                sta 1,x
.8d1e		60		rts		z_over:         rts
.8d1f						xt_pad:
.8d1f		ca		dex		                dex
.8d20		ca		dex		                dex
.8d21		a5 00		lda $00		                lda cp
.8d23		18		clc		                clc
.8d24		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8d26		95 00		sta $00,x	                sta 0,x
.8d28		a5 01		lda $01		                lda cp+1
.8d2a		69 00		adc #$00	                adc #0          ; only need carry
.8d2c		95 01		sta $01,x	                sta 1,x
.8d2e		60		rts		z_pad:          rts
.8d2f						xt_page:
.8d2f		a9 1b		lda #$1b	                lda #AscESC
.8d31		20 c5 86	jsr $86c5	                jsr emit_a
.8d34		a9 5b		lda #$5b	                lda #'['
.8d36		20 c5 86	jsr $86c5	                jsr emit_a
.8d39		a9 32		lda #$32	                lda #'2'
.8d3b		20 c5 86	jsr $86c5	                jsr emit_a
.8d3e		a9 4a		lda #$4a	                lda #'J'
.8d40		20 c5 86	jsr $86c5	                jsr emit_a
.8d43		20 f6 9d	jsr $9df6	                jsr xt_zero
.8d46		20 f6 9d	jsr $9df6	                jsr xt_zero
.8d49		20 a2 82	jsr $82a2	                jsr xt_at_xy
.8d4c		60		rts		z_page:         rts
.8d4d						xt_paren:
.8d4d		ca		dex		                dex
.8d4e		ca		dex		                dex
.8d4f		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8d51		95 00		sta $00,x	                sta 0,x
.8d53		74 01		stz $01,x	                stz 1,x
.8d55		20 b8 8d	jsr $8db8	                jsr xt_parse
.8d58		e8		inx		                inx
.8d59		e8		inx		                inx
.8d5a		e8		inx		                inx
.8d5b		e8		inx		                inx
.8d5c		60		rts		z_paren:        rts
.8d5d						xt_parse_name:
.8d5d		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8d5f		38		sec		                sec
.8d60		e5 10		sbc $10		                sbc toin
.8d62		85 25		sta $25		                sta tmp1
.8d64		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8d66		e5 11		sbc $11		                sbc toin+1
.8d68		85 26		sta $26		                sta tmp1+1
.8d6a		a5 25		lda $25		                lda tmp1
.8d6c		05 26		ora $26		                ora tmp1+1
.8d6e		f0 28		beq $8d98	                beq _empty_line
.8d70		a5 0c		lda $0c		                lda cib
.8d72		18		clc		                clc
.8d73		65 10		adc $10		                adc toin
.8d75		85 27		sta $27		                sta tmp2                ; LSB of first character
.8d77		a5 0d		lda $0d		                lda cib+1
.8d79		65 11		adc $11		                adc toin+1
.8d7b		85 28		sta $28		                sta tmp2+1              ; MSB
.8d7d						_skip_loop:
.8d7d		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8d7f		20 32 d8	jsr $d832	                jsr is_whitespace
.8d82		90 1f		bcc $8da3	                bcc _char_found
.8d84		e6 27		inc $27		                inc tmp2
.8d86		d0 02		bne $8d8a	                bne +
.8d88		e6 28		inc $28		                inc tmp2+1
.8d8a						+
.8d8a		a5 25		lda $25		                lda tmp1
.8d8c		d0 02		bne $8d90	                bne +
.8d8e		c6 26		dec $26		                dec tmp1+1
.8d90		c6 25		dec $25		+               dec tmp1
.8d92		a5 25		lda $25		                lda tmp1
.8d94		05 26		ora $26		                ora tmp1+1
.8d96		d0 e5		bne $8d7d	                bne _skip_loop          ; fall through if empty line
.8d98						_empty_line:
.8d98		ca		dex		                dex
.8d99		ca		dex		                dex
.8d9a		ca		dex		                dex
.8d9b		ca		dex		                dex
.8d9c		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8d9e		74 01		stz $01,x	                stz 1,x
.8da0		4c 4d 8e	jmp $8e4d	                jmp z_parse_name        ; skip over PARSE
.8da3						_char_found:
.8da3		a5 27		lda $27		                lda tmp2
.8da5		38		sec		                sec
.8da6		e5 0c		sbc $0c		                sbc cib
.8da8		85 10		sta $10		                sta toin
.8daa		a5 28		lda $28		                lda tmp2+1
.8dac		e5 0d		sbc $0d		                sbc cib+1
.8dae		85 11		sta $11		                sta toin+1
.8db0		ca		dex		                dex
.8db1		ca		dex		                dex
.8db2		a9 20		lda #$20	                lda #AscSP
.8db4		95 00		sta $00,x	                sta 0,x
.8db6		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8db8						xt_parse:
.8db8		20 3f d8	jsr $d83f	                jsr underflow_1
.8dbb		a5 0e		lda $0e		                lda ciblen
.8dbd		05 0f		ora $0f		                ora ciblen+1
.8dbf		f0 0c		beq $8dcd	                beq _abort_parse
.8dc1		a5 11		lda $11		                lda toin+1              ; MSB
.8dc3		c5 0f		cmp $0f		                cmp ciblen+1
.8dc5		90 0e		bcc $8dd5	                bcc _go_parse           ; unsigned comparison
.8dc7		a5 10		lda $10		                lda toin                ; LSB
.8dc9		c5 0e		cmp $0e		                cmp ciblen
.8dcb		90 08		bcc $8dd5	                bcc _go_parse
.8dcd						_abort_parse:
.8dcd		ca		dex		                dex
.8dce		ca		dex		                dex
.8dcf		74 00		stz $00,x	                stz 0,x
.8dd1		74 01		stz $01,x	                stz 1,x
.8dd3		80 78		bra $8e4d	                bra _done
.8dd5						_go_parse:
.8dd5		b5 00		lda $00,x	                lda 0,x
.8dd7		85 23		sta $23		                sta tmptos
.8dd9		ca		dex		                dex
.8dda		ca		dex		                dex
.8ddb		a5 0c		lda $0c		                lda cib
.8ddd		18		clc		                clc
.8dde		65 10		adc $10		                adc toin        ; LSB
.8de0		85 25		sta $25		                sta tmp1
.8de2		85 27		sta $27		                sta tmp2
.8de4		95 02		sta $02,x	                sta 2,x
.8de6		a5 0d		lda $0d		                lda cib+1
.8de8		65 11		adc $11		                adc toin+1      ; MSB
.8dea		85 26		sta $26		                sta tmp1+1
.8dec		85 28		sta $28		                sta tmp2+1
.8dee		95 03		sta $03,x	                sta 3,x
.8df0		a5 0c		lda $0c		                lda cib
.8df2		18		clc		                clc
.8df3		65 0e		adc $0e		                adc ciblen
.8df5		85 29		sta $29		                sta tmp3
.8df7		a5 0d		lda $0d		                lda cib+1
.8df9		65 0f		adc $0f		                adc ciblen+1
.8dfb		85 2a		sta $2a		                sta tmp3+1
.8dfd		64 24		stz $24		                stz tmptos+1
.8dff						_loop:
.8dff		a5 27		lda $27		                lda tmp2
.8e01		c5 29		cmp $29		                cmp tmp3
.8e03		d0 06		bne $8e0b	                bne _not_empty
.8e05		a5 28		lda $28		                lda tmp2+1
.8e07		c5 2a		cmp $2a		                cmp tmp3+1
.8e09		f0 1d		beq $8e28	                beq _eol
.8e0b						_not_empty:
.8e0b		b2 27		lda ($27)	                lda (tmp2)
.8e0d		a4 23		ldy $23		                ldy tmptos
.8e0f		c0 20		cpy #$20	                cpy #AscSP
.8e11		d0 07		bne $8e1a	                bne _not_whitespace
.8e13		20 32 d8	jsr $d832	                jsr is_whitespace
.8e16		90 02		bcc $8e1a	                bcc _not_whitespace
.8e18		80 0c		bra $8e26	                bra _found_delimiter
.8e1a						_not_whitespace:
.8e1a		c5 23		cmp $23		                cmp tmptos
.8e1c		f0 08		beq $8e26	                beq _found_delimiter
.8e1e		e6 27		inc $27		                inc tmp2
.8e20		d0 dd		bne $8dff	                bne _loop
.8e22		e6 28		inc $28		                inc tmp2+1
.8e24		80 d9		bra $8dff	                bra _loop
.8e26						_found_delimiter:
.8e26		e6 24		inc $24		                inc tmptos+1
.8e28						_eol:
.8e28		a5 27		lda $27		                lda tmp2
.8e2a		38		sec		                sec
.8e2b		e5 25		sbc $25		                sbc tmp1
.8e2d		95 00		sta $00,x	                sta 0,x
.8e2f		a5 28		lda $28		                lda tmp2+1
.8e31		e5 26		sbc $26		                sbc tmp1+1
.8e33		95 01		sta $01,x	                sta 1,x
.8e35		a5 27		lda $27		                lda tmp2
.8e37		38		sec		                sec
.8e38		e5 0c		sbc $0c		                sbc cib
.8e3a		85 10		sta $10		                sta toin
.8e3c		a5 28		lda $28		                lda tmp2+1
.8e3e		e5 0d		sbc $0d		                sbc cib+1
.8e40		85 11		sta $11		                sta toin+1
.8e42		a5 10		lda $10		                lda toin
.8e44		18		clc		                clc
.8e45		65 24		adc $24		                adc tmptos+1
.8e47		85 10		sta $10		                sta toin
.8e49		90 02		bcc $8e4d	                bcc +
.8e4b		e6 11		inc $11		                inc toin+1
.8e4d						+
.8e4d						_done:
.8e4d						z_parse_name:
.8e4d		60		rts		z_parse:        rts
.8e4e						xt_pick:
.8e4e		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8e50		8a		txa		                txa
.8e51		75 00		adc $00,x	                adc 0,x
.8e53		a8		tay		                tay
.8e54		b9 02 00	lda $0002,y	                lda 0002,y
.8e57		95 00		sta $00,x	                sta 0,x
.8e59		b9 03 00	lda $0003,y	                lda 0003,y
.8e5c		95 01		sta $01,x	                sta 1,x
.8e5e		60		rts		z_pick:         rts
.8e5f						xt_plus:
.8e5f		20 44 d8	jsr $d844	                jsr underflow_2
.8e62		18		clc		                clc
.8e63		b5 00		lda $00,x	                lda 0,x         ; LSB
.8e65		75 02		adc $02,x	                adc 2,x
.8e67		95 02		sta $02,x	                sta 2,x
.8e69		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8e6b		75 03		adc $03,x	                adc 3,x
.8e6d		95 03		sta $03,x	                sta 3,x
.8e6f		e8		inx		                inx
.8e70		e8		inx		                inx
.8e71		60		rts		z_plus:         rts
.8e72						xt_plus_store:
.8e72		20 44 d8	jsr $d844	                jsr underflow_2
.8e75		b5 00		lda $00,x	                lda 0,x
.8e77		85 25		sta $25		                sta tmp1
.8e79		b5 01		lda $01,x	                lda 1,x
.8e7b		85 26		sta $26		                sta tmp1+1
.8e7d		a0 00		ldy #$00	                ldy #0          ; LSB
.8e7f		b1 25		lda ($25),y	                lda (tmp1),y
.8e81		18		clc		                clc
.8e82		75 02		adc $02,x	                adc 2,x
.8e84		91 25		sta ($25),y	                sta (tmp1),y
.8e86		c8		iny		                iny             ; MSB
.8e87		b1 25		lda ($25),y	                lda (tmp1),y
.8e89		75 03		adc $03,x	                adc 3,x
.8e8b		91 25		sta ($25),y	                sta (tmp1),y
.8e8d		e8		inx		                inx
.8e8e		e8		inx		                inx
.8e8f		e8		inx		                inx
.8e90		e8		inx		                inx
.8e91		60		rts		z_plus_store:   rts
.8e92						xt_postpone:
.8e92		20 5d 8d	jsr $8d5d	                jsr xt_parse_name               ; ( -- addr n )
.8e95		b5 00		lda $00,x	                lda 0,x
.8e97		15 01		ora $01,x	                ora 1,x
.8e99		d0 05		bne $8ea0	                bne +
.8e9b		a9 05		lda #$05	                lda #err_noname
.8e9d		4c 55 d8	jmp $d855	                jmp error
.8ea0						+
.8ea0		20 ea 9a	jsr $9aea	                jsr xt_find_name                ; ( -- nt | 0 )
.8ea3		d0 05		bne $8eaa	                bne +
.8ea5		a9 05		lda #$05	                lda #err_noname
.8ea7		4c 55 d8	jmp $d855	                jmp error
.8eaa						+
.8eaa		b5 00		lda $00,x	                lda 0,x
.8eac		85 25		sta $25		                sta tmp1
.8eae		b5 01		lda $01,x	                lda 1,x
.8eb0		85 26		sta $26		                sta tmp1+1
.8eb2		20 33 9c	jsr $9c33	                jsr xt_name_to_int              ; ( nt -- xt )
.8eb5		e6 25		inc $25		                inc tmp1
.8eb7		d0 02		bne $8ebb	                bne +
.8eb9		e6 26		inc $26		                inc tmp1+1
.8ebb						+
.8ebb		b2 25		lda ($25)	                lda (tmp1)
.8ebd		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.8ebf		f0 05		beq $8ec6	                beq _not_immediate
.8ec1		20 d3 96	jsr $96d3	                jsr xt_compile_comma
.8ec4		80 0a		bra $8ed0	                bra _done
.8ec6						_not_immediate:
.8ec6		20 04 8a	jsr $8a04	                jsr xt_literal
.8ec9		a0 96		ldy #$96	                ldy #>xt_compile_comma
.8ecb		a9 d3		lda #$d3	                lda #<xt_compile_comma
.8ecd		20 74 97	jsr $9774	                jsr cmpl_subroutine
.8ed0						_done:
.8ed0		60		rts		z_postpone:     rts
.8ed1						xt_question_dup:
.8ed1		20 3f d8	jsr $d83f	                jsr underflow_1
.8ed4		b5 00		lda $00,x	                lda 0,x
.8ed6		15 01		ora $01,x	                ora 1,x
.8ed8		f0 0a		beq $8ee4	                beq _done
.8eda		ca		dex		                dex
.8edb		ca		dex		                dex
.8edc		b5 02		lda $02,x	                lda 2,x
.8ede		95 00		sta $00,x	                sta 0,x
.8ee0		b5 03		lda $03,x	                lda 3,x
.8ee2		95 01		sta $01,x	                sta 1,x
.8ee4						_done:
.8ee4		60		rts		z_question_dup: rts
.8ee5						xt_r_fetch:
.8ee5		68		pla		                pla                     ; LSB
.8ee6		7a		ply		                ply                     ; MSB
.8ee7		1a		inc a		                inc a
.8ee8		85 25		sta $25		                sta tmp1                ; LSB
.8eea		d0 01		bne $8eed	                bne +
.8eec		c8		iny		                iny
.8eed						+
.8eed		84 26		sty $26		                sty tmp1+1              ; MSB
.8eef		ca		dex		                dex
.8ef0		ca		dex		                dex
.8ef1		7a		ply		                ply             ; LSB
.8ef2		94 00		sty $00,x	                sty 0,x
.8ef4		68		pla		                pla             ; MSB
.8ef5		95 01		sta $01,x	                sta 1,x
.8ef7		48		pha		                pha
.8ef8		5a		phy		                phy
.8ef9		6c 25 00	jmp ($0025)	z_r_fetch:      jmp (tmp1)
.8efc						xt_r_from:
.8efc		68		pla		                pla                     ; LSB
.8efd		7a		ply		                ply                     ; MSB
.8efe		1a		inc a		                inc a
.8eff		85 25		sta $25		                sta tmp1                ; LSB
.8f01		d0 01		bne $8f04	                bne +
.8f03		c8		iny		                iny
.8f04						+
.8f04		84 26		sty $26		                sty tmp1+1              ; MSB
.8f06		ca		dex		                dex
.8f07		ca		dex		                dex
.8f08		68		pla		                pla             ; LSB
.8f09		95 00		sta $00,x	                sta 0,x
.8f0b		68		pla		                pla             ; MSB
.8f0c		95 01		sta $01,x	                sta 1,x
.8f0e		6c 25 00	jmp ($0025)	z_r_from:       jmp (tmp1)
.8f11						xt_recurse:
.8f11		a0 00		ldy #$00	                ldy #0
.8f13		a9 20		lda #$20	                lda #OpJSR
.8f15		91 00		sta ($00),y	                sta (cp),y
.8f17		c8		iny		                iny
.8f18		24 1c		bit $1c		                bit status
.8f1a		70 0c		bvs $8f28	                bvs _nt_in_workword
.8f1c		a5 06		lda $06		                lda workword
.8f1e		91 00		sta ($00),y	                sta (cp),y
.8f20		c8		iny		                iny
.8f21		a5 07		lda $07		                lda workword+1
.8f23		91 00		sta ($00),y	                sta (cp),y
.8f25		c8		iny		                iny
.8f26		80 1b		bra $8f43	                bra _update_cp
.8f28						_nt_in_workword:
.8f28		a5 06		lda $06		                lda workword            ; LSB
.8f2a		18		clc		                clc
.8f2b		69 04		adc #$04	                adc #4
.8f2d		85 25		sta $25		                sta tmp1
.8f2f		a5 07		lda $07		                lda workword+1          ; MSB
.8f31		69 00		adc #$00	                adc #0
.8f33		85 26		sta $26		                sta tmp1+1
.8f35		b2 25		lda ($25)	                lda (tmp1)
.8f37		91 00		sta ($00),y	                sta (cp),y
.8f39		5a		phy		                phy
.8f3a		a0 01		ldy #$01	                ldy #1
.8f3c		b1 25		lda ($25),y	                lda (tmp1),y
.8f3e		7a		ply		                ply
.8f3f		c8		iny		                iny
.8f40		91 00		sta ($00),y	                sta (cp),y
.8f42		c8		iny		                iny
.8f43						_update_cp:
.8f43		98		tya		                tya
.8f44		18		clc		                clc
.8f45		65 00		adc $00		                adc cp
.8f47		85 00		sta $00		                sta cp
.8f49		90 02		bcc $8f4d	                bcc _done
.8f4b		e6 01		inc $01		                inc cp+1
.8f4d						_done:
.8f4d		60		rts		z_recurse:      rts
.8f4e						xt_refill:
.8f4e		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.8f50		d0 2d		bne $8f7f	                bne _src_not_kbd
.8f52		ca		dex		                dex
.8f53		ca		dex		                dex
.8f54		ca		dex		                dex
.8f55		ca		dex		                dex
.8f56		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.8f58		95 02		sta $02,x	                sta 2,x
.8f5a		a5 0d		lda $0d		                lda cib+1
.8f5c		95 03		sta $03,x	                sta 3,x
.8f5e		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.8f60		64 0f		stz $0f		                stz ciblen+1
.8f62		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.8f64		95 00		sta $00,x	                sta 0,x
.8f66		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.8f68		20 e4 80	jsr $80e4	                jsr xt_accept           ; ( addr n1 -- n2)
.8f6b		b5 00		lda $00,x	                lda 0,x
.8f6d		85 0e		sta $0e		                sta ciblen
.8f6f		b5 01		lda $01,x	                lda 1,x
.8f71		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.8f73		64 10		stz $10		                stz toin
.8f75		64 11		stz $11		                stz toin+1
.8f77		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.8f79		95 00		sta $00,x	                sta 0,x
.8f7b		95 01		sta $01,x	                sta 1,x
.8f7d		80 10		bra $8f8f	                bra _done
.8f7f						_src_not_kbd:
.8f7f		1a		inc a		                ina
.8f80		d0 08		bne $8f8a	                bne _src_not_string
.8f82		ca		dex		                dex
.8f83		ca		dex		                dex
.8f84		74 00		stz $00,x	                stz 0,x
.8f86		74 01		stz $01,x	                stz 1,x
.8f88		80 05		bra $8f8f	                bra z_refill
.8f8a						_src_not_string:
.8f8a		a9 01		lda #$01	                lda #err_badsource
.8f8c		4c 55 d8	jmp $d855	                jmp error
.8f8f						_done:
.8f8f		60		rts		z_refill:       rts
.8f90						xt_repeat:
.8f90		20 1f 82	jsr $821f	                jsr xt_again
.8f93		4c b4 86	jmp $86b4	                jmp xt_then
.8f96						z_repeat:
.8f96						xt_right_bracket:
.8f96		a9 ff		lda #$ff	                lda #$FF
.8f98		85 1a		sta $1a		                sta state
.8f9a		85 1b		sta $1b		                sta state+1
.8f9c						z_right_bracket:
.8f9c		60		rts		                rts
.8f9d						xt_rot:
.8f9d		20 49 d8	jsr $d849	                jsr underflow_3
.8fa0		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.8fa2		b5 03		lda $03,x	                lda 3,x
.8fa4		95 05		sta $05,x	                sta 5,x
.8fa6		b5 01		lda $01,x	                lda 1,x
.8fa8		95 03		sta $03,x	                sta 3,x
.8faa		94 01		sty $01,x	                sty 1,x
.8fac		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.8fae		b5 02		lda $02,x	                lda 2,x
.8fb0		95 04		sta $04,x	                sta 4,x
.8fb2		b5 00		lda $00,x	                lda 0,x
.8fb4		95 02		sta $02,x	                sta 2,x
.8fb6		94 00		sty $00,x	                sty 0,x
.8fb8		60		rts		z_rot:          rts
.8fb9						xt_rshift:
.8fb9		20 44 d8	jsr $d844	                jsr underflow_2
.8fbc		b5 00		lda $00,x	                lda 0,x
.8fbe		29 0f		and #$0f	                and #%00001111
.8fc0		f0 08		beq $8fca	                beq _done               ; if 0 shifts, quit
.8fc2		a8		tay		                tay
.8fc3						_loop:
.8fc3		56 03		lsr $03,x	                lsr 3,x
.8fc5		76 02		ror $02,x	                ror 2,x
.8fc7		88		dey		                dey
.8fc8		d0 f9		bne $8fc3	                bne _loop
.8fca						_done:
.8fca		e8		inx		                inx
.8fcb		e8		inx		                inx
.8fcc		60		rts		z_rshift:       rts
.8fcd						xt_s_backslash_quote:
.8fcd		a9 ff		lda #$ff	                lda #$FF
.8fcf		85 27		sta $27		                sta tmp2
.8fd1		64 28		stz $28		                stz tmp2+1
.8fd3		20 ea 8f	jsr $8fea	                jsr s_quote_start
.8fd6						z_s_backslash_quote:
.8fd6		60		rts		                rts
.8fd7						convert_hex_value:
.8fd7		c9 41		cmp #$41	        cmp #'A'
.8fd9		90 07		bcc $8fe2	        bcc _digit
.8fdb		29 df		and #$df	        and #$DF                ; Make it uppercase.
.8fdd		38		sec		        sec
.8fde		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.8fe0		80 03		bra $8fe5	        bra _done
.8fe2						_digit:
.8fe2		38		sec		        sec
.8fe3		e9 30		sbc #$30	        sbc #'0'
.8fe5						_done:
.8fe5		60		rts		        rts
.8fe6						xt_s_quote:
.8fe6		64 27		stz $27		                stz tmp2
.8fe8		64 28		stz $28		                stz tmp2+1
.8fea						s_quote_start:
.8fea		20 95 97	jsr $9795	                jsr cmpl_jump_later
.8fed		20 1b 89	jsr $891b	                jsr xt_here             ; the start of the string
.8ff0						_savechars_loop:
.8ff0		a5 11		lda $11		                lda toin+1              ; MSB
.8ff2		c5 0f		cmp $0f		                cmp ciblen+1
.8ff4		90 2a		bcc $9020	                bcc _input_fine         ; unsigned comparison
.8ff6		a5 10		lda $10		                lda toin                ; LSB
.8ff8		c5 0e		cmp $0e		                cmp ciblen
.8ffa		90 24		bcc $9020	                bcc _input_fine
.8ffc		a5 27		lda $27		                lda tmp2
.8ffe		48		pha		                pha
.8fff		a5 28		lda $28		                lda tmp2+1
.9001		48		pha		                pha
.9002		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9004		48		pha		                pha
.9005		20 4e 8f	jsr $8f4e	                jsr xt_refill           ; ( -- f )
.9008		68		pla		                pla
.9009		85 29		sta $29		                sta tmp3
.900b		68		pla		                pla
.900c		85 28		sta $28		                sta tmp2+1
.900e		68		pla		                pla
.900f		85 27		sta $27		                sta tmp2
.9011		b5 00		lda $00,x	                lda 0,x
.9013		15 01		ora $01,x	                ora 1,x
.9015		d0 05		bne $901c	                bne _refill_ok
.9017		a9 06		lda #$06	                lda #err_refill
.9019		4c 55 d8	jmp $d855	                jmp error
.901c						_refill_ok:
.901c		e8		inx		                inx
.901d		e8		inx		                inx
.901e		80 d0		bra $8ff0	                bra _savechars_loop
.9020						_input_fine:
.9020		a5 0c		lda $0c		                lda cib
.9022		18		clc		                clc
.9023		65 10		adc $10		                adc toin        ; LSB
.9025		85 25		sta $25		                sta tmp1
.9027		a5 0d		lda $0d		                lda cib+1
.9029		65 11		adc $11		                adc toin+1      ; MSB
.902b		85 26		sta $26		                sta tmp1+1
.902d		b2 25		lda ($25)	                lda (tmp1)
.902f		24 27		bit $27		                bit tmp2
.9031		30 03		bmi $9036	                bmi _handle_escapes    ; Only checking bit 7
.9033		4c b9 90	jmp $90b9	                jmp _regular_char
.9036						_handle_escapes:
.9036		24 28		bit $28		                bit tmp2+1
.9038		30 03		bmi $903d	                bmi _escaped
.903a		4c af 90	jmp $90af	                jmp _not_escaped
.903d						_escaped:
.903d		70 3c		bvs $907b	                bvs _check_esc_chars
.903f		a9 01		lda #$01	                lda #1
.9041		24 28		bit $28		                bit tmp2+1
.9043		d0 10		bne $9055	                bne _esc_x_second_digit
.9045		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.9047		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.9049		20 d7 8f	jsr $8fd7	                jsr convert_hex_value
.904c		0a		asl a		                asl
.904d		0a		asl a		                asl
.904e		0a		asl a		                asl
.904f		0a		asl a		                asl
.9050		85 29		sta $29		                sta tmp3    ; Save it for later.
.9052		4c c0 90	jmp $90c0	                jmp _next_character
.9055						_esc_x_second_digit:
.9055		64 28		stz $28		                stz tmp2+1
.9057		b2 25		lda ($25)	                lda (tmp1)
.9059		20 d7 8f	jsr $8fd7	                jsr convert_hex_value
.905c		05 29		ora $29		                ora tmp3
.905e		4c bd 90	jmp $90bd	                jmp _save_character
.9061						_esc_tr_table:
>9061		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9062		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9063		00 00				    .byte   0,0             ; c, d no escape
>9065		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9066		0c				    .byte   12              ; f -> FF (ASCII value 12)
>9067		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>906c		0a				    .byte   10              ; l -> LF (ASCII value 10)
>906d		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>906e		0a				    .byte   10              ; n behaves like l --> lf
>906f		00 00				    .byte   0,0             ; o,p
>9071		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9072		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9073		00				    .byte   0               ; s
>9074		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9075		00				    .byte   0               ; u
>9076		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9077		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>907a		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.907b						_check_esc_chars:
.907b		64 28		stz $28		                stz tmp2+1
.907d		c9 61		cmp #$61	                cmp #'a'
.907f		30 1a		bmi $909b	                bmi _check_esc_quote
.9081		c9 7b		cmp #$7b	                cmp #'z'+1
.9083		10 16		bpl $909b	                bpl _check_esc_quote
.9085		a8		tay		                tay
.9086		b9 00 90	lda $9000,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9089		d0 03		bne $908e	                bne _esc_replace
.908b		98		tya		                tya                     ; revert if no translation
.908c		80 0d		bra $909b	                bra _check_esc_quote
.908e		10 2d		bpl $90bd	_esc_replace:   bpl _save_character     ; simple replacement
.9090		29 7f		and #$7f	                and #$7F                ; clear hi bit
.9092		f0 29		beq $90bd	                beq _save_character     ; NUL we can just output
.9094		20 84 97	jsr $9784	                jsr cmpl_a              ; else output first char (CR)
.9097		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9099		80 22		bra $90bd	                bra _save_character
.909b						_check_esc_quote:
.909b		c9 22		cmp #$22	                cmp #'"'
.909d		f0 1e		beq $90bd	                beq _save_character
.909f		c9 78		cmp #$78	                cmp #'x'
.90a1		d0 06		bne $90a9	                bne _check_esc_backslash
.90a3		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.90a5		85 28		sta $28		                sta tmp2+1
.90a7		80 17		bra $90c0	                bra _next_character
.90a9						_check_esc_backslash:
.90a9		c9 5c		cmp #$5c	                cmp #'\'
.90ab		d0 0c		bne $90b9	                bne _regular_char
.90ad		80 0e		bra $90bd	                bra _save_character
.90af						_not_escaped:
.90af		c9 5c		cmp #$5c	                cmp #'\'
.90b1		d0 06		bne $90b9	                bne _regular_char
.90b3		a9 ff		lda #$ff	                lda #$FF
.90b5		85 28		sta $28		                sta tmp2+1
.90b7		80 07		bra $90c0	                bra _next_character
.90b9						_regular_char:
.90b9		c9 22		cmp #$22	                cmp #'"'
.90bb		f0 0c		beq $90c9	                beq _found_string_end
.90bd						_save_character:
.90bd		20 84 97	jsr $9784	                jsr cmpl_a
.90c0						_next_character:
.90c0		e6 10		inc $10		                inc toin
.90c2		d0 02		bne $90c6	                bne _savechars_loop_longjump
.90c4		e6 11		inc $11		                inc toin+1
.90c6						_savechars_loop_longjump:
.90c6		4c f0 8f	jmp $8ff0	                jmp _savechars_loop
.90c9						_found_string_end:
.90c9		e6 10		inc $10		                inc toin
.90cb		d0 02		bne $90cf	                bne +
.90cd		e6 11		inc $11		                inc toin+1
.90cf						+
.90cf		20 1b 89	jsr $891b	                jsr xt_here
.90d2		20 9d 8f	jsr $8f9d	                jsr xt_rot
.90d5		20 24 92	jsr $9224	                jsr xt_store    ; Update the jmp target
.90d8		20 1b 89	jsr $891b	                jsr xt_here
.90db		20 11 8d	jsr $8d11	                jsr xt_over
.90de		20 f6 8b	jsr $8bf6	                jsr xt_minus    ; HERE - addr gives string length
.90e1		a5 1a		lda $1a		                lda state
.90e3		05 1b		ora $1b		                ora state+1             ; paranoid
.90e5		f0 03		beq $90ea	                beq _done
.90e7		20 c8 a1	jsr $a1c8	                jsr cmpl_sliteral         ; ( addr u -- )
.90ea						_done:
.90ea		60		rts		z_s_quote:      rts
.90eb						xt_s_to_d:
.90eb		20 3f d8	jsr $d83f	                jsr underflow_1
.90ee		ca		dex		                dex
.90ef		ca		dex		                dex
.90f0		74 00		stz $00,x	                stz 0,x
.90f2		74 01		stz $01,x	                stz 1,x
.90f4		b5 03		lda $03,x	                lda 3,x
.90f6		10 04		bpl $90fc	                bpl _done
.90f8		d6 00		dec $00,x	                dec 0,x
.90fa		d6 01		dec $01,x	                dec 1,x
.90fc						_done:
.90fc		60		rts		z_s_to_d:       rts
.90fd						xt_semicolon:
.90fd		24 1c		bit $1c		                bit status
.90ff		70 11		bvs $9112	                bvs _colonword
.9101		a9 60		lda #$60	                lda #OpRTS
.9103		20 84 97	jsr $9784	                jsr cmpl_a
.9106		ca		dex		                dex
.9107		ca		dex		                dex
.9108		a5 06		lda $06		                lda workword
.910a		95 00		sta $00,x	                sta 0,x
.910c		a5 07		lda $07		                lda workword+1
.910e		95 01		sta $01,x	                sta 1,x
.9110		80 45		bra $9157	                bra _semicolon_done
.9112						_colonword:
.9112		a0 06		ldy #$06	                ldy #6
.9114		a5 00		lda $00		                lda cp
.9116		91 06		sta ($06),y	                sta (workword),y
.9118		c8		iny		                iny
.9119		a5 01		lda $01		                lda cp+1
.911b		91 06		sta ($06),y	                sta (workword),y
.911d		a9 60		lda #$60	                lda #OpRTS
.911f		20 84 97	jsr $9784	                jsr cmpl_a
.9122		24 1c		bit $1c		                bit status
.9124		10 26		bpl $914c	                bpl _new_word   ; Bit 7 is clear = new word
.9126		ca		dex		                dex
.9127		ca		dex		                dex
.9128		ca		dex		                dex
.9129		ca		dex		                dex
.912a		b2 06		lda ($06)	                lda (workword)
.912c		95 00		sta $00,x	                sta 0,x
.912e		74 01		stz $01,x	                stz 1,x
.9130		a5 06		lda $06		                lda workword
.9132		18		clc		                clc
.9133		69 08		adc #$08	                adc #8
.9135		95 02		sta $02,x	                sta 2,x
.9137		a5 07		lda $07		                lda workword+1
.9139		69 00		adc #$00	                adc #0                  ; only want carry
.913b		95 03		sta $03,x	                sta 3,x
.913d		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.913f		20 7b d8	jsr $d87b	                jsr print_string_no_lf
.9142		20 d0 94	jsr $94d0	                jsr xt_type
.9145		20 d7 91	jsr $91d7	                jsr xt_space
.9148		a9 80		lda #$80	                lda #%10000000
.914a		14 1c		trb $1c		                trb status
.914c						_new_word:
.914c		a5 06		lda $06		                lda workword
.914e		85 02		sta $02		                sta dp
.9150		a5 07		lda $07		                lda workword+1
.9152		85 03		sta $03		                sta dp+1
.9154		20 a9 d7	jsr $d7a9	                jsr dp_to_current       ; Save the updated DP to the
.9157						_semicolon_done:
.9157		64 1a		stz $1a		                stz state
.9159		64 1b		stz $1b		                stz state+1
.915b		60		rts		z_semicolon:    rts
.915c						xt_sign:
.915c		20 3f d8	jsr $d83f	                jsr underflow_1
.915f		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9161		30 04		bmi $9167	                bmi _minus
.9163		e8		inx		                inx
.9164		e8		inx		                inx
.9165		80 09		bra $9170	                bra _done
.9167						_minus:
.9167		a9 2d		lda #$2d	                lda #'-'
.9169		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.916b		74 01		stz $01,x	                stz 1,x         ; paranoid
.916d		20 2d 89	jsr $892d	                jsr xt_hold
.9170						_done:
.9170		60		rts		z_sign:         rts
.9171						xt_slash:
.9171		a9 00		lda #$00	                lda #0
.9173		48		pha		                pha
.9174		80 03		bra $9179	                bra slashmod_common
.9176						xt_slash_mod:
.9176		a9 ff		lda #$ff	                lda #$FF
.9178		48		pha		                pha             ; falls through to _common
.9179						slashmod_common:
.9179		20 78 93	jsr $9378	                jsr xt_to_r             ; >R
.917c		20 eb 90	jsr $90eb	                jsr xt_s_to_d           ; S>D
.917f		20 fc 8e	jsr $8efc	                jsr xt_r_from           ; R>
.9182		20 8e 91	jsr $918e	                jsr xt_sm_slash_rem     ; SM/REM
.9185		68		pla		                pla
.9186		d0 05		bne $918d	                bne _done
.9188		20 3a 92	jsr $923a	                jsr xt_swap
.918b		e8		inx		                inx             ; DROP
.918c		e8		inx		                inx
.918d						_done:
.918d						z_slash_mod:
.918d		60		rts		z_slash:        rts
.918e						xt_sm_slash_rem:
.918e		20 49 d8	jsr $d849	                jsr underflow_3 ; contains double number
.9191		b5 03		lda $03,x	                lda 3,x
.9193		48		pha		                pha
.9194		b5 01		lda $01,x	                lda 1,x
.9196		55 03		eor $03,x	                eor 3,x
.9198		48		pha		                pha
.9199		20 cf 80	jsr $80cf	                jsr xt_abs
.919c		e8		inx		                inx             ; pretend we pushed n1 to R
.919d		e8		inx		                inx
.919e		20 45 9e	jsr $9e45	                jsr xt_dabs
.91a1		ca		dex		                dex
.91a2		ca		dex		                dex
.91a3		20 55 95	jsr $9555	                jsr xt_um_slash_mod     ; UM/MOD
.91a6		68		pla		                pla
.91a7		10 03		bpl $91ac	                bpl +
.91a9		20 31 8c	jsr $8c31	                jsr xt_negate
.91ac						+
.91ac		68		pla		                pla
.91ad		10 07		bpl $91b6	                bpl _done
.91af		e8		inx		                inx             ; pretend we pushed quotient to R
.91b0		e8		inx		                inx
.91b1		20 31 8c	jsr $8c31	                jsr xt_negate
.91b4		ca		dex		                dex
.91b5		ca		dex		                dex
.91b6						_done:
.91b6		60		rts		z_sm_slash_rem: rts
.91b7						xt_source:
.91b7		ca		dex		                dex
.91b8		ca		dex		                dex
.91b9		a5 0c		lda $0c		                lda cib
.91bb		95 00		sta $00,x	                sta 0,x
.91bd		a5 0d		lda $0d		                lda cib+1
.91bf		95 01		sta $01,x	                sta 1,x
.91c1		ca		dex		                dex
.91c2		ca		dex		                dex
.91c3		a5 0e		lda $0e		                lda ciblen
.91c5		95 00		sta $00,x	                sta 0,x
.91c7		a5 0f		lda $0f		                lda ciblen+1
.91c9		95 01		sta $01,x	                sta 1,x
.91cb		60		rts		z_source:       rts
.91cc						xt_source_id:
.91cc		ca		dex		                dex
.91cd		ca		dex		                dex
.91ce		a5 0a		lda $0a		                lda insrc
.91d0		95 00		sta $00,x	                sta 0,x
.91d2		a5 0b		lda $0b		                lda insrc+1
.91d4		95 01		sta $01,x	                sta 1,x
.91d6		60		rts		z_source_id:    rts
.91d7						xt_space:
.91d7		a9 20		lda #$20	                lda #AscSP
.91d9		20 c5 86	jsr $86c5	                jsr emit_a
.91dc		60		rts		z_space:        rts
.91dd						xt_spaces:
.91dd		20 3f d8	jsr $d83f	                jsr underflow_1
.91e0		b5 01		lda $01,x	                lda 1,x         ; ANS says this word takes a signed value
.91e2		30 10		bmi $91f4	                bmi _done       ; but prints no spaces for negative values.
.91e4		b4 00		ldy $00,x	                ldy 0,x
.91e6		f0 08		beq $91f0	                beq _msb
.91e8						_loop:
.91e8		a9 20		lda #$20	                lda #AscSP
.91ea		20 c5 86	jsr $86c5	                jsr emit_a      ; user routine preserves X and Y
.91ed		88		dey		                dey
.91ee		d0 f8		bne $91e8	                bne _loop       ; Y is zero on exit so looping again emits 256 more spaces
.91f0						_msb:
.91f0		d6 01		dec $01,x	                dec 1,x         ; when decrementing MSB goes negative, it was zero so we're done
.91f2		10 f4		bpl $91e8	                bpl _loop       ; otherwise emit another 256 spaces
.91f4		e8		inx		_done:          inx
.91f5		e8		inx		                inx
.91f6		60		rts		z_spaces:       rts
.91f7						xt_star:
.91f7		20 44 d8	jsr $d844	                jsr underflow_2
.91fa		20 97 95	jsr $9597	                jsr xt_um_star
.91fd		e8		inx		                inx
.91fe		e8		inx		                inx
.91ff		60		rts		z_star:         rts
.9200						xt_star_slash:
.9200		20 09 92	jsr $9209	                jsr xt_star_slash_mod
.9203		20 3a 92	jsr $923a	                jsr xt_swap
.9206		e8		inx		                inx
.9207		e8		inx		                inx
.9208						z_star_slash:
.9208		60		rts		                rts
.9209						xt_star_slash_mod:
.9209		20 49 d8	jsr $d849	                jsr underflow_3
.920c		20 78 93	jsr $9378	                jsr xt_to_r
.920f		20 33 8b	jsr $8b33	                jsr xt_m_star
.9212		20 fc 8e	jsr $8efc	                jsr xt_r_from
.9215		20 8e 91	jsr $918e	                jsr xt_sm_slash_rem
.9218						z_star_slash_mod:
.9218		60		rts		                rts
.9219						xt_state:
.9219		ca		dex		                dex
.921a		ca		dex		                dex
.921b		a9 1a		lda #$1a	                lda #<state
.921d		95 00		sta $00,x	                sta 0,x
.921f		a9 00		lda #$00	                lda #>state
.9221		95 01		sta $01,x	                sta 1,x
.9223		60		rts		z_state:        rts
.9224						xt_store:
.9224		20 44 d8	jsr $d844	                jsr underflow_2
.9227		b5 02		lda $02,x	                lda 2,x         ; LSB
.9229		81 00		sta ($00,x)	                sta (0,x)
.922b		f6 00		inc $00,x	                inc 0,x
.922d		d0 02		bne $9231	                bne +
.922f		f6 01		inc $01,x	                inc 1,x
.9231						+
.9231		b5 03		lda $03,x	                lda 3,x         ; MSB
.9233		81 00		sta ($00,x)	                sta (0,x)
.9235		e8		inx		                inx             ; 2DROP
.9236		e8		inx		                inx
.9237		e8		inx		                inx
.9238		e8		inx		                inx
.9239		60		rts		z_store:        rts
.923a						xt_swap:
.923a		20 44 d8	jsr $d844	                jsr underflow_2
.923d		b5 00		lda $00,x	                lda 0,x         ; LSB
.923f		b4 02		ldy $02,x	                ldy 2,x
.9241		95 02		sta $02,x	                sta 2,x
.9243		94 00		sty $00,x	                sty 0,x
.9245		b5 01		lda $01,x	                lda 1,x         ; MSB
.9247		b4 03		ldy $03,x	                ldy 3,x
.9249		95 03		sta $03,x	                sta 3,x
.924b		94 01		sty $01,x	                sty 1,x
.924d		60		rts		z_swap:         rts
.924e						xt_tick:
.924e		20 5d 8d	jsr $8d5d	                jsr xt_parse_name       ; ( -- addr u )
.9251		b5 00		lda $00,x	                lda 0,x
.9253		15 01		ora $01,x	                ora 1,x
.9255		d0 05		bne $925c	                bne +
.9257		a9 05		lda #$05	                lda #err_noname
.9259		4c 55 d8	jmp $d855	                jmp error
.925c						+
.925c		20 ea 9a	jsr $9aea	                jsr xt_find_name        ; ( addr u -- nt )
.925f		b5 00		lda $00,x	                lda 0,x
.9261		15 01		ora $01,x	                ora 1,x
.9263		d0 05		bne $926a	                bne +
.9265		a9 08		lda #$08	                lda #err_syntax
.9267		4c 55 d8	jmp $d855	                jmp error
.926a						+
.926a		20 33 9c	jsr $9c33	                jsr xt_name_to_int      ; ( nt -- xt )
.926d		60		rts		z_tick:         rts
.926e						xt_to:
.926e		20 4e 92	jsr $924e	                jsr xt_tick             ; ( [n] xt )
.9271		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9273		18		clc		                clc
.9274		69 03		adc #$03	                adc #3
.9276		85 25		sta $25		                sta tmp1
.9278		b5 01		lda $01,x	                lda 1,x                 ; MSB
.927a		69 00		adc #$00	                adc #0                  ; we just want the carry
.927c		85 26		sta $26		                sta tmp1+1
.927e		a5 1a		lda $1a		                lda state
.9280		05 1b		ora $1b		                ora state+1
.9282		f0 14		beq $9298	                beq _interpret
.9284		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.9286		95 00		sta $00,x	                sta 0,x
.9288		a5 26		lda $26		                lda tmp1+1
.928a		95 01		sta $01,x	                sta 1,x
.928c		20 04 8a	jsr $8a04	                jsr xt_literal      ; generate the runtime for LITERAL tmp1
.928f		a0 92		ldy #$92	                ldy #>xt_store      ; write the runtime for !
.9291		a9 24		lda #$24	                lda #<xt_store
.9293		20 74 97	jsr $9774	                jsr cmpl_subroutine
.9296		80 11		bra $92a9	                bra _done
.9298						_interpret:
.9298		20 44 d8	jsr $d844	                jsr underflow_2
.929b		e8		inx		                inx
.929c		e8		inx		                inx                     ; leaving just ( n )
.929d		b5 00		lda $00,x	                lda 0,x
.929f		92 25		sta ($25)	                sta (tmp1)              ; LSB
.92a1		a0 01		ldy #$01	                ldy #1
.92a3		b5 01		lda $01,x	                lda 1,x                 ; MSB
.92a5		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.92a7		e8		inx		                inx                     ; DROP
.92a8		e8		inx		                inx
.92a9						_done:
.92a9		60		rts		z_to:           rts
.92aa						xt_to_body:
.92aa		20 3f d8	jsr $d83f	                jsr underflow_1
.92ad		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( xt xt )
.92b0		20 ad 9b	jsr $9bad	                jsr xt_int_to_name      ; ( xt nt )
.92b3		f6 00		inc $00,x	                inc 0,x
.92b5		d0 02		bne $92b9	                bne +
.92b7		f6 01		inc $01,x	                inc 1,x
.92b9						+
.92b9		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.92bb		29 20		and #$20	                and #HC
.92bd		f0 0b		beq $92ca	                beq _no_cfa
.92bf		18		clc		                clc
.92c0		b5 02		lda $02,x	                lda 2,x         ; LSB
.92c2		69 03		adc #$03	                adc #3
.92c4		95 02		sta $02,x	                sta 2,x
.92c6		90 02		bcc $92ca	                bcc _no_cfa
.92c8		f6 03		inc $03,x	                inc 3,x         ; MSB
.92ca						_no_cfa:
.92ca		e8		inx		                inx             ; get rid of the nt
.92cb		e8		inx		                inx
.92cc		60		rts		z_to_body:      rts
.92cd						xt_to_in:
.92cd		ca		dex		                dex
.92ce		ca		dex		                dex
.92cf		a9 10		lda #$10	                lda #<toin
.92d1		95 00		sta $00,x	                sta 0,x
.92d3		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.92d5		95 01		sta $01,x	                sta 1,x
.92d7		60		rts		z_to_in:        rts
.92d8						xt_to_number:
.92d8		20 4e d8	jsr $d84e	                jsr underflow_4
.92db		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.92dd		85 2d		sta $2d		                sta scratch
.92df		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.92e1		85 2e		sta $2e		                sta scratch+1
.92e3		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.92e5		85 2f		sta $2f		                sta scratch+2
.92e7		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.92e9		85 30		sta $30		                sta scratch+3
.92eb		ca		dex		                dex
.92ec		ca		dex		                dex
.92ed						_loop:
.92ed		a1 04		lda ($04,x)	                lda (4,x)
.92ef		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.92f1		74 01		stz $01,x	                stz 1,x                 ; paranoid
.92f3		20 8e 9a	jsr $9a8e	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.92f6		b5 00		lda $00,x	                lda 0,x
.92f8		d0 04		bne $92fe	                bne _digit_ok
.92fa		e8		inx		                inx
.92fb		e8		inx		                inx
.92fc		80 67		bra $9365	                bra _done       ; ( ud-lo ud-hi addr u char )
.92fe						_digit_ok:
.92fe		b5 02		lda $02,x	                lda 2,x
.9300		85 31		sta $31		                sta scratch+4
.9302		b5 03		lda $03,x	                lda 3,x
.9304		85 32		sta $32		                sta scratch+5
.9306		a5 2f		lda $2f		                lda scratch+2
.9308		95 02		sta $02,x	                sta 2,x         ; NOS
.930a		a5 30		lda $30		                lda scratch+3
.930c		95 03		sta $03,x	                sta 3,x
.930e		a5 18		lda $18		                lda base
.9310		95 00		sta $00,x	                sta 0,x         ; TOS
.9312		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.9314		20 97 95	jsr $9597	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.9317		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.9319		85 33		sta $33		                sta scratch+6
.931b		b5 03		lda $03,x	                lda 3,x
.931d		85 34		sta $34		                sta scratch+7
.931f		a5 2d		lda $2d		                lda scratch
.9321		95 02		sta $02,x	                sta 2,x
.9323		a5 2e		lda $2e		                lda scratch+1
.9325		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.9327		a5 18		lda $18		                lda base
.9329		95 00		sta $00,x	                sta 0,x
.932b		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.932d		20 97 95	jsr $9597	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9330		b5 00		lda $00,x	                lda 0,x
.9332		85 2f		sta $2f		                sta scratch+2
.9334		b5 01		lda $01,x	                lda 1,x
.9336		85 30		sta $30		                sta scratch+3
.9338		b5 02		lda $02,x	                lda 2,x
.933a		85 2d		sta $2d		                sta scratch
.933c		b5 03		lda $03,x	                lda 3,x
.933e		85 2e		sta $2e		                sta scratch+1
.9340		18		clc		                clc
.9341		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.9343		65 31		adc $31		                adc scratch+4   ; n LSB
.9345		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.9347		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.9349		65 32		adc $32		                adc scratch+5   ; n MSB
.934b		85 2e		sta $2e		                sta scratch+1
.934d		a5 2f		lda $2f		                lda scratch+2   ; LSB
.934f		65 33		adc $33		                adc scratch+6
.9351		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.9353		a5 30		lda $30		                lda scratch+3   ; MSB
.9355		65 34		adc $34		                adc scratch+7
.9357		85 30		sta $30		                sta scratch+3
.9359		e8		inx		                inx
.935a		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.935b		f6 04		inc $04,x	                inc 4,x
.935d		d0 02		bne $9361	                bne +
.935f		f6 05		inc $05,x	                inc 5,x
.9361						+
.9361		d6 02		dec $02,x	                dec 2,x
.9363		d0 88		bne $92ed	                bne _loop
.9365						_done:
.9365		e8		inx		                inx
.9366		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.9367		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.9369		95 06		sta $06,x	                sta 6,x
.936b		a5 2e		lda $2e		                lda scratch+1
.936d		95 07		sta $07,x	                sta 7,x
.936f		a5 2f		lda $2f		                lda scratch+2
.9371		95 04		sta $04,x	                sta 4,x
.9373		a5 30		lda $30		                lda scratch+3
.9375		95 05		sta $05,x	                sta 5,x
.9377		60		rts		z_to_number:    rts
.9378						xt_to_r:
.9378						w_to_r:
.9378		68		pla		                pla                     ; LSB
.9379		7a		ply		                ply                     ; MSB
.937a		1a		inc a		                inc a
.937b		85 25		sta $25		                sta tmp1                ; LSB
.937d		d0 01		bne $9380	                bne +
.937f		c8		iny		                iny
.9380						+
.9380		84 26		sty $26		                sty tmp1+1              ; MSB
.9382		20 3f d8	jsr $d83f	                jsr underflow_1
.9385		b5 01		lda $01,x	                lda 1,x         ; MSB
.9387		48		pha		                pha
.9388		b5 00		lda $00,x	                lda 0,x         ; LSB
.938a		48		pha		                pha
.938b		e8		inx		                inx
.938c		e8		inx		                inx
.938d		6c 25 00	jmp ($0025)	z_to_r:         jmp (tmp1)
.9390						xt_true:
.9390		ca		dex		                dex
.9391		ca		dex		                dex
.9392		a9 ff		lda #$ff	                lda #$FF
.9394		95 00		sta $00,x	                sta 0,x
.9396		95 01		sta $01,x	                sta 1,x
.9398		60		rts		z_true:         rts
.9399						xt_tuck:
.9399		20 44 d8	jsr $d844	                jsr underflow_2
.939c		ca		dex		                dex
.939d		ca		dex		                dex
.939e		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.93a0		b5 02		lda $02,x	                lda 2,x
.93a2		95 04		sta $04,x	                sta 4,x
.93a4		94 02		sty $02,x	                sty 2,x
.93a6		95 00		sta $00,x	                sta 0,x
.93a8		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.93aa		b5 03		lda $03,x	                lda 3,x
.93ac		95 05		sta $05,x	                sta 5,x
.93ae		94 03		sty $03,x	                sty 3,x         ; bba
.93b0		95 01		sta $01,x	                sta 1,x         ; baa
.93b2		60		rts		z_tuck:         rts
.93b3						xt_two_drop:
.93b3		20 44 d8	jsr $d844	                jsr underflow_2
.93b6		e8		inx		                inx
.93b7		e8		inx		                inx
.93b8		e8		inx		                inx
.93b9		e8		inx		                inx
.93ba		60		rts		z_two_drop:     rts
.93bb						xt_two_dup:
.93bb		20 44 d8	jsr $d844	                jsr underflow_2
.93be		ca		dex		                dex
.93bf		ca		dex		                dex
.93c0		ca		dex		                dex
.93c1		ca		dex		                dex
.93c2		b5 04		lda $04,x	                lda 4,x         ; TOS
.93c4		95 00		sta $00,x	                sta 0,x
.93c6		b5 05		lda $05,x	                lda 5,x
.93c8		95 01		sta $01,x	                sta 1,x
.93ca		b5 06		lda $06,x	                lda 6,x         ; NOS
.93cc		95 02		sta $02,x	                sta 2,x
.93ce		b5 07		lda $07,x	                lda 7,x
.93d0		95 03		sta $03,x	                sta 3,x
.93d2		60		rts		z_two_dup:      rts
.93d3						xt_two_fetch:
.93d3		20 3f d8	jsr $d83f	                jsr underflow_1
.93d6		b5 00		lda $00,x	                lda 0,x
.93d8		85 25		sta $25		                sta tmp1
.93da		b4 01		ldy $01,x	                ldy 1,x
.93dc		84 26		sty $26		                sty tmp1+1
.93de		ca		dex		                dex             ; reuse one stack element
.93df		ca		dex		                dex
.93e0		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.93e2		95 00		sta $00,x	                sta 0,x
.93e4		a0 01		ldy #$01	                ldy #1          ; copy next
.93e6		b1 25		lda ($25),y	                lda (tmp1),y
.93e8		95 01		sta $01,x	                sta 1,x
.93ea		c8		iny		                iny             ; copy next
.93eb		b1 25		lda ($25),y	                lda (tmp1),y
.93ed		95 02		sta $02,x	                sta 2,x
.93ef		c8		iny		                iny             ; copy next
.93f0		b1 25		lda ($25),y	                lda (tmp1),y
.93f2		95 03		sta $03,x	                sta 3,x
.93f4		60		rts		z_two_fetch:    rts
.93f5						xt_two_over:
.93f5		20 4e d8	jsr $d84e	                jsr underflow_4
.93f8		ca		dex		                dex
.93f9		ca		dex		                dex
.93fa		ca		dex		                dex
.93fb		ca		dex		                dex
.93fc		b5 08		lda $08,x	                lda 8,x
.93fe		95 00		sta $00,x	                sta 0,x
.9400		b5 09		lda $09,x	                lda 9,x
.9402		95 01		sta $01,x	                sta 1,x
.9404		b5 0a		lda $0a,x	                lda 10,x
.9406		95 02		sta $02,x	                sta 2,x
.9408		b5 0b		lda $0b,x	                lda 11,x
.940a		95 03		sta $03,x	                sta 3,x
.940c		60		rts		z_two_over:     rts
.940d						xt_two_r_fetch:
.940d		68		pla		                pla                     ; LSB
.940e		7a		ply		                ply                     ; MSB
.940f		1a		inc a		                inc a
.9410		85 25		sta $25		                sta tmp1                ; LSB
.9412		d0 01		bne $9415	                bne +
.9414		c8		iny		                iny
.9415						+
.9415		84 26		sty $26		                sty tmp1+1              ; MSB
.9417		8a		txa		                txa             ; arrange for Y = SP; X -= 4
.9418		ba		tsx		                tsx
.9419		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.941a		7a		ply		                ply
.941b		38		sec		                sec
.941c		e9 04		sbc #$04	                sbc #4
.941e		aa		tax		                tax
.941f		b9 01 01	lda $0101,y	                lda $101,y
.9422		95 00		sta $00,x	                sta 0,x
.9424		b9 02 01	lda $0102,y	                lda $102,y
.9427		95 01		sta $01,x	                sta 1,x
.9429		b9 03 01	lda $0103,y	                lda $103,y
.942c		95 02		sta $02,x	                sta 2,x
.942e		b9 04 01	lda $0104,y	                lda $104,y
.9431		95 03		sta $03,x	                sta 3,x
.9433		6c 25 00	jmp ($0025)	z_two_r_fetch:  jmp (tmp1)
.9436						xt_two_r_from:
.9436		68		pla		                pla
.9437		7a		ply		                ply                     ; MSB
.9438		1a		inc a		                inc a
.9439		85 25		sta $25		                sta tmp1                ; LSB
.943b		d0 01		bne $943e	                bne +
.943d		c8		iny		                iny
.943e						+
.943e		84 26		sty $26		                sty tmp1+1              ; MSB
.9440		ca		dex		                dex
.9441		ca		dex		                dex
.9442		ca		dex		                dex
.9443		ca		dex		                dex
.9444		68		pla		                pla                     ; LSB
.9445		95 00		sta $00,x	                sta 0,x
.9447		68		pla		                pla                     ; MSB
.9448		95 01		sta $01,x	                sta 1,x
.944a		68		pla		                pla                     ; LSB
.944b		95 02		sta $02,x	                sta 2,x
.944d		68		pla		                pla                     ; MSB
.944e		95 03		sta $03,x	                sta 3,x
.9450		6c 25 00	jmp ($0025)	z_two_r_from:   jmp (tmp1)
.9453						xt_two_slash:
.9453		20 3f d8	jsr $d83f	                jsr underflow_1
.9456		b5 01		lda $01,x	                lda 1,x
.9458		0a		asl a		                asl                     ; save the sign
.9459		76 01		ror $01,x	                ror 1,x
.945b		76 00		ror $00,x	                ror 0,x
.945d		60		rts		z_two_slash:    rts
.945e						xt_two_star:
.945e						xt_cells:
.945e		20 3f d8	jsr $d83f	                jsr underflow_1
.9461		16 00		asl $00,x	                asl 0,x
.9463		36 01		rol $01,x	                rol 1,x
.9465						z_cells:
.9465		60		rts		z_two_star:     rts
.9466						xt_two_store:
.9466		20 49 d8	jsr $d849	                jsr underflow_3
.9469		b5 00		lda $00,x	                lda 0,x
.946b		85 25		sta $25		                sta tmp1
.946d		b4 01		ldy $01,x	                ldy 1,x
.946f		84 26		sty $26		                sty tmp1+1
.9471		e8		inx		                inx
.9472		e8		inx		                inx
.9473		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.9475		92 25		sta ($25)	                sta (tmp1)
.9477		b5 01		lda $01,x	                lda 1,x         ; copy next
.9479		a0 01		ldy #$01	                ldy #1
.947b		91 25		sta ($25),y	                sta (tmp1),y
.947d		b5 02		lda $02,x	                lda 2,x         ; copy next
.947f		c8		iny		                iny
.9480		91 25		sta ($25),y	                sta (tmp1),y
.9482		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.9484		c8		iny		                iny
.9485		91 25		sta ($25),y	                sta (tmp1),y
.9487		e8		inx		                inx             ; 2DROP
.9488		e8		inx		                inx
.9489		e8		inx		                inx
.948a		e8		inx		                inx
.948b		60		rts		z_two_store:    rts
.948c						xt_two_swap:
.948c		20 4e d8	jsr $d84e	                jsr underflow_4
.948f		b5 00		lda $00,x	                lda 0,x
.9491		b4 04		ldy $04,x	                ldy 4,x
.9493		95 04		sta $04,x	                sta 4,x
.9495		94 00		sty $00,x	                sty 0,x
.9497		b5 01		lda $01,x	                lda 1,x
.9499		b4 05		ldy $05,x	                ldy 5,x
.949b		95 05		sta $05,x	                sta 5,x
.949d		94 01		sty $01,x	                sty 1,x
.949f		b5 02		lda $02,x	                lda 2,x
.94a1		b4 06		ldy $06,x	                ldy 6,x
.94a3		95 06		sta $06,x	                sta 6,x
.94a5		94 02		sty $02,x	                sty 2,x
.94a7		b5 03		lda $03,x	                lda 3,x
.94a9		b4 07		ldy $07,x	                ldy 7,x
.94ab		95 07		sta $07,x	                sta 7,x
.94ad		94 03		sty $03,x	                sty 3,x
.94af		60		rts		z_two_swap:     rts
.94b0						xt_two_to_r:
.94b0						w_two_to_r:
.94b0		68		pla		                pla                     ; LSB
.94b1		7a		ply		                ply                     ; MSB
.94b2		1a		inc a		                inc a
.94b3		85 25		sta $25		                sta tmp1                ; LSB
.94b5		d0 01		bne $94b8	                bne +
.94b7		c8		iny		                iny
.94b8						+
.94b8		84 26		sty $26		                sty tmp1+1              ; MSB
.94ba		20 44 d8	jsr $d844	                jsr underflow_2
.94bd		b5 03		lda $03,x	                lda 3,x         ; MSB
.94bf		48		pha		                pha
.94c0		b5 02		lda $02,x	                lda 2,x         ; LSB
.94c2		48		pha		                pha
.94c3		b5 01		lda $01,x	                lda 1,x         ; MSB
.94c5		48		pha		                pha
.94c6		b5 00		lda $00,x	                lda 0,x         ; LSB
.94c8		48		pha		                pha
.94c9		e8		inx		                inx
.94ca		e8		inx		                inx
.94cb		e8		inx		                inx
.94cc		e8		inx		                inx
.94cd		6c 25 00	jmp ($0025)	z_two_to_r:     jmp (tmp1)
.94d0						xt_type:
.94d0		20 44 d8	jsr $d844	                jsr underflow_2
.94d3		b5 02		lda $02,x	                lda 2,x
.94d5		85 25		sta $25		                sta tmp1
.94d7		b5 03		lda $03,x	                lda 3,x
.94d9		85 26		sta $26		                sta tmp1+1
.94db						_loop:
.94db		b5 00		lda $00,x	                lda 0,x
.94dd		15 01		ora $01,x	                ora 1,x
.94df		f0 15		beq $94f6	                beq _done
.94e1		b2 25		lda ($25)	                lda (tmp1)
.94e3		20 c5 86	jsr $86c5	                jsr emit_a      ; avoids stack foolery
.94e6		e6 25		inc $25		                inc tmp1
.94e8		d0 02		bne $94ec	                bne +
.94ea		e6 26		inc $26		                inc tmp1+1
.94ec						+
.94ec		b5 00		lda $00,x	                lda 0,x
.94ee		d0 02		bne $94f2	                bne +
.94f0		d6 01		dec $01,x	                dec 1,x
.94f2						+
.94f2		d6 00		dec $00,x	                dec 0,x
.94f4		80 e5		bra $94db	                bra _loop
.94f6						_done:
.94f6		e8		inx		                inx
.94f7		e8		inx		                inx
.94f8		e8		inx		                inx
.94f9		e8		inx		                inx
.94fa		60		rts		z_type:         rts
.94fb						xt_u_dot:
.94fb		20 3f d8	jsr $d83f	                jsr underflow_1
.94fe		20 ac d8	jsr $d8ac	                jsr print_u
.9501		a9 20		lda #$20	                lda #AscSP
.9503		20 c5 86	jsr $86c5	                jsr emit_a
.9506		60		rts		z_u_dot:        rts
.9507						xt_u_dot_r:
.9507		20 44 d8	jsr $d844	                jsr underflow_2
.950a		20 78 93	jsr $9378	                jsr xt_to_r
.950d		20 f6 9d	jsr $9df6	                jsr xt_zero
.9510		20 e1 89	jsr $89e1	                jsr xt_less_number_sign
.9513		20 bf 8c	jsr $8cbf	                jsr xt_number_sign_s
.9516		20 9d 8c	jsr $8c9d	                jsr xt_number_sign_greater
.9519		20 fc 8e	jsr $8efc	                jsr xt_r_from
.951c		20 11 8d	jsr $8d11	                jsr xt_over
.951f		20 f6 8b	jsr $8bf6	                jsr xt_minus
.9522		20 dd 91	jsr $91dd	                jsr xt_spaces
.9525		20 d0 94	jsr $94d0	                jsr xt_type
.9528		60		rts		z_u_dot_r:      rts
.9529						xt_u_greater_than:
.9529		20 44 d8	jsr $d844	                jsr underflow_2
.952c		b5 00		lda $00,x	                lda 0,x
.952e		d5 02		cmp $02,x	                cmp 2,x
.9530		b5 01		lda $01,x	                lda 1,x
.9532		f5 03		sbc $03,x	                sbc 3,x
.9534		e8		inx		                inx
.9535		e8		inx		                inx
.9536		a9 00		lda #$00	                lda #0
.9538		69 ff		adc #$ff	                adc #$FF
.953a		95 00		sta $00,x	                sta 0,x         ; store flag
.953c		95 01		sta $01,x	                sta 1,x
.953e		60		rts		z_u_greater_than:    rts
.953f						xt_u_less_than:
.953f		20 44 d8	jsr $d844	                jsr underflow_2
.9542		b5 02		lda $02,x	                lda 2,x
.9544		d5 00		cmp $00,x	                cmp 0,x
.9546		b5 03		lda $03,x	                lda 3,x
.9548		f5 01		sbc $01,x	                sbc 1,x
.954a		e8		inx		                inx
.954b		e8		inx		                inx
.954c		a9 00		lda #$00	                lda #0
.954e		69 ff		adc #$ff	                adc #$FF
.9550		95 00		sta $00,x	                sta 0,x         ; store flag
.9552		95 01		sta $01,x	                sta 1,x
.9554		60		rts		z_u_less_than:    rts
.9555						xt_um_slash_mod:
.9555		20 49 d8	jsr $d849	                jsr underflow_3
.9558		b5 00		lda $00,x	                lda 0,x
.955a		15 01		ora $01,x	                ora 1,x
.955c		d0 05		bne $9563	                bne _not_zero
.955e		a9 04		lda #$04	                lda #err_divzero
.9560		4c 55 d8	jmp $d855	                jmp error
.9563						_not_zero:
.9563		a9 11		lda #$11	                lda #17
.9565		85 23		sta $23		                sta tmptos
.9567						_loop:
.9567		36 04		rol $04,x	                rol 4,x
.9569		36 05		rol $05,x	                rol 5,x
.956b		c6 23		dec $23		                dec tmptos
.956d		f0 22		beq $9591	                beq _done
.956f		36 02		rol $02,x	                rol 2,x
.9571		36 03		rol $03,x	                rol 3,x
.9573		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.9575		26 25		rol $25		                rol tmp1
.9577		38		sec		                sec
.9578		b5 02		lda $02,x	                lda 2,x
.957a		f5 00		sbc $00,x	                sbc 0,x
.957c		85 26		sta $26		                sta tmp1+1
.957e		b5 03		lda $03,x	                lda 3,x
.9580		f5 01		sbc $01,x	                sbc 1,x
.9582		a8		tay		                tay
.9583		a5 25		lda $25		                lda tmp1
.9585		e9 00		sbc #$00	                sbc #0
.9587		90 de		bcc $9567	                bcc _loop
.9589		a5 26		lda $26		                lda tmp1+1
.958b		95 02		sta $02,x	                sta 2,x
.958d		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.958f		80 d6		bra $9567	                bra _loop
.9591						_done:
.9591		e8		inx		                inx
.9592		e8		inx		                inx
.9593		20 3a 92	jsr $923a	                jsr xt_swap
.9596		60		rts		z_um_slash_mod: rts
.9597						xt_um_star:
.9597		20 44 d8	jsr $d844	                jsr underflow_2
.959a		18		clc		                clc
.959b		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.959d		e9 00		sbc #$00	                sbc #0
.959f		85 27		sta $27		                sta tmp2
.95a1		b5 01		lda $01,x	                lda 1,x
.95a3		e9 00		sbc #$00	                sbc #0
.95a5		90 31		bcc $95d8	                bcc _zero       ; is TOS zero?
.95a7		85 28		sta $28		                sta tmp2+1
.95a9		a9 00		lda #$00	                lda #0
.95ab		85 25		sta $25		                sta tmp1
.95ad		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.95af		ca		dex		                dex
.95b0		ca		dex		                dex
.95b1						_outer_loop:
.95b1		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.95b3		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.95b5						_inner_loop:
.95b5		90 0c		bcc $95c3	                bcc _no_add
.95b7		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.95b9		a5 25		lda $25		                lda tmp1
.95bb		65 27		adc $27		                adc tmp2
.95bd		85 25		sta $25		                sta tmp1
.95bf		a5 26		lda $26		                lda tmp1+1
.95c1		65 28		adc $28		                adc tmp2+1
.95c3						_no_add:
.95c3		6a		ror a		                ror
.95c4		66 25		ror $25		                ror tmp1
.95c6		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.95c8		88		dey		                dey
.95c9		d0 ea		bne $95b5	                bne _inner_loop ; go back for one more shift?
.95cb		e8		inx		                inx
.95cc		e4 29		cpx $29		                cpx tmp3
.95ce		d0 e1		bne $95b1	                bne _outer_loop ; go back for eight more shifts?
.95d0		95 01		sta $01,x	                sta 1,x
.95d2		a5 25		lda $25		                lda tmp1
.95d4		95 00		sta $00,x	                sta 0,x
.95d6		80 04		bra $95dc	                bra _done
.95d8						_zero:
.95d8		74 02		stz $02,x	                stz 2,x
.95da		74 03		stz $03,x	                stz 3,x
.95dc						_done:
.95dc		60		rts		z_um_star:      rts
.95dd						xt_unloop:
.95dd		a4 1f		ldy $1f		                ldy loopctrl
.95df		88		dey		                dey
.95e0		88		dey		                dey
.95e1		88		dey		                dey
.95e2		88		dey		                dey
.95e3		84 1f		sty $1f		                sty loopctrl
.95e5		30 05		bmi $95ec	                bmi z_unloop            ; no active loops?
.95e7		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.95ea		85 20		sta $20		                sta loopidx0
.95ec		60		rts		z_unloop:       rts
.95ed						xt_until:
.95ed		20 c6 97	jsr $97c6	                jsr cmpl_0branch_tos
.95f0		60		rts		z_until:        rts
.95f1						xt_unused:
.95f1		ca		dex		                dex
.95f2		ca		dex		                dex
.95f3		a9 00		lda #$00	                lda #<cp_end
.95f5		38		sec		                sec
.95f6		e5 00		sbc $00		                sbc cp
.95f8		95 00		sta $00,x	                sta 0,x
.95fa		a9 7c		lda #$7c	                lda #>cp_end
.95fc		e5 01		sbc $01		                sbc cp+1
.95fe		95 01		sta $01,x	                sta 1,x
.9600		60		rts		z_unused:       rts
.9601						xt_variable:
.9601		20 40 84	jsr $8440	                jsr xt_create
.9604		a9 00		lda #$00	                lda #0
.9606		92 00		sta ($00)	                sta (cp)
.9608		e6 00		inc $00		                inc cp
.960a		d0 02		bne $960e	                bne +
.960c		e6 01		inc $01		                inc cp+1
.960e						+
.960e		92 00		sta ($00)	                sta (cp)
.9610		e6 00		inc $00		                inc cp
.9612		d0 02		bne $9616	                bne +
.9614		e6 01		inc $01		                inc cp+1
.9616						+
.9616		20 08 84	jsr $8408	                jsr adjust_z
.9619		60		rts		z_variable:     rts
.961a						xt_while:
.961a		20 b1 97	jsr $97b1	                jsr cmpl_0branch_later          ; branch to location we'll determine later
.961d		20 3a 92	jsr $923a	                jsr xt_swap
.9620		60		rts		z_while:        rts
.9621						xt_within:
.9621		20 49 d8	jsr $d849	                jsr underflow_3
.9624		20 11 8d	jsr $8d11	                jsr xt_over
.9627		20 f6 8b	jsr $8bf6	                jsr xt_minus
.962a		20 78 93	jsr $9378	                jsr xt_to_r
.962d		20 f6 8b	jsr $8bf6	                jsr xt_minus
.9630		20 fc 8e	jsr $8efc	                jsr xt_r_from
.9633		20 3f 95	jsr $953f	                jsr xt_u_less_than
.9636		60		rts		z_within:       rts
.9637						xt_word:
.9637		20 3f d8	jsr $d83f	                jsr underflow_1
.963a		a4 10		ldy $10		                ldy toin                ; >IN
.963c						_loop:
.963c		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.963e		f0 09		beq $9649	                beq _found_char
.9640		b1 0c		lda ($0c),y	                lda (cib),y
.9642		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.9644		d0 03		bne $9649	                bne _found_char
.9646		c8		iny		                iny
.9647		80 f3		bra $963c	                bra _loop
.9649						_found_char:
.9649		84 10		sty $10		                sty toin
.964b		20 b8 8d	jsr $8db8	                jsr xt_parse            ; Returns ( addr u )
.964e		b5 00		lda $00,x	                lda 0,x
.9650		92 00		sta ($00)	                sta (cp)                ; Save length of string
.9652		48		pha		                pha                     ; Keep copy of length for later
.9653		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr u u )
.9656		a5 00		lda $00		                lda cp
.9658		18		clc		                clc
.9659		69 01		adc #$01	                adc #1
.965b		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.965d		a5 01		lda $01		                lda cp+1
.965f		69 00		adc #$00	                adc #0
.9661		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.9663		20 12 8c	jsr $8c12	                jsr xt_move
.9666		ca		dex		                dex
.9667		ca		dex		                dex
.9668		a5 00		lda $00		                lda cp
.966a		95 00		sta $00,x	                sta 0,x
.966c		a5 01		lda $01		                lda cp+1
.966e		95 01		sta $01,x	                sta 1,x
.9670		68		pla		                pla                     ; length of string
.9671		18		clc		                clc
.9672		65 00		adc $00		                adc cp
.9674		85 00		sta $00		                sta cp
.9676		90 02		bcc $967a	                bcc z_word
.9678		e6 01		inc $01		                inc cp+1
.967a		60		rts		z_word:         rts
.967b						xt_xor:
.967b		20 44 d8	jsr $d844	                jsr underflow_2
.967e		b5 00		lda $00,x	                lda 0,x
.9680		55 02		eor $02,x	                eor 2,x
.9682		95 02		sta $02,x	                sta 2,x
.9684		b5 01		lda $01,x	                lda 1,x
.9686		55 03		eor $03,x	                eor 3,x
.9688		95 03		sta $03,x	                sta 3,x
.968a		e8		inx		                inx
.968b		e8		inx		                inx
.968c		60		rts		z_xor:          rts
.968d						xt_zero_equal:
.968d		20 3f d8	jsr $d83f	                jsr underflow_1
.9690		b5 00		lda $00,x	                lda 0,x
.9692		15 01		ora $01,x	                ora 1,x
.9694		f0 02		beq $9698	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.9696		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.9698						_zero:
.9698		49 ff		eor #$ff	                eor #$FF        ; now just invert:
.969a		95 00		sta $00,x	                sta 0,x
.969c		95 01		sta $01,x	                sta 1,x
.969e		60		rts		z_zero_equal:   rts
.969f						xt_zero_greater:
.969f		20 3f d8	jsr $d83f	                jsr underflow_1
.96a2		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.96a4		b5 01		lda $01,x	                lda 1,x         ; MSB
.96a6		30 05		bmi $96ad	                bmi _done       ; TOS is negative, keep FLASE
.96a8		15 00		ora $00,x	                ora 0,x
.96aa		f0 01		beq $96ad	                beq _done       ; TOS is zero, keep FALSE
.96ac		88		dey		                dey             ; TOS is postive, make true
.96ad						_done:
.96ad		98		tya		                tya
.96ae		95 00		sta $00,x	                sta 0,x
.96b0		95 01		sta $01,x	                sta 1,x
.96b2		60		rts		z_zero_greater: rts
.96b3						xt_zero_less:
.96b3		20 3f d8	jsr $d83f	                jsr underflow_1
.96b6		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.96b8		b5 01		lda $01,x	                lda 1,x         ; MSB
.96ba		10 01		bpl $96bd	                bpl _done       ; TOS is positive, so keep FALSE
.96bc		88		dey		                dey             ; TOS is negative, make TRUE
.96bd						_done:
.96bd		98		tya		                tya
.96be		95 00		sta $00,x	                sta 0,x
.96c0		95 01		sta $01,x	                sta 1,x
.96c2		60		rts		z_zero_less:    rts
.96c3						xt_zero_unequal:
.96c3		20 3f d8	jsr $d83f	                jsr underflow_1
.96c6		b5 00		lda $00,x	                lda 0,x
.96c8		15 01		ora $01,x	                ora 1,x
.96ca		f0 02		beq $96ce	                beq _zero
.96cc		a9 ff		lda #$ff	                lda #$FF
.96ce						_zero:
.96ce		95 00		sta $00,x	                sta 0,x
.96d0		95 01		sta $01,x	                sta 1,x
.96d2		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/compile.asm

.96d3						xt_compile_comma:
.96d3		20 3f d8	jsr $d83f	                jsr underflow_1
.96d6		20 a0 86	jsr $86a0	                jsr xt_dup              ; keep an unadjusted copy of xt
.96d9		20 a0 86	jsr $86a0	                jsr xt_dup              ; plus one to convert to nt
.96dc		20 ad 9b	jsr $9bad	                jsr xt_int_to_name
.96df		b5 00		lda $00,x	                lda 0,x
.96e1		15 01		ora $01,x	                ora 1,x
.96e3		f0 6b		beq $9750	                beq cmpl_as_call        ; No nt so unknown size; must compile as a JSR
.96e5		20 a0 86	jsr $86a0	                jsr xt_dup
.96e8		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; status is at nt+1
.96eb		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.96ed		e8		inx		                inx                     ; drop pointer
.96ee		e8		inx		                inx
.96ef		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.96f1		29 08		and #$08	                and #NN
.96f3		d0 5b		bne $9750	                bne cmpl_as_call        ; never native
.96f5		20 d5 9d	jsr $9dd5	                jsr xt_wordsize
.96f8		a5 29		lda $29		                lda tmp3
.96fa		29 40		and #$40	                and #ST
.96fc		f0 16		beq $9714	                beq _check_uf
=10						_strip_sz = 10  ; skip the standard 10 byte header which saves return address + 1 to tmp1
.96fe		18		clc		                clc
.96ff		b5 02		lda $02,x	                lda 2,x
.9701		69 0a		adc #$0a	                adc #_strip_sz
.9703		95 02		sta $02,x	                sta 2,x
.9705		90 02		bcc $9709	                bcc +
.9707		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.9709						+
.9709		38		sec		                sec
.970a		b5 00		lda $00,x	                lda 0,x
.970c		e9 0a		sbc #$0a	                sbc #_strip_sz
.970e		95 00		sta $00,x	                sta 0,x
.9710		b0 02		bcs $9714	                bcs +
.9712		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.9714						+
.9714						_check_uf:
.9714		a5 29		lda $29		                lda tmp3
.9716		29 10		and #$10	                and #UF
.9718		f0 1f		beq $9739	                beq _check_limit
.971a		a0 02		ldy #$02	                ldy #uf_strip_offset
.971c		b1 08		lda ($08),y	                lda (up),y
.971e		c8		iny		                iny
.971f		11 08		ora ($08),y	                ora (up),y
.9721		f0 16		beq $9739	                beq _check_limit
.9723		18		clc		                clc
.9724		b5 02		lda $02,x	                lda 2,x
.9726		69 03		adc #$03	                adc #3
.9728		95 02		sta $02,x	                sta 2,x
.972a		90 02		bcc $972e	                bcc +
.972c		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.972e						+
.972e		38		sec		                sec
.972f		b5 00		lda $00,x	                lda 0,x
.9731		e9 03		sbc #$03	                sbc #3
.9733		95 00		sta $00,x	                sta 0,x
.9735		b0 02		bcs $9739	                bcs +
.9737		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.9739						+
.9739						_check_limit:
.9739		a5 29		lda $29		                lda tmp3
.973b		29 02		and #$02	                and #AN                 ; check Always Native (AN) bit
.973d		d0 21		bne $9760	                bne cmpl_inline         ; always natively compile
.973f						cmpl_by_limit:
.973f		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9741		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.9743		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.9745		90 19		bcc $9760	                bcc cmpl_inline         ; borrow (C=0) means size < limit
.9747		d0 07		bne $9750	                bne cmpl_as_call        ; else non-zero means size > limit
.9749		88		dey		                dey
.974a		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.974c		d5 00		cmp $00,x	                cmp 0,x
.974e		b0 10		bcs $9760	                bcs cmpl_inline         ; not bigger, so good to go
.9750						cmpl_as_call:
.9750		20 9a 86	jsr $869a	                jsr xt_drop
.9753		20 42 8c	jsr $8c42	                jsr xt_nip
.9756		a9 20		lda #$20	                lda #OpJSR
.9758		20 84 97	jsr $9784	                jsr cmpl_a
.975b		20 cd 83	jsr $83cd	                jsr xt_comma
.975e		38		sec		                sec
.975f		60		rts		                rts
.9760						cmpl_inline:
.9760		20 1b 89	jsr $891b	                jsr xt_here
.9763		20 3a 92	jsr $923a	                jsr xt_swap
.9766		20 a0 86	jsr $86a0	                jsr xt_dup
.9769		20 27 82	jsr $8227	                jsr xt_allot            ; allocate space for the word
.976c		20 12 8c	jsr $8c12	                jsr xt_move
.976f		20 9a 86	jsr $869a	                jsr xt_drop             ; drop original xt
.9772		18		clc		                clc
.9773						z_compile_comma:
.9773		60		rts		                rts
.9774						cmpl_subroutine:
.9774		48		pha		                pha             ; save LSB of address
.9775		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR
.9777		80 03		bra $977c	                bra +
.9779						cmpl_jump:
.9779		48		pha		                pha             ; save LSB of address
.977a		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP, fall thru
.977c						+
.977c		20 84 97	jsr $9784	                jsr cmpl_a      ; compile opcode
.977f		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.9780						cmpl_word:
.9780		20 84 97	jsr $9784	                jsr cmpl_a      ; compile LSB of address
.9783		98		tya		                tya             ; fall thru for MSB
.9784						cmpl_a:
.9784		92 00		sta ($00)	                sta (cp)
.9786		e6 00		inc $00		                inc cp
.9788		d0 02		bne $978c	                bne _done
.978a		e6 01		inc $01		                inc cp+1
.978c						_done:
.978c		60		rts		                rts
.978d						cmpl_jump_tos:
.978d		a9 4c		lda #$4c	                lda #OpJMP
.978f		20 84 97	jsr $9784	                jsr cmpl_a
.9792		4c cd 83	jmp $83cd	                jmp xt_comma
.9795						cmpl_jump_later:
.9795		a9 4c		lda #$4c	                lda #OpJMP
.9797		20 84 97	jsr $9784	                jsr cmpl_a
.979a		20 1b 89	jsr $891b	                jsr xt_here
.979d		80 e1		bra $9780	                bra cmpl_word
.979f						check_nc_limit:
.979f		48		pha		                pha
.97a0		38		sec		                sec
.97a1		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.97a3		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're good, leave with C=0
.97a5		f0 01		beq $97a8	                beq +
.97a7		18		clc		                clc
.97a8						+
.97a8		68		pla		                pla
.97a9		90 05		bcc $97b0	                bcc _done
.97ab		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.97ac		88		dey		                dey
.97ad		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.97af		1a		inc a		                ina                     ; restore A, preserves carry
.97b0						_done:
.97b0		60		rts		                rts
.97b1						cmpl_0branch_later:
.97b1		20 f6 9d	jsr $9df6	                jsr xt_zero             ; dummy placeholder, which forces long jmp in native version
.97b4		20 c6 97	jsr $97c6	                jsr cmpl_0branch_tos    ; generate native or subroutine branch code
.97b7		20 1b 89	jsr $891b	                jsr xt_here             ; either way the target address is two bytes before here
.97ba		38		sec		                sec
.97bb		b5 00		lda $00,x	                lda 0,x
.97bd		e9 02		sbc #$02	                sbc #2
.97bf		95 00		sta $00,x	                sta 0,x
.97c1		b0 02		bcs $97c5	                bcs +
.97c3		d6 01		dec $01,x	                dec 1,x
.97c5						+
.97c5		60		rts		                rts
.97c6						cmpl_0branch_tos:
.97c6		a9 0b		lda #$0b	                lda #ztest_runtime_size+5       ; typical size of inline form
.97c8		20 9f 97	jsr $979f	                jsr check_nc_limit              ; returns C=0 if we should native compile
.97cb		90 0a		bcc $97d7	                bcc _inline
.97cd		a0 98		ldy #$98	                ldy #>zero_branch_runtime
.97cf		a9 28		lda #$28	                lda #<zero_branch_runtime
.97d1		20 74 97	jsr $9774	                jsr cmpl_subroutine             ; call the 0branch runtime
.97d4		4c cd 83	jmp $83cd	                jmp xt_comma                    ; add the payload and return
.97d7						_inline:
.97d7		a0 00		ldy #$00	                ldy #0
.97d9						-
.97d9		b9 28 98	lda $9828,y	                lda ztest_runtime,y
.97dc		20 84 97	jsr $9784	                jsr cmpl_a
.97df		c8		iny		                iny
.97e0		c0 06		cpy #$06	                cpy #ztest_runtime_size
.97e2		d0 f5		bne $97d9	                bne -
.97e4		b5 00		lda $00,x	                lda 0,x
.97e6		15 01		ora $01,x	                ora 1,x
.97e8		f0 31		beq $981b	                beq _long               ; always use the long form if target is 0
.97ea		20 a0 86	jsr $86a0	                jsr xt_dup
.97ed		20 1b 89	jsr $891b	                jsr xt_here
.97f0		18		clc		                clc
.97f1		a9 02		lda #$02	                lda #2
.97f3		75 00		adc $00,x	                adc 0,x
.97f5		95 00		sta $00,x	                sta 0,x
.97f7		90 02		bcc $97fb	                bcc +
.97f9		f6 01		inc $01,x	                inc 1,x
.97fb						+
.97fb		20 f6 8b	jsr $8bf6	                jsr xt_minus
.97fe		e8		inx		                inx             ; pre-drop offset and use wraparound indexing to preserve flags
.97ff		e8		inx		                inx
.9800		b5 ff		lda $ff,x	                lda $ff,x
.9802		a8		tay		                tay             ; Y=MSB of offset
.9803		b5 fe		lda $fe,x	                lda $fe,x       ; A=LSB, setting N flag to bit 7
.9805		30 04		bmi $980b	                bmi _minus
.9807		c0 00		cpy #$00	                cpy #0          ; if LSB is positive we need MSB = 0
.9809		80 02		bra $980d	                bra +
.980b		c0 ff		cpy #$ff	_minus:         cpy #$ff        ; if LSB is negative we need MSB = ff
.980d		d0 0c		bne $981b	+               bne _long
.980f		a9 f0		lda #$f0	                lda #OpBEQ
.9811		20 84 97	jsr $9784	                jsr cmpl_a
.9814		b5 fe		lda $fe,x	                lda $fe,x
.9816		e8		inx		                inx             ; drop the original address we used to calc offset
.9817		e8		inx		                inx
.9818		4c 84 97	jmp $9784	                jmp cmpl_a
.981b						_long:
.981b		a9 d0		lda #$d0	                lda #OpBNE
.981d		20 84 97	jsr $9784	                jsr cmpl_a
.9820		a9 03		lda #$03	                lda #3
.9822		20 84 97	jsr $9784	                jsr cmpl_a
.9825		4c 8d 97	jmp $978d	                jmp cmpl_jump_tos
.9828						zero_branch_runtime:
.9828						ztest_runtime:
.9828		e8		inx		                inx
.9829		e8		inx		                inx
.982a		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.982c		15 ff		ora $ff,x	                ora $FF,x
=6						ztest_runtime_size = * - ztest_runtime
.982e						zbranch_runtime:
.982e		7a		ply		                ply
.982f		84 25		sty $25		                sty tmp1
.9831		7a		ply		                ply
.9832		84 26		sty $26		                sty tmp1+1
.9834		a8		tay		                tay             ; test if A = 0 which tells us whether to branch
.9835		f0 0d		beq $9844	                beq _branch
.9837		18		clc		                clc
.9838		a5 25		lda $25		                lda tmp1        ; LSB
.983a		69 03		adc #$03	                adc #3          ; skip two bytes plus the extra for jsr/rts behavior
.983c		85 25		sta $25		                sta tmp1
.983e		90 11		bcc $9851	                bcc _jmp
.9840		e6 26		inc $26		                inc tmp1+1
.9842		80 0d		bra $9851	                bra _jmp
.9844						_branch:
.9844		a0 01		ldy #$01	                ldy #1
.9846		b1 25		lda ($25),y	                lda (tmp1),y
.9848		48		pha		                pha                     ; stash the LSB until we've read the MSB too
.9849		c8		iny		                iny
.984a		b1 25		lda ($25),y	                lda (tmp1),y
.984c		85 26		sta $26		                sta tmp1+1              ; update tmp1 with our branch target
.984e		68		pla		                pla
.984f		85 25		sta $25		                sta tmp1
.9851						_jmp:
.9851		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.9854						xt_bye:
.9854		4c 26 f0	jmp $f026	                jmp kernel_bye
.9857						z_bye:
.9857						xt_dot_s:
.9857		20 52 85	jsr $8552	                jsr xt_depth    ; ( -- u )
.985a		a9 3c		lda #$3c	                lda #'<'
.985c		20 c5 86	jsr $86c5	                jsr emit_a
.985f		b5 00		lda $00,x	                lda 0,x
.9861		48		pha		                pha
.9862		ca		dex		                dex             ; DUP
.9863		ca		dex		                dex
.9864		95 00		sta $00,x	                sta 0,x
.9866		74 01		stz $01,x	                stz 1,x
.9868		20 ac d8	jsr $d8ac	                jsr print_u
.986b		a9 3e		lda #$3e	                lda #'>'
.986d		20 c5 86	jsr $86c5	                jsr emit_a
.9870		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.9872		20 c5 86	jsr $86c5	                jsr emit_a
.9875		e8		inx		                inx
.9876		e8		inx		                inx
.9877		e0 78		cpx #$78	                cpx #dsp0
.9879		f0 1e		beq $9899	                beq _done
.987b		7a		ply		                ply
.987c		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.987e		85 29		sta $29		                sta tmp3
.9880		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.9882						_loop:
.9882		ca		dex		                dex
.9883		ca		dex		                dex
.9884		b2 29		lda ($29)	                lda (tmp3)
.9886		95 01		sta $01,x	                sta 1,x
.9888		c6 29		dec $29		                dec tmp3
.988a		b2 29		lda ($29)	                lda (tmp3)
.988c		95 00		sta $00,x	                sta 0,x
.988e		c6 29		dec $29		                dec tmp3
.9890		5a		phy		                phy
.9891		20 30 86	jsr $8630	                jsr xt_dot
.9894		7a		ply		                ply
.9895		88		dey		                dey
.9896		d0 ea		bne $9882	                bne _loop
.9898		48		pha		                pha             ; dummy to balance stack
.9899						_done:
.9899		68		pla		                pla
.989a		60		rts		z_dot_s:        rts
.989b						xt_dump:
.989b		20 44 d8	jsr $d844	                jsr underflow_2
.989e						_row:
.989e		a0 10		ldy #$10	                ldy #16
.98a0		64 27		stz $27		                stz tmp2
.98a2		20 3a 84	jsr $843a	                jsr xt_cr
.98a5		b5 03		lda $03,x	                lda 3,x
.98a7		20 0a d7	jsr $d70a	                jsr byte_to_ascii
.98aa		b5 02		lda $02,x	                lda 2,x
.98ac		20 0a d7	jsr $d70a	                jsr byte_to_ascii
.98af		20 d7 91	jsr $91d7	                jsr xt_space
.98b2		20 d7 91	jsr $91d7	                jsr xt_space
.98b5						_loop:
.98b5		b5 00		lda $00,x	                lda 0,x
.98b7		15 01		ora $01,x	                ora 1,x
.98b9		f0 39		beq $98f4	                beq _all_printed
.98bb		a1 02		lda ($02,x)	                lda (2,x)
.98bd		48		pha		                pha                     ; byte_to_ascii destroys A
.98be		20 0a d7	jsr $d70a	                jsr byte_to_ascii
.98c1		20 d7 91	jsr $91d7	                jsr xt_space
.98c4		68		pla		                pla
.98c5		20 25 d8	jsr $d825	                jsr is_printable
.98c8		b0 02		bcs $98cc	                bcs _printable
.98ca		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.98cc						_printable:
.98cc		5a		phy		                phy                     ; save counter
.98cd		a4 27		ldy $27		                ldy tmp2
.98cf		91 00		sta ($00),y	                sta (cp),y
.98d1		e6 27		inc $27		                inc tmp2
.98d3		7a		ply		                ply
.98d4		c0 09		cpy #$09	                cpy #9
.98d6		d0 03		bne $98db	                bne _next_char
.98d8		20 d7 91	jsr $91d7	                jsr xt_space
.98db						_next_char:
.98db		f6 02		inc $02,x	                inc 2,x
.98dd		d0 02		bne $98e1	                bne _counter
.98df		f6 03		inc $03,x	                inc 3,x
.98e1						_counter:
.98e1		b5 00		lda $00,x	                lda 0,x
.98e3		d0 02		bne $98e7	                bne +
.98e5		d6 01		dec $01,x	                dec 1,x
.98e7						+
.98e7		d6 00		dec $00,x	                dec 0,x
.98e9		88		dey		                dey
.98ea		d0 c9		bne $98b5	                bne _loop               ; next byte
.98ec		20 d7 91	jsr $91d7	                jsr xt_space
.98ef		20 02 99	jsr $9902	                jsr dump_print_ascii
.98f2		80 aa		bra $989e	                bra _row                ; new row
.98f4						_all_printed:
.98f4		a5 27		lda $27		                lda tmp2
.98f6		f0 06		beq $98fe	                beq _done
.98f8		20 d7 91	jsr $91d7	                jsr xt_space
.98fb		20 02 99	jsr $9902	                jsr dump_print_ascii
.98fe						_done:
.98fe		20 b3 93	jsr $93b3	                jsr xt_two_drop         ; one byte less than 4x INX
.9901		60		rts		z_dump:         rts
.9902						dump_print_ascii:
.9902		a0 00		ldy #$00	                ldy #0
.9904						_ascii_loop:
.9904		b1 00		lda ($00),y	                lda (cp),y
.9906		20 c5 86	jsr $86c5	                jsr emit_a
.9909		c8		iny		                iny
.990a		c0 08		cpy #$08	                cpy #8
.990c		d0 03		bne $9911	                bne +
.990e		20 d7 91	jsr $91d7	                jsr xt_space
.9911						+
.9911		c6 27		dec $27		                dec tmp2
.9913		d0 ef		bne $9904	                bne _ascii_loop
.9915		60		rts		                rts
.9916						xt_question:
.9916		20 1a 88	jsr $881a	                jsr xt_fetch
.9919		20 30 86	jsr $8630	                jsr xt_dot
.991c		60		rts		z_question:     rts
.991d						xt_see:
.991d		20 5d 8d	jsr $8d5d	                jsr xt_parse_name       ; ( addr u )
.9920		20 ea 9a	jsr $9aea	                jsr xt_find_name        ; ( nt | 0 )
.9923		b5 00		lda $00,x	                lda 0,x
.9925		15 01		ora $01,x	                ora 1,x
.9927		d0 05		bne $992e	                bne +
.9929		a9 05		lda #$05	                lda #err_noname
.992b		4c 55 d8	jmp $d855	                jmp error
.992e						+
.992e		20 3a 84	jsr $843a	                jsr xt_cr
.9931		a5 18		lda $18		                lda base
.9933		48		pha		                pha
.9934		20 26 89	jsr $8926	                jsr xt_hex
.9937		a9 09		lda #$09	                lda #str_see_nt
.9939		20 7b d8	jsr $d87b	                jsr print_string_no_lf
.993c		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.993f		20 fb 94	jsr $94fb	                jsr xt_u_dot
.9942		20 d7 91	jsr $91d7	                jsr xt_space            ; ( nt )
.9945		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.9948		20 33 9c	jsr $9c33	                jsr xt_name_to_int      ; ( nt xt )
.994b		a9 0a		lda #$0a	                lda #str_see_xt
.994d		20 7b d8	jsr $d87b	                jsr print_string_no_lf
.9950		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt xt xt )
.9953		20 fb 94	jsr $94fb	                jsr xt_u_dot
.9956		20 3a 84	jsr $843a	                jsr xt_cr               ; ( nt xt )
.9959		a9 08		lda #$08	                lda #str_see_flags
.995b		20 7b d8	jsr $d87b	                jsr print_string_no_lf
.995e		20 11 8d	jsr $8d11	                jsr xt_over             ; ( nt xt nt )
.9961		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9964		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( nt xt flags )
.9967		b5 00		lda $00,x	                lda 0,x
.9969		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.996b						_flag_loop:
.996b		48		pha		                pha
.996c		29 01		and #$01	                and #%00000001
.996e		18		clc		                clc
.996f		69 30		adc #$30	                adc #'0'
.9971		20 c5 86	jsr $86c5	                jsr emit_a
.9974		20 d7 91	jsr $91d7	                jsr xt_space
.9977		68		pla		                pla
.9978		6a		ror a		                ror                     ; Next flag
.9979		88		dey		                dey
.997a		d0 ef		bne $996b	                bne _flag_loop
.997c		20 3a 84	jsr $843a	                jsr xt_cr
.997f		e8		inx		                inx
.9980		e8		inx		                inx                     ; ( nt xt )
.9981		a9 0b		lda #$0b	                lda #str_see_size
.9983		20 7b d8	jsr $d87b	                jsr print_string_no_lf
.9986		20 3a 92	jsr $923a	                jsr xt_swap             ; ( xt nt )
.9989		20 d5 9d	jsr $9dd5	                jsr xt_wordsize         ; ( xt u )
.998c		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.998f		20 0a 85	jsr $850a	                jsr xt_decimal
.9992		20 fb 94	jsr $94fb	                jsr xt_u_dot            ; ( xt u )
.9995		20 26 89	jsr $8926	                jsr xt_hex
.9998		20 3a 84	jsr $843a	                jsr xt_cr
.999b		20 bb 93	jsr $93bb	                jsr xt_two_dup          ; ( xt u xt u )
.999e		20 9b 98	jsr $989b	                jsr xt_dump
.99a1		20 3a 84	jsr $843a	                jsr xt_cr
.99a4		20 0a a2	jsr $a20a	                jsr xt_disasm
.99a7		68		pla		                pla
.99a8		85 18		sta $18		                sta base
.99aa		60		rts		z_see:          rts
.99ab						xt_words:
.99ab		20 3a 84	jsr $843a	                jsr xt_cr
.99ae		a9 00		lda #$00	                lda #0
.99b0		48		pha		                pha
.99b1		ca		dex		                dex                     ; Make room on the stack for
.99b2		ca		dex		                dex                     ; a dictionary pointer.
.99b3		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.99b5						_wordlist_loop:
.99b5		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.99b7		a5 29		lda $29		                lda tmp3
.99b9		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.99bb		d0 02		bne $99bf	                bne _have_wordlist
.99bd		80 45		bra $9a04	                bra _words_done
.99bf						_have_wordlist:
.99bf		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.99c0		69 23		adc #$23	                adc #search_order_offset
.99c2		a8		tay		                tay
.99c3		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.99c5		0a		asl a		                asl                     ; Turn offset into cells offset.
.99c6		18		clc		                clc
.99c7		69 0a		adc #$0a	                adc #wordlists_offset
.99c9		a8		tay		                tay
.99ca		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.99cc		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.99ce		c8		iny		                iny
.99cf		b1 08		lda ($08),y	                lda (up),y
.99d1		95 01		sta $01,x	                sta 1,x
.99d3						_loop:
.99d3		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.99d6		20 50 9c	jsr $9c50	                jsr xt_name_to_string   ; ( nt addr u )
.99d9		68		pla		                pla
.99da		18		clc		                clc
.99db		75 00		adc $00,x	                adc 0,x
.99dd		1a		inc a		                ina                     ; don't forget the space between words
.99de		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.99e0		90 06		bcc $99e8	                bcc +
.99e2		20 3a 84	jsr $843a	                jsr xt_cr
.99e5		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.99e7		1a		inc a		                ina                     ; with length of this word.
.99e8						+
.99e8		48		pha		                pha
.99e9		20 d0 94	jsr $94d0	                jsr xt_type             ; ( nt )
.99ec		a9 20		lda #$20	                lda #AscSP
.99ee		20 c5 86	jsr $86c5	                jsr emit_a
.99f1		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+
.99f4		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+
.99f7		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( nt+1 )
.99fa		b5 00		lda $00,x	                lda 0,x
.99fc		15 01		ora $01,x	                ora 1,x
.99fe		d0 d3		bne $99d3	                bne _loop
.9a00		e6 29		inc $29		                inc tmp3
.9a02		80 b1		bra $99b5	                bra _wordlist_loop
.9a04						_words_done:
.9a04		68		pla		                pla                     ; dump counter
.9a05		e8		inx		                inx
.9a06		e8		inx		                inx
.9a07		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.9a08						xt_allow_native:
.9a08		20 96 d7	jsr $d796	                jsr current_to_dp
.9a0b		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a0d		b1 02		lda ($02),y	                lda (dp),y
.9a0f		29 f5		and #$f5	                and #$FF-NN-AN  ; AN and NN flag is clear.
.9a11		91 02		sta ($02),y	                sta (dp),y
.9a13						z_allow_native:
.9a13		60		rts		                rts
.9a14						xt_always_native:
.9a14		20 96 d7	jsr $d796	                jsr current_to_dp
.9a17		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a19		b1 02		lda ($02),y	                lda (dp),y
.9a1b		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.9a1d		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9a1f		91 02		sta ($02),y	                sta (dp),y
.9a21						z_always_native:
.9a21		60		rts		                rts
.9a22						xt_bell:
.9a22		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.9a24		20 c5 86	jsr $86c5	                jsr emit_a
.9a27		60		rts		z_bell:         rts
.9a28						xt_bounds:
.9a28		20 44 d8	jsr $d844	                jsr underflow_2
.9a2b		18		clc		                clc
.9a2c		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9a2e		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9a30		75 02		adc $02,x	                adc 2,x
.9a32		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9a34		94 00		sty $00,x	                sty 0,x
.9a36		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9a38		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9a3a		75 03		adc $03,x	                adc 3,x
.9a3c		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9a3e		94 01		sty $01,x	                sty 1,x
.9a40		60		rts		z_bounds:       rts
.9a41						xt_cleave:
.9a41		20 44 d8	jsr $d844	                jsr underflow_2
.9a44		20 89 a0	jsr $a089	                jsr xt_minus_leading    ; -LEADING ( addr u )
.9a47		20 97 9b	jsr $9b97	                jsr xt_input_to_r       ; save old imput state
.9a4a		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9a4c		85 0e		sta $0e		                sta ciblen
.9a4e		b5 01		lda $01,x	                lda 1,x
.9a50		85 0f		sta $0f		                sta ciblen+1
.9a52		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9a54		85 0c		sta $0c		                sta cib
.9a56		b5 03		lda $03,x	                lda 3,x
.9a58		85 0d		sta $0d		                sta cib+1
.9a5a		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9a5c		64 11		stz $11		                stz toin+1
.9a5e		20 5d 8d	jsr $8d5d	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.9a61		b5 00		lda $00,x	                lda 0,x
.9a63		15 01		ora $01,x	                ora 1,x
.9a65		f0 23		beq $9a8a	                beq _done
.9a67		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9a69		38		sec		                sec
.9a6a		f5 00		sbc $00,x	                sbc 0,x
.9a6c		95 04		sta $04,x	                sta 4,x
.9a6e		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9a70		f5 01		sbc $01,x	                sbc 1,x
.9a72		95 05		sta $05,x	                sta 5,x
.9a74		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9a76		18		clc		                clc
.9a77		75 00		adc $00,x	                adc 0,x
.9a79		95 06		sta $06,x	                sta 6,x
.9a7b		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9a7d		75 01		adc $01,x	                adc 1,x
.9a7f		95 07		sta $07,x	                sta 7,x
.9a81		20 8c 94	jsr $948c	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.9a84		20 89 a0	jsr $a089	                jsr xt_minus_leading
.9a87		20 8c 94	jsr $948c	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.9a8a						_done:
.9a8a		20 a4 9d	jsr $9da4	                jsr xt_r_to_input
.9a8d		60		rts		z_cleave:       rts
.9a8e						xt_digit_question:
.9a8e		20 3f d8	jsr $d83f	                jsr underflow_1
.9a91		ca		dex		                dex
.9a92		ca		dex		                dex
.9a93		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9a95		74 01		stz $01,x	                stz 1,x
.9a97		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9a99		b5 02		lda $02,x	                lda 2,x
.9a9b		c9 30		cmp #$30	                cmp #'0'
.9a9d		90 23		bcc $9ac2	                bcc _done               ; failure flag already set
.9a9f		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9aa1		90 12		bcc $9ab5	                bcc _checkbase
.9aa3		c9 41		cmp #$41	                cmp #'A'
.9aa5		90 1b		bcc $9ac2	                bcc _done               ; failure flag is already set
.9aa7		c9 61		cmp #$61	                cmp #'a'
.9aa9		90 07		bcc $9ab2	                bcc _case_done          ; not lower case, too low
.9aab		c9 7b		cmp #$7b	                cmp #'z'+1
.9aad		b0 03		bcs $9ab2	                bcs _case_done          ; not lower case, too high
.9aaf		18		clc		                clc                     ; just right
.9ab0		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9ab2						_case_done:
.9ab2		38		sec		                sec
.9ab3		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9ab5						_checkbase:
.9ab5		38		sec		                sec
.9ab6		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9ab8		c5 18		cmp $18		                cmp base
.9aba		b0 06		bcs $9ac2	                bcs _done               ; already have false flag
.9abc		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9abe		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9ac0		d6 01		dec $01,x	                dec 1,x
.9ac2						_done:
.9ac2						z_digit_question:
.9ac2		60		rts		                rts
.9ac3						xt_execute_parsing:
.9ac3		20 49 d8	jsr $d849	                jsr underflow_3
.9ac6		20 97 9b	jsr $9b97	                jsr xt_input_to_r       ; save normal input for later
.9ac9		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; -ROT ( xt addr u )
.9acc		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9ace		85 0e		sta $0e		                sta ciblen
.9ad0		b5 01		lda $01,x	                lda 1,x
.9ad2		85 0f		sta $0f		                sta ciblen+1
.9ad4		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9ad6		85 0c		sta $0c		                sta cib
.9ad8		b5 03		lda $03,x	                lda 3,x
.9ada		85 0d		sta $0d		                sta cib+1
.9adc		64 10		stz $10		                stz toin                ; Set >IN to zero
.9ade		64 11		stz $11		                stz toin+1
.9ae0		20 b3 93	jsr $93b3	                jsr xt_two_drop         ; 2DROP ( xt )
.9ae3		20 05 88	jsr $8805	                jsr xt_execute
.9ae6		20 a4 9d	jsr $9da4	                jsr xt_r_to_input
.9ae9						z_execute_parsing:
.9ae9		60		rts		                rts
.9aea						xt_find_name:
.9aea		20 44 d8	jsr $d844	                jsr underflow_2
.9aed		b5 00		lda $00,x	                lda 0,x
.9aef		15 01		ora $01,x	                ora 1,x
.9af1		d0 03		bne $9af6	                bne _nonempty
.9af3		4c 27 9b	jmp $9b27	                jmp _fail_done
.9af6						_nonempty:
.9af6		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9af8						_wordlist_loop:
.9af8		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9afa		a5 29		lda $29		                lda tmp3
.9afc		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9afe		f0 27		beq $9b27	                beq _fail_done
.9b00		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9b01		69 23		adc #$23	                adc #search_order_offset
.9b03		a8		tay		                tay
.9b04		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9b06		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b07		18		clc		                clc
.9b08		69 0a		adc #$0a	                adc #wordlists_offset
.9b0a		a8		tay		                tay
.9b0b		b1 08		lda ($08),y	                lda (up),y
.9b0d		85 25		sta $25		                sta tmp1
.9b0f		c8		iny		                iny
.9b10		b1 08		lda ($08),y	                lda (up),y
.9b12		85 26		sta $26		                sta tmp1+1
.9b14		20 21 d7	jsr $d721	                jsr find_header_name
.9b17		d0 04		bne $9b1d	                bne _success
.9b19		e6 29		inc $29		                inc tmp3
.9b1b		80 db		bra $9af8	                bra _wordlist_loop
.9b1d						_success:
.9b1d		a5 25		lda $25		                lda tmp1
.9b1f		95 02		sta $02,x	                sta 2,x
.9b21		a5 26		lda $26		                lda tmp1+1
.9b23		95 03		sta $03,x	                sta 3,x
.9b25		80 04		bra $9b2b	                bra _done
.9b27						_fail_done:
.9b27		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b29		74 03		stz $03,x	                stz 3,x
.9b2b						_done:
.9b2b		e8		inx		                inx
.9b2c		e8		inx		                inx
.9b2d		60		rts		z_find_name:    rts
.9b2e						xt_havekey:
.9b2e		ca		dex		                dex
.9b2f		ca		dex		                dex
.9b30		a9 16		lda #$16	                lda #<havekey
.9b32		95 00		sta $00,x	                sta 0,x
.9b34		a9 00		lda #$00	                lda #>havekey
.9b36		95 01		sta $01,x	                sta 1,x
.9b38		60		rts		z_havekey:      rts
.9b39						xt_hexstore:
.9b39		20 49 d8	jsr $d849	                jsr underflow_3
.9b3c		20 a0 86	jsr $86a0	                jsr xt_dup              ; Save copy of original address
.9b3f		20 b0 94	jsr $94b0	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b42						_loop:
.9b42		b5 00		lda $00,x	                lda 0,x
.9b44		15 01		ora $01,x	                ora 1,x
.9b46		f0 36		beq $9b7e	                beq _done
.9b48		20 41 9a	jsr $9a41	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9b4b		20 b0 94	jsr $94b0	                jsr xt_two_to_r
.9b4e		20 f6 9d	jsr $9df6	                jsr xt_zero
.9b51		20 f6 9d	jsr $9df6	                jsr xt_zero
.9b54		20 36 94	jsr $9436	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9b57		20 d8 92	jsr $92d8	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9b5a		b5 00		lda $00,x	                lda 0,x
.9b5c		15 01		ora $01,x	                ora 1,x
.9b5e		d0 17		bne $9b77	                bne _have_chars_left
.9b60		20 b3 93	jsr $93b3	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9b63		20 3f 9e	jsr $9e3f	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9b66		20 e5 8e	jsr $8ee5	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9b69		20 37 83	jsr $8337	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b6c		20 fc 8e	jsr $8efc	                jsr xt_r_from           ; R>
.9b6f		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+
.9b72		20 78 93	jsr $9378	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9b75		80 cb		bra $9b42	                bra _loop
.9b77						_have_chars_left:
.9b77		8a		txa		                txa
.9b78		18		clc		                clc
.9b79		69 08		adc #$08	                adc #8
.9b7b		aa		tax		                tax
.9b7c		80 c4		bra $9b42	                bra _loop
.9b7e						_done:
.9b7e		e8		inx		                inx
.9b7f		e8		inx		                inx
.9b80		e8		inx		                inx
.9b81		e8		inx		                inx                     ; 2DROP
.9b82		20 36 94	jsr $9436	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9b85		20 3a 92	jsr $923a	                jsr xt_swap
.9b88		20 f6 8b	jsr $8bf6	                jsr xt_minus            ; ( n )
.9b8b		60		rts		z_hexstore:     rts
.9b8c						xt_input:
.9b8c		ca		dex		                dex
.9b8d		ca		dex		                dex
.9b8e		a9 14		lda #$14	                lda #<input
.9b90		95 00		sta $00,x	                sta 0,x
.9b92		a9 00		lda #$00	                lda #>input
.9b94		95 01		sta $01,x	                sta 1,x
.9b96		60		rts		z_input:        rts
.9b97						xt_input_to_r:
.9b97		68		pla		                pla
.9b98		85 25		sta $25		                sta tmp1
.9b9a		68		pla		                pla
.9b9b		85 26		sta $26		                sta tmp1+1
.9b9d		a0 07		ldy #$07	                ldy #7
.9b9f						_loop:
.9b9f		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9ba2		48		pha		                pha
.9ba3		88		dey		                dey
.9ba4		10 f9		bpl $9b9f	                bpl _loop
.9ba6		a5 26		lda $26		                lda tmp1+1
.9ba8		48		pha		                pha
.9ba9		a5 25		lda $25		                lda tmp1
.9bab		48		pha		                pha
.9bac		60		rts		z_input_to_r: 	rts
.9bad						xt_int_to_name:
.9bad		20 3f d8	jsr $d83f	                jsr underflow_1
.9bb0		ca		dex		                dex
.9bb1		ca		dex		                dex
.9bb2		74 00		stz $00,x	                stz 0,x
.9bb4		74 01		stz $01,x	                stz 1,x
.9bb6						_wordlist_loop:
.9bb6		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9bb8		0a		asl a		                asl                     ; Turn offset into cells offset.
.9bb9		18		clc		                clc
.9bba		69 0a		adc #$0a	                adc #wordlists_offset
.9bbc		a8		tay		                tay
.9bbd		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9bbf		85 27		sta $27		                sta tmp2                ; into tmp2
.9bc1		c8		iny		                iny
.9bc2		b1 08		lda ($08),y	                lda (up),y
.9bc4		85 28		sta $28		                sta tmp2+1
.9bc6		a5 27		lda $27		                lda tmp2
.9bc8		05 28		ora $28		                ora tmp2+1
.9bca		f0 36		beq $9c02	                beq _next_wordlist
.9bcc		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9bce		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9bd0		b5 03		lda $03,x	                lda 3,x
.9bd2		85 2a		sta $2a		                sta tmp3+1
.9bd4						_loop:
.9bd4		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9bd6		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9bd8		c5 29		cmp $29		                cmp tmp3
.9bda		d0 07		bne $9be3	                bne _no_match
.9bdc		c8		iny		                iny
.9bdd		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9bdf		c5 2a		cmp $2a		                cmp tmp3+1
.9be1		f0 30		beq $9c13	                beq _match
.9be3						_no_match:
.9be3		18		clc		                clc
.9be4		a5 27		lda $27		                lda tmp2
.9be6		69 02		adc #$02	                adc #2
.9be8		85 27		sta $27		                sta tmp2
.9bea		90 02		bcc $9bee	                bcc +
.9bec		e6 28		inc $28		                inc tmp2+1
.9bee						+
.9bee		a0 00		ldy #$00	                ldy #0
.9bf0		b1 27		lda ($27),y	                lda (tmp2),y
.9bf2		48		pha		                pha
.9bf3		c8		iny		                iny
.9bf4		11 27		ora ($27),y	                ora (tmp2),y
.9bf6		f0 09		beq $9c01	                beq _zero
.9bf8		b1 27		lda ($27),y	                lda (tmp2),y
.9bfa		85 28		sta $28		                sta tmp2+1
.9bfc		68		pla		                pla
.9bfd		85 27		sta $27		                sta tmp2
.9bff		80 d3		bra $9bd4	                bra _loop
.9c01						_zero:
.9c01		68		pla		                pla             ; Leftover from above loop
.9c02						_next_wordlist:
.9c02		b5 00		lda $00,x	                lda 0,x
.9c04		1a		inc a		                ina
.9c05		95 00		sta $00,x	                sta 0,x
.9c07		c9 0c		cmp #$0c	                cmp #max_wordlists
.9c09		d0 ab		bne $9bb6	                bne _wordlist_loop
.9c0b		e8		inx		                inx
.9c0c		e8		inx		                inx
.9c0d		74 00		stz $00,x	                stz 0,x
.9c0f		74 01		stz $01,x	                stz 1,x
.9c11		80 0a		bra $9c1d	                bra z_int_to_name
.9c13						_match:
.9c13		e8		inx		                inx
.9c14		e8		inx		                inx
.9c15		a5 27		lda $27		                lda tmp2
.9c17		95 00		sta $00,x	                sta 0,x
.9c19		a5 28		lda $28		                lda tmp2+1
.9c1b		95 01		sta $01,x	                sta 1,x
.9c1d		60		rts		z_int_to_name:  rts
.9c1e						xt_latestnt:
.9c1e		ca		dex		                dex
.9c1f		ca		dex		                dex
.9c20		20 96 d7	jsr $d796	                jsr current_to_dp
.9c23		a5 02		lda $02		                lda dp
.9c25		95 00		sta $00,x	                sta 0,x
.9c27		a5 03		lda $03		                lda dp+1
.9c29		95 01		sta $01,x	                sta 1,x
.9c2b		60		rts		z_latestnt:     rts
.9c2c						xt_latestxt:
.9c2c		20 1e 9c	jsr $9c1e	                jsr xt_latestnt         ; ( nt )
.9c2f		20 33 9c	jsr $9c33	                jsr xt_name_to_int      ; ( xt )
.9c32		60		rts		z_latestxt:     rts
.9c33						xt_name_to_int:
.9c33		20 3f d8	jsr $d83f	                jsr underflow_1
.9c36		b5 00		lda $00,x	                lda 0,x
.9c38		18		clc		                clc
.9c39		69 04		adc #$04	                adc #4
.9c3b		85 29		sta $29		                sta tmp3
.9c3d		b5 01		lda $01,x	                lda 1,x
.9c3f		90 01		bcc $9c42	                bcc _done
.9c41		1a		inc a		                ina
.9c42						_done:
.9c42		85 2a		sta $2a		                sta tmp3+1
.9c44		a0 00		ldy #$00	                ldy #0
.9c46		b1 29		lda ($29),y	                lda (tmp3),y
.9c48		95 00		sta $00,x	                sta 0,x
.9c4a		c8		iny		                iny
.9c4b		b1 29		lda ($29),y	                lda (tmp3),y
.9c4d		95 01		sta $01,x	                sta 1,x
.9c4f		60		rts		z_name_to_int:  rts
.9c50						xt_name_to_string:
.9c50		20 3f d8	jsr $d83f	                jsr underflow_1
.9c53		ca		dex		                dex
.9c54		ca		dex		                dex
.9c55		a1 02		lda ($02,x)	                lda (2,x)
.9c57		95 00		sta $00,x	                sta 0,x
.9c59		74 01		stz $01,x	                stz 1,x
.9c5b		b5 02		lda $02,x	                lda 2,x         ; LSB
.9c5d		18		clc		                clc
.9c5e		69 08		adc #$08	                adc #8
.9c60		95 02		sta $02,x	                sta 2,x
.9c62		90 02		bcc $9c66	                bcc z_name_to_string
.9c64		f6 03		inc $03,x	                inc 3,x         ; MSB
.9c66						z_name_to_string:
.9c66		60		rts		                rts
.9c67						xt_nc_limit:
.9c67		a9 00		lda #$00	                lda #nc_limit_offset
.9c69		4c fb d6	jmp $d6fb	                jmp push_upvar_tos
.9c6c						z_nc_limit:
.9c6c						xt_never_native:
.9c6c		20 96 d7	jsr $d796	                jsr current_to_dp
.9c6f		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9c71		b1 02		lda ($02),y	                lda (dp),y
.9c73		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9c75		29 fd		and #$fd	                and #$FF-AN     ; and AN flag is clear.
.9c77		91 02		sta ($02),y	                sta (dp),y
.9c79						z_never_native:
.9c79		60		rts		                rts
.9c7a						xt_not_rote:
.9c7a		20 49 d8	jsr $d849	                jsr underflow_3
.9c7d		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9c7f		b5 03		lda $03,x	                lda 3,x
.9c81		95 01		sta $01,x	                sta 1,x
.9c83		b5 05		lda $05,x	                lda 5,x
.9c85		95 03		sta $03,x	                sta 3,x
.9c87		94 05		sty $05,x	                sty 5,x
.9c89		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9c8b		b5 02		lda $02,x	                lda 2,x
.9c8d		95 00		sta $00,x	                sta 0,x
.9c8f		b5 04		lda $04,x	                lda 4,x
.9c91		95 02		sta $02,x	                sta 2,x
.9c93		94 04		sty $04,x	                sty 4,x
.9c95		60		rts		z_not_rote:     rts
.9c96						xt_number:
.9c96		20 44 d8	jsr $d844	                jsr underflow_2
.9c99		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9c9b		a5 18		lda $18		                lda base
.9c9d		48		pha		                pha
.9c9e		20 bb 93	jsr $93bb	                jsr xt_two_dup
.9ca1		a1 02		lda ($02,x)	                lda (2,x)
.9ca3		c9 23		cmp #$23	                cmp #'#'                ; decimal?
.9ca5		d0 04		bne $9cab	                bne _check_hex
.9ca7		a9 0a		lda #$0a	                lda #10
.9ca9		80 42		bra $9ced	                bra _base_changed
.9cab						_check_hex:
.9cab		c9 24		cmp #$24	                cmp #'$'
.9cad		d0 04		bne $9cb3	                bne _check_binary
.9caf		a9 10		lda #$10	                lda #16
.9cb1		80 3a		bra $9ced	                bra _base_changed
.9cb3						_check_binary:
.9cb3		c9 25		cmp #$25	                cmp #'%'
.9cb5		d0 04		bne $9cbb	                bne _check_char
.9cb7		a9 02		lda #$02	                lda #2
.9cb9		80 32		bra $9ced	                bra _base_changed
.9cbb						_check_char:
.9cbb		c9 27		cmp #$27	                cmp #"'"
.9cbd		d0 3a		bne $9cf9	                bne _check_minus
.9cbf		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9cc1		c9 03		cmp #$03	                cmp #3
.9cc3		d0 26		bne $9ceb	                bne _not_a_char
.9cc5		b5 01		lda $01,x	                lda 1,x
.9cc7		d0 22		bne $9ceb	                bne _not_a_char ; No compare needed to check for non-zero.
.9cc9		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9ccb		18		clc		                clc
.9ccc		69 02		adc #$02	                adc #2          ; length of string
.9cce		85 23		sta $23		                sta tmptos
.9cd0		b5 03		lda $03,x	                lda 3,x
.9cd2		69 00		adc #$00	                adc #0          ; only need carry
.9cd4		85 24		sta $24		                sta tmptos+1
.9cd6		b2 23		lda ($23)	                lda (tmptos)
.9cd8		c9 27		cmp #$27	                cmp #"'"
.9cda		d0 0f		bne $9ceb	                bne _not_a_char
.9cdc		f6 02		inc $02,x	                inc 2,x
.9cde		d0 02		bne $9ce2	                bne +
.9ce0		f6 03		inc $03,x	                inc 3,x
.9ce2						+
.9ce2		a1 02		lda ($02,x)	                lda (2,x)
.9ce4		95 02		sta $02,x	                sta 2,x
.9ce6		74 03		stz $03,x	                stz 3,x
.9ce8		4c 6b 9d	jmp $9d6b	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9ceb						_not_a_char:
.9ceb		80 5c		bra $9d49	                bra _number_error
.9ced						_base_changed:
.9ced		85 18		sta $18		                sta base        ; Switch to the new base
.9cef		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9cf1		d0 02		bne $9cf5	                bne +
.9cf3		f6 03		inc $03,x	                inc 3,x
.9cf5						+
.9cf5		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9cf7		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9cf9						_check_minus:
.9cf9		c9 2d		cmp #$2d	                cmp #'-'
.9cfb		d0 0c		bne $9d09	                bne _check_dot
.9cfd		a9 80		lda #$80	                lda #$80
.9cff		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9d01		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d03		d0 02		bne $9d07	                bne +
.9d05		f6 03		inc $03,x	                inc 3,x
.9d07						+
.9d07		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d09						_check_dot:
.9d09		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d0b		18		clc		                clc
.9d0c		75 00		adc $00,x	                adc 0,x         ; length of string
.9d0e		85 23		sta $23		                sta tmptos
.9d10		b5 03		lda $03,x	                lda 3,x
.9d12		69 00		adc #$00	                adc #0          ; only need carry
.9d14		85 24		sta $24		                sta tmptos+1
.9d16		a5 23		lda $23		                lda tmptos
.9d18		d0 02		bne $9d1c	                bne +
.9d1a		c6 24		dec $24		                dec tmptos+1
.9d1c						+
.9d1c		c6 23		dec $23		                dec tmptos
.9d1e		b2 23		lda ($23)	                lda (tmptos)
.9d20		c9 2e		cmp #$2e	                cmp #'.'
.9d22		d0 04		bne $9d28	                bne _main
.9d24		e6 1e		inc $1e		                inc tmpdsp
.9d26		d6 00		dec $00,x	                dec 0,x
.9d28						_main:
.9d28		ca		dex		                dex
.9d29		ca		dex		                dex
.9d2a		ca		dex		                dex
.9d2b		ca		dex		                dex
.9d2c		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9d2e		95 00		sta $00,x	                sta 0,x
.9d30		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9d32		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9d34		95 02		sta $02,x	                sta 2,x
.9d36		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9d38		95 03		sta $03,x	                sta 3,x
.9d3a		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9d3c		74 05		stz $05,x	                stz 5,x
.9d3e		74 06		stz $06,x	                stz 6,x
.9d40		74 07		stz $07,x	                stz 7,x
.9d42		20 d8 92	jsr $92d8	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9d45		b5 00		lda $00,x	                lda 0,x
.9d47		f0 1e		beq $9d67	                beq _all_converted
.9d49						_number_error:
.9d49		20 b3 93	jsr $93b3	                jsr xt_two_drop ; >NUMBER modified addr u
.9d4c		20 b3 93	jsr $93b3	                jsr xt_two_drop ; ud   (partially converted number)
.9d4f		a9 3e		lda #$3e	                lda #'>'
.9d51		20 c5 86	jsr $86c5	                jsr emit_a
.9d54		20 d0 94	jsr $94d0	                jsr xt_type
.9d57		a9 3c		lda #$3c	                lda #'<'
.9d59		20 c5 86	jsr $86c5	                jsr emit_a
.9d5c		20 d7 91	jsr $91d7	                jsr xt_space
.9d5f		68		pla		                pla
.9d60		85 18		sta $18		                sta base
.9d62		a9 08		lda #$08	                lda #err_syntax
.9d64		4c 55 d8	jmp $d855	                jmp error
.9d67						_all_converted:
.9d67		e8		inx		                inx ; Drop the current addr u
.9d68		e8		inx		                inx
.9d69		e8		inx		                inx
.9d6a		e8		inx		                inx
.9d6b						_drop_original_string:
.9d6b		20 8c 94	jsr $948c	                jsr xt_two_swap  ; Drop the original addr u
.9d6e		20 b3 93	jsr $93b3	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9d71		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9d73		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9d75		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9d76		f0 0a		beq $9d82	                beq _single
.9d78		98		tya		                tya
.9d79		04 1c		tsb $1c		                tsb status
.9d7b		90 0f		bcc $9d8c	                bcc _done       ; no minus, all done
.9d7d		20 64 9e	jsr $9e64	                jsr xt_dnegate
.9d80		80 0a		bra $9d8c	                bra _done
.9d82						_single:
.9d82		e8		inx		                inx
.9d83		e8		inx		                inx
.9d84		98		tya		                tya
.9d85		14 1c		trb $1c		                trb status
.9d87		90 03		bcc $9d8c	                bcc _done       ; no minus, all done
.9d89		20 31 8c	jsr $8c31	                jsr xt_negate
.9d8c						_done:
.9d8c		68		pla		                pla
.9d8d		85 18		sta $18		                sta base
.9d8f		60		rts		z_number:       rts
.9d90						xt_editor_wordlist:
.9d90						xt_one:
.9d90		ca		dex		                dex
.9d91		ca		dex		                dex
.9d92		a9 01		lda #$01	                lda #1
.9d94		95 00		sta $00,x	                sta 0,x
.9d96		74 01		stz $01,x	                stz 1,x
.9d98						z_editor_wordlist:
.9d98						z_one:
.9d98		60		rts		                rts
.9d99						xt_output:
.9d99		ca		dex		                dex
.9d9a		ca		dex		                dex
.9d9b		a9 12		lda #$12	                lda #<output
.9d9d		95 00		sta $00,x	                sta 0,x
.9d9f		a9 00		lda #$00	                lda #>output
.9da1		95 01		sta $01,x	                sta 1,x
.9da3		60		rts		z_output:       rts
.9da4						xt_r_to_input:
.9da4		68		pla		                pla
.9da5		85 25		sta $25		                sta tmp1
.9da7		68		pla		                pla
.9da8		85 26		sta $26		                sta tmp1+1
.9daa		a0 00		ldy #$00	                ldy #0
.9dac						_loop:
.9dac		68		pla		                pla
.9dad		99 0a 00	sta $000a,y	                sta insrc,y
.9db0		c8		iny		                iny
.9db1		c0 08		cpy #$08	                cpy #8
.9db3		d0 f7		bne $9dac	                bne _loop
.9db5		a5 26		lda $26		                lda tmp1+1
.9db7		48		pha		                pha
.9db8		a5 25		lda $25		                lda tmp1
.9dba		48		pha		                pha
.9dbb		60		rts		z_r_to_input: 	rts
.9dbc						xt_strip_underflow:
.9dbc		a9 02		lda #$02	                lda #uf_strip_offset
.9dbe		4c fb d6	jmp $d6fb	                jmp push_upvar_tos
.9dc1						z_strip_underflow:
.9dc1						xt_assembler_wordlist:
.9dc1						xt_two:
.9dc1		ca		dex		                dex
.9dc2		ca		dex		                dex
.9dc3		a9 02		lda #$02	                lda #2
.9dc5		95 00		sta $00,x	                sta 0,x
.9dc7		74 01		stz $01,x	                stz 1,x
.9dc9						z_assembler_wordlist:
.9dc9		60		rts		z_two:          rts
.9dca						xt_useraddr:
.9dca		ca		dex		                dex
.9dcb		ca		dex		                dex
.9dcc		a9 08		lda #$08	                lda #<up
.9dce		95 00		sta $00,x	                sta 0,x
.9dd0		a9 00		lda #$00	                lda #>up
.9dd2		95 01		sta $01,x	                sta 1,x
.9dd4		60		rts		z_useraddr:     rts
.9dd5						xt_wordsize:
.9dd5		20 3f d8	jsr $d83f	                jsr underflow_1
.9dd8		b5 00		lda $00,x	                lda 0,x
.9dda		85 25		sta $25		                sta tmp1
.9ddc		b5 01		lda $01,x	                lda 1,x
.9dde		85 26		sta $26		                sta tmp1+1
.9de0		a0 06		ldy #$06	                ldy #6
.9de2		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9de4		88		dey		                dey
.9de5		88		dey		                dey
.9de6		38		sec		                sec
.9de7		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9de9		95 00		sta $00,x	                sta 0,x
.9deb		a0 07		ldy #$07	                ldy #7
.9ded		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9def		88		dey		                dey
.9df0		88		dey		                dey
.9df1		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9df3		95 01		sta $01,x	                sta 1,x
.9df5		60		rts		z_wordsize:     rts
.9df6						xt_case:
.9df6						xt_false:
.9df6						xt_forth_wordlist:
.9df6						xt_zero:
.9df6		ca		dex		                dex             ; push
.9df7		ca		dex		                dex
.9df8		74 00		stz $00,x	                stz 0,x
.9dfa		74 01		stz $01,x	                stz 1,x
.9dfc						z_case:
.9dfc						z_false:
.9dfc						z_forth_wordlist:
.9dfc						z_zero:
.9dfc		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9dfd						xt_d_minus:
.9dfd		20 4e d8	jsr $d84e	                jsr underflow_4 ; two double numbers
.9e00		38		sec		                sec
.9e01		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9e03		f5 02		sbc $02,x	                sbc 2,x
.9e05		95 06		sta $06,x	                sta 6,x
.9e07		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9e09		f5 03		sbc $03,x	                sbc 3,x
.9e0b		95 07		sta $07,x	                sta 7,x
.9e0d		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9e0f		f5 00		sbc $00,x	                sbc 0,x
.9e11		95 04		sta $04,x	                sta 4,x
.9e13		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9e15		f5 01		sbc $01,x	                sbc 1,x
.9e17		95 05		sta $05,x	                sta 5,x
.9e19		e8		inx		                inx
.9e1a		e8		inx		                inx
.9e1b		e8		inx		                inx
.9e1c		e8		inx		                inx
.9e1d		60		rts		z_d_minus:      rts
.9e1e						xt_d_plus:
.9e1e		20 4e d8	jsr $d84e	                jsr underflow_4 ; two double numbers
.9e21		18		clc		                clc
.9e22		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9e24		75 06		adc $06,x	                adc 6,x
.9e26		95 06		sta $06,x	                sta 6,x
.9e28		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9e2a		75 07		adc $07,x	                adc 7,x
.9e2c		95 07		sta $07,x	                sta 7,x
.9e2e		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9e30		75 04		adc $04,x	                adc 4,x
.9e32		95 04		sta $04,x	                sta 4,x
.9e34		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9e36		75 05		adc $05,x	                adc 5,x
.9e38		95 05		sta $05,x	                sta 5,x
.9e3a		e8		inx		                inx
.9e3b		e8		inx		                inx
.9e3c		e8		inx		                inx
.9e3d		e8		inx		                inx
.9e3e		60		rts		z_d_plus:       rts
.9e3f						xt_d_to_s:
.9e3f		20 44 d8	jsr $d844	                jsr underflow_2
.9e42		e8		inx		                inx
.9e43		e8		inx		                inx
.9e44		60		rts		z_d_to_s:       rts
.9e45						xt_dabs:
.9e45		20 44 d8	jsr $d844	                jsr underflow_2 ; double number
.9e48		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9e4a		10 17		bpl $9e63	                bpl _done       ; positive, we get off light
.9e4c		a0 00		ldy #$00	                ldy #0
.9e4e		38		sec		                sec
.9e4f		98		tya		                tya
.9e50		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e52		95 02		sta $02,x	                sta 2,x
.9e54		98		tya		                tya
.9e55		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e57		95 03		sta $03,x	                sta 3,x
.9e59		98		tya		                tya
.9e5a		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e5c		95 00		sta $00,x	                sta 0,x
.9e5e		98		tya		                tya
.9e5f		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e61		95 01		sta $01,x	                sta 1,x
.9e63						_done:
.9e63		60		rts		z_dabs:         rts
.9e64						xt_dnegate:
.9e64		20 44 d8	jsr $d844	                jsr underflow_2 ; double number
.9e67		a0 00		ldy #$00	     		ldy #0
.9e69		38		sec		                sec
.9e6a		98		tya		                tya
.9e6b		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e6d		95 02		sta $02,x	                sta 2,x
.9e6f		98		tya		                tya
.9e70		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e72		95 03		sta $03,x	                sta 3,x
.9e74		98		tya		                tya
.9e75		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e77		95 00		sta $00,x	                sta 0,x
.9e79		98		tya		                tya
.9e7a		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9e7c		95 01		sta $01,x	                sta 1,x
.9e7e		60		rts		z_dnegate:      rts
.9e7f						xt_d_dot:
.9e7f		20 44 d8	jsr $d844	                jsr underflow_2
.9e82		20 99 93	jsr $9399	                jsr xt_tuck
.9e85		20 45 9e	jsr $9e45	                jsr xt_dabs
.9e88		20 e1 89	jsr $89e1	                jsr xt_less_number_sign
.9e8b		20 bf 8c	jsr $8cbf	                jsr xt_number_sign_s
.9e8e		20 9d 8f	jsr $8f9d	                jsr xt_rot
.9e91		20 5c 91	jsr $915c	                jsr xt_sign
.9e94		20 9d 8c	jsr $8c9d	                jsr xt_number_sign_greater
.9e97		20 d0 94	jsr $94d0	                jsr xt_type
.9e9a		20 d7 91	jsr $91d7	                jsr xt_space
.9e9d		60		rts		z_d_dot:        rts
.9e9e						xt_d_dot_r:
.9e9e		20 49 d8	jsr $d849	                jsr underflow_3
.9ea1		20 78 93	jsr $9378	                jsr xt_to_r
.9ea4		20 99 93	jsr $9399	                jsr xt_tuck
.9ea7		20 45 9e	jsr $9e45	                jsr xt_dabs
.9eaa		20 e1 89	jsr $89e1	                jsr xt_less_number_sign
.9ead		20 bf 8c	jsr $8cbf	                jsr xt_number_sign_s
.9eb0		20 9d 8f	jsr $8f9d	                jsr xt_rot
.9eb3		20 5c 91	jsr $915c	                jsr xt_sign
.9eb6		20 9d 8c	jsr $8c9d	                jsr xt_number_sign_greater
.9eb9		20 fc 8e	jsr $8efc	                jsr xt_r_from
.9ebc		20 11 8d	jsr $8d11	                jsr xt_over
.9ebf		20 f6 8b	jsr $8bf6	                jsr xt_minus
.9ec2		20 dd 91	jsr $91dd	                jsr xt_spaces
.9ec5		20 d0 94	jsr $94d0	                jsr xt_type
.9ec8		60		rts		z_d_dot_r:      rts
.9ec9						xt_m_star_slash:
.9ec9		20 4e d8	jsr $d84e	                jsr underflow_4
.9ecc		20 bb 93	jsr $93bb	                jsr xt_two_dup
.9ecf		20 7b 96	jsr $967b	                jsr xt_xor
.9ed2		20 3a 92	jsr $923a	                jsr xt_swap
.9ed5		20 cf 80	jsr $80cf	                jsr xt_abs
.9ed8		20 78 93	jsr $9378	                jsr xt_to_r
.9edb		20 3a 92	jsr $923a	                jsr xt_swap
.9ede		20 cf 80	jsr $80cf	                jsr xt_abs
.9ee1		20 78 93	jsr $9378	                jsr xt_to_r
.9ee4		20 11 8d	jsr $8d11	                jsr xt_over
.9ee7		20 7b 96	jsr $967b	                jsr xt_xor
.9eea		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; rot rot
.9eed		20 45 9e	jsr $9e45	                jsr xt_dabs
.9ef0		20 3a 92	jsr $923a	                jsr xt_swap
.9ef3		20 e5 8e	jsr $8ee5	                jsr xt_r_fetch
.9ef6		20 97 95	jsr $9597	                jsr xt_um_star
.9ef9		20 9d 8f	jsr $8f9d	                jsr xt_rot
.9efc		20 fc 8e	jsr $8efc	                jsr xt_r_from
.9eff		20 97 95	jsr $9597	                jsr xt_um_star
.9f02		20 9d 8f	jsr $8f9d	                jsr xt_rot
.9f05		20 f6 9d	jsr $9df6	                jsr xt_zero
.9f08		20 1e 9e	jsr $9e1e	                jsr xt_d_plus
.9f0b		20 e5 8e	jsr $8ee5	                jsr xt_r_fetch
.9f0e		20 55 95	jsr $9555	                jsr xt_um_slash_mod
.9f11		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; rot rot
.9f14		20 fc 8e	jsr $8efc	                jsr xt_r_from
.9f17		20 55 95	jsr $9555	                jsr xt_um_slash_mod
.9f1a		20 3a 92	jsr $923a	                jsr xt_swap
.9f1d		20 9a 86	jsr $869a	                jsr xt_drop
.9f20		20 3a 92	jsr $923a	                jsr xt_swap
.9f23		20 9d 8f	jsr $8f9d	                jsr xt_rot
.9f26		e8		inx		                inx                     ; drop TOS
.9f27		e8		inx		                inx
.9f28		b5 fe		lda $fe,x	                lda $fe,x               ; but keep MSB
.9f2a		10 03		bpl $9f2f	                bpl z_m_star_slash      ; ... 0< if ...
.9f2c		20 64 9e	jsr $9e64	                jsr xt_dnegate
.9f2f		60		rts		z_m_star_slash: rts
.9f30						xt_two_constant:
.9f30		20 44 d8	jsr $d844	                jsr underflow_2
.9f33		20 40 84	jsr $8440	                jsr xt_create
.9f36		20 3a 92	jsr $923a	                jsr xt_swap
.9f39		20 cd 83	jsr $83cd	                jsr xt_comma
.9f3c		20 cd 83	jsr $83cd	                jsr xt_comma
.9f3f		20 fe 85	jsr $85fe	                jsr does_runtime    ; does> turns into these two routines.
.9f42		20 d4 d6	jsr $d6d4	                jsr dodoes
.9f45		20 a0 86	jsr $86a0	                jsr xt_dup
.9f48		20 1a 88	jsr $881a	                jsr xt_fetch
.9f4b		20 3a 92	jsr $923a	                jsr xt_swap
.9f4e		20 43 83	jsr $8343	                jsr xt_cell_plus
.9f51		20 1a 88	jsr $881a	                jsr xt_fetch
.9f54		60		rts		z_two_constant: rts
.9f55						xt_two_literal:
.9f55		20 44 d8	jsr $d844	                jsr underflow_2 ; double number
.9f58		a9 0a		lda #$0a	                lda #template_push_tos_size
.9f5a		0a		asl a		                asl
.9f5b		20 9f 97	jsr $979f	                jsr check_nc_limit
.9f5e		b0 09		bcs $9f69	                bcs _no_inline
.9f60		20 3a 92	jsr $923a	                jsr xt_swap
.9f63		20 04 8a	jsr $8a04	                jsr xt_literal
.9f66		4c 04 8a	jmp $8a04	                jmp xt_literal
.9f69						_no_inline:
.9f69		20 c8 a1	jsr $a1c8	                jsr cmpl_two_literal
.9f6c		60		rts		z_two_literal:  rts
.9f6d						xt_two_variable:
.9f6d		20 40 84	jsr $8440	                jsr xt_create
.9f70		ca		dex		                dex
.9f71		ca		dex		                dex
.9f72		a9 04		lda #$04	                lda #4
.9f74		95 00		sta $00,x	                sta 0,x
.9f76		74 01		stz $01,x	                stz 1,x
.9f78		20 27 82	jsr $8227	                jsr xt_allot
.9f7b		60		rts		z_two_variable: rts
.9f7c						xt_ud_dot:
.9f7c		20 44 d8	jsr $d844	                jsr underflow_2 ; double number
.9f7f		20 e1 89	jsr $89e1	                jsr xt_less_number_sign
.9f82		20 bf 8c	jsr $8cbf	                jsr xt_number_sign_s
.9f85		20 9d 8c	jsr $8c9d	                jsr xt_number_sign_greater
.9f88		20 d0 94	jsr $94d0	                jsr xt_type
.9f8b		20 d7 91	jsr $91d7	                jsr xt_space
.9f8e		60		rts		z_ud_dot:        rts
.9f8f						xt_ud_dot_r:
.9f8f		20 49 d8	jsr $d849	                jsr underflow_3
.9f92		20 78 93	jsr $9378	                jsr xt_to_r
.9f95		20 e1 89	jsr $89e1	                jsr xt_less_number_sign
.9f98		20 bf 8c	jsr $8cbf	                jsr xt_number_sign_s
.9f9b		20 9d 8c	jsr $8c9d	                jsr xt_number_sign_greater
.9f9e		20 fc 8e	jsr $8efc	                jsr xt_r_from
.9fa1		20 11 8d	jsr $8d11	                jsr xt_over
.9fa4		20 f6 8b	jsr $8bf6	                jsr xt_minus
.9fa7		20 dd 91	jsr $91dd	                jsr xt_spaces
.9faa		20 d0 94	jsr $94d0	                jsr xt_type
.9fad		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.9fae						xt_cmove:
.9fae		20 49 d8	jsr $d849	                jsr underflow_3
.9fb1		b5 02		lda $02,x	                lda 2,x
.9fb3		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9fb5		b5 03		lda $03,x	                lda 3,x
.9fb7		85 28		sta $28		                sta tmp2+1
.9fb9		b5 04		lda $04,x	                lda 4,x
.9fbb		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9fbd		b5 05		lda $05,x	                lda 5,x
.9fbf		85 26		sta $26		                sta tmp1+1
.9fc1		a0 00		ldy #$00	                ldy #0
.9fc3		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.9fc5		f0 0f		beq $9fd6	                beq _dopartial
.9fc7						_page:
.9fc7		b1 25		lda ($25),y	                lda (tmp1),y
.9fc9		91 27		sta ($27),y	                sta (tmp2),y
.9fcb		c8		iny		                iny
.9fcc		d0 f9		bne $9fc7	                bne _page
.9fce		e6 26		inc $26		                inc tmp1+1
.9fd0		e6 28		inc $28		                inc tmp2+1
.9fd2		d6 01		dec $01,x	                dec 1,x
.9fd4		d0 f1		bne $9fc7	                bne _page
.9fd6						_dopartial:
.9fd6		b5 00		lda $00,x	                lda 0,x         ; length of last page
.9fd8		f0 09		beq $9fe3	                beq _done
.9fda						_partial:
.9fda		b1 25		lda ($25),y	                lda (tmp1),y
.9fdc		91 27		sta ($27),y	                sta (tmp2),y
.9fde		c8		iny		                iny
.9fdf		d6 00		dec $00,x	                dec 0,x
.9fe1		d0 f7		bne $9fda	                bne _partial
.9fe3						_done:
.9fe3		8a		txa		                txa
.9fe4		18		clc		                clc
.9fe5		69 06		adc #$06	                adc #6
.9fe7		aa		tax		                tax
.9fe8		60		rts		z_cmove:        rts
.9fe9						xt_cmove_up:
.9fe9		20 49 d8	jsr $d849	                jsr underflow_3
.9fec		b5 02		lda $02,x	                lda 2,x
.9fee		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9ff0		b5 03		lda $03,x	                lda 3,x
.9ff2		18		clc		                clc
.9ff3		75 01		adc $01,x	                adc 1,x
.9ff5		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.9ff7		b5 04		lda $04,x	                lda 4,x
.9ff9		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9ffb		b5 05		lda $05,x	                lda 5,x
.9ffd		18		clc		                clc
.9ffe		75 01		adc $01,x	                adc 1,x
.a000		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.a002		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.a004		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.a006		f0 0e		beq $a016	                beq _nopartial
.a008						_outerloop:
.a008		88		dey		                dey
.a009		f0 07		beq $a012	                beq _finishpage
.a00b						_innerloop:
.a00b		b1 25		lda ($25),y	                lda (tmp1),y
.a00d		91 27		sta ($27),y	                sta (tmp2),y
.a00f		88		dey		                dey
.a010		d0 f9		bne $a00b	                bne _innerloop
.a012						_finishpage:
.a012		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.a014		92 27		sta ($27)	                sta (tmp2)
.a016						_nopartial:
.a016		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.a018		c6 28		dec $28		                dec tmp2+1
.a01a		d6 01		dec $01,x	                dec 1,x
.a01c		d0 ea		bne $a008	                bne _outerloop
.a01e		8a		txa		                txa
.a01f		18		clc		                clc
.a020		69 06		adc #$06	                adc #6
.a022		aa		tax		                tax
.a023		60		rts		z_cmove_up:     rts
.a024						xt_compare:
.a024		20 4e d8	jsr $d84e	                jsr underflow_4
.a027		b5 02		lda $02,x	                lda 2,x
.a029		85 27		sta $27		                sta tmp2
.a02b		b5 03		lda $03,x	                lda 3,x
.a02d		85 28		sta $28		                sta tmp2+1
.a02f		b5 06		lda $06,x	                lda 6,x
.a031		85 25		sta $25		                sta tmp1
.a033		b5 07		lda $07,x	                lda 7,x
.a035		85 26		sta $26		                sta tmp1+1
.a037						_compare_loop:
.a037		b5 04		lda $04,x	                lda 4,x
.a039		15 05		ora $05,x	                ora 5,x
.a03b		f0 2c		beq $a069	                beq _str1_done
.a03d		b5 00		lda $00,x	                lda 0,x
.a03f		15 01		ora $01,x	                ora 1,x
.a041		f0 3a		beq $a07d	                beq _greater    ; Str2 empty first
.a043		b2 25		lda ($25)	                lda (tmp1)
.a045		d2 27		cmp ($27)	                cmp (tmp2)
.a047		90 26		bcc $a06f	                bcc _less
.a049		d0 32		bne $a07d	                bne _greater
.a04b		e6 25		inc $25		                inc tmp1
.a04d		d0 02		bne $a051	                bne +
.a04f		e6 26		inc $26		                inc tmp1+1
.a051						+
.a051		e6 27		inc $27		                inc tmp2
.a053		d0 02		bne $a057	                bne +
.a055		e6 28		inc $28		                inc tmp2+1
.a057						+
.a057		b5 04		lda $04,x	                lda 4,x
.a059		d0 02		bne $a05d	                bne +
.a05b		d6 05		dec $05,x	                dec 5,x
.a05d						+
.a05d		d6 04		dec $04,x	                dec 4,x
.a05f		b5 00		lda $00,x	                lda 0,x
.a061		d0 02		bne $a065	                bne +
.a063		d6 01		dec $01,x	                dec 1,x
.a065						+
.a065		d6 00		dec $00,x	                dec 0,x
.a067		80 ce		bra $a037	                bra _compare_loop
.a069						_str1_done:
.a069		b5 00		lda $00,x	                lda 0,x
.a06b		15 01		ora $01,x	                ora 1,x
.a06d		f0 08		beq $a077	                beq _equal      ; Both out of letters
.a06f						_less:
.a06f		a9 ff		lda #$ff	                lda #$FF
.a071		95 06		sta $06,x	                sta 6,x
.a073		95 07		sta $07,x	                sta 7,x
.a075		80 0c		bra $a083	                bra _done
.a077						_equal:
.a077		74 06		stz $06,x	                stz 6,x
.a079		74 07		stz $07,x	                stz 7,x
.a07b		80 06		bra $a083	                bra _done
.a07d						_greater:
.a07d		a9 01		lda #$01	                lda #1
.a07f		95 06		sta $06,x	                sta 6,x
.a081		74 07		stz $07,x	                stz 7,x
.a083						_done:
.a083		8a		txa		                txa
.a084		18		clc		                clc
.a085		69 06		adc #$06	                adc #6
.a087		aa		tax		                tax
.a088		60		rts		z_compare:      rts
.a089						xt_minus_leading:
.a089		20 44 d8	jsr $d844	                jsr underflow_2
.a08c						_loop:
.a08c		b5 00		lda $00,x	                lda 0,x
.a08e		15 01		ora $01,x	                ora 1,x
.a090		f0 0f		beq $a0a1	                beq _done
.a092		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a094		20 32 d8	jsr $d832	                jsr is_whitespace
.a097		90 08		bcc $a0a1	                bcc _done
.a099		20 90 9d	jsr $9d90	                jsr xt_one              ; ( addr u 1 )
.a09c		20 7e a1	jsr $a17e	                jsr xt_slash_string     ; ( addr+ u-1 )
.a09f		80 eb		bra $a08c	                bra _loop
.a0a1						_done:
.a0a1						z_minus_leading:
.a0a1		60		rts		                rts
.a0a2						xt_minus_trailing:
.a0a2		20 44 d8	jsr $d844	                jsr underflow_2
.a0a5		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a0a7		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a0a9		f0 33		beq $a0de	                beq _done
.a0ab		18		clc		                clc
.a0ac		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a0ae		75 00		adc $00,x	                adc 0,x
.a0b0		85 25		sta $25		                sta tmp1
.a0b2		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a0b4		75 01		adc $01,x	                adc 1,x
.a0b6		85 26		sta $26		                sta tmp1+1
.a0b8		a5 25		lda $25		                lda tmp1
.a0ba		d0 02		bne $a0be	                bne +
.a0bc		c6 26		dec $26		                dec tmp1+1
.a0be						+
.a0be		c6 25		dec $25		                dec tmp1
.a0c0						_loop:
.a0c0		b2 25		lda ($25)	                lda (tmp1)
.a0c2		c9 20		cmp #$20	                cmp #AscSP
.a0c4		d0 18		bne $a0de	                bne _done
.a0c6		a5 25		lda $25		                lda tmp1
.a0c8		d0 02		bne $a0cc	                bne +
.a0ca		c6 26		dec $26		                dec tmp1+1
.a0cc						+
.a0cc		c6 25		dec $25		                dec tmp1
.a0ce		b5 00		lda $00,x	                lda 0,x
.a0d0		d0 02		bne $a0d4	                bne +
.a0d2		d6 01		dec $01,x	                dec 1,x
.a0d4						+
.a0d4		d6 00		dec $00,x	                dec 0,x
.a0d6		b5 00		lda $00,x	                lda 0,x
.a0d8		15 01		ora $01,x	                ora 1,x
.a0da		f0 02		beq $a0de	                beq _done       ; Count has reached zero - we're done!
.a0dc		80 e2		bra $a0c0	                bra _loop
.a0de						_done:
.a0de						z_minus_trailing:
.a0de		60		rts		                rts
.a0df						xt_search:
.a0df		20 4e d8	jsr $d84e	                jsr underflow_4
.a0e2		b5 00		lda $00,x	                lda 0,x
.a0e4		15 01		ora $01,x	                ora 1,x
.a0e6		d0 0b		bne $a0f3	                bne _start_search
.a0e8		e8		inx		                inx             ; Remove u2
.a0e9		e8		inx		                inx
.a0ea		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a0ec		95 00		sta $00,x	                sta 0,x
.a0ee		95 01		sta $01,x	                sta 1,x
.a0f0		4c 7d a1	jmp $a17d	                jmp z_search
.a0f3						_start_search:
.a0f3		20 f6 9d	jsr $9df6	                jsr xt_zero
.a0f6						_search_loop:
.a0f6		18		clc		                clc
.a0f7		b5 00		lda $00,x	                lda 0,x
.a0f9		75 02		adc $02,x	                adc 2,x
.a0fb		85 25		sta $25		                sta tmp1
.a0fd		b5 01		lda $01,x	                lda 1,x
.a0ff		75 03		adc $03,x	                adc 3,x
.a101		d5 07		cmp $07,x	                cmp 7,x
.a103		90 12		bcc $a117	                bcc _init_comparison ; Obviously less
.a105		d0 06		bne $a10d	                bne _not_found
.a107		b5 06		lda $06,x	                lda 6,x
.a109		c5 25		cmp $25		                cmp tmp1
.a10b		b0 0a		bcs $a117	                bcs _init_comparison
.a10d						_not_found:
.a10d		e8		inx		                inx             ; Remove offset
.a10e		e8		inx		                inx
.a10f		e8		inx		                inx             ; Remove u2
.a110		e8		inx		                inx
.a111		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a113		74 01		stz $01,x	                stz 1,x
.a115		80 66		bra $a17d	                bra z_search
.a117						_init_comparison:
.a117		18		clc		                clc
.a118		b5 08		lda $08,x	                lda 8,x
.a11a		75 00		adc $00,x	                adc 0,x
.a11c		85 25		sta $25		                sta tmp1
.a11e		b5 09		lda $09,x	                lda 9,x
.a120		75 01		adc $01,x	                adc 1,x
.a122		85 26		sta $26		                sta tmp1+1
.a124		b5 04		lda $04,x	                lda 4,x
.a126		85 27		sta $27		                sta tmp2
.a128		b5 05		lda $05,x	                lda 5,x
.a12a		85 28		sta $28		                sta tmp2+1
.a12c		b5 02		lda $02,x	                lda 2,x
.a12e		85 29		sta $29		                sta tmp3
.a130		b5 03		lda $03,x	                lda 3,x
.a132		85 2a		sta $2a		                sta tmp3+1
.a134						_comparison_loop:
.a134		b2 25		lda ($25)	                lda (tmp1)
.a136		d2 27		cmp ($27)	                cmp (tmp2)
.a138		f0 05		beq $a13f	                beq _letters_match
.a13a		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.a13d		80 b7		bra $a0f6	                bra _search_loop
.a13f						_letters_match:
.a13f		e6 25		inc $25		                inc tmp1
.a141		d0 02		bne $a145	                bne +
.a143		e6 26		inc $26		                inc tmp1+1
.a145						+
.a145		e6 27		inc $27		                inc tmp2
.a147		d0 02		bne $a14b	                bne +
.a149		e6 28		inc $28		                inc tmp2+1
.a14b						+
.a14b		a5 29		lda $29		                lda tmp3
.a14d		d0 02		bne $a151	                bne +
.a14f		c6 2a		dec $2a		                dec tmp3+1
.a151						+
.a151		c6 29		dec $29		                dec tmp3
.a153		a5 29		lda $29		                lda tmp3
.a155		05 2a		ora $2a		                ora tmp3+1
.a157		d0 db		bne $a134	                bne _comparison_loop ; Check the next letter
.a159		18		clc		                clc
.a15a		b5 00		lda $00,x	                lda 0,x
.a15c		75 08		adc $08,x	                adc 8,x
.a15e		95 08		sta $08,x	                sta 8,x
.a160		b5 01		lda $01,x	                lda 1,x
.a162		75 09		adc $09,x	                adc 9,x
.a164		95 09		sta $09,x	                sta 9,x
.a166		38		sec		                sec
.a167		b5 06		lda $06,x	                lda 6,x
.a169		f5 00		sbc $00,x	                sbc 0,x
.a16b		95 06		sta $06,x	                sta 6,x
.a16d		b5 07		lda $07,x	                lda 7,x
.a16f		f5 01		sbc $01,x	                sbc 1,x
.a171		95 07		sta $07,x	                sta 7,x
.a173		e8		inx		                inx             ; drop offset
.a174		e8		inx		                inx
.a175		e8		inx		                inx             ; drop u2
.a176		e8		inx		                inx
.a177		a9 ff		lda #$ff	                lda #$FF
.a179		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a17b		95 01		sta $01,x	                sta 1,x
.a17d		60		rts		z_search:       rts
.a17e						xt_slash_string:
.a17e		20 49 d8	jsr $d849	                jsr underflow_3
.a181		18		clc		                clc             ; 3OS+TOS
.a182		b5 00		lda $00,x	                lda 0,x
.a184		75 04		adc $04,x	                adc 4,x
.a186		95 04		sta $04,x	                sta 4,x
.a188		b5 01		lda $01,x	                lda 1,x
.a18a		75 05		adc $05,x	                adc 5,x
.a18c		95 05		sta $05,x	                sta 5,x
.a18e		38		sec		                sec             ; NOS-TOS
.a18f		b5 02		lda $02,x	                lda 2,x
.a191		f5 00		sbc $00,x	                sbc 0,x
.a193		95 02		sta $02,x	                sta 2,x
.a195		b5 03		lda $03,x	                lda 3,x
.a197		f5 01		sbc $01,x	                sbc 1,x
.a199		95 03		sta $03,x	                sta 3,x
.a19b		e8		inx		                inx
.a19c		e8		inx		                inx
.a19d		60		rts		z_slash_string: rts
.a19e						xt_sliteral:
.a19e		20 44 d8	jsr $d844	                jsr underflow_2
.a1a1		20 95 97	jsr $9795	                jsr cmpl_jump_later
.a1a4		20 78 93	jsr $9378	                jsr xt_to_r
.a1a7		20 1b 89	jsr $891b	                jsr xt_here
.a1aa		20 3a 92	jsr $923a	                jsr xt_swap
.a1ad		20 a0 86	jsr $86a0	                jsr xt_dup
.a1b0		20 27 82	jsr $8227	                jsr xt_allot            ; reserve u bytes for string
.a1b3		20 1b 89	jsr $891b	                jsr xt_here
.a1b6		20 fc 8e	jsr $8efc	                jsr xt_r_from
.a1b9		20 24 92	jsr $9224	                jsr xt_store            ; point jmp past string
.a1bc		20 bb 93	jsr $93bb	                jsr xt_two_dup
.a1bf		20 b0 94	jsr $94b0	                jsr xt_two_to_r
.a1c2		20 12 8c	jsr $8c12	                jsr xt_move             ; copy u bytes from addr -> addr'
.a1c5		20 36 94	jsr $9436	                jsr xt_two_r_from
.a1c8						cmpl_sliteral:
.a1c8						cmpl_two_literal:
.a1c8		a0 a1		ldy #$a1	                ldy #>sliteral_runtime
.a1ca		a9 e2		lda #$e2	                lda #<sliteral_runtime
.a1cc		20 74 97	jsr $9774	                jsr cmpl_subroutine
.a1cf		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a1d1		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a1d3		20 80 97	jsr $9780	                jsr cmpl_word
.a1d6		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a1d8		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a1da		20 80 97	jsr $9780	                jsr cmpl_word
.a1dd		e8		inx		                inx
.a1de		e8		inx		                inx
.a1df		e8		inx		                inx
.a1e0		e8		inx		                inx
.a1e1		60		rts		z_sliteral:     rts
.a1e2						sliteral_runtime:
.a1e2		ca		dex		                dex
.a1e3		ca		dex		                dex
.a1e4		ca		dex		                dex
.a1e5		ca		dex		                dex
.a1e6		68		pla		                pla
.a1e7		85 25		sta $25		                sta tmp1        ; LSB of address
.a1e9		7a		ply		                ply
.a1ea		84 26		sty $26		                sty tmp1+1      ; MSB of address
.a1ec		18		clc		                clc
.a1ed		69 04		adc #$04	                adc #4
.a1ef		90 01		bcc $a1f2	                bcc +
.a1f1		c8		iny		                iny
.a1f2						+
.a1f2		5a		phy		                phy
.a1f3		48		pha		                pha
.a1f4		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a1f6		b1 25		lda ($25),y	                lda (tmp1),y
.a1f8		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a1fa		c8		iny		                iny
.a1fb		b1 25		lda ($25),y	                lda (tmp1),y
.a1fd		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a1ff		c8		iny		                iny
.a200		b1 25		lda ($25),y	                lda (tmp1),y
.a202		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a204		c8		iny		                iny
.a205		b1 25		lda ($25),y	                lda (tmp1),y
.a207		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a209		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a20a						xt_disasm:
.a20a		20 44 d8	jsr $d844	                jsr underflow_2
.a20d		20 11 a2	jsr $a211	                jsr disassembler
.a210		60		rts		z_disasm:       rts
.a211						disassembler:
.a211		64 32		stz $32		                stz scratch+5   ; flag indicating whether we're arriving at sliteral (vs 2literal)
.a213		20 3a 84	jsr $843a	                jsr xt_cr       ; ( addr u )
.a216						_byte_loop:
.a216		20 11 8d	jsr $8d11	                jsr xt_over     ; ( addr u addr )
.a219		20 fb 94	jsr $94fb	                jsr xt_u_dot    ; ( addr u )
.a21c		20 d7 91	jsr $91d7	                jsr xt_space
.a21f		a9 3c		lda #$3c	                lda #<oc_index_table
.a221		85 27		sta $27		                sta tmp2
.a223		a9 b4		lda #$b4	                lda #>oc_index_table
.a225		85 28		sta $28		                sta tmp2+1
.a227		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a229		85 2d		sta $2d		                sta scratch     ; Save opcode
.a22b		0a		asl a		                asl             ; multiply by two for offset
.a22c		90 02		bcc $a230	                bcc +
.a22e		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a230						+
.a230		a8		tay		                tay             ; use Y as the index
.a231		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a233		85 29		sta $29		                sta tmp3
.a235		48		pha		                pha
.a236		c8		iny		                iny
.a237		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a239		85 2a		sta $2a		                sta tmp3+1
.a23b		48		pha		                pha
.a23c		b2 29		lda ($29)	                lda (tmp3)
.a23e		a8		tay		                tay                     ; save copy of lengths byte
.a23f		10 3c		bpl $a27d	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a241		20 f6 9d	jsr $9df6	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.a244		f6 04		inc $04,x	                inc 4,x
.a246		d0 02		bne $a24a	                bne +
.a248		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.a24a						+
.a24a		b5 02		lda $02,x	                lda 2,x
.a24c		d0 02		bne $a250	                bne +
.a24e		d6 03		dec $03,x	                dec 3,x
.a250						+
.a250		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.a252		a1 04		lda ($04,x)	                lda (4,x)
.a254		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a256		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a258		98		tya		                tya                     ; retrieve copy of lengths byte
.a259		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a25a		10 14		bpl $a270	                bpl _print_operand
.a25c		f6 04		inc $04,x	                inc 4,x
.a25e		d0 02		bne $a262	                bne +
.a260		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.a262						+
.a262		b5 02		lda $02,x	                lda 2,x
.a264		d0 02		bne $a268	                bne +
.a266		d6 03		dec $03,x	                dec 3,x
.a268						+
.a268		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.a26a		a1 04		lda ($04,x)	                lda (4,x)
.a26c		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a26e		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a270						_print_operand:
.a270		ca		dex		                dex
.a271		ca		dex		                dex
.a272		a9 05		lda #$05	                lda #5
.a274		95 00		sta $00,x	                sta 0,x
.a276		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.a278		20 07 95	jsr $9507	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.a27b		80 0b		bra $a288	                bra _print_mnemonic
.a27d						_no_operand:
.a27d		ca		dex		                dex
.a27e		ca		dex		                dex
.a27f		a9 05		lda #$05	                lda #5
.a281		95 00		sta $00,x	                sta 0,x
.a283		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.a285		20 dd 91	jsr $91dd	                jsr xt_spaces           ; ( addr u )
.a288						_print_mnemonic:
.a288		20 d7 91	jsr $91d7	                jsr xt_space
.a28b		ca		dex		                dex
.a28c		ca		dex		                dex                     ; ( addr u ? )
.a28d		68		pla		                pla                     ; MSB
.a28e		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a290		68		pla		                pla                     ; LSB
.a291		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a293		20 26 84	jsr $8426	                jsr xt_count            ; ( addr u addr-o u-o )
.a296		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a298		b5 00		lda $00,x	                lda 0,x
.a29a		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a29c		95 00		sta $00,x	                sta 0,x
.a29e		20 d0 94	jsr $94d0	                jsr xt_type             ; ( addr u )
.a2a1		a5 2d		lda $2d		                lda scratch
.a2a3		c9 20		cmp #$20	                cmp #OpJSR
.a2a5		d0 15		bne $a2bc	                bne _not_jsr
.a2a7		ca		dex		                dex
.a2a8		ca		dex		                dex
.a2a9		a9 05		lda #$05	                lda #5
.a2ab		95 00		sta $00,x	                sta 0,x
.a2ad		74 01		stz $01,x	                stz 1,x
.a2af		20 dd 91	jsr $91dd	                jsr xt_spaces
.a2b2		20 b0 a3	jsr $a3b0	                jsr disasm_special
.a2b5		b0 70		bcs $a327	                bcs _printing_done
.a2b7		20 6d a3	jsr $a36d	                jsr disasm_jsr
.a2ba		b0 6b		bcs $a327	                bcs _printing_done
.a2bc						_not_jsr:
.a2bc		c9 4c		cmp #$4c	                cmp #OpJMP
.a2be		d0 2d		bne $a2ed	                bne _not_jmp
.a2c0		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.a2c2		85 30		sta $30		                sta scratch+3
.a2c4		a5 2f		lda $2f		                lda scratch+2
.a2c6		85 31		sta $31		                sta scratch+4
.a2c8		b2 30		lda ($30)	                lda (scratch+3)
.a2ca		c9 20		cmp #$20	                cmp #OpJSR          ; check for JSR
.a2cc		d0 59		bne $a327	                bne _printing_done
.a2ce		e6 30		inc $30		                inc scratch+3
.a2d0		d0 02		bne $a2d4	                bne +
.a2d2		e6 31		inc $31		                inc scratch+4
.a2d4						+
.a2d4		b2 30		lda ($30)	                lda (scratch+3)
.a2d6		c9 e2		cmp #$e2	                cmp #<sliteral_runtime
.a2d8		d0 4d		bne $a327	                bne _printing_done
.a2da		e6 30		inc $30		                inc scratch+3
.a2dc		d0 02		bne $a2e0	                bne +
.a2de		e6 31		inc $31		                inc scratch+4
.a2e0						+
.a2e0		b2 30		lda ($30)	                lda (scratch+3)
.a2e2		c9 a1		cmp #$a1	                cmp #>sliteral_runtime
.a2e4		d0 41		bne $a327	                bne _printing_done
.a2e6		c6 32		dec $32		                dec scratch+5                   ; flag for next go round
.a2e8		20 43 a3	jsr $a343	                jsr disasm_sliteral_jump
.a2eb		80 3a		bra $a327	                bra _printing_done
.a2ed						_not_jmp:
.a2ed		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a2ef		f0 06		beq $a2f7	                beq _is_rel
.a2f1		29 1f		and #$1f	                and #$1F
.a2f3		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a2f5		d0 30		bne $a327	                bne _printing_done
.a2f7						_is_rel:
.a2f7		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a2f9		ca		dex		                dex
.a2fa		ca		dex		                dex
.a2fb		74 01		stz $01,x	                stz 1,x
.a2fd		a5 2e		lda $2e		                lda scratch+1
.a2ff		95 00		sta $00,x	                sta 0,x
.a301		10 04		bpl $a307	                bpl +
.a303		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a305		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a307		38		sec		+               sec                 ; start counting from address after opcode
.a308		75 04		adc $04,x	                adc 4,x
.a30a		95 00		sta $00,x	                sta 0,x
.a30c		b5 01		lda $01,x	                lda 1,x
.a30e		75 05		adc $05,x	                adc 5,x
.a310		95 01		sta $01,x	                sta 1,x
.a312		5a		phy		                phy                 ; save the direction indicator
.a313		ca		dex		                dex
.a314		ca		dex		                dex
.a315		a9 09		lda #$09	                lda #9
.a317		95 00		sta $00,x	                sta 0,x
.a319		74 01		stz $01,x	                stz 1,x
.a31b		20 07 95	jsr $9507	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.a31e		a9 20		lda #$20	                lda #AscSP          ; print space and branch direction indicator
.a320		20 c5 86	jsr $86c5	                jsr emit_a
.a323		68		pla		                pla
.a324		20 c5 86	jsr $86c5	                jsr emit_a
.a327						_printing_done:
.a327		20 3a 84	jsr $843a	                jsr xt_cr
.a32a		f6 02		inc $02,x	                inc 2,x
.a32c		d0 02		bne $a330	                bne +
.a32e		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.a330						+
.a330		20 e9 8c	jsr $8ce9	                jsr xt_one_minus        ; ( addr+1 u-1 )
.a333		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a335		15 01		ora $01,x	                ora 1,x
.a337		f0 07		beq $a340	                beq _done
.a339		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a33b		30 03		bmi $a340	                bmi _done
.a33d		4c 16 a2	jmp $a216	                jmp _byte_loop          ; out of range for BRA
.a340						_done:
.a340		4c b3 93	jmp $93b3	                jmp xt_two_drop         ; JSR/RTS
.a343						disasm_sliteral_jump:
.a343		20 3a 92	jsr $923a	                jsr xt_swap
.a346		ca		dex		                dex
.a347		ca		dex		                dex
.a348		a5 2e		lda $2e		                lda scratch+1
.a34a		95 00		sta $00,x	                sta 0,x
.a34c		a5 2f		lda $2f		                lda scratch+2
.a34e		95 01		sta $01,x	                sta 1,x
.a350		20 3a 92	jsr $923a	                jsr xt_swap
.a353		20 f6 8b	jsr $8bf6	                jsr xt_minus
.a356		20 e9 8c	jsr $8ce9	                jsr xt_one_minus
.a359		20 f6 8b	jsr $8bf6	                jsr xt_minus
.a35c		ca		dex		                dex
.a35d		ca		dex		                dex
.a35e		a5 2e		lda $2e		                lda scratch+1
.a360		95 00		sta $00,x	                sta 0,x
.a362		a5 2f		lda $2f		                lda scratch+2
.a364		95 01		sta $01,x	                sta 1,x
.a366		20 e9 8c	jsr $8ce9	                jsr xt_one_minus
.a369		20 3a 92	jsr $923a	                jsr xt_swap ; ( new_addr new_n )
.a36c		60		rts		                rts
.a36d						disasm_jsr:
.a36d		ca		dex		                dex
.a36e		ca		dex		                dex
.a36f		a5 2e		lda $2e		                lda scratch+1
.a371		95 00		sta $00,x	                sta 0,x
.a373		a5 2f		lda $2f		                lda scratch+2
.a375		95 01		sta $01,x	                sta 1,x
.a377		20 ad 9b	jsr $9bad	                jsr xt_int_to_name
.a37a		b5 00		lda $00,x	                lda 0,x
.a37c		15 01		ora $01,x	                ora 1,x
.a37e		d0 24		bne $a3a4	                bne _found_nt
.a380		a5 2e		lda $2e		                lda scratch+1
.a382		38		sec		                sec
.a383		e9 03		sbc #$03	                sbc #3         ; Subtract 3 this time.
.a385		95 00		sta $00,x	                sta 0,x
.a387		a5 2f		lda $2f		                lda scratch+2
.a389		e9 00		sbc #$00	                sbc #0         ; Subtract the carry if needed.
.a38b		95 01		sta $01,x	                sta 1,x
.a38d		20 ad 9b	jsr $9bad	                jsr xt_int_to_name    ; Try looking again
.a390		b5 00		lda $00,x	                lda 0,x
.a392		15 01		ora $01,x	                ora 1,x
.a394		f0 16		beq $a3ac	                beq _no_nt
.a396		20 a0 86	jsr $86a0	                jsr xt_dup
.a399		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.a39c		a1 00		lda ($00,x)	                lda (0,x)
.a39e		e8		inx		                inx
.a39f		e8		inx		                inx
.a3a0		29 10		and #$10	                and #UF
.a3a2		f0 08		beq $a3ac	                beq _no_nt      ; The word doesn't have underflow checking
.a3a4						_found_nt:
.a3a4		20 50 9c	jsr $9c50	                jsr xt_name_to_string
.a3a7		20 d0 94	jsr $94d0	                jsr xt_type
.a3aa		38		sec		                sec
.a3ab		60		rts		                rts
.a3ac						_no_nt:
.a3ac		e8		inx		                inx
.a3ad		e8		inx		                inx
.a3ae		18		clc		                clc
.a3af		60		rts		                rts
.a3b0						disasm_special:
.a3b0		a0 2c		ldy #$2c	                ldy #(_end_handlers - _special_handlers - 4)
.a3b2		b9 3e a4	lda $a43e,y	_check:         lda _special_handlers,y
.a3b5		c5 2e		cmp $2e		                cmp scratch+1
.a3b7		d0 07		bne $a3c0	                bne _next
.a3b9		b9 3f a4	lda $a43f,y	                lda _special_handlers+1,y
.a3bc		c5 2f		cmp $2f		                cmp scratch+2
.a3be		f0 08		beq $a3c8	                beq _found_handler
.a3c0		88		dey		_next:          dey
.a3c1		88		dey		                dey
.a3c2		88		dey		                dey
.a3c3		88		dey		                dey
.a3c4		10 ec		bpl $a3b2	                bpl _check
.a3c6		18		clc		                clc
.a3c7		60		rts		                rts
.a3c8						_found_handler:
.a3c8		a5 32		lda $32		                lda scratch+5               ; are we expecting sliteral?
.a3ca		f0 04		beq $a3d0	                beq +
.a3cc		64 32		stz $32		                stz scratch+5               ; yes, skip 2literal and match again
.a3ce		80 f0		bra $a3c0	                bra _next
.a3d0						+
.a3d0		b9 41 a4	lda $a441,y	                lda _special_handlers+3,y   ; payload + prefix
.a3d3		48		pha		                pha                         ; stash a copy for payload later
.a3d4		4a		lsr a		                lsr
.a3d5		4a		lsr a		                lsr
.a3d6		f0 06		beq $a3de	                beq _no_prefix
.a3d8		18		clc		                clc
.a3d9		69 20		adc #$20	                adc #32
.a3db		20 c5 86	jsr $86c5	                jsr emit_a
.a3de						_no_prefix:
.a3de		b9 40 a4	lda $a440,y	                lda _special_handlers+2,y   ; string index
.a3e1		20 7b d8	jsr $d87b	                jsr print_string_no_lf
.a3e4		68		pla		                pla
.a3e5		29 03		and #$03	                and #3                      ; payload is 0, 1 or 2 words
.a3e7		f0 0f		beq $a3f8	                beq _done
.a3e9		c9 03		cmp #$03	                cmp #3                      ; but 3 means a double-word
.a3eb		d0 03		bne $a3f0	                bne _show_payload
.a3ed		4c 12 a4	jmp $a412	                jmp _print_2literal
.a3f0						_show_payload:
.a3f0		48		pha		                pha
.a3f1		20 fa a3	jsr $a3fa	                jsr _print_literal
.a3f4		68		pla		                pla
.a3f5		3a		dec a		                dea
.a3f6		d0 f8		bne $a3f0	                bne _show_payload
.a3f8		38		sec		_done:          sec
.a3f9		60		rts		                rts
.a3fa						_print_literal:
.a3fa		20 3a 92	jsr $923a	                jsr xt_swap ; switch to (u addr)
.a3fd		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.a400		20 a0 86	jsr $86a0	                jsr xt_dup
.a403		20 16 99	jsr $9916	                jsr xt_question ; Print the value at the address
.a406		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.a409		20 3a 92	jsr $923a	                jsr xt_swap ; (addr+2 u)
.a40c		20 e9 8c	jsr $8ce9	                jsr xt_one_minus
.a40f		4c e9 8c	jmp $8ce9	                jmp xt_one_minus ; (addr+2 u-2)
.a412						_print_2literal:
.a412		20 3a 92	jsr $923a	                jsr xt_swap
.a415		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.a418		20 a0 86	jsr $86a0	                jsr xt_dup
.a41b		20 d3 93	jsr $93d3	                jsr xt_two_fetch
.a41e		20 3a 92	jsr $923a	                jsr xt_swap             ; 2! / 2@ put MSW first; but 2literal writes LSW first
.a421		20 7f 9e	jsr $9e7f	                jsr xt_d_dot
.a424		18		clc		                clc
.a425		b5 00		lda $00,x	                lda 0,x
.a427		69 03		adc #$03	                adc #3
.a429		95 00		sta $00,x	                sta 0,x
.a42b		90 02		bcc $a42f	                bcc +
.a42d		f6 01		inc $01,x	                inc 1,x
.a42f						+
.a42f		20 3a 92	jsr $923a	                jsr xt_swap ; ( addr+4 u )
.a432		38		sec		                sec
.a433		b5 00		lda $00,x	                lda 0,x
.a435		e9 04		sbc #$04	                sbc #4
.a437		95 00		sta $00,x	                sta 0,x
.a439		b0 02		bcs $a43d	                bcs +
.a43b		d6 01		dec $01,x	                dec 1,x
.a43d						+
.a43d		60		rts		                rts
.a43e						_special_handlers:
>a43e		3f d8				    .word underflow_1
>a440		0c 44				        .byte str_disasm_sdc, 0 + ('1'-32)*4
>a442		44 d8				    .word underflow_2
>a444		0c 48				        .byte str_disasm_sdc, 0 + ('2'-32)*4
>a446		49 d8				    .word underflow_3
>a448		0c 4c				        .byte str_disasm_sdc, 0 + ('3'-32)*4
>a44a		4e d8				    .word underflow_4
>a44c		0c 50				        .byte str_disasm_sdc, 0 + ('4'-32)*4
>a44e		4c 8a				    .word literal_runtime
>a450		0d 01				        .byte str_disasm_lit, 1
>a452		e2 a1				    .word sliteral_runtime
>a454		0d ce				        .byte str_disasm_lit, 2 + ('S'-32)*4
>a456		e2 a1				    .word sliteral_runtime                      ; 2literal and sliteral use the same runtime
>a458		0d 4b				        .byte str_disasm_lit, 3 + ('2'-32)*4    ; list is searched in reverse, put 2literal first
>a45a		28 98				    .word zero_branch_runtime
>a45c		0e 01				        .byte str_disasm_0bra, 1
>a45e		e4 8a				    .word loop_runtime
>a460		0f 01				        .byte str_disasm_loop, 1
>a462		fd 8a				    .word plus_loop_runtime
>a464		0f 2d				        .byte str_disasm_loop, 1 + ('+'-32)*4
>a466		bc 85				    .word do_runtime
>a468		10 00				        .byte str_disasm_do, 0
>a46a		a4 85				    .word question_do_runtime
>a46c		10 7d				        .byte str_disasm_do, 1 + ('?'-32)*4
.a46e						_end_handlers:
.a46e						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a46e						assembler:
.a46e						xt_asm_adc_h:
.a46e		a9 69		lda #$69	                lda #$69
.a470		4c c9 a7	jmp $a7c9	                jmp asm_common
.a473						z_asm_adc_h:
.a473						xt_asm_adc_x:
.a473		a9 7d		lda #$7d	                lda #$7D
.a475		4c c9 a7	jmp $a7c9	                jmp asm_common
.a478						z_asm_adc_x:
.a478						xt_asm_adc_y:
.a478		a9 79		lda #$79	                lda #$79
.a47a		4c c9 a7	jmp $a7c9	                jmp asm_common
.a47d						z_asm_adc_y:
.a47d						xt_asm_adc_z:
.a47d		a9 65		lda #$65	                lda #$65
.a47f		4c c9 a7	jmp $a7c9	                jmp asm_common
.a482						z_asm_adc_z:
.a482						xt_asm_adc_zi:
.a482		a9 72		lda #$72	                lda #$72
.a484		4c c9 a7	jmp $a7c9	                jmp asm_common
.a487						z_asm_adc_zi:
.a487						xt_asm_adc_ziy:
.a487		a9 71		lda #$71	                lda #$71
.a489		4c c9 a7	jmp $a7c9	                jmp asm_common
.a48c						z_asm_adc_ziy:
.a48c						xt_asm_adc_zx:
.a48c		a9 75		lda #$75	                lda #$75
.a48e		4c c9 a7	jmp $a7c9	                jmp asm_common
.a491						z_asm_adc_zx:
.a491						xt_asm_adc_zxi:
.a491		a9 61		lda #$61	                lda #$61
.a493		4c c9 a7	jmp $a7c9	                jmp asm_common
.a496						z_asm_adc_zxi:
.a496						xt_asm_and:
.a496		a9 2d		lda #$2d	                lda #$2D
.a498		4c c9 a7	jmp $a7c9	                jmp asm_common
.a49b						z_asm_and:
.a49b						xt_asm_and_h:
.a49b		a9 29		lda #$29	                lda #$29
.a49d		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4a0						z_asm_and_h:
.a4a0						xt_asm_and_x:
.a4a0		a9 3d		lda #$3d	                lda #$3D
.a4a2		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4a5						z_asm_and_x:
.a4a5						xt_asm_and_y:
.a4a5		a9 39		lda #$39	                lda #$39
.a4a7		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4aa						z_asm_and_y:
.a4aa						xt_asm_and_z:
.a4aa		a9 25		lda #$25	                lda #$25
.a4ac		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4af						z_asm_and_z:
.a4af						xt_asm_and_zi:
.a4af		a9 32		lda #$32	                lda #$32
.a4b1		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4b4						z_asm_and_zi:
.a4b4						xt_asm_and_ziy:
.a4b4		a9 31		lda #$31	                lda #$31
.a4b6		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4b9						z_asm_and_ziy:
.a4b9						xt_asm_and_zx:
.a4b9		a9 35		lda #$35	                lda #$35
.a4bb		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4be						z_asm_and_zx:
.a4be						xt_asm_and_zxi:
.a4be		a9 21		lda #$21	                lda #$21
.a4c0		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4c3						z_asm_and_zxi:
.a4c3						xt_asm_asl:
.a4c3		a9 0e		lda #$0e	                lda #$0E
.a4c5		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4c8						z_asm_asl:
.a4c8						xt_asm_asl_a:
.a4c8		a9 0a		lda #$0a	                lda #$0A
.a4ca		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4cd						z_asm_asl_a:
.a4cd						xt_asm_asl_x:
.a4cd		a9 1e		lda #$1e	                lda #$1E
.a4cf		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4d2						z_asm_asl_x:
.a4d2						xt_asm_asl_z:
.a4d2		a9 06		lda #$06	                lda #$06
.a4d4		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4d7						z_asm_asl_z:
.a4d7						xt_asm_asl_zx:
.a4d7		a9 16		lda #$16	                lda #$16
.a4d9		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4dc						z_asm_asl_zx:
.a4dc						xt_asm_bcc:
.a4dc		a9 90		lda #$90	                lda #$90
.a4de		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4e1						z_asm_bcc:
.a4e1						xt_asm_bcs:
.a4e1		a9 b0		lda #$b0	                lda #$B0
.a4e3		a0 02		ldy #$02	                ldy #2
.a4e5		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4e8						z_asm_bcs:
.a4e8						xt_asm_beq:
.a4e8		a9 f0		lda #$f0	                lda #$F0
.a4ea		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4ed						z_asm_beq:
.a4ed						xt_asm_bit:
.a4ed		a9 2c		lda #$2c	                lda #$2C
.a4ef		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4f2						z_asm_bit:
.a4f2						xt_asm_bit_h:
.a4f2		a9 89		lda #$89	                lda #$89
.a4f4		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4f7						z_asm_bit_h:
.a4f7						xt_asm_bit_x:
.a4f7		a9 3c		lda #$3c	                lda #$3C
.a4f9		4c c9 a7	jmp $a7c9	                jmp asm_common
.a4fc						z_asm_bit_x:
.a4fc						xt_asm_bit_z:
.a4fc		a9 24		lda #$24	                lda #$24
.a4fe		4c c9 a7	jmp $a7c9	                jmp asm_common
.a501						z_asm_bit_z:
.a501						xt_asm_bit_zx:
.a501		a9 34		lda #$34	                lda #$34
.a503		4c c9 a7	jmp $a7c9	                jmp asm_common
.a506						z_asm_bit_zx:
.a506						xt_asm_bmi:
.a506		a9 30		lda #$30	                lda #$30
.a508		4c c9 a7	jmp $a7c9	                jmp asm_common
.a50b						z_asm_bmi:
.a50b						xt_asm_bne:
.a50b		a9 d0		lda #$d0	                lda #$D0
.a50d		4c c9 a7	jmp $a7c9	                jmp asm_common
.a510						z_asm_bne:
.a510						xt_asm_bpl:
.a510		a9 10		lda #$10	                lda #$10
.a512		4c c9 a7	jmp $a7c9	                jmp asm_common
.a515						z_asm_bpl:
.a515						xt_asm_bra:
.a515		a9 80		lda #$80	                lda #$80
.a517		4c c9 a7	jmp $a7c9	                jmp asm_common
.a51a						z_asm_bra:
.a51a						xt_asm_brk:
.a51a		a9 00		lda #$00	                lda #$00
.a51c		4c c9 a7	jmp $a7c9	                jmp asm_common
.a51f						z_asm_brk:
.a51f						xt_asm_bvc:
.a51f		a9 50		lda #$50	                lda #$50
.a521		4c c9 a7	jmp $a7c9	                jmp asm_common
.a524						z_asm_bvc:
.a524						xt_asm_bvs:
.a524		a9 70		lda #$70	                lda #$70
.a526		4c c9 a7	jmp $a7c9	                jmp asm_common
.a529						z_asm_bvs:
.a529						xt_asm_clc:
.a529		a9 18		lda #$18	                lda #$18
.a52b		4c c9 a7	jmp $a7c9	                jmp asm_common
.a52e						z_asm_clc:
.a52e						xt_asm_cld:
.a52e		a9 d8		lda #$d8	                lda #$D8
.a530		4c c9 a7	jmp $a7c9	                jmp asm_common
.a533						z_asm_cld:
.a533						xt_asm_cli:
.a533		a9 58		lda #$58	                lda #$58
.a535		4c c9 a7	jmp $a7c9	                jmp asm_common
.a538						z_asm_cli:
.a538						xt_asm_clv:
.a538		a9 b8		lda #$b8	                lda #$B8
.a53a		4c c9 a7	jmp $a7c9	                jmp asm_common
.a53d						z_asm_clv:
.a53d						xt_asm_cmp:
.a53d		a9 cd		lda #$cd	                lda #$CD
.a53f		4c c9 a7	jmp $a7c9	                jmp asm_common
.a542						z_asm_cmp:
.a542						xt_asm_cmp_h:
.a542		a9 c9		lda #$c9	                lda #$C9
.a544		4c c9 a7	jmp $a7c9	                jmp asm_common
.a547						z_asm_cmp_h:
.a547						xt_asm_cmp_x:
.a547		a9 dd		lda #$dd	                lda #$DD
.a549		4c c9 a7	jmp $a7c9	                jmp asm_common
.a54c						z_asm_cmp_x:
.a54c						xt_asm_cmp_y:
.a54c		a9 d9		lda #$d9	                lda #$D9
.a54e		4c c9 a7	jmp $a7c9	                jmp asm_common
.a551						z_asm_cmp_y:
.a551						xt_asm_cmp_z:
.a551		a9 c5		lda #$c5	                lda #$C5
.a553		4c c9 a7	jmp $a7c9	                jmp asm_common
.a556						z_asm_cmp_z:
.a556						xt_asm_cmp_zi:
.a556		a9 d2		lda #$d2	                lda #$D2
.a558		4c c9 a7	jmp $a7c9	                jmp asm_common
.a55b						z_asm_cmp_zi:
.a55b						xt_asm_cmp_ziy:
.a55b		a9 d1		lda #$d1	                lda #$D1
.a55d		4c c9 a7	jmp $a7c9	                jmp asm_common
.a560						z_asm_cmp_ziy:
.a560						xt_asm_cmp_zx:
.a560		a9 d5		lda #$d5	                lda #$D5
.a562		4c c9 a7	jmp $a7c9	                jmp asm_common
.a565						z_asm_cmp_zx:
.a565						xt_asm_cmp_zxi:
.a565		a9 c1		lda #$c1	                lda #$C1
.a567		4c c9 a7	jmp $a7c9	                jmp asm_common
.a56a						z_asm_cmp_zxi:
.a56a						xt_asm_cpx:
.a56a		a9 ec		lda #$ec	                lda #$EC
.a56c		4c c9 a7	jmp $a7c9	                jmp asm_common
.a56f						z_asm_cpx:
.a56f						xt_asm_cpx_h:
.a56f		a9 e0		lda #$e0	                lda #$E0
.a571		4c c9 a7	jmp $a7c9	                jmp asm_common
.a574						z_asm_cpx_h:
.a574						xt_asm_cpx_z:
.a574		a9 e4		lda #$e4	                lda #$E4
.a576		4c c9 a7	jmp $a7c9	                jmp asm_common
.a579						z_asm_cpx_z:
.a579						xt_asm_cpy:
.a579		a9 cc		lda #$cc	                lda #$CC
.a57b		a0 03		ldy #$03	                ldy #3
.a57d		4c c9 a7	jmp $a7c9	                jmp asm_common
.a580						z_asm_cpy:
.a580						xt_asm_cpy_h:
.a580		a9 c0		lda #$c0	                lda #$C0
.a582		4c c9 a7	jmp $a7c9	                jmp asm_common
.a585						z_asm_cpy_h:
.a585						xt_asm_cpy_z:
.a585		a9 c4		lda #$c4	                lda #$C4
.a587		4c c9 a7	jmp $a7c9	                jmp asm_common
.a58a						z_asm_cpy_z:
.a58a						xt_asm_dec:
.a58a		a9 ce		lda #$ce	                lda #$CE
.a58c		4c c9 a7	jmp $a7c9	                jmp asm_common
.a58f						z_asm_dec:
.a58f						xt_asm_dec_a:
.a58f		a9 3a		lda #$3a	                lda #$3A
.a591		4c c9 a7	jmp $a7c9	                jmp asm_common
.a594						z_asm_dec_a:
.a594						xt_asm_dec_x:
.a594		a9 de		lda #$de	                lda #$DE
.a596		4c c9 a7	jmp $a7c9	                jmp asm_common
.a599						z_asm_dec_x:
.a599						xt_asm_dec_z:
.a599		a9 c6		lda #$c6	                lda #$C6
.a59b		4c c9 a7	jmp $a7c9	                jmp asm_common
.a59e						z_asm_dec_z:
.a59e						xt_asm_dec_zx:
.a59e		a9 d6		lda #$d6	                lda #$D6
.a5a0		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5a3						z_asm_dec_zx:
.a5a3						xt_asm_dex:
.a5a3		a9 ca		lda #$ca	                lda #$CA
.a5a5		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5a8						z_asm_dex:
.a5a8						xt_asm_dey:
.a5a8		a9 88		lda #$88	                lda #$88
.a5aa		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5ad						z_asm_dey:
.a5ad						xt_asm_eor:
.a5ad		a9 4d		lda #$4d	                lda #$4D
.a5af		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5b2						z_asm_eor:
.a5b2						xt_asm_eor_h:
.a5b2		a9 49		lda #$49	                lda #$49
.a5b4		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5b7						z_asm_eor_h:
.a5b7						xt_asm_eor_x:
.a5b7		a9 5d		lda #$5d	                lda #$5D
.a5b9		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5bc						z_asm_eor_x:
.a5bc						xt_asm_eor_y:
.a5bc		a9 59		lda #$59	                lda #$59
.a5be		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5c1						z_asm_eor_y:
.a5c1						xt_asm_eor_z:
.a5c1		a9 45		lda #$45	                lda #$45
.a5c3		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5c6						z_asm_eor_z:
.a5c6						xt_asm_eor_zi:
.a5c6		a9 52		lda #$52	                lda #$52
.a5c8		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5cb						z_asm_eor_zi:
.a5cb						xt_asm_eor_ziy:
.a5cb		a9 51		lda #$51	                lda #$51
.a5cd		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5d0						z_asm_eor_ziy:
.a5d0						xt_asm_eor_zx:
.a5d0		a9 55		lda #$55	                lda #$55
.a5d2		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5d5						z_asm_eor_zx:
.a5d5						xt_asm_eor_zxi:
.a5d5		a9 41		lda #$41	                lda #$41
.a5d7		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5da						z_asm_eor_zxi:
.a5da						xt_asm_inc:
.a5da		a9 ee		lda #$ee	                lda #$EE
.a5dc		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5df						z_asm_inc:
.a5df						xt_asm_inc_a:
.a5df		a9 1a		lda #$1a	                lda #$1A
.a5e1		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5e4						z_asm_inc_a:
.a5e4						xt_asm_inc_x:
.a5e4		a9 fe		lda #$fe	                lda #$FE
.a5e6		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5e9						z_asm_inc_x:
.a5e9						xt_asm_inc_z:
.a5e9		a9 e6		lda #$e6	                lda #$E6
.a5eb		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5ee						z_asm_inc_z:
.a5ee						xt_asm_inc_zx:
.a5ee		a9 f6		lda #$f6	                lda #$F6
.a5f0		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5f3						z_asm_inc_zx:
.a5f3						xt_asm_inx:
.a5f3		a9 e8		lda #$e8	                lda #$E8
.a5f5		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5f8						z_asm_inx:
.a5f8						xt_asm_iny:
.a5f8		a9 c8		lda #$c8	                lda #$C8
.a5fa		4c c9 a7	jmp $a7c9	                jmp asm_common
.a5fd						z_asm_iny:
.a5fd						xt_asm_jmp:
.a5fd		a9 4c		lda #$4c	                lda #$4C
.a5ff		4c c9 a7	jmp $a7c9	                jmp asm_common
.a602						z_asm_jmp:
.a602						xt_asm_jmp_i:
.a602		a9 6c		lda #$6c	                lda #$6C
.a604		4c c9 a7	jmp $a7c9	                jmp asm_common
.a607						z_asm_jmp_i:
.a607						xt_asm_jmp_xi:
.a607		a9 7c		lda #$7c	                lda #$7C
.a609		4c c9 a7	jmp $a7c9	                jmp asm_common
.a60c						z_asm_jmp_xi:
.a60c						xt_asm_jsr:
.a60c		a9 20		lda #$20	                lda #$20
.a60e		4c c9 a7	jmp $a7c9	                jmp asm_common
.a611						z_asm_jsr:
.a611						xt_asm_lda:
.a611		a9 ad		lda #$ad	                lda #$AD
.a613		4c c9 a7	jmp $a7c9	                jmp asm_common
.a616						z_asm_lda:
.a616						xt_asm_lda_h:
.a616		a9 a9		lda #$a9	                lda #$A9
.a618		4c c9 a7	jmp $a7c9	                jmp asm_common
.a61b						z_asm_lda_h:
.a61b						xt_asm_lda_x:
.a61b		a9 bd		lda #$bd	                lda #$BD
.a61d		4c c9 a7	jmp $a7c9	                jmp asm_common
.a620						z_asm_lda_x:
.a620						xt_asm_lda_y:
.a620		a9 b9		lda #$b9	                lda #$B9
.a622		4c c9 a7	jmp $a7c9	                jmp asm_common
.a625						z_asm_lda_y:
.a625						xt_asm_lda_z:
.a625		a9 a5		lda #$a5	                lda #$A5
.a627		4c c9 a7	jmp $a7c9	                jmp asm_common
.a62a						z_asm_lda_z:
.a62a						xt_asm_lda_zi:
.a62a		a9 b2		lda #$b2	                lda #$B2
.a62c		4c c9 a7	jmp $a7c9	                jmp asm_common
.a62f						z_asm_lda_zi:
.a62f						xt_asm_lda_ziy:
.a62f		a9 b1		lda #$b1	                lda #$B1
.a631		4c c9 a7	jmp $a7c9	                jmp asm_common
.a634						z_asm_lda_ziy:
.a634						xt_asm_lda_zx:
.a634		a9 b5		lda #$b5	                lda #$B5
.a636		4c c9 a7	jmp $a7c9	                jmp asm_common
.a639						z_asm_lda_zx:
.a639						xt_asm_lda_zxi:
.a639		a9 a1		lda #$a1	                lda #$A1
.a63b		4c c9 a7	jmp $a7c9	                jmp asm_common
.a63e						z_asm_lda_zxi:
.a63e						xt_asm_ldx:
.a63e		a9 ae		lda #$ae	                lda #$AE
.a640		4c c9 a7	jmp $a7c9	                jmp asm_common
.a643						z_asm_ldx:
.a643						xt_asm_ldx_h:
.a643		a9 a2		lda #$a2	                lda #$A2
.a645		4c c9 a7	jmp $a7c9	                jmp asm_common
.a648						z_asm_ldx_h:
.a648						xt_asm_ldx_y:
.a648		a9 be		lda #$be	                lda #$BE
.a64a		4c c9 a7	jmp $a7c9	                jmp asm_common
.a64d						z_asm_ldx_y:
.a64d						xt_asm_ldx_z:
.a64d		a9 a6		lda #$a6	                lda #$A6
.a64f		4c c9 a7	jmp $a7c9	                jmp asm_common
.a652						z_asm_ldx_z:
.a652						xt_asm_ldx_zy:
.a652		a9 b6		lda #$b6	                lda #$B6
.a654		4c c9 a7	jmp $a7c9	                jmp asm_common
.a657						z_asm_ldx_zy:
.a657						xt_asm_ldy:
.a657		a9 ac		lda #$ac	                lda #$AC
.a659		4c c9 a7	jmp $a7c9	                jmp asm_common
.a65c						z_asm_ldy:
.a65c						xt_asm_ldy_h:
.a65c		a9 a0		lda #$a0	                lda #$A0
.a65e		4c c9 a7	jmp $a7c9	                jmp asm_common
.a661						z_asm_ldy_h:
.a661						xt_asm_ldy_x:
.a661		a9 bc		lda #$bc	                lda #$BC
.a663		4c c9 a7	jmp $a7c9	                jmp asm_common
.a666						z_asm_ldy_x:
.a666						xt_asm_ldy_z:
.a666		a9 a4		lda #$a4	                lda #$A4
.a668		4c c9 a7	jmp $a7c9	                jmp asm_common
.a66b						z_asm_ldy_z:
.a66b						xt_asm_ldy_zx:
.a66b		a9 b4		lda #$b4	                lda #$B4
.a66d		4c c9 a7	jmp $a7c9	                jmp asm_common
.a670						z_asm_ldy_zx:
.a670						xt_asm_lsr:
.a670		a9 4e		lda #$4e	                lda #$4E
.a672		4c c9 a7	jmp $a7c9	                jmp asm_common
.a675						z_asm_lsr:
.a675						xt_asm_lsr_a:
.a675		a9 4a		lda #$4a	                lda #$4A
.a677		4c c9 a7	jmp $a7c9	                jmp asm_common
.a67a						z_asm_lsr_a:
.a67a						xt_asm_lsr_x:
.a67a		a9 5e		lda #$5e	                lda #$5E
.a67c		4c c9 a7	jmp $a7c9	                jmp asm_common
.a67f						z_asm_lsr_x:
.a67f						xt_asm_lsr_z:
.a67f		a9 46		lda #$46	                lda #$46
.a681		4c c9 a7	jmp $a7c9	                jmp asm_common
.a684						z_asm_lsr_z:
.a684						xt_asm_lsr_zx:
.a684		a9 56		lda #$56	                lda #$56
.a686		4c c9 a7	jmp $a7c9	                jmp asm_common
.a689						z_asm_lsr_zx:
.a689						xt_asm_nop:
.a689		a9 ea		lda #$ea	                lda #$EA
.a68b		4c c9 a7	jmp $a7c9	                jmp asm_common
.a68e						z_asm_nop:
.a68e						xt_asm_ora:
.a68e		a9 0d		lda #$0d	                lda #$0D
.a690		4c c9 a7	jmp $a7c9	                jmp asm_common
.a693						z_asm_ora:
.a693						xt_asm_ora_h:
.a693		a9 09		lda #$09	                lda #$09
.a695		4c c9 a7	jmp $a7c9	                jmp asm_common
.a698						z_asm_ora_h:
.a698						xt_asm_ora_x:
.a698		a9 1d		lda #$1d	                lda #$1D
.a69a		4c c9 a7	jmp $a7c9	                jmp asm_common
.a69d						z_asm_ora_x:
.a69d						xt_asm_ora_y:
.a69d		a9 19		lda #$19	                lda #$19
.a69f		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6a2						z_asm_ora_y:
.a6a2						xt_asm_ora_z:
.a6a2		a9 05		lda #$05	                lda #$05
.a6a4		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6a7						z_asm_ora_z:
.a6a7						xt_asm_ora_zi:
.a6a7		a9 12		lda #$12	                lda #$12
.a6a9		a0 02		ldy #$02	                ldy #2
.a6ab		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6ae						z_asm_ora_zi:
.a6ae						xt_asm_ora_ziy:
.a6ae		a9 11		lda #$11	                lda #$11
.a6b0		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6b3						z_asm_ora_ziy:
.a6b3						xt_asm_ora_zx:
.a6b3		a9 15		lda #$15	                lda #$15
.a6b5		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6b8						z_asm_ora_zx:
.a6b8						xt_asm_ora_zxi:
.a6b8		a9 01		lda #$01	                lda #$01
.a6ba		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6bd						z_asm_ora_zxi:
.a6bd						xt_asm_pha:
.a6bd		a9 48		lda #$48	                lda #$48
.a6bf		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6c2						z_asm_pha:
.a6c2						xt_asm_php:
.a6c2		a9 08		lda #$08	                lda #$08
.a6c4		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6c7						z_asm_php:
.a6c7						xt_asm_phx:
.a6c7		a9 da		lda #$da	                lda #$DA
.a6c9		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6cc						z_asm_phx:
.a6cc						xt_asm_phy:
.a6cc		a9 5a		lda #$5a	                lda #$5A
.a6ce		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6d1						z_asm_phy:
.a6d1						xt_asm_pla:
.a6d1		a9 68		lda #$68	                lda #$68
.a6d3		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6d6						z_asm_pla:
.a6d6						xt_asm_plp:
.a6d6		a9 28		lda #$28	                lda #$28
.a6d8		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6db						z_asm_plp:
.a6db						xt_asm_plx:
.a6db		a9 fa		lda #$fa	                lda #$FA
.a6dd		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6e0						z_asm_plx:
.a6e0						xt_asm_ply:
.a6e0		a9 7a		lda #$7a	                lda #$7A
.a6e2		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6e5						z_asm_ply:
.a6e5						xt_asm_rol:
.a6e5		a9 2e		lda #$2e	                lda #$2E
.a6e7		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6ea						z_asm_rol:
.a6ea						xt_asm_rol_a:
.a6ea		a9 2a		lda #$2a	                lda #$2A
.a6ec		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6ef						z_asm_rol_a:
.a6ef						xt_asm_rol_x:
.a6ef		a9 3e		lda #$3e	                lda #$3E
.a6f1		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6f4						z_asm_rol_x:
.a6f4						xt_asm_rol_z:
.a6f4		a9 26		lda #$26	                lda #$26
.a6f6		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6f9						z_asm_rol_z:
.a6f9						xt_asm_rol_zx:
.a6f9		a9 36		lda #$36	                lda #$36
.a6fb		4c c9 a7	jmp $a7c9	                jmp asm_common
.a6fe						z_asm_rol_zx:
.a6fe						xt_asm_ror:
.a6fe		a9 6e		lda #$6e	                lda #$6E
.a700		4c c9 a7	jmp $a7c9	                jmp asm_common
.a703						z_asm_ror:
.a703						xt_asm_ror_a:
.a703		a9 6a		lda #$6a	                lda #$6A
.a705		4c c9 a7	jmp $a7c9	                jmp asm_common
.a708						z_asm_ror_a:
.a708						xt_asm_ror_x:
.a708		a9 7e		lda #$7e	                lda #$7E
.a70a		4c c9 a7	jmp $a7c9	                jmp asm_common
.a70d						z_asm_ror_x:
.a70d						xt_asm_ror_z:
.a70d		a9 66		lda #$66	                lda #$66
.a70f		4c c9 a7	jmp $a7c9	                jmp asm_common
.a712						z_asm_ror_z:
.a712						xt_asm_ror_zx:
.a712		a9 76		lda #$76	                lda #$76
.a714		4c c9 a7	jmp $a7c9	                jmp asm_common
.a717						z_asm_ror_zx:
.a717						xt_asm_rti:
.a717		a9 40		lda #$40	                lda #$40
.a719		4c c9 a7	jmp $a7c9	                jmp asm_common
.a71c						z_asm_rti:
.a71c						xt_asm_rts:
.a71c		a9 60		lda #$60	                lda #$60
.a71e		4c c9 a7	jmp $a7c9	                jmp asm_common
.a721						z_asm_rts:
.a721						xt_asm_sbc:
.a721		a9 ed		lda #$ed	                lda #$ED
.a723		4c c9 a7	jmp $a7c9	                jmp asm_common
.a726						z_asm_sbc:
.a726						xt_asm_sbc_h:
.a726		a9 e9		lda #$e9	                lda #$E9
.a728		4c c9 a7	jmp $a7c9	                jmp asm_common
.a72b						z_asm_sbc_h:
.a72b						xt_asm_sbc_x:
.a72b		a9 fd		lda #$fd	                lda #$FD
.a72d		4c c9 a7	jmp $a7c9	                jmp asm_common
.a730						z_asm_sbc_x:
.a730						xt_asm_sbc_y:
.a730		a9 f9		lda #$f9	                lda #$F9
.a732		4c c9 a7	jmp $a7c9	                jmp asm_common
.a735						z_asm_sbc_y:
.a735						xt_asm_sbc_z:
.a735		a9 e5		lda #$e5	                lda #$E5
.a737		4c c9 a7	jmp $a7c9	                jmp asm_common
.a73a						z_asm_sbc_z:
.a73a						xt_asm_sbc_zi:
.a73a		a9 f2		lda #$f2	                lda #$F2
.a73c		4c c9 a7	jmp $a7c9	                jmp asm_common
.a73f						z_asm_sbc_zi:
.a73f						xt_asm_sbc_ziy:
.a73f		a9 f1		lda #$f1	                lda #$F1
.a741		4c c9 a7	jmp $a7c9	                jmp asm_common
.a744						z_asm_sbc_ziy:
.a744						xt_asm_sbc_zx:
.a744		a9 f5		lda #$f5	                lda #$F5
.a746		4c c9 a7	jmp $a7c9	                jmp asm_common
.a749						z_asm_sbc_zx:
.a749						xt_asm_sbc_zxi:
.a749		a9 e1		lda #$e1	                lda #$E1
.a74b		80 7c		bra $a7c9	                bra asm_common  ; <-- limit for BRA instead of JMP
.a74d						z_asm_sbc_zxi:
.a74d						xt_asm_sec:
.a74d		a9 38		lda #$38	                lda #$38
.a74f		80 78		bra $a7c9	                bra asm_common
.a751						z_asm_sec:
.a751						xt_asm_sed:
.a751		a9 f8		lda #$f8	                lda #$F8
.a753		80 74		bra $a7c9	                bra asm_common
.a755						z_asm_sed:
.a755						xt_asm_sei:
.a755		a9 78		lda #$78	                lda #$78
.a757		80 70		bra $a7c9	                bra asm_common
.a759						z_asm_sei:
.a759						xt_asm_sta:
.a759		a9 8d		lda #$8d	                lda #$8D
.a75b		80 6c		bra $a7c9	                bra asm_common
.a75d						z_asm_sta:
.a75d						xt_asm_sta_x:
.a75d		a9 9d		lda #$9d	                lda #$9D
.a75f		80 68		bra $a7c9	                bra asm_common
.a761						z_asm_sta_x:
.a761						xt_asm_sta_y:
.a761		a9 99		lda #$99	                lda #$99
.a763		80 64		bra $a7c9	                bra asm_common
.a765						z_asm_sta_y:
.a765						xt_asm_sta_z:
.a765		a9 85		lda #$85	                lda #$85
.a767		80 60		bra $a7c9	                bra asm_common
.a769						z_asm_sta_z:
.a769						xt_asm_sta_zi:
.a769		a9 92		lda #$92	                lda #$92
.a76b		80 5c		bra $a7c9	                bra asm_common
.a76d						z_asm_sta_zi:
.a76d						xt_asm_sta_ziy:
.a76d		a9 91		lda #$91	                lda #$91
.a76f		80 58		bra $a7c9	                bra asm_common
.a771						z_asm_sta_ziy:
.a771						xt_asm_sta_zx:
.a771		a9 95		lda #$95	                lda #$95
.a773		80 54		bra $a7c9	                bra asm_common
.a775						z_asm_sta_zx:
.a775						xt_asm_sta_zxi:
.a775		a9 81		lda #$81	                lda #$81
.a777		80 50		bra $a7c9	                bra asm_common
.a779						z_asm_sta_zxi:
.a779						xt_asm_stx:
.a779		a9 8e		lda #$8e	                lda #$8E
.a77b		80 4c		bra $a7c9	                bra asm_common
.a77d						z_asm_stx:
.a77d						xt_asm_stx_z:
.a77d		a9 86		lda #$86	                lda #$86
.a77f		80 48		bra $a7c9	                bra asm_common
.a781						z_asm_stx_z:
.a781						xt_asm_stx_zy:
.a781		a9 96		lda #$96	                lda #$96
.a783		80 44		bra $a7c9	                bra asm_common
.a785						z_asm_stx_zy:
.a785						xt_asm_sty:
.a785		a9 8c		lda #$8c	                lda #$8C
.a787		80 40		bra $a7c9	                bra asm_common
.a789						z_asm_sty:
.a789						xt_asm_sty_z:
.a789		a9 84		lda #$84	                lda #$84
.a78b		80 3c		bra $a7c9	                bra asm_common
.a78d						z_asm_sty_z:
.a78d						xt_asm_sty_zx:
.a78d		a9 94		lda #$94	                lda #$94
.a78f		80 38		bra $a7c9	                bra asm_common
.a791						z_asm_sty_zx:
.a791						xt_asm_stz:
.a791		a9 9c		lda #$9c	                lda #$9C
.a793		80 34		bra $a7c9	                bra asm_common
.a795						z_asm_stz:
.a795						xt_asm_stz_x:
.a795		a9 9e		lda #$9e	                lda #$9E
.a797		80 30		bra $a7c9	                bra asm_common
.a799						z_asm_stz_x:
.a799						xt_asm_stz_z:
.a799		a9 64		lda #$64	                lda #$64
.a79b		80 2c		bra $a7c9	                bra asm_common
.a79d						z_asm_stz_z:
.a79d						xt_asm_stz_zx:
.a79d		a9 74		lda #$74	                lda #$74
.a79f		80 28		bra $a7c9	                bra asm_common
.a7a1						z_asm_stz_zx:
.a7a1						xt_asm_tax:
.a7a1		a9 aa		lda #$aa	                lda #$AA
.a7a3		80 24		bra $a7c9	                bra asm_common
.a7a5						z_asm_tax:
.a7a5						xt_asm_tay:
.a7a5		a9 a8		lda #$a8	                lda #$A8
.a7a7		80 20		bra $a7c9	                bra asm_common
.a7a9						z_asm_tay:
.a7a9						xt_asm_trb:
.a7a9		a9 1c		lda #$1c	                lda #$1C
.a7ab		80 1c		bra $a7c9	                bra asm_common
.a7ad						z_asm_trb:
.a7ad						xt_asm_trb_z:
.a7ad		a9 14		lda #$14	                lda #$14
.a7af		80 18		bra $a7c9	                bra asm_common
.a7b1						z_asm_trb_z:
.a7b1						xt_asm_tsb:
.a7b1		a9 0c		lda #$0c	                lda #$0C
.a7b3		80 14		bra $a7c9	                bra asm_common
.a7b5						z_asm_tsb:
.a7b5						xt_asm_tsb_z:
.a7b5		a9 04		lda #$04	                lda #$04
.a7b7		80 10		bra $a7c9	                bra asm_common
.a7b9						z_asm_tsb_z:
.a7b9						xt_asm_tsx:
.a7b9		a9 ba		lda #$ba	                lda #$BA
.a7bb		80 0c		bra $a7c9	                bra asm_common
.a7bd						z_asm_tsx:
.a7bd						xt_asm_txa:
.a7bd		a9 8a		lda #$8a	                lda #$8A
.a7bf		80 08		bra $a7c9	                bra asm_common
.a7c1						z_asm_txa:
.a7c1						xt_asm_txs:
.a7c1		a9 9a		lda #$9a	                lda #$9A
.a7c3		80 04		bra $a7c9	                bra asm_common
.a7c5						z_asm_txs:
.a7c5						xt_asm_tya:
.a7c5		a9 98		lda #$98	                lda #$98
.a7c7		80 00		bra $a7c9	                bra asm_common
.a7c9						z_asm_tya:
.a7c9						asm_common:
.a7c9		a8		tay		                tay
.a7ca		20 84 97	jsr $9784	                jsr cmpl_a
.a7cd		a9 3c		lda #$3c	                lda #<oc_index_table
.a7cf		85 27		sta $27		                sta tmp2
.a7d1		a9 b4		lda #$b4	                lda #>oc_index_table
.a7d3		85 28		sta $28		                sta tmp2+1
.a7d5		98		tya		                tya             ; retrieve opcode
.a7d6		0a		asl a		                asl             ; times two for offset
.a7d7		90 02		bcc $a7db	                bcc +
.a7d9		e6 28		inc $28		                inc tmp2+1
.a7db						+
.a7db		a8		tay		                tay             ; use Y as the index
.a7dc		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a7de		85 29		sta $29		                sta tmp3
.a7e0		c8		iny		                iny
.a7e1		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a7e3		85 2a		sta $2a		                sta tmp3+1
.a7e5		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a7e7		2a		rol a		                rol
.a7e8		2a		rol a		                rol
.a7e9		2a		rol a		                rol             ; Three times because we go through Carry
.a7ea		29 03		and #$03	                and #%00000011
.a7ec		a8		tay		                tay
.a7ed		88		dey		                dey
.a7ee		f0 12		beq $a802	                beq _done
.a7f0		20 3f d8	jsr $d83f	                jsr underflow_1
.a7f3		b5 00		lda $00,x	                lda 0,x
.a7f5		20 84 97	jsr $9784	                jsr cmpl_a      ; does not use Y
.a7f8		88		dey		                dey
.a7f9		f0 05		beq $a800	                beq _done_drop
.a7fb		b5 01		lda $01,x	                lda 1,x
.a7fd		20 84 97	jsr $9784	                jsr cmpl_a      ; Fall through to _done_drop
.a800						_done_drop:
.a800		e8		inx		                inx
.a801		e8		inx		                inx             ; Fall through to _done
.a802						_done:
.a802		60		rts		                rts             ; Returns to original caller
.a803						xt_asm_push_a:
.a803		a0 00		ldy #$00	                ldy #0
.a805						_loop:
.a805		b9 13 a8	lda $a813,y	                lda asm_push_a_data,y
.a808		c9 ff		cmp #$ff	                cmp #$FF
.a80a		f0 06		beq $a812	                beq _done
.a80c		20 84 97	jsr $9784	                jsr cmpl_a      ; does not change Y
.a80f		c8		iny		                iny
.a810		80 f3		bra $a805	                bra _loop
.a812						_done:
.a812						z_asm_push_a:
.a812		60		rts		                rts
.a813						asm_push_a_data:
>a813		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>a819		ff				        .byte $FF               ; terminator
.a81a						xt_asm_back_jump:
.a81a						z_asm_back_jump:
.a81a		60		rts		                rts
.a81b						xt_asm_back_branch:
.a81b		20 1b 89	jsr $891b	                jsr xt_here             ; ( addr-l addr-h )
.a81e		20 f6 8b	jsr $8bf6	                jsr xt_minus            ; ( offset )
.a821		3a		dec a		                dea
.a822		3a		dec a		                dea
.a823						z_asm_back_branch:
.a823		60		rts		                rts
.a824						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a824						xt_ed:
.a824		20 28 a8	jsr $a828	                jsr ed6502      ; kept in separate file
.a827		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a828						ed6502:
.a828		a5 18		lda $18		                lda base
.a82a		85 3a		sta $3a		                sta ed_base
.a82c		a9 0a		lda #$0a	                lda #10
.a82e		85 18		sta $18		                sta base
.a830		64 35		stz $35		                stz ed_head
.a832		64 36		stz $36		                stz ed_head+1
.a834		64 37		stz $37		                stz ed_cur
.a836		64 38		stz $38		                stz ed_cur+1
.a838		64 39		stz $39		                stz ed_flags
.a83a		20 f6 9d	jsr $9df6	                jsr xt_zero
.a83d		20 f6 9d	jsr $9df6	                jsr xt_zero             ; ( addr-t u-t )
.a840		20 3a 84	jsr $843a	                jsr xt_cr
.a843						ed_input_loop:
.a843		a9 81		lda #$81	                lda #%10000001
.a845		14 39		trb $39		                trb ed_flags
.a847		20 22 ad	jsr $ad22	                jsr ed_get_input
.a84a		a5 0e		lda $0e		                lda ciblen
.a84c		d0 1f		bne $a86d	                bne _command_mode
.a84e		ca		dex		                dex
.a84f		ca		dex		                dex                     ; ( addr-t u-t ? )
.a850		a5 37		lda $37		                lda ed_cur
.a852		95 00		sta $00,x	                sta 0,x
.a854		a5 38		lda $38		                lda ed_cur+1
.a856		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a858		a9 80		lda #$80	                lda #%10000000
.a85a		04 39		tsb $39		                tsb ed_flags
.a85c		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.a85f		20 3e ad	jsr $ad3e	                jsr ed_is_valid_line
.a862		b0 03		bcs $a867	                bcs +
.a864		4c 12 ad	jmp $ad12	                jmp ed_error_1drop
.a867						+
.a867		20 f6 9d	jsr $9df6	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.a86a		4c 38 a9	jmp $a938	                jmp _line_number_only_from_external
.a86d						_command_mode:
.a86d		20 f6 9d	jsr $9df6	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a870		20 f6 9d	jsr $9df6	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a873		b2 0c		lda ($0c)	                lda (cib)
.a875		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a877		d0 3a		bne $a8b3	                bne _prefix_dollar
.a879		20 33 ad	jsr $ad33	                jsr ed_have_text
.a87c		a5 37		lda $37		                lda ed_cur
.a87e		95 02		sta $02,x	                sta 2,x
.a880		a5 38		lda $38		                lda ed_cur+1
.a882		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a884		a9 80		lda #$80	                lda #%10000000
.a886		04 39		tsb $39		                tsb ed_flags
.a888		a5 0e		lda $0e		                lda ciblen
.a88a		3a		dec a		                dea                     ; sets Z if A was 1
.a88b		d0 03		bne $a890	                bne +
.a88d		4c 38 a9	jmp $a938	                jmp _line_number_only_from_external
.a890						+
.a890		ca		dex		                dex
.a891		ca		dex		                dex
.a892		ca		dex		                dex
.a893		ca		dex		                dex
.a894		a5 0c		lda $0c		                lda cib
.a896		95 02		sta $02,x	                sta 2,x
.a898		a5 0d		lda $0d		                lda cib+1
.a89a		95 03		sta $03,x	                sta 3,x
.a89c		a5 0e		lda $0e		                lda ciblen
.a89e		95 00		sta $00,x	                sta 0,x
.a8a0		a5 0f		lda $0f		                lda ciblen+1
.a8a2		95 01		sta $01,x	                sta 1,x
.a8a4		20 e9 8c	jsr $8ce9	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a8a7		20 3a 92	jsr $923a	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a8aa		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a8ad		20 3a 92	jsr $923a	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a8b0		4c 90 a9	jmp $a990	                jmp _check_for_para2
.a8b3						_prefix_dollar:
.a8b3		b2 0c		lda ($0c)	                lda (cib)
.a8b5		c9 24		cmp #$24	                cmp #'$'
.a8b7		d0 1c		bne $a8d5	                bne _prefix_percent
.a8b9		20 33 ad	jsr $ad33	                jsr ed_have_text
.a8bc		e8		inx		                inx
.a8bd		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a8be		20 60 ad	jsr $ad60	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a8c1		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.a8c4		a9 80		lda #$80	                lda #%10000000
.a8c6		04 39		tsb $39		                tsb ed_flags
.a8c8		a5 0e		lda $0e		                lda ciblen
.a8ca		3a		dec a		                dea                     ; sets Z if A was 1
.a8cb		d0 03		bne $a8d0	                bne +
.a8cd		4c 38 a9	jmp $a938	                jmp _line_number_only_from_external
.a8d0						+
.a8d0		a0 01		ldy #$01	                ldy #01
.a8d2		4c 0c aa	jmp $aa0c	                jmp _check_command
.a8d5						_prefix_percent:
.a8d5		b2 0c		lda ($0c)	                lda (cib)
.a8d7		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a8d9		f0 04		beq $a8df	                beq _whole_text
.a8db		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a8dd		d0 17		bne $a8f6	                bne _prefix_semicolon
.a8df						_whole_text:
.a8df		20 33 ad	jsr $ad33	                jsr ed_have_text
.a8e2		a9 01		lda #$01	                lda #01
.a8e4		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a8e6		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a8e8						_semicolon_entry:
.a8e8		e8		inx		                inx
.a8e9		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a8ea		20 60 ad	jsr $ad60	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a8ed		a9 80		lda #$80	                lda #%10000000
.a8ef		04 39		tsb $39		                tsb ed_flags
.a8f1		a0 01		ldy #$01	                ldy #01
.a8f3		4c 0c aa	jmp $aa0c	                jmp _check_command
.a8f6						_prefix_semicolon:
.a8f6		b2 0c		lda ($0c)	                lda (cib)
.a8f8		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a8fa		d0 0d		bne $a909	                bne _prefix_number
.a8fc		20 33 ad	jsr $ad33	                jsr ed_have_text
.a8ff		a5 37		lda $37		                lda ed_cur
.a901		95 02		sta $02,x	                sta 2,x
.a903		a5 38		lda $38		                lda ed_cur+1
.a905		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a907		80 df		bra $a8e8	                bra _semicolon_entry
.a909						_prefix_number:
.a909		20 f6 9d	jsr $9df6	                jsr xt_zero
.a90c		20 f6 9d	jsr $9df6	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.a90f		ca		dex		                dex
.a910		ca		dex		                dex
.a911		ca		dex		                dex
.a912		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a913		a5 0c		lda $0c		                lda cib
.a915		95 02		sta $02,x	                sta 2,x
.a917		a5 0d		lda $0d		                lda cib+1
.a919		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a91b		a5 0e		lda $0e		                lda ciblen
.a91d		95 00		sta $00,x	                sta 0,x
.a91f		a5 0f		lda $0f		                lda ciblen+1
.a921		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a923		20 d8 92	jsr $92d8	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a926		b5 00		lda $00,x	                lda 0,x
.a928		15 01		ora $01,x	                ora 1,x
.a92a		d0 24		bne $a950	                bne _have_unconverted_chars
.a92c		e8		inx		                inx
.a92d		e8		inx		                inx
.a92e		e8		inx		                inx
.a92f		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a930		20 3f 9e	jsr $9e3f	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a933		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.a936		e8		inx		                inx
.a937		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a938						_line_number_only_from_external:
.a938		20 3a 92	jsr $923a	                jsr xt_swap             ; ( addr-t u-t 0 u )
.a93b		20 3e ad	jsr $ad3e	                jsr ed_is_valid_line
.a93e		b0 03		bcs $a943	                bcs +
.a940		4c 10 ad	jmp $ad10	                jmp ed_error_2drop
.a943						+
.a943		20 3a 92	jsr $923a	                jsr xt_swap             ; ( addr-t u-t u 0 )
.a946		20 cd ad	jsr $adcd	                jsr ed_para1_to_cur
.a949		a9 80		lda #$80	                lda #%10000000
.a94b		04 39		tsb $39		                tsb ed_flags
.a94d		4c eb ab	jmp $abeb	                jmp ed_cmd_p_from_external
.a950						_have_unconverted_chars:
.a950		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a953		ca		dex		                dex
.a954		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a955		a5 0e		lda $0e		                lda ciblen
.a957		95 00		sta $00,x	                sta 0,x
.a959		a5 0f		lda $0f		                lda ciblen+1
.a95b		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a95d		20 96 87	jsr $8796	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a960		b5 00		lda $00,x	                lda 0,x
.a962		15 01		ora $01,x	                ora 1,x
.a964		f0 0e		beq $a974	                beq _no_command_yet
.a966		8a		txa		                txa
.a967		18		clc		                clc
.a968		69 0a		adc #$0a	                adc #10
.a96a		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a96b		a9 80		lda #$80	                lda #%10000000
.a96d		14 39		trb $39		                trb ed_flags
.a96f		a0 00		ldy #$00	                ldy #00
.a971		4c 0c aa	jmp $aa0c	                jmp _check_command
.a974						_no_command_yet:
.a974		e8		inx		                inx
.a975		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a976		20 78 93	jsr $9378	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a979		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a97c		20 3f 9e	jsr $9e3f	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a97f		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a981		95 06		sta $06,x	                sta 6,x
.a983		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a985		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a987		e8		inx		                inx
.a988		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a989		20 fc 8e	jsr $8efc	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a98c		a9 80		lda #$80	                lda #%10000000
.a98e		04 39		tsb $39		                tsb ed_flags
.a990						_check_for_para2:
.a990		a1 02		lda ($02,x)	                lda (2,x)
.a992		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a994		f0 0d		beq $a9a3	                beq _got_comma
.a996		38		sec		                sec
.a997		a5 0e		lda $0e		                lda ciblen
.a999		f5 00		sbc $00,x	                sbc 0,x
.a99b		a8		tay		                tay
.a99c		e8		inx		                inx
.a99d		e8		inx		                inx
.a99e		e8		inx		                inx
.a99f		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a9a0		4c 0c aa	jmp $aa0c	                jmp _check_command
.a9a3						_got_comma:
.a9a3		f6 02		inc $02,x	                inc 2,x
.a9a5		d0 02		bne $a9a9	                bne +
.a9a7		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a9a9						+
.a9a9		b5 01		lda $01,x	                lda 1,x
.a9ab		f0 02		beq $a9af	                beq +
.a9ad		d6 01		dec $01,x	                dec 1,x
.a9af						+
.a9af		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a9b1		a1 02		lda ($02,x)	                lda (2,x)
.a9b3		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a9b5		d0 14		bne $a9cb	                bne _para2_not_dollar
.a9b7		38		sec		                sec
.a9b8		a5 0e		lda $0e		                lda ciblen
.a9ba		f5 02		sbc $02,x	                sbc 2,x
.a9bc		a8		tay		                tay
.a9bd		c8		iny		                iny
.a9be		5a		phy		                phy
.a9bf		8a		txa		                txa
.a9c0		18		clc		                clc
.a9c1		69 06		adc #$06	                adc #06
.a9c3		aa		tax		                tax                     ; ( addr-t u-t para1 )
.a9c4		20 60 ad	jsr $ad60	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a9c7		7a		ply		                ply
.a9c8		4c 0c aa	jmp $aa0c	                jmp _check_command
.a9cb						_para2_not_dollar:
.a9cb		20 78 93	jsr $9378	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.a9ce		20 f6 9d	jsr $9df6	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.a9d1		20 f6 9d	jsr $9df6	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.a9d4		20 9d 8f	jsr $8f9d	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.a9d7		20 fc 8e	jsr $8efc	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.a9da		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.a9dd		20 78 93	jsr $9378	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.a9e0		20 d8 92	jsr $92d8	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.a9e3		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.a9e6		20 fc 8e	jsr $8efc	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.a9e9		20 96 87	jsr $8796	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.a9ec		b5 00		lda $00,x	                lda 0,x
.a9ee		15 01		ora $01,x	                ora 1,x
.a9f0		f0 08		beq $a9fa	                beq _second_number
.a9f2		8a		txa		                txa
.a9f3		18		clc		                clc
.a9f4		69 0c		adc #$0c	                adc #12
.a9f6		aa		tax		                tax                     ; back to ( addr-t u-t )
.a9f7		4c 14 ad	jmp $ad14	                jmp ed_error
.a9fa						_second_number:
.a9fa		e8		inx		                inx
.a9fb		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.a9fc		38		sec		                sec
.a9fd		a5 0e		lda $0e		                lda ciblen
.a9ff		f5 00		sbc $00,x	                sbc 0,x
.aa01		48		pha		                pha
.aa02		20 b3 93	jsr $93b3	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.aa05		20 3f 9e	jsr $9e3f	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.aa08		20 42 8c	jsr $8c42	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.aa0b		7a		ply		                ply
.aa0c						_check_command:
.aa0c		24 39		bit $39		                bit ed_flags
.aa0e		30 08		bmi $aa18	                bmi _check_command_have_arg
.aa10		a5 37		lda $37		                lda ed_cur
.aa12		95 02		sta $02,x	                sta 2,x
.aa14		a5 38		lda $38		                lda ed_cur+1
.aa16		95 03		sta $03,x	                sta 3,x
.aa18						_check_command_have_arg:
.aa18		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.aa1a		85 25		sta $25		                sta tmp1
.aa1c		da		phx		                phx
.aa1d		a2 00		ldx #$00	                ldx #00
.aa1f						_cmd_loop:
.aa1f		bd f8 ad	lda $adf8,x	                lda ed_cmd_list,x
.aa22		f0 07		beq $aa2b	                beq _illegal_command    ; zero marks end of list
.aa24		c5 25		cmp $25		                cmp tmp1
.aa26		f0 07		beq $aa2f	                beq _found_cmd
.aa28		e8		inx		                inx
.aa29		80 f4		bra $aa1f	                bra _cmd_loop
.aa2b						_illegal_command:
.aa2b		fa		plx		                plx
.aa2c		4c 10 ad	jmp $ad10	                jmp ed_error_2drop
.aa2f						_found_cmd:
.aa2f		8a		txa		                txa
.aa30		0a		asl a		                asl
.aa31		aa		tax		                tax                     ; X * 2 for table
.aa32		7c 03 ae	jmp ($ae03,x)	                jmp (ed_cmd_table,x)
.aa35						ed_next_command:
.aa35		e8		inx		                inx
.aa36		e8		inx		                inx
.aa37		e8		inx		                inx
.aa38		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.aa39		4c 43 a8	jmp $a843	                jmp ed_input_loop
.aa3c						ed_all_done:
.aa3c		64 0e		stz $0e		                stz ciblen
.aa3e		64 0f		stz $0f		                stz ciblen+1
.aa40		20 b3 93	jsr $93b3	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.aa43		a5 3a		lda $3a		                lda ed_base
.aa45		85 18		sta $18		                sta base
.aa47		60		rts		                rts
.aa48						ed_cmd_a:
.aa48		fa		plx		                plx
.aa49		e8		inx		                inx
.aa4a		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.aa4b						ed_entry_cmd_i:
.aa4b		20 96 ad	jsr $ad96	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.aa4e		20 3a 84	jsr $843a	                jsr xt_cr
.aa51						_next_string_loop:
.aa51		20 22 ad	jsr $ad22	                jsr ed_get_input
.aa54		b2 0c		lda ($0c)	                lda (cib)
.aa56		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.aa58		d0 16		bne $aa70	                bne _add_line
.aa5a		a4 0e		ldy $0e		                ldy ciblen
.aa5c		c0 01		cpy #$01	                cpy #01
.aa5e		d0 10		bne $aa70	                bne _add_line
.aa60		a4 0f		ldy $0f		                ldy ciblen+1
.aa62		d0 0c		bne $aa70	                bne _add_line
.aa64		e8		inx		                inx
.aa65		e8		inx		                inx
.aa66		a9 40		lda #$40	                lda #%01000000
.aa68		04 39		tsb $39		                tsb ed_flags
.aa6a		20 3a 84	jsr $843a	                jsr xt_cr
.aa6d		4c 43 a8	jmp $a843	                jmp ed_input_loop
.aa70						_add_line:
.aa70		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.aa73		20 1b 89	jsr $891b	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.aa76		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.aa79		20 1a 88	jsr $881a	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.aa7c		20 cd 83	jsr $83cd	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.aa7f		20 99 93	jsr $9399	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.aa82		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.aa85		20 24 92	jsr $9224	                jsr xt_store            ; ! ( addr-t u-t here )
.aa88		20 1b 89	jsr $891b	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.aa8b		a5 00		lda $00		                lda cp
.aa8d		18		clc		                clc
.aa8e		69 04		adc #$04	                adc #04
.aa90		85 00		sta $00		                sta cp
.aa92		90 02		bcc $aa96	                bcc +
.aa94		e6 01		inc $01		                inc cp+1
.aa96						+
.aa96		e6 37		inc $37		                inc ed_cur
.aa98		d0 02		bne $aa9c	                bne +
.aa9a		e6 38		inc $38		                inc ed_cur+1
.aa9c						+
.aa9c		20 1b 89	jsr $891b	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.aa9f		20 a0 86	jsr $86a0	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.aaa2		ca		dex		                dex
.aaa3		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.aaa4		a5 0c		lda $0c		                lda cib
.aaa6		95 00		sta $00,x	                sta 0,x
.aaa8		a5 0d		lda $0d		                lda cib+1
.aaaa		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.aaac		20 3a 92	jsr $923a	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.aaaf		ca		dex		                dex
.aab0		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aab1		a5 0e		lda $0e		                lda ciblen
.aab3		95 00		sta $00,x	                sta 0,x
.aab5		a5 0f		lda $0f		                lda ciblen+1
.aab7		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.aab9		20 12 8c	jsr $8c12	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.aabc		18		clc		                clc
.aabd		a5 00		lda $00		                lda cp
.aabf		65 0e		adc $0e		                adc ciblen
.aac1		85 00		sta $00		                sta cp
.aac3		90 06		bcc $aacb	                bcc +
.aac5		a5 01		lda $01		                lda cp+1
.aac7		65 0f		adc $0f		                adc ciblen+1
.aac9		85 01		sta $01		                sta cp+1
.aacb						+
.aacb		20 11 8d	jsr $8d11	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.aace		20 24 92	jsr $9224	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.aad1		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+
.aad4		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.aad7		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.aada		a5 0e		lda $0e		                lda ciblen
.aadc		95 02		sta $02,x	                sta 2,x
.aade		a5 0f		lda $0f		                lda ciblen+1
.aae0		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.aae2		20 24 92	jsr $9224	                jsr xt_store            ; ! ( addr-t u-t here )
.aae5		20 3a 84	jsr $843a	                jsr xt_cr
.aae8		4c 51 aa	jmp $aa51	                jmp _next_string_loop
.aaeb						ed_cmd_d:
.aaeb		fa		plx		                plx
.aaec		20 33 ad	jsr $ad33	                jsr ed_have_text
.aaef		20 88 ad	jsr $ad88	                jsr ed_no_line_zero
.aaf2		b5 00		lda $00,x	                lda 0,x
.aaf4		15 01		ora $01,x	                ora 1,x
.aaf6		d0 08		bne $ab00	                bne +
.aaf8		20 11 8d	jsr $8d11	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.aafb		20 3d ab	jsr $ab3d	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.aafe		80 33		bra $ab33	                bra _cmd_d_done
.ab00						+
.ab00		20 3e ad	jsr $ad3e	                jsr ed_is_valid_line      ; result is in C flag
.ab03		b0 03		bcs $ab08	                bcs _cmd_d_loop
.ab05		4c 10 ad	jmp $ad10	                jmp ed_error_2drop
.ab08						_cmd_d_loop:
.ab08		20 bb 93	jsr $93bb	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab0b		20 06 89	jsr $8906	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab0e		b5 00		lda $00,x	                lda 0,x
.ab10		15 01		ora $01,x	                ora 1,x
.ab12		d0 0d		bne $ab21	                bne _cmd_d_done_with_flag
.ab14		e8		inx		                inx
.ab15		e8		inx		                inx                     ; Get rid of the flag from >
.ab16		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.ab19		20 3d ab	jsr $ab3d	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.ab1c		20 e9 8c	jsr $8ce9	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.ab1f		80 e7		bra $ab08	                bra _cmd_d_loop
.ab21						_cmd_d_done_with_flag:
.ab21		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.ab22		e8		inx		                inx
.ab23		b5 02		lda $02,x	                lda 2,x
.ab25		d0 02		bne $ab29	                bne +
.ab27		d6 03		dec $03,x	                dec 3,x
.ab29						+
.ab29		d6 02		dec $02,x	                dec 2,x
.ab2b		b5 02		lda $02,x	                lda 2,x
.ab2d		85 37		sta $37		                sta ed_cur
.ab2f		b5 03		lda $03,x	                lda 3,x
.ab31		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.ab33						_cmd_d_done:
.ab33		a9 40		lda #$40	                lda #%01000000
.ab35		04 39		tsb $39		                tsb ed_flags
.ab37		20 3a 84	jsr $843a	                jsr xt_cr
.ab3a		4c 35 aa	jmp $aa35	                jmp ed_next_command
.ab3d						_cmd_d_common:
.ab3d		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.ab40		20 96 ad	jsr $ad96	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.ab43		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.ab46		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.ab49		20 e9 8c	jsr $8ce9	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.ab4c		20 96 ad	jsr $ad96	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.ab4f		20 24 92	jsr $9224	                jsr xt_store            ; ! ( addr-t u-t )
.ab52		60		rts		                rts
.ab53						ed_cmd_equ:
.ab53		fa		plx		                plx
.ab54		a5 35		lda $35		                lda ed_head
.ab56		05 36		ora $36		                ora ed_head+1
.ab58		d0 08		bne $ab62	                bne _cmd_equ_have_text
.ab5a		ca		dex		                dex
.ab5b		ca		dex		                dex
.ab5c		74 00		stz $00,x	                stz 0,x
.ab5e		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.ab60		80 21		bra $ab83	                bra _cmd_equ_done
.ab62						_cmd_equ_have_text:
.ab62		20 88 ad	jsr $ad88	                jsr ed_no_line_zero
.ab65		24 39		bit $39		                bit ed_flags
.ab67		30 0c		bmi $ab75	                bmi _cmd_equ_have_para
.ab69		ca		dex		                dex
.ab6a		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.ab6b		a5 37		lda $37		                lda ed_cur
.ab6d		95 00		sta $00,x	                sta 0,x
.ab6f		a5 38		lda $38		                lda ed_cur+1
.ab71		95 01		sta $01,x	                sta 1,x
.ab73		80 0e		bra $ab83	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.ab75						_cmd_equ_have_para:
.ab75		b5 00		lda $00,x	                lda 0,x
.ab77		15 01		ora $01,x	                ora 1,x
.ab79		d0 05		bne $ab80	                bne _cmd_equ_two_paras
.ab7b		20 11 8d	jsr $8d11	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.ab7e		80 03		bra $ab83	                bra _cmd_equ_done
.ab80						_cmd_equ_two_paras:
.ab80		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.ab83						_cmd_equ_done:
.ab83		20 3a 84	jsr $843a	                jsr xt_cr               ; number goes on new line
.ab86		20 fb 94	jsr $94fb	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.ab89		20 3a 84	jsr $843a	                jsr xt_cr
.ab8c		4c 35 aa	jmp $aa35	                jmp ed_next_command
.ab8f						ed_cmd_f:
.ab8f		fa		plx		                plx
.ab90		24 39		bit $39		                bit ed_flags
.ab92		30 17		bmi $abab	                bmi _cmd_f_have_para
.ab94		20 3a 84	jsr $843a	                jsr xt_cr
.ab97		20 78 93	jsr $9378	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.ab9a		20 9d 8f	jsr $8f9d	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.ab9d		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.aba0		20 fb 94	jsr $94fb	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.aba3		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.aba6		20 fc 8e	jsr $8efc	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.aba9		80 11		bra $abbc	                bra _cmd_f_done
.abab						_cmd_f_have_para:
.abab		20 11 8d	jsr $8d11	                jsr xt_over
.abae		20 3a 84	jsr $843a	                jsr xt_cr
.abb1		20 fb 94	jsr $94fb	                jsr xt_u_dot
.abb4		b5 02		lda $02,x	                lda 2,x
.abb6		95 06		sta $06,x	                sta 6,x
.abb8		b5 03		lda $03,x	                lda 3,x
.abba		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.abbc						_cmd_f_done:
.abbc		20 3a 84	jsr $843a	                jsr xt_cr
.abbf		4c 35 aa	jmp $aa35	                jmp ed_next_command
.abc2						ed_cmd_i:
.abc2		fa		plx		                plx
.abc3		e8		inx		                inx
.abc4		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.abc5		24 39		bit $39		                bit ed_flags
.abc7		30 08		bmi $abd1	                bmi _cmd_i_have_para
.abc9		a5 37		lda $37		                lda ed_cur
.abcb		95 00		sta $00,x	                sta 0,x
.abcd		a5 38		lda $38		                lda ed_cur+1
.abcf		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.abd1						_cmd_i_have_para:
.abd1		b5 00		lda $00,x	                lda 0,x
.abd3		15 01		ora $01,x	                ora 1,x
.abd5		f0 09		beq $abe0	                beq _cmd_i_done
.abd7		20 e9 8c	jsr $8ce9	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.abda		20 f6 9d	jsr $9df6	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.abdd		20 be 8b	jsr $8bbe	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.abe0						_cmd_i_done:
.abe0		4c 4b aa	jmp $aa4b	                jmp ed_entry_cmd_i
.abe3						ed_cmd_n:
.abe3		fa		plx		                plx
.abe4		a9 01		lda #$01	                lda #%00000001
.abe6		04 39		tsb $39		                tsb ed_flags
.abe8		80 05		bra $abef	                bra ed_cmd_p_entry_for_cmd_n
.abea						ed_cmd_p:
.abea		fa		plx		                plx
.abeb						ed_cmd_p_from_external:
.abeb		a9 01		lda #$01	                lda #%00000001
.abed		14 39		trb $39		                trb ed_flags
.abef						ed_cmd_p_entry_for_cmd_n:
.abef		20 33 ad	jsr $ad33	                jsr ed_have_text
.abf2		20 88 ad	jsr $ad88	                jsr ed_no_line_zero
.abf5		20 3a 84	jsr $843a	                jsr xt_cr
.abf8		b5 00		lda $00,x	                lda 0,x
.abfa		15 01		ora $01,x	                ora 1,x
.abfc		d0 10		bne $ac0e	                bne _cmd_p_loop
.abfe		b5 02		lda $02,x	                lda 2,x
.ac00		85 37		sta $37		                sta ed_cur
.ac02		b5 03		lda $03,x	                lda 3,x
.ac04		85 38		sta $38		                sta ed_cur+1
.ac06		20 11 8d	jsr $8d11	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ac09		20 37 ac	jsr $ac37	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac0c		80 26		bra $ac34	                bra _cmd_p_all_done
.ac0e						_cmd_p_loop:
.ac0e		20 bb 93	jsr $93bb	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ac11		20 06 89	jsr $8906	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.ac14		b5 00		lda $00,x	                lda 0,x
.ac16		15 01		ora $01,x	                ora 1,x
.ac18		d0 10		bne $ac2a	                bne _cmd_p_done
.ac1a		e8		inx		                inx
.ac1b		e8		inx		                inx                     ; Get rid of the flag from >
.ac1c		20 11 8d	jsr $8d11	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.ac1f		20 37 ac	jsr $ac37	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac22		f6 02		inc $02,x	                inc 2,x
.ac24		d0 02		bne $ac28	                bne +
.ac26		f6 03		inc $03,x	                inc 3,x
.ac28						+
.ac28		80 e4		bra $ac0e	                bra _cmd_p_loop
.ac2a						_cmd_p_done:
.ac2a		e8		inx		                inx
.ac2b		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.ac2c		b5 00		lda $00,x	                lda 0,x
.ac2e		85 37		sta $37		                sta ed_cur
.ac30		b5 01		lda $01,x	                lda 1,x
.ac32		85 38		sta $38		                sta ed_cur+1
.ac34						_cmd_p_all_done:
.ac34		4c 35 aa	jmp $aa35	                jmp ed_next_command
.ac37						_cmd_p_common:
.ac37		a5 39		lda $39		                lda ed_flags
.ac39		4a		lsr a		                lsr                     ; bit 0 now in carry
.ac3a		90 0b		bcc $ac47	                bcc _cmd_p_common_no_num
.ac3c		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.ac3f		20 fb 94	jsr $94fb	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.ac42		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.ac44		20 c5 86	jsr $86c5	                jsr emit_a
.ac47						_cmd_p_common_no_num:
.ac47		20 96 ad	jsr $ad96	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.ac4a		20 d6 ad	jsr $add6	                jsr ed_print_addr
.ac4d		60		rts		                rts
.ac4e						ed_cmd_q:
.ac4e		fa		plx		                plx
.ac4f		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.ac51		50 03		bvc $ac56	                bvc +
.ac53		4c 10 ad	jmp $ad10	                jmp ed_error_2drop
.ac56						+
.ac56		4c 3c aa	jmp $aa3c	                jmp ed_all_done            ; can't fall thru because of PLX
.ac59						ed_cmd_qq:
.ac59		fa		plx		                plx
.ac5a		4c 3c aa	jmp $aa3c	                jmp ed_all_done
.ac5d						ed_cmd_w:
.ac5d		fa		plx		                plx
.ac5e		20 33 ad	jsr $ad33	                jsr ed_have_text
.ac61		24 39		bit $39		                bit ed_flags
.ac63		30 13		bmi $ac78	                bmi _cmd_w_have_para
.ac65		b5 06		lda $06,x	                lda 6,x
.ac67		15 07		ora $07,x	                ora 7,x
.ac69		d0 03		bne $ac6e	                bne +
.ac6b		4c 10 ad	jmp $ad10	                jmp ed_error_2drop
.ac6e						+
.ac6e		b5 06		lda $06,x	                lda 6,x
.ac70		95 02		sta $02,x	                sta 2,x
.ac72		b5 07		lda $07,x	                lda 7,x
.ac74		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.ac76		80 08		bra $ac80	                bra _cmd_w_para_ready
.ac78						_cmd_w_have_para:
.ac78		b5 02		lda $02,x	                lda 2,x
.ac7a		95 06		sta $06,x	                sta 6,x
.ac7c		b5 03		lda $03,x	                lda 3,x
.ac7e		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.ac80						_cmd_w_para_ready:
.ac80		a9 35		lda #$35	                lda #<ed_head
.ac82		95 00		sta $00,x	                sta 0,x
.ac84		a9 00		lda #$00	                lda #>ed_head
.ac86		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ac88		20 11 8d	jsr $8d11	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ac8b		20 78 93	jsr $9378	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ac8e						_cmd_w_loop:
.ac8e		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ac91		b5 00		lda $00,x	                lda 0,x
.ac93		15 01		ora $01,x	                ora 1,x
.ac95		f0 55		beq $acec	                beq _cmd_w_eol
.ac97		20 bb 93	jsr $93bb	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ac9a		20 b0 94	jsr $94b0	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ac9d		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.aca0		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.aca3		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.aca6		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.aca9		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.acac		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.acaf		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.acb2		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.acb5		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.acb8		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.acbb		20 9d 8f	jsr $8f9d	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.acbe		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.acc1		20 78 93	jsr $9378	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.acc4		20 12 8c	jsr $8c12	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.acc7		20 fc 8e	jsr $8efc	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.acca		20 36 94	jsr $9436	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.accd		20 7a 9c	jsr $9c7a	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.acd0		20 5f 8e	jsr $8e5f	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.acd3		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.acd6		ca		dex		                dex
.acd7		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.acd8		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.acda		95 00		sta $00,x	                sta 0,x
.acdc		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.acde		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ace1		20 24 92	jsr $9224	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ace4		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ace7		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.acea		80 a2		bra $ac8e	                bra _cmd_w_loop
.acec						_cmd_w_eol:
.acec		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.acef		20 fc 8e	jsr $8efc	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.acf2		20 f6 8b	jsr $8bf6	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.acf5		b5 00		lda $00,x	                lda 0,x
.acf7		95 04		sta $04,x	                sta 4,x
.acf9		b5 01		lda $01,x	                lda 1,x
.acfb		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.acfd		20 3a 84	jsr $843a	                jsr xt_cr
.ad00		20 a0 86	jsr $86a0	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ad03		20 fb 94	jsr $94fb	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ad06		20 3a 84	jsr $843a	                jsr xt_cr
.ad09		a9 40		lda #$40	                lda #%01000000
.ad0b		14 39		trb $39		                trb ed_flags
.ad0d		4c 35 aa	jmp $aa35	                jmp ed_next_command
.ad10						ed_error_2drop:
.ad10		e8		inx		                inx
.ad11		e8		inx		                inx                     ; drop through to _error_1drop
.ad12						ed_error_1drop:
.ad12		e8		inx		                inx
.ad13		e8		inx		                inx                     ; drop through to _error
.ad14						ed_error:
.ad14		20 3a 84	jsr $843a	                jsr xt_cr
.ad17		a9 3f		lda #$3f	                lda #'?'
.ad19		20 c5 86	jsr $86c5	                jsr emit_a
.ad1c		20 3a 84	jsr $843a	                jsr xt_cr
.ad1f		4c 43 a8	jmp $a843	                jmp ed_input_loop
.ad22						ed_get_input:
.ad22		20 4e 8f	jsr $8f4e	                jsr xt_refill           ;  ( addr-t u-t f )
.ad25		b5 00		lda $00,x	                lda 0,x
.ad27		15 01		ora $01,x	                ora 1,x
.ad29		d0 05		bne $ad30	                bne +
.ad2b		7a		ply		                ply
.ad2c		7a		ply		                ply
.ad2d		4c 12 ad	jmp $ad12	                jmp ed_error_1drop
.ad30						+
.ad30		e8		inx		                inx
.ad31		e8		inx		                inx
.ad32		60		rts		                rts
.ad33						ed_have_text:
.ad33		a5 35		lda $35		                lda ed_head
.ad35		05 36		ora $36		                ora ed_head+1
.ad37		d0 04		bne $ad3d	                bne +
.ad39		7a		ply		                ply
.ad3a		7a		ply		                ply
.ad3b		80 d7		bra $ad14	                bra ed_error
.ad3d						+
.ad3d		60		rts		                rts
.ad3e						ed_is_valid_line:
.ad3e		38		sec		                sec                             ; default is legal line number
.ad3f		b5 00		lda $00,x	                lda 0,x
.ad41		15 01		ora $01,x	                ora 1,x
.ad43		f0 19		beq $ad5e	                beq _is_valid_line_nope_zero    ; ( n )
.ad45		20 a0 86	jsr $86a0	                jsr xt_dup                      ; DUP ( n n )
.ad48		20 60 ad	jsr $ad60	                jsr ed_last_line                  ; ( n n last )
.ad4b		20 3a 92	jsr $923a	                jsr xt_swap                     ; SWAP ( n last n )
.ad4e		20 ef 89	jsr $89ef	                jsr xt_less_than                ; < ( n f )
.ad51		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ad53		15 01		ora $01,x	                ora 1,x
.ad55		d0 05		bne $ad5c	                bne _is_valid_line_too_small
.ad57		e8		inx		                inx
.ad58		e8		inx		                inx                     ; DROP flag ( n )
.ad59		38		sec		                sec                     ; Who knows what's happened to C by now
.ad5a		80 03		bra $ad5f	                bra _is_valid_line_done ; only one exit from this routine
.ad5c						_is_valid_line_too_small:
.ad5c		e8		inx		                inx
.ad5d		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ad5e						_is_valid_line_nope_zero:
.ad5e		18		clc		                clc                     ; drop through to _is_valid_line_done
.ad5f						_is_valid_line_done:
.ad5f		60		rts		                rts
.ad60						ed_last_line:
.ad60		64 25		stz $25		                stz tmp1
.ad62		64 26		stz $26		                stz tmp1+1
.ad64		ca		dex		                dex
.ad65		ca		dex		                dex                     ; ( ? )
.ad66		a9 35		lda #$35	                lda #<ed_head
.ad68		95 00		sta $00,x	                sta 0,x
.ad6a		a9 00		lda #$00	                lda #>ed_head
.ad6c		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.ad6e						_last_line_loop:
.ad6e		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( addr | 0 )
.ad71		b5 00		lda $00,x	                lda 0,x
.ad73		15 01		ora $01,x	                ora 1,x
.ad75		f0 08		beq $ad7f	                beq _last_line_done
.ad77		e6 25		inc $25		                inc tmp1
.ad79		d0 02		bne $ad7d	                bne +
.ad7b		e6 26		inc $26		                inc tmp1+1
.ad7d						+
.ad7d		80 ef		bra $ad6e	                bra _last_line_loop
.ad7f						_last_line_done:
.ad7f		a5 25		lda $25		                lda tmp1
.ad81		95 00		sta $00,x	                sta 0,x
.ad83		a5 26		lda $26		                lda tmp1+1
.ad85		95 01		sta $01,x	                sta 1,x                 ; ( u )
.ad87		60		rts		                rts
.ad88						ed_no_line_zero:
.ad88		b5 02		lda $02,x	                lda 2,x
.ad8a		15 03		ora $03,x	                ora 3,x
.ad8c		d0 07		bne $ad95	                bne _no_line_zero_done
.ad8e		24 39		bit $39		                bit ed_flags
.ad90		10 03		bpl $ad95	                bpl _no_line_zero_done
.ad92		4c 10 ad	jmp $ad10	                jmp ed_error_2drop
.ad95						_no_line_zero_done:
.ad95		60		rts		                rts
.ad96						ed_num_to_addr:
.ad96		ca		dex		                dex
.ad97		ca		dex		                dex                     ; ( u ? )
.ad98		a9 35		lda #$35	                lda #<ed_head
.ad9a		95 00		sta $00,x	                sta 0,x
.ad9c		a9 00		lda #$00	                lda #>ed_head
.ad9e		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.ada0		b5 02		lda $02,x	                lda 2,x
.ada2		15 03		ora $03,x	                ora 3,x
.ada4		d0 05		bne $adab	                bne _num_to_addr_loop
.ada6		20 42 8c	jsr $8c42	                jsr xt_nip              ; ( addr-h )
.ada9		80 21		bra $adcc	                bra _num_to_addr_done
.adab						_num_to_addr_loop:
.adab		20 1a 88	jsr $881a	                jsr xt_fetch            ; @ ( u addr1 )
.adae		b5 00		lda $00,x	                lda 0,x
.adb0		15 01		ora $01,x	                ora 1,x
.adb2		d0 05		bne $adb9	                bne +
.adb4		20 42 8c	jsr $8c42	                jsr xt_nip              ; NIP ( addr1 )
.adb7		80 13		bra $adcc	                bra _num_to_addr_done
.adb9						+
.adb9		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( addr1 u )
.adbc		20 e9 8c	jsr $8ce9	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.adbf		b5 00		lda $00,x	                lda 0,x
.adc1		15 01		ora $01,x	                ora 1,x
.adc3		f0 05		beq $adca	                beq _num_to_addr_finished
.adc5		20 3a 92	jsr $923a	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.adc8		80 e1		bra $adab	                bra _num_to_addr_loop
.adca						_num_to_addr_finished:
.adca		e8		inx		                inx
.adcb		e8		inx		                inx                     ; ( addr )
.adcc						_num_to_addr_done:
.adcc		60		rts		                rts
.adcd						ed_para1_to_cur:
.adcd		b5 02		lda $02,x	                lda 2,x
.adcf		85 37		sta $37		                sta ed_cur
.add1		b5 03		lda $03,x	                lda 3,x
.add3		85 38		sta $38		                sta ed_cur+1
.add5		60		rts		                rts
.add6						ed_print_addr:
.add6		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.add9		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; ( addr+2 )
.addc		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( addr+2 addr+2 )
.addf		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.ade2		20 f5 8c	jsr $8cf5	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.ade5		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( addr+2 u-s )
.ade8		20 3a 92	jsr $923a	                jsr xt_swap             ; ( u-s addr+2 )
.adeb		20 1a 88	jsr $881a	                jsr xt_fetch            ; ( u-s addr-s )
.adee		20 3a 92	jsr $923a	                jsr xt_swap             ; ( addr-s u-s )
.adf1		20 d0 94	jsr $94d0	                jsr xt_type
.adf4		20 3a 84	jsr $843a	                jsr xt_cr
.adf7		60		rts		                rts
>adf8		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ae00		71 51 00
.ae03						ed_cmd_table:
>ae03		48 aa 8f ab c2 ab eb aa		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ae0b		ea ab e3 ab
>ae0f		53 ab 5d ac 4e ac 59 ac		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ae17						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ae17						xt_blk:
.ae17		a9 04		lda #$04	                lda #blk_offset
.ae19		4c fb d6	jmp $d6fb	                jmp push_upvar_tos
.ae1c						z_blk:
.ae1c						xt_blkbuffer:
.ae1c		ca		dex		                dex
.ae1d		ca		dex		                dex
.ae1e		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ae20		b1 08		lda ($08),y	                lda (up),y
.ae22		95 00		sta $00,x	                sta 0,x
.ae24		c8		iny		                iny             ; Move along to the next byte
.ae25		b1 08		lda ($08),y	                lda (up),y
.ae27		95 01		sta $01,x	                sta 1,x
.ae29		60		rts		z_blkbuffer:    rts
.ae2a						xt_block:
.ae2a		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae2c		b1 08		lda ($08),y	                lda (up),y
.ae2e		d5 00		cmp $00,x	                cmp 0,x
.ae30		d0 0f		bne $ae41	                bne _not_in_buffer
.ae32		c8		iny		                iny
.ae33		b1 08		lda ($08),y	                lda (up),y
.ae35		d5 01		cmp $01,x	                cmp 1,x
.ae37		d0 08		bne $ae41	                bne _not_in_buffer
.ae39		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae3b		b1 08		lda ($08),y	                lda (up),y
.ae3d		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ae3f		d0 30		bne $ae71	                bne _done       ; It's already in the buffer and in use.
.ae41						_not_in_buffer:
.ae41		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae43		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ae45		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ae47		d0 0c		bne $ae55	                bne _buffer_available ; Unused or not dirty = available
.ae49		20 1c ae	jsr $ae1c	                jsr xt_blkbuffer
.ae4c		20 26 b0	jsr $b026	                jsr xt_buffblocknum
.ae4f		20 1a 88	jsr $881a	                jsr xt_fetch
.ae52		20 13 b0	jsr $b013	                jsr xt_block_write
.ae55						_buffer_available:
.ae55		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae57		b5 00		lda $00,x	                lda 0,x
.ae59		91 08		sta ($08),y	                sta (up),y
.ae5b		c8		iny		                iny
.ae5c		b5 01		lda $01,x	                lda 1,x
.ae5e		91 08		sta ($08),y	                sta (up),y
.ae60		20 1c ae	jsr $ae1c	                jsr xt_blkbuffer
.ae63		20 3a 92	jsr $923a	                jsr xt_swap
.ae66		20 fb af	jsr $affb	                jsr xt_block_read
.ae69		a9 01		lda #$01	                lda #1
.ae6b		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae6d		91 08		sta ($08),y	                sta (up),y
.ae6f		ca		dex		                dex
.ae70		ca		dex		                dex
.ae71						_done:
.ae71		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ae73		b1 08		lda ($08),y	                lda (up),y
.ae75		95 00		sta $00,x	                sta 0,x
.ae77		c8		iny		                iny
.ae78		b1 08		lda ($08),y	                lda (up),y
.ae7a		95 01		sta $01,x	                sta 1,x
.ae7c		60		rts		z_block:        rts
.ae7d						xt_block_c65_init:
=0						io_blk_status = 0
=0						io_blk_action = 0
=0						io_blk_number = 0
=0						io_blk_buffer = 0
.ae7d		a9 ff		lda #$ff	                lda #$ff
.ae7f		8d 10 f0	sta $f010	                sta io_blk_status
.ae82		a9 00		lda #$00	                lda #$0
.ae84		8d 0f f0	sta $f00f	                sta io_blk_action
.ae87		ad 10 f0	lda $f010	                lda io_blk_status      ; $0 if OK, $ff otherwise
.ae8a		49 ff		eor #$ff	                eor #$ff            ; invert to forth true/false
.ae8c		ca		dex		                dex
.ae8d		ca		dex		                dex
.ae8e		95 00		sta $00,x	                sta 0,x             ; true ($ff) if OK, false (0) otherwise
.ae90		95 01		sta $01,x	                sta 1,x
.ae92		ca		dex		                dex
.ae93		ca		dex		                dex
.ae94		a9 b7		lda #$b7	                lda #<c65_blk_read
.ae96		95 00		sta $00,x	                sta 0,x
.ae98		a9 ae		lda #$ae	                lda #>c65_blk_read
.ae9a		95 01		sta $01,x	                sta 1,x
.ae9c		20 09 b0	jsr $b009	                jsr xt_block_read_vector
.ae9f		20 24 92	jsr $9224	                jsr xt_store
.aea2		ca		dex		                dex
.aea3		ca		dex		                dex
.aea4		a9 b3		lda #$b3	                lda #<c65_blk_write
.aea6		95 00		sta $00,x	                sta 0,x
.aea8		a9 ae		lda #$ae	                lda #>c65_blk_write
.aeaa		95 01		sta $01,x	                sta 1,x
.aeac		20 21 b0	jsr $b021	                jsr xt_block_write_vector
.aeaf		20 24 92	jsr $9224	                jsr xt_store
.aeb2						z_block_c65_init:
.aeb2		60		rts		                rts
.aeb3		a0 02		ldy #$02	c65_blk_write:  ldy #2
.aeb5		80 02		bra $aeb9	                bra c65_blk_rw
.aeb7		a0 01		ldy #$01	c65_blk_read:   ldy #1
.aeb9		b5 00		lda $00,x	c65_blk_rw:     lda 0,x                 ; ( addr blk# )
.aebb		8d 11 f0	sta $f011	                sta io_blk_number
.aebe		b5 01		lda $01,x	                lda 1,x
.aec0		8d 12 f0	sta $f012	                sta io_blk_number+1
.aec3		b5 02		lda $02,x	                lda 2,x
.aec5		8d 13 f0	sta $f013	                sta io_blk_buffer
.aec8		b5 03		lda $03,x	                lda 3,x
.aeca		8d 14 f0	sta $f014	                sta io_blk_buffer+1
.aecd		8c 0f f0	sty $f00f	                sty io_blk_action       ; trigger the r/w
.aed0		e8		inx		                inx                     ; clean up stack
.aed1		e8		inx		                inx
.aed2		e8		inx		                inx
.aed3		e8		inx		                inx
.aed4		60		rts		                rts
.aed5						xt_block_ramdrive_init:
.aed5		20 3f d8	jsr $d83f	                jsr underflow_1
.aed8		20 e2 a1	jsr $a1e2	                jsr sliteral_runtime
>aedb		e3 ae 18 01			                .word ramdrive_code, ramdrive_code_end-ramdrive_code
.aedf		20 b2 88	jsr $88b2	                jsr xt_evaluate
.aee2						z_block_ramdrive_init:
.aee2		60		rts		                rts
.aee3						ramdrive_code:
>aee3		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>aeeb		77 61 70 20 64 65 63 69 6d 61 6c
>aef6		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>aefd		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>af01		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>af09		20 72 61 6d 64 72 69 76 65
>af12		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>af1a		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>af28		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>af30		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af40		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>af50		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>af58		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>af67		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>af6f		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af7f		31 30 32 34 20 6d 6f 76 65 20 3b
>af8a		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>af92		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>afa2		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>afb2		20 21
>afb4		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>afbc		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>afcc		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>afdc		6f 72 20 21
>afe0		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>afe8		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>aff8		65 20 21
.affb						ramdrive_code_end:
.affb						xt_block_read:
.affb		a0 32		ldy #$32	                ldy #blockread_offset
.affd		b1 08		lda ($08),y	                lda (up),y
.afff		85 25		sta $25		                sta tmp1
.b001		c8		iny		                iny
.b002		b1 08		lda ($08),y	                lda (up),y
.b004		85 26		sta $26		                sta tmp1+1
.b006		6c 25 00	jmp ($0025)	                jmp (tmp1)
.b009						z_block_read:
.b009						xt_block_read_vector:
.b009		a9 32		lda #$32	                lda #blockread_offset
.b00b		4c fb d6	jmp $d6fb	                jmp push_upvar_tos
.b00e						z_block_read_vector:
.b00e						xt_block_word_error:
.b00e		a9 0c		lda #$0c	                lda #err_blockwords
.b010		4c 55 d8	jmp $d855	                jmp error       ; no RTS needed
.b013						xt_block_write:
.b013		a0 34		ldy #$34	                ldy #blockwrite_offset
.b015		b1 08		lda ($08),y	                lda (up),y
.b017		85 25		sta $25		                sta tmp1
.b019		c8		iny		                iny
.b01a		b1 08		lda ($08),y	                lda (up),y
.b01c		85 26		sta $26		                sta tmp1+1
.b01e		6c 25 00	jmp ($0025)	                jmp (tmp1)
.b021						z_block_write:
.b021						xt_block_write_vector:
.b021		a9 34		lda #$34	                lda #blockwrite_offset
.b023		4c fb d6	jmp $d6fb	                jmp push_upvar_tos
.b026						z_block_write_vector:
.b026						xt_buffblocknum:
.b026		a9 2e		lda #$2e	                lda #buffblocknum_offset
.b028		4c fb d6	jmp $d6fb	                jmp push_upvar_tos
.b02b						z_buffblocknum:
.b02b						xt_buffer:
.b02b		a0 30		ldy #$30	                ldy #buffstatus_offset
.b02d		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b02f		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b031		d0 0c		bne $b03f	                bne _buffer_available ; Unused or not dirty = available
.b033		20 1c ae	jsr $ae1c	                jsr xt_blkbuffer
.b036		20 26 b0	jsr $b026	                jsr xt_buffblocknum
.b039		20 1a 88	jsr $881a	                jsr xt_fetch
.b03c		20 13 b0	jsr $b013	                jsr xt_block_write
.b03f						_buffer_available:
.b03f		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.b041		b5 00		lda $00,x	                lda 0,x
.b043		91 08		sta ($08),y	                sta (up),y
.b045		c8		iny		                iny
.b046		b5 01		lda $01,x	                lda 1,x
.b048		91 08		sta ($08),y	                sta (up),y
.b04a		a9 01		lda #$01	                lda #1
.b04c		a0 30		ldy #$30	                ldy #buffstatus_offset
.b04e		91 08		sta ($08),y	                sta (up),y
.b050		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.b052		b1 08		lda ($08),y	                lda (up),y
.b054		95 00		sta $00,x	                sta 0,x
.b056		c8		iny		                iny
.b057		b1 08		lda ($08),y	                lda (up),y
.b059		95 01		sta $01,x	                sta 1,x
.b05b		60		rts		z_buffer:       rts
.b05c						xt_buffstatus:
.b05c		a9 30		lda #$30	                lda #buffstatus_offset
.b05e		4c fb d6	jmp $d6fb	                jmp push_upvar_tos
.b061						z_buffstatus:
.b061						xt_empty_buffers:
.b061		a0 30		ldy #$30	                ldy #buffstatus_offset
.b063		a9 00		lda #$00	                lda #0
.b065		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b067						z_empty_buffers:
.b067		60		rts		                rts
.b068						xt_flush:
.b068		20 c3 b0	jsr $b0c3	                jsr xt_save_buffers
.b06b		a0 30		ldy #$30	                ldy #buffstatus_offset
.b06d		a9 00		lda #$00	                lda #0
.b06f		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b071						z_flush:
.b071		60		rts		                rts
.b072						xt_list:
.b072		20 3f d8	jsr $d83f	                jsr underflow_1
.b075		20 de b0	jsr $b0de	                jsr xt_scr
.b078		20 24 92	jsr $9224	                jsr xt_store
.b07b		20 7d b1	jsr $b17d	                jsr xt_editor_l
.b07e		60		rts		z_list:         rts
.b07f						xt_load:
.b07f		20 3f d8	jsr $d83f	                jsr underflow_1
.b082		a0 05		ldy #$05	                ldy #blk_offset+1
.b084		b1 08		lda ($08),y	                lda (up),y
.b086		48		pha		                pha
.b087		88		dey		                dey
.b088		b1 08		lda ($08),y	                lda (up),y
.b08a		48		pha		                pha
.b08b		b5 00		lda $00,x	                lda 0,x
.b08d		91 08		sta ($08),y	                sta (up),y
.b08f		c8		iny		                iny
.b090		b5 01		lda $01,x	                lda 1,x
.b092		91 08		sta ($08),y	                sta (up),y
.b094		20 2a ae	jsr $ae2a	                jsr xt_block
.b097		ca		dex		                dex
.b098		ca		dex		                dex
.b099		a9 04		lda #$04	                lda #4
.b09b		95 01		sta $01,x	                sta 1,x
.b09d		74 00		stz $00,x	                stz 0,x
.b09f		20 ac 88	jsr $88ac	                jsr load_evaluate
.b0a2		a0 04		ldy #$04	                ldy #blk_offset
.b0a4		68		pla		                pla
.b0a5		91 08		sta ($08),y	                sta (up),y
.b0a7		c8		iny		                iny
.b0a8		68		pla		                pla
.b0a9		91 08		sta ($08),y	                sta (up),y
.b0ab		88		dey		                dey
.b0ac		11 08		ora ($08),y	                ora (up),y
.b0ae		f0 12		beq $b0c2	                beq _done
.b0b0		ca		dex		                dex
.b0b1		ca		dex		                dex
.b0b2		a0 04		ldy #$04	                ldy #blk_offset
.b0b4		b1 08		lda ($08),y	                lda (up),y
.b0b6		95 00		sta $00,x	                sta 0,x
.b0b8		c8		iny		                iny
.b0b9		b1 08		lda ($08),y	                lda (up),y
.b0bb		95 01		sta $01,x	                sta 1,x
.b0bd		20 2a ae	jsr $ae2a	                jsr xt_block
.b0c0		e8		inx		                inx
.b0c1		e8		inx		                inx
.b0c2						_done:
.b0c2		60		rts		z_load:         rts
.b0c3						xt_save_buffers:
.b0c3		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0c5		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b0c7		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b0c9		d0 12		bne $b0dd	                bne _done       ; Either not used or not dirty = done!
.b0cb		20 1c ae	jsr $ae1c	                jsr xt_blkbuffer
.b0ce		20 26 b0	jsr $b026	                jsr xt_buffblocknum
.b0d1		20 1a 88	jsr $881a	                jsr xt_fetch
.b0d4		20 13 b0	jsr $b013	                jsr xt_block_write
.b0d7		a9 01		lda #$01	                lda #1
.b0d9		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0db		91 08		sta ($08),y	                sta (up),y
.b0dd						_done:
.b0dd		60		rts		z_save_buffers: rts
.b0de						xt_scr:
.b0de		a9 06		lda #$06	                lda #scr_offset
.b0e0		4c fb d6	jmp $d6fb	                jmp push_upvar_tos
.b0e3						z_scr:
.b0e3						xt_thru:
.b0e3		20 44 d8	jsr $d844	                jsr underflow_2
.b0e6		b5 01		lda $01,x	                lda 1,x
.b0e8		48		pha		                pha
.b0e9		b5 00		lda $00,x	                lda 0,x
.b0eb		48		pha		                pha
.b0ec		e8		inx		                inx
.b0ed		e8		inx		                inx
.b0ee						_thru_loop:
.b0ee		b5 01		lda $01,x	                lda 1,x
.b0f0		48		pha		                pha
.b0f1		b5 00		lda $00,x	                lda 0,x
.b0f3		48		pha		                pha
.b0f4		20 7f b0	jsr $b07f	                jsr xt_load
.b0f7		68		pla		                pla
.b0f8		85 25		sta $25		                sta tmp1
.b0fa		68		pla		                pla
.b0fb		85 26		sta $26		                sta tmp1+1
.b0fd		68		pla		                pla
.b0fe		85 27		sta $27		                sta tmp2
.b100		68		pla		                pla
.b101		85 28		sta $28		                sta tmp2+1
.b103		c5 26		cmp $26		                cmp tmp1+1
.b105		d0 08		bne $b10f	                bne _next_screen
.b107		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b109		c5 25		cmp $25		                cmp tmp1
.b10b		d0 02		bne $b10f	                bne _next_screen
.b10d		80 18		bra $b127	                bra _done       ; We just did the last screen.
.b10f						_next_screen:
.b10f		a5 28		lda $28		                lda tmp2+1
.b111		48		pha		                pha
.b112		a5 27		lda $27		                lda tmp2
.b114		48		pha		                pha
.b115		e6 25		inc $25		                inc tmp1
.b117		d0 02		bne $b11b	                bne +
.b119		e6 26		inc $26		                inc tmp1+1
.b11b						+
.b11b		ca		dex		                dex
.b11c		ca		dex		                dex
.b11d		a5 25		lda $25		                lda tmp1
.b11f		95 00		sta $00,x	                sta 0,x
.b121		a5 26		lda $26		                lda tmp1+1
.b123		95 01		sta $01,x	                sta 1,x
.b125		80 c7		bra $b0ee	                bra _thru_loop
.b127						_done:
.b127		60		rts		z_thru:         rts
.b128						xt_update:
.b128		a0 30		ldy #$30	                ldy #buffstatus_offset
.b12a		b1 08		lda ($08),y	                lda (up),y
.b12c		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b12e		91 08		sta ($08),y	                sta (up),y
.b130		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b131						xt_editor_screen_helper:
.b131		20 a0 86	jsr $86a0	                jsr xt_dup
.b134		20 de b0	jsr $b0de	                jsr xt_scr
.b137		20 24 92	jsr $9224	                jsr xt_store
.b13a		4c 2b b0	jmp $b02b	                jmp xt_buffer
.b13d						xt_editor_enter_screen:
.b13d		20 31 b1	jsr $b131	                jsr xt_editor_screen_helper
.b140		20 9a 86	jsr $869a	                jsr xt_drop
.b143		64 35		stz $35		                stz ed_head
.b145						_prompt_loop:
.b145		ca		dex		                dex
.b146		ca		dex		                dex
.b147		a5 35		lda $35		                lda ed_head
.b149		95 00		sta $00,x	                sta 0,x
.b14b		74 01		stz $01,x	                stz 1,x
.b14d		20 10 b2	jsr $b210	                jsr xt_editor_o
.b150		e6 35		inc $35		                inc ed_head
.b152		a9 10		lda #$10	                lda #16
.b154		c5 35		cmp $35		                cmp ed_head
.b156		d0 ed		bne $b145	                bne _prompt_loop
.b158						z_editor_enter_screen:
.b158		60		rts		                rts
.b159						xt_editor_erase_screen:
.b159		20 31 b1	jsr $b131	                jsr xt_editor_screen_helper
.b15c		ca		dex		                dex
.b15d		ca		dex		                dex
.b15e		74 00		stz $00,x	                stz 0,x
.b160		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b162		95 01		sta $01,x	                sta 1,x
.b164		20 b2 87	jsr $87b2	                jsr xt_blank
.b167		20 28 b1	jsr $b128	                jsr xt_update
.b16a						z_editor_erase_screen:
.b16a		60		rts		                rts
.b16b						xt_editor_el:
.b16b		20 f7 b1	jsr $b1f7	                jsr xt_editor_line
.b16e		ca		dex		                dex
.b16f		ca		dex		                dex
.b170		a9 40		lda #$40	                lda #64
.b172		95 00		sta $00,x	                sta 0,x
.b174		74 01		stz $01,x	                stz 1,x
.b176		20 b2 87	jsr $87b2	                jsr xt_blank
.b179		20 28 b1	jsr $b128	                jsr xt_update
.b17c		60		rts		z_editor_el:    rts
.b17d						xt_editor_l:
.b17d		ca		dex		                dex             ; Put SCR on the stack.
.b17e		ca		dex		                dex
.b17f		a0 06		ldy #$06	                ldy #scr_offset
.b181		b1 08		lda ($08),y	                lda (up),y
.b183		95 00		sta $00,x	                sta 0,x
.b185		c8		iny		                iny
.b186		b1 08		lda ($08),y	                lda (up),y
.b188		95 01		sta $01,x	                sta 1,x
.b18a		20 2a ae	jsr $ae2a	                jsr xt_block    ; Get the current screen.
.b18d		20 3a 84	jsr $843a	                jsr xt_cr
.b190		80 08		bra $b19a	                bra _after_screen_msg
.b192						_screen_msg:
>b192		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b19a						_after_screen_msg:
.b19a		20 e2 a1	jsr $a1e2	                jsr sliteral_runtime
>b19d		92 b1 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.b1a1		20 d0 94	jsr $94d0	                jsr xt_type
.b1a4		20 de b0	jsr $b0de	                jsr xt_scr
.b1a7		20 1a 88	jsr $881a	                jsr xt_fetch
.b1aa		ca		dex		                dex
.b1ab		ca		dex		                dex
.b1ac		a9 04		lda #$04	                lda #4          ; four spaces
.b1ae		95 00		sta $00,x	                sta 0,x
.b1b0		74 01		stz $01,x	                stz 1,x
.b1b2		20 07 95	jsr $9507	                jsr xt_u_dot_r
.b1b5		64 29		stz $29		                stz tmp3
.b1b7						_line_loop:
.b1b7		20 3a 84	jsr $843a	                jsr xt_cr
.b1ba		ca		dex		                dex
.b1bb		ca		dex		                dex
.b1bc		ca		dex		                dex
.b1bd		ca		dex		                dex
.b1be		74 03		stz $03,x	                stz 3,x
.b1c0		a5 29		lda $29		                lda tmp3
.b1c2		95 02		sta $02,x	                sta 2,x
.b1c4		74 01		stz $01,x	                stz 1,x
.b1c6		a9 02		lda #$02	                lda #2
.b1c8		95 00		sta $00,x	                sta 0,x
.b1ca		20 07 95	jsr $9507	                jsr xt_u_dot_r
.b1cd		20 d7 91	jsr $91d7	                jsr xt_space
.b1d0		20 a0 86	jsr $86a0	                jsr xt_dup
.b1d3		ca		dex		                dex
.b1d4		ca		dex		                dex
.b1d5		a9 40		lda #$40	                lda #64
.b1d7		95 00		sta $00,x	                sta 0,x
.b1d9		74 01		stz $01,x	                stz 1,x
.b1db		20 d0 94	jsr $94d0	                jsr xt_type
.b1de		18		clc		                clc
.b1df		a9 40		lda #$40	                lda #64
.b1e1		75 00		adc $00,x	                adc 0,x
.b1e3		95 00		sta $00,x	                sta 0,x
.b1e5		90 02		bcc $b1e9	                bcc +
.b1e7		f6 01		inc $01,x	                inc 1,x
.b1e9						+
.b1e9		e6 29		inc $29		                inc tmp3
.b1eb		a5 29		lda $29		                lda tmp3
.b1ed		c9 10		cmp #$10	                cmp #16
.b1ef		d0 c6		bne $b1b7	                bne _line_loop
.b1f1		20 3a 84	jsr $843a	                jsr xt_cr
.b1f4		e8		inx		                inx
.b1f5		e8		inx		                inx
.b1f6		60		rts		z_editor_l:            rts
.b1f7						xt_editor_line:
.b1f7		20 3f d8	jsr $d83f	                jsr underflow_1
.b1fa		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b1fc						_shift_tos_left:
.b1fc		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b1fe		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b200		88		dey		                dey
.b201		d0 f9		bne $b1fc	                bne _shift_tos_left
.b203		20 de b0	jsr $b0de	                jsr xt_scr
.b206		20 1a 88	jsr $881a	                jsr xt_fetch
.b209		20 2a ae	jsr $ae2a	                jsr xt_block
.b20c		20 5f 8e	jsr $8e5f	                jsr xt_plus
.b20f		60		rts		z_editor_line:  rts
.b210						xt_editor_o:
.b210		20 3a 84	jsr $843a	                jsr xt_cr
.b213		20 a0 86	jsr $86a0	                jsr xt_dup
.b216		20 c1 9d	jsr $9dc1	                jsr xt_two
.b219		20 07 95	jsr $9507	                jsr xt_u_dot_r
.b21c		20 d7 91	jsr $91d7	                jsr xt_space
.b21f		a9 2a		lda #$2a	                lda #'*'
.b221		20 c5 86	jsr $86c5	                jsr emit_a
.b224		20 d7 91	jsr $91d7	                jsr xt_space
.b227		20 f7 b1	jsr $b1f7	                jsr xt_editor_line
.b22a		20 a0 86	jsr $86a0	                jsr xt_dup      ; Save a copy of the line address for later.
.b22d		ca		dex		                dex
.b22e		ca		dex		                dex
.b22f		a9 40		lda #$40	                lda #64         ; chars/line
.b231		95 00		sta $00,x	                sta 0,x
.b233		74 01		stz $01,x	                stz 1,x
.b235		20 e4 80	jsr $80e4	                jsr xt_accept
.b238		20 a0 86	jsr $86a0	                jsr xt_dup
.b23b		20 7a 9c	jsr $9c7a	                jsr xt_not_rote ; -rot
.b23e		20 5f 8e	jsr $8e5f	                jsr xt_plus
.b241		ca		dex		                dex
.b242		ca		dex		                dex
.b243		a9 40		lda #$40	                lda #64         ; chars/line
.b245		95 00		sta $00,x	                sta 0,x
.b247		74 01		stz $01,x	                stz 1,x
.b249		20 9d 8f	jsr $8f9d	                jsr xt_rot
.b24c		20 f6 8b	jsr $8bf6	                jsr xt_minus
.b24f		20 b2 87	jsr $87b2	                jsr xt_blank
.b252		20 28 b1	jsr $b128	                jsr xt_update
.b255		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b256						xt_also:
.b256		20 81 b2	jsr $b281	                jsr xt_get_order
.b259		20 11 8d	jsr $8d11	                jsr xt_over
.b25c		20 3a 92	jsr $923a	                jsr xt_swap
.b25f		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.b262		20 8a b3	jsr $b38a	                jsr xt_set_order
.b265		60		rts		z_also:         rts
.b266						xt_definitions:
.b266		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b268		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b26a		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b26c		91 08		sta ($08),y	                sta (up),y
.b26e		60		rts		z_definitions:  rts
.b26f						xt_forth:
.b26f		a0 23		ldy #$23	                ldy #search_order_offset
.b271		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b273		91 08		sta ($08),y	                sta (up),y
.b275						z_forth:
.b275		60		rts		                rts
.b276						xt_get_current:
.b276		ca		dex		                dex
.b277		ca		dex		                dex
.b278		a0 08		ldy #$08	                ldy #current_offset
.b27a		b1 08		lda ($08),y	                lda (up),y
.b27c		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b27e		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b280		60		rts		z_get_current:  rts
.b281						xt_get_order:
.b281		a0 22		ldy #$22	                ldy #num_order_offset
.b283		b1 08		lda ($08),y	                lda (up),y
.b285		85 25		sta $25		                sta tmp1
.b287		f0 16		beq $b29f	                beq _done       ; If zero, there are no wordlists.
.b289						_loop:
.b289		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b28b		a9 23		lda #$23	                lda #search_order_offset
.b28d		18		clc		                clc
.b28e		65 25		adc $25		                adc tmp1
.b290		a8		tay		                tay
.b291		ca		dex		                dex
.b292		ca		dex		                dex
.b293		b1 08		lda ($08),y	                lda (up),y
.b295		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b297		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b299		a9 00		lda #$00	                lda #0
.b29b		c5 25		cmp $25		                cmp tmp1
.b29d		d0 ea		bne $b289	                bne _loop
.b29f						_done:
.b29f		ca		dex		                dex
.b2a0		ca		dex		                dex
.b2a1		a0 22		ldy #$22	                ldy #num_order_offset
.b2a3		b1 08		lda ($08),y	                lda (up),y
.b2a5		95 00		sta $00,x	                sta 0,x
.b2a7		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b2a9		60		rts		z_get_order:    rts
.b2aa						xt_only:
.b2aa		20 90 93	jsr $9390	                jsr xt_true
.b2ad		20 8a b3	jsr $b38a	                jsr xt_set_order
.b2b0		60		rts		z_only:         rts
.b2b1						xt_order:
.b2b1		20 3a 84	jsr $843a	                jsr xt_cr
.b2b4		20 81 b2	jsr $b281	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.b2b7		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.b2b9		f0 1e		beq $b2d9	                beq _drop_done
.b2bb		a8		tay		                tay
.b2bc						_loop:
.b2bc		e8		inx		                inx
.b2bd		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.b2be		b5 00		lda $00,x	                lda 0,x
.b2c0		5a		phy		                phy
.b2c1		20 dc b2	jsr $b2dc	                jsr order_print_wid_string   ; internal helper function
.b2c4		7a		ply		                ply
.b2c5		88		dey		                dey
.b2c6		d0 f4		bne $b2bc	                bne _loop
.b2c8		20 d7 91	jsr $91d7	                jsr xt_space
.b2cb		20 d7 91	jsr $91d7	                jsr xt_space
.b2ce		20 76 b2	jsr $b276	                jsr xt_get_current      ; ( wid )
.b2d1		b5 00		lda $00,x	                lda 0,x
.b2d3		20 dc b2	jsr $b2dc	                jsr order_print_wid_string
.b2d6		20 3a 84	jsr $843a	                jsr xt_cr
.b2d9						_drop_done:
.b2d9		e8		inx		                inx
.b2da		e8		inx		                inx
.b2db						z_order:
.b2db		60		rts		                rts
.b2dc						order_print_wid_string:
.b2dc		c9 04		cmp #$04	                cmp #4
.b2de		90 09		bcc $b2e9	                bcc _output_string      ; less than 4, print a real string
.b2e0		ca		dex		                dex
.b2e1		ca		dex		                dex
.b2e2		95 00		sta $00,x	                sta 0,x
.b2e4		74 01		stz $01,x	                stz 1,x
.b2e6		4c fb 94	jmp $94fb	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.b2e9						_output_string:
.b2e9		a8		tay		                tay
.b2ea		b9 f0 b2	lda $b2f0,y	                lda _wid_data,y
.b2ed		4c 7b d8	jmp $d87b	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b2f0						_wid_data:
>b2f0		04				        .byte str_wid_forth            ; WID 0: "Forth"
>b2f1		05				        .byte str_wid_editor           ; WID 1: "Editor"
>b2f2		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>b2f3		07				        .byte str_wid_root             ; WID 3: "Root"
.b2f4						xt_previous:
.b2f4		20 81 b2	jsr $b281	                jsr xt_get_order
.b2f7		20 42 8c	jsr $8c42	                jsr xt_nip
.b2fa		20 e9 8c	jsr $8ce9	                jsr xt_one_minus
.b2fd		20 8a b3	jsr $b38a	                jsr xt_set_order
.b300		60		rts		z_previous:     rts
.b301						xt_root_wordlist:
.b301		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b302		ca		dex		                dex
.b303		a9 03		lda #$03	                lda #3
.b305		95 00		sta $00,x	                sta 0,x
.b307		74 01		stz $01,x	                stz 1,x
.b309						z_root_wordlist:
.b309		60		rts		                rts
.b30a						xt_search_wordlist:
.b30a		20 49 d8	jsr $d849	                jsr underflow_3
.b30d		a5 08		lda $08		                lda up
.b30f		18		clc		                clc
.b310		69 0a		adc #$0a	                adc #wordlists_offset
.b312		85 27		sta $27		                sta tmp2
.b314		a5 09		lda $09		                lda up+1
.b316		69 00		adc #$00	                adc #0          ; Adding carry
.b318		85 28		sta $28		                sta tmp2+1
.b31a		b5 00		lda $00,x	                lda 0,x
.b31c		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b31d		65 27		adc $27		                adc tmp2
.b31f		85 27		sta $27		                sta tmp2
.b321		90 02		bcc $b325	                bcc +
.b323		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b325						+
.b325		e8		inx		                inx
.b326		e8		inx		                inx
.b327		b5 00		lda $00,x	                lda 0,x
.b329		15 01		ora $01,x	                ora 1,x
.b32b		f0 4e		beq $b37b	                beq _done
.b32d		a5 27		lda $27		                lda tmp2
.b32f		05 28		ora $28		                ora tmp2+1
.b331		f0 48		beq $b37b	                beq _done
.b333		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b335		85 25		sta $25		                sta tmp1
.b337		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b339		d0 02		bne $b33d	                bne +
.b33b		e6 28		inc $28		                inc tmp2+1
.b33d						+
.b33d		b2 27		lda ($27)	                lda (tmp2)
.b33f		85 26		sta $26		                sta tmp1+1
.b341		20 21 d7	jsr $d721	                jsr find_header_name
.b344		f0 31		beq $b377	                beq _fail_done
.b346		e8		inx		                inx
.b347		e8		inx		                inx
.b348		a5 25		lda $25		                lda tmp1
.b34a		95 00		sta $00,x	                sta 0,x
.b34c		a5 26		lda $26		                lda tmp1+1
.b34e		95 01		sta $01,x	                sta 1,x
.b350		20 a0 86	jsr $86a0	                jsr xt_dup              ; ( nt nt )
.b353		20 33 9c	jsr $9c33	                jsr xt_name_to_int      ; ( nt xt )
.b356		20 3a 92	jsr $923a	                jsr xt_swap             ; ( xt nt )
.b359		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b35b		f6 00		inc $00,x	                inc 0,x
.b35d		d0 02		bne $b361	                bne +
.b35f		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b361						+
.b361		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b363		29 04		and #$04	                and #IM
.b365		d0 08		bne $b36f	                bne _immediate          ; bit set, we're immediate
.b367		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b369		95 00		sta $00,x	                sta 0,x
.b36b		95 01		sta $01,x	                sta 1,x
.b36d		80 0e		bra $b37d	                bra _done_nodrop
.b36f						_immediate:
.b36f		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b371		95 00		sta $00,x	                sta 0,x
.b373		74 01		stz $01,x	                stz 1,x
.b375		80 06		bra $b37d	                bra _done_nodrop
.b377						_fail_done:
.b377		74 02		stz $02,x	                stz 2,x         ; failure flag
.b379		74 03		stz $03,x	                stz 3,x
.b37b						_done:
.b37b		e8		inx		                inx
.b37c		e8		inx		                inx
.b37d						_done_nodrop:
.b37d						z_search_wordlist:
.b37d		60		rts		                rts
.b37e						xt_set_current:
.b37e		20 3f d8	jsr $d83f	                jsr underflow_1
.b381		a0 08		ldy #$08	                ldy #current_offset
.b383		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b385		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b387		e8		inx		                inx
.b388		e8		inx		                inx
.b389		60		rts		z_set_current:  rts
.b38a						xt_set_order:
.b38a		a9 ff		lda #$ff	                lda #$FF
.b38c		d5 01		cmp $01,x	                cmp 1,x
.b38e		d0 12		bne $b3a2	                bne _start
.b390		d5 00		cmp $00,x	                cmp 0,x
.b392		d0 0e		bne $b3a2	                bne _start
.b394		ca		dex		                dex             ; Make room for the count.
.b395		ca		dex		                dex
.b396		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b398		a9 03		lda #$03	                lda #3
.b39a		95 02		sta $02,x	                sta 2,x
.b39c		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b39e		a9 01		lda #$01	                lda #1
.b3a0		95 00		sta $00,x	                sta 0,x
.b3a2						_start:
.b3a2		a0 22		ldy #$22	                ldy #num_order_offset
.b3a4		b5 00		lda $00,x	                lda 0,x
.b3a6		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b3a8		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b3aa		e8		inx		                inx             ; Drop the count off the data stack.
.b3ab		e8		inx		                inx
.b3ac		a5 25		lda $25		                lda tmp1
.b3ae		f0 0d		beq $b3bd	                beq _done       ; If zero, there are no wordlists.
.b3b0		a0 23		ldy #$23	                ldy #search_order_offset
.b3b2						_loop:
.b3b2		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b3b4		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b3b6		c8		iny		                iny
.b3b7		e8		inx		                inx
.b3b8		e8		inx		                inx
.b3b9		c6 25		dec $25		                dec tmp1
.b3bb		d0 f5		bne $b3b2	                bne _loop
.b3bd						_done:
.b3bd		60		rts		z_set_order:    rts
.b3be						xt_to_order:
.b3be		20 78 93	jsr $9378	                jsr xt_to_r
.b3c1		20 81 b2	jsr $b281	                jsr xt_get_order
.b3c4		20 fc 8e	jsr $8efc	                jsr xt_r_from
.b3c7		20 3a 92	jsr $923a	                jsr xt_swap
.b3ca		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.b3cd		20 8a b3	jsr $b38a	                jsr xt_set_order
.b3d0		60		rts		z_to_order:     rts
.b3d1						xt_wordlist:
.b3d1		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b3d3		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b3d5		c9 0c		cmp #$0c	                cmp #max_wordlists
.b3d7		d0 05		bne $b3de	                bne _ok
.b3d9		a9 0b		lda #$0b	                lda #err_wordlist
.b3db		4c 55 d8	jmp $d855	                jmp error
.b3de						_ok:
.b3de		1a		inc a		                ina             ; Increment the wordlist#
.b3df		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b3e1		ca		dex		                dex             ; and put it on the stack.
.b3e2		ca		dex		                dex
.b3e3		95 00		sta $00,x	                sta 0,x
.b3e5		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b3e7		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=$0000						ram_start = $0000          ; start of installed RAM, must include zpage
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=32767						ram_end   = $8000-1        ; end of installed RAM
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=512						buffer0   = stack0+$100      ; input buffer ($0200-$02ff)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b3e8						cold_zp_table:
>b3e8	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b3ea	0002	cb bb				dp:         .word dictionary_start  ; Dictionary Pointer
>b3ec	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b3ee	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b3f0	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b3f2	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b3f4	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b3f6	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b3f8	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b3fa	0012	27 f0				output:     .word kernel_putc       ; vector for EMIT
>b3fc	0014	2b f0				input:      .word kernel_getc       ; vector for KEY
>b3fe	0016	39 f0				havekey:    .word kernel_kbhit      ; vector for KEY?
>b400	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b402	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b404	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>b406	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b407	001f					loopctrl:   .byte ?         ; Offset from lcbstack0 to current loop control block for DO/LOOP/+LOOP
>b408	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$0100						lcbstack0 = stack0
=256						loopindex = lcbstack0+0     ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack0+2     ; loop control block offset for limit fudge factor
>b409	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b40b	0023					tmptos:     .word ?         ; temporary TOS storage
>b40d	0025					tmp1:       .word ?         ; temporary storage
>b40f	0027					tmp2:       .word ?         ; temporary storage
>b411	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b413	002b					tohold:     .word ?         ; pointer for formatted output
>b415	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b41d	0035					tmped:      .word ?,?,?     ; temporary for editors
.b406						cold_zp_table_end:
.b406						cold_user_table:
>b406	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b408	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b40a	0004	00 00				blk_offset:             .word 0         ; BLK
>b40c	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
.b40e	0008					marker_start_offset:
>b40e	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b40f	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b410	000a					wordlists_offset:
>b410	000a	cb bb				    .word dictionary_start              ; FORTH-WORDLIST
>b412	000c	50 ca				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b414	000e	a0 ca				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b416	0010	0f ca				    .word root_dictionary_start         ; ROOT-WORDLIST
>b418	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b420	001a	00 00 00 00 00 00 00 00
>b428	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b429	0023					search_order_offset:
>b429	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b431	002b	00
.b432	002c					marker_end_offset:
>b432	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b434	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b436	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b438	0032	0e b0				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b43a	0034	0e b0				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b43c						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$d0						OpBNE   = $D0
=$f0						OpBEQ   = $F0
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=64						ST = 64 ; Stack juggling to be stripped for native compile
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b43c						oc_index_table:
>b43c		3c b6 40 b6 e7 ba e7 ba		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc07
>b444		48 b6 4e b6 54 b6 5a b6
>b44c		61 b6 65 b6 6b b6 e7 ba		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b454		71 b6 75 b6 79 b6 7d b6
>b45c		82 b6 86 b6 8e b6 e7 ba		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b464		95 b6 9b b6 a2 b6 a9 b6
>b46c		b0 b6 b4 b6 ba b6 e7 ba		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc1E, oc1F
>b474		c0 b6 c4 b6 ca b6 d0 b6
>b47c		d5 b6 d9 b6 e7 ba e7 ba		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b484		e1 b6 e7 b6 ed b6 f3 b6
>b48c		fa b6 fe b6 04 b7 e7 ba		        .word oc28, oc29, oc2A, oc__, oc2C, oc2D, oc2E, oc2F
>b494		0a b7 0e b7 13 b7 17 b7
>b49c		1c b7 20 b7 28 b7 e7 ba		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b4a4		2f b7 37 b7 3e b7 45 b7
>b4ac		4c b7 50 b7 56 b7 e7 ba		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc3F
>b4b4		5c b7 62 b7 68 b7 6e b7
>b4bc		73 b7 77 b7 e7 ba e7 ba		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b4c4		e7 ba 7f b7 85 b7 8b b7
>b4cc		92 b7 96 b7 9c b7 e7 ba		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b4d4		a2 b7 a6 b7 aa b7 ae b7
>b4dc		b3 b7 b7 b7 bf b7 e7 ba		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b4e4		e7 ba c6 b7 cd b7 d4 b7
>b4ec		db b7 df b7 e5 b7 e7 ba		        .word oc58, oc59, oc5A, oc__, oc__, oc5D, oc5E, oc5F
>b4f4		e7 ba e9 b7 ef b7 f5 b7
>b4fc		fa b7 fe b7 e7 ba e7 ba		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b504		06 b8 0c b8 12 b8 18 b8
>b50c		1f b8 23 b8 29 b8 e7 ba		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b514		2f b8 35 b8 39 b8 3d b8
>b51c		42 b8 46 b8 4e b8 e7 ba		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b524		55 b8 5c b8 63 b8 6a b8
>b52c		71 b8 75 b8 7b b8 e7 ba		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b534		7f b8 86 b8 8c b8 92 b8
>b53c		97 b8 9b b8 e7 ba e7 ba		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc87
>b544		a3 b8 a9 b8 af b8 b5 b8
>b54c		bc b8 c0 b8 c6 b8 e7 ba		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b554		ca b8 ce b8 d2 b8 d6 b8
>b55c		db b8 df b8 e7 b8 e7 ba		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b564		ee b8 f5 b8 fc b8 03 b9
>b56c		0a b9 0e b9 14 b9 e7 ba		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b574		18 b9 1c b9 22 b9 28 b9
>b57c		2d b9 33 b9 3b b9 e7 ba		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b584		41 b9 47 b9 4d b9 53 b9
>b58c		5a b9 5e b9 64 b9 e7 ba		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b594		68 b9 6c b9 70 b9 74 b9
>b59c		79 b9 7d b9 85 b9 e7 ba		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b5a4		8c b9 93 b9 9a b9 a1 b9
>b5ac		a8 b9 ac b9 b2 b9 e7 ba		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b5b4		b6 b9 bc b9 c2 b9 c8 b9
>b5bc		cd b9 d3 b9 e7 ba e7 ba		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b5c4		db b9 e1 b9 e7 b9 ed b9
>b5cc		f4 b9 f8 b9 fe b9 e7 ba		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b5d4		02 ba 06 ba 0a ba 0e ba
>b5dc		13 ba 17 ba 1f ba e7 ba		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b5e4		e7 ba 26 ba 2d ba 34 ba
>b5ec		3b ba 3f ba 45 ba e7 ba		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b5f4		e7 ba 49 ba 4f ba 55 ba
>b5fc		5a ba 60 ba e7 ba e7 ba		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b604		68 ba 6e ba 74 ba 7a ba
>b60c		81 ba 85 ba 8b ba e7 ba		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b614		8f ba 93 ba 97 ba 9b ba
>b61c		a0 ba a4 ba ac ba e7 ba		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b624		e7 ba b3 ba ba ba c1 ba
>b62c		c8 ba cc ba d2 ba e7 ba		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b634		e7 ba d6 ba dc ba e2 ba
>b63c		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b640		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b648		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b64e		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b654		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b65a		86 72 6d 62 30 2e 7a			oc07:	.text 2*64+6, "rmb0.z"
>b661		43 70 68 70				oc08:	.text 1*64+3, "php"
>b665		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b66b		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b671		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b675		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b679		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b67d		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b682		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b686		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b68e		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b695		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b69b		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b6a2		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b6a9		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b6b0		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b6b4		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b6ba		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b6c0		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b6c4		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b6ca		c5 61 73 6c 2e 78			oc1E:	.text 3*64+5, "asl.x"
>b6d0		c4 62 62 72 31				oc1F:	.text 3*64+4, "bbr1"
>b6d5		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b6d9		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b6e1		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b6e7		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b6ed		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b6f3		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b6fa		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b6fe		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b704		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b70a		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b70e		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b713		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b717		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b71c		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b720		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b728		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b72f		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b737		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b73e		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b745		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b74c		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b750		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b756		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b75c		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b762		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b768		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b76e		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b773		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b777		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b77f		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b785		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b78b		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b792		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b796		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b79c		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b7a2		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b7a6		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b7aa		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b7ae		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b7b3		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b7b7		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b7bf		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b7c6		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b7cd		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b7d4		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b7db		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b7df		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b7e5		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b7e9		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b7ef		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b7f5		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b7fa		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b7fe		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b806		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b80c		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b812		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b818		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b81f		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b823		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b829		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b82f		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b835		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b839		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b83d		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b842		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b846		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b84e		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b855		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b85c		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b863		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b86a		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b871		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b875		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b87b		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b87f		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b886		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b88c		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b892		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b897		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b89b		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b8a3		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b8a9		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b8af		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b8b5		86 73 6d 62 30 2e 7a			oc87:	.text 2*64+6, "smb0.z"
>b8bc		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b8c0		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b8c6		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b8ca		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b8ce		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b8d2		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b8d6		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b8db		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b8df		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b8e7		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b8ee		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b8f5		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b8fc		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b903		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b90a		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b90e		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b914		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b918		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b91c		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b922		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b928		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b92d		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b933		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b93b		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b941		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b947		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b94d		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b953		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b95a		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b95e		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b964		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b968		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b96c		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b970		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b974		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b979		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b97d		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b985		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b98c		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b993		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b99a		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b9a1		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b9a8		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b9ac		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b9b2		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b9b6		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b9bc		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b9c2		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b9c8		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b9cd		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b9d3		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b9db		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b9e1		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b9e7		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b9ed		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b9f4		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b9f8		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b9fe		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>ba02		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>ba06		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>ba0a		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>ba0e		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>ba13		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>ba17		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>ba1f		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>ba26		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>ba2d		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>ba34		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>ba3b		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>ba3f		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>ba45		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>ba49		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>ba4f		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>ba55		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>ba5a		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>ba60		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>ba68		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>ba6e		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>ba74		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>ba7a		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>ba81		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>ba85		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>ba8b		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>ba8f		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>ba93		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>ba97		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>ba9b		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>baa0		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>baa4		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>baac		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>bab3		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>baba		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>bac1		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>bac8		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>bacc		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>bad2		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>bad6		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>badc		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>bae2		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>bae7		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.bae9						forth_words_start:
>bae9		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>baf1		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb01		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bb11		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>bb21		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>bb31		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bb41		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>bb51		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bb61		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bb71		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bb81		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bb91		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bba1		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bbb1		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bbc1		78 69 74 29 20 63 72 20
.bbc9						forth_words_end:
.bbc9						user_words_start:
>bbc9		20 20				.binary "user_words.asc"
.bbcb						user_words_end:

;******  Processing file: platform/../headers.asm

.bbcb						dictionary_start:
.bbcb						nt_drop:
>bbcb		04 10				        .byte 4, UF
>bbcd		d7 bb 9a 86 9f 86		        .word nt_dup, xt_drop, z_drop
>bbd3		64 72 6f 70			        .text "drop"
.bbd7						nt_dup:
>bbd7		03 10				        .byte 3, UF
>bbd9		e2 bb a0 86 ad 86		        .word nt_swap, xt_dup, z_dup
>bbdf		64 75 70			        .text "dup"
.bbe2						nt_swap:
>bbe2		04 10				        .byte 4, UF
>bbe4		ee bb 3a 92 4d 92		        .word nt_store, xt_swap, z_swap
>bbea		73 77 61 70			        .text "swap"
.bbee						nt_store:
>bbee		01 10				        .byte 1, UF
>bbf0		f7 bb 24 92 39 92		        .word nt_fetch, xt_store, z_store
>bbf6		21				        .text "!"
.bbf7						nt_fetch:
>bbf7		01 10				        .byte 1, UF
>bbf9		00 bc 1a 88 2c 88		        .word nt_over, xt_fetch, z_fetch
>bbff		40				        .text "@"
.bc00						nt_over:
>bc00		04 10				        .byte 4, UF
>bc02		0c bc 11 8d 1e 8d		        .word nt_to_r, xt_over, z_over
>bc08		6f 76 65 72			        .text "over"
.bc0c						nt_to_r:
>bc0c		02 51				        .byte 2, CO+UF+ST       ; native skips stack juggling
>bc0e		16 bc 78 93 8d 93		        .word nt_r_from, xt_to_r, z_to_r
>bc14		3e 72				        .text ">r"
.bc16						nt_r_from:
>bc16		02 41				        .byte 2, CO+ST          ; native skips stack juggling
>bc18		20 bc fc 8e 0e 8f		        .word nt_r_fetch, xt_r_from, z_r_from
>bc1e		72 3e				        .text "r>"
.bc20						nt_r_fetch:
>bc20		02 41				        .byte 2, CO+ST          ; native skips stack juggling
>bc22		2a bc e5 8e f9 8e		        .word nt_nip, xt_r_fetch, z_r_fetch
>bc28		72 40				        .text "r@"
.bc2a						nt_nip:
>bc2a		03 10				        .byte 3, UF
>bc2c		35 bc 42 8c 4f 8c		        .word nt_rot, xt_nip, z_nip
>bc32		6e 69 70			        .text "nip"
.bc35						nt_rot:
>bc35		03 10				        .byte 3, UF
>bc37		40 bc 9d 8f b8 8f		        .word nt_not_rote, xt_rot, z_rot
>bc3d		72 6f 74			        .text "rot"
.bc40						nt_not_rote:
>bc40		04 10				        .byte 4, UF
>bc42		4c bc 7a 9c 95 9c		        .word nt_tuck, xt_not_rote, z_not_rote
>bc48		2d 72 6f 74			        .text "-rot"
.bc4c						nt_tuck:
>bc4c		04 10				        .byte 4, UF
>bc4e		58 bc 99 93 b2 93		        .word nt_comma, xt_tuck, z_tuck
>bc54		74 75 63 6b			        .text "tuck"
.bc58						nt_comma:
>bc58		01 10				        .byte 1, UF
>bc5a		61 bc cd 83 db 83		        .word nt_c_fetch, xt_comma, z_comma
>bc60		2c				        .text ","
.bc61						nt_c_fetch:
>bc61		02 10				        .byte 2, UF
>bc63		6b bc 2d 83 36 83		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bc69		63 40				        .text "c@"
.bc6b						nt_c_store:
>bc6b		02 10				        .byte 2, UF
>bc6d		75 bc 37 83 42 83		        .word nt_plus_store, xt_c_store, z_c_store
>bc73		63 21				        .text "c!"
.bc75						nt_plus_store:
>bc75		02 10				        .byte 2, UF
>bc77		7f bc 72 8e 91 8e		        .word nt_zero, xt_plus_store, z_plus_store
>bc7d		2b 21				        .text "+!"
.bc7f						nt_zero:
>bc7f		01 00				        .byte 1, 0
>bc81		88 bc f6 9d fc 9d		        .word nt_one, xt_zero, z_zero
>bc87		30				        .text "0"
.bc88						nt_one:
>bc88		01 00				        .byte 1, 0
>bc8a		91 bc 90 9d 98 9d		        .word nt_two, xt_one, z_one
>bc90		31				        .text "1"
.bc91						nt_two:
>bc91		01 00				        .byte 1, 0
>bc93		9a bc c1 9d c9 9d		        .word nt_execute, xt_two, z_two
>bc99		32				        .text "2"
.bc9a						nt_execute:
>bc9a		07 10				        .byte 7, UF
>bc9c		a9 bc 05 88 0b 88		        .word nt_emit, xt_execute, z_execute
>bca2		65 78 65 63 75 74 65		        .text "execute"
.bca9						nt_emit:
>bca9		04 18				        .byte 4, NN+UF
>bcab		b5 bc be 86 c8 86		        .word nt_type, xt_emit, z_emit
>bcb1		65 6d 69 74			        .text "emit"
.bcb5						nt_type:
>bcb5		04 10				        .byte 4, UF
>bcb7		c1 bc d0 94 fa 94		        .word nt_dot, xt_type, z_type
>bcbd		74 79 70 65			        .text "type"
.bcc1						nt_dot:
>bcc1		01 10				        .byte 1, UF
>bcc3		ca bc 30 86 51 86		        .word nt_u_dot, xt_dot, z_dot
>bcc9		2e				        .text "."
.bcca						nt_u_dot:
>bcca		02 10				        .byte 2, UF
>bccc		d4 bc fb 94 06 95		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bcd2		75 2e				        .text "u."
.bcd4						nt_u_dot_r:
>bcd4		03 10				        .byte 3, UF
>bcd6		df bc 07 95 28 95		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bcdc		75 2e 72			        .text "u.r"
.bcdf						nt_dot_r:
>bcdf		02 10				        .byte 2, UF
>bce1		e9 bc 6c 86 99 86		        .word nt_d_dot, xt_dot_r, z_dot_r
>bce7		2e 72				        .text ".r"
.bce9						nt_d_dot:
>bce9		02 10				        .byte 2, UF
>bceb		f3 bc 7f 9e 9d 9e		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bcf1		64 2e				        .text "d."
.bcf3						nt_d_dot_r:
>bcf3		03 10				        .byte 3, UF
>bcf5		fe bc 9e 9e c8 9e		        .word nt_m_star_slash, xt_d_dot_r, z_d_dot_r
>bcfb		64 2e 72			        .text "d.r"
.bcfe						nt_m_star_slash:
>bcfe		03 10				        .byte 3, UF
>bd00		09 bd c9 9e 2f 9f		        .word nt_ud_dot, xt_m_star_slash, z_m_star_slash
>bd06		6d 2a 2f			        .text "m*/"
.bd09						nt_ud_dot:
>bd09		03 10				        .byte 3, UF
>bd0b		14 bd 7c 9f 8e 9f		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd11		75 64 2e			        .text "ud."
.bd14						nt_ud_dot_r:
>bd14		04 10				        .byte 4, UF
>bd16		20 bd 8f 9f ad 9f		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd1c		75 64 2e 72			        .text "ud.r"
.bd20						nt_question:
>bd20		01 00				        .byte 1, 0
>bd22		29 bd 16 99 1c 99		        .word nt_false, xt_question, z_question
>bd28		3f				        .text "?"
.bd29						nt_false:
>bd29		05 00				        .byte 5, 0
>bd2b		36 bd f6 9d fc 9d		        .word nt_true, xt_false, z_false
>bd31		66 61 6c 73 65			        .text "false"
.bd36						nt_true:
>bd36		04 00				        .byte 4, 0
>bd38		42 bd 90 93 98 93		        .word nt_space, xt_true, z_true
>bd3e		74 72 75 65			        .text "true"
.bd42						nt_space:
>bd42		05 00				        .byte 5, 0
>bd44		4f bd d7 91 dc 91		        .word nt_two_dup, xt_space, z_space
>bd4a		73 70 61 63 65			        .text "space"
.bd4f						nt_two_dup:
>bd4f		04 10				        .byte 4, UF
>bd51		5b bd bb 93 d2 93		        .word nt_question_dup, xt_two_dup, z_two_dup
>bd57		32 64 75 70			        .text "2dup"
.bd5b						nt_question_dup:
>bd5b		04 10				        .byte 4, UF
>bd5d		67 bd d1 8e e4 8e		        .word nt_plus, xt_question_dup, z_question_dup
>bd63		3f 64 75 70			        .text "?dup"
.bd67						nt_plus:
>bd67		01 10				        .byte 1, UF
>bd69		70 bd 5f 8e 71 8e		        .word nt_minus, xt_plus, z_plus
>bd6f		2b				        .text "+"
.bd70						nt_minus:
>bd70		01 10				        .byte 1, UF
>bd72		79 bd f6 8b 08 8c		        .word nt_one_minus, xt_minus, z_minus
>bd78		2d				        .text "-"
.bd79						nt_one_minus:
>bd79		02 10				        .byte 2, UF
>bd7b		83 bd e9 8c f4 8c		        .word nt_one_plus, xt_one_minus, z_one_minus
>bd81		31 2d				        .text "1-"
.bd83						nt_one_plus:
>bd83		02 10				        .byte 2, UF
>bd85		8d bd f5 8c fe 8c		        .word nt_two_star, xt_one_plus, z_one_plus
>bd8b		31 2b				        .text "1+"
.bd8d						nt_two_star:
>bd8d		02 10				        .byte 2, UF
>bd8f		97 bd 5e 94 65 94		        .word nt_two_slash, xt_two_star, z_two_star
>bd95		32 2a				        .text "2*"
.bd97						nt_two_slash:
>bd97		02 10				        .byte 2, UF
>bd99		a1 bd 53 94 5d 94		        .word nt_abs, xt_two_slash, z_two_slash
>bd9f		32 2f				        .text "2/"
.bda1						nt_abs:
>bda1		03 10				        .byte 3, UF
>bda3		ac bd cf 80 e3 80		        .word nt_dabs, xt_abs, z_abs
>bda9		61 62 73			        .text "abs"
.bdac						nt_dabs:
>bdac		04 10				        .byte 4, UF
>bdae		b8 bd 45 9e 63 9e		        .word nt_and, xt_dabs, z_dabs
>bdb4		64 61 62 73			        .text "dabs"
.bdb8						nt_and:
>bdb8		03 10				        .byte 3, UF
>bdba		c3 bd 90 82 a1 82		        .word nt_or, xt_and, z_and
>bdc0		61 6e 64			        .text "and"
.bdc3						nt_or:
>bdc3		02 10				        .byte 2, UF
>bdc5		cd bd ff 8c 10 8d		        .word nt_xor, xt_or, z_or
>bdcb		6f 72				        .text "or"
.bdcd						nt_xor:
>bdcd		03 10				        .byte 3, UF
>bdcf		d8 bd 7b 96 8c 96		        .word nt_rshift, xt_xor, z_xor
>bdd5		78 6f 72			        .text "xor"
.bdd8						nt_rshift:
>bdd8		06 10				        .byte 6, UF
>bdda		e6 bd b9 8f cc 8f		        .word nt_lshift, xt_rshift, z_rshift
>bde0		72 73 68 69 66 74		        .text "rshift"
.bde6						nt_lshift:
>bde6		06 10				        .byte 6, UF
>bde8		f4 bd 1f 8b 32 8b		        .word nt_pick, xt_lshift, z_lshift
>bdee		6c 73 68 69 66 74		        .text "lshift"
.bdf4						nt_pick:
>bdf4		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bdf6		00 be 4e 8e 5e 8e		        .word nt_char, xt_pick, z_pick
>bdfc		70 69 63 6b			        .text "pick"
.be00						nt_char:
>be00		04 00				        .byte 4, 0
>be02		0c be 53 83 69 83		        .word nt_bracket_char, xt_char, z_char
>be08		63 68 61 72			        .text "char"
.be0c						nt_bracket_char:
>be0c		06 05				        .byte 6, CO+IM
>be0e		1a be 0d 83 13 83		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>be14		5b 63 68 61 72 5d		        .text "[char]"
.be1a						nt_char_plus:
>be1a		05 00				        .byte 5, 0
>be1c		27 be f5 8c fe 8c		        .word nt_chars, xt_char_plus, z_char_plus ; same as 1+
>be22		63 68 61 72 2b			        .text "char+"
.be27						nt_chars:
>be27		05 10				        .byte 5, UF     ; deleted during compile
>be29		34 be 6a 83 6d 83		        .word nt_cells, xt_chars, z_chars
>be2f		63 68 61 72 73			        .text "chars"
.be34						nt_cells:
>be34		05 00				        .byte 5, 0
>be36		41 be 5e 94 65 94		        .word nt_cell_plus, xt_cells, z_cells  ; same as 2*
>be3c		63 65 6c 6c 73			        .text "cells"
.be41						nt_cell_plus:
>be41		05 10				        .byte 5, UF
>be43		4e be 43 83 52 83		        .word nt_here, xt_cell_plus, z_cell_plus
>be49		63 65 6c 6c 2b			        .text "cell+"
.be4e						nt_here:
>be4e		04 00				        .byte 4, 0
>be50		5a be 1b 89 25 89		        .word nt_equal, xt_here, z_here
>be56		68 65 72 65			        .text "here"
.be5a						nt_equal:
>be5a		01 10				        .byte 1, UF
>be5c		63 be 96 87 b1 87		        .word nt_not_equals, xt_equal, z_equal
>be62		3d				        .text "="
.be63						nt_not_equals:
>be63		02 10				        .byte 2, UF
>be65		6d be 50 8c 6d 8c		        .word nt_less_than, xt_not_equals, z_not_equals
>be6b		3c 3e				        .text "<>"
.be6d						nt_less_than:
>be6d		01 10				        .byte 1, UF
>be6f		76 be ef 89 03 8a		        .word nt_u_less_than, xt_less_than, z_less_than
>be75		3c				        .text "<"
.be76						nt_u_less_than:
>be76		02 10				        .byte 2, UF
>be78		80 be 3f 95 54 95		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>be7e		75 3c				        .text "u<"
.be80						nt_u_greater_than:
>be80		02 10				        .byte 2, UF
>be82		8a be 29 95 3e 95		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>be88		75 3e				        .text "u>"
.be8a						nt_greater_than:
>be8a		01 10				        .byte 1, UF
>be8c		93 be 06 89 1a 89		        .word nt_zero_equal, xt_greater_than, z_greater_than
>be92		3e				        .text ">"
.be93						nt_zero_equal:
>be93		02 10				        .byte 2, UF
>be95		9d be 8d 96 9e 96		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>be9b		30 3d				        .text "0="
.be9d						nt_zero_unequal:
>be9d		03 10				        .byte 3, UF
>be9f		a8 be c3 96 d2 96		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bea5		30 3c 3e			        .text "0<>"
.bea8						nt_zero_greater:
>bea8		02 10				        .byte 2, UF
>beaa		b2 be 9f 96 b2 96		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>beb0		30 3e				        .text "0>"
.beb2						nt_zero_less:
>beb2		02 10				        .byte 2, UF
>beb4		bc be b3 96 c2 96		        .word nt_min, xt_zero_less, z_zero_less
>beba		30 3c				        .text "0<"
.bebc						nt_min:
>bebc		03 10				        .byte 3, UF
>bebe		c7 be da 8b f5 8b		        .word nt_max, xt_min, z_min
>bec4		6d 69 6e			        .text "min"
.bec7						nt_max:
>bec7		03 10				        .byte 3, UF
>bec9		d2 be be 8b d9 8b		        .word nt_two_drop, xt_max, z_max
>becf		6d 61 78			        .text "max"
.bed2						nt_two_drop:
>bed2		05 10				        .byte 5, UF
>bed4		df be b3 93 ba 93		        .word nt_two_swap, xt_two_drop, z_two_drop
>beda		32 64 72 6f 70			        .text "2drop"
.bedf						nt_two_swap:
>bedf		05 10				        .byte 5, UF
>bee1		ec be 8c 94 af 94		        .word nt_two_over, xt_two_swap, z_two_swap
>bee7		32 73 77 61 70			        .text "2swap"
.beec						nt_two_over:
>beec		05 10				        .byte 5, UF
>beee		f9 be f5 93 0c 94		        .word nt_two_store, xt_two_over, z_two_over
>bef4		32 6f 76 65 72			        .text "2over"
.bef9						nt_two_store:
>bef9		02 10				        .byte 2, UF
>befb		03 bf 66 94 8b 94		        .word nt_two_fetch, xt_two_store, z_two_store
>bf01		32 21				        .text "2!"
.bf03						nt_two_fetch:
>bf03		02 10				        .byte 2, UF
>bf05		0d bf d3 93 f4 93		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bf0b		32 40				        .text "2@"
.bf0d						nt_two_variable:
>bf0d		09 00				        .byte 9, 0
>bf0f		1e bf 6d 9f 7b 9f		        .word nt_two_constant, xt_two_variable, z_two_variable
>bf15		32 76 61 72 69 61 62 6c		        .text "2variable"
>bf1d		65
.bf1e						nt_two_constant:
>bf1e		09 10				        .byte 9, UF
>bf20		2f bf 30 9f 54 9f		        .word nt_two_literal, xt_two_constant, z_two_constant
>bf26		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bf2e		74
.bf2f						nt_two_literal:
>bf2f		08 14				        .byte 8, UF+IM
>bf31		3f bf 55 9f 6c 9f		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bf37		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bf3f						nt_two_r_fetch:
>bf3f		03 41				        .byte 3, CO+ST          ; native skips stack juggling
>bf41		4a bf 0d 94 33 94		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bf47		32 72 40			        .text "2r@"
.bf4a						nt_two_r_from:
>bf4a		03 41				        .byte 3, CO+ST          ; native skips stack juggling
>bf4c		55 bf 36 94 50 94		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bf52		32 72 3e			        .text "2r>"
.bf55						nt_two_to_r:
>bf55		03 51				        .byte 3, CO+UF+ST       ; native skips stack juggling
>bf57		60 bf b0 94 cd 94		        .word nt_invert, xt_two_to_r, z_two_to_r
>bf5d		32 3e 72			        .text "2>r"
.bf60						nt_invert:
>bf60		06 10				        .byte 6, UF
>bf62		6e bf 64 89 73 89		        .word nt_negate, xt_invert, z_invert
>bf68		69 6e 76 65 72 74		        .text "invert"
.bf6e						nt_negate:
>bf6e		06 10				        .byte 6, UF
>bf70		7c bf 31 8c 41 8c		        .word nt_dnegate, xt_negate, z_negate
>bf76		6e 65 67 61 74 65		        .text "negate"
.bf7c						nt_dnegate:
>bf7c		07 10				        .byte 7, UF
>bf7e		8b bf 64 9e 7e 9e		        .word nt_c_comma, xt_dnegate, z_dnegate
>bf84		64 6e 65 67 61 74 65		        .text "dnegate"
.bf8b						nt_c_comma:
>bf8b		02 10				        .byte 2, UF
>bf8d		95 bf 22 83 2c 83		        .word nt_bounds, xt_c_comma, z_c_comma
>bf93		63 2c				        .text "c,"
.bf95						nt_bounds:
>bf95		06 10				        .byte 6, UF
>bf97		a3 bf 28 9a 40 9a		        .word nt_spaces, xt_bounds, z_bounds
>bf9d		62 6f 75 6e 64 73		        .text "bounds"
.bfa3						nt_spaces:
>bfa3		06 10				        .byte 6, UF
>bfa5		b1 bf dd 91 f6 91		        .word nt_bl, xt_spaces, z_spaces
>bfab		73 70 61 63 65 73		        .text "spaces"
.bfb1						nt_bl:
>bfb1		02 00				        .byte 2, 0
>bfb3		bb bf 04 83 0c 83		        .word nt_minus_trailing, xt_bl, z_bl
>bfb9		62 6c				        .text "bl"
.bfbb						nt_minus_trailing:
>bfbb		09 10				        .byte 9, UF
>bfbd		cc bf a2 a0 de a0		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>bfc3		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>bfcb		67
.bfcc						nt_minus_leading:
>bfcc		08 10				        .byte 8, UF
>bfce		dc bf 89 a0 a1 a0		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>bfd4		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.bfdc						nt_slash_string:
>bfdc		07 10				        .byte 7, UF
>bfde		eb bf 7e a1 9d a1		        .word nt_refill, xt_slash_string, z_slash_string
>bfe4		2f 73 74 72 69 6e 67		        .text "/string"
.bfeb						nt_refill:
>bfeb		06 00				        .byte 6, 0
>bfed		f9 bf 4e 8f 8f 8f		        .word nt_accept, xt_refill, z_refill
>bff3		72 65 66 69 6c 6c		        .text "refill"
.bff9						nt_accept:
>bff9		06 18				        .byte 6, UF+NN
>bffb		07 c0 e4 80 dc 81		        .word nt_input_to_r, xt_accept, z_accept
>c001		61 63 63 65 70 74		        .text "accept"
.c007						nt_input_to_r:
>c007		07 08				        .byte 7, NN
>c009		16 c0 97 9b ac 9b		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c00f		69 6e 70 75 74 3e 72		        .text "input>r"
.c016						nt_r_to_input:
>c016		07 08				        .byte 7, NN
>c018		25 c0 a4 9d bb 9d		        .word nt_unused, xt_r_to_input, z_r_to_input
>c01e		72 3e 69 6e 70 75 74		        .text "r>input"
.c025						nt_unused:
>c025		06 00				        .byte 6, 0
>c027		33 c0 f1 95 00 96		        .word nt_depth, xt_unused, z_unused
>c02d		75 6e 75 73 65 64		        .text "unused"
.c033						nt_depth:
>c033		05 00				        .byte 5, 0
>c035		40 c0 52 85 60 85		        .word nt_key, xt_depth, z_depth
>c03b		64 65 70 74 68			        .text "depth"
.c040						nt_key:
>c040		03 00				        .byte 3, 0
>c042		4b c0 a7 89 b0 89		        .word nt_keyq, xt_key, z_key
>c048		6b 65 79			        .text "key"
.c04b						nt_keyq:
>c04b		04 00				        .byte 4, 0
>c04d		57 c0 b4 89 c2 89		        .word nt_allot, xt_keyq, z_keyq
>c053		6b 65 79 3f			        .text "key?"
.c057						nt_allot:
>c057		05 10				        .byte 5, UF
>c059		64 c0 27 82 8f 82		        .word nt_create, xt_allot, z_allot
>c05f		61 6c 6c 6f 74			        .text "allot"
.c064						nt_create:
>c064		06 00				        .byte 6, 0
>c066		72 c0 40 84 09 85		        .word nt_does, xt_create, z_create
>c06c		63 72 65 61 74 65		        .text "create"
.c072						nt_does:
>c072		05 05				        .byte 5, CO+IM
>c074		7f c0 ef 85 fd 85		        .word nt_variable, xt_does, z_does
>c07a		64 6f 65 73 3e			        .text "does>"
.c07f						nt_variable:
>c07f		08 00				        .byte 8, 0
>c081		8f c0 01 96 19 96		        .word nt_constant, xt_variable, z_variable
>c087		76 61 72 69 61 62 6c 65		        .text "variable"
.c08f						nt_constant:
>c08f		08 10				        .byte 8, UF
>c091		9f c0 e8 83 25 84		        .word nt_value, xt_constant, z_constant
>c097		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c09f						nt_value:
>c09f		05 10				        .byte 5, UF
>c0a1		ac c0 e8 83 25 84		        .word nt_to, xt_value, z_value          ; same code as CONSTANT
>c0a7		76 61 6c 75 65			        .text "value"
.c0ac						nt_to:
>c0ac		02 0c				        .byte 2, NN+IM
>c0ae		b6 c0 6e 92 a9 92		        .word nt_s_to_d, xt_to, z_to
>c0b4		74 6f				        .text "to"
.c0b6						nt_s_to_d:
>c0b6		03 10				        .byte 3, UF
>c0b8		c1 c0 eb 90 fc 90		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c0be		73 3e 64			        .text "s>d"
.c0c1						nt_d_to_s:
>c0c1		03 10				        .byte 3, UF
>c0c3		cc c0 3f 9e 44 9e		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c0c9		64 3e 73			        .text "d>s"
.c0cc						nt_d_minus:
>c0cc		02 10				        .byte 2, UF
>c0ce		d6 c0 fd 9d 1d 9e		        .word nt_d_plus, xt_d_minus, z_d_minus
>c0d4		64 2d				        .text "d-"
.c0d6						nt_d_plus:
>c0d6		02 10				        .byte 2, UF
>c0d8		e0 c0 1e 9e 3e 9e		        .word nt_erase, xt_d_plus, z_d_plus
>c0de		64 2b				        .text "d+"
.c0e0						nt_erase:
>c0e0		05 00				        .byte 5, 0      ; underflow checked by FILL
>c0e2		ed c0 bc 87 04 88		        .word nt_blank, xt_erase, z_erase
>c0e8		65 72 61 73 65			        .text "erase"
.c0ed						nt_blank:
>c0ed		05 00				        .byte 5, 0     ; underflow checked by FILL
>c0ef		fa c0 b2 87 04 88		        .word nt_fill, xt_blank, z_blank
>c0f5		62 6c 61 6e 6b			        .text "blank"
.c0fa						nt_fill:
>c0fa		04 10				        .byte 4, UF
>c0fc		06 c1 c2 87 04 88		        .word nt_find_name, xt_fill, z_fill
>c102		66 69 6c 6c			        .text "fill"
.c106						nt_find_name:
>c106		09 10				        .byte 9, UF
>c108		17 c1 ea 9a 2d 9b		        .word nt_tick, xt_find_name, z_find_name
>c10e		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c116		65
.c117						nt_tick:
>c117		01 00				        .byte 1, 0
>c119		20 c1 4e 92 6d 92		        .word nt_bracket_tick, xt_tick, z_tick
>c11f		27				        .text "'"
.c120						nt_bracket_tick:
>c120		03 05				        .byte 3, CO+IM
>c122		2b c1 14 83 1a 83		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c128		5b 27 5d			        .text "[']"
.c12b						nt_name_to_int:
>c12b		08 10				        .byte 8, UF
>c12d		3b c1 33 9c 4f 9c		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c133		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c13b						nt_int_to_name:
>c13b		08 10				        .byte 8, UF
>c13d		4b c1 ad 9b 1d 9c		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c143		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c14b						nt_name_to_string:
>c14b		0b 10				        .byte 11, UF
>c14d		5e c1 50 9c 66 9c		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c153		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c15b		69 6e 67
.c15e						nt_to_body:
>c15e		05 10				        .byte 5, UF
>c160		6b c1 aa 92 cc 92		        .word nt_defer, xt_to_body, z_to_body
>c166		3e 62 6f 64 79			        .text ">body"
.c16b						nt_defer:
>c16b		05 00				        .byte 5, 0
>c16d		78 c1 11 85 43 85		        .word nt_latestxt, xt_defer, z_defer
>c173		64 65 66 65 72			        .text "defer"
.c178						nt_latestxt:
>c178		08 00				        .byte 8, 0
>c17a		88 c1 2c 9c 32 9c		        .word nt_latestnt, xt_latestxt, z_latestxt
>c180		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c188						nt_latestnt:
>c188		08 00				        .byte 8, 0
>c18a		98 c1 1e 9c 2b 9c		        .word nt_parse_name, xt_latestnt, z_latestnt
>c190		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c198						nt_parse_name:
>c198		0a 08				        .byte 10, NN
>c19a		aa c1 5d 8d 4d 8e		        .word nt_parse, xt_parse_name, z_parse_name
>c1a0		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c1a8		6d 65
.c1aa						nt_parse:
>c1aa		05 10				        .byte 5, UF
>c1ac		b7 c1 b8 8d 4d 8e		        .word nt_execute_parsing, xt_parse, z_parse
>c1b2		70 61 72 73 65			        .text "parse"
.c1b7						nt_execute_parsing:
>c1b7		0f 10				        .byte 15, UF
>c1b9		ce c1 c3 9a e9 9a		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c1bf		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c1c7		70 61 72 73 69 6e 67
.c1ce						nt_source:
>c1ce		06 00				        .byte 6, 0
>c1d0		dc c1 b7 91 cb 91		        .word nt_source_id, xt_source, z_source
>c1d6		73 6f 75 72 63 65		        .text "source"
.c1dc						nt_source_id:
>c1dc		09 00				        .byte 9, 0
>c1de		ed c1 cc 91 d6 91		        .word nt_colon, xt_source_id, z_source_id
>c1e4		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c1ec		64
.c1ed						nt_colon:
>c1ed		01 00				        .byte 1, 0
>c1ef		f6 c1 6e 83 b0 83		        .word nt_semicolon, xt_colon, z_colon
>c1f5		3a				        .text ":"
.c1f6						nt_semicolon:
>c1f6		01 05				        .byte 1, CO+IM
>c1f8		ff c1 fd 90 5b 91		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c1fe		3b				        .text ";"
.c1ff						nt_colon_noname:
>c1ff		07 00				        .byte 7, 0
>c201		0e c2 b1 83 cc 83		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c207		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c20e						nt_compile_comma:
>c20e		08 18				        .byte 8, UF+NN
>c210		1e c2 d3 96 73 97		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c216		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c21e						nt_left_bracket:
>c21e		01 05				        .byte 1, IM+CO
>c220		27 c2 dc 89 e0 89		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c226		5b				        .text "["
.c227						nt_right_bracket:
>c227		01 04				        .byte 1, IM
>c229		30 c2 96 8f 9c 8f		        .word nt_literal, xt_right_bracket, z_right_bracket
>c22f		5d				        .text "]"
.c230						nt_literal:
>c230		07 15				        .byte 7, IM+CO+UF
>c232		3f c2 04 8a 41 8a		        .word nt_sliteral, xt_literal, z_literal
>c238		6c 69 74 65 72 61 6c		        .text "literal"
.c23f						nt_sliteral:
>c23f		08 15				        .byte 8, CO+IM+UF
>c241		4f c2 9e a1 e1 a1		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c247		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c24f						nt_dot_quote:
>c24f		02 05				        .byte 2, CO+IM
>c251		59 c2 61 86 6b 86		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c257		2e 22				        .text ".", $22
.c259						nt_s_quote:
>c259		02 0c				        .byte 2, IM+NN
>c25b		63 c2 e6 8f ea 90		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c261		73 22				        .text "s", $22
.c263						nt_s_backslash_quote:
>c263		03 04				        .byte 3, IM
>c265		6e c2 cd 8f d6 8f		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c26b		73 5c 22			        .text "s", $5C, $22
.c26e						nt_postpone:
>c26e		08 05				        .byte 8, IM+CO
>c270		7e c2 92 8e d0 8e		        .word nt_immediate, xt_postpone, z_postpone
>c276		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c27e						nt_immediate:
>c27e		09 00				        .byte 9, 0
>c280		8f c2 58 89 63 89		        .word nt_compile_only, xt_immediate, z_immediate
>c286		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c28e		65
.c28f						nt_compile_only:
>c28f		0c 00				        .byte 12, 0
>c291		a3 c2 dc 83 e7 83		        .word nt_never_native, xt_compile_only, z_compile_only
>c297		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c29f		6f 6e 6c 79
.c2a3						nt_never_native:
>c2a3		0c 00				        .byte 12, 0
>c2a5		b7 c2 6c 9c 79 9c		        .word nt_always_native, xt_never_native, z_never_native
>c2ab		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c2b3		74 69 76 65
.c2b7						nt_always_native:
>c2b7		0d 00				        .byte 13, 0
>c2b9		cc c2 14 9a 21 9a		        .word nt_allow_native, xt_always_native, z_always_native
>c2bf		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c2c7		61 74 69 76 65
.c2cc						nt_allow_native:
>c2cc		0c 00				        .byte 12, 0
>c2ce		e0 c2 08 9a 13 9a		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c2d4		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c2dc		74 69 76 65
.c2e0						nt_nc_limit:
>c2e0		08 08				        .byte 8, NN
>c2e2		f0 c2 67 9c 6c 9c		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c2e8		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c2f0						nt_strip_underflow:
>c2f0		0f 08				        .byte 15, NN
>c2f2		07 c3 bc 9d c1 9d		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c2f8		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c300		64 65 72 66 6c 6f 77
.c307						nt_abort:
>c307		05 00				        .byte 5, 0
>c309		14 c3 5e 80 af 80		        .word nt_abort_quote, xt_abort, z_abort
>c30f		61 62 6f 72 74			        .text "abort"
.c314						nt_abort_quote:
>c314		06 0d				        .byte 6, CO+IM+NN
>c316		22 c3 af 80 b9 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c31c		61 62 6f 72 74 22		        .text "abort", $22
.c322						nt_do:
>c322		02 0d				        .byte 2, CO+IM+NN
>c324		2c c3 8b 85 a4 85		        .word nt_question_do, xt_do, z_do
>c32a		64 6f				        .text "do"
.c32c						nt_question_do:
>c32c		03 0d				        .byte 3, CO+IM+NN
>c32e		37 c3 61 85 a4 85		        .word nt_i, xt_question_do, z_question_do
>c334		3f 64 6f			        .text "?do"
.c337						nt_i:
>c337		01 01				        .byte 1, CO
>c339		40 c3 3f 89 53 89		        .word nt_j, xt_i, z_i
>c33f		69				        .text "i"
.c340						nt_j:
>c340		01 01				        .byte 1, CO
>c342		49 c3 8d 89 a6 89		        .word nt_loop, xt_j, z_j
>c348		6a				        .text "j"
.c349						nt_loop:
>c349		04 05				        .byte 4, CO+IM
>c34b		55 c3 6b 8a e3 8a		        .word nt_plus_loop, xt_loop, z_loop
>c351		6c 6f 6f 70			        .text "loop"
.c355						nt_plus_loop:
>c355		05 05				        .byte 5, CO+IM
>c357		62 c3 7f 8a e3 8a		        .word nt_exit, xt_plus_loop, z_plus_loop
>c35d		2b 6c 6f 6f 70			        .text "+loop"
.c362						nt_exit:
>c362		04 03				        .byte 4, AN+CO
>c364		6e c3 19 88 1a 88		        .word nt_unloop, xt_exit, z_exit
>c36a		65 78 69 74			        .text "exit"
.c36e						nt_unloop:
>c36e		06 01				        .byte 6, CO
>c370		7c c3 dd 95 ec 95		        .word nt_leave, xt_unloop, z_unloop
>c376		75 6e 6c 6f 6f 70		        .text "unloop"
.c37c						nt_leave:
>c37c		05 05				        .byte 5, CO+IM
>c37e		89 c3 c6 89 db 89		        .word nt_recurse, xt_leave, z_leave
>c384		6c 65 61 76 65			        .text "leave"
.c389						nt_recurse:
>c389		07 0d				        .byte 7, CO+IM+NN
>c38b		98 c3 11 8f 4d 8f		        .word nt_quit, xt_recurse, z_recurse
>c391		72 65 63 75 72 73 65		        .text "recurse"
.c398						nt_quit:
>c398		04 00				        .byte 4, 0
>c39a		a4 c3 60 80 af 80		        .word nt_begin, xt_quit, z_quit
>c3a0		71 75 69 74			        .text "quit"
.c3a4						nt_begin:
>c3a4		05 05				        .byte 5, CO+IM
>c3a6		b1 c3 1b 89 25 89		        .word nt_again, xt_begin, z_begin
>c3ac		62 65 67 69 6e			        .text "begin"
.c3b1						nt_again:
>c3b1		05 15				        .byte 5, CO+IM+UF
>c3b3		be c3 1f 82 25 82		        .word nt_state, xt_again, z_again
>c3b9		61 67 61 69 6e			        .text "again"
.c3be						nt_state:
>c3be		05 00				        .byte 5, 0
>c3c0		cb c3 19 92 23 92		        .word nt_evaluate, xt_state, z_state
>c3c6		73 74 61 74 65			        .text "state"
.c3cb						nt_evaluate:
>c3cb		08 10				        .byte 8, UF
>c3cd		db c3 b2 88 05 89		        .word nt_base, xt_evaluate, z_evaluate
>c3d3		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c3db						nt_base:
>c3db		04 00				        .byte 4, 0
>c3dd		e7 c3 fb 82 03 83		        .word nt_digit_question, xt_base, z_base
>c3e3		62 61 73 65			        .text "base"
.c3e7						nt_digit_question:
>c3e7		06 10				        .byte 6, UF
>c3e9		f5 c3 8e 9a c2 9a		        .word nt_number, xt_digit_question, z_digit_question
>c3ef		64 69 67 69 74 3f		        .text "digit?"
.c3f5						nt_number:
>c3f5		06 10				        .byte 6, UF
>c3f7		03 c4 96 9c 8f 9d		        .word nt_to_number, xt_number, z_number
>c3fd		6e 75 6d 62 65 72		        .text "number"
.c403						nt_to_number:
>c403		07 10				        .byte 7, UF
>c405		12 c4 d8 92 77 93		        .word nt_hex, xt_to_number, z_to_number
>c40b		3e 6e 75 6d 62 65 72		        .text ">number"
.c412						nt_hex:
>c412		03 00				        .byte 3, 0
>c414		1d c4 26 89 2c 89		        .word nt_decimal, xt_hex, z_hex
>c41a		68 65 78			        .text "hex"
.c41d						nt_decimal:
>c41d		07 00				        .byte 7, 0
>c41f		2c c4 0a 85 10 85		        .word nt_count, xt_decimal, z_decimal
>c425		64 65 63 69 6d 61 6c		        .text "decimal"
.c42c						nt_count:
>c42c		05 10				        .byte 5, UF
>c42e		39 c4 26 84 39 84		        .word nt_m_star, xt_count, z_count
>c434		63 6f 75 6e 74			        .text "count"
.c439						nt_m_star:
>c439		02 10				        .byte 2, UF
>c43b		43 c4 33 8b 4d 8b		        .word nt_um_star, xt_m_star, z_m_star
>c441		6d 2a				        .text "m*"
.c443						nt_um_star:
>c443		03 10				        .byte 3, UF
>c445		4e c4 97 95 dc 95		        .word nt_star, xt_um_star, z_um_star
>c44b		75 6d 2a			        .text "um*"
.c44e						nt_star:
>c44e		01 10				        .byte 1, UF
>c450		57 c4 f7 91 ff 91		        .word nt_um_slash_mod, xt_star, z_star
>c456		2a				        .text "*"
.c457						nt_um_slash_mod:
>c457		06 10				        .byte 6, UF
>c459		65 c4 55 95 96 95		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c45f		75 6d 2f 6d 6f 64		        .text "um/mod"
.c465						nt_sm_slash_rem:
>c465		06 10				        .byte 6, UF
>c467		73 c4 8e 91 b6 91		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c46d		73 6d 2f 72 65 6d		        .text "sm/rem"
.c473						nt_fm_slash_mod:
>c473		06 10				        .byte 6, UF
>c475		81 c4 75 88 ab 88		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c47b		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c481						nt_slash:
>c481		01 10				        .byte 1, UF
>c483		8a c4 71 91 8d 91		        .word nt_slash_mod, xt_slash, z_slash
>c489		2f				        .text "/"
.c48a						nt_slash_mod:
>c48a		04 10				        .byte 4, UF
>c48c		96 c4 76 91 8d 91		        .word nt_mod, xt_slash_mod, z_slash_mod
>c492		2f 6d 6f 64			        .text "/mod"
.c496						nt_mod:
>c496		03 10				        .byte 3, UF
>c498		a1 c4 09 8c 11 8c		        .word nt_star_slash_mod, xt_mod, z_mod
>c49e		6d 6f 64			        .text "mod"
.c4a1						nt_star_slash_mod:
>c4a1		05 10				        .byte 5, UF
>c4a3		ae c4 09 92 18 92		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c4a9		2a 2f 6d 6f 64			        .text "*/mod"
.c4ae						nt_star_slash:
>c4ae		02 10				        .byte 2, UF
>c4b0		b8 c4 00 92 08 92		        .word nt_backslash, xt_star_slash, z_star_slash
>c4b6		2a 2f				        .text "*/"
.c4b8						nt_backslash:
>c4b8		01 04				        .byte 1, IM
>c4ba		c1 c4 d0 82 fa 82		        .word nt_move, xt_backslash, z_backslash
>c4c0		5c				        .byte '\'
.c4c1						nt_move:
>c4c1		04 18				        .byte 4, NN+UF
>c4c3		cd c4 12 8c 30 8c		        .word nt_cmove_up, xt_move, z_move
>c4c9		6d 6f 76 65			        .text "move"
.c4cd						nt_cmove_up:
>c4cd		06 10				        .byte 6, UF
>c4cf		db c4 e9 9f 23 a0		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c4d5		63 6d 6f 76 65 3e		        .text "cmove>"
.c4db						nt_cmove:
>c4db		05 10				        .byte 5, UF
>c4dd		e8 c4 ae 9f e8 9f		        .word nt_pad, xt_cmove, z_cmove
>c4e3		63 6d 6f 76 65			        .text "cmove"
.c4e8						nt_pad:
>c4e8		03 00				        .byte 3, 0
>c4ea		f3 c4 1f 8d 2e 8d		        .word nt_cleave, xt_pad, z_pad
>c4f0		70 61 64			        .text "pad"
.c4f3						nt_cleave:
>c4f3		06 10				        .byte 6, UF
>c4f5		01 c5 41 9a 8d 9a		        .word nt_hexstore, xt_cleave, z_cleave
>c4fb		63 6c 65 61 76 65		        .text "cleave"
.c501						nt_hexstore:
>c501		08 10				        .byte 8, UF
>c503		11 c5 39 9b 8b 9b		        .word nt_within, xt_hexstore, z_hexstore
>c509		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c511						nt_within:
>c511		06 10				        .byte 6, UF
>c513		1f c5 21 96 36 96		        .word nt_to_in, xt_within, z_within
>c519		77 69 74 68 69 6e		        .text "within"
.c51f						nt_to_in:
>c51f		03 00				        .byte 3, 0
>c521		2a c5 cd 92 d7 92		        .word nt_less_number_sign, xt_to_in, z_to_in
>c527		3e 69 6e			        .text ">in"
.c52a						nt_less_number_sign:
>c52a		02 00				        .byte 2, 0
>c52c		34 c5 e1 89 ee 89		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c532		3c 23				        .text "<#"
.c534						nt_number_sign:
>c534		01 10				        .byte 1, UF
>c536		3d c5 6e 8c 9c 8c		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c53c		23				        .text "#"
.c53d						nt_number_sign_s:
>c53d		02 10				        .byte 2, UF
>c53f		47 c5 bf 8c cf 8c		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c545		23 73				        .text "#s"
.c547						nt_number_sign_greater:
>c547		02 10				        .byte 2, UF
>c549		51 c5 9d 8c be 8c		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c54f		23 3e				        .text "#>"
.c551						nt_hold:
>c551		04 10				        .byte 4, UF
>c553		5d c5 2d 89 3e 89		        .word nt_sign, xt_hold, z_hold
>c559		68 6f 6c 64			        .text "hold"
.c55d						nt_sign:
>c55d		04 10				        .byte 4, UF
>c55f		69 c5 5c 91 70 91		        .word nt_output, xt_sign, z_sign
>c565		73 69 67 6e			        .text "sign"
.c569						nt_output:
>c569		06 00				        .byte 6, 0
>c56b		77 c5 99 9d a3 9d		        .word nt_input, xt_output, z_output
>c571		6f 75 74 70 75 74		        .text "output"
.c577						nt_input:
>c577		05 00				        .byte 5, 0
>c579		84 c5 8c 9b 96 9b		        .word nt_havekey, xt_input, z_input
>c57f		69 6e 70 75 74			        .text "input"
.c584						nt_havekey:
>c584		07 00				        .byte 7, 0
>c586		93 c5 2e 9b 38 9b		        .word nt_cr, xt_havekey, z_havekey
>c58c		68 61 76 65 6b 65 79		        .text "havekey"
.c593						nt_cr:
>c593		02 00				        .byte 2, 0
>c595		9d c5 3a 84 3f 84		        .word nt_page, xt_cr, z_cr
>c59b		63 72				        .text "cr"
.c59d						nt_page:
>c59d		04 00				        .byte 4, 0
>c59f		a9 c5 2f 8d 4c 8d		        .word nt_at_xy, xt_page, z_page
>c5a5		70 61 67 65			        .text "page"
.c5a9						nt_at_xy:
>c5a9		05 10				        .byte 5, UF
>c5ab		b6 c5 a2 82 cf 82		        .word nt_marker, xt_at_xy, z_at_xy
>c5b1		61 74 2d 78 79			        .text "at-xy"
.c5b6						nt_marker:
>c5b6		06 04				        .byte 6, IM
>c5b8		c4 c5 4e 8b 88 8b		        .word nt_words, xt_marker, z_marker
>c5be		6d 61 72 6b 65 72		        .text "marker"
.c5c4						nt_words:
>c5c4		05 00				        .byte 5, 0
>c5c6		d1 c5 ab 99 07 9a		        .word nt_wordsize, xt_words, z_words
>c5cc		77 6f 72 64 73			        .text "words"
.c5d1						nt_wordsize:
>c5d1		08 10				        .byte 8, UF
>c5d3		e1 c5 d5 9d f5 9d		        .word nt_aligned, xt_wordsize, z_wordsize
>c5d9		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c5e1						nt_aligned:
>c5e1		07 00				        .byte 7, 0
>c5e3		f0 c5 26 82 26 82		        .word nt_align, xt_aligned, z_aligned   ; same code as ALIGN
>c5e9		61 6c 69 67 6e 65 64		        .text "aligned"
.c5f0						nt_align:
>c5f0		05 00				        .byte 5, 0
>c5f2		fd c5 26 82 26 82		        .word nt_bell, xt_align, z_align
>c5f8		61 6c 69 67 6e			        .text "align"
.c5fd						nt_bell:
>c5fd		04 00				        .byte 4, 0
>c5ff		09 c6 22 9a 27 9a		        .word nt_dump, xt_bell, z_bell
>c605		62 65 6c 6c			        .text "bell"
.c609						nt_dump:
>c609		04 10				        .byte 4, UF
>c60b		15 c6 9b 98 01 99		        .word nt_dot_s, xt_dump, z_dump
>c611		64 75 6d 70			        .text "dump"
.c615						nt_dot_s:
>c615		02 00				        .byte 2, 0
>c617		1f c6 57 98 9a 98		        .word +, xt_dot_s, z_dot_s
>c61d		2e 73				        .text ".s"
.c61f						+
.c61f						nt_disasm:
>c61f		06 10				        .byte 6, UF
>c621		2d c6 0a a2 10 a2		        .word +, xt_disasm, z_disasm
>c627		64 69 73 61 73 6d		        .text "disasm"
.c62d						+
.c62d						nt_compare:
>c62d		07 10				        .byte 7, UF
>c62f		3c c6 24 a0 88 a0		        .word nt_search, xt_compare, z_compare
>c635		63 6f 6d 70 61 72 65		        .text "compare"
.c63c						nt_search:
>c63c		06 18				        .byte 6, UF+NN
>c63e		4a c6 df a0 7d a1		        .word +, xt_search, z_search
>c644		73 65 61 72 63 68		        .text "search"
.c64a						+
.c64a						nt_environment_q:
>c64a		0c 10				        .byte 12, UF
>c64c		5e c6 dd 86 59 87		        .word +, xt_environment_q, z_environment_q
>c652		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c65a		65 6e 74 3f
.c65e						+
.c65e						nt_find:
>c65e		04 10				        .byte 4, UF
>c660		6a c6 2d 88 74 88		        .word nt_word, xt_find, z_find
>c666		66 69 6e 64			        .text "find"
.c66a						nt_word:
>c66a		04 10				        .byte 4, UF
>c66c		76 c6 37 96 7a 96		        .word nt_paren, xt_word, z_word
>c672		77 6f 72 64			        .text "word"
.c676						nt_paren:
>c676		01 04				        .byte 1, IM
>c678		7f c6 4d 8d 5c 8d		        .word nt_dot_paren, xt_paren, z_paren
>c67e		28				        .text "("
.c67f						nt_dot_paren:
>c67f		02 04				        .byte 2, IM
>c681		89 c6 52 86 60 86		        .word nt_if, xt_dot_paren, z_dot_paren
>c687		2e 28				        .text ".("
.c689						nt_if:
>c689		02 0d				        .byte 2, IM+CO+NN
>c68b		93 c6 54 89 57 89		        .word nt_then, xt_if, z_if
>c691		69 66				        .text "if"
.c693						nt_then:
>c693		04 0d				        .byte 4, IM+CO+NN
>c695		9f c6 b4 86 bd 86		        .word nt_else, xt_then, z_then
>c69b		74 68 65 6e			        .text "then"
.c69f						nt_else:
>c69f		04 0d				        .byte 4, IM+CO+NN
>c6a1		ab c6 ae 86 bd 86		        .word nt_repeat, xt_else, z_else
>c6a7		65 6c 73 65			        .text "else"
.c6ab						nt_repeat:
>c6ab		06 0d				        .byte 6, IM+CO+NN
>c6ad		b9 c6 90 8f 96 8f		        .word nt_until, xt_repeat, z_repeat
>c6b3		72 65 70 65 61 74		        .text "repeat"
.c6b9						nt_until:
>c6b9		05 0d				        .byte 5, IM+CO+NN
>c6bb		c6 c6 ed 95 f0 95		        .word nt_while, xt_until, z_until
>c6c1		75 6e 74 69 6c			        .text "until"
.c6c6						nt_while:
>c6c6		05 0d				        .byte 5, IM+CO+NN
>c6c8		d3 c6 1a 96 20 96		        .word nt_case, xt_while, z_while
>c6ce		77 68 69 6c 65			        .text "while"
.c6d3						nt_case:
>c6d3		04 0d				        .byte 4, IM+CO+NN
>c6d5		df c6 f6 9d fc 9d		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c6db		63 61 73 65			        .text "case"
.c6df						nt_of:
>c6df		02 0d				        .byte 2, IM+CO+NN
>c6e1		e9 c6 d0 8c e8 8c		        .word nt_endof, xt_of, z_of
>c6e7		6f 66				        .text "of"
.c6e9						nt_endof:
>c6e9		05 0d				        .byte 5, IM+CO+NN
>c6eb		f6 c6 ae 86 bd 86		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c6f1		65 6e 64 6f 66			        .text "endof"
.c6f6						nt_endcase:
>c6f6		07 0d				        .byte 7, IM+CO+NN
>c6f8		05 c7 c8 86 dc 86		        .word nt_defer_fetch, xt_endcase, z_endcase
>c6fe		65 6e 64 63 61 73 65		        .text "endcase"
.c705						nt_defer_fetch:
>c705		06 00				        .byte 6, 0
>c707		13 c7 44 85 4a 85		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c70d		64 65 66 65 72 40		        .text "defer@"
.c713						nt_defer_store:
>c713		06 00				        .byte 6, 0
>c715		21 c7 4b 85 51 85		        .word nt_is, xt_defer_store, z_defer_store
>c71b		64 65 66 65 72 21		        .text "defer!"
.c721						nt_is:
>c721		02 04				        .byte 2, IM
>c723		2b c7 74 89 8c 89		        .word nt_action_of, xt_is, z_is
>c729		69 73				        .text "is"
.c72b						nt_action_of:
>c72b		09 04				        .byte 9, IM
>c72d		3c c7 06 82 1e 82		        .word nt_useraddr, xt_action_of, z_action_of
>c733		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c73b		66
.c73c						nt_useraddr:
>c73c		08 00				        .byte 8, 0
>c73e		4c c7 ca 9d d4 9d		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c744		75 73 65 72 61 64 64 72		        .text "useraddr"
.c74c						nt_buffer_colon:
>c74c		07 00				        .byte 7, 0
>c74e		5b c7 1b 83 21 83		        .word +, xt_buffer_colon, z_buffer_colon
>c754		62 75 66 66 65 72 3a		        .text "buffer:"
.c75b						+
.c75b						nt_buffstatus:
>c75b		0a 00				        .byte 10, 0
>c75d		6d c7 5c b0 61 b0		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c763		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c76b		75 73
.c76d						nt_buffblocknum:
>c76d		0c 00				        .byte 12, 0
>c76f		81 c7 26 b0 2b b0		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c775		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c77d		6b 6e 75 6d
.c781						nt_blkbuffer:
>c781		09 00				        .byte 9, 0
>c783		92 c7 1c ae 29 ae		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c789		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c791		72
.c792						nt_scr:
>c792		03 08				        .byte 3, NN
>c794		9d c7 de b0 e3 b0		        .word nt_blk, xt_scr, z_scr
>c79a		73 63 72			        .text "scr"
.c79d						nt_blk:
>c79d		03 08				        .byte 3, NN
>c79f		a8 c7 17 ae 1c ae		        .word nt_block_write, xt_blk, z_blk
>c7a5		62 6c 6b			        .text "blk"
.c7a8						nt_block_write:
>c7a8		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c7aa		bb c7 13 b0 21 b0		        .word nt_block_write_vector, xt_block_write, z_block_write
>c7b0		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c7b8		69 74 65
.c7bb						nt_block_write_vector:
>c7bb		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c7bd		d5 c7 21 b0 26 b0		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c7c3		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c7cb		69 74 65 2d 76 65 63 74 6f 72
.c7d5						nt_block_read:
>c7d5		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c7d7		e7 c7 fb af 09 b0		        .word nt_block_read_vector, xt_block_read, z_block_read
>c7dd		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c7e5		61 64
.c7e7						nt_block_read_vector:
>c7e7		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c7e9		00 c8 09 b0 0e b0		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c7ef		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c7f7		61 64 2d 76 65 63 74 6f 72
.c800						nt_save_buffers:
>c800		0c 00				        .byte 12, 0
>c802		14 c8 c3 b0 dd b0		        .word nt_block, xt_save_buffers, z_save_buffers
>c808		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c810		66 65 72 73
.c814						nt_block:
>c814		05 00				        .byte 5, 0
>c816		21 c8 2a ae 7c ae		        .word nt_update, xt_block, z_block
>c81c		62 6c 6f 63 6b			        .text "block"
.c821						nt_update:
>c821		06 00				        .byte 6, 0
>c823		2f c8 28 b1 30 b1		        .word nt_buffer, xt_update, z_update
>c829		75 70 64 61 74 65		        .text "update"
.c82f						nt_buffer:
>c82f		06 00				        .byte 6, 0
>c831		3d c8 2b b0 5b b0		        .word nt_empty_buffers, xt_buffer, z_buffer
>c837		62 75 66 66 65 72		        .text "buffer"
.c83d						nt_empty_buffers:
>c83d		0d 00				        .byte 13, 0
>c83f		52 c8 61 b0 67 b0		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c845		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c84d		66 66 65 72 73
.c852						nt_flush:
>c852		05 00				        .byte 5, 0
>c854		5f c8 68 b0 71 b0		        .word nt_load, xt_flush, z_flush
>c85a		66 6c 75 73 68			        .text "flush"
.c85f						nt_load:
>c85f		04 10				        .byte 4, UF
>c861		6b c8 7f b0 c2 b0		        .word nt_thru, xt_load, z_load
>c867		6c 6f 61 64			        .text "load"
.c86b						nt_thru:
>c86b		04 10				        .byte 4, UF
>c86d		77 c8 e3 b0 27 b1		        .word +, xt_thru, z_thru
>c873		74 68 72 75			        .text "thru"
.c877						+
.c877						nt_list:
>c877		04 10				        .byte 4, UF
>c879		83 c8 72 b0 7e b0		        .word nt_block_c65_init, xt_list, z_list
>c87f		6c 69 73 74			        .text "list"
.c883						nt_block_c65_init:
>c883		0e 00				        .byte 14, 0
>c885		99 c8 7d ae b2 ae		        .word +, xt_block_c65_init, z_block_c65_init
>c88b		62 6c 6f 63 6b 2d 63 36		        .text "block-c65-init"
>c893		35 2d 69 6e 69 74
.c899						+
.c899						nt_block_ramdrive_init:
>c899		13 10				        .byte 19, UF
>c89b		b4 c8 d5 ae e2 ae		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c8a1		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c8a9		6d 64 72 69 76 65 2d 69 6e 69 74
.c8b4						+
.c8b4						nt_definitions:
>c8b4		0b 00				        .byte 11, 0
>c8b6		c7 c8 66 b2 6e b2		        .word nt_wordlist, xt_definitions, z_definitions
>c8bc		64 65 66 69 6e 69 74 69		        .text "definitions"
>c8c4		6f 6e 73
.c8c7						nt_wordlist:
>c8c7		08 00				        .byte 8, 0
>c8c9		d7 c8 d1 b3 e7 b3		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c8cf		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c8d7						nt_search_wordlist:
>c8d7		0f 10				        .byte 15, UF
>c8d9		ee c8 0a b3 7d b3		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c8df		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c8e7		6f 72 64 6c 69 73 74
.c8ee						nt_set_current:
>c8ee		0b 10				        .byte 11, UF
>c8f0		01 c9 7e b3 89 b3		        .word nt_get_current, xt_set_current, z_set_current
>c8f6		73 65 74 2d 63 75 72 72		        .text "set-current"
>c8fe		65 6e 74
.c901						nt_get_current:
>c901		0b 00				        .byte 11, 0
>c903		14 c9 76 b2 80 b2		        .word nt_set_order, xt_get_current, z_get_current
>c909		67 65 74 2d 63 75 72 72		        .text "get-current"
>c911		65 6e 74
.c914						nt_set_order:
>c914		09 00				        .byte 9, 0
>c916		25 c9 8a b3 bd b3		        .word nt_get_order, xt_set_order, z_set_order
>c91c		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c924		72
.c925						nt_get_order:
>c925		09 00				        .byte 9, 0
>c927		36 c9 81 b2 a9 b2		        .word nt_root_wordlist, xt_get_order, z_get_order
>c92d		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c935		72
.c936						nt_root_wordlist:
>c936		0d 00				        .byte 13, 0
>c938		4b c9 01 b3 09 b3		        .word +, xt_root_wordlist, z_root_wordlist
>c93e		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c946		64 6c 69 73 74
.c94b						+
.c94b						nt_assembler_wordlist:
>c94b		12 00				        .byte 18, 0
>c94d		65 c9 c1 9d c9 9d		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c953		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c95b		72 2d 77 6f 72 64 6c 69 73 74
.c965						+
.c965						nt_editor_wordlist:
>c965		0f 00				        .byte 15, 0
>c967		7c c9 90 9d 98 9d		        .word +, xt_editor_wordlist, z_editor_wordlist
>c96d		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c975		6f 72 64 6c 69 73 74
.c97c						+
.c97c						nt_forth_wordlist:
>c97c		0e 00				        .byte 14, 0
>c97e		92 c9 f6 9d fc 9d		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c984		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c98c		72 64 6c 69 73 74
.c992						nt_only:
>c992		04 00				        .byte 4, 0
>c994		9e c9 aa b2 b0 b2		        .word nt_also, xt_only, z_only
>c99a		6f 6e 6c 79			        .text "only"
.c99e						nt_also:
>c99e		04 00				        .byte 4, 0
>c9a0		aa c9 56 b2 65 b2		        .word nt_previous, xt_also, z_also
>c9a6		61 6c 73 6f			        .text "also"
.c9aa						nt_previous:
>c9aa		08 00				        .byte 8, 0
>c9ac		ba c9 f4 b2 00 b3		        .word nt_to_order, xt_previous, z_previous
>c9b2		70 72 65 76 69 6f 75 73		        .text "previous"
.c9ba						nt_to_order:
>c9ba		06 00				        .byte 6, 0
>c9bc		c8 c9 be b3 d0 b3		        .word nt_order, xt_to_order, z_to_order
>c9c2		3e 6f 72 64 65 72		        .text ">order"
.c9c8						nt_order:
>c9c8		05 00				        .byte 5, 0
>c9ca		d5 c9 b1 b2 db b2		        .word nt_forth, xt_order, z_order
>c9d0		6f 72 64 65 72			        .text "order"
.c9d5						nt_forth:
>c9d5		05 00				        .byte 5, 0
>c9d7		e2 c9 6f b2 75 b2		        .word +, xt_forth, z_forth
>c9dd		66 6f 72 74 68			        .text "forth"
.c9e2						+
>c9e2		03 08				nt_see: .byte 3, NN
>c9e4		ed c9 1d 99 aa 99		        .word +, xt_see, z_see
>c9ea		73 65 65			        .text "see"
.c9ed						+
.c9ed						nt_ed:
>c9ed		03 08				        .byte 3, NN
>c9ef		f8 c9 24 a8 27 a8		        .word +, xt_ed, z_ed
>c9f5		65 64 3a			        .text "ed:"
.c9f8						+
.c9f8						nt_cold:
>c9f8		04 00				        .byte 4, 0
>c9fa		04 ca 00 80 af 80		        .word nt_bye, xt_cold, z_cold
>ca00		63 6f 6c 64			        .text "cold"
.ca04						nt_bye:
>ca04		03				        .byte 3         ; length of word strings
>ca05		00				        .byte 0         ; status byte
>ca06		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca08		54 98				        .word xt_bye    ; start of code block (xt of this word)
>ca0a		57 98				        .word z_bye     ; end of code (RTS)
>ca0c		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca0f						root_dictionary_start:
.ca0f						nt_root_set_order:
>ca0f		09 00				        .byte 9, 0
>ca11		20 ca 8a b3 bd b3		        .word nt_root_forth, xt_set_order, z_set_order
>ca17		73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca1f		72
.ca20						nt_root_forth:
>ca20		05 00				        .byte 5, 0
>ca22		2d ca 6f b2 75 b2		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca28		66 6f 72 74 68			        .text "forth"
.ca2d						nt_root_forth_wordlist:
>ca2d		0e 00				        .byte 14, 0
>ca2f		43 ca f6 9d fc 9d		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca35		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca3d		72 64 6c 69 73 74
.ca43						nt_root_words:
>ca43		05 00				        .byte 5, 0
>ca45		00 00 ab 99 07 9a		        .word 0000, xt_words, z_words
>ca4b		77 6f 72 64 73			        .text "words"
.ca50						editor_dictionary_start:
.ca50						nt_editor_o:
>ca50		01 00				        .byte 1, 0
>ca52		59 ca 10 b2 55 b2		        .word nt_editor_line, xt_editor_o, z_editor_o
>ca58		6f				        .text "o"
.ca59						nt_editor_line:
>ca59		04 10				        .byte 4, UF
>ca5b		65 ca f7 b1 0f b2		        .word nt_editor_l, xt_editor_line, z_editor_line
>ca61		6c 69 6e 65			        .text "line"
.ca65						nt_editor_l:
>ca65		01 00				        .byte 1, 0
>ca67		6e ca 7d b1 f6 b1		        .word nt_editor_el, xt_editor_l, z_editor_l
>ca6d		6c				        .text "l"
.ca6e						nt_editor_el:
>ca6e		02 00				        .byte 2, 0
>ca70		78 ca 6b b1 7c b1		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>ca76		65 6c				        .text "el"
.ca78						nt_editor_erase_screen:
>ca78		0c 00				        .byte 12, 0
>ca7a		8c ca 59 b1 6a b1		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>ca80		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>ca88		72 65 65 6e
.ca8c						nt_editor_enter_screen:
>ca8c		0c 00				        .byte 12, 0
>ca8e		00 00 3d b1 58 b1		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>ca94		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>ca9c		72 65 65 6e
.caa0						assembler_dictionary_start:
.caa0						nt_asm_adc_h:
>caa0		05 0c						.byte 5, IM+NN
>caa2		ad ca				                .word nt_asm_adc_x
>caa4		6e a4 73 a4					.word xt_asm_adc_h, z_asm_adc_h
>caa8		61 64 63 2e 23					.text "adc.#"
.caad						nt_asm_adc_x:
>caad		05 0c						.byte 5, IM+NN
>caaf		ba ca				                .word nt_asm_adc_y
>cab1		73 a4 78 a4					.word xt_asm_adc_x, z_asm_adc_x
>cab5		61 64 63 2e 78					.text "adc.x"
.caba						nt_asm_adc_y:
>caba		05 0c						.byte 5, IM+NN
>cabc		c7 ca				                .word nt_asm_adc_z
>cabe		78 a4 7d a4					.word xt_asm_adc_y, z_asm_adc_y
>cac2		61 64 63 2e 79					.text "adc.y"
.cac7						nt_asm_adc_z:
>cac7		05 0c						.byte 5, IM+NN
>cac9		d4 ca				                .word nt_asm_adc_zi
>cacb		7d a4 82 a4					.word xt_asm_adc_z, z_asm_adc_z
>cacf		61 64 63 2e 7a					.text "adc.z"
.cad4						nt_asm_adc_zi:
>cad4		06 0c						.byte 6, IM+NN
>cad6		e2 ca				                .word nt_asm_adc_ziy
>cad8		82 a4 87 a4					.word xt_asm_adc_zi, z_asm_adc_zi
>cadc		61 64 63 2e 7a 69				.text "adc.zi"
.cae2						nt_asm_adc_ziy:
>cae2		07 0c						.byte 7, IM+NN
>cae4		f1 ca				                .word nt_asm_adc_zx
>cae6		87 a4 8c a4					.word xt_asm_adc_ziy, z_asm_adc_ziy
>caea		61 64 63 2e 7a 69 79				.text "adc.ziy"
.caf1						nt_asm_adc_zx:
>caf1		06 0c						.byte 6, IM+NN
>caf3		ff ca				                .word nt_asm_adc_zxi
>caf5		8c a4 91 a4					.word xt_asm_adc_zx, z_asm_adc_zx
>caf9		61 64 63 2e 7a 78				.text "adc.zx"
.caff						nt_asm_adc_zxi:
>caff		07 0c						.byte 7, IM+NN
>cb01		0e cb				                .word nt_asm_and
>cb03		91 a4 96 a4					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb07		61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb0e						nt_asm_and:
>cb0e		04 0c						.byte 4, IM+NN
>cb10		1a cb				                .word nt_asm_and_h
>cb12		96 a4 9b a4					.word xt_asm_and, z_asm_and
>cb16		61 6e 64 2e					.text "and."
.cb1a						nt_asm_and_h:
>cb1a		05 0c						.byte 5, IM+NN
>cb1c		27 cb				                .word nt_asm_and_x
>cb1e		9b a4 a0 a4					.word xt_asm_and_h, z_asm_and_h
>cb22		61 6e 64 2e 23					.text "and.#"
.cb27						nt_asm_and_x:
>cb27		05 0c						.byte 5, IM+NN
>cb29		34 cb				                .word nt_asm_and_y
>cb2b		a0 a4 a5 a4					.word xt_asm_and_x, z_asm_and_x
>cb2f		61 6e 64 2e 78					.text "and.x"
.cb34						nt_asm_and_y:
>cb34		05 0c						.byte 5, IM+NN
>cb36		41 cb				                .word nt_asm_and_z
>cb38		a5 a4 aa a4					.word xt_asm_and_y, z_asm_and_y
>cb3c		61 6e 64 2e 79					.text "and.y"
.cb41						nt_asm_and_z:
>cb41		05 0c						.byte 5, IM+NN
>cb43		4e cb				                .word nt_asm_and_zi
>cb45		aa a4 af a4					.word xt_asm_and_z, z_asm_and_z
>cb49		61 6e 64 2e 7a					.text "and.z"
.cb4e						nt_asm_and_zi:
>cb4e		06 0c						.byte 6, IM+NN
>cb50		5c cb				                .word nt_asm_and_ziy
>cb52		af a4 b4 a4					.word xt_asm_and_zi, z_asm_and_zi
>cb56		61 6e 64 2e 7a 69				.text "and.zi"
.cb5c						nt_asm_and_ziy:
>cb5c		07 0c						.byte 7, IM+NN
>cb5e		6b cb				                .word nt_asm_and_zx
>cb60		b4 a4 b9 a4					.word xt_asm_and_ziy, z_asm_and_ziy
>cb64		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cb6b						nt_asm_and_zx:
>cb6b		06 0c						.byte 6, IM+NN
>cb6d		79 cb				                .word nt_asm_and_zxi
>cb6f		b9 a4 be a4					.word xt_asm_and_zx, z_asm_and_zx
>cb73		61 6e 64 2e 7a 78				.text "and.zx"
.cb79						nt_asm_and_zxi:
>cb79		07 0c						.byte 7, IM+NN
>cb7b		88 cb				                .word nt_asm_asl
>cb7d		be a4 c3 a4					.word xt_asm_and_zxi, z_asm_and_zxi
>cb81		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cb88						nt_asm_asl:
>cb88		03 0c						.byte 3, IM+NN
>cb8a		93 cb				                .word nt_asm_asl_a
>cb8c		c3 a4 c8 a4					.word xt_asm_asl, z_asm_asl
>cb90		61 73 6c					.text "asl"
.cb93						nt_asm_asl_a:
>cb93		05 0c						.byte 5, IM+NN
>cb95		a0 cb				                .word nt_asm_asl_x
>cb97		c8 a4 cd a4					.word xt_asm_asl_a, z_asm_asl_a
>cb9b		61 73 6c 2e 61					.text "asl.a"
.cba0						nt_asm_asl_x:
>cba0		05 0c						.byte 5, IM+NN
>cba2		ad cb				                .word nt_asm_asl_z
>cba4		cd a4 d2 a4					.word xt_asm_asl_x, z_asm_asl_x
>cba8		61 73 6c 2e 78					.text "asl.x"
.cbad						nt_asm_asl_z:
>cbad		05 0c						.byte 5, IM+NN
>cbaf		ba cb				                .word nt_asm_asl_zx
>cbb1		d2 a4 d7 a4					.word xt_asm_asl_z, z_asm_asl_z
>cbb5		61 73 6c 2e 7a					.text "asl.z"
.cbba						nt_asm_asl_zx:
>cbba		06 0c						.byte 6, IM+NN
>cbbc		c8 cb				                .word nt_asm_bcc
>cbbe		d7 a4 dc a4					.word xt_asm_asl_zx, z_asm_asl_zx
>cbc2		61 73 6c 2e 7a 78				.text "asl.zx"
.cbc8						nt_asm_bcc:
>cbc8		03 0c						.byte 3, IM+NN
>cbca		d3 cb				                .word nt_asm_bcs
>cbcc		dc a4 e1 a4					.word xt_asm_bcc, z_asm_bcc
>cbd0		62 63 63					.text "bcc"
.cbd3						nt_asm_bcs:
>cbd3		03 0c						.byte 3, IM+NN
>cbd5		de cb				                .word nt_asm_beq
>cbd7		e1 a4 e8 a4					.word xt_asm_bcs, z_asm_bcs
>cbdb		62 63 73					.text "bcs"
.cbde						nt_asm_beq:
>cbde		03 0c						.byte 3, IM+NN
>cbe0		e9 cb				                .word nt_asm_bit
>cbe2		e8 a4 ed a4					.word xt_asm_beq, z_asm_beq
>cbe6		62 65 71					.text "beq"
.cbe9						nt_asm_bit:
>cbe9		03 0c						.byte 3, IM+NN
>cbeb		f4 cb				                .word nt_asm_bit_h
>cbed		ed a4 f2 a4					.word xt_asm_bit, z_asm_bit
>cbf1		62 69 74					.text "bit"
.cbf4						nt_asm_bit_h:
>cbf4		05 0c						.byte 5, IM+NN
>cbf6		01 cc				                .word nt_asm_bit_x
>cbf8		f2 a4 f7 a4					.word xt_asm_bit_h, z_asm_bit_h
>cbfc		62 69 74 2e 23					.text "bit.#"
.cc01						nt_asm_bit_x:
>cc01		05 0c						.byte 5, IM+NN
>cc03		0e cc				                .word nt_asm_bit_z
>cc05		f7 a4 fc a4					.word xt_asm_bit_x, z_asm_bit_x
>cc09		62 69 74 2e 78					.text "bit.x"
.cc0e						nt_asm_bit_z:
>cc0e		05 0c						.byte 5, IM+NN
>cc10		1b cc				                .word nt_asm_bit_zx
>cc12		fc a4 01 a5					.word xt_asm_bit_z, z_asm_bit_z
>cc16		62 69 74 2e 7a					.text "bit.z"
.cc1b						nt_asm_bit_zx:
>cc1b		06 0c						.byte 6, IM+NN
>cc1d		29 cc				                .word nt_asm_bmi
>cc1f		01 a5 06 a5					.word xt_asm_bit_zx, z_asm_bit_zx
>cc23		62 69 74 2e 7a 78				.text "bit.zx"
.cc29						nt_asm_bmi:
>cc29		03 0c						.byte 3, IM+NN
>cc2b		34 cc				                .word nt_asm_bne
>cc2d		06 a5 0b a5					.word xt_asm_bmi, z_asm_bmi
>cc31		62 6d 69					.text "bmi"
.cc34						nt_asm_bne:
>cc34		03 0c						.byte 3, IM+NN
>cc36		3f cc				                .word nt_asm_bpl
>cc38		0b a5 10 a5					.word xt_asm_bne, z_asm_bne
>cc3c		62 6e 65					.text "bne"
.cc3f						nt_asm_bpl:
>cc3f		03 0c						.byte 3, IM+NN
>cc41		4a cc				                .word nt_asm_bra
>cc43		10 a5 15 a5					.word xt_asm_bpl, z_asm_bpl
>cc47		62 70 6c					.text "bpl"
.cc4a						nt_asm_bra:
>cc4a		03 0c						.byte 3, IM+NN
>cc4c		55 cc				                .word nt_asm_brk
>cc4e		15 a5 1a a5					.word xt_asm_bra, z_asm_bra
>cc52		62 72 61					.text "bra"
.cc55						nt_asm_brk:
>cc55		03 0c						.byte 3, IM+NN
>cc57		60 cc				                .word nt_asm_bvc
>cc59		1a a5 1f a5					.word xt_asm_brk, z_asm_brk
>cc5d		62 72 6b					.text "brk"
.cc60						nt_asm_bvc:
>cc60		03 0c						.byte 3, IM+NN
>cc62		6b cc				                .word nt_asm_bvs
>cc64		1f a5 24 a5					.word xt_asm_bvc, z_asm_bvc
>cc68		62 76 63					.text "bvc"
.cc6b						nt_asm_bvs:
>cc6b		03 0c						.byte 3, IM+NN
>cc6d		76 cc				                .word nt_asm_clc
>cc6f		24 a5 29 a5					.word xt_asm_bvs, z_asm_bvs
>cc73		62 76 73					.text "bvs"
.cc76						nt_asm_clc:
>cc76		03 0c						.byte 3, IM+NN
>cc78		81 cc				                .word nt_asm_cld
>cc7a		29 a5 2e a5					.word xt_asm_clc, z_asm_clc
>cc7e		63 6c 63					.text "clc"
.cc81						nt_asm_cld:
>cc81		03 0c						.byte 3, IM+NN
>cc83		8c cc				                .word nt_asm_cli
>cc85		2e a5 33 a5					.word xt_asm_cld, z_asm_cld
>cc89		63 6c 64					.text "cld"
.cc8c						nt_asm_cli:
>cc8c		03 0c						.byte 3, IM+NN
>cc8e		97 cc				                .word nt_asm_clv
>cc90		33 a5 38 a5					.word xt_asm_cli, z_asm_cli
>cc94		63 6c 69					.text "cli"
.cc97						nt_asm_clv:
>cc97		03 0c						.byte 3, IM+NN
>cc99		a2 cc				                .word nt_asm_cmp
>cc9b		38 a5 3d a5					.word xt_asm_clv, z_asm_clv
>cc9f		63 6c 76					.text "clv"
.cca2						nt_asm_cmp:
>cca2		03 0c						.byte 3, IM+NN
>cca4		ad cc				                .word nt_asm_cmp_h
>cca6		3d a5 42 a5					.word xt_asm_cmp, z_asm_cmp
>ccaa		63 6d 70					.text "cmp"
.ccad						nt_asm_cmp_h:
>ccad		05 0c						.byte 5, IM+NN
>ccaf		ba cc				                .word nt_asm_cmp_x
>ccb1		42 a5 47 a5					.word xt_asm_cmp_h, z_asm_cmp_h
>ccb5		63 6d 70 2e 23					.text "cmp.#"
.ccba						nt_asm_cmp_x:
>ccba		05 0c						.byte 5, IM+NN
>ccbc		c7 cc				                .word nt_asm_cmp_y
>ccbe		47 a5 4c a5					.word xt_asm_cmp_x, z_asm_cmp_x
>ccc2		63 6d 70 2e 78					.text "cmp.x"
.ccc7						nt_asm_cmp_y:
>ccc7		05 0c						.byte 5, IM+NN
>ccc9		d4 cc				                .word nt_asm_cmp_z
>cccb		4c a5 51 a5					.word xt_asm_cmp_y, z_asm_cmp_y
>cccf		63 6d 70 2e 79					.text "cmp.y"
.ccd4						nt_asm_cmp_z:
>ccd4		05 0c						.byte 5, IM+NN
>ccd6		e1 cc				                .word nt_asm_cmp_zi
>ccd8		51 a5 56 a5					.word xt_asm_cmp_z, z_asm_cmp_z
>ccdc		63 6d 70 2e 7a					.text "cmp.z"
.cce1						nt_asm_cmp_zi:
>cce1		06 0c						.byte 6, IM+NN
>cce3		ef cc				                .word nt_asm_cmp_ziy
>cce5		56 a5 5b a5					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cce9		63 6d 70 2e 7a 69				.text "cmp.zi"
.ccef						nt_asm_cmp_ziy:
>ccef		07 0c						.byte 7, IM+NN
>ccf1		fe cc				                .word nt_asm_cmp_zx
>ccf3		5b a5 60 a5					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>ccf7		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.ccfe						nt_asm_cmp_zx:
>ccfe		06 0c						.byte 6, IM+NN
>cd00		0c cd				                .word nt_asm_cmp_zxi
>cd02		60 a5 65 a5					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd06		63 6d 70 2e 7a 78				.text "cmp.zx"
.cd0c						nt_asm_cmp_zxi:
>cd0c		07 0c						.byte 7, IM+NN
>cd0e		1b cd				                .word nt_asm_cpx
>cd10		65 a5 6a a5					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd14		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd1b						nt_asm_cpx:
>cd1b		03 0c						.byte 3, IM+NN
>cd1d		26 cd				                .word nt_asm_cpx_h
>cd1f		6a a5 6f a5					.word xt_asm_cpx, z_asm_cpx
>cd23		63 70 78					.text "cpx"
.cd26						nt_asm_cpx_h:
>cd26		05 0c						.byte 5, IM+NN
>cd28		33 cd				                .word nt_asm_cpx_z
>cd2a		6f a5 74 a5					.word xt_asm_cpx_h, z_asm_cpx_h
>cd2e		63 70 78 2e 23					.text "cpx.#"
.cd33						nt_asm_cpx_z:
>cd33		05 0c						.byte 5, IM+NN
>cd35		40 cd				                .word nt_asm_cpy
>cd37		74 a5 79 a5					.word xt_asm_cpx_z, z_asm_cpx_z
>cd3b		63 70 78 2e 7a					.text "cpx.z"
.cd40						nt_asm_cpy:
>cd40		03 0c						.byte 3, IM+NN
>cd42		4b cd				                .word nt_asm_cpy_h
>cd44		79 a5 80 a5					.word xt_asm_cpy, z_asm_cpy
>cd48		63 70 79					.text "cpy"
.cd4b						nt_asm_cpy_h:
>cd4b		05 0c						.byte 5, IM+NN
>cd4d		58 cd				                .word nt_asm_cpy_z
>cd4f		80 a5 85 a5					.word xt_asm_cpy_h, z_asm_cpy_h
>cd53		63 70 79 2e 23					.text "cpy.#"
.cd58						nt_asm_cpy_z:
>cd58		05 0c						.byte 5, IM+NN
>cd5a		65 cd				                .word nt_asm_dec
>cd5c		85 a5 8a a5					.word xt_asm_cpy_z, z_asm_cpy_z
>cd60		63 70 79 2e 7a					.text "cpy.z"
.cd65						nt_asm_dec:
>cd65		03 0c						.byte 3, IM+NN
>cd67		70 cd				                .word nt_asm_dec_a
>cd69		8a a5 8f a5					.word xt_asm_dec, z_asm_dec
>cd6d		64 65 63					.text "dec"
.cd70						nt_asm_dec_a:
>cd70		05 0c						.byte 5, IM+NN
>cd72		7d cd				                .word nt_asm_dec_x
>cd74		8f a5 94 a5					.word xt_asm_dec_a, z_asm_dec_a
>cd78		64 65 63 2e 61					.text "dec.a"
.cd7d						nt_asm_dec_x:
>cd7d		05 0c						.byte 5, IM+NN
>cd7f		8a cd				                .word nt_asm_dec_z
>cd81		94 a5 99 a5					.word xt_asm_dec_x, z_asm_dec_x
>cd85		64 65 63 2e 78					.text "dec.x"
.cd8a						nt_asm_dec_z:
>cd8a		05 0c						.byte 5, IM+NN
>cd8c		97 cd				                .word nt_asm_dec_zx
>cd8e		99 a5 9e a5					.word xt_asm_dec_z, z_asm_dec_z
>cd92		64 65 63 2e 7a					.text "dec.z"
.cd97						nt_asm_dec_zx:
>cd97		06 0c						.byte 6, IM+NN
>cd99		a5 cd				                .word nt_asm_dex
>cd9b		9e a5 a3 a5					.word xt_asm_dec_zx, z_asm_dec_zx
>cd9f		64 65 63 2e 7a 78				.text "dec.zx"
.cda5						nt_asm_dex:
>cda5		03 0c						.byte 3, IM+NN
>cda7		b0 cd				                .word nt_asm_dey
>cda9		a3 a5 a8 a5					.word xt_asm_dex, z_asm_dex
>cdad		64 65 78					.text "dex"
.cdb0						nt_asm_dey:
>cdb0		03 0c						.byte 3, IM+NN
>cdb2		bb cd				                .word nt_asm_eor
>cdb4		a8 a5 ad a5					.word xt_asm_dey, z_asm_dey
>cdb8		64 65 79					.text "dey"
.cdbb						nt_asm_eor:
>cdbb		03 0c						.byte 3, IM+NN
>cdbd		c6 cd				                .word nt_asm_eor_h
>cdbf		ad a5 b2 a5					.word xt_asm_eor, z_asm_eor
>cdc3		65 6f 72					.text "eor"
.cdc6						nt_asm_eor_h:
>cdc6		05 0c						.byte 5, IM+NN
>cdc8		d3 cd				                .word nt_asm_eor_x
>cdca		b2 a5 b7 a5					.word xt_asm_eor_h, z_asm_eor_h
>cdce		65 6f 72 2e 23					.text "eor.#"
.cdd3						nt_asm_eor_x:
>cdd3		05 0c						.byte 5, IM+NN
>cdd5		e0 cd				                .word nt_asm_eor_y
>cdd7		b7 a5 bc a5					.word xt_asm_eor_x, z_asm_eor_x
>cddb		65 6f 72 2e 78					.text "eor.x"
.cde0						nt_asm_eor_y:
>cde0		05 0c						.byte 5, IM+NN
>cde2		ed cd				                .word nt_asm_eor_z
>cde4		bc a5 c1 a5					.word xt_asm_eor_y, z_asm_eor_y
>cde8		65 6f 72 2e 79					.text "eor.y"
.cded						nt_asm_eor_z:
>cded		05 0c						.byte 5, IM+NN
>cdef		fa cd				                .word nt_asm_eor_zi
>cdf1		c1 a5 c6 a5					.word xt_asm_eor_z, z_asm_eor_z
>cdf5		65 6f 72 2e 7a					.text "eor.z"
.cdfa						nt_asm_eor_zi:
>cdfa		06 0c						.byte 6, IM+NN
>cdfc		08 ce				                .word nt_asm_eor_ziy
>cdfe		c6 a5 cb a5					.word xt_asm_eor_zi, z_asm_eor_zi
>ce02		65 6f 72 2e 7a 69				.text "eor.zi"
.ce08						nt_asm_eor_ziy:
>ce08		07 0c						.byte 7, IM+NN
>ce0a		17 ce				                .word nt_asm_eor_zx
>ce0c		cb a5 d0 a5					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce10		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce17						nt_asm_eor_zx:
>ce17		06 0c						.byte 6, IM+NN
>ce19		25 ce				                .word nt_asm_eor_zxi
>ce1b		d0 a5 d5 a5					.word xt_asm_eor_zx, z_asm_eor_zx
>ce1f		65 6f 72 2e 7a 78				.text "eor.zx"
.ce25						nt_asm_eor_zxi:
>ce25		07 0c						.byte 7, IM+NN
>ce27		34 ce				                .word nt_asm_inc
>ce29		d5 a5 da a5					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce2d		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce34						nt_asm_inc:
>ce34		03 0c						.byte 3, IM+NN
>ce36		3f ce				                .word nt_asm_inc_a
>ce38		da a5 df a5					.word xt_asm_inc, z_asm_inc
>ce3c		69 6e 63					.text "inc"
.ce3f						nt_asm_inc_a:
>ce3f		05 0c						.byte 5, IM+NN
>ce41		4c ce				                .word nt_asm_inc_x
>ce43		df a5 e4 a5					.word xt_asm_inc_a, z_asm_inc_a
>ce47		69 6e 63 2e 61					.text "inc.a"
.ce4c						nt_asm_inc_x:
>ce4c		05 0c						.byte 5, IM+NN
>ce4e		59 ce				                .word nt_asm_inc_z
>ce50		e4 a5 e9 a5					.word xt_asm_inc_x, z_asm_inc_x
>ce54		69 6e 63 2e 78					.text "inc.x"
.ce59						nt_asm_inc_z:
>ce59		05 0c						.byte 5, IM+NN
>ce5b		66 ce				                .word nt_asm_inc_zx
>ce5d		e9 a5 ee a5					.word xt_asm_inc_z, z_asm_inc_z
>ce61		69 6e 63 2e 7a					.text "inc.z"
.ce66						nt_asm_inc_zx:
>ce66		06 0c						.byte 6, IM+NN
>ce68		74 ce				                .word nt_asm_inx
>ce6a		ee a5 f3 a5					.word xt_asm_inc_zx, z_asm_inc_zx
>ce6e		69 6e 63 2e 7a 78				.text "inc.zx"
.ce74						nt_asm_inx:
>ce74		03 0c						.byte 3, IM+NN
>ce76		7f ce				                .word nt_asm_iny
>ce78		f3 a5 f8 a5					.word xt_asm_inx, z_asm_inx
>ce7c		69 6e 78					.text "inx"
.ce7f						nt_asm_iny:
>ce7f		03 0c						.byte 3, IM+NN
>ce81		8a ce				                .word nt_asm_jmp
>ce83		f8 a5 fd a5					.word xt_asm_iny, z_asm_iny
>ce87		69 6e 79					.text "iny"
.ce8a						nt_asm_jmp:
>ce8a		03 0c						.byte 3, IM+NN
>ce8c		95 ce				                .word nt_asm_jmp_i
>ce8e		fd a5 02 a6					.word xt_asm_jmp, z_asm_jmp
>ce92		6a 6d 70					.text "jmp"
.ce95						nt_asm_jmp_i:
>ce95		05 0c						.byte 5, IM+NN
>ce97		a2 ce				                .word nt_asm_jmp_xi
>ce99		02 a6 07 a6					.word xt_asm_jmp_i, z_asm_jmp_i
>ce9d		6a 6d 70 2e 69					.text "jmp.i"
.cea2						nt_asm_jmp_xi:
>cea2		06 0c						.byte 6, IM+NN
>cea4		b0 ce				                .word nt_asm_jsr
>cea6		07 a6 0c a6					.word xt_asm_jmp_xi, z_asm_jmp_xi
>ceaa		6a 6d 70 2e 78 69				.text "jmp.xi"
.ceb0						nt_asm_jsr:
>ceb0		03 0c						.byte 3, IM+NN
>ceb2		bb ce				                .word nt_asm_lda
>ceb4		0c a6 11 a6					.word xt_asm_jsr, z_asm_jsr
>ceb8		6a 73 72					.text "jsr"
.cebb						nt_asm_lda:
>cebb		03 0c						.byte 3, IM+NN
>cebd		c6 ce				                .word nt_asm_lda_h
>cebf		11 a6 16 a6					.word xt_asm_lda, z_asm_lda
>cec3		6c 64 61					.text "lda"
.cec6						nt_asm_lda_h:
>cec6		05 0c						.byte 5, IM+NN
>cec8		d3 ce				                .word nt_asm_lda_x
>ceca		16 a6 1b a6					.word xt_asm_lda_h, z_asm_lda_h
>cece		6c 64 61 2e 23					.text "lda.#"
.ced3						nt_asm_lda_x:
>ced3		05 0c						.byte 5, IM+NN
>ced5		e0 ce				                .word nt_asm_lda_y
>ced7		1b a6 20 a6					.word xt_asm_lda_x, z_asm_lda_x
>cedb		6c 64 61 2e 78					.text "lda.x"
.cee0						nt_asm_lda_y:
>cee0		05 0c						.byte 5, IM+NN
>cee2		ed ce				                .word nt_asm_lda_z
>cee4		20 a6 25 a6					.word xt_asm_lda_y, z_asm_lda_y
>cee8		6c 64 61 2e 79					.text "lda.y"
.ceed						nt_asm_lda_z:
>ceed		05 0c						.byte 5, IM+NN
>ceef		fa ce				                .word nt_asm_lda_zi
>cef1		25 a6 2a a6					.word xt_asm_lda_z, z_asm_lda_z
>cef5		6c 64 61 2e 7a					.text "lda.z"
.cefa						nt_asm_lda_zi:
>cefa		06 0c						.byte 6, IM+NN
>cefc		08 cf				                .word nt_asm_lda_ziy
>cefe		2a a6 2f a6					.word xt_asm_lda_zi, z_asm_lda_zi
>cf02		6c 64 61 2e 7a 69				.text "lda.zi"
.cf08						nt_asm_lda_ziy:
>cf08		07 0c						.byte 7, IM+NN
>cf0a		17 cf				                .word nt_asm_lda_zx
>cf0c		2f a6 34 a6					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf10		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf17						nt_asm_lda_zx:
>cf17		06 0c						.byte 6, IM+NN
>cf19		25 cf				                .word nt_asm_lda_zxi
>cf1b		34 a6 39 a6					.word xt_asm_lda_zx, z_asm_lda_zx
>cf1f		6c 64 61 2e 7a 78				.text "lda.zx"
.cf25						nt_asm_lda_zxi:
>cf25		07 0c						.byte 7, IM+NN
>cf27		34 cf				                .word nt_asm_ldx
>cf29		39 a6 3e a6					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf2d		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf34						nt_asm_ldx:
>cf34		03 0c						.byte 3, IM+NN
>cf36		3f cf				                .word nt_asm_ldx_h
>cf38		3e a6 43 a6					.word xt_asm_ldx, z_asm_ldx
>cf3c		6c 64 78					.text "ldx"
.cf3f						nt_asm_ldx_h:
>cf3f		05 0c						.byte 5, IM+NN
>cf41		4c cf				                .word nt_asm_ldx_y
>cf43		43 a6 48 a6					.word xt_asm_ldx_h, z_asm_ldx_h
>cf47		6c 64 78 2e 23					.text "ldx.#"
.cf4c						nt_asm_ldx_y:
>cf4c		05 0c						.byte 5, IM+NN
>cf4e		59 cf				                .word nt_asm_ldx_z
>cf50		48 a6 4d a6					.word xt_asm_ldx_y, z_asm_ldx_y
>cf54		6c 64 78 2e 79					.text "ldx.y"
.cf59						nt_asm_ldx_z:
>cf59		05 0c						.byte 5, IM+NN
>cf5b		66 cf				                .word nt_asm_ldx_zy
>cf5d		4d a6 52 a6					.word xt_asm_ldx_z, z_asm_ldx_z
>cf61		6c 64 78 2e 7a					.text "ldx.z"
.cf66						nt_asm_ldx_zy:
>cf66		06 0c						.byte 6, IM+NN
>cf68		74 cf				                .word nt_asm_ldy
>cf6a		52 a6 57 a6					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cf6e		6c 64 78 2e 7a 79				.text "ldx.zy"
.cf74						nt_asm_ldy:
>cf74		03 0c						.byte 3, IM+NN
>cf76		7f cf				                .word nt_asm_ldy_h
>cf78		57 a6 5c a6					.word xt_asm_ldy, z_asm_ldy
>cf7c		6c 64 79					.text "ldy"
.cf7f						nt_asm_ldy_h:
>cf7f		05 0c						.byte 5, IM+NN
>cf81		8c cf				                .word nt_asm_ldy_x
>cf83		5c a6 61 a6					.word xt_asm_ldy_h, z_asm_ldy_h
>cf87		6c 64 79 2e 23					.text "ldy.#"
.cf8c						nt_asm_ldy_x:
>cf8c		05 0c						.byte 5, IM+NN
>cf8e		99 cf				                .word nt_asm_ldy_z
>cf90		61 a6 66 a6					.word xt_asm_ldy_x, z_asm_ldy_x
>cf94		6c 64 79 2e 78					.text "ldy.x"
.cf99						nt_asm_ldy_z:
>cf99		05 0c						.byte 5, IM+NN
>cf9b		a6 cf				                .word nt_asm_ldy_zx
>cf9d		66 a6 6b a6					.word xt_asm_ldy_z, z_asm_ldy_z
>cfa1		6c 64 79 2e 7a					.text "ldy.z"
.cfa6						nt_asm_ldy_zx:
>cfa6		06 0c						.byte 6, IM+NN
>cfa8		b4 cf				                .word nt_asm_lsr
>cfaa		6b a6 70 a6					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cfae		6c 64 79 2e 7a 78				.text "ldy.zx"
.cfb4						nt_asm_lsr:
>cfb4		03 0c						.byte 3, IM+NN
>cfb6		bf cf				                .word nt_asm_lsr_a
>cfb8		70 a6 75 a6					.word xt_asm_lsr, z_asm_lsr
>cfbc		6c 73 72					.text "lsr"
.cfbf						nt_asm_lsr_a:
>cfbf		05 0c						.byte 5, IM+NN
>cfc1		cc cf				                .word nt_asm_lsr_x
>cfc3		75 a6 7a a6					.word xt_asm_lsr_a, z_asm_lsr_a
>cfc7		6c 73 72 2e 61					.text "lsr.a"
.cfcc						nt_asm_lsr_x:
>cfcc		05 0c						.byte 5, IM+NN
>cfce		d9 cf				                .word nt_asm_lsr_z
>cfd0		7a a6 7f a6					.word xt_asm_lsr_x, z_asm_lsr_x
>cfd4		6c 73 72 2e 78					.text "lsr.x"
.cfd9						nt_asm_lsr_z:
>cfd9		05 0c						.byte 5, IM+NN
>cfdb		e6 cf				                .word nt_asm_lsr_zx
>cfdd		7f a6 84 a6					.word xt_asm_lsr_z, z_asm_lsr_z
>cfe1		6c 73 72 2e 7a					.text "lsr.z"
.cfe6						nt_asm_lsr_zx:
>cfe6		06 0c						.byte 6, IM+NN
>cfe8		f4 cf				                .word nt_asm_nop
>cfea		84 a6 89 a6					.word xt_asm_lsr_zx, z_asm_lsr_zx
>cfee		6c 73 72 2e 7a 78				.text "lsr.zx"
.cff4						nt_asm_nop:
>cff4		03 0c						.byte 3, IM+NN
>cff6		ff cf				                .word nt_asm_ora
>cff8		89 a6 8e a6					.word xt_asm_nop, z_asm_nop
>cffc		6e 6f 70					.text "nop"
.cfff						nt_asm_ora:
>cfff		03 0c						.byte 3, IM+NN
>d001		0a d0				                .word nt_asm_ora_h
>d003		8e a6 93 a6					.word xt_asm_ora, z_asm_ora
>d007		6f 72 61					.text "ora"
.d00a						nt_asm_ora_h:
>d00a		05 0c						.byte 5, IM+NN
>d00c		17 d0				                .word nt_asm_ora_x
>d00e		93 a6 98 a6					.word xt_asm_ora_h, z_asm_ora_h
>d012		6f 72 61 2e 23					.text "ora.#"
.d017						nt_asm_ora_x:
>d017		05 0c						.byte 5, IM+NN
>d019		24 d0				                .word nt_asm_ora_y
>d01b		98 a6 9d a6					.word xt_asm_ora_x, z_asm_ora_x
>d01f		6f 72 61 2e 78					.text "ora.x"
.d024						nt_asm_ora_y:
>d024		05 0c						.byte 5, IM+NN
>d026		31 d0				                .word nt_asm_ora_z
>d028		9d a6 a2 a6					.word xt_asm_ora_y, z_asm_ora_y
>d02c		6f 72 61 2e 79					.text "ora.y"
.d031						nt_asm_ora_z:
>d031		05 0c						.byte 5, IM+NN
>d033		3e d0				                .word nt_asm_ora_zi
>d035		a2 a6 a7 a6					.word xt_asm_ora_z, z_asm_ora_z
>d039		6f 72 61 2e 7a					.text "ora.z"
.d03e						nt_asm_ora_zi:
>d03e		06 0c						.byte 6, IM+NN
>d040		4c d0				                .word nt_asm_ora_ziy
>d042		a7 a6 ae a6					.word xt_asm_ora_zi, z_asm_ora_zi
>d046		6f 72 61 2e 7a 69				.text "ora.zi"
.d04c						nt_asm_ora_ziy:
>d04c		07 0c						.byte 7, IM+NN
>d04e		5b d0				                .word nt_asm_ora_zx
>d050		ae a6 b3 a6					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d054		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d05b						nt_asm_ora_zx:
>d05b		06 0c						.byte 6, IM+NN
>d05d		69 d0				                .word nt_asm_ora_zxi
>d05f		b3 a6 b8 a6					.word xt_asm_ora_zx, z_asm_ora_zx
>d063		6f 72 61 2e 7a 78				.text "ora.zx"
.d069						nt_asm_ora_zxi:
>d069		07 0c						.byte 7, IM+NN
>d06b		78 d0				                .word nt_asm_pha
>d06d		b8 a6 bd a6					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d071		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d078						nt_asm_pha:
>d078		03 0c						.byte 3, IM+NN
>d07a		83 d0				                .word nt_asm_php
>d07c		bd a6 c2 a6					.word xt_asm_pha, z_asm_pha
>d080		70 68 61					.text "pha"
.d083						nt_asm_php:
>d083		03 0c						.byte 3, IM+NN
>d085		8e d0				                .word nt_asm_phx
>d087		c2 a6 c7 a6					.word xt_asm_php, z_asm_php
>d08b		70 68 70					.text "php"
.d08e						nt_asm_phx:
>d08e		03 0c						.byte 3, IM+NN
>d090		99 d0				                .word nt_asm_phy
>d092		c7 a6 cc a6					.word xt_asm_phx, z_asm_phx
>d096		70 68 78					.text "phx"
.d099						nt_asm_phy:
>d099		03 0c						.byte 3, IM+NN
>d09b		a4 d0				                .word nt_asm_pla
>d09d		cc a6 d1 a6					.word xt_asm_phy, z_asm_phy
>d0a1		70 68 79					.text "phy"
.d0a4						nt_asm_pla:
>d0a4		03 0c						.byte 3, IM+NN
>d0a6		af d0				                .word nt_asm_plp
>d0a8		d1 a6 d6 a6					.word xt_asm_pla, z_asm_pla
>d0ac		70 6c 61					.text "pla"
.d0af						nt_asm_plp:
>d0af		03 0c						.byte 3, IM+NN
>d0b1		ba d0				                .word nt_asm_plx
>d0b3		d6 a6 db a6					.word xt_asm_plp, z_asm_plp
>d0b7		70 6c 70					.text "plp"
.d0ba						nt_asm_plx:
>d0ba		03 0c						.byte 3, IM+NN
>d0bc		c5 d0				                .word nt_asm_ply
>d0be		db a6 e0 a6					.word xt_asm_plx, z_asm_plx
>d0c2		70 6c 78					.text "plx"
.d0c5						nt_asm_ply:
>d0c5		03 0c						.byte 3, IM+NN
>d0c7		d0 d0				                .word nt_asm_rol
>d0c9		e0 a6 e5 a6					.word xt_asm_ply, z_asm_ply
>d0cd		70 6c 79					.text "ply"
.d0d0						nt_asm_rol:
>d0d0		03 0c						.byte 3, IM+NN
>d0d2		db d0				                .word nt_asm_rol_a
>d0d4		e5 a6 ea a6					.word xt_asm_rol, z_asm_rol
>d0d8		72 6f 6c					.text "rol"
.d0db						nt_asm_rol_a:
>d0db		05 0c						.byte 5, IM+NN
>d0dd		e8 d0				                .word nt_asm_rol_x
>d0df		ea a6 ef a6					.word xt_asm_rol_a, z_asm_rol_a
>d0e3		72 6f 6c 2e 61					.text "rol.a"
.d0e8						nt_asm_rol_x:
>d0e8		05 0c						.byte 5, IM+NN
>d0ea		f5 d0				                .word nt_asm_rol_z
>d0ec		ef a6 f4 a6					.word xt_asm_rol_x, z_asm_rol_x
>d0f0		72 6f 6c 2e 78					.text "rol.x"
.d0f5						nt_asm_rol_z:
>d0f5		05 0c						.byte 5, IM+NN
>d0f7		02 d1				                .word nt_asm_rol_zx
>d0f9		f4 a6 f9 a6					.word xt_asm_rol_z, z_asm_rol_z
>d0fd		72 6f 6c 2e 7a					.text "rol.z"
.d102						nt_asm_rol_zx:
>d102		06 0c						.byte 6, IM+NN
>d104		10 d1				                .word nt_asm_ror
>d106		f9 a6 fe a6					.word xt_asm_rol_zx, z_asm_rol_zx
>d10a		72 6f 6c 2e 7a 78				.text "rol.zx"
.d110						nt_asm_ror:
>d110		03 0c						.byte 3, IM+NN
>d112		1b d1				                .word nt_asm_ror_a
>d114		fe a6 03 a7					.word xt_asm_ror, z_asm_ror
>d118		72 6f 72					.text "ror"
.d11b						nt_asm_ror_a:
>d11b		05 0c						.byte 5, IM+NN
>d11d		28 d1				                .word nt_asm_ror_x
>d11f		03 a7 08 a7					.word xt_asm_ror_a, z_asm_ror_a
>d123		72 6f 72 2e 61					.text "ror.a"
.d128						nt_asm_ror_x:
>d128		05 0c						.byte 5, IM+NN
>d12a		35 d1				                .word nt_asm_ror_z
>d12c		08 a7 0d a7					.word xt_asm_ror_x, z_asm_ror_x
>d130		72 6f 72 2e 78					.text "ror.x"
.d135						nt_asm_ror_z:
>d135		05 0c						.byte 5, IM+NN
>d137		42 d1				                .word nt_asm_ror_zx
>d139		0d a7 12 a7					.word xt_asm_ror_z, z_asm_ror_z
>d13d		72 6f 72 2e 7a					.text "ror.z"
.d142						nt_asm_ror_zx:
>d142		06 0c						.byte 6, IM+NN
>d144		50 d1				                .word nt_asm_rti
>d146		12 a7 17 a7					.word xt_asm_ror_zx, z_asm_ror_zx
>d14a		72 6f 72 2e 7a 78				.text "ror.zx"
.d150						nt_asm_rti:
>d150		03 0c						.byte 3, IM+NN
>d152		5b d1				                .word nt_asm_rts
>d154		17 a7 1c a7					.word xt_asm_rti, z_asm_rti
>d158		72 74 69					.text "rti"
.d15b						nt_asm_rts:
>d15b		03 0c						.byte 3, IM+NN
>d15d		66 d1				                .word nt_asm_sbc
>d15f		1c a7 21 a7					.word xt_asm_rts, z_asm_rts
>d163		72 74 73					.text "rts"
.d166						nt_asm_sbc:
>d166		03 0c						.byte 3, IM+NN
>d168		71 d1				                .word nt_asm_sbc_h
>d16a		21 a7 26 a7					.word xt_asm_sbc, z_asm_sbc
>d16e		73 62 63					.text "sbc"
.d171						nt_asm_sbc_h:
>d171		05 0c						.byte 5, IM+NN
>d173		7e d1				                .word nt_asm_sbc_x
>d175		26 a7 2b a7					.word xt_asm_sbc_h, z_asm_sbc_h
>d179		73 62 63 2e 23					.text "sbc.#"
.d17e						nt_asm_sbc_x:
>d17e		05 0c						.byte 5, IM+NN
>d180		8b d1				                .word nt_asm_sbc_y
>d182		2b a7 30 a7					.word xt_asm_sbc_x, z_asm_sbc_x
>d186		73 62 63 2e 78					.text "sbc.x"
.d18b						nt_asm_sbc_y:
>d18b		05 0c						.byte 5, IM+NN
>d18d		98 d1				                .word nt_asm_sbc_z
>d18f		30 a7 35 a7					.word xt_asm_sbc_y, z_asm_sbc_y
>d193		73 62 63 2e 79					.text "sbc.y"
.d198						nt_asm_sbc_z:
>d198		05 0c						.byte 5, IM+NN
>d19a		a5 d1				                .word nt_asm_sbc_zi
>d19c		35 a7 3a a7					.word xt_asm_sbc_z, z_asm_sbc_z
>d1a0		73 62 63 2e 7a					.text "sbc.z"
.d1a5						nt_asm_sbc_zi:
>d1a5		06 0c						.byte 6, IM+NN
>d1a7		b3 d1				                .word nt_asm_sbc_ziy
>d1a9		3a a7 3f a7					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d1ad		73 62 63 2e 7a 69				.text "sbc.zi"
.d1b3						nt_asm_sbc_ziy:
>d1b3		07 0c						.byte 7, IM+NN
>d1b5		c2 d1				                .word nt_asm_sbc_zx
>d1b7		3f a7 44 a7					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d1bb		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d1c2						nt_asm_sbc_zx:
>d1c2		06 0c						.byte 6, IM+NN
>d1c4		d0 d1				                .word nt_asm_sbc_zxi
>d1c6		44 a7 49 a7					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d1ca		73 62 63 2e 7a 78				.text "sbc.zx"
.d1d0						nt_asm_sbc_zxi:
>d1d0		07 0c						.byte 7, IM+NN
>d1d2		df d1				                .word nt_asm_sec
>d1d4		49 a7 4d a7					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d1d8		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d1df						nt_asm_sec:
>d1df		03 0c						.byte 3, IM+NN
>d1e1		ea d1				                .word nt_asm_sed
>d1e3		4d a7 51 a7					.word xt_asm_sec, z_asm_sec
>d1e7		73 65 63					.text "sec"
.d1ea						nt_asm_sed:
>d1ea		03 0c						.byte 3, IM+NN
>d1ec		f5 d1				                .word nt_asm_sei
>d1ee		51 a7 55 a7					.word xt_asm_sed, z_asm_sed
>d1f2		73 65 64					.text "sed"
.d1f5						nt_asm_sei:
>d1f5		03 0c						.byte 3, IM+NN
>d1f7		00 d2				                .word nt_asm_sta
>d1f9		55 a7 59 a7					.word xt_asm_sei, z_asm_sei
>d1fd		73 65 69					.text "sei"
.d200						nt_asm_sta:
>d200		03 0c						.byte 3, IM+NN
>d202		0b d2				                .word nt_asm_sta_x
>d204		59 a7 5d a7					.word xt_asm_sta, z_asm_sta
>d208		73 74 61					.text "sta"
.d20b						nt_asm_sta_x:
>d20b		05 0c						.byte 5, IM+NN
>d20d		18 d2				                .word nt_asm_sta_y
>d20f		5d a7 61 a7					.word xt_asm_sta_x, z_asm_sta_x
>d213		73 74 61 2e 78					.text "sta.x"
.d218						nt_asm_sta_y:
>d218		05 0c						.byte 5, IM+NN
>d21a		25 d2				                .word nt_asm_sta_z
>d21c		61 a7 65 a7					.word xt_asm_sta_y, z_asm_sta_y
>d220		73 74 61 2e 79					.text "sta.y"
.d225						nt_asm_sta_z:
>d225		05 0c						.byte 5, IM+NN
>d227		32 d2				                .word nt_asm_sta_zi
>d229		65 a7 69 a7					.word xt_asm_sta_z, z_asm_sta_z
>d22d		73 74 61 2e 7a					.text "sta.z"
.d232						nt_asm_sta_zi:
>d232		06 0c						.byte 6, IM+NN
>d234		40 d2				                .word nt_asm_sta_ziy
>d236		69 a7 6d a7					.word xt_asm_sta_zi, z_asm_sta_zi
>d23a		73 74 61 2e 7a 69				.text "sta.zi"
.d240						nt_asm_sta_ziy:
>d240		07 0c						.byte 7, IM+NN
>d242		4f d2				                .word nt_asm_sta_zx
>d244		6d a7 71 a7					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d248		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d24f						nt_asm_sta_zx:
>d24f		06 0c						.byte 6, IM+NN
>d251		5d d2				                .word nt_asm_sta_zxi
>d253		71 a7 75 a7					.word xt_asm_sta_zx, z_asm_sta_zx
>d257		73 74 61 2e 7a 78				.text "sta.zx"
.d25d						nt_asm_sta_zxi:
>d25d		07 0c						.byte 7, IM+NN
>d25f		6c d2				                .word nt_asm_stx
>d261		75 a7 79 a7					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d265		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d26c						nt_asm_stx:
>d26c		03 0c						.byte 3, IM+NN
>d26e		77 d2				                .word nt_asm_stx_z
>d270		79 a7 7d a7					.word xt_asm_stx, z_asm_stx
>d274		73 74 78					.text "stx"
.d277						nt_asm_stx_z:
>d277		05 0c						.byte 5, IM+NN
>d279		84 d2				                .word nt_asm_stx_zy
>d27b		7d a7 81 a7					.word xt_asm_stx_z, z_asm_stx_z
>d27f		73 74 78 2e 7a					.text "stx.z"
.d284						nt_asm_stx_zy:
>d284		06 0c						.byte 6, IM+NN
>d286		92 d2				                .word nt_asm_sty
>d288		81 a7 85 a7					.word xt_asm_stx_zy, z_asm_stx_zy
>d28c		73 74 78 2e 7a 79				.text "stx.zy"
.d292						nt_asm_sty:
>d292		03 0c						.byte 3, IM+NN
>d294		9d d2				                .word nt_asm_sty_z
>d296		85 a7 89 a7					.word xt_asm_sty, z_asm_sty
>d29a		73 74 79					.text "sty"
.d29d						nt_asm_sty_z:
>d29d		05 0c						.byte 5, IM+NN
>d29f		aa d2				                .word nt_asm_sty_zx
>d2a1		89 a7 8d a7					.word xt_asm_sty_z, z_asm_sty_z
>d2a5		73 74 79 2e 7a					.text "sty.z"
.d2aa						nt_asm_sty_zx:
>d2aa		06 0c						.byte 6, IM+NN
>d2ac		b8 d2				                .word nt_asm_stz
>d2ae		8d a7 91 a7					.word xt_asm_sty_zx, z_asm_sty_zx
>d2b2		73 74 79 2e 7a 78				.text "sty.zx"
.d2b8						nt_asm_stz:
>d2b8		03 0c						.byte 3, IM+NN
>d2ba		c3 d2				                .word nt_asm_stz_x
>d2bc		91 a7 95 a7					.word xt_asm_stz, z_asm_stz
>d2c0		73 74 7a					.text "stz"
.d2c3						nt_asm_stz_x:
>d2c3		05 0c						.byte 5, IM+NN
>d2c5		d0 d2				                .word nt_asm_stz_z
>d2c7		95 a7 99 a7					.word xt_asm_stz_x, z_asm_stz_x
>d2cb		73 74 7a 2e 78					.text "stz.x"
.d2d0						nt_asm_stz_z:
>d2d0		05 0c						.byte 5, IM+NN
>d2d2		dd d2				                .word nt_asm_stz_zx
>d2d4		99 a7 9d a7					.word xt_asm_stz_z, z_asm_stz_z
>d2d8		73 74 7a 2e 7a					.text "stz.z"
.d2dd						nt_asm_stz_zx:
>d2dd		06 0c						.byte 6, IM+NN
>d2df		eb d2				                .word nt_asm_tax
>d2e1		9d a7 a1 a7					.word xt_asm_stz_zx, z_asm_stz_zx
>d2e5		73 74 7a 2e 7a 78				.text "stz.zx"
.d2eb						nt_asm_tax:
>d2eb		03 0c						.byte 3, IM+NN
>d2ed		f6 d2				                .word nt_asm_tay
>d2ef		a1 a7 a5 a7					.word xt_asm_tax, z_asm_tax
>d2f3		74 61 78					.text "tax"
.d2f6						nt_asm_tay:
>d2f6		03 0c						.byte 3, IM+NN
>d2f8		01 d3				                .word nt_asm_trb
>d2fa		a5 a7 a9 a7					.word xt_asm_tay, z_asm_tay
>d2fe		74 61 79					.text "tay"
.d301						nt_asm_trb:
>d301		03 0c						.byte 3, IM+NN
>d303		0c d3				                .word nt_asm_trb_z
>d305		a9 a7 ad a7					.word xt_asm_trb, z_asm_trb
>d309		74 72 62					.text "trb"
.d30c						nt_asm_trb_z:
>d30c		05 0c						.byte 5, IM+NN
>d30e		19 d3				                .word nt_asm_tsb
>d310		ad a7 b1 a7					.word xt_asm_trb_z, z_asm_trb_z
>d314		74 72 62 2e 7a					.text "trb.z"
.d319						nt_asm_tsb:
>d319		03 0c						.byte 3, IM+NN
>d31b		24 d3				                .word nt_asm_tsb_z
>d31d		b1 a7 b5 a7					.word xt_asm_tsb, z_asm_tsb
>d321		74 73 62					.text "tsb"
.d324						nt_asm_tsb_z:
>d324		05 0c						.byte 5, IM+NN
>d326		31 d3				                .word nt_asm_tsx
>d328		b5 a7 b9 a7					.word xt_asm_tsb_z, z_asm_tsb_z
>d32c		74 73 62 2e 7a					.text "tsb.z"
.d331						nt_asm_tsx:
>d331		03 0c						.byte 3, IM+NN
>d333		3c d3				                .word nt_asm_txa
>d335		b9 a7 bd a7					.word xt_asm_tsx, z_asm_tsx
>d339		74 73 78					.text "tsx"
.d33c						nt_asm_txa:
>d33c		03 0c						.byte 3, IM+NN
>d33e		47 d3				                .word nt_asm_txs
>d340		bd a7 c1 a7					.word xt_asm_txa, z_asm_txa
>d344		74 78 61					.text "txa"
.d347						nt_asm_txs:
>d347		03 0c						.byte 3, IM+NN
>d349		52 d3				                .word nt_asm_tya
>d34b		c1 a7 c5 a7					.word xt_asm_txs, z_asm_txs
>d34f		74 78 73					.text "txs"
.d352						nt_asm_tya:
>d352		03 0c						.byte 3, IM+NN
>d354		5d d3				                .word nt_asm_arrow
>d356		c5 a7 c9 a7					.word xt_asm_tya, z_asm_tya
>d35a		74 79 61					.text "tya"
.d35d						nt_asm_arrow:
>d35d		03 04				                .byte 3, IM
>d35f		68 d3				                .word nt_asm_back_jump
>d361		1b 89 25 89			                .word xt_asm_arrow, z_asm_arrow
>d365		2d 2d 3e			                .text "-->"
.d368						nt_asm_back_jump:
>d368		02 04				                .byte 2, IM
>d36a		72 d3				                .word nt_asm_back_branch
>d36c		1a a8 1a a8			                .word xt_asm_back_jump, z_asm_back_jump
>d370		3c 6a				                .text "<j"
.d372						nt_asm_back_branch:
>d372		02 04				                .byte 2, IM
>d374		7c d3				                .word nt_asm_push_a
>d376		1b a8 23 a8			                .word xt_asm_back_branch, z_asm_back_branch
>d37a		3c 62				                .text "<b"
.d37c						nt_asm_push_a:
>d37c		06 0c				                .byte 6, IM+NN
>d37e		00 00				                .word 0000
>d380		03 a8 12 a8			                .word xt_asm_push_a, z_asm_push_a
>d384		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix         ; unused?
=1						ix += 1
=1						str_compile        = ix         ; unused?
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix         ; unused?
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_sdc     = ix
=13						ix += 1
=13						str_disasm_lit     = ix
=14						ix += 1
=14						str_disasm_0bra    = ix
=15						ix += 1
=15						str_disasm_loop    = ix
=16						ix += 1
=16						str_disasm_do      = ix
=17						ix += 1
.d38a						string_table:
>d38a		ac d3 b0 d3 ba d3 c5 d3		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d392		fc d3 f4 d3 e9 d3 03 d4		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d39a		09 d4 25 d4 2a d4 2f d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d3a2		40 d4 53 d4 5c d4 65 d4		        .word s_disasm_sdc, s_disasm_lit, s_disasm_0bra, s_disasm_loop, s_disasm_do ; 12-16
>d3aa		6b d4
>d3ac		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d3b0		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d3b8		64 00
>d3ba		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d3c2		64 20 00
>d3c5		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d3cd		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d3dd		4f 50 51 52 53 54 55 56 57 58 59 5a
>d3e9		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d3f1		72 20 00
>d3f4		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d3fc		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d403		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d409		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d411		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d421		29 3a 20 00
>d425		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d42a		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d42f		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d437		63 69 6d 61 6c 29 3a 20 00
>d440		20 53 54 41 43 4b 20 44		s_disasm_sdc: .text " STACK DEPTH CHECK", 0
>d448		45 50 54 48 20 43 48 45 43 4b 00
>d453		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d45b		00
>d45c		30 42 52 41 4e 43 48 20		s_disasm_0bra: .text "0BRANCH ",0
>d464		00
>d465		4c 4f 4f 50 20 00		s_disasm_loop: .text "LOOP ",0
>d46b		44 4f 20 00			s_disasm_do: .text "DO ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d46f						error_table:
>d46f		8b d4 ac d4 cc d4 ed d4		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d477		0a d5 1b d5 2b d5 59 d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d47f		71 d5 92 d5 a7 d5 c3 d5		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d487		da d5 19 d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d48b		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d493		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d4a3		65 20 6d 65 6d 6f 72 79 00
>d4ac		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d4b4		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d4c4		20 52 45 46 49 4c 4c 00
>d4cc		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d4d4		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d4e4		6e 6c 79 20 77 6f 72 64 00
>d4ed		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d4f5		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d505		20 79 65 74 00
>d50a		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d512		20 62 79 20 7a 65 72 6f 00
>d51b		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d523		66 61 69 6c 75 72 65 00
>d52b		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d533		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d543		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d553		64 20 2d 31 29 00
>d559		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d561		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d571		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d579		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d589		64 20 6e 75 6d 62 65 72 00
>d592		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d59a		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d5a7		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d5af		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d5bf		4c 4f 54 00
>d5c3		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d5cb		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d5da		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d5e2		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d5f2		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d602		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d612		56 45 43 54 4f 52 00
>d619		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d621		74 61 63 6b 3a 00
>d627		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d62f		44 2d 53 54 52 49 4e 47
>d637		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d63d		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d642		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d64a		2d 55 4e 49 54 2d 42 49 54 53
>d654		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d65c		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d664		52
>d665		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d66b		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d671		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d679		53 54 41 43 4b 2d 43 45 4c 4c 53
>d684		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d68c		45 4c 4c 53
>d690		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d698		54 53
>d69a		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d6a0		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d6a7						doconst:
.d6a7		ca		dex		                dex             ; make room for constant
.d6a8		ca		dex		                dex
.d6a9		68		pla		                pla             ; LSB of return address
.d6aa		85 25		sta $25		                sta tmp1
.d6ac		68		pla		                pla             ; MSB of return address
.d6ad		85 26		sta $26		                sta tmp1+1
.d6af		a0 01		ldy #$01	                ldy #1
.d6b1		b1 25		lda ($25),y	                lda (tmp1),y
.d6b3		95 00		sta $00,x	                sta 0,x
.d6b5		c8		iny		                iny
.d6b6		b1 25		lda ($25),y	                lda (tmp1),y
.d6b8		95 01		sta $01,x	                sta 1,x
.d6ba		60		rts		                rts
.d6bb						dodefer:
.d6bb		68		pla		                pla             ; LSB
.d6bc		85 25		sta $25		                sta tmp1
.d6be		68		pla		                pla             ; MSB
.d6bf		85 26		sta $26		                sta tmp1+1
.d6c1		a0 01		ldy #$01	                ldy #1
.d6c3		b1 25		lda ($25),y	                lda (tmp1),y
.d6c5		85 27		sta $27		                sta tmp2
.d6c7		c8		iny		                iny
.d6c8		b1 25		lda ($25),y	                lda (tmp1),y
.d6ca		85 28		sta $28		                sta tmp2+1
.d6cc		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d6cf						defer_error:
.d6cf		a9 03		lda #$03	                lda #err_defer
.d6d1		4c 55 d8	jmp $d855	                jmp error
.d6d4						dodoes:
.d6d4		7a		ply		                ply             ; LSB
.d6d5		68		pla		                pla             ; MSB
.d6d6		c8		iny		                iny
.d6d7		d0 01		bne $d6da	                bne +
.d6d9		1a		inc a		                ina
.d6da						+
.d6da		84 27		sty $27		                sty tmp2
.d6dc		85 28		sta $28		                sta tmp2+1
.d6de		ca		dex		                dex
.d6df		ca		dex		                dex
.d6e0		7a		ply		                ply
.d6e1		68		pla		                pla
.d6e2		c8		iny		                iny
.d6e3		d0 01		bne $d6e6	                bne +
.d6e5		1a		inc a		                ina
.d6e6						+
.d6e6		94 00		sty $00,x	                sty 0,x         ; LSB
.d6e8		95 01		sta $01,x	                sta 1,x         ; MSB
.d6ea		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d6ed						dovar:
.d6ed		7a		ply		                ply             ; LSB
.d6ee		68		pla		                pla             ; MSB
.d6ef		c8		iny		                iny
.d6f0		d0 01		bne $d6f3	                bne +
.d6f2		1a		inc a		                ina
.d6f3						+
.d6f3		ca		dex		                dex
.d6f4		ca		dex		                dex
.d6f5		95 01		sta $01,x	                sta 1,x
.d6f7		98		tya		                tya
.d6f8		95 00		sta $00,x	                sta 0,x
.d6fa		60		rts		                rts
.d6fb						push_upvar_tos:
.d6fb		ca		dex		                dex
.d6fc		ca		dex		                dex
.d6fd		18		clc		                clc
.d6fe		65 08		adc $08		                adc up
.d700		95 00		sta $00,x	                sta 0,x
.d702		a5 09		lda $09		                lda up+1
.d704		90 01		bcc $d707	                bcc +
.d706		1a		inc a		                ina
.d707						+
.d707		95 01		sta $01,x	                sta 1,x
.d709		60		rts		                rts
.d70a						byte_to_ascii:
.d70a		48		pha		                pha
.d70b		4a		lsr a		                lsr             ; convert high nibble first
.d70c		4a		lsr a		                lsr
.d70d		4a		lsr a		                lsr
.d70e		4a		lsr a		                lsr
.d70f		20 13 d7	jsr $d713	                jsr _nibble_to_ascii
.d712		68		pla		                pla
.d713						_nibble_to_ascii:
.d713		29 0f		and #$0f	                and #$F
.d715		09 30		ora #$30	                ora #'0'
.d717		c9 3a		cmp #$3a	                cmp #'9'+1
.d719		90 02		bcc $d71d	                bcc +
.d71b		69 06		adc #$06	                adc #6
.d71d		4c c5 86	jmp $86c5	+               jmp emit_a
.d720		60		rts		                rts
.d721						find_header_name:
.d721		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d723		85 27		sta $27		                sta tmp2
.d725		b5 03		lda $03,x	                lda 3,x
.d727		85 28		sta $28		                sta tmp2+1
.d729						_loop:
.d729		b2 25		lda ($25)	                lda (tmp1)
.d72b		d5 00		cmp $00,x	                cmp 0,x
.d72d		d0 3a		bne $d769	                bne _next_entry
.d72f		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d731		a0 08		ldy #$08	                ldy #8
.d733		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d735		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d737		d0 30		bne $d769	                bne _next_entry ; definitely not equal if any bits differ
.d739		a5 25		lda $25		                lda tmp1
.d73b		48		pha		                pha             ; Save original address on the stack
.d73c		18		clc		                clc
.d73d		69 08		adc #$08	                adc #8
.d73f		85 25		sta $25		                sta tmp1
.d741		a5 26		lda $26		                lda tmp1+1
.d743		48		pha		                pha
.d744		90 03		bcc $d749	                bcc +
.d746		1a		inc a		                ina
.d747		85 26		sta $26		                sta tmp1+1
.d749						+
.d749		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d74b		88		dey		                dey
.d74c						_next_char:
.d74c		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d74e		c9 5b		cmp #$5b	                cmp #'Z'+1
.d750		b0 06		bcs $d758	                bcs _check_char
.d752		c9 41		cmp #$41	                cmp #'A'
.d754		90 02		bcc $d758	                bcc _check_char
.d756		09 20		ora #$20	                ora #$20
.d758						_check_char:
.d758		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d75a		d0 03		bne $d75f	                bne _reset_tmp1
.d75c		88		dey		                dey
.d75d		10 ed		bpl $d74c	                bpl _next_char
.d75f						_reset_tmp1:
.d75f		68		pla		                pla
.d760		85 26		sta $26		                sta tmp1+1
.d762		68		pla		                pla
.d763		85 25		sta $25		                sta tmp1
.d765		98		tya		                tya             ; leave A = $FF on success
.d766		c8		iny		                iny             ; if Y was $FF, we succeeded
.d767		f0 11		beq $d77a	                beq _done
.d769						_next_entry:
.d769		a0 02		ldy #$02	                ldy #2
.d76b		b1 25		lda ($25),y	                lda (tmp1),y
.d76d		48		pha		                pha
.d76e		c8		iny		                iny
.d76f		b1 25		lda ($25),y	                lda (tmp1),y
.d771		85 26		sta $26		                sta tmp1+1
.d773		68		pla		                pla
.d774		85 25		sta $25		                sta tmp1
.d776		05 26		ora $26		                ora tmp1+1
.d778		d0 af		bne $d729	                bne _loop
.d77a		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d77c		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d77d						compare_16bit:
.d77d		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d77f		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d781		f0 08		beq $d78b	                beq _equal
.d783		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d785		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d787		70 08		bvs $d791	                bvs _overflow
.d789		80 08		bra $d793	                bra _not_equal
.d78b						_equal:
.d78b		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d78d		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d78f		50 04		bvc $d795	                bvc _done
.d791						_overflow:
.d791		49 80		eor #$80	                eor #$80                ; complement negative flag
.d793						_not_equal:
.d793		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d795						_done:
.d795		60		rts		                rts
.d796						current_to_dp:
.d796		a0 08		ldy #$08	                ldy #current_offset
.d798		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d79a		0a		asl a		                asl             ; turn it into an offset (in cells)
.d79b		18		clc		                clc
.d79c		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d79e		a8		tay		                tay
.d79f		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d7a1		85 02		sta $02		                sta dp
.d7a3		c8		iny		                iny
.d7a4		b1 08		lda ($08),y	                lda (up),y
.d7a6		85 03		sta $03		                sta dp+1
.d7a8		60		rts		                rts
.d7a9						dp_to_current:
.d7a9		a0 08		ldy #$08	                ldy #current_offset
.d7ab		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d7ad		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7ae		18		clc		                clc
.d7af		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d7b1		a8		tay		                tay
.d7b2		a5 02		lda $02		                lda dp
.d7b4		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d7b6		c8		iny		                iny
.d7b7		a5 03		lda $03		                lda dp+1
.d7b9		91 08		sta ($08),y	                sta (up),y
.d7bb		60		rts		                rts
.d7bc						interpret:
.d7bc						_loop:
.d7bc		20 5d 8d	jsr $8d5d	                jsr xt_parse_name       ; ( "string" -- addr u )
.d7bf		b5 00		lda $00,x	                lda 0,x
.d7c1		15 01		ora $01,x	                ora 1,x
.d7c3		f0 5b		beq $d820	                beq _line_done
.d7c5		20 bb 93	jsr $93bb	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d7c8		20 ea 9a	jsr $9aea	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d7cb		b5 00		lda $00,x	                lda 0,x
.d7cd		15 01		ora $01,x	                ora 1,x
.d7cf		d0 19		bne $d7ea	                bne _got_name_token
.d7d1		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d7d2		e8		inx		                inx
.d7d3		20 96 9c	jsr $9c96	                jsr xt_number           ; ( addr u -- u|d )
.d7d6		a5 1a		lda $1a		                lda state
.d7d8		f0 e2		beq $d7bc	                beq _loop
.d7da		a9 20		lda #$20	                lda #%00100000
.d7dc		24 1c		bit $1c		                bit status
.d7de		d0 05		bne $d7e5	                bne _double_number
.d7e0		20 04 8a	jsr $8a04	                jsr xt_literal
.d7e3		80 d7		bra $d7bc	                bra _loop
.d7e5						_double_number:
.d7e5		20 55 9f	jsr $9f55	                jsr xt_two_literal
.d7e8		80 d2		bra $d7bc	                bra _loop
.d7ea						_got_name_token:
.d7ea		b5 00		lda $00,x	                lda 0,x
.d7ec		95 04		sta $04,x	                sta 4,x
.d7ee		b5 01		lda $01,x	                lda 1,x
.d7f0		95 05		sta $05,x	                sta 5,x
.d7f2		e8		inx		                inx
.d7f3		e8		inx		                inx
.d7f4		e8		inx		                inx
.d7f5		e8		inx		                inx                     ; ( nt )
.d7f6		20 f5 8c	jsr $8cf5	                jsr xt_one_plus
.d7f9		a1 00		lda ($00,x)	                lda (0,x)
.d7fb		48		pha		                pha
.d7fc		20 e9 8c	jsr $8ce9	                jsr xt_one_minus
.d7ff		20 33 9c	jsr $9c33	                jsr xt_name_to_int      ; ( nt - xt )
.d802		a5 1a		lda $1a		                lda state
.d804		d0 10		bne $d816	                bne _compile
.d806		68		pla		                pla
.d807		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d809		f0 05		beq $d810	                beq _interpret
.d80b		a9 02		lda #$02	                lda #err_compileonly
.d80d		4c 55 d8	jmp $d855	                jmp error
.d810						_interpret:
.d810		20 05 88	jsr $8805	                jsr xt_execute
.d813		4c bc d7	jmp $d7bc	                jmp _loop
.d816						_compile:
.d816		68		pla		                pla
.d817		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d819		d0 f5		bne $d810	                bne _interpret          ; IMMEDIATE word, execute right now
.d81b		20 d3 96	jsr $96d3	                jsr xt_compile_comma
.d81e		80 9c		bra $d7bc	                bra _loop
.d820						_line_done:
.d820		e8		inx		                inx
.d821		e8		inx		                inx
.d822		e8		inx		                inx
.d823		e8		inx		                inx
.d824		60		rts		                rts
.d825						is_printable:
.d825		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d827		90 08		bcc $d831	                bcc _done
.d829		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d82b		b0 03		bcs $d830	                bcs _failed
.d82d		38		sec		                sec
.d82e		80 01		bra $d831	                bra _done
.d830						_failed:
.d830		18		clc		                clc
.d831						_done:
.d831		60		rts		                rts
.d832						is_whitespace:
.d832		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d834		90 08		bcc $d83e	                bcc _done
.d836		c9 21		cmp #$21	                cmp #AscSP+1
.d838		b0 03		bcs $d83d	                bcs _failed
.d83a		38		sec		                sec
.d83b		80 01		bra $d83e	                bra _done
.d83d						_failed:
.d83d		18		clc		                clc
.d83e						_done:
.d83e		60		rts		                rts
.d83f						underflow_1:
.d83f		e0 77		cpx #$77	                cpx #dsp0-1
.d841		10 10		bpl $d853	                bpl underflow_error
.d843		60		rts		                rts
.d844						underflow_2:
.d844		e0 75		cpx #$75	                cpx #dsp0-3
.d846		10 0b		bpl $d853	                bpl underflow_error
.d848		60		rts		                rts
.d849						underflow_3:
.d849		e0 73		cpx #$73	                cpx #dsp0-5
.d84b		10 06		bpl $d853	                bpl underflow_error
.d84d		60		rts		                rts
.d84e						underflow_4:
.d84e		e0 71		cpx #$71	                cpx #dsp0-7
.d850		10 01		bpl $d853	                bpl underflow_error
.d852		60		rts		                rts
.d853						underflow_error:
.d853		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d855						error:
.d855		48		pha		                pha                     ; save error
.d856		20 95 d8	jsr $d895	                jsr print_error
.d859		20 3a 84	jsr $843a	                jsr xt_cr
.d85c		68		pla		                pla
.d85d		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d85f		d0 17		bne $d878	                bne _no_underflow
.d861		a9 0d		lda #$0d	                lda #err_returnstack
.d863		20 95 d8	jsr $d895	                jsr print_error
.d866		ba		tsx		                tsx
.d867						-
.d867		e8		inx		                inx
.d868		f0 0b		beq $d875	                beq +
.d86a		20 d7 91	jsr $91d7	                jsr xt_space
.d86d		bd 00 01	lda $0100,x	                lda $100,x
.d870		20 0a d7	jsr $d70a	                jsr byte_to_ascii
.d873		80 f2		bra $d867	                bra -
.d875						+
.d875		20 3a 84	jsr $843a	                jsr xt_cr
.d878						_no_underflow:
.d878		4c 5e 80	jmp $805e	                jmp xt_abort            ; no jsr, as we clobber return stack
.d87b						print_string_no_lf:
.d87b		0a		asl a		                asl
.d87c		a8		tay		                tay
.d87d		b9 8a d3	lda $d38a,y	                lda string_table,y
.d880		85 29		sta $29		                sta tmp3                ; LSB
.d882		c8		iny		                iny
.d883		b9 8a d3	lda $d38a,y	                lda string_table,y
.d886		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d888						print_common:
.d888		a0 00		ldy #$00	                ldy #0
.d88a						_loop:
.d88a		b1 29		lda ($29),y	                lda (tmp3),y
.d88c		f0 06		beq $d894	                beq _done               ; strings are zero-terminated
.d88e		20 c5 86	jsr $86c5	                jsr emit_a              ; allows vectoring via output
.d891		c8		iny		                iny
.d892		80 f6		bra $d88a	                bra _loop
.d894						_done:
.d894		60		rts		                rts
.d895						print_error:
.d895		0a		asl a		                asl
.d896		a8		tay		                tay
.d897		b9 6f d4	lda $d46f,y	                lda error_table,y
.d89a		85 29		sta $29		                sta tmp3                ; LSB
.d89c		c8		iny		                iny
.d89d		b9 6f d4	lda $d46f,y	                lda error_table,y
.d8a0		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d8a2		20 88 d8	jsr $d888	                jsr print_common
.d8a5		60		rts		                rts
.d8a6						print_string:
.d8a6		20 7b d8	jsr $d87b	                jsr print_string_no_lf
.d8a9		4c 3a 84	jmp $843a	                jmp xt_cr               ; JSR/RTS because never compiled
.d8ac						print_u:
.d8ac		20 f6 9d	jsr $9df6	                jsr xt_zero                     ; 0
.d8af		20 e1 89	jsr $89e1	                jsr xt_less_number_sign         ; <#
.d8b2		20 bf 8c	jsr $8cbf	                jsr xt_number_sign_s            ; #S
.d8b5		20 9d 8c	jsr $8c9d	                jsr xt_number_sign_greater      ; #>
.d8b8		4c d0 94	jmp $94d0	                jmp xt_type                     ; JSR/RTS because never compiled
.d8bb						code_end:

;******  Return to file: platform/simulator.asm

=$f000						io_start = $f000                ; virtual hardware addresses for the simulators
>f000						                .byte ?
>f001						io_putc:        .byte ?         ; $f001     write byte to stdout
>f002						                .byte ?
>f003						io_kbhit:       .byte ?         ; $f003     read non-zero on key ready (c65 only)
>f004						io_getc:        .byte ?         ; $f004     non-blocking read input character (0 if no key)
>f005						io_clk_start:   .byte ?         ; $f006     *read* to start cycle counter
>f006						io_clk_stop:    .byte ?         ; $f007     *read* to stop the cycle counter
>f007						io_clk_cycles:  .word ?,?       ; $f008-b   32-bit cycle count in NUXI order
>f00b						                .word ?,?
>f00f						io_blk_action:  .byte ?     ; $f010     Write to act (status=0 read=1 write=2)
>f010						io_blk_status:  .byte ?     ; $f011     Read action result (OK=0)
>f011						io_blk_number:  .word ?     ; $f012     Little endian block number 0-ffff
>f013						io_blk_buffer:  .word ?     ; $f014     Little endian memory address
.f015						io_end:
.f015						kernel_init:
.f015		78		sei		                sei             ; Disable interrupts
.f016		a2 00		ldx #$00	                ldx #0
.f018		bd 45 f0	lda $f045,x	-               lda s_kernel_id,x
.f01b		f0 06		beq $f023	                beq _done
.f01d		20 27 f0	jsr $f027	                jsr kernel_putc
.f020		e8		inx		                inx
.f021		80 f5		bra $f018	                bra -
.f023						_done:
.f023		4c 00 80	jmp $8000	                jmp forth
.f026						kernel_bye:
.f026		00		brk #		                brk
.f027						kernel_putc:
.f027		8d 01 f0	sta $f001	                sta io_putc
.f02a		60		rts		                rts

;******  Return to file: platform/platform-py65mon.asm

=$f003						io_bufc = io_kbhit
.f02b						kernel_getc:
.f02b		ad 03 f0	lda $f003	                lda io_bufc             ; first check the buffer
.f02e		9c 03 f0	stz $f003	                stz io_bufc
.f031		d0 05		bne $f038	                bne _done
.f033						_loop:
.f033		ad 04 f0	lda $f004	                lda io_getc
.f036		f0 fb		beq $f033	                beq _loop
.f038						_done:
.f038		60		rts		                rts
.f039						kernel_kbhit:
.f039		ad 03 f0	lda $f003	                lda io_bufc             ; do we already have a character?
.f03c		d0 06		bne $f044	                bne _done
.f03e		ad 04 f0	lda $f004	                lda io_getc             ; otherwise check and buffer the result
.f041		8d 03 f0	sta $f003	                sta io_bufc
.f044						_done:
.f044		60		rts		                rts
.f045						s_kernel_id:
>f045		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f04d		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f05d		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f06d		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		15 f0				v_nmi   .word kernel_init
>fffc		15 f0				v_reset .word kernel_init
>fffe		15 f0				v_irq   .word kernel_init

;******  End of listing
