
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Fri Jan  8 22:31:24 2021

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000					ram_start = $0000          ; start of installed 32 KiB of RAM
=32767					ram_end   = $8000-1        ; end of installed RAM
=$0000					zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f					zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100					stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744					hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000					user0     = zpage            ; user and system variables
=$ff					rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff					bsize     = $ff              ; size of input/output buffers
=512					buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768					cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744					cp_end    = hist_buff        ; Last RAM byte available for code
=$ff					padoffset = $ff              ; offset from CP to PAD (holds number strings)
=["ed","editor","ramdrive","block","environment?","assembler","wordlist"]
					                         "environment?", "assembler", "wordlist" ]

;******  Processing file: platform/../taliforth.asm

.8000					code0:

;******  Processing file: platform/../definitions.asm

=0					cp        = user0+0   ; Compiler Pointer
=2					dp        = user0+2   ; Dictionary Pointer
=4					workword  = user0+4   ; nt (not xt!) of word being compiled, except in
=6					insrc     = user0+6   ; input Source for SOURCE-ID
=8					cib       = user0+8   ; address of current input buffer
=10					ciblen    = user0+10  ; length of current input buffer
=12					toin      = user0+12  ; pointer to CIB (>IN in Forth)
=14					ip        = user0+14  ; Instruction Pointer (current xt)
=16					output    = user0+16  ; vector for EMIT
=18					input     = user0+18  ; vector for KEY
=20					havekey   = user0+20  ; vector for KEY?
=22					state     = user0+22  ; STATE: -1 compile, 0 interpret
=24					base      = user0+24  ; number radix, default decimal
=26					nc_limit  = user0+26  ; limit for Native Compile size
=28					uf_strip  = user0+28  ; flag to strip underflow detection code
=30					up        = user0+30  ; User Pointer (Address of user variables)
=32					status    = user0+32  ; internal status information
=34					tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
=36					tmp1      = user0+36  ; temporary storage
=38					tmp2      = user0+38  ; temporary storage
=40					tmp3      = user0+40  ; temporary storage (especially for print)
=42					tmpdsp    = user0+42  ; temporary DSP (X) storage (two bytes)
=44					tmptos    = user0+44  ; temporary TOS storage
=46					editor1   = user0+46  ; temporary for editors
=48					editor2   = user0+48  ; temporary for editors
=50					editor3   = user0+50  ; temporary for editors
=52					tohold    = user0+52  ; pointer for formatted output
=54					scratch   = user0+54  ; 8 byte scratchpad (see UM/MOD)
=120					dsp0      = zpage_end-7    ; initial Data Stack Pointer
=0					blk_offset = 0        ; BLK : UP + 0
=2					scr_offset = 2        ; SCR : UP + 2
=4					current_offset = 4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
=5					num_wordlists_offset = 5
=6					wordlists_offset = 6  ; WORDLISTS (cells) : UP + 6 to UP + 29
=30					num_order_offset = 30 ; #ORDER (byte) : UP + 30
=31					search_order_offset = 31
=12					max_wordlists = 12    ; Maximum number of wordlists supported
=40					blkbuffer_offset    = 40   ; Address of buffer
=42					buffblocknum_offset = 42   ; Block number current in buffer
=44					buffstatus_offset   = 44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
=46					blockread_offset    = 46   ; Vector to block reading routine
=48					blockwrite_offset   = 48   ; Vector to block writing routine
=$03					AscCC   = $03  ; break (CTRL-c)
=$07					AscBELL = $07  ; bell sound
=$08					AscBS   = $08  ; backspace
=$0a					AscLF   = $0a  ; line feed
=$0d					AscCR   = $0d  ; carriage return
=$1b					AscESC  = $1b  ; escape
=$20					AscSP   = $20  ; space
=$7f					AscDEL  = $7f  ; delete (CTRL-h)
=$10					AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e					AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1					CO = 1  ; Compile Only
=2					AN = 2  ; Always Native Compile
=4					IM = 4  ; Immediate Word
=8					NN = 8  ; Never Native Compile
=16					UF = 16 ; Includes Underflow Check (RESERVED)
=32					HC = 32 ; Word has Code Field Area (CFA)
=79					MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm

.8000					forth:

;******  Processing file: platform/../native_words.asm

.8000					xt_cold:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 10		sta $10		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 11		sta $11		                sta output+1
.8009	a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b					_load_zp_loop:
.800b	bd c5 80	lda $80c5,x	                lda cold_zp_table,x
.800e	95 00		sta $00,x	                sta zpage,x
.8010	ca		dex		                dex
.8011	d0 f8		bne $800b	                bne _load_zp_loop
.8013	ad c5 80	lda $80c5	                lda cold_zp_table
.8016	85 00		sta $00		                sta zpage
.8018	a2 ff		ldx #$ff	                ldx #rsp0
.801a	9a		txs		                txs
.801b	a2 78		ldx #$78	                ldx #dsp0
.801d	a0 31		ldy #$31	                ldy #cold_user_table_end-cold_user_table-1
.801f	a9 00		lda #$00	                lda #0
.8021					_load_user_vars_loop:
.8021	b9 e7 80	lda $80e7,y	                lda cold_user_table,y
.8024	91 1e		sta ($1e),y	                sta (up),y
.8026	88		dey		                dey
.8027	d0 f8		bne $8021	                bne _load_user_vars_loop
.8029	ad e7 80	lda $80e7	                lda cold_user_table
.802c	92 1e		sta ($1e)	                sta (up)
.802e	20 53 89	jsr $8953	                jsr xt_cr
.8031	ca		dex		                dex
.8032	ca		dex		                dex
.8033	ca		dex		                dex
.8034	ca		dex		                dex
.8035	a9 c2		lda #$c2	                lda #<forth_words_start
.8037	95 02		sta $02,x	                sta 2,x
.8039	a9 b9		lda #$b9	                lda #>forth_words_start
.803b	95 03		sta $03,x	                sta 3,x
.803d	a9 86		lda #$86	                lda #<forth_words_end
.803f	38		sec		                sec
.8040	e9 c2		sbc #$c2	                sbc #<forth_words_start
.8042	95 00		sta $00,x	                sta 0,x
.8044	a9 ba		lda #$ba	                lda #>forth_words_end
.8046	e9 b9		sbc #$b9	                sbc #>forth_words_start
.8048	95 01		sta $01,x	                sta 1,x
.804a	20 c5 90	jsr $90c5	                jsr xt_evaluate
.804d	ca		dex		                dex
.804e	ca		dex		                dex
.804f	ca		dex		                dex
.8050	ca		dex		                dex
.8051	a9 86		lda #$86	                lda #<user_words_start
.8053	95 02		sta $02,x	                sta 2,x
.8055	a9 ba		lda #$ba	                lda #>user_words_start
.8057	95 03		sta $03,x	                sta 3,x
.8059	a9 88		lda #$88	                lda #<user_words_end
.805b	38		sec		                sec
.805c	e9 86		sbc #$86	                sbc #<user_words_start
.805e	95 00		sta $00,x	                sta 0,x
.8060	a9 ba		lda #$ba	                lda #>user_words_end
.8062	e9 ba		sbc #$ba	                sbc #>user_words_start
.8064	95 01		sta $01,x	                sta 1,x
.8066	20 c5 90	jsr $90c5	                jsr xt_evaluate
.8069	9c 00 7c	stz $7c00	                stz hist_buff
.806c	9c 80 7c	stz $7c80	                stz hist_buff+$80
.806f	9c 00 7d	stz $7d00	                stz hist_buff+$100
.8072	9c 80 7d	stz $7d80	                stz hist_buff+$180
.8075	9c 00 7e	stz $7e00	                stz hist_buff+$200
.8078	9c 80 7e	stz $7e80	                stz hist_buff+$280
.807b	9c 00 7f	stz $7f00	                stz hist_buff+$300
.807e	9c 80 7f	stz $7f80	                stz hist_buff+$380
.8081					xt_abort:
.8081	a2 78		ldx #$78	                ldx #dsp0
.8083					xt_quit:
.8083	8a		txa		                txa             ; Save the DSP that we just defined
.8084	a2 ff		ldx #$ff	                ldx #rsp0
.8086	9a		txs		                txs
.8087	aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8088	64 0e		stz $0e		                stz ip
.808a	64 0f		stz $0f		                stz ip+1
.808c	64 06		stz $06		                stz insrc
.808e	64 07		stz $07		                stz insrc+1
.8090	64 16		stz $16		                stz state
.8092	64 17		stz $17		                stz state+1
.8094					_get_line:
.8094	a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8096	85 08		sta $08		                sta cib
.8098	a9 02		lda #$02	                lda #>buffer0
.809a	85 09		sta $09		                sta cib+1
.809c	64 0a		stz $0a		                stz ciblen
.809e	64 0b		stz $0b		                stz ciblen+1
.80a0	20 d9 9a	jsr $9ad9	                jsr xt_refill           ; ( -- f )
.80a3	b5 00		lda $00,x	                lda 0,x
.80a5	d0 05		bne $80ac	                bne _success
.80a7	a9 06		lda #$06	                lda #err_refill
.80a9	4c 60 d6	jmp $d660	                jmp error
.80ac					_success:
.80ac	e8		inx		                inx                     ; drop
.80ad	e8		inx		                inx
.80ae	20 b2 d5	jsr $d5b2	                jsr interpret
.80b1	e0 78		cpx #$78	                cpx #dsp0
.80b3	f0 05		beq $80ba	                beq _stack_ok
.80b5	90 03		bcc $80ba	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80b7	4c 5e d6	jmp $d65e	                jmp underflow_error
.80ba					_stack_ok:
.80ba	a5 16		lda $16		                lda state
.80bc	f0 02		beq $80c0	                beq _print
.80be	a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80c0					_print:
.80c0	20 90 d6	jsr $d690	                jsr print_string
.80c3	80 cf		bra $8094	                bra _get_line
.80c5					z_cold:
.80c5					z_abort:
.80c5					z_quit:
.80c5					cold_zp_table:
>80c5	00 08				        .word cp0+256+1024      ; cp moved to make room for user vars and
>80c7	88 ba				        .word dictionary_start  ; dp
>80c9	00 00				        .word 0                 ; workword
>80cb	00 00				        .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
>80cd	00 02				        .word buffer0           ; cib
>80cf	00 00				        .word 0                 ; ciblen
>80d1	00 00				        .word 0                 ; toin
>80d3	00 00				        .word 0                 ; ip
>80d5	27 f0				        .word kernel_putc       ; output
>80d7	21 f0				        .word kernel_getc       ; input
>80d9	00 00				        .word 0                 ; havekey
>80db	00 00				        .word 0                 ; state (0 = interpret)
>80dd	0a 00				        .word 10                ; base
>80df	14 00				        .word 20                ; nc-limit
>80e1	00 00				        .word 0                 ; uf_strip (off by default)
>80e3	00 03				        .word cp0               ; up (user vars put right at beginning of
>80e5	00 00				        .word 0                 ; status
.80e7					cold_zp_table_end:
.80e7					cold_user_table:
>80e7	00 00				        .word 0                         ; BLK
>80e9	00 00				        .word 0                         ; SCR
>80eb	00				        .byte 0                         ; CURRENT = FORTH-WORDLIST
>80ec	04				        .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>80ed	88 ba				        .word dictionary_start          ; FORTH-WORDLIST
>80ef	d0 c8				        .word editor_dictionary_start   ; EDITOR-WORDLIST
>80f1	20 c9				        .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
>80f3	8f c8				        .word root_dictionary_start     ; ROOT-WORDLIST
>80f5	00 00 00 00 00 00 00 00		        .word 0,0,0,0,0,0,0,0           ; User wordlists
>80fd	00 00 00 00 00 00 00 00
>8105	01				        .byte 1                         ; #ORDER
>8106	00 00 00 00 00 00 00 00		        .byte 0,0,0,0,0,0,0,0,0         ; search-order
>810e	00
>810f	00 04				        .word cp0+256                   ; Address of buffer (right after USER vars)
>8111	00 00				        .word 0                         ; block in buffer
>8113	00 00				        .word 0                         ; buffer status (not in use)
>8115	4b 85				        .word xt_block_word_error       ; block-read vector
>8117	4b 85				        .word xt_block_word_error       ; block-write vector
.8119					cold_user_table_end:
.8119					xt_abort_quote:
.8119	20 30 9d	jsr $9d30	                jsr xt_s_quote          ; S"
.811c	a0 81		ldy #$81	                ldy #>abort_quote_runtime
.811e	a9 24		lda #$24	                lda #<abort_quote_runtime
.8120	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.8123	60		rts		z_abort_quote:  rts
.8124					abort_quote_runtime:
.8124	b5 04		lda $04,x	                lda 4,x
.8126	15 05		ora $05,x	                ora 5,x
.8128	f0 09		beq $8133	                beq _done       ; if FALSE, we're done
.812a	20 de a4	jsr $a4de	                jsr xt_type
.812d	20 53 89	jsr $8953	                jsr xt_cr
.8130	4c 81 80	jmp $8081	                jmp xt_abort    ; not JSR, so never come back
.8133					_done:
.8133	8a		txa		                txa
.8134	18		clc		                clc
.8135	69 06		adc #$06	                adc #6
.8137	aa		tax		                tax
.8138	60		rts		                rts
.8139					xt_abs:
.8139	20 4a d6	jsr $d64a	                jsr underflow_1
.813c	b5 01		lda $01,x	                lda 1,x
.813e	10 0d		bpl $814d	                bpl _done       ; positive number, easy money!
.8140	38		sec		                sec
.8141	a9 00		lda #$00	                lda #0
.8143	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8145	95 00		sta $00,x	                sta 0,x
.8147	a9 00		lda #$00	                lda #0          ; MSB
.8149	f5 01		sbc $01,x	                sbc 1,x
.814b	95 01		sta $01,x	                sta 1,x
.814d					_done:
.814d	60		rts		z_abs:          rts
.814e					xt_accept:
.814e	20 4f d6	jsr $d64f	                jsr underflow_2
.8151	b5 00		lda $00,x	                lda 0,x
.8153	15 01		ora $01,x	                ora 1,x
.8155	d0 09		bne $8160	                bne _not_zero
.8157	e8		inx		                inx
.8158	e8		inx		                inx
.8159	74 00		stz $00,x	                stz 0,x
.815b	74 01		stz $01,x	                stz 1,x
.815d	4c 2c 82	jmp $822c	                jmp accept_done
.8160					_not_zero:
.8160	b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.8162	85 26		sta $26		                sta tmp2
.8164	64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.8166	b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8168	85 24		sta $24		                sta tmp1
.816a	b5 03		lda $03,x	                lda 3,x
.816c	85 25		sta $25		                sta tmp1+1
.816e	e8		inx		                inx
.816f	e8		inx		                inx
.8170	a0 00		ldy #$00	                ldy #0
.8172	a5 20		lda $20		                lda status
.8174	29 f7		and #$f7	                and #$f7
.8176	1a		inc a		               ina
.8177	09 08		ora #$08	                ora #$08
.8179	85 20		sta $20		                sta status
.817b					accept_loop:
.817b	20 28 93	jsr $9328	                jsr key_a
.817e	c9 0a		cmp #$0a	                cmp #AscLF
.8180	f0 20		beq $81a2	                beq _eol
.8182	c9 0d		cmp #$0d	                cmp #AscCR
.8184	f0 1c		beq $81a2	                beq _eol
.8186	c9 08		cmp #$08	                cmp #AscBS
.8188	f0 22		beq $81ac	                beq _backspace
.818a	c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.818c	f0 1e		beq $81ac	                beq _backspace
.818e	c9 10		cmp #$10	                cmp #AscCP
.8190	f0 36		beq $81c8	                beq _ctrl_p
.8192	c9 0e		cmp #$0e	                cmp #AscCN
.8194	f0 44		beq $81da	                beq _ctrl_n
.8196	91 24		sta ($24),y	                sta (tmp1),y
.8198	c8		iny		                iny
.8199	20 e6 8d	jsr $8de6	                jsr emit_a
.819c	c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.819e	d0 db		bne $817b	                bne accept_loop       ; fall through if buffer limit reached
.81a0	80 03		bra $81a5	                bra _buffer_full
.81a2					_eol:
.81a2	20 ff a0	jsr $a0ff	                jsr xt_space    ; print final space
.81a5					_buffer_full:
.81a5	94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.81a7	74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.81a9	4c 2c 82	jmp $822c	                jmp accept_done
.81ac					_backspace:
.81ac	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.81ae	d0 06		bne $81b6	                bne +
.81b0	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.81b2	20 e6 8d	jsr $8de6	                jsr emit_a
.81b5	c8		iny		                iny
.81b6					+
.81b6	88		dey		                dey
.81b7	a9 08		lda #$08	                lda #AscBS      ; move back one
.81b9	20 e6 8d	jsr $8de6	                jsr emit_a
.81bc	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.81be	20 e6 8d	jsr $8de6	                jsr emit_a
.81c1	a9 08		lda #$08	                lda #AscBS      ; move back over space
.81c3	20 e6 8d	jsr $8de6	                jsr emit_a
.81c6	80 b3		bra $817b	                bra accept_loop
.81c8					_ctrl_p:
.81c8	a5 20		lda $20		                lda status
.81ca	29 07		and #$07	                and #7
.81cc	d0 08		bne $81d6	                bne _ctrl_p_dec
.81ce	a5 20		lda $20		                lda status
.81d0	09 07		ora #$07	                ora #7
.81d2	85 20		sta $20		                sta status
.81d4	80 11		bra $81e7	                bra _recall_history
.81d6					_ctrl_p_dec:
.81d6	c6 20		dec $20		                dec status
.81d8	80 0d		bra $81e7	                bra _recall_history
.81da					_ctrl_n:
.81da	a9 08		lda #$08	                lda #$8
.81dc	24 20		bit $20		                bit status
.81de	d0 07		bne $81e7	                bne _recall_history
.81e0	a5 20		lda $20		                lda status
.81e2	29 f7		and #$f7	                and #$f7
.81e4	1a		inc a		               ina
.81e5	85 20		sta $20		                sta status
.81e7					_recall_history:
.81e7	a9 08		lda #$08	                lda #%00001000
.81e9	14 20		trb $20		                trb status
.81eb	20 47 82	jsr $8247	                jsr accept_total_recall
.81ee	a9 0d		lda #$0d	                lda #AscCR
.81f0	20 e6 8d	jsr $8de6	                jsr emit_a
.81f3					input_clear:
.81f3	c0 00		cpy #$00	                cpy #0
.81f5	f0 08		beq $81ff	                beq input_cleared
.81f7	a9 20		lda #$20	                lda #AscSP
.81f9	20 e6 8d	jsr $8de6	                jsr emit_a
.81fc	88		dey		                dey
.81fd	80 f4		bra $81f3	                bra input_clear
.81ff					input_cleared:
.81ff	a9 0d		lda #$0d	                lda #AscCR
.8201	20 e6 8d	jsr $8de6	                jsr emit_a
.8204	b1 28		lda ($28),y	                lda (tmp3),y
.8206	85 21		sta $21		                sta status+1
.8208	e6 28		inc $28		                inc tmp3
.820a	d0 02		bne $820e	                bne +           ; Increment the upper byte on carry.
.820c	e6 29		inc $29		                inc tmp3+1
.820e					+
.820e	a9 0d		lda #$0d	                lda #AscCR
.8210	20 e6 8d	jsr $8de6	                jsr emit_a
.8213					_history_loop:
.8213	c4 21		cpy $21		                cpy status+1
.8215	d0 03		bne $821a	                bne +
.8217	4c 7b 81	jmp $817b	                jmp accept_loop       ; Needs a long jump
.821a					+
.821a	c4 26		cpy $26		                cpy tmp2
.821c	f0 0a		beq $8228	                beq _hist_filled_buffer
.821e	b1 28		lda ($28),y	                lda (tmp3),y
.8220	91 24		sta ($24),y	                sta (tmp1),y
.8222	20 e6 8d	jsr $8de6	                jsr emit_a
.8225	c8		iny		                iny
.8226	80 eb		bra $8213	                bra _history_loop
.8228					_hist_filled_buffer:
.8228	88		dey		                dey
.8229	4c 7b 81	jmp $817b	                jmp accept_loop
.822c					accept_done:
.822c	20 47 82	jsr $8247	                jsr accept_total_recall
.822f	85 21		sta $21		                sta status+1
.8231	a0 00		ldy #$00	                ldy #0
.8233	91 28		sta ($28),y	                sta (tmp3),y
.8235	e6 28		inc $28		                inc tmp3
.8237	d0 02		bne $823b	                bne +           ; Increment the upper byte on carry.
.8239	e6 29		inc $29		                inc tmp3+1
.823b					+
.823b					_save_history_loop:
.823b	c4 21		cpy $21		                cpy status+1
.823d	f0 07		beq $8246	                beq _save_history_done
.823f	b1 24		lda ($24),y	                lda (tmp1),y
.8241	91 28		sta ($28),y	                sta (tmp3),y
.8243	c8		iny		                iny
.8244	80 f5		bra $823b	                bra _save_history_loop
.8246					_save_history_done:
.8246					z_accept:
.8246	60		rts		                rts
.8247					accept_total_recall:
.8247	a9 00		lda #$00	                lda #<hist_buff
.8249	85 28		sta $28		                sta tmp3
.824b	a9 7c		lda #$7c	                lda #>hist_buff
.824d	85 29		sta $29		                sta tmp3+1
.824f	a5 20		lda $20		                lda status
.8251	6a		ror a		                ror
.8252	29 03		and #$03	                and #3
.8254	18		clc		                clc
.8255	65 29		adc $29		                adc tmp3+1
.8257	85 29		sta $29		                sta tmp3+1
.8259	a5 20		lda $20		                lda status
.825b	6a		ror a		                ror             ; Rotate through carry into msb.
.825c	6a		ror a		                ror
.825d	29 80		and #$80	                and #$80
.825f	18		clc		                clc
.8260	65 28		adc $28		                adc tmp3
.8262	85 28		sta $28		                sta tmp3
.8264	90 02		bcc $8268	                bcc +           ; Increment the upper byte on carry.
.8266	e6 29		inc $29		                inc tmp3+1
.8268					+
.8268	98		tya		                tya
.8269	c9 80		cmp #$80	                cmp #$80
.826b	90 02		bcc $826f	                bcc +
.826d	a9 7f		lda #$7f	                lda #$7F
.826f					+
.826f	60		rts		                rts
.8270					xt_action_of:
.8270	a5 16		lda $16		                lda state
.8272	05 17		ora $17		                ora state+1
.8274	f0 0c		beq $8282	                beq _interpreting
.8276					_compiling:
.8276	20 8e 85	jsr $858e	                jsr xt_bracket_tick
.8279	a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.827b	a9 cf		lda #$cf	                lda #<xt_defer_fetch
.827d	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.8280	80 06		bra $8288	                bra _done
.8282					_interpreting:
.8282	20 ec a1	jsr $a1ec	                jsr xt_tick
.8285	20 cf 8a	jsr $8acf	                jsr xt_defer_fetch
.8288					_done:
.8288	60		rts		z_action_of:           rts
.8289					xt_again:
.8289	20 4a d6	jsr $d64a	                jsr underflow_1
.828c	a0 00		ldy #$00	                ldy #0
.828e	a9 4c		lda #$4c	                lda #$4C        ; JMP
.8290	91 00		sta ($00),y	                sta (cp),y
.8292	c8		iny		                iny
.8293	b5 00		lda $00,x	                lda 0,x         ; LSB of address
.8295	91 00		sta ($00),y	                sta (cp),y
.8297	c8		iny		                iny
.8298	b5 01		lda $01,x	                lda 1,x         ; MSB of address
.829a	91 00		sta ($00),y	                sta (cp),y
.829c	c8		iny		                iny
.829d	98		tya		                tya
.829e	18		clc		                clc
.829f	65 00		adc $00		                adc cp
.82a1	85 00		sta $00		                sta cp
.82a3	90 02		bcc $82a7	                bcc _done
.82a5	e6 01		inc $01		                inc cp+1
.82a7					_done:
.82a7	e8		inx		                inx
.82a8	e8		inx		                inx
.82a9	60		rts		z_again:        rts
.82aa					xt_align:
.82aa					xt_aligned:
.82aa					z_align:
.82aa	60		rts		z_aligned:      rts             ; stripped out during native compile
.82ab					xt_allot:
.82ab	20 4a d6	jsr $d64a	                jsr underflow_1
.82ae	b5 01		lda $01,x	                lda 1,x
.82b0	30 22		bmi $82d4	                bmi _release
.82b2	18		clc		                clc
.82b3	a5 00		lda $00		                lda cp
.82b5	75 00		adc $00,x	                adc 0,x
.82b7	85 00		sta $00		                sta cp
.82b9	a5 01		lda $01		                lda cp+1
.82bb	75 01		adc $01,x	                adc 1,x
.82bd	85 01		sta $01		                sta cp+1
.82bf	a0 00		ldy #$00	                ldy #<cp_end
.82c1	c4 00		cpy $00		                cpy cp
.82c3	a9 7c		lda #$7c	                lda #>cp_end
.82c5	e5 01		sbc $01		                sbc cp+1
.82c7	b0 48		bcs $8311	                bcs _done               ; we're fine.
.82c9	84 00		sty $00		                sty cp                  ; still #<cp_end
.82cb	a9 7c		lda #$7c	                lda #>cp_end
.82cd	85 01		sta $01		                sta cp+1
.82cf	a9 00		lda #$00	                lda #err_allot
.82d1	4c 60 d6	jmp $d660	                jmp error
.82d4					_release:
.82d4	ca		dex		                dex
.82d5	ca		dex		                dex
.82d6	a5 00		lda $00		                lda cp
.82d8	95 00		sta $00,x	                sta 0,x
.82da	a5 01		lda $01		                lda cp+1
.82dc	95 01		sta $01,x	                sta 1,x
.82de	20 c4 99	jsr $99c4	                jsr xt_plus                     ; new CP is now TOS
.82e1	ca		dex		                dex
.82e2	ca		dex		                dex                             ; new CP now NOS
.82e3	a9 00		lda #$00	                lda #<cp0
.82e5	95 00		sta $00,x	                sta 0,x
.82e7	a9 03		lda #$03	                lda #>cp0
.82e9	95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.82eb	20 71 d5	jsr $d571	                jsr compare_16bit               ; still ( CP CP0 )
.82ee	f0 17		beq $8307	                beq _nega_done
.82f0	30 15		bmi $8307	                bmi _nega_done
.82f2	a9 00		lda #$00	                lda #<cp0
.82f4	85 00		sta $00		                sta cp
.82f6	a9 03		lda #$03	                lda #>cp0
.82f8	85 01		sta $01		                sta cp+1
.82fa	a9 88		lda #$88	                lda #<dictionary_start
.82fc	85 02		sta $02		                sta dp
.82fe	a9 ba		lda #$ba	                lda #>dictionary_start
.8300	85 03		sta $03		                sta dp+1
.8302	a9 0a		lda #$0a	                lda #err_negallot
.8304	4c 60 d6	jmp $d660	                jmp error
.8307					_nega_done:
.8307	b5 02		lda $02,x	                lda 2,x
.8309	85 00		sta $00		                sta cp
.830b	b5 03		lda $03,x	                lda 3,x
.830d	85 01		sta $01		                sta cp+1
.830f	e8		inx		                inx
.8310	e8		inx		                inx                     ; drop through to _done
.8311					_done:
.8311	e8		inx		                inx
.8312	e8		inx		                inx
.8313					z_allot:
.8313	60		rts		                rts
.8314					xt_allow_native:
.8314	20 8c d5	jsr $d58c	                jsr current_to_dp
.8317	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8319	b1 02		lda ($02),y	                lda (dp),y
.831b	29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.831d	91 02		sta ($02),y	                sta (dp),y
.831f					z_allow_native:
.831f	60		rts		                rts
.8320					xt_also:
.8320	20 24 91	jsr $9124	                jsr xt_get_order
.8323	20 74 98	jsr $9874	                jsr xt_over
.8326	20 89 a1	jsr $a189	                jsr xt_swap
.8329	20 fe 97	jsr $97fe	                jsr xt_one_plus
.832c	20 fc 9c	jsr $9cfc	                jsr xt_set_order
.832f	60		rts		z_also:         rts
.8330					xt_always_native:
.8330	20 8c d5	jsr $d58c	                jsr current_to_dp
.8333	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8335	b1 02		lda ($02),y	                lda (dp),y
.8337	09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.8339	29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.833b	91 02		sta ($02),y	                sta (dp),y
.833d					z_always_native:
.833d	60		rts		                rts
.833e					xt_and:
.833e	20 4f d6	jsr $d64f	                jsr underflow_2
.8341	b5 00		lda $00,x	                lda 0,x
.8343	35 02		and $02,x	                and 2,x
.8345	95 02		sta $02,x	                sta 2,x
.8347	b5 01		lda $01,x	                lda 1,x
.8349	35 03		and $03,x	                and 3,x
.834b	95 03		sta $03,x	                sta 3,x
.834d	e8		inx		                inx
.834e	e8		inx		                inx
.834f	60		rts		z_and:          rts
.8350					xt_at_xy:
.8350	20 4f d6	jsr $d64f	                jsr underflow_2
.8353	a9 1b		lda #$1b	                lda #AscESC
.8355	20 e6 8d	jsr $8de6	                jsr emit_a
.8358	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.835a	20 e6 8d	jsr $8de6	                jsr emit_a
.835d	20 96 d6	jsr $d696	                jsr print_u
.8360	a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8362	20 e6 8d	jsr $8de6	                jsr emit_a
.8365	20 96 d6	jsr $d696	                jsr print_u
.8368	a9 48		lda #$48	                lda #'H'
.836a	20 e6 8d	jsr $8de6	                jsr emit_a
.836d	60		rts		z_at_xy:        rts
.836e					xt_backslash:
.836e	a5 0a		lda $0a		                lda ciblen
.8370	85 0c		sta $0c		                sta toin
.8372	a5 0b		lda $0b		                lda ciblen+1
.8374	85 0d		sta $0d		                sta toin+1
.8376	60		rts		z_backslash:    rts
.8377					xt_base:
.8377	ca		dex		                dex
.8378	ca		dex		                dex
.8379	a9 18		lda #$18	                lda #<base
.837b	95 00		sta $00,x	                sta 0,x         ; LSB
.837d	74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.837f	60		rts		z_base:         rts
.8380					xt_begin:
.8380	20 62 91	jsr $9162	                jsr xt_here
.8383	60		rts		z_begin:        rts
.8384					xt_bell:
.8384	a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.8386	20 e6 8d	jsr $8de6	                jsr emit_a
.8389	60		rts		z_bell:         rts
.838a					xt_bl:
.838a	ca		dex		                dex
.838b	ca		dex		                dex
.838c	a9 20		lda #$20	                lda #AscSP
.838e	95 00		sta $00,x	                sta 0,x
.8390	74 01		stz $01,x	                stz 1,x
.8392	60		rts		z_bl:           rts
.8393					xt_blk:
.8393	ca		dex		                dex
.8394	ca		dex		                dex
.8395	18		clc		                clc
.8396	a5 1e		lda $1e		                lda up
.8398	69 00		adc #$00	                adc #blk_offset ; Add offset
.839a	95 00		sta $00,x	                sta 0,x
.839c	a5 1f		lda $1f		                lda up+1
.839e	69 00		adc #$00	                adc #0          ; Adding carry
.83a0	95 01		sta $01,x	                sta 1,x
.83a2	60		rts		z_blk:          rts
.83a3					xt_blkbuffer:
.83a3	ca		dex		                dex
.83a4	ca		dex		                dex
.83a5	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83a7	b1 1e		lda ($1e),y	                lda (up),y
.83a9	95 00		sta $00,x	                sta 0,x
.83ab	c8		iny		                iny             ; Move along to the next byte
.83ac	b1 1e		lda ($1e),y	                lda (up),y
.83ae	95 01		sta $01,x	                sta 1,x
.83b0	60		rts		z_blkbuffer:    rts
.83b1					xt_block:
.83b1	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83b3	b1 1e		lda ($1e),y	                lda (up),y
.83b5	d5 00		cmp $00,x	                cmp 0,x
.83b7	d0 0f		bne $83c8	                bne _not_in_buffer
.83b9	c8		iny		                iny
.83ba	b1 1e		lda ($1e),y	                lda (up),y
.83bc	d5 01		cmp $01,x	                cmp 1,x
.83be	d0 08		bne $83c8	                bne _not_in_buffer
.83c0	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83c2	b1 1e		lda ($1e),y	                lda (up),y
.83c4	29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.83c6	d0 30		bne $83f8	                bne _done       ; It's already in the buffer and in use.
.83c8					_not_in_buffer:
.83c8	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83ca	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.83cc	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.83ce	d0 0c		bne $83dc	                bne _buffer_available ; Unused or not dirty = available
.83d0	20 a3 83	jsr $83a3	                jsr xt_blkbuffer
.83d3	20 95 85	jsr $8595	                jsr xt_buffblocknum
.83d6	20 70 8f	jsr $8f70	                jsr xt_fetch
.83d9	20 50 85	jsr $8550	                jsr xt_block_write
.83dc					_buffer_available:
.83dc	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83de	b5 00		lda $00,x	                lda 0,x
.83e0	91 1e		sta ($1e),y	                sta (up),y
.83e2	c8		iny		                iny
.83e3	b5 01		lda $01,x	                lda 1,x
.83e5	91 1e		sta ($1e),y	                sta (up),y
.83e7	20 a3 83	jsr $83a3	                jsr xt_blkbuffer
.83ea	20 89 a1	jsr $a189	                jsr xt_swap
.83ed	20 2d 85	jsr $852d	                jsr xt_block_read
.83f0	a9 01		lda #$01	                lda #1
.83f2	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83f4	91 1e		sta ($1e),y	                sta (up),y
.83f6	ca		dex		                dex
.83f7	ca		dex		                dex
.83f8					_done:
.83f8	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83fa	b1 1e		lda ($1e),y	                lda (up),y
.83fc	95 00		sta $00,x	                sta 0,x
.83fe	c8		iny		                iny
.83ff	b1 1e		lda ($1e),y	                lda (up),y
.8401	95 01		sta $01,x	                sta 1,x
.8403	60		rts		z_block:        rts
.8404					xt_block_ramdrive_init:
.8404	20 4a d6	jsr $d64a	                jsr underflow_1
.8407	4c 22 85	jmp $8522	                jmp _after_ramdrive_code
.840a					_ramdrive_code:
>840a	62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>8412	77 61 70 20 64 65 63 69 6d 61 6c
>841d	20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>8424	20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>8428	20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>8430	20 72 61 6d 64 72 69 76 65
>8439	20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>8441	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>844f	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8457	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8467	73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>8477	20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>847f	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>848e	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>8496	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>84a6	31 30 32 34 20 6d 6f 76 65 20 3b
>84b1	20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>84b9	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>84c9	6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>84d9	20 21
>84db	20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84e3	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>84f3	62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>8503	6f 72 20 21
>8507	20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>850f	65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>851f	65 20 21
.8522					_after_ramdrive_code:
.8522	20 8a a0	jsr $a08a	                jsr sliteral_runtime
>8525	0a 84 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.8529	20 c5 90	jsr $90c5	                jsr xt_evaluate
.852c					z_block_ramdrive_init:
.852c	60		rts		                rts
.852d					xt_block_read:
.852d	a0 2e		ldy #$2e	                ldy #blockread_offset
.852f	b1 1e		lda ($1e),y	                lda (up),y
.8531	85 24		sta $24		                sta tmp1
.8533	c8		iny		                iny
.8534	b1 1e		lda ($1e),y	                lda (up),y
.8536	85 25		sta $25		                sta tmp1+1
.8538	6c 24 00	jmp ($0024)	                jmp (tmp1)
.853b					z_block_read:
.853b					xt_block_read_vector:
.853b	ca		dex		                dex
.853c	ca		dex		                dex
.853d	18		clc		                clc
.853e	a5 1e		lda $1e		                lda up
.8540	69 2e		adc #$2e	                adc #blockread_offset
.8542	95 00		sta $00,x	                sta 0,x
.8544	a5 1f		lda $1f		                lda up+1
.8546	69 00		adc #$00	                adc #0          ; Add carry
.8548	95 01		sta $01,x	                sta 1,x
.854a					z_block_read_vector:
.854a	60		rts		                rts
.854b					xt_block_word_error:
.854b	a9 0c		lda #$0c	                lda #err_blockwords
.854d	4c 60 d6	jmp $d660	                jmp error       ; no RTS needed
.8550					z_block_word_error:
.8550					xt_block_write:
.8550	a0 30		ldy #$30	                ldy #blockwrite_offset
.8552	b1 1e		lda ($1e),y	                lda (up),y
.8554	85 24		sta $24		                sta tmp1
.8556	c8		iny		                iny
.8557	b1 1e		lda ($1e),y	                lda (up),y
.8559	85 25		sta $25		                sta tmp1+1
.855b	6c 24 00	jmp ($0024)	                jmp (tmp1)
.855e					z_block_write:
.855e					xt_block_write_vector:
.855e	ca		dex		                dex
.855f	ca		dex		                dex
.8560	18		clc		                clc
.8561	a5 1e		lda $1e		                lda up
.8563	69 30		adc #$30	                adc #blockwrite_offset
.8565	95 00		sta $00,x	                sta 0,x
.8567	a5 1f		lda $1f		                lda up+1
.8569	69 00		adc #$00	                adc #0          ; Add carry
.856b	95 01		sta $01,x	                sta 1,x
.856d					z_block_write_vector:
.856d	60		rts		                rts
.856e					xt_bounds:
.856e	20 4f d6	jsr $d64f	                jsr underflow_2
.8571	18		clc		                clc
.8572	b5 00		lda $00,x	                lda 0,x                 ; LSB u
.8574	b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.8576	75 02		adc $02,x	                adc 2,x
.8578	95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.857a	94 00		sty $00,x	                sty 0,x
.857c	b5 01		lda $01,x	                lda 1,x                 ; MSB u
.857e	b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8580	75 03		adc $03,x	                adc 3,x
.8582	95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.8584	94 01		sty $01,x	                sty 1,x
.8586	60		rts		z_bounds:       rts
.8587					xt_bracket_char:
.8587	20 21 86	jsr $8621	                jsr xt_char
.858a	20 7a 93	jsr $937a	                jsr xt_literal
.858d	60		rts		z_bracket_char: rts
.858e					xt_bracket_tick:
.858e	20 ec a1	jsr $a1ec	                jsr xt_tick
.8591	20 7a 93	jsr $937a	                jsr xt_literal
.8594	60		rts		z_bracket_tick: rts
.8595					xt_buffblocknum:
.8595	ca		dex		                dex
.8596	ca		dex		                dex
.8597	18		clc		                clc
.8598	a5 1e		lda $1e		                lda up
.859a	69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.859c	95 00		sta $00,x	                sta 0,x
.859e	a5 1f		lda $1f		                lda up+1
.85a0	69 00		adc #$00	                adc #0                          ; Adding carry
.85a2	95 01		sta $01,x	                sta 1,x
.85a4	60		rts		z_buffblocknum: rts
.85a5					xt_buffer:
.85a5	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85a7	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.85a9	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.85ab	d0 0c		bne $85b9	                bne _buffer_available ; Unused or not dirty = available
.85ad	20 a3 83	jsr $83a3	                jsr xt_blkbuffer
.85b0	20 95 85	jsr $8595	                jsr xt_buffblocknum
.85b3	20 70 8f	jsr $8f70	                jsr xt_fetch
.85b6	20 50 85	jsr $8550	                jsr xt_block_write
.85b9					_buffer_available:
.85b9	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.85bb	b5 00		lda $00,x	                lda 0,x
.85bd	91 1e		sta ($1e),y	                sta (up),y
.85bf	c8		iny		                iny
.85c0	b5 01		lda $01,x	                lda 1,x
.85c2	91 1e		sta ($1e),y	                sta (up),y
.85c4	a9 01		lda #$01	                lda #1
.85c6	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85c8	91 1e		sta ($1e),y	                sta (up),y
.85ca					_done:
.85ca	a0 28		ldy #$28	                ldy #blkbuffer_offset
.85cc	b1 1e		lda ($1e),y	                lda (up),y
.85ce	95 00		sta $00,x	                sta 0,x
.85d0	c8		iny		                iny
.85d1	b1 1e		lda ($1e),y	                lda (up),y
.85d3	95 01		sta $01,x	                sta 1,x
.85d5	60		rts		z_buffer:       rts
.85d6					xt_buffer_colon:
.85d6	20 59 89	jsr $8959	                jsr xt_create
.85d9	20 ab 82	jsr $82ab	                jsr xt_allot
.85dc	60		rts		z_buffer_colon: rts
.85dd					xt_buffstatus:
.85dd	ca		dex		                dex
.85de	ca		dex		                dex
.85df	18		clc		                clc
.85e0	a5 1e		lda $1e		                lda up
.85e2	69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.85e4	95 00		sta $00,x	                sta 0,x
.85e6	a5 1f		lda $1f		                lda up+1
.85e8	69 00		adc #$00	                adc #0                  ; Adding carry
.85ea	95 01		sta $01,x	                sta 1,x
.85ec	60		rts		z_buffstatus:   rts
.85ed					xt_bye:
.85ed	4c 2b f0	jmp $f02b	                jmp platform_bye
.85f0					z_bye:
.85f0					xt_c_comma:
.85f0	20 4a d6	jsr $d64a	                jsr underflow_1
.85f3	b5 00		lda $00,x	                lda 0,x
.85f5	20 fd d4	jsr $d4fd	                jsr cmpl_a
.85f8	e8		inx		                inx
.85f9	e8		inx		                inx
.85fa	60		rts		z_c_comma:      rts
.85fb					xt_c_fetch:
.85fb	20 4a d6	jsr $d64a	                jsr underflow_1
.85fe	a1 00		lda ($00,x)	                lda (0,x)
.8600	95 00		sta $00,x	                sta 0,x
.8602	74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8604	60		rts		z_c_fetch:      rts
.8605					xt_c_store:
.8605	20 4f d6	jsr $d64f	                jsr underflow_2
.8608	b5 02		lda $02,x	                lda 2,x
.860a	81 00		sta ($00,x)	                sta (0,x)
.860c	e8		inx		                inx
.860d	e8		inx		                inx
.860e	e8		inx		                inx
.860f	e8		inx		                inx
.8610	60		rts		z_c_store:      rts
.8611					xt_cell_plus:
.8611	20 4a d6	jsr $d64a	                jsr underflow_1
.8614	f6 00		inc $00,x	                inc 0,x
.8616	d0 02		bne $861a	                bne +
.8618	f6 01		inc $01,x	                inc 1,x
.861a					+
.861a	f6 00		inc $00,x	                inc 0,x
.861c	d0 02		bne $8620	                bne _done
.861e	f6 01		inc $01,x	                inc 1,x
.8620					_done:
.8620	60		rts		z_cell_plus:    rts
.8621					xt_char:
.8621	20 c0 98	jsr $98c0	                jsr xt_parse_name
.8624	b5 00		lda $00,x	                lda 0,x
.8626	15 01		ora $01,x	                ora 1,x
.8628	d0 05		bne $862f	                bne _not_empty
.862a	a9 05		lda #$05	                lda #err_noname
.862c	4c 60 d6	jmp $d660	                jmp error
.862f					_not_empty:
.862f	e8		inx		                inx             ; drop number of characters, leave addr
.8630	e8		inx		                inx
.8631	a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8633	95 00		sta $00,x	                sta 0,x
.8635	74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8637	60		rts		z_char:         rts
.8638					xt_chars:
.8638	20 4a d6	jsr $d64a	                jsr underflow_1
.863b	60		rts		z_chars:        rts
.863c					xt_cleave:
.863c	20 4f d6	jsr $d64f	                jsr underflow_2
.863f	20 53 95	jsr $9553	                jsr xt_minus_leading    ; -LEADING ( addr u )
.8642	20 52 92	jsr $9252	                jsr xt_input_to_r       ; save old imput state
.8645	b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.8647	85 0a		sta $0a		                sta ciblen
.8649	b5 01		lda $01,x	                lda 1,x
.864b	85 0b		sta $0b		                sta ciblen+1
.864d	b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.864f	85 08		sta $08		                sta cib
.8651	b5 03		lda $03,x	                lda 3,x
.8653	85 09		sta $09		                sta cib+1
.8655	64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.8657	64 0d		stz $0d		                stz toin+1
.8659	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.865c	b5 00		lda $00,x	                lda 0,x
.865e	15 01		ora $01,x	                ora 1,x
.8660	f0 23		beq $8685	                beq _done
.8662	b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.8664	38		sec		                sec
.8665	f5 00		sbc $00,x	                sbc 0,x
.8667	95 04		sta $04,x	                sta 4,x
.8669	b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.866b	f5 01		sbc $01,x	                sbc 1,x
.866d	95 05		sta $05,x	                sta 5,x
.866f	b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.8671	18		clc		                clc
.8672	75 00		adc $00,x	                adc 0,x
.8674	95 06		sta $06,x	                sta 6,x
.8676	b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.8678	75 01		adc $01,x	                adc 1,x
.867a	95 07		sta $07,x	                sta 7,x
.867c	20 59 a4	jsr $a459	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.867f	20 53 95	jsr $9553	                jsr xt_minus_leading
.8682	20 59 a4	jsr $a459	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.8685					_done:
.8685	20 84 9a	jsr $9a84	                jsr xt_r_to_input
.8688	60		rts		z_cleave:       rts
.8689					xt_cmove:
.8689	20 54 d6	jsr $d654	                jsr underflow_3
.868c	b5 02		lda $02,x	                lda 2,x
.868e	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.8690	b5 03		lda $03,x	                lda 3,x
.8692	85 27		sta $27		                sta tmp2+1
.8694	b5 04		lda $04,x	                lda 4,x
.8696	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.8698	b5 05		lda $05,x	                lda 5,x
.869a	85 25		sta $25		                sta tmp1+1
.869c	a0 00		ldy #$00	                ldy #0
.869e	b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.86a0	f0 0f		beq $86b1	                beq _dopartial
.86a2					_page:
.86a2	b1 24		lda ($24),y	                lda (tmp1),y
.86a4	91 26		sta ($26),y	                sta (tmp2),y
.86a6	c8		iny		                iny
.86a7	d0 f9		bne $86a2	                bne _page
.86a9	e6 25		inc $25		                inc tmp1+1
.86ab	e6 27		inc $27		                inc tmp2+1
.86ad	d6 01		dec $01,x	                dec 1,x
.86af	d0 f1		bne $86a2	                bne _page
.86b1					_dopartial:
.86b1	b5 00		lda $00,x	                lda 0,x         ; length of last page
.86b3	f0 09		beq $86be	                beq _done
.86b5					_partial:
.86b5	b1 24		lda ($24),y	                lda (tmp1),y
.86b7	91 26		sta ($26),y	                sta (tmp2),y
.86b9	c8		iny		                iny
.86ba	d6 00		dec $00,x	                dec 0,x
.86bc	d0 f7		bne $86b5	                bne _partial
.86be					_done:
.86be	8a		txa		                txa
.86bf	18		clc		                clc
.86c0	69 06		adc #$06	                adc #6
.86c2	aa		tax		                tax
.86c3	60		rts		z_cmove:        rts
.86c4					xt_cmove_up:
.86c4	20 54 d6	jsr $d654	                jsr underflow_3
.86c7	b5 02		lda $02,x	                lda 2,x
.86c9	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86cb	b5 03		lda $03,x	                lda 3,x
.86cd	18		clc		                clc
.86ce	75 01		adc $01,x	                adc 1,x
.86d0	85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.86d2	b5 04		lda $04,x	                lda 4,x
.86d4	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86d6	b5 05		lda $05,x	                lda 5,x
.86d8	18		clc		                clc
.86d9	75 01		adc $01,x	                adc 1,x
.86db	85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86dd	f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86df	b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86e1	f0 0e		beq $86f1	                beq _nopartial
.86e3					_outerloop:
.86e3	88		dey		                dey
.86e4	f0 07		beq $86ed	                beq _finishpage
.86e6					_innerloop:
.86e6	b1 24		lda ($24),y	                lda (tmp1),y
.86e8	91 26		sta ($26),y	                sta (tmp2),y
.86ea	88		dey		                dey
.86eb	d0 f9		bne $86e6	                bne _innerloop
.86ed					_finishpage:
.86ed	b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.86ef	92 26		sta ($26)	                sta (tmp2)
.86f1					_nopartial:
.86f1	c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.86f3	c6 27		dec $27		                dec tmp2+1
.86f5	d6 01		dec $01,x	                dec 1,x
.86f7	d0 ea		bne $86e3	                bne _outerloop
.86f9					_done:
.86f9	8a		txa		                txa
.86fa	18		clc		                clc
.86fb	69 06		adc #$06	                adc #6
.86fd	aa		tax		                tax
.86fe	60		rts		z_cmove_up:     rts
.86ff					xt_colon:
.86ff	a5 16		lda $16		                lda state
.8701	05 17		ora $17		                ora state+1
.8703	f0 05		beq $870a	                beq +
.8705	a9 07		lda #$07	                lda #err_state
.8707	4c 60 d6	jmp $d660	                jmp error
.870a					+
.870a	c6 16		dec $16		                dec state
.870c	c6 17		dec $17		                dec state+1
.870e	a9 40		lda #$40	                lda #%01000000
.8710	04 20		tsb $20		                tsb status
.8712	20 8c d5	jsr $d58c	                jsr current_to_dp
.8715	a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8717	48		pha		                pha
.8718	a5 02		lda $02		                lda dp
.871a	48		pha		                pha
.871b	a9 80		lda #$80	                lda #%10000000
.871d	04 20		tsb $20		                tsb status
.871f	20 59 89	jsr $8959	                jsr xt_create
.8722	20 8c d5	jsr $d58c	                jsr current_to_dp   ; This might be able to be omitted
.8725	a5 02		lda $02		                lda dp
.8727	85 04		sta $04		                sta workword
.8729	a5 03		lda $03		                lda dp+1
.872b	85 05		sta $05		                sta workword+1
.872d	68		pla		                pla
.872e	85 02		sta $02		                sta dp
.8730	68		pla		                pla
.8731	85 03		sta $03		                sta dp+1
.8733	20 9f d5	jsr $d59f	                jsr dp_to_current
.8736	a5 00		lda $00		                lda cp
.8738	38		sec		                sec
.8739	e9 03		sbc #$03	                sbc #3
.873b	85 00		sta $00		                sta cp
.873d	b0 02		bcs $8741	                bcs _done
.873f	c6 01		dec $01		                dec cp+1
.8741					_done:
.8741	60		rts		z_colon:        rts
.8742					xt_colon_noname:
.8742	a5 16		lda $16		                lda state
.8744	05 17		ora $17		                ora state+1
.8746	f0 05		beq $874d	                beq +
.8748	a9 07		lda #$07	                lda #err_state
.874a	4c 60 d6	jmp $d660	                jmp error
.874d					+
.874d	c6 16		dec $16		                dec state
.874f	c6 17		dec $17		                dec state+1
.8751	a9 40		lda #$40	                lda #%01000000
.8753	14 20		trb $20		                trb status
.8755	a5 00		lda $00		                lda cp
.8757	85 04		sta $04		                sta workword
.8759	a5 01		lda $01		                lda cp+1
.875b	85 05		sta $05		                sta workword+1
.875d					_done:
.875d	60		rts		z_colon_noname:        rts
.875e					xt_comma:
.875e	20 4a d6	jsr $d64a	                jsr underflow_1
.8761	b5 00		lda $00,x	                lda 0,x
.8763	92 00		sta ($00)	                sta (cp)
.8765	e6 00		inc $00		                inc cp
.8767	d0 02		bne $876b	                bne +
.8769	e6 01		inc $01		                inc cp+1
.876b					+
.876b	b5 01		lda $01,x	                lda 1,x
.876d	92 00		sta ($00)	                sta (cp)
.876f	e6 00		inc $00		                inc cp
.8771	d0 02		bne $8775	                bne _done
.8773	e6 01		inc $01		                inc cp+1
.8775					_done:
.8775	e8		inx		                inx
.8776	e8		inx		                inx
.8777	60		rts		z_comma:        rts
.8778					xt_compare:
.8778	20 59 d6	jsr $d659	                jsr underflow_4
.877b	b5 02		lda $02,x	                lda 2,x
.877d	85 26		sta $26		                sta tmp2
.877f	b5 03		lda $03,x	                lda 3,x
.8781	85 27		sta $27		                sta tmp2+1
.8783	b5 06		lda $06,x	                lda 6,x
.8785	85 24		sta $24		                sta tmp1
.8787	b5 07		lda $07,x	                lda 7,x
.8789	85 25		sta $25		                sta tmp1+1
.878b					_compare_loop:
.878b	b5 04		lda $04,x	                lda 4,x
.878d	15 05		ora $05,x	                ora 5,x
.878f	f0 2c		beq $87bd	                beq _str1_done
.8791	b5 00		lda $00,x	                lda 0,x
.8793	15 01		ora $01,x	                ora 1,x
.8795	f0 3a		beq $87d1	                beq _greater    ; Str2 empty first
.8797					_check_letter:
.8797	b2 24		lda ($24)	                lda (tmp1)
.8799	d2 26		cmp ($26)	                cmp (tmp2)
.879b	90 26		bcc $87c3	                bcc _less
.879d	d0 32		bne $87d1	                bne _greater
.879f					_next_letter:
.879f	e6 24		inc $24		                inc tmp1
.87a1	d0 02		bne $87a5	                bne +
.87a3	e6 25		inc $25		                inc tmp1+1
.87a5					+
.87a5	e6 26		inc $26		                inc tmp2
.87a7	d0 02		bne $87ab	                bne +
.87a9	e6 27		inc $27		                inc tmp2+1
.87ab					+
.87ab	b5 04		lda $04,x	                lda 4,x
.87ad	d0 02		bne $87b1	                bne +
.87af	d6 05		dec $05,x	                dec 5,x
.87b1					+
.87b1	d6 04		dec $04,x	                dec 4,x
.87b3	b5 00		lda $00,x	                lda 0,x
.87b5	d0 02		bne $87b9	                bne +
.87b7	d6 01		dec $01,x	                dec 1,x
.87b9					+
.87b9	d6 00		dec $00,x	                dec 0,x
.87bb	80 ce		bra $878b	                bra _compare_loop
.87bd					_str1_done:
.87bd	b5 00		lda $00,x	                lda 0,x
.87bf	15 01		ora $01,x	                ora 1,x
.87c1	f0 08		beq $87cb	                beq _equal      ; Both out of letters
.87c3					_less:
.87c3	a9 ff		lda #$ff	                lda #$FF
.87c5	95 06		sta $06,x	                sta 6,x
.87c7	95 07		sta $07,x	                sta 7,x
.87c9	80 0c		bra $87d7	                bra _done
.87cb					_equal:
.87cb	74 06		stz $06,x	                stz 6,x
.87cd	74 07		stz $07,x	                stz 7,x
.87cf	80 06		bra $87d7	                bra _done
.87d1					_greater:
.87d1	a9 01		lda #$01	                lda #1
.87d3	95 06		sta $06,x	                sta 6,x
.87d5	74 07		stz $07,x	                stz 7,x
.87d7					_done:
.87d7	8a		txa		                txa
.87d8	18		clc		                clc
.87d9	69 06		adc #$06	                adc #6
.87db	aa		tax		                tax
.87dc	60		rts		z_compare:      rts
.87dd					xt_compile_comma:
.87dd	20 4a d6	jsr $d64a	                jsr underflow_1
.87e0	b5 01		lda $01,x	                lda 1,x                 ; MSB
.87e2	48		pha		                pha
.87e3	b5 00		lda $00,x	                lda 0,x
.87e5	48		pha		                pha                     ; LSB
.87e6	20 68 92	jsr $9268	                jsr xt_int_to_name      ; ( xt -- nt )
.87e9	b5 00		lda $00,x	                lda 0,x
.87eb	15 01		ora $01,x	                ora 1,x
.87ed	d0 03		bne $87f2	                bne _check_nt
.87ef	4c da 88	jmp $88da	                jmp _compile_as_jump
.87f2					_check_nt:
.87f2	b5 00		lda $00,x	                lda 0,x
.87f4	85 2c		sta $2c		                sta tmptos
.87f6	b5 01		lda $01,x	                lda 1,x
.87f8	85 2d		sta $2d		                sta tmptos+1
.87fa	f6 00		inc $00,x	                inc 0,x
.87fc	d0 02		bne $8800	                bne +
.87fe	f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.8800					+
.8800	a1 00		lda ($00,x)	                lda (0,x)
.8802	85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.8804	29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8806	f0 0d		beq $8815	                beq _compile_check
.8808	a5 2c		lda $2c		                lda tmptos
.880a	95 00		sta $00,x	                sta 0,x
.880c	a5 2d		lda $2d		                lda tmptos+1
.880e	95 01		sta $01,x	                sta 1,x
.8810	20 4f a7	jsr $a74f	                jsr xt_wordsize         ; ( nt -- u )
.8813	80 27		bra $883c	                bra _compile_as_code
.8815					_compile_check:
.8815	a5 28		lda $28		                lda tmp3
.8817	29 08		and #$08	                and #NN
.8819	f0 03		beq $881e	                beq _check_size_limit
.881b	4c da 88	jmp $88da	                jmp _compile_as_jump    ; too far for BRA
.881e					_check_size_limit:
.881e	a5 2c		lda $2c		                lda tmptos
.8820	95 00		sta $00,x	                sta 0,x
.8822	a5 2d		lda $2d		                lda tmptos+1
.8824	95 01		sta $01,x	                sta 1,x
.8826	20 4f a7	jsr $a74f	                jsr xt_wordsize         ; ( nt -- u )
.8829	b5 01		lda $01,x	                lda 1,x
.882b	c5 1b		cmp $1b		                cmp nc_limit+1
.882d	90 0d		bcc $883c	                bcc _compile_as_code    ; user-defined limit MSB
.882f	d0 08		bne $8839	                bne _jumpto_compile_as_jump
.8831	b5 00		lda $00,x	                lda 0,x
.8833	c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.8835	90 05		bcc $883c	                bcc _compile_as_code    ; Allow native compiling for less
.8837	f0 03		beq $883c	                beq _compile_as_code    ; than or equal to the limit.
.8839					_jumpto_compile_as_jump:
.8839	4c da 88	jmp $88da	                jmp _compile_as_jump    ; too far for BRA
.883c					_compile_as_code:
.883c	ca		dex		                dex
.883d	ca		dex		                dex                     ; ( -- u ? )
.883e	ca		dex		                dex
.883f	ca		dex		                dex                     ; ( -- u ? ? )
.8840	b5 04		lda $04,x	                lda 4,x
.8842	95 00		sta $00,x	                sta 0,x                 ; LSB of u
.8844	b5 05		lda $05,x	                lda 5,x
.8846	95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.8848	68		pla		                pla
.8849	95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.884b	68		pla		                pla
.884c	95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.884e	a5 00		lda $00		                lda cp                  ; LSB of cp
.8850	95 02		sta $02,x	                sta 2,x
.8852	a5 01		lda $01		                lda cp+1
.8854	95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.8856	a0 00		ldy #$00	                ldy #0
.8858					_strip_loop:
.8858	b9 c8 88	lda $88c8,y	                lda _strip_table,y      ; LSB of first word
.885b	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.885d	d0 07		bne $8866	                bne _next_entry
.885f	b9 c9 88	lda $88c9,y	                lda _strip_table+1,y
.8862	d5 05		cmp $05,x	                cmp 5,x
.8864	f0 0c		beq $8872	                beq _found_entry
.8866					_next_entry:
.8866	b9 c8 88	lda $88c8,y	                lda _strip_table,y      ; pointing to LSB
.8869	19 c9 88	ora $88c9,y	                ora _strip_table+1,y    ; get MSB
.886c	f0 22		beq $8890	                beq _underflow_strip    ; table done, let's get out of here
.886e	c8		iny		                iny
.886f	c8		iny		                iny
.8870	80 e6		bra $8858	                bra _strip_loop
.8872					_found_entry:
.8872	98		tya		                tya
.8873	4a		lsr a		                lsr
.8874	a8		tay		                tay
.8875	b9 d4 88	lda $88d4,y	                lda _strip_size,y
.8878	85 2c		sta $2c		                sta tmptos              ; save a copy
.887a	18		clc		                clc
.887b	75 04		adc $04,x	                adc 4,x
.887d	95 04		sta $04,x	                sta 4,x
.887f	90 02		bcc $8883	                bcc+
.8881	f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8883					+
.8883	06 2c		asl $2c		                asl tmptos
.8885	38		sec		                sec
.8886	b5 00		lda $00,x	                lda 0,x
.8888	e5 2c		sbc $2c		                sbc tmptos
.888a	95 00		sta $00,x	                sta 0,x
.888c	b0 02		bcs $8890	                bcs +
.888e	d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8890					+
.8890					_underflow_strip:
.8890	a5 1c		lda $1c		                lda uf_strip
.8892	05 1d		ora $1d		                ora uf_strip+1
.8894	f0 1c		beq $88b2	                beq _specials_done
.8896	a5 28		lda $28		                lda tmp3
.8898	29 10		and #$10	                and #UF
.889a	f0 16		beq $88b2	                beq _specials_done
.889c	18		clc		                clc
.889d	b5 04		lda $04,x	                lda 4,x
.889f	69 03		adc #$03	                adc #3
.88a1	95 04		sta $04,x	                sta 4,x
.88a3	90 02		bcc $88a7	                bcc +
.88a5	f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.88a7					+
.88a7	38		sec		                sec
.88a8	b5 00		lda $00,x	                lda 0,x
.88aa	e9 03		sbc #$03	                sbc #3
.88ac	95 00		sta $00,x	                sta 0,x
.88ae	b0 02		bcs $88b2	                bcs +
.88b0	d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.88b2					+
.88b2					_specials_done:
.88b2	b5 01		lda $01,x	                lda 1,x                 ; MSB
.88b4	48		pha		                pha
.88b5	b5 00		lda $00,x	                lda 0,x                 ; LSB
.88b7	48		pha		                pha
.88b8	20 b2 95	jsr $95b2	                jsr xt_move
.88bb	18		clc		                clc
.88bc	68		pla		                pla                     ; LSB
.88bd	65 00		adc $00		                adc cp
.88bf	85 00		sta $00		                sta cp
.88c1	68		pla		                pla                     ; MSB
.88c2	65 01		adc $01		                adc cp+1
.88c4	85 01		sta $01		                sta cp+1
.88c6	80 2c		bra $88f4	                bra _done
.88c8					_strip_table:
>88c8	73 9a 5e 9a 4b a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88ce	7d a4 03 a4 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88d4					_strip_size:
>88d4	04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88da					_compile_as_jump:
.88da	a9 20		lda #$20	                lda #$20
.88dc	92 00		sta ($00)	                sta (cp)
.88de	a0 01		ldy #$01	                ldy #1
.88e0	68		pla		                pla             ; LSB
.88e1	91 00		sta ($00),y	                sta (cp),y
.88e3	c8		iny		                iny
.88e4	68		pla		                pla             ; MSB
.88e5	91 00		sta ($00),y	                sta (cp),y
.88e7	a9 03		lda #$03	                lda #3
.88e9	18		clc		                clc
.88ea	65 00		adc $00		                adc cp
.88ec	85 00		sta $00		                sta cp
.88ee	90 02		bcc $88f2	                bcc +
.88f0	e6 01		inc $01		                inc cp+1
.88f2					+
.88f2	e8		inx		                inx             ; drop xt
.88f3	e8		inx		                inx
.88f4					_done:
.88f4					z_compile_comma:
.88f4	60		rts		                rts
.88f5					xt_compile_only:
.88f5	20 8c d5	jsr $d58c	                jsr current_to_dp
.88f8	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.88fa	b1 02		lda ($02),y	                lda (dp),y
.88fc	09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.88fe	91 02		sta ($02),y	                sta (dp),y
.8900	60		rts		z_compile_only: rts
.8901					xt_value:
.8901					xt_constant:
.8901	20 4a d6	jsr $d64a	                jsr underflow_1
.8904	20 59 89	jsr $8959	                jsr xt_create
.8907	38		sec		                sec
.8908	a5 00		lda $00		                lda cp
.890a	e9 02		sbc #$02	                sbc #2
.890c	85 24		sta $24		                sta tmp1
.890e	a5 01		lda $01		                lda cp+1
.8910	e9 00		sbc #$00	                sbc #0
.8912	85 25		sta $25		                sta tmp1+1
.8914	a9 06		lda #$06	                lda #<doconst           ; LSB of DOCONST
.8916	92 24		sta ($24)	                sta (tmp1)
.8918	a0 01		ldy #$01	                ldy #1
.891a	a9 d5		lda #$d5	                lda #>doconst           ; MSB of DOCONST
.891c	91 24		sta ($24),y	                sta (tmp1),y
.891e	20 5e 87	jsr $875e	                jsr xt_comma            ; drop through to adjust_z
.8921					adjust_z:
.8921	20 2b 93	jsr $932b	                jsr xt_latestnt         ; gives us ( -- nt )
.8924	b5 00		lda $00,x	                lda 0,x
.8926	85 24		sta $24		                sta tmp1
.8928	b5 01		lda $01,x	                lda 1,x
.892a	85 25		sta $25		                sta tmp1+1
.892c	a0 06		ldy #$06	                ldy #6
.892e	b1 24		lda ($24),y	                lda (tmp1),y
.8930	18		clc		                clc
.8931	69 02		adc #$02	                adc #2
.8933	91 24		sta ($24),y	                sta (tmp1),y
.8935	c8		iny		                iny
.8936	b1 24		lda ($24),y	                lda (tmp1),y
.8938	69 00		adc #$00	                adc #0                  ; only need carry
.893a	91 24		sta ($24),y	                sta (tmp1),y
.893c	e8		inx		                inx
.893d	e8		inx		                inx
.893e					z_value:
.893e	60		rts		z_constant:     rts
.893f					xt_count:
.893f	20 4a d6	jsr $d64a	                jsr underflow_1
.8942	a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.8944	a8		tay		                tay
.8945	f6 00		inc $00,x	                inc 0,x         ; LSB
.8947	d0 02		bne $894b	                bne +
.8949	f6 01		inc $01,x	                inc 1,x         ; MSB
.894b	98		tya		+               tya
.894c	ca		dex		                dex
.894d	ca		dex		                dex
.894e	95 00		sta $00,x	                sta 0,x         ; LSB
.8950	74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8952	60		rts		z_count:        rts
.8953					xt_cr:
.8953	a9 0a		lda #$0a	                lda #AscLF
.8955	20 e6 8d	jsr $8de6	                jsr emit_a
.8958	60		rts		z_cr:           rts
.8959					xt_create:
.8959	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( addr u )
.895c	b5 00		lda $00,x	                lda 0,x
.895e	15 01		ora $01,x	                ora 1,x
.8960	d0 05		bne $8967	                bne _got_name
.8962	a9 05		lda #$05	                lda #err_noname
.8964	4c 60 d6	jmp $d660	                jmp error
.8967					_got_name:
.8967	74 01		stz $01,x	                stz 1,x
.8969	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( addr u addr u )
.896c	20 cb 8f	jsr $8fcb	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.896f	b5 00		lda $00,x	                lda 0,x
.8971	15 01		ora $01,x	                ora 1,x
.8973	f0 1e		beq $8993	                beq _new_name           ; We haven't seen this one before.
.8975	e8		inx		                inx                     ; Drop flag (nt) from find-name.
.8976	e8		inx		                inx
.8977	24 20		bit $20		                bit status
.8979	10 08		bpl $8983	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.897b	a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.897d	05 20		ora $20		                ora status
.897f	85 20		sta $20		                sta status
.8981	80 18		bra $899b	                bra _process_name
.8983					_redefined_name:
.8983	a9 02		lda #$02	                lda #str_redefined
.8985	20 76 d6	jsr $d676	                jsr print_string_no_lf
.8988	20 93 a3	jsr $a393	                jsr xt_two_dup           ; ( addr u addr u )
.898b	20 de a4	jsr $a4de	                jsr xt_type
.898e	20 ff a0	jsr $a0ff	                jsr xt_space
.8991	80 08		bra $899b	                bra _process_name
.8993					_new_name:
.8993	e8		inx		                inx                     ; Drop flag (0) from find-name.
.8994	e8		inx		                inx
.8995	a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.8997	25 20		and $20		                and status
.8999	85 20		sta $20		                sta status
.899b					_process_name:
.899b	b5 00		lda $00,x	                lda 0,x
.899d	85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.899f	a5 00		lda $00		                lda cp
.89a1	85 24		sta $24		                sta tmp1
.89a3	a5 01		lda $01		                lda cp+1
.89a5	85 25		sta $25		                sta tmp1+1
.89a7	b5 00		lda $00,x	                lda 0,x
.89a9	18		clc		                clc
.89aa	69 08		adc #$08	                adc #8
.89ac	85 28		sta $28		                sta tmp3                ; total header length
.89ae	18		clc		                clc
.89af	69 03		adc #$03	                adc #3
.89b1	95 00		sta $00,x	                sta 0,x
.89b3	74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.89b5	20 ab 82	jsr $82ab	                jsr xt_allot    ; ( addr )
.89b8	20 8c d5	jsr $d58c	                jsr current_to_dp
.89bb	a0 00		ldy #$00	                ldy #0
.89bd	a5 26		lda $26		                lda tmp2
.89bf	91 24		sta ($24),y	                sta (tmp1),y
.89c1	a9 08		lda #$08	                lda #NN
.89c3	09 20		ora #$20	                ora #HC
.89c5	c8		iny		                iny
.89c6	91 24		sta ($24),y	                sta (tmp1),y
.89c8	c8		iny		                iny
.89c9	a5 02		lda $02		                lda dp
.89cb	91 24		sta ($24),y	                sta (tmp1),y
.89cd	c8		iny		                iny
.89ce	a5 03		lda $03		                lda dp+1
.89d0	91 24		sta ($24),y	                sta (tmp1),y
.89d2	c8		iny		                iny
.89d3	a5 25		lda $25		                lda tmp1+1
.89d5	85 03		sta $03		                sta dp+1
.89d7	a5 24		lda $24		                lda tmp1
.89d9	85 02		sta $02		                sta dp
.89db	18		clc		                clc
.89dc	65 28		adc $28		                adc tmp3        ; add total header length
.89de	91 24		sta ($24),y	                sta (tmp1),y
.89e0	48		pha		                pha             ; we need this in the next step
.89e1	c8		iny		                iny
.89e2	a5 25		lda $25		                lda tmp1+1
.89e4	69 00		adc #$00	                adc #0          ; only need the carry
.89e6	91 24		sta ($24),y	                sta (tmp1),y
.89e8	c8		iny		                iny
.89e9	68		pla		                pla             ; LSB of "z_" address
.89ea	18		clc		                clc
.89eb	69 03		adc #$03	                adc #3
.89ed	91 24		sta ($24),y	                sta (tmp1),y
.89ef	88		dey		                dey             ; get the MSB of xt back
.89f0	b1 24		lda ($24),y	                lda (tmp1),y
.89f2	69 00		adc #$00	                adc #0          ; only need the carry
.89f4	c8		iny		                iny
.89f5	c8		iny		                iny
.89f6	91 24		sta ($24),y	                sta (tmp1),y
.89f8	c8		iny		                iny
.89f9	b5 00		lda $00,x	                lda 0,x
.89fb	38		sec		                sec
.89fc	e9 08		sbc #$08	                sbc #8
.89fe	85 2c		sta $2c		                sta tmptos
.8a00	b5 01		lda $01,x	                lda 1,x
.8a02	e9 00		sbc #$00	                sbc #0          ; only need carry
.8a04	85 2d		sta $2d		                sta tmptos+1
.8a06					_name_loop:
.8a06	b1 2c		lda ($2c),y	                lda (tmptos),y
.8a08	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8a0a	b0 07		bcs $8a13	                bcs _store_name
.8a0c	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8a0e	90 03		bcc $8a13	                bcc _store_name
.8a10	18		clc		                clc
.8a11	69 20		adc #$20	                adc #$20
.8a13					_store_name:
.8a13	91 24		sta ($24),y	                sta (tmp1),y
.8a15	c8		iny		                iny
.8a16	c6 26		dec $26		                dec tmp2
.8a18	d0 ec		bne $8a06	                bne _name_loop
.8a1a	a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a1c	91 24		sta ($24),y	                sta (tmp1),y
.8a1e	c8		iny		                iny
.8a1f	a9 4c		lda #$4c	                lda #<dovar
.8a21	91 24		sta ($24),y	                sta (tmp1),y
.8a23	c8		iny		                iny
.8a24	a9 d5		lda #$d5	                lda #>dovar
.8a26	91 24		sta ($24),y	                sta (tmp1),y
.8a28	20 9f d5	jsr $d59f	                jsr dp_to_current
.8a2b	e8		inx		                inx
.8a2c	e8		inx		                inx
.8a2d	60		rts		z_create:       rts
.8a2e					xt_d_minus:
.8a2e	20 59 d6	jsr $d659	                jsr underflow_4 ; two double numbers
.8a31	38		sec		                sec
.8a32	b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a34	f5 02		sbc $02,x	                sbc 2,x
.8a36	95 06		sta $06,x	                sta 6,x
.8a38	b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a3a	f5 03		sbc $03,x	                sbc 3,x
.8a3c	95 07		sta $07,x	                sta 7,x
.8a3e	b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a40	f5 00		sbc $00,x	                sbc 0,x
.8a42	95 04		sta $04,x	                sta 4,x
.8a44	b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a46	f5 01		sbc $01,x	                sbc 1,x
.8a48	95 05		sta $05,x	                sta 5,x
.8a4a	e8		inx		                inx
.8a4b	e8		inx		                inx
.8a4c	e8		inx		                inx
.8a4d	e8		inx		                inx
.8a4e	60		rts		z_d_minus:      rts
.8a4f					xt_d_plus:
.8a4f	20 59 d6	jsr $d659	                jsr underflow_4 ; two double numbers
.8a52	18		clc		                clc
.8a53	b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a55	75 06		adc $06,x	                adc 6,x
.8a57	95 06		sta $06,x	                sta 6,x
.8a59	b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a5b	75 07		adc $07,x	                adc 7,x
.8a5d	95 07		sta $07,x	                sta 7,x
.8a5f	b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a61	75 04		adc $04,x	                adc 4,x
.8a63	95 04		sta $04,x	                sta 4,x
.8a65	b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a67	75 05		adc $05,x	                adc 5,x
.8a69	95 05		sta $05,x	                sta 5,x
.8a6b	e8		inx		                inx
.8a6c	e8		inx		                inx
.8a6d	e8		inx		                inx
.8a6e	e8		inx		                inx
.8a6f	60		rts		z_d_plus:       rts
.8a70					xt_d_to_s:
.8a70	20 4f d6	jsr $d64f	                jsr underflow_2
.8a73	e8		inx		                inx
.8a74	e8		inx		                inx
.8a75	60		rts		z_d_to_s:       rts
.8a76					xt_dabs:
.8a76	20 4f d6	jsr $d64f	                jsr underflow_2 ; double number
.8a79	b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a7b	10 17		bpl $8a94	                bpl _done       ; positive, we get off light
.8a7d	a0 00		ldy #$00	                ldy #0
.8a7f	38		sec		                sec
.8a80	98		tya		                tya
.8a81	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a83	95 02		sta $02,x	                sta 2,x
.8a85	98		tya		                tya
.8a86	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a88	95 03		sta $03,x	                sta 3,x
.8a8a	98		tya		                tya
.8a8b	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a8d	95 00		sta $00,x	                sta 0,x
.8a8f	98		tya		                tya
.8a90	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a92	95 01		sta $01,x	                sta 1,x
.8a94					_done:
.8a94	60		rts		z_dabs:         rts
.8a95					xt_decimal:
.8a95	a9 0a		lda #$0a	                lda #10
.8a97	85 18		sta $18		                sta base
.8a99	64 19		stz $19		                stz base+1              ; paranoid
.8a9b	60		rts		z_decimal:      rts
.8a9c					xt_defer:
.8a9c	20 59 89	jsr $8959	                jsr xt_create
.8a9f	a5 00		lda $00		                lda cp          ; LSB
.8aa1	38		sec		                sec
.8aa2	e9 02		sbc #$02	                sbc #2
.8aa4	85 24		sta $24		                sta tmp1
.8aa6	a5 01		lda $01		                lda cp+1        ; MSB
.8aa8	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8aaa	85 25		sta $25		                sta tmp1+1
.8aac	a0 00		ldy #$00	                ldy #0
.8aae	a9 1a		lda #$1a	                lda #<dodefer   ; LSB
.8ab0	91 24		sta ($24),y	                sta (tmp1),y
.8ab2	c8		iny		                iny
.8ab3	a9 d5		lda #$d5	                lda #>dodefer   ; MSB
.8ab5	91 24		sta ($24),y	                sta (tmp1),y
.8ab7	a9 2e		lda #$2e	                lda #<defer_error
.8ab9	92 00		sta ($00)	                sta (cp)
.8abb	e6 00		inc $00		                inc cp
.8abd	d0 02		bne $8ac1	                bne +
.8abf	e6 01		inc $01		                inc cp+1
.8ac1					+
.8ac1	a9 d5		lda #$d5	                lda #>defer_error
.8ac3	92 00		sta ($00)	                sta (cp)
.8ac5	e6 00		inc $00		                inc cp
.8ac7	d0 02		bne $8acb	                bne +
.8ac9	e6 01		inc $01		                inc cp+1
.8acb					+
.8acb	20 21 89	jsr $8921	                jsr adjust_z    ; adjust header to correct length
.8ace	60		rts		z_defer:        rts
.8acf					xt_defer_fetch:
.8acf	20 68 a2	jsr $a268	                jsr xt_to_body
.8ad2	20 70 8f	jsr $8f70	                jsr xt_fetch
.8ad5	60		rts		z_defer_fetch:  rts
.8ad6					xt_defer_store:
.8ad6	20 68 a2	jsr $a268	                jsr xt_to_body
.8ad9	20 68 a1	jsr $a168	                jsr xt_store
.8adc	60		rts		z_defer_store:  rts
.8add					xt_definitions:
.8add	a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8adf	b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8ae1	a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8ae3	91 1e		sta ($1e),y	                sta (up),y
.8ae5	60		rts		z_definitions:  rts
.8ae6					xt_depth:
.8ae6	a9 78		lda #$78	                lda #dsp0
.8ae8	86 2a		stx $2a		                stx tmpdsp
.8aea	38		sec		                sec
.8aeb	e5 2a		sbc $2a		                sbc tmpdsp
.8aed	4a		lsr a		                lsr
.8aee	ca		dex		                dex
.8aef	ca		dex		                dex
.8af0	95 00		sta $00,x	                sta 0,x
.8af2	74 01		stz $01,x	                stz 1,x
.8af4	60		rts		z_depth:        rts
.8af5					xt_digit_question:
.8af5	20 4a d6	jsr $d64a	                jsr underflow_1
.8af8	ca		dex		                dex
.8af9	ca		dex		                dex
.8afa	74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8afc	74 01		stz $01,x	                stz 1,x
.8afe	74 03		stz $03,x	                stz 3,x                 ; paranoid
.8b00	b5 02		lda $02,x	                lda 2,x
.8b02	c9 30		cmp #$30	                cmp #'0'
.8b04	90 23		bcc $8b29	                bcc _done               ; failure flag already set
.8b06	c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8b08	90 12		bcc $8b1c	                bcc _checkbase
.8b0a	c9 41		cmp #$41	                cmp #'A'
.8b0c	90 1b		bcc $8b29	                bcc _done               ; failure flag is already set
.8b0e	c9 61		cmp #$61	                cmp #'a'
.8b10	90 07		bcc $8b19	                bcc _case_done          ; not lower case, too low
.8b12	c9 7b		cmp #$7b	                cmp #'z'+1
.8b14	b0 03		bcs $8b19	                bcs _case_done          ; not lower case, too high
.8b16	18		clc		                clc                     ; just right
.8b17	69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b19					_case_done:
.8b19	38		sec		                sec
.8b1a	e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b1c					_checkbase:
.8b1c	38		sec		                sec
.8b1d	e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b1f	c5 18		cmp $18		                cmp base
.8b21	b0 06		bcs $8b29	                bcs _done               ; already have false flag
.8b23	95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b25	d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b27	d6 01		dec $01,x	                dec 1,x
.8b29					_done:
.8b29					z_digit_question:
.8b29	60		rts		                rts
.8b2a					xt_disasm:
.8b2a	20 4f d6	jsr $d64f	                jsr underflow_2
.8b2d	20 b1 ac	jsr $acb1	                jsr disassembler
.8b30	60		rts		z_disasm:       rts
.8b31					xt_dnegate:
.8b31	20 4f d6	jsr $d64f	                jsr underflow_2 ; double number
.8b34	a0 00		ldy #$00	     		ldy #0
.8b36	38		sec		                sec
.8b37	98		tya		                tya
.8b38	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b3a	95 02		sta $02,x	                sta 2,x
.8b3c	98		tya		                tya
.8b3d	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b3f	95 03		sta $03,x	                sta 3,x
.8b41	98		tya		                tya
.8b42	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b44	95 00		sta $00,x	                sta 0,x
.8b46	98		tya		                tya
.8b47	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b49	95 01		sta $01,x	                sta 1,x
.8b4b	60		rts		z_dnegate:      rts
.8b4c					xt_question_do:
.8b4c	a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b4e	85 24		sta $24		                sta tmp1
.8b50	80 02		bra $8b54	                bra do_common           ; skip flag for DO
.8b52					xt_do:
.8b52	64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b54					do_common:
.8b54	ca		dex		                dex
.8b55	ca		dex		                dex
.8b56	a5 00		lda $00		                lda cp
.8b58	95 00		sta $00,x	                sta 0,x                 ; LSB
.8b5a	a5 01		lda $01		                lda cp+1
.8b5c	95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b5e	a9 05		lda #$05	                lda #5                  ; we don't really care about the value,
.8b60	a8		tay		                tay                     ; so we use 5 to be tricky
.8b61					_loop:
.8b61	91 00		sta ($00),y	                sta (CP),y
.8b63	88		dey		                dey
.8b64	10 fb		bpl $8b61	                bpl _loop
.8b66	1a		inc a		                ina             ; we used 5 as a dummy value, this is why
.8b67	18		clc		                clc
.8b68	65 00		adc $00		                adc CP
.8b6a	85 00		sta $00		                sta CP
.8b6c	90 02		bcc $8b70	                bcc +
.8b6e	e6 01		inc $01		                inc CP+1
.8b70					+
.8b70	a5 24		lda $24		                lda tmp1
.8b72	f0 17		beq $8b8b	                beq _compile_do
.8b74	a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b76	5a		phy		                phy             ; save counter to calculate new CP
.8b77					-
.8b77	b9 d1 8b	lda $8bd1,y	                lda question_do_runtime,y
.8b7a	91 00		sta ($00),y	                sta (cp),y
.8b7c	88		dey		                dey
.8b7d	10 f8		bpl $8b77	                bpl -
.8b7f	68		pla		                pla             ; retrieve counter
.8b80	18		clc		                clc
.8b81	65 00		adc $00		                adc cp
.8b83	85 00		sta $00		                sta cp
.8b85	a5 01		lda $01		                lda cp+1
.8b87	69 00		adc #$00	                adc #0          ; only care about carry
.8b89	85 01		sta $01		                sta cp+1        ; fall through to _compile_do
.8b8b					_compile_do:
.8b8b	a0 24		ldy #$24	                ldy #do_runtime_end-do_runtime  ; counter
.8b8d	5a		phy		                phy             ; save counter to calculate new CP
.8b8e					-
.8b8e	b9 ad 8b	lda $8bad,y	                lda do_runtime,y
.8b91	91 00		sta ($00),y	                sta (cp),y
.8b93	88		dey		                dey
.8b94	10 f8		bpl $8b8e	                bpl -
.8b96	68		pla		                pla             ; retrieve counter
.8b97	18		clc		                clc
.8b98	65 00		adc $00		                adc cp
.8b9a	85 00		sta $00		                sta cp
.8b9c	a5 01		lda $01		                lda cp+1
.8b9e	69 00		adc #$00	                adc #0          ; only care about carry
.8ba0	85 01		sta $01		                sta cp+1
.8ba2	ca		dex		                dex
.8ba3	ca		dex		                dex
.8ba4	a5 00		lda $00		                lda CP          ; LSB
.8ba6	95 00		sta $00,x	                sta 0,x
.8ba8	a5 01		lda $01		                lda CP+1        ; MSB
.8baa	95 01		sta $01,x	                sta 1,x
.8bac					z_question_do:
.8bac	60		rts		z_do:           rts
.8bad					do_runtime:
.8bad	38		sec		                sec
.8bae	a9 00		lda #$00	                lda #0
.8bb0	f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8bb2	95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8bb4	a9 80		lda #$80	                lda #$80
.8bb6	f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8bb8	95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8bba	48		pha		                pha             ; FUFA replaces limit on R stack
.8bbb	b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8bbd	48		pha		                pha
.8bbe	18		clc		                clc
.8bbf	b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8bc1	75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8bc3	95 00		sta $00,x	                sta 0,x
.8bc5	b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8bc7	75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8bc9	48		pha		                pha
.8bca	b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8bcc	48		pha		                pha
.8bcd	e8		inx		                inx
.8bce	e8		inx		                inx
.8bcf	e8		inx		                inx
.8bd0	e8		inx		                inx             ; no RTS because this is copied into code
.8bd1					do_runtime_end:
.8bd1					question_do_runtime:
.8bd1	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8bd4	20 be 8e	jsr $8ebe	                jsr xt_equal            ; ( -- n1 n2 f )
.8bd7	b5 00		lda $00,x	                lda 0,x
.8bd9	15 01		ora $01,x	                ora 1,x
.8bdb	f0 06		beq $8be3	                beq _do_do
.8bdd	8a		txa		                txa
.8bde	18		clc		                clc
.8bdf	69 06		adc #$06	                adc #6
.8be1	aa		tax		                tax
.8be2	60		rts		                rts
.8be3					_do_do:
.8be3	e8		inx		                inx             ; clear flag from EQUAL off stack
.8be4	e8		inx		                inx             ; no RTS because this is copied into code
.8be5					question_do_runtime_end:
.8be5					xt_does:
.8be5	a0 8b		ldy #$8b	                ldy #>does_runtime
.8be7	a9 f4		lda #$f4	                lda #<does_runtime
.8be9	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.8bec	a0 d5		ldy #$d5	                ldy #>dodoes
.8bee	a9 33		lda #$33	                lda #<dodoes
.8bf0	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.8bf3	60		rts		z_does:         rts
.8bf4					does_runtime:
.8bf4	7a		ply		                ply             ; LSB
.8bf5	68		pla		                pla             ; MSB
.8bf6	c8		iny		                iny
.8bf7	d0 01		bne $8bfa	                bne +
.8bf9	1a		inc a		                ina
.8bfa					+
.8bfa	84 24		sty $24		                sty tmp1
.8bfc	85 25		sta $25		                sta tmp1+1
.8bfe	20 8c d5	jsr $d58c	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8c01	a5 02		lda $02		                lda dp
.8c03	18		clc		                clc
.8c04	69 04		adc #$04	                adc #4
.8c06	85 26		sta $26		                sta tmp2
.8c08	a5 03		lda $03		                lda dp+1
.8c0a	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c0c	85 27		sta $27		                sta tmp2+1
.8c0e	b2 26		lda ($26)	                lda (tmp2)
.8c10	18		clc		                clc
.8c11	69 01		adc #$01	                adc #1
.8c13	85 28		sta $28		                sta tmp3
.8c15	a0 01		ldy #$01	                ldy #1
.8c17	b1 26		lda ($26),y	                lda (tmp2),y
.8c19	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c1b	85 29		sta $29		                sta tmp3+1
.8c1d	a5 24		lda $24		                lda tmp1        ; LSB
.8c1f	92 28		sta ($28)	                sta (tmp3)
.8c21	a5 25		lda $25		                lda tmp1+1
.8c23	91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8c25	60		rts		                rts
.8c26					xt_dot:
.8c26	20 4a d6	jsr $d64a	                jsr underflow_1
.8c29	20 9f 8d	jsr $8d9f	                jsr xt_dup                      ; ( n n )
.8c2c	20 39 81	jsr $8139	                jsr xt_abs                      ; ( n u )
.8c2f	20 82 a7	jsr $a782	                jsr xt_zero                     ; ( n u 0 )
.8c32	20 4a 93	jsr $934a	                jsr xt_less_number_sign         ; ( n u 0 )
.8c35	20 bf 97	jsr $97bf	                jsr xt_number_sign_s            ; ( n ud )
.8c38	20 38 9b	jsr $9b38	                jsr xt_rot                      ; ( ud n )
.8c3b	20 c8 9f	jsr $9fc8	                jsr xt_sign                     ; ( ud )
.8c3e	20 9d 97	jsr $979d	                jsr xt_number_sign_greater      ; ( addr u )
.8c41	20 de a4	jsr $a4de	                jsr xt_type
.8c44	20 ff a0	jsr $a0ff	                jsr xt_space
.8c47	60		rts		z_dot:          rts
.8c48					xt_dot_paren:
.8c48	ca		dex		                dex
.8c49	ca		dex		                dex
.8c4a	a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c4c	95 00		sta $00,x	                sta 0,x
.8c4e	74 01		stz $01,x	                stz 1,x
.8c50	20 1b 99	jsr $991b	                jsr xt_parse
.8c53	20 de a4	jsr $a4de	                jsr xt_type
.8c56	60		rts		z_dot_paren:    rts
.8c57					xt_dot_quote:
.8c57	20 30 9d	jsr $9d30	                jsr xt_s_quote
.8c5a	a0 a4		ldy #$a4	                ldy #>xt_type
.8c5c	a9 de		lda #$de	                lda #<xt_type
.8c5e	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.8c61	60		rts		z_dot_quote:    rts
.8c62					xt_dot_r:
.8c62	20 4f d6	jsr $d64f	                jsr underflow_2
.8c65	20 4b a3	jsr $a34b	                jsr xt_to_r
.8c68	20 9f 8d	jsr $8d9f	                jsr xt_dup
.8c6b	20 39 81	jsr $8139	                jsr xt_abs
.8c6e	20 82 a7	jsr $a782	                jsr xt_zero
.8c71	20 4a 93	jsr $934a	                jsr xt_less_number_sign
.8c74	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.8c77	20 38 9b	jsr $9b38	                jsr xt_rot
.8c7a	20 c8 9f	jsr $9fc8	                jsr xt_sign
.8c7d	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.8c80	20 73 9a	jsr $9a73	                jsr xt_r_from
.8c83	20 74 98	jsr $9874	                jsr xt_over
.8c86	20 40 95	jsr $9540	                jsr xt_minus
.8c89	20 05 a1	jsr $a105	                jsr xt_spaces
.8c8c	20 de a4	jsr $a4de	                jsr xt_type
.8c8f	60		rts		z_dot_r:        rts
.8c90					xt_dot_s:
.8c90	20 e6 8a	jsr $8ae6	                jsr xt_depth    ; ( -- u )
.8c93	a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8c95	20 e6 8d	jsr $8de6	                jsr emit_a
.8c98	b5 00		lda $00,x	                lda 0,x
.8c9a	48		pha		                pha
.8c9b	ca		dex		                dex             ; DUP
.8c9c	ca		dex		                dex
.8c9d	95 00		sta $00,x	                sta 0,x
.8c9f	74 01		stz $01,x	                stz 1,x
.8ca1	20 96 d6	jsr $d696	                jsr print_u
.8ca4	a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8ca6	20 e6 8d	jsr $8de6	                jsr emit_a
.8ca9	a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8cab	20 e6 8d	jsr $8de6	                jsr emit_a
.8cae	e8		inx		                inx
.8caf	e8		inx		                inx
.8cb0	e0 78		cpx #$78	                cpx #dsp0
.8cb2	f0 1e		beq $8cd2	                beq _done
.8cb4					_have_stack:
.8cb4	7a		ply		                ply
.8cb5	a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8cb7	85 28		sta $28		                sta tmp3
.8cb9	64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8cbb					_loop:
.8cbb	ca		dex		                dex
.8cbc	ca		dex		                dex
.8cbd	b2 28		lda ($28)	                lda (tmp3)
.8cbf	95 01		sta $01,x	                sta 1,x
.8cc1	c6 28		dec $28		                dec tmp3
.8cc3	b2 28		lda ($28)	                lda (tmp3)
.8cc5	95 00		sta $00,x	                sta 0,x
.8cc7	c6 28		dec $28		                dec tmp3
.8cc9	5a		phy		                phy
.8cca	20 26 8c	jsr $8c26	                jsr xt_dot
.8ccd	7a		ply		                ply
.8cce	88		dey		                dey
.8ccf	d0 ea		bne $8cbb	                bne _loop
.8cd1	48		pha		                pha             ; dummy to balance stack
.8cd2					_done:
.8cd2	68		pla		                pla
.8cd3	60		rts		z_dot_s:        rts
.8cd4					xt_d_dot:
.8cd4	20 4f d6	jsr $d64f	                jsr underflow_2
.8cd7	20 68 a3	jsr $a368	                jsr xt_tuck
.8cda	20 76 8a	jsr $8a76	                jsr xt_dabs
.8cdd	20 4a 93	jsr $934a	                jsr xt_less_number_sign
.8ce0	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.8ce3	20 38 9b	jsr $9b38	                jsr xt_rot
.8ce6	20 c8 9f	jsr $9fc8	                jsr xt_sign
.8ce9	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.8cec	20 de a4	jsr $a4de	                jsr xt_type
.8cef	20 ff a0	jsr $a0ff	                jsr xt_space
.8cf2	60		rts		z_d_dot:        rts
.8cf3					xt_d_dot_r:
.8cf3	20 54 d6	jsr $d654	                jsr underflow_3
.8cf6	20 4b a3	jsr $a34b	                jsr xt_to_r
.8cf9	20 68 a3	jsr $a368	                jsr xt_tuck
.8cfc	20 76 8a	jsr $8a76	                jsr xt_dabs
.8cff	20 4a 93	jsr $934a	                jsr xt_less_number_sign
.8d02	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.8d05	20 38 9b	jsr $9b38	                jsr xt_rot
.8d08	20 c8 9f	jsr $9fc8	                jsr xt_sign
.8d0b	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.8d0e	20 73 9a	jsr $9a73	                jsr xt_r_from
.8d11	20 74 98	jsr $9874	                jsr xt_over
.8d14	20 40 95	jsr $9540	                jsr xt_minus
.8d17	20 05 a1	jsr $a105	                jsr xt_spaces
.8d1a	20 de a4	jsr $a4de	                jsr xt_type
.8d1d	60		rts		z_d_dot_r:      rts
.8d1e					xt_drop:
.8d1e	20 4a d6	jsr $d64a	                jsr underflow_1
.8d21	e8		inx		                inx
.8d22	e8		inx		                inx
.8d23	60		rts		z_drop:         rts
.8d24					xt_dump:
.8d24	20 4f d6	jsr $d64f	                jsr underflow_2
.8d27					_row:
.8d27	a0 10		ldy #$10	                ldy #16
.8d29	64 26		stz $26		                stz tmp2
.8d2b	20 53 89	jsr $8953	                jsr xt_cr
.8d2e	b5 03		lda $03,x	                lda 3,x
.8d30	20 5a d5	jsr $d55a	                jsr byte_to_ascii
.8d33	b5 02		lda $02,x	                lda 2,x
.8d35	20 5a d5	jsr $d55a	                jsr byte_to_ascii
.8d38	20 ff a0	jsr $a0ff	                jsr xt_space
.8d3b	20 ff a0	jsr $a0ff	                jsr xt_space
.8d3e					_loop:
.8d3e	b5 00		lda $00,x	                lda 0,x
.8d40	15 01		ora $01,x	                ora 1,x
.8d42	f0 39		beq $8d7d	                beq _all_printed
.8d44	a1 02		lda ($02,x)	                lda (2,x)
.8d46	48		pha		                pha                     ; byte_to_ascii destroys A
.8d47	20 5a d5	jsr $d55a	                jsr byte_to_ascii
.8d4a	20 ff a0	jsr $a0ff	                jsr xt_space
.8d4d	68		pla		                pla
.8d4e	20 30 d6	jsr $d630	                jsr is_printable
.8d51	b0 02		bcs $8d55	                bcs _printable
.8d53	a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d55					_printable:
.8d55	5a		phy		                phy                     ; save counter
.8d56	a4 26		ldy $26		                ldy tmp2
.8d58	91 00		sta ($00),y	                sta (cp),y
.8d5a	e6 26		inc $26		                inc tmp2
.8d5c	7a		ply		                ply
.8d5d	c0 09		cpy #$09	                cpy #9
.8d5f	d0 03		bne $8d64	                bne _next_char
.8d61	20 ff a0	jsr $a0ff	                jsr xt_space
.8d64					_next_char:
.8d64	f6 02		inc $02,x	                inc 2,x
.8d66	d0 02		bne $8d6a	                bne _counter
.8d68	f6 03		inc $03,x	                inc 3,x
.8d6a					_counter:
.8d6a	b5 00		lda $00,x	                lda 0,x
.8d6c	d0 02		bne $8d70	                bne +
.8d6e	d6 01		dec $01,x	                dec 1,x
.8d70					+
.8d70	d6 00		dec $00,x	                dec 0,x
.8d72	88		dey		                dey
.8d73	d0 c9		bne $8d3e	                bne _loop               ; next byte
.8d75	20 ff a0	jsr $a0ff	                jsr xt_space
.8d78	20 8b 8d	jsr $8d8b	                jsr dump_print_ascii
.8d7b	80 aa		bra $8d27	                bra _row                ; new row
.8d7d					_all_printed:
.8d7d	a5 26		lda $26		                lda tmp2
.8d7f	f0 06		beq $8d87	                beq _done
.8d81	20 ff a0	jsr $a0ff	                jsr xt_space
.8d84	20 8b 8d	jsr $8d8b	                jsr dump_print_ascii
.8d87					_done:
.8d87	20 8b a3	jsr $a38b	                jsr xt_two_drop         ; one byte less than 4x INX
.8d8a	60		rts		z_dump:         rts
.8d8b					dump_print_ascii:
.8d8b	a0 00		ldy #$00	                ldy #0
.8d8d					_ascii_loop:
.8d8d	b1 00		lda ($00),y	                lda (cp),y
.8d8f	20 e6 8d	jsr $8de6	                jsr emit_a
.8d92	c8		iny		                iny
.8d93	c0 08		cpy #$08	                cpy #8
.8d95	d0 03		bne $8d9a	                bne +
.8d97	20 ff a0	jsr $a0ff	                jsr xt_space
.8d9a					+
.8d9a	c6 26		dec $26		                dec tmp2
.8d9c	d0 ef		bne $8d8d	                bne _ascii_loop
.8d9e	60		rts		                rts
.8d9f					xt_dup:
.8d9f	20 4a d6	jsr $d64a	                jsr underflow_1
.8da2	ca		dex		                dex
.8da3	ca		dex		                dex
.8da4	b5 02		lda $02,x	                lda 2,x         ; LSB
.8da6	95 00		sta $00,x	                sta 0,x
.8da8	b5 03		lda $03,x	                lda 3,x         ; MSB
.8daa	95 01		sta $01,x	                sta 1,x
.8dac	60		rts		z_dup:          rts
.8dad					xt_ed:
.8dad	20 ef b3	jsr $b3ef	                jsr ed6502      ; kept in separate file
.8db0	60		rts		z_ed:           rts
.8db1					xt_else:
.8db1					xt_endof:
.8db1	a0 8d		ldy #$8d	                ldy #>branch_runtime
.8db3	a9 cb		lda #$cb	                lda #<branch_runtime
.8db5	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.8db8	20 62 91	jsr $9162	                jsr xt_here
.8dbb	20 82 a7	jsr $a782	                jsr xt_zero
.8dbe	20 5e 87	jsr $875e	                jsr xt_comma
.8dc1	20 62 91	jsr $9162	                jsr xt_here
.8dc4	20 38 9b	jsr $9b38	                jsr xt_rot
.8dc7	20 68 a1	jsr $a168	                jsr xt_store
.8dca					z_else:
.8dca					z_endof:
.8dca	60		rts		                rts
.8dcb					branch_runtime:
.8dcb	68		pla		                pla
.8dcc	85 22		sta $22		                sta tmpbranch
.8dce	68		pla		                pla
.8dcf	85 23		sta $23		                sta tmpbranch+1
.8dd1	a0 01		ldy #$01	                ldy #1
.8dd3	b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8dd5	85 24		sta $24		                sta tmp1
.8dd7	c8		iny		                iny
.8dd8	b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8dda	85 25		sta $25		                sta tmp1+1
.8ddc	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8ddf					xt_emit:
.8ddf	20 4a d6	jsr $d64a	                jsr underflow_1
.8de2	b5 00		lda $00,x	                lda 0,x
.8de4	e8		inx		                inx
.8de5	e8		inx		                inx
.8de6					emit_a:
.8de6	6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8de9					z_emit:
.8de9					xt_empty_buffers:
.8de9	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8deb	a9 00		lda #$00	                lda #0
.8ded	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8def					z_empty_buffers:
.8def	60		rts		                rts
.8df0					xt_endcase:
.8df0	a0 8d		ldy #$8d	                ldy #>xt_drop
.8df2	a9 1e		lda #$1e	                lda #<xt_drop
.8df4	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.8df7					_endcase_loop:
.8df7	b5 00		lda $00,x	                lda 0,x
.8df9	15 01		ora $01,x	                ora 1,x
.8dfb	f0 05		beq $8e02	                beq _done
.8dfd	20 9d a1	jsr $a19d	                jsr xt_then
.8e00	80 f5		bra $8df7	                bra _endcase_loop
.8e02					_done:
.8e02	e8		inx		                inx
.8e03	e8		inx		                inx
.8e04	60		rts		z_endcase:      rts
.8e05					xt_environment_q:
.8e05	20 4a d6	jsr $d64a	                jsr underflow_1
.8e08	a0 00		ldy #$00	                ldy #00                 ; counter for table
.8e0a	5a		phy		                phy
.8e0b					_table_loop:
.8e0b	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e0e	ca		dex		                dex
.8e0f	ca		dex		                dex                     ; ( addr u addr u ? )
.8e10	b9 82 8e	lda $8e82,y	                lda env_table_single,y
.8e13	95 00		sta $00,x	                sta 0,x
.8e15	c8		iny		                iny
.8e16	b9 82 8e	lda $8e82,y	                lda env_table_single,y
.8e19	95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e1b	c8		iny		                iny
.8e1c	15 00		ora $00,x	                ora 0,x
.8e1e	f0 4d		beq $8e6d	                beq _table_done
.8e20	5a		phy		                phy                     ; save Y, which is used by COUNT
.8e21	20 3f 89	jsr $893f	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e24	20 78 87	jsr $8778	                jsr xt_compare          ; ( addr u f )
.8e27	7a		ply		                ply
.8e28	b5 00		lda $00,x	                lda 0,x
.8e2a	15 01		ora $01,x	                ora 1,x
.8e2c	f0 04		beq $8e32	                beq _got_result
.8e2e	e8		inx		                inx                     ; DROP, now ( addr u )
.8e2f	e8		inx		                inx
.8e30	80 d9		bra $8e0b	                bra _table_loop
.8e32					_got_result:
.8e32	e8		inx		                inx                     ; drop flag, now ( addr u )
.8e33	e8		inx		                inx
.8e34	88		dey		                dey                     ; go back to index we had
.8e35	88		dey		                dey
.8e36	68		pla		                pla
.8e37	d0 0d		bne $8e46	                bne _double_result
.8e39	b9 a0 8e	lda $8ea0,y	                lda env_results_single,y
.8e3c	95 02		sta $02,x	                sta 2,x
.8e3e	c8		iny		                iny
.8e3f	b9 a0 8e	lda $8ea0,y	                lda env_results_single,y
.8e42	95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e44	80 1f		bra $8e65	                bra _set_flag
.8e46					_double_result:
.8e46	ca		dex		                dex                     ; ( addr u ? )
.8e47	ca		dex		                dex
.8e48	98		tya		                tya
.8e49	38		sec		                sec
.8e4a	e9 18		sbc #$18	                sbc #24
.8e4c	0a		asl a		                asl
.8e4d	a8		tay		                tay
.8e4e	b9 b6 8e	lda $8eb6,y	                lda env_results_double,y
.8e51	95 02		sta $02,x	                sta 2,x
.8e53	c8		iny		                iny
.8e54	b9 b6 8e	lda $8eb6,y	                lda env_results_double,y
.8e57	95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e59	c8		iny		                iny
.8e5a	b9 b6 8e	lda $8eb6,y	                lda env_results_double,y
.8e5d	95 04		sta $04,x	                sta 4,x
.8e5f	c8		iny		                iny
.8e60	b9 b6 8e	lda $8eb6,y	                lda env_results_double,y
.8e63	95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e65					_set_flag:
.8e65	a9 ff		lda #$ff	                lda #$ff
.8e67	95 00		sta $00,x	                sta 0,x
.8e69	95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e6b	80 14		bra $8e81	                bra _done
.8e6d					_table_done:
.8e6d	68		pla		                pla
.8e6e	d0 09		bne $8e79	                bne _no_match
.8e70	1a		inc a		                ina
.8e71	48		pha		                pha
.8e72	8a		txa		                txa
.8e73	18		clc		                clc
.8e74	69 06		adc #$06	                adc #6                  ; skip six bytes
.8e76	aa		tax		                tax                     ; ( addr u )
.8e77	80 92		bra $8e0b	                bra _table_loop
.8e79					_no_match:
.8e79	8a		txa		                txa
.8e7a	18		clc		                clc
.8e7b	69 0a		adc #$0a	                adc #10
.8e7d	aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e7e	20 69 8f	jsr $8f69	                jsr xt_false
.8e81					_done:
.8e81					z_environment_q:
.8e81	60		rts		                rts
.8e82					env_table_single:
>8e82	6d d4 7d d4 83 d4 88 d4		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e8a	9a d4
>8e8c	a2 d4 ab d4 b1 d4 b7 d4		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e94	ca d4 d6 d4 00 00		        .word envs_sc, envs_wl, 0000
.8e9a					env_table_double:
>8e9a	e0 d4 e6 d4 00 00		        .word envs_max_d, envs_max_ud, 0000
.8ea0					env_results_single:
>8ea0	ff 7f				        .word $7FFF     ; /COUNTED-STRING
>8ea2	ff 00				        .word $00FF     ; /HOLD
>8ea4	54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8ea6	08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8ea8	00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8eaa	ff 00				        .word $00FF     ; MAX-CHAR
>8eac	ff 7f				        .word $7FFF     ; MAX-N
>8eae	ff ff				        .word $FFFF     ; MAX-U
>8eb0	80 00				        .word $0080     ; RETURN-STACK-CELLS
>8eb2	20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8eb4	09 00				        .word $0009     ; WORDLISTS
.8eb6					env_results_double:
>8eb6	ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8eba	ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8ebe					xt_equal:
.8ebe	20 4f d6	jsr $d64f	                jsr underflow_2
.8ec1	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8ec3	d5 02		cmp $02,x	                cmp 2,x
.8ec5	d0 0a		bne $8ed1	                bne _false
.8ec7	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8ec9	d5 03		cmp $03,x	                cmp 3,x
.8ecb	d0 04		bne $8ed1	                bne _false
.8ecd	a9 ff		lda #$ff	                lda #$ff
.8ecf	80 02		bra $8ed3	                bra _done
.8ed1	a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8ed3	95 02		sta $02,x	_done:          sta 2,x
.8ed5	95 03		sta $03,x	                sta 3,x
.8ed7	e8		inx		                inx
.8ed8	e8		inx		                inx
.8ed9	60		rts		z_equal:        rts
.8eda					xt_blank:
.8eda	ca		dex		                dex
.8edb	ca		dex		                dex
.8edc	a9 20		lda #$20	                lda #AscSP
.8ede	95 00		sta $00,x	                sta 0,x
.8ee0	74 01		stz $01,x	                stz 1,x
.8ee2	80 06		bra $8eea	                bra xt_fill     ; skip over code for ERASE
.8ee4					xt_erase:
.8ee4	ca		dex		                dex
.8ee5	ca		dex		                dex
.8ee6	74 00		stz $00,x	                stz 0,x
.8ee8	74 01		stz $01,x	                stz 1,x
.8eea					xt_fill:
.8eea	20 54 d6	jsr $d654	                jsr underflow_3
.8eed	b5 04		lda $04,x	                lda 4,x         ; LSB
.8eef	85 24		sta $24		                sta tmp1
.8ef1	b5 05		lda $05,x	                lda 5,x
.8ef3	85 25		sta $25		                sta tmp1+1
.8ef5	b5 02		lda $02,x	                lda 2,x
.8ef7	85 26		sta $26		                sta tmp2
.8ef9	b5 03		lda $03,x	                lda 3,x
.8efb	85 27		sta $27		                sta tmp2+1
.8efd	b5 00		lda $00,x	                lda 0,x
.8eff	a8		tay		                tay
.8f00					_loop:
.8f00	a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8f02	c5 25		cmp $25		                cmp tmp1+1
.8f04	90 21		bcc $8f27	                bcc _done               ; RAM_END < TMP1, so leave
.8f06	d0 06		bne $8f0e	                bne _check_counter      ; RAM_END is not smaller and not equal
.8f08	a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8f0a	c5 24		cmp $24		                cmp tmp1
.8f0c	90 19		bcc $8f27	                bcc _done               ; RAM_END < TMP1, so leave
.8f0e					_check_counter:
.8f0e	a5 26		lda $26		                lda tmp2
.8f10	05 27		ora $27		                ora tmp2+1
.8f12	f0 13		beq $8f27	                beq _done
.8f14	98		tya		                tya
.8f15	92 24		sta ($24)	                sta (tmp1)
.8f17	a5 26		lda $26		                lda tmp2
.8f19	d0 02		bne $8f1d	                bne +
.8f1b	c6 27		dec $27		                dec tmp2+1
.8f1d	c6 26		dec $26		+               dec tmp2
.8f1f	e6 24		inc $24		                inc tmp1
.8f21	d0 dd		bne $8f00	                bne _loop
.8f23	e6 25		inc $25		                inc tmp1+1
.8f25	80 d9		bra $8f00	                bra _loop
.8f27					_done:
.8f27	8a		txa		                txa
.8f28	18		clc		                clc
.8f29	69 06		adc #$06	                adc #6
.8f2b	aa		tax		                tax
.8f2c					z_blank:
.8f2c					z_erase:
.8f2c	60		rts		z_fill:         rts
.8f2d					xt_execute:
.8f2d	20 4a d6	jsr $d64a	                jsr underflow_1
.8f30	20 34 8f	jsr $8f34	                jsr doexecute   ; do not combine to JMP (native coding)
.8f33	60		rts		z_execute:      rts
.8f34					doexecute:
.8f34	b5 00		lda $00,x	                lda 0,x
.8f36	85 0e		sta $0e		                sta ip
.8f38	b5 01		lda $01,x	                lda 1,x
.8f3a	85 0f		sta $0f		                sta ip+1
.8f3c	e8		inx		                inx
.8f3d	e8		inx		                inx
.8f3e	6c 0e 00	jmp ($000e)	                jmp (ip)
.8f41					xt_execute_parsing:
.8f41	20 54 d6	jsr $d654	                jsr underflow_3
.8f44	20 52 92	jsr $9252	                jsr xt_input_to_r       ; save normal input for later
.8f47	20 5e 96	jsr $965e	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f4a	b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f4c	85 0a		sta $0a		                sta ciblen
.8f4e	b5 01		lda $01,x	                lda 1,x
.8f50	85 0b		sta $0b		                sta ciblen+1
.8f52	b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f54	85 08		sta $08		                sta cib
.8f56	b5 03		lda $03,x	                lda 3,x
.8f58	85 09		sta $09		                sta cib+1
.8f5a	64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f5c	64 0d		stz $0d		                stz toin+1
.8f5e	20 8b a3	jsr $a38b	                jsr xt_two_drop         ; 2DROP ( xt )
.8f61	20 2d 8f	jsr $8f2d	                jsr xt_execute
.8f64	20 84 9a	jsr $9a84	                jsr xt_r_to_input
.8f67					z_execute_parsing:
.8f67	60		rts		                rts
.8f68					xt_exit:
.8f68	60		rts		                rts             ; keep before z_exit
.8f69					z_exit:
.8f69					xt_false:
.8f69	ca		dex		                dex
.8f6a	ca		dex		                dex
.8f6b	74 00		stz $00,x	                stz 0,x
.8f6d	74 01		stz $01,x	                stz 1,x
.8f6f	60		rts		z_false:        rts
.8f70					xt_fetch:
.8f70	20 4a d6	jsr $d64a	                jsr underflow_1
.8f73	a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f75	a8		tay		                tay
.8f76	f6 00		inc $00,x	                inc 0,x
.8f78	d0 02		bne $8f7c	                bne +
.8f7a	f6 01		inc $01,x	                inc 1,x
.8f7c					+
.8f7c	a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f7e	95 01		sta $01,x	                sta 1,x
.8f80	94 00		sty $00,x	                sty 0,x
.8f82	60		rts		z_fetch:        rts
.8f83					xt_find:
.8f83	20 4a d6	jsr $d64a	                jsr underflow_1
.8f86	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f88	48		pha		                pha
.8f89	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f8b	48		pha		                pha
.8f8c	20 3f 89	jsr $893f	                jsr xt_count            ; ( caddr -- addr u )
.8f8f	20 cb 8f	jsr $8fcb	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f92	b5 00		lda $00,x	                lda 0,x
.8f94	15 01		ora $01,x	                ora 1,x
.8f96	d0 0b		bne $8fa3	                bne _found_word
.8f98	20 69 8f	jsr $8f69	                jsr xt_false            ; ( 0 0 )
.8f9b	68		pla		                pla                     ; LSB of address
.8f9c	95 02		sta $02,x	                sta 2,x
.8f9e	68		pla		                pla
.8f9f	95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8fa1	80 27		bra $8fca	                bra _done               ; ( addr 0 )
.8fa3					_found_word:
.8fa3	68		pla		                pla
.8fa4	68		pla		                pla
.8fa5	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( nt nt )
.8fa8	20 d1 95	jsr $95d1	                jsr xt_name_to_int      ; ( nt xt )
.8fab	20 89 a1	jsr $a189	                jsr xt_swap             ; ( xt nt )
.8fae	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fb0	f6 00		inc $00,x	                inc 0,x
.8fb2	d0 02		bne $8fb6	                bne +
.8fb4	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fb6					+
.8fb6	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fb8	29 04		and #$04	                and #IM
.8fba	d0 08		bne $8fc4	                bne _immediate          ; bit set, we're immediate
.8fbc	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8fbe	95 00		sta $00,x	                sta 0,x
.8fc0	95 01		sta $01,x	                sta 1,x
.8fc2	80 06		bra $8fca	                bra _done
.8fc4					_immediate:
.8fc4	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8fc6	95 00		sta $00,x	                sta 0,x
.8fc8	74 01		stz $01,x	                stz 1,x
.8fca					_done:
.8fca	60		rts		z_find:         rts
.8fcb					xt_find_name:
.8fcb	20 4f d6	jsr $d64f	                jsr underflow_2
.8fce	b5 00		lda $00,x	                lda 0,x
.8fd0	15 01		ora $01,x	                ora 1,x
.8fd2	d0 03		bne $8fd7	                bne _nonempty
.8fd4	4c 70 90	jmp $9070	                jmp _fail_done
.8fd7					_nonempty:
.8fd7	64 28		stz $28		                stz tmp3                ; Start at the beginning
.8fd9					_wordlist_loop:
.8fd9	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8fdb	a5 28		lda $28		                lda tmp3
.8fdd	d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8fdf	d0 03		bne $8fe4	                bne _have_string
.8fe1	4c 70 90	jmp $9070	                jmp _fail_done
.8fe4					_have_string:
.8fe4	18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8fe5	69 1f		adc #$1f	                adc #search_order_offset
.8fe7	a8		tay		                tay
.8fe8	b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.8fea	0a		asl a		                asl                     ; Turn offset into cells offset.
.8feb	18		clc		                clc
.8fec	69 06		adc #$06	                adc #wordlists_offset
.8fee	a8		tay		                tay
.8fef	b1 1e		lda ($1e),y	                lda (up),y
.8ff1	85 24		sta $24		                sta tmp1
.8ff3	c8		iny		                iny
.8ff4	b1 1e		lda ($1e),y	                lda (up),y
.8ff6	85 25		sta $25		                sta tmp1+1
.8ff8	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.8ffa	85 26		sta $26		                sta tmp2
.8ffc	b5 03		lda $03,x	                lda 3,x
.8ffe	85 27		sta $27		                sta tmp2+1
.9000					_loop:
.9000	b2 24		lda ($24)	                lda (tmp1)
.9002	d5 00		cmp $00,x	                cmp 0,x
.9004	d0 54		bne $905a	                bne _next_entry
.9006					_compare_string:
.9006	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9008	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.900a	b0 07		bcs $9013	                bcs _compare_first
.900c	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.900e	90 03		bcc $9013	                bcc _compare_first
.9010	18		clc		                clc
.9011	69 20		adc #$20	                adc #$20
.9013					_compare_first:
.9013	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9015	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9017	d0 41		bne $905a	                bne _next_entry
.9019	b5 00		lda $00,x	                lda 0,x
.901b	3a		dec a		                dea
.901c	f0 2c		beq $904a	                beq _success
.901e	a5 24		lda $24		                lda tmp1
.9020	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9021	18		clc		                clc
.9022	69 08		adc #$08	                adc #8
.9024	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9026	a5 25		lda $25		                lda tmp1+1
.9028	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9029	69 00		adc #$00	                adc #0          ; we only need the carry
.902b	85 25		sta $25		                sta tmp1+1
.902d	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.902f	88		dey		                dey
.9030					_string_loop:
.9030	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9032	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9034	b0 07		bcs $903d	                bcs _check_char
.9036	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9038	90 03		bcc $903d	                bcc _check_char
.903a	18		clc		                clc
.903b	69 20		adc #$20	                adc #$20
.903d					_check_char:
.903d	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.903f	d0 13		bne $9054	                bne _next_entry_tmp1
.9041	88		dey		                dey
.9042	d0 ec		bne $9030	                bne _string_loop
.9044					_success_tmp1:
.9044	68		pla		                pla             ; Restore tmp1 from the return stack.
.9045	85 25		sta $25		                sta tmp1+1
.9047	68		pla		                pla
.9048	85 24		sta $24		                sta tmp1
.904a					_success:
.904a	a5 24		lda $24		                lda tmp1
.904c	95 02		sta $02,x	                sta 2,x
.904e	a5 25		lda $25		                lda tmp1+1
.9050	95 03		sta $03,x	                sta 3,x
.9052	80 20		bra $9074	                bra _done
.9054					_next_entry_tmp1:
.9054	68		pla		                pla             ; Restore tmp1 from the return stack.
.9055	85 25		sta $25		                sta tmp1+1
.9057	68		pla		                pla
.9058	85 24		sta $24		                sta tmp1
.905a					_next_entry:
.905a	a0 02		ldy #$02	                ldy #2
.905c	b1 24		lda ($24),y	                lda (tmp1),y
.905e	48		pha		                pha
.905f	c8		iny		                iny
.9060	b1 24		lda ($24),y	                lda (tmp1),y
.9062	85 25		sta $25		                sta tmp1+1
.9064	68		pla		                pla
.9065	85 24		sta $24		                sta tmp1
.9067	05 25		ora $25		                ora tmp1+1
.9069	d0 95		bne $9000	                bne _loop
.906b	e6 28		inc $28		                inc tmp3
.906d	4c d9 8f	jmp $8fd9	                jmp _wordlist_loop
.9070					_fail_done:
.9070	74 02		stz $02,x	                stz 2,x         ; failure flag
.9072	74 03		stz $03,x	                stz 3,x
.9074					_done:
.9074	e8		inx		                inx
.9075	e8		inx		                inx
.9076	60		rts		z_find_name:    rts
.9077					xt_flush:
.9077	20 9f 9e	jsr $9e9f	                jsr xt_save_buffers
.907a	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.907c	a9 00		lda #$00	                lda #0
.907e	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.9080					z_flush:
.9080	60		rts		                rts
.9081					xt_fm_slash_mod:
.9081	20 54 d6	jsr $d654	                jsr underflow_3
.9084	64 26		stz $26		                stz tmp2        ; default: n is positive
.9086	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9088	10 0e		bpl $9098	                bpl _check_d
.908a	e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.908c	20 13 96	jsr $9613	                jsr xt_negate   ; NEGATE
.908f	20 4b a3	jsr $a34b	                jsr xt_to_r     ; >R
.9092	20 31 8b	jsr $8b31	                jsr xt_dnegate  ; DNEGATE
.9095	20 73 9a	jsr $9a73	                jsr xt_r_from   ; R>
.9098					_check_d:
.9098	b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.909a	10 0d		bpl $90a9	                bpl _multiply
.909c	18		clc		                clc
.909d	b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.909f	75 02		adc $02,x	                adc 2,x         ; LSB of dh
.90a1	95 02		sta $02,x	                sta 2,x
.90a3	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90a5	75 03		adc $03,x	                adc 3,x         ; MSB of dh
.90a7	95 03		sta $03,x	                sta 3,x
.90a9					_multiply:
.90a9	20 95 a5	jsr $a595	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90ac	a5 26		lda $26		                lda tmp2
.90ae	f0 07		beq $90b7	                beq _done
.90b0	e8		inx		                inx             ; pretend that we SWAP
.90b1	e8		inx		                inx
.90b2	20 13 96	jsr $9613	                jsr xt_negate
.90b5	ca		dex		                dex
.90b6	ca		dex		                dex
.90b7					_done:
.90b7	60		rts		z_fm_slash_mod: rts
.90b8					xt_forth:
.90b8	a0 1f		ldy #$1f	                ldy #search_order_offset
.90ba	a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90bc	91 1e		sta ($1e),y	                sta (up),y
.90be					z_forth:
.90be	60		rts		                rts
.90bf					load_evaluate:
.90bf	a9 ff		lda #$ff	                lda #$FF
.90c1	85 24		sta $24		                sta tmp1
.90c3	80 11		bra $90d6	                bra load_evaluate_start
.90c5					xt_evaluate:
.90c5	20 4f d6	jsr $d64f	                jsr underflow_2
.90c8	64 24		stz $24		                stz tmp1
.90ca	b5 00		lda $00,x	                lda 0,x
.90cc	15 01		ora $01,x	                ora 1,x
.90ce	d0 06		bne $90d6	                bne evaluate_got_work
.90d0	e8		inx		                inx
.90d1	e8		inx		                inx
.90d2	e8		inx		                inx
.90d3	e8		inx		                inx
.90d4	80 42		bra $9118	                bra evaluate_done
.90d6					load_evaluate_start:
.90d6					evaluate_got_work:
.90d6	a0 01		ldy #$01	                ldy #blk_offset+1
.90d8	b1 1e		lda ($1e),y	                lda (up),y
.90da	48		pha		                pha
.90db	88		dey		                dey
.90dc	b1 1e		lda ($1e),y	                lda (up),y
.90de	48		pha		                pha
.90df	a5 24		lda $24		                lda tmp1
.90e1	d0 05		bne $90e8	                bne _nozero
.90e3	91 1e		sta ($1e),y	                sta (up),y
.90e5	c8		iny		                iny
.90e6	91 1e		sta ($1e),y	                sta (up),y
.90e8					_nozero:
.90e8	20 52 92	jsr $9252	                jsr xt_input_to_r
.90eb	a9 ff		lda #$ff	                lda #$ff
.90ed	85 06		sta $06		                sta insrc
.90ef	85 07		sta $07		                sta insrc+1
.90f1	64 0c		stz $0c		                stz toin
.90f3	64 0d		stz $0d		                stz toin+1
.90f5	b5 00		lda $00,x	                lda 0,x
.90f7	85 0a		sta $0a		                sta ciblen
.90f9	b5 01		lda $01,x	                lda 1,x
.90fb	85 0b		sta $0b		                sta ciblen+1
.90fd	b5 02		lda $02,x	                lda 2,x
.90ff	85 08		sta $08		                sta cib
.9101	b5 03		lda $03,x	                lda 3,x
.9103	85 09		sta $09		                sta cib+1
.9105	e8		inx		                inx             ; A clean stack is a clean mind
.9106	e8		inx		                inx
.9107	e8		inx		                inx
.9108	e8		inx		                inx
.9109	20 b2 d5	jsr $d5b2	                jsr interpret   ; ( -- )
.910c	20 84 9a	jsr $9a84	                jsr xt_r_to_input
.910f	a0 00		ldy #$00	                ldy #blk_offset
.9111	68		pla		                pla
.9112	91 1e		sta ($1e),y	                sta (up),y
.9114	c8		iny		                iny
.9115	68		pla		                pla
.9116	91 1e		sta ($1e),y	                sta (up),y
.9118					evaluate_done:
.9118	60		rts		z_evaluate:     rts
.9119					xt_get_current:
.9119	ca		dex		                dex
.911a	ca		dex		                dex
.911b	a0 04		ldy #$04	                ldy #current_offset
.911d	b1 1e		lda ($1e),y	                lda (up),y
.911f	95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.9121	74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.9123	60		rts		z_get_current:  rts
.9124					xt_get_order:
.9124	a0 1e		ldy #$1e	                ldy #num_order_offset
.9126	b1 1e		lda ($1e),y	                lda (up),y
.9128	85 24		sta $24		                sta tmp1
.912a	f0 16		beq $9142	                beq _done       ; If zero, there are no wordlists.
.912c					_loop:
.912c	c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.912e	a9 1f		lda #$1f	                lda #search_order_offset
.9130	18		clc		                clc
.9131	65 24		adc $24		                adc tmp1
.9133	a8		tay		                tay
.9134	ca		dex		                dex
.9135	ca		dex		                dex
.9136	b1 1e		lda ($1e),y	                lda (up),y
.9138	95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.913a	74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.913c	a9 00		lda #$00	                lda #0
.913e	c5 24		cmp $24		                cmp tmp1
.9140	d0 ea		bne $912c	                bne _loop
.9142					_done:
.9142	ca		dex		                dex
.9143	ca		dex		                dex
.9144	a0 1e		ldy #$1e	                ldy #num_order_offset
.9146	b1 1e		lda ($1e),y	                lda (up),y
.9148	95 00		sta $00,x	                sta 0,x
.914a	74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.914c	60		rts		z_get_order:    rts
.914d					xt_greater_than:
.914d	20 4f d6	jsr $d64f	                jsr underflow_2
.9150	a0 00		ldy #$00	                ldy #0          ; default false
.9152	20 71 d5	jsr $d571	                jsr compare_16bit
.9155	f0 03		beq $915a	                beq _false
.9157	10 01		bpl $915a	                bpl _false
.9159	88		dey		                dey
.915a					_false:
.915a	98		tya		                tya
.915b	e8		inx		                inx
.915c	e8		inx		                inx
.915d	95 00		sta $00,x	                sta 0,x
.915f	95 01		sta $01,x	                sta 1,x
.9161	60		rts		z_greater_than: rts
.9162					xt_here:
.9162					xt_asm_arrow:
.9162	ca		dex		                dex
.9163	ca		dex		                dex
.9164	a5 00		lda $00		                lda cp
.9166	95 00		sta $00,x	                sta 0,x
.9168	a5 01		lda $01		                lda cp+1
.916a	95 01		sta $01,x	                sta 1,x
.916c					z_asm_arrow:
.916c	60		rts		z_here:         rts
.916d					xt_hex:
.916d	a9 10		lda #$10	                lda #16
.916f	85 18		sta $18		                sta base
.9171	64 19		stz $19		                stz base+1              ; paranoid
.9173	60		rts		z_hex:          rts
.9174					xt_hexstore:
.9174	20 54 d6	jsr $d654	                jsr underflow_3
.9177	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; Save copy of original address
.917a	20 7d a4	jsr $a47d	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.917d					_loop:
.917d	b5 00		lda $00,x	                lda 0,x
.917f	15 01		ora $01,x	                ora 1,x
.9181	f0 36		beq $91b9	                beq _done
.9183	20 3c 86	jsr $863c	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9186	20 7d a4	jsr $a47d	                jsr xt_two_to_r
.9189	20 82 a7	jsr $a782	                jsr xt_zero
.918c	20 82 a7	jsr $a782	                jsr xt_zero
.918f	20 03 a4	jsr $a403	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9192	20 98 a2	jsr $a298	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9195	b5 00		lda $00,x	                lda 0,x
.9197	15 01		ora $01,x	                ora 1,x
.9199	d0 17		bne $91b2	                bne _have_chars_left
.919b	20 8b a3	jsr $a38b	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.919e	20 70 8a	jsr $8a70	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.91a1	20 5e 9a	jsr $9a5e	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.91a4	20 05 86	jsr $8605	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.91a7	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R>
.91aa	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+
.91ad	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91b0	80 cb		bra $917d	                bra _loop
.91b2					_have_chars_left:
.91b2	8a		txa		                txa
.91b3	18		clc		                clc
.91b4	69 08		adc #$08	                adc #8
.91b6	aa		tax		                tax
.91b7	80 c4		bra $917d	                bra _loop
.91b9					_done:
.91b9	e8		inx		                inx
.91ba	e8		inx		                inx
.91bb	e8		inx		                inx
.91bc	e8		inx		                inx                     ; 2DROP
.91bd	20 03 a4	jsr $a403	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91c0	20 89 a1	jsr $a189	                jsr xt_swap
.91c3	20 40 95	jsr $9540	                jsr xt_minus            ; ( n )
.91c6	60		rts		z_hexstore:     rts
.91c7					xt_hold:
.91c7	20 4a d6	jsr $d64a	                jsr underflow_1
.91ca	a5 34		lda $34		                lda tohold
.91cc	d0 02		bne $91d0	                bne +
.91ce	c6 35		dec $35		                dec tohold+1
.91d0					+
.91d0	c6 34		dec $34		                dec tohold
.91d2	b5 00		lda $00,x	                lda 0,x
.91d4	92 34		sta ($34)	                sta (tohold)
.91d6	e8		inx		                inx
.91d7	e8		inx		                inx
.91d8	60		rts		z_hold:         rts
.91d9					xt_i:
.91d9	ca		dex		                dex
.91da	ca		dex		                dex
.91db	86 2a		stx $2a		                stx tmpdsp
.91dd	ba		tsx		                tsx
.91de	38		sec		                sec
.91df	bd 01 01	lda $0101,x	                lda $0101,x     ; LSB
.91e2	fd 03 01	sbc $0103,x	                sbc $0103,x
.91e5	a8		tay		                tay
.91e6	bd 02 01	lda $0102,x	                lda $0102,x     ; MSB
.91e9	fd 04 01	sbc $0104,x	                sbc $0104,x
.91ec	a6 2a		ldx $2a		                ldx tmpdsp
.91ee	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.91f0	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.91f2	60		rts		z_i:            rts
.91f3					xt_if:
.91f3	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.91f5	a9 04		lda #$04	                lda #<zero_branch_runtime
.91f7	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.91fa	20 62 91	jsr $9162	                jsr xt_here
.91fd	20 82 a7	jsr $a782	                jsr xt_zero
.9200	20 5e 87	jsr $875e	                jsr xt_comma
.9203	60		rts		z_if:           rts
.9204					zero_branch_runtime:
.9204	68		pla		                pla
.9205	85 22		sta $22		                sta tmpbranch
.9207	68		pla		                pla
.9208	85 23		sta $23		                sta tmpbranch+1
.920a	b5 00		lda $00,x	                lda 0,x
.920c	15 01		ora $01,x	                ora 1,x
.920e	f0 0f		beq $921f	                beq _zero
.9210	a5 22		lda $22		                lda tmpbranch   ; LSB
.9212	18		clc		                clc
.9213	69 02		adc #$02	                adc #2
.9215	85 24		sta $24		                sta tmp1
.9217	a5 23		lda $23		                lda tmpbranch+1 ; MSB
.9219	69 00		adc #$00	                adc #0          ; For carry
.921b	85 25		sta $25		                sta tmp1+1
.921d	80 13		bra $9232	                bra _done
.921f					_zero:
.921f	a0 01		ldy #$01	                ldy #1
.9221	b1 22		lda ($22),y	                lda (tmpbranch),y
.9223	85 24		sta $24		                sta tmp1
.9225	c8		iny		                iny
.9226	b1 22		lda ($22),y	                lda (tmpbranch),y
.9228	85 25		sta $25		                sta tmp1+1
.922a	a5 24		lda $24		                lda tmp1
.922c	d0 02		bne $9230	                bne +
.922e	c6 25		dec $25		                dec tmp1+1
.9230					+
.9230	c6 24		dec $24		                dec tmp1
.9232					_done:
.9232	a5 25		lda $25		                lda tmp1+1
.9234	48		pha		                pha             ; MSB first
.9235	a5 24		lda $24		                lda tmp1
.9237	48		pha		                pha
.9238	e8		inx		                inx
.9239	e8		inx		                inx
.923a	60		rts		                rts
.923b					xt_immediate:
.923b	20 8c d5	jsr $d58c	                jsr current_to_dp
.923e	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9240	b1 02		lda ($02),y	                lda (dp),y
.9242	09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9244	91 02		sta ($02),y	                sta (dp),y
.9246	60		rts		z_immediate:    rts
.9247					xt_input:
.9247	ca		dex		                dex
.9248	ca		dex		                dex
.9249	a9 12		lda #$12	                lda #<input
.924b	95 00		sta $00,x	                sta 0,x
.924d	a9 00		lda #$00	                lda #>input
.924f	95 01		sta $01,x	                sta 1,x
.9251	60		rts		z_input:        rts
.9252					xt_input_to_r:
.9252	68		pla		                pla
.9253	85 24		sta $24		                sta tmp1
.9255	68		pla		                pla
.9256	85 25		sta $25		                sta tmp1+1
.9258	a0 07		ldy #$07	                ldy #7
.925a					_loop:
.925a	b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.925d	48		pha		                pha
.925e	88		dey		                dey
.925f	10 f9		bpl $925a	                bpl _loop
.9261	a5 25		lda $25		                lda tmp1+1
.9263	48		pha		                pha
.9264	a5 24		lda $24		                lda tmp1
.9266	48		pha		                pha
.9267	60		rts		z_input_to_r: 	rts
.9268					xt_int_to_name:
.9268	20 4a d6	jsr $d64a	                jsr underflow_1
.926b	ca		dex		                dex
.926c	ca		dex		                dex
.926d	74 00		stz $00,x	                stz 0,x
.926f	74 01		stz $01,x	                stz 1,x
.9271					_wordlist_loop:
.9271	b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9273	0a		asl a		                asl                     ; Turn offset into cells offset.
.9274	18		clc		                clc
.9275	69 06		adc #$06	                adc #wordlists_offset
.9277	a8		tay		                tay
.9278	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.927a	85 26		sta $26		                sta tmp2                ; into tmp2
.927c	c8		iny		                iny
.927d	b1 1e		lda ($1e),y	                lda (up),y
.927f	85 27		sta $27		                sta tmp2+1
.9281	a5 26		lda $26		                lda tmp2
.9283	05 27		ora $27		                ora tmp2+1
.9285	f0 38		beq $92bf	                beq _next_wordlist
.9287	b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9289	85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.928b	b5 03		lda $03,x	                lda 3,x
.928d	85 29		sta $29		                sta tmp3+1
.928f					_loop:
.928f	a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9291	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.9293	c5 28		cmp $28		                cmp tmp3
.9295	d0 07		bne $929e	                bne _no_match
.9297	c8		iny		                iny
.9298	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.929a	c5 29		cmp $29		                cmp tmp3+1
.929c	f0 32		beq $92d0	                beq _match
.929e					_no_match:
.929e	18		clc		                clc
.929f	a5 26		lda $26		                lda tmp2
.92a1	69 02		adc #$02	                adc #2
.92a3	85 26		sta $26		                sta tmp2
.92a5	a5 27		lda $27		                lda tmp2+1
.92a7	69 00		adc #$00	                adc #0          ; only care about carry
.92a9	85 27		sta $27		                sta tmp2+1
.92ab	a0 00		ldy #$00	                ldy #0
.92ad	b1 26		lda ($26),y	                lda (tmp2),y
.92af	48		pha		                pha
.92b0	c8		iny		                iny
.92b1	11 26		ora ($26),y	                ora (tmp2),y
.92b3	f0 09		beq $92be	                beq _zero
.92b5	b1 26		lda ($26),y	                lda (tmp2),y
.92b7	85 27		sta $27		                sta tmp2+1
.92b9	68		pla		                pla
.92ba	85 26		sta $26		                sta tmp2
.92bc	80 d1		bra $928f	                bra _loop
.92be					_zero:
.92be	68		pla		                pla             ; Leftover from above loop
.92bf					_next_wordlist:
.92bf	b5 00		lda $00,x	                lda 0,x
.92c1	1a		inc a		                ina
.92c2	95 00		sta $00,x	                sta 0,x
.92c4	c9 0c		cmp #$0c	                cmp #max_wordlists
.92c6	d0 a9		bne $9271	                bne _wordlist_loop
.92c8	e8		inx		                inx
.92c9	e8		inx		                inx
.92ca	74 00		stz $00,x	                stz 0,x
.92cc	74 01		stz $01,x	                stz 1,x
.92ce	80 0a		bra $92da	                bra z_int_to_name
.92d0					_match:
.92d0	e8		inx		                inx
.92d1	e8		inx		                inx
.92d2	a5 26		lda $26		                lda tmp2
.92d4	95 00		sta $00,x	                sta 0,x
.92d6	a5 27		lda $27		                lda tmp2+1
.92d8	95 01		sta $01,x	                sta 1,x
.92da	60		rts		z_int_to_name:  rts
.92db					xt_invert:
.92db	20 4a d6	jsr $d64a	                jsr underflow_1
.92de	a9 ff		lda #$ff	                lda #$FF
.92e0	55 00		eor $00,x	                eor 0,x         ; LSB
.92e2	95 00		sta $00,x	                sta 0,x
.92e4	a9 ff		lda #$ff	                lda #$FF
.92e6	55 01		eor $01,x	                eor 1,x         ; MSB
.92e8	95 01		sta $01,x	                sta 1,x
.92ea	60		rts		z_invert:       rts
.92eb					xt_is:
.92eb	a5 16		lda $16		                lda state
.92ed	05 17		ora $17		                ora state+1
.92ef	f0 0c		beq $92fd	                beq _interpreting
.92f1					_compiling:
.92f1	20 8e 85	jsr $858e	                jsr xt_bracket_tick
.92f4	a0 8a		ldy #$8a	                ldy #>xt_defer_store
.92f6	a9 d6		lda #$d6	                lda #<xt_defer_store
.92f8	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.92fb	80 06		bra $9303	                bra _done
.92fd					_interpreting:
.92fd	20 ec a1	jsr $a1ec	                jsr xt_tick
.9300	20 d6 8a	jsr $8ad6	                jsr xt_defer_store
.9303					_done:
.9303	60		rts		z_is:           rts
.9304					xt_j:
.9304	ca		dex		                dex
.9305	ca		dex		                dex
.9306	86 2a		stx $2a		                stx tmpdsp
.9308	ba		tsx		                tsx
.9309	38		sec		                sec
.930a	bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.930d	fd 09 01	sbc $0109,x	                sbc $0109,x
.9310	a8		tay		                tay
.9311	bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.9314	fd 0a 01	sbc $010a,x	                sbc $010A,x
.9317	a6 2a		ldx $2a		                ldx tmpdsp
.9319	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.931b	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.931d	60		rts		z_j:            rts
.931e					xt_key:
.931e	20 28 93	jsr $9328	                jsr key_a               ; returns char in A
.9321	ca		dex		                dex
.9322	ca		dex		                dex
.9323	95 00		sta $00,x	                sta 0,x
.9325	74 01		stz $01,x	                stz 1,x
.9327	60		rts		z_key:          rts
.9328					key_a:
.9328	6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.932b					xt_latestnt:
.932b	ca		dex		                dex
.932c	ca		dex		                dex
.932d	20 8c d5	jsr $d58c	                jsr current_to_dp
.9330	a5 02		lda $02		                lda dp
.9332	95 00		sta $00,x	                sta 0,x
.9334	a5 03		lda $03		                lda dp+1
.9336	95 01		sta $01,x	                sta 1,x
.9338	60		rts		z_latestnt:     rts
.9339					xt_latestxt:
.9339	20 2b 93	jsr $932b	                jsr xt_latestnt         ; ( nt )
.933c	20 d1 95	jsr $95d1	                jsr xt_name_to_int      ; ( xt )
.933f	60		rts		z_latestxt:     rts
.9340					xt_leave:
.9340	68		pla		                pla
.9341	68		pla		                pla
.9342	68		pla		                pla
.9343	68		pla		                pla
.9344	60		rts		                rts             ; this must be compiled, so keep before z_leave
.9345					z_leave:
.9345					xt_left_bracket:
.9345	64 16		stz $16		                stz state
.9347	64 17		stz $17		                stz state+1
.9349	60		rts		z_left_bracket: rts
.934a					xt_less_number_sign:
.934a	20 82 98	jsr $9882	                jsr xt_pad      ; ( addr )
.934d	b5 00		lda $00,x	                lda 0,x
.934f	85 34		sta $34		                sta tohold
.9351	b5 01		lda $01,x	                lda 1,x
.9353	85 35		sta $35		                sta tohold+1
.9355	e8		inx		                inx
.9356	e8		inx		                inx
.9357					z_less_number_sign:
.9357	60		rts		                rts
.9358					xt_less_than:
.9358	20 4f d6	jsr $d64f	                jsr underflow_2
.935b	a0 00		ldy #$00	                ldy #0          ; default false
.935d	20 71 d5	jsr $d571	                jsr compare_16bit
.9360	f0 03		beq $9365	                beq _false
.9362	30 01		bmi $9365	                bmi _false
.9364	88		dey		                dey
.9365					_false:
.9365	98		tya		                tya
.9366	e8		inx		                inx
.9367	e8		inx		                inx
.9368	95 00		sta $00,x	                sta 0,x
.936a	95 01		sta $01,x	                sta 1,x
.936c	60		rts		z_less_than:    rts
.936d					xt_list:
.936d	20 4a d6	jsr $d64a	                jsr underflow_1
.9370	20 ba 9e	jsr $9eba	                jsr xt_scr
.9373	20 68 a1	jsr $a168	                jsr xt_store
.9376	20 20 a8	jsr $a820	                jsr xt_editor_l
.9379	60		rts		z_list:         rts
.937a					xt_literal:
.937a	20 4a d6	jsr $d64a	                jsr underflow_1
.937d	a0 93		ldy #$93	                ldy #>literal_runtime
.937f	a9 88		lda #$88	                lda #<literal_runtime
.9381	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.9384	20 5e 87	jsr $875e	                jsr xt_comma
.9387	60		rts		z_literal:      rts
.9388					literal_runtime:
.9388	ca		dex		                dex
.9389	ca		dex		                dex
.938a	68		pla		                pla             ; LSB
.938b	85 24		sta $24		                sta tmp1
.938d	68		pla		                pla             ; MSB
.938e	85 25		sta $25		                sta tmp1+1
.9390	a0 01		ldy #$01	                ldy #1
.9392	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.9394	95 00		sta $00,x	                sta 0,x
.9396	c8		iny		                iny
.9397	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.9399	95 01		sta $01,x	                sta 1,x
.939b	98		tya		                tya
.939c	18		clc		                clc
.939d	65 24		adc $24		                adc tmp1
.939f	a8		tay		                tay
.93a0	a5 25		lda $25		                lda tmp1+1
.93a2	69 00		adc #$00	                adc #0
.93a4	48		pha		                pha
.93a5	5a		phy		                phy
.93a6	60		rts		                rts
.93a7					xt_load:
.93a7	20 4a d6	jsr $d64a	                jsr underflow_1
.93aa	a0 01		ldy #$01	                ldy #blk_offset+1
.93ac	b1 1e		lda ($1e),y	                lda (up),y
.93ae	48		pha		                pha
.93af	88		dey		                dey
.93b0	b1 1e		lda ($1e),y	                lda (up),y
.93b2	48		pha		                pha
.93b3	b5 00		lda $00,x	                lda 0,x
.93b5	91 1e		sta ($1e),y	                sta (up),y
.93b7	c8		iny		                iny
.93b8	b5 01		lda $01,x	                lda 1,x
.93ba	91 1e		sta ($1e),y	                sta (up),y
.93bc	20 b1 83	jsr $83b1	                jsr xt_block
.93bf	ca		dex		                dex
.93c0	ca		dex		                dex
.93c1	a9 04		lda #$04	                lda #4
.93c3	95 01		sta $01,x	                sta 1,x
.93c5	74 00		stz $00,x	                stz 0,x
.93c7	20 bf 90	jsr $90bf	                jsr load_evaluate
.93ca	a0 00		ldy #$00	                ldy #blk_offset
.93cc	68		pla		                pla
.93cd	91 1e		sta ($1e),y	                sta (up),y
.93cf	c8		iny		                iny
.93d0	68		pla		                pla
.93d1	91 1e		sta ($1e),y	                sta (up),y
.93d3	88		dey		                dey
.93d4	11 1e		ora ($1e),y	                ora (up),y
.93d6	f0 12		beq $93ea	                beq _done
.93d8	ca		dex		                dex
.93d9	ca		dex		                dex
.93da	a0 00		ldy #$00	                ldy #blk_offset
.93dc	b1 1e		lda ($1e),y	                lda (up),y
.93de	95 00		sta $00,x	                sta 0,x
.93e0	c8		iny		                iny
.93e1	b1 1e		lda ($1e),y	                lda (up),y
.93e3	95 01		sta $01,x	                sta 1,x
.93e5	20 b1 83	jsr $83b1	                jsr xt_block
.93e8	e8		inx		                inx
.93e9	e8		inx		                inx
.93ea					_done:
.93ea	60		rts		z_load:         rts
.93eb					xt_loop:
.93eb	a0 97		ldy #$97	                ldy #>xt_one
.93ed	a9 e9		lda #$e9	                lda #<xt_one
.93ef	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine     ; drop through to +LOOP
.93f2					xt_plus_loop:
.93f2	a0 11		ldy #$11	                ldy #plus_loop_runtime_end-plus_loop_runtime
.93f4	5a		phy		                phy             ; save counter to adjust CP
.93f5					-
.93f5	b9 59 94	lda $9459,y	                lda plus_loop_runtime,y
.93f8	91 00		sta ($00),y	                sta (cp),y
.93fa	88		dey		                dey
.93fb	10 f8		bpl $93f5	                bpl -
.93fd	68		pla		                pla
.93fe	18		clc		                clc
.93ff	65 00		adc $00		                adc cp
.9401	85 00		sta $00		                sta cp
.9403	a5 01		lda $01		                lda cp+1
.9405	69 00		adc #$00	                adc #0          ; only need carry
.9407	85 01		sta $01		                sta cp+1
.9409	20 5e 87	jsr $875e	                jsr xt_comma
.940c	a9 68		lda #$68	                lda #$68                ; opcode for PLA
.940e	a0 06		ldy #$06	                ldy #6
.9410					-
.9410	91 00		sta ($00),y	                sta (cp),y
.9412	88		dey		                dey
.9413	10 fb		bpl $9410	                bpl -
.9415	a9 06		lda #$06	                lda #6
.9417	18		clc		                clc
.9418	65 00		adc $00		                adc cp
.941a	85 00		sta $00		                sta cp
.941c	a5 01		lda $01		                lda cp+1
.941e	69 00		adc #$00	                adc #0                  ; only need carry
.9420	85 01		sta $01		                sta cp+1
.9422	b5 00		lda $00,x	                lda 0,x
.9424	85 24		sta $24		                sta tmp1
.9426	b5 01		lda $01,x	                lda 1,x
.9428	85 25		sta $25		                sta tmp1+1
.942a	e8		inx		                inx
.942b	e8		inx		                inx
.942c	a5 00		lda $00		                lda cp
.942e	38		sec		                sec
.942f	e9 01		sbc #$01	                sbc #1
.9431	85 26		sta $26		                sta tmp2
.9433	a5 01		lda $01		                lda cp+1
.9435	e9 00		sbc #$00	                sbc #0
.9437	85 27		sta $27		                sta tmp2+1
.9439	a0 00		ldy #$00	                ldy #0
.943b	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.943d	91 24		sta ($24),y	                sta (tmp1),y
.943f	c8		iny		                iny
.9440	a5 27		lda $27		                lda tmp2+1      ; MSB
.9442	91 24		sta ($24),y	                sta (tmp1),y
.9444	c8		iny		                iny
.9445	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9447	91 24		sta ($24),y	                sta (tmp1),y
.9449	c8		iny		                iny
.944a	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.944c	91 24		sta ($24),y	                sta (tmp1),y
.944e	c8		iny		                iny
.944f	a5 26		lda $26		                lda tmp2        ; LSB
.9451	91 24		sta ($24),y	                sta (tmp1),y
.9453	c8		iny		                iny
.9454	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9456	91 24		sta ($24),y	                sta (tmp1),y
.9458					z_loop:
.9458	60		rts		z_plus_loop:    rts
.9459					plus_loop_runtime:
.9459	18		clc		                clc
.945a	68		pla		                pla             ; LSB of index
.945b	75 00		adc $00,x	                adc 0,x         ; LSB of step
.945d	a8		tay		                tay             ; temporary storage of LSB
.945e	b8		clv		                clv
.945f	68		pla		                pla             ; MSB of index
.9460	75 01		adc $01,x	                adc 1,x         ; MSB of step
.9462	48		pha		                pha             ; put MSB of index back on stack
.9463	98		tya		                tya             ; put LSB of index back on stack
.9464	48		pha		                pha
.9465	e8		inx		                inx             ; dump step from TOS
.9466	e8		inx		                inx
.9467	70 03		bvs $946c	                bvs _hack+3     ; skip over JMP instruction
.9469					_hack:
>9469	4c				                .byte $4C
.946a					plus_loop_runtime_end:
.946a					xt_lshift:
.946a	20 4f d6	jsr $d64f	                jsr underflow_2
.946d	b5 00		lda $00,x	                lda 0,x
.946f	29 0f		and #$0f	                and #%00001111
.9471	f0 08		beq $947b	                beq _done
.9473	a8		tay		                tay
.9474					_loop:
.9474	16 02		asl $02,x	                asl 2,x
.9476	36 03		rol $03,x	                rol 3,x
.9478	88		dey		                dey
.9479	d0 f9		bne $9474	                bne _loop
.947b					_done:
.947b	e8		inx		                inx
.947c	e8		inx		                inx
.947d	60		rts		z_lshift:       rts
.947e					xt_m_star:
.947e	20 4f d6	jsr $d64f	                jsr underflow_2
.9481	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9483	55 03		eor $03,x	                eor 3,x         ; MSB of n2
.9485	48		pha		                pha
.9486	20 39 81	jsr $8139	                jsr xt_abs
.9489	20 89 a1	jsr $a189	                jsr xt_swap
.948c	20 39 81	jsr $8139	                jsr xt_abs
.948f	20 d7 a5	jsr $a5d7	                jsr xt_um_star          ; ( d )
.9492	68		pla		                pla
.9493	10 03		bpl $9498	                bpl _done
.9495	20 31 8b	jsr $8b31	                jsr xt_dnegate
.9498					_done:
.9498	60		rts		z_m_star:       rts
.9499					xt_marker:
.9499	20 8c d5	jsr $d58c	                jsr current_to_dp
.949c	a5 02		lda $02		                lda dp
.949e	48		pha		                pha
.949f	a5 03		lda $03		                lda dp+1
.94a1	48		pha		                pha
.94a2	a5 00		lda $00		                lda cp
.94a4	48		pha		                pha
.94a5	a5 01		lda $01		                lda cp+1
.94a7	48		pha		                pha
.94a8	20 59 89	jsr $8959	                jsr xt_create
.94ab	a5 00		lda $00		                lda cp          ; LSB
.94ad	38		sec		                sec
.94ae	e9 02		sbc #$02	                sbc #2
.94b0	85 00		sta $00		                sta cp
.94b2	a5 01		lda $01		                lda cp+1        ; MSB
.94b4	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94b6	85 01		sta $01		                sta cp+1
.94b8	a0 94		ldy #$94	                ldy #>marker_runtime
.94ba	a9 d7		lda #$d7	                lda #<marker_runtime
.94bc	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.94bf	7a		ply		                ply                     ; MSB
.94c0	68		pla		                pla                     ; LSB
.94c1	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.94c4	7a		ply		                ply                     ; MSB
.94c5	68		pla		                pla                     ; LSB
.94c6	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.94c9	a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94cb					_marker_loop:
.94cb	b1 1e		lda ($1e),y	                lda (up),y
.94cd	20 fd d4	jsr $d4fd	                jsr cmpl_a
.94d0	c8		iny		                iny
.94d1	98		tya		                tya
.94d2	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94d4	d0 f5		bne $94cb	                bne _marker_loop
.94d6	60		rts		z_marker:       rts
.94d7					marker_runtime:
.94d7	68		pla		                pla
.94d8	85 24		sta $24		                sta tmp1        ; LSB of address
.94da	68		pla		                pla
.94db	85 25		sta $25		                sta tmp1+1      ; MSB of address
.94dd	e6 24		inc $24		                inc tmp1
.94df	d0 02		bne $94e3	                bne +
.94e1	e6 25		inc $25		                inc tmp1+1
.94e3					+
.94e3	a0 00		ldy #$00	                ldy #0
.94e5	b1 24		lda ($24),y	                lda (tmp1),y
.94e7	85 00		sta $00		                sta cp
.94e9	c8		iny		                iny
.94ea	b1 24		lda ($24),y	                lda (tmp1),y
.94ec	85 01		sta $01		                sta cp+1
.94ee	c8		iny		                iny
.94ef	b1 24		lda ($24),y	                lda (tmp1),y
.94f1	85 02		sta $02		                sta dp
.94f3	c8		iny		                iny
.94f4	b1 24		lda ($24),y	                lda (tmp1),y
.94f6	85 03		sta $03		                sta dp+1
.94f8	a0 04		ldy #$04	                ldy #4
.94fa					_marker_restore_loop:
.94fa	b1 24		lda ($24),y	                lda (tmp1), y
.94fc	91 1e		sta ($1e),y	                sta (up), y
.94fe	c8		iny		                iny
.94ff	98		tya		                tya
.9500	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.9502	d0 f6		bne $94fa	                bne _marker_restore_loop
.9504	20 9f d5	jsr $d59f	                jsr dp_to_current       ; Move the CURRENT DP back.
.9507	60		rts		                rts
.9508					xt_max:
.9508	20 4f d6	jsr $d64f	                jsr underflow_2
.950b	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.950d	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.950f	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9511	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9513	50 02		bvc $9517	                bvc _no_overflow
.9515	49 80		eor #$80	                eor #$80        ; complement negative flag
.9517					_no_overflow:
.9517	30 08		bmi $9521	                bmi _keep_nos
.9519	b5 00		lda $00,x	                lda 0,x
.951b	95 02		sta $02,x	                sta 2,x
.951d	b5 01		lda $01,x	                lda 1,x
.951f	95 03		sta $03,x	                sta 3,x
.9521					_keep_nos:
.9521	e8		inx		                inx
.9522	e8		inx		                inx
.9523	60		rts		z_max:          rts
.9524					xt_min:
.9524	20 4f d6	jsr $d64f	                jsr underflow_2
.9527	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9529	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.952b	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.952d	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.952f	50 02		bvc $9533	                bvc _no_overflow
.9531	49 80		eor #$80	                eor #$80
.9533					_no_overflow:
.9533	10 08		bpl $953d	                bpl _keep_nos
.9535	b5 00		lda $00,x	                lda 0,x
.9537	95 02		sta $02,x	                sta 2,x
.9539	b5 01		lda $01,x	                lda 1,x
.953b	95 03		sta $03,x	                sta 3,x
.953d					_keep_nos:
.953d	e8		inx		                inx
.953e	e8		inx		                inx
.953f	60		rts		z_min:          rts
.9540					xt_minus:
.9540	20 4f d6	jsr $d64f	                jsr underflow_2
.9543	38		sec		                sec
.9544	b5 02		lda $02,x	                lda 2,x         ; LSB
.9546	f5 00		sbc $00,x	                sbc 0,x
.9548	95 02		sta $02,x	                sta 2,x
.954a	b5 03		lda $03,x	                lda 3,x         ; MSB
.954c	f5 01		sbc $01,x	                sbc 1,x
.954e	95 03		sta $03,x	                sta 3,x
.9550	e8		inx		                inx
.9551	e8		inx		                inx
.9552	60		rts		z_minus:        rts
.9553					xt_minus_leading:
.9553	20 4f d6	jsr $d64f	                jsr underflow_2
.9556					_loop:
.9556	b5 00		lda $00,x	                lda 0,x
.9558	15 01		ora $01,x	                ora 1,x
.955a	f0 0f		beq $956b	                beq _done
.955c	a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.955e	20 3d d6	jsr $d63d	                jsr is_whitespace
.9561	90 08		bcc $956b	                bcc _done
.9563	20 e9 97	jsr $97e9	                jsr xt_one              ; ( addr u 1 )
.9566	20 fa 9f	jsr $9ffa	                jsr xt_slash_string     ; ( addr+ u-1 )
.9569	80 eb		bra $9556	                bra _loop
.956b					_done:
.956b					z_minus_leading:
.956b	60		rts		                rts
.956c					xt_minus_trailing:
.956c	20 4f d6	jsr $d64f	                jsr underflow_2
.956f	b5 00		lda $00,x	                lda 0,x         ; LSB of n
.9571	15 01		ora $01,x	                ora 1,x         ; MSB of n
.9573	f0 33		beq $95a8	                beq _done
.9575	18		clc		                clc
.9576	b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.9578	75 00		adc $00,x	                adc 0,x
.957a	85 24		sta $24		                sta tmp1
.957c	b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.957e	75 01		adc $01,x	                adc 1,x
.9580	85 25		sta $25		                sta tmp1+1
.9582	a5 24		lda $24		                lda tmp1
.9584	d0 02		bne $9588	                bne +
.9586	c6 25		dec $25		                dec tmp1+1
.9588					+
.9588	c6 24		dec $24		                dec tmp1
.958a					_loop:
.958a	b2 24		lda ($24)	                lda (tmp1)
.958c	c9 20		cmp #$20	                cmp #AscSP
.958e	d0 18		bne $95a8	                bne _done
.9590	a5 24		lda $24		                lda tmp1
.9592	d0 02		bne $9596	                bne +
.9594	c6 25		dec $25		                dec tmp1+1
.9596					+
.9596	c6 24		dec $24		                dec tmp1
.9598	b5 00		lda $00,x	                lda 0,x
.959a	d0 02		bne $959e	                bne +
.959c	d6 01		dec $01,x	                dec 1,x
.959e					+
.959e	d6 00		dec $00,x	                dec 0,x
.95a0	b5 00		lda $00,x	                lda 0,x
.95a2	15 01		ora $01,x	                ora 1,x
.95a4	f0 02		beq $95a8	                beq _done       ; Count has reached zero - we're done!
.95a6	80 e2		bra $958a	                bra _loop
.95a8					_done:
.95a8					z_minus_trailing:
.95a8	60		rts		                rts
.95a9					xt_mod:
.95a9	20 4f d6	jsr $d64f	                jsr underflow_2
.95ac	20 e2 9f	jsr $9fe2	                jsr xt_slash_mod
.95af	e8		inx		                inx             ; DROP
.95b0	e8		inx		                inx
.95b1					z_mod:
.95b1	60		rts		                rts
.95b2					xt_move:
.95b2	b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95b4	d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95b6	f0 05		beq $95bd	                beq _lsb                ; wasn't helpful, move to LSB
.95b8	b0 0e		bcs $95c8	                bcs _to_move_up         ; we want CMOVE>
.95ba	4c 89 86	jmp $8689	                jmp xt_cmove            ; JSR/RTS
.95bd					_lsb:
.95bd	b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95bf	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95c1	f0 08		beq $95cb	                beq _equal              ; LSB is equal as well
.95c3	b0 03		bcs $95c8	                bcs _to_move_up         ; we want CMOVE>
.95c5	4c 89 86	jmp $8689	                jmp xt_cmove            ; JSR/RTS
.95c8					_to_move_up:
.95c8	4c c4 86	jmp $86c4	                jmp xt_cmove_up         ; JSR/RTS
.95cb					_equal:
.95cb	8a		txa		                txa
.95cc	18		clc		                clc
.95cd	69 06		adc #$06	                adc #6
.95cf	aa		tax		                tax
.95d0	60		rts		z_move:         rts
.95d1					xt_name_to_int:
.95d1	20 4a d6	jsr $d64a	                jsr underflow_1
.95d4	b5 00		lda $00,x	                lda 0,x
.95d6	18		clc		                clc
.95d7	69 04		adc #$04	                adc #4
.95d9	85 28		sta $28		                sta tmp3
.95db	b5 01		lda $01,x	                lda 1,x
.95dd	90 01		bcc $95e0	                bcc _done
.95df	1a		inc a		                ina
.95e0					_done:
.95e0	85 29		sta $29		                sta tmp3+1
.95e2	a0 00		ldy #$00	                ldy #0
.95e4	b1 28		lda ($28),y	                lda (tmp3),y
.95e6	95 00		sta $00,x	                sta 0,x
.95e8	c8		iny		                iny
.95e9	b1 28		lda ($28),y	                lda (tmp3),y
.95eb	95 01		sta $01,x	                sta 1,x
.95ed	60		rts		z_name_to_int:  rts
.95ee					xt_name_to_string:
.95ee	20 4a d6	jsr $d64a	                jsr underflow_1
.95f1	ca		dex		                dex
.95f2	ca		dex		                dex
.95f3	a1 02		lda ($02,x)	                lda (2,x)
.95f5	95 00		sta $00,x	                sta 0,x
.95f7	74 01		stz $01,x	                stz 1,x
.95f9	b5 02		lda $02,x	                lda 2,x         ; LSB
.95fb	18		clc		                clc
.95fc	69 08		adc #$08	                adc #8
.95fe	a8		tay		                tay
.95ff	b5 03		lda $03,x	                lda 3,x         ; MSB
.9601	69 00		adc #$00	                adc #0          ; just need carry
.9603	95 03		sta $03,x	                sta 3,x
.9605	94 02		sty $02,x	                sty 2,x
.9607					z_name_to_string:
.9607	60		rts		                rts
.9608					xt_nc_limit:
.9608	ca		dex		                dex
.9609	ca		dex		                dex
.960a	a9 1a		lda #$1a	                lda #<nc_limit
.960c	95 00		sta $00,x	                sta 0,x
.960e	a9 00		lda #$00	                lda #>nc_limit
.9610	95 01		sta $01,x	                sta 1,x
.9612	60		rts		z_nc_limit:     rts
.9613					xt_negate:
.9613	20 4a d6	jsr $d64a	                jsr underflow_1
.9616	a9 00		lda #$00	        	lda #0
.9618	38		sec		                sec
.9619	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.961b	95 00		sta $00,x	                sta 0,x
.961d	a9 00		lda #$00	                lda #0
.961f	f5 01		sbc $01,x	                sbc 1,x         ; MSB
.9621	95 01		sta $01,x	                sta 1,x
.9623	60		rts		z_negate:       rts
.9624					xt_never_native:
.9624	20 8c d5	jsr $d58c	                jsr current_to_dp
.9627	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9629	b1 02		lda ($02),y	                lda (dp),y
.962b	09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.962d	29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.962f	91 02		sta ($02),y	                sta (dp),y
.9631					z_never_native:
.9631	60		rts		                rts
.9632					xt_nip:
.9632	20 4f d6	jsr $d64f	                jsr underflow_2
.9635	b5 00		lda $00,x	                lda 0,x         ; LSB
.9637	95 02		sta $02,x	                sta 2,x
.9639	b5 01		lda $01,x	                lda 1,x         ; MSB
.963b	95 03		sta $03,x	                sta 3,x
.963d	e8		inx		                inx
.963e	e8		inx		                inx
.963f	60		rts		z_nip:          rts
.9640					xt_not_equals:
.9640	20 4f d6	jsr $d64f	                jsr underflow_2
.9643	a0 00		ldy #$00	                ldy #0                  ; default is true
.9645	b5 00		lda $00,x	                lda 0,x                 ; LSB
.9647	d5 02		cmp $02,x	                cmp 2,x
.9649	d0 0a		bne $9655	                bne _not_equal
.964b	b5 01		lda $01,x	                lda 1,x                 ; MSB
.964d	d5 03		cmp $03,x	                cmp 3,x
.964f	d0 04		bne $9655	                bne _not_equal
.9651	a9 ff		lda #$ff	                lda #$FF
.9653	80 01		bra $9656	                bra _done
.9655					_not_equal:
.9655	88		dey		                dey                     ; drop thru to done
.9656					_done:
.9656	98		tya		                tya
.9657	e8		inx		                inx
.9658	e8		inx		                inx
.9659	95 00		sta $00,x	                sta 0,x
.965b	95 01		sta $01,x	                sta 1,x
.965d	60		rts		z_not_equals:   rts
.965e					xt_not_rote:
.965e	20 54 d6	jsr $d654	                jsr underflow_3
.9661	b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9663	b5 03		lda $03,x	                lda 3,x
.9665	95 01		sta $01,x	                sta 1,x
.9667	b5 05		lda $05,x	                lda 5,x
.9669	95 03		sta $03,x	                sta 3,x
.966b	94 05		sty $05,x	                sty 5,x
.966d	b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.966f	b5 02		lda $02,x	                lda 2,x
.9671	95 00		sta $00,x	                sta 0,x
.9673	b5 04		lda $04,x	                lda 4,x
.9675	95 02		sta $02,x	                sta 2,x
.9677	94 04		sty $04,x	                sty 4,x
.9679	60		rts		z_not_rote:     rts
.967a					xt_number:
.967a	20 4f d6	jsr $d64f	                jsr underflow_2
.967d	64 2a		stz $2a		                stz tmpdsp      ; flag for double
.967f	64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.9681	a5 18		lda $18		                lda base
.9683	48		pha		                pha
.9684	a1 02		lda ($02,x)	                lda (2,x)
.9686					_check_dec:
.9686	c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.9688	d0 04		bne $968e	                bne _check_hex
.968a	a9 0a		lda #$0a	                lda #$0A
.968c	80 42		bra $96d0	                bra _base_changed
.968e					_check_hex:
.968e	c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.9690	d0 04		bne $9696	                bne _check_binary
.9692	a9 10		lda #$10	                lda #$10
.9694	80 3a		bra $96d0	                bra _base_changed
.9696					_check_binary:
.9696	c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.9698	d0 04		bne $969e	                bne _check_char
.969a	a9 02		lda #$02	                lda #$02
.969c	80 32		bra $96d0	                bra _base_changed
.969e					_check_char:
.969e	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96a0	d0 3a		bne $96dc	                bne _check_minus
.96a2	b5 00		lda $00,x	                lda 0,x         ; Get the length
.96a4	c9 03		cmp #$03	                cmp #$03
.96a6	d0 26		bne $96ce	                bne _not_a_char
.96a8	b5 01		lda $01,x	                lda 1,x
.96aa	d0 22		bne $96ce	                bne _not_a_char ; No compare needed to check for non-zero.
.96ac	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96ae	18		clc		                clc
.96af	69 02		adc #$02	                adc #2          ; length of string
.96b1	85 2c		sta $2c		                sta tmptos
.96b3	b5 03		lda $03,x	                lda 3,x
.96b5	69 00		adc #$00	                adc #0          ; only need carry
.96b7	85 2d		sta $2d		                sta tmptos+1
.96b9	b2 2c		lda ($2c)	                lda (tmptos)
.96bb	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96bd	d0 0f		bne $96ce	                bne _not_a_char
.96bf	f6 02		inc $02,x	                inc 2,x
.96c1	d0 02		bne $96c5	                bne +
.96c3	f6 03		inc $03,x	                inc 3,x
.96c5					+
.96c5	a1 02		lda ($02,x)	                lda (2,x)
.96c7	95 02		sta $02,x	                sta 2,x
.96c9	74 03		stz $03,x	                stz 3,x
.96cb	4c 57 97	jmp $9757	                jmp _single ; Single with drop the TOS for us.
.96ce					_not_a_char:
.96ce	80 5a		bra $972a	                bra _number_error
.96d0					_base_changed:
.96d0	85 18		sta $18		                sta base        ; Switch to the new base
.96d2	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96d4	d0 02		bne $96d8	                bne +
.96d6	f6 03		inc $03,x	                inc 3,x
.96d8					+
.96d8	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96da	a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96dc					_check_minus:
.96dc	c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96de	d0 0a		bne $96ea	                bne _check_dot
.96e0	c6 2b		dec $2b		                dec tmpdsp+1
.96e2	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96e4	d0 02		bne $96e8	                bne +
.96e6	f6 03		inc $03,x	                inc 3,x
.96e8					+
.96e8	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96ea					_check_dot:
.96ea	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96ec	18		clc		                clc
.96ed	75 00		adc $00,x	                adc 0,x         ; length of string
.96ef	85 2c		sta $2c		                sta tmptos
.96f1	b5 03		lda $03,x	                lda 3,x
.96f3	69 00		adc #$00	                adc #0          ; only need carry
.96f5	85 2d		sta $2d		                sta tmptos+1
.96f7	a5 2c		lda $2c		                lda tmptos
.96f9	d0 02		bne $96fd	                bne +
.96fb	c6 2d		dec $2d		                dec tmptos+1
.96fd					+
.96fd	c6 2c		dec $2c		                dec tmptos
.96ff	b2 2c		lda ($2c)	                lda (tmptos)
.9701	c9 2e		cmp #$2e	                cmp #'.'
.9703	d0 04		bne $9709	                bne _main
.9705	c6 2a		dec $2a		                dec tmpdsp
.9707	d6 00		dec $00,x	                dec 0,x
.9709					_main:
.9709	ca		dex		                dex
.970a	ca		dex		                dex
.970b	ca		dex		                dex
.970c	ca		dex		                dex
.970d	b5 04		lda $04,x	                lda 4,x         ; LSB of length
.970f	95 00		sta $00,x	                sta 0,x
.9711	74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9713	b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9715	95 02		sta $02,x	                sta 2,x
.9717	b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9719	95 03		sta $03,x	                sta 3,x
.971b	74 04		stz $04,x	                stz 4,x         ; clear space for ud
.971d	74 05		stz $05,x	                stz 5,x
.971f	74 06		stz $06,x	                stz 6,x
.9721	74 07		stz $07,x	                stz 7,x
.9723	20 98 a2	jsr $a298	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9726	b5 00		lda $00,x	                lda 0,x
.9728	f0 18		beq $9742	                beq _all_converted
.972a					_number_error:
.972a	a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.972c	20 e6 8d	jsr $8de6	                jsr emit_a
.972f	20 de a4	jsr $a4de	                jsr xt_type
.9732	a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.9734	20 e6 8d	jsr $8de6	                jsr emit_a
.9737	20 ff a0	jsr $a0ff	                jsr xt_space
.973a	68		pla		                pla
.973b	85 18		sta $18		                sta base
.973d	a9 08		lda #$08	                lda #err_syntax
.973f	4c 60 d6	jmp $d660	                jmp error
.9742					_all_converted:
.9742	e8		inx		                inx
.9743	e8		inx		                inx
.9744	e8		inx		                inx
.9745	e8		inx		                inx
.9746	a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9748	f0 0d		beq $9757	                beq _single
.974a	a9 20		lda #$20	                lda #%00100000
.974c	04 20		tsb $20		                tsb status
.974e	a5 2b		lda $2b		                lda tmpdsp+1
.9750	f0 12		beq $9764	                beq _done       ; no minus, all done
.9752	20 31 8b	jsr $8b31	                jsr xt_dnegate
.9755	80 0d		bra $9764	                bra _done
.9757					_single:
.9757	e8		inx		                inx
.9758	e8		inx		                inx
.9759	a9 20		lda #$20	                lda #%00100000
.975b	14 20		trb $20		                trb status
.975d	a5 2b		lda $2b		                lda tmpdsp+1
.975f	f0 03		beq $9764	                beq _done       ; no minus, all done
.9761	20 13 96	jsr $9613	                jsr xt_negate
.9764					_done:
.9764	68		pla		                pla
.9765	85 18		sta $18		                sta base
.9767	60		rts		z_number:       rts
.9768					xt_number_sign:
.9768	20 4f d6	jsr $d64f	                jsr underflow_2         ; double number
.976b	20 77 83	jsr $8377	                jsr xt_base
.976e	20 70 8f	jsr $8f70	                jsr xt_fetch            ; ( ud1 base )
.9771	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >r
.9774	20 82 a7	jsr $a782	                jsr xt_zero             ; 0
.9777	20 5e 9a	jsr $9a5e	                jsr xt_r_fetch          ; r@
.977a	20 95 a5	jsr $a595	                jsr xt_um_slash_mod     ; um/mod
.977d	20 38 9b	jsr $9b38	                jsr xt_rot              ; rot
.9780	20 38 9b	jsr $9b38	                jsr xt_rot              ; rot
.9783	20 73 9a	jsr $9a73	                jsr xt_r_from           ; r>
.9786	20 95 a5	jsr $a595	                jsr xt_um_slash_mod     ; um/mod
.9789	20 38 9b	jsr $9b38	                jsr xt_rot              ; rot
.978c	20 38 9b	jsr $9b38	                jsr xt_rot              ; ( ud rem )
.978f	b5 00		lda $00,x	                lda 0,x
.9791	a8		tay		                tay
.9792	b9 61 d2	lda $d261,y	                lda s_abc_upper,y
.9795	95 00		sta $00,x	                sta 0,x
.9797	74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.9799	20 c7 91	jsr $91c7	                jsr xt_hold
.979c					z_number_sign:
.979c	60		rts		                rts
.979d					xt_number_sign_greater:
.979d	20 4f d6	jsr $d64f	                jsr underflow_2         ; double number
.97a0	a5 34		lda $34		                lda tohold
.97a2	95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97a4	95 02		sta $02,x	                sta 2,x
.97a6	a5 35		lda $35		                lda tohold+1
.97a8	95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97aa	95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97ac	20 82 98	jsr $9882	                jsr xt_pad      ; ( addr addr pad )
.97af	38		sec		                sec
.97b0	b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97b2	f5 02		sbc $02,x	                sbc 2,x
.97b4	95 02		sta $02,x	                sta 2,x
.97b6	b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97b8	f5 03		sbc $03,x	                sbc 3,x
.97ba	95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97bc	e8		inx		                inx
.97bd	e8		inx		                inx
.97be					z_number_sign_greater:
.97be	60		rts		                rts
.97bf					xt_number_sign_s:
.97bf	20 4f d6	jsr $d64f	                jsr underflow_2
.97c2					_loop:
.97c2	20 68 97	jsr $9768	                jsr xt_number_sign
.97c5	b5 00		lda $00,x	                lda 0,x
.97c7	15 01		ora $01,x	                ora 1,x
.97c9	15 02		ora $02,x	                ora 2,x
.97cb	15 03		ora $03,x	                ora 3,x
.97cd	d0 f3		bne $97c2	                bne _loop
.97cf					z_number_sign_s:
.97cf	60		rts		                rts
.97d0					xt_of:
.97d0	a0 98		ldy #$98	                ldy #>xt_over
.97d2	a9 74		lda #$74	                lda #<xt_over
.97d4	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.97d7	a0 8e		ldy #$8e	                ldy #>xt_equal
.97d9	a9 be		lda #$be	                lda #<xt_equal
.97db	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.97de	20 f3 91	jsr $91f3	                jsr xt_if
.97e1	a0 8d		ldy #$8d	                ldy #>xt_drop
.97e3	a9 1e		lda #$1e	                lda #<xt_drop
.97e5	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.97e8	60		rts		z_of:           rts
.97e9					xt_editor_wordlist:
.97e9					xt_one:
.97e9	ca		dex		                dex
.97ea	ca		dex		                dex
.97eb	a9 01		lda #$01	                lda #1
.97ed	95 00		sta $00,x	                sta 0,x
.97ef	74 01		stz $01,x	                stz 1,x
.97f1					z_editor_wordlist:
.97f1					z_one:
.97f1	60		rts		                rts
.97f2					xt_one_minus:
.97f2	20 4a d6	jsr $d64a	                jsr underflow_1
.97f5	b5 00		lda $00,x	                lda 0,x
.97f7	d0 02		bne $97fb	                bne +
.97f9	d6 01		dec $01,x	                dec 1,x
.97fb					+
.97fb	d6 00		dec $00,x	                dec 0,x
.97fd	60		rts		z_one_minus:    rts
.97fe					xt_char_plus:
.97fe					xt_one_plus:
.97fe	20 4a d6	jsr $d64a	                jsr underflow_1
.9801	f6 00		inc $00,x	                inc 0,x
.9803	d0 02		bne $9807	                bne _done
.9805	f6 01		inc $01,x	                inc 1,x
.9807					_done:
.9807					z_char_plus:
.9807	60		rts		z_one_plus:     rts
.9808					xt_only:
.9808	ca		dex		                dex
.9809	ca		dex		                dex
.980a	a9 ff		lda #$ff	                lda #$FF
.980c	95 00		sta $00,x	                sta 0,x
.980e	95 01		sta $01,x	                sta 1,x
.9810	20 fc 9c	jsr $9cfc	                jsr xt_set_order
.9813	60		rts		z_only:         rts
.9814					xt_or:
.9814	20 4f d6	jsr $d64f	                jsr underflow_2
.9817	b5 00		lda $00,x	                lda 0,x
.9819	15 02		ora $02,x	                ora 2,x
.981b	95 02		sta $02,x	                sta 2,x
.981d	b5 01		lda $01,x	                lda 1,x
.981f	15 03		ora $03,x	                ora 3,x
.9821	95 03		sta $03,x	                sta 3,x
.9823	e8		inx		                inx
.9824	e8		inx		                inx
.9825	60		rts		z_or:           rts
.9826					xt_order:
.9826	20 53 89	jsr $8953	                jsr xt_cr
.9829	20 24 91	jsr $9124	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.982c	b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.982e	f0 1e		beq $984e	                beq _drop_done
.9830					_have_wordlists:
.9830	a8		tay		                tay
.9831					_loop:
.9831	e8		inx		                inx
.9832	e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.9833	b5 00		lda $00,x	                lda 0,x
.9835	5a		phy		                phy
.9836	20 51 98	jsr $9851	                jsr order_print_wid_string   ; internal helper function
.9839	7a		ply		                ply
.983a	88		dey		                dey
.983b	d0 f4		bne $9831	                bne _loop
.983d	20 ff a0	jsr $a0ff	                jsr xt_space
.9840	20 ff a0	jsr $a0ff	                jsr xt_space
.9843	20 19 91	jsr $9119	                jsr xt_get_current      ; ( wid )
.9846	b5 00		lda $00,x	                lda 0,x
.9848	20 51 98	jsr $9851	                jsr order_print_wid_string
.984b	20 53 89	jsr $8953	                jsr xt_cr
.984e					_drop_done:
.984e	e8		inx		                inx
.984f	e8		inx		                inx
.9850					z_order:
.9850	60		rts		                rts
.9851					order_print_wid_string:
.9851	c9 04		cmp #$04	                cmp #4
.9853	90 09		bcc $985e	                bcc _output_string      ; less than 4, print a real string
.9855	ca		dex		                dex
.9856	ca		dex		                dex
.9857	95 00		sta $00,x	                sta 0,x
.9859	74 01		stz $01,x	                stz 1,x
.985b	4c 09 a5	jmp $a509	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.985e					_output_string:
.985e	a8		tay		                tay
.985f	b9 65 98	lda $9865,y	                lda _wid_data,y
.9862	4c 76 d6	jmp $d676	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.9865					_wid_data:
>9865	03				        .byte str_wid_forth            ; WID 0: "Forth"
>9866	06				        .byte str_wid_editor           ; WID 1: "Editor"
>9867	07				        .byte str_wid_assembler        ; WID 2: "Assembler"
>9868	08				        .byte str_wid_root             ; WID 3: "Root"
.9869					xt_output:
.9869	ca		dex		                dex
.986a	ca		dex		                dex
.986b	a9 10		lda #$10	                lda #<output
.986d	95 00		sta $00,x	                sta 0,x
.986f	a9 00		lda #$00	                lda #>output
.9871	95 01		sta $01,x	                sta 1,x
.9873	60		rts		z_output:       rts
.9874					xt_over:
.9874	20 4f d6	jsr $d64f	                jsr underflow_2
.9877	ca		dex		                dex
.9878	ca		dex		                dex
.9879	b5 04		lda $04,x	                lda 4,x         ; LSB
.987b	95 00		sta $00,x	                sta 0,x
.987d	b5 05		lda $05,x	                lda 5,x         ; MSB
.987f	95 01		sta $01,x	                sta 1,x
.9881	60		rts		z_over:         rts
.9882					xt_pad:
.9882	ca		dex		                dex
.9883	ca		dex		                dex
.9884	a5 00		lda $00		                lda cp
.9886	18		clc		                clc
.9887	69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.9889	95 00		sta $00,x	                sta 0,x
.988b	a5 01		lda $01		                lda cp+1
.988d	69 00		adc #$00	                adc #0          ; only need carry
.988f	95 01		sta $01,x	                sta 1,x
.9891	60		rts		z_pad:          rts
.9892					xt_page:
.9892	a9 1b		lda #$1b	                lda #AscESC
.9894	20 e6 8d	jsr $8de6	                jsr emit_a
.9897	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.9899	20 e6 8d	jsr $8de6	                jsr emit_a
.989c	a9 32		lda #$32	                lda #'2'
.989e	20 e6 8d	jsr $8de6	                jsr emit_a
.98a1	a9 4a		lda #$4a	                lda #'J'
.98a3	20 e6 8d	jsr $8de6	                jsr emit_a
.98a6	20 82 a7	jsr $a782	                jsr xt_zero
.98a9	20 82 a7	jsr $a782	                jsr xt_zero
.98ac	20 50 83	jsr $8350	                jsr xt_at_xy
.98af	60		rts		z_page:         rts
.98b0					xt_paren:
.98b0	ca		dex		                dex
.98b1	ca		dex		                dex
.98b2	a9 29		lda #$29	                lda #41     ; Right parenthesis
.98b4	95 00		sta $00,x	                sta 0,x
.98b6	74 01		stz $01,x	                stz 1,x
.98b8	20 1b 99	jsr $991b	                jsr xt_parse
.98bb	e8		inx		                inx
.98bc	e8		inx		                inx
.98bd	e8		inx		                inx
.98be	e8		inx		                inx
.98bf	60		rts		z_paren:        rts
.98c0					xt_parse_name:
.98c0	a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98c2	38		sec		                sec
.98c3	e5 0c		sbc $0c		                sbc toin
.98c5	85 24		sta $24		                sta tmp1
.98c7	a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98c9	e5 0d		sbc $0d		                sbc toin+1
.98cb	85 25		sta $25		                sta tmp1+1
.98cd	a5 24		lda $24		                lda tmp1
.98cf	05 25		ora $25		                ora tmp1+1
.98d1	f0 28		beq $98fb	                beq _empty_line
.98d3	a5 08		lda $08		                lda cib
.98d5	18		clc		                clc
.98d6	65 0c		adc $0c		                adc toin
.98d8	85 26		sta $26		                sta tmp2                ; LSB of first character
.98da	a5 09		lda $09		                lda cib+1
.98dc	65 0d		adc $0d		                adc toin+1
.98de	85 27		sta $27		                sta tmp2+1              ; MSB
.98e0					_skip_loop:
.98e0	b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.98e2	20 3d d6	jsr $d63d	                jsr is_whitespace
.98e5	90 1f		bcc $9906	                bcc _char_found
.98e7	e6 26		inc $26		                inc tmp2
.98e9	d0 02		bne $98ed	                bne +
.98eb	e6 27		inc $27		                inc tmp2+1
.98ed					+
.98ed	a5 24		lda $24		                lda tmp1
.98ef	d0 02		bne $98f3	                bne +
.98f1	c6 25		dec $25		                dec tmp1+1
.98f3	c6 24		dec $24		+               dec tmp1
.98f5	a5 24		lda $24		                lda tmp1
.98f7	05 25		ora $25		                ora tmp1+1
.98f9	d0 e5		bne $98e0	                bne _skip_loop          ; fall through if empty line
.98fb					_empty_line:
.98fb	ca		dex		                dex
.98fc	ca		dex		                dex
.98fd	ca		dex		                dex
.98fe	ca		dex		                dex
.98ff	74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.9901	74 01		stz $01,x	                stz 1,x
.9903	4c b2 99	jmp $99b2	                jmp z_parse_name        ; skip over PARSE
.9906					_char_found:
.9906	a5 26		lda $26		                lda tmp2
.9908	38		sec		                sec
.9909	e5 08		sbc $08		                sbc cib
.990b	85 0c		sta $0c		                sta toin
.990d	a5 27		lda $27		                lda tmp2+1
.990f	e5 09		sbc $09		                sbc cib+1
.9911	85 0d		sta $0d		                sta toin+1
.9913	ca		dex		                dex
.9914	ca		dex		                dex
.9915	a9 20		lda #$20	                lda #AscSP
.9917	95 00		sta $00,x	                sta 0,x
.9919	74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.991b					xt_parse:
.991b	20 4a d6	jsr $d64a	                jsr underflow_1
.991e	a5 0a		lda $0a		                lda ciblen
.9920	05 0b		ora $0b		                ora ciblen+1
.9922	f0 0c		beq $9930	                beq _abort_parse
.9924	a5 0d		lda $0d		                lda toin+1              ; MSB
.9926	c5 0b		cmp $0b		                cmp ciblen+1
.9928	90 0e		bcc $9938	                bcc _go_parse           ; unsigned comparison
.992a	a5 0c		lda $0c		                lda toin                ; LSB
.992c	c5 0a		cmp $0a		                cmp ciblen
.992e	90 08		bcc $9938	                bcc _go_parse
.9930					_abort_parse:
.9930	ca		dex		                dex
.9931	ca		dex		                dex
.9932	74 00		stz $00,x	                stz 0,x
.9934	74 01		stz $01,x	                stz 1,x
.9936	80 7a		bra $99b2	                bra _done
.9938					_go_parse:
.9938	b5 00		lda $00,x	                lda 0,x
.993a	85 2c		sta $2c		                sta tmptos
.993c	ca		dex		                dex
.993d	ca		dex		                dex
.993e	a5 08		lda $08		                lda cib
.9940	18		clc		                clc
.9941	65 0c		adc $0c		                adc toin        ; LSB
.9943	85 24		sta $24		                sta tmp1
.9945	85 26		sta $26		                sta tmp2
.9947	95 02		sta $02,x	                sta 2,x
.9949	a5 09		lda $09		                lda cib+1
.994b	65 0d		adc $0d		                adc toin+1      ; MSB
.994d	85 25		sta $25		                sta tmp1+1
.994f	85 27		sta $27		                sta tmp2+1
.9951	95 03		sta $03,x	                sta 3,x
.9953	a5 08		lda $08		                lda cib
.9955	18		clc		                clc
.9956	65 0a		adc $0a		                adc ciblen
.9958	85 28		sta $28		                sta tmp3
.995a	a5 09		lda $09		                lda cib+1
.995c	65 0b		adc $0b		                adc ciblen+1
.995e	85 29		sta $29		                sta tmp3+1
.9960	64 2d		stz $2d		                stz tmptos+1
.9962					_loop:
.9962	a5 26		lda $26		                lda tmp2
.9964	c5 28		cmp $28		                cmp tmp3
.9966	d0 06		bne $996e	                bne _not_empty
.9968	a5 27		lda $27		                lda tmp2+1
.996a	c5 29		cmp $29		                cmp tmp3+1
.996c	f0 1d		beq $998b	                beq _eol
.996e					_not_empty:
.996e	b2 26		lda ($26)	                lda (tmp2)
.9970	a4 2c		ldy $2c		                ldy tmptos
.9972	c0 20		cpy #$20	                cpy #AscSP
.9974	d0 07		bne $997d	                bne _not_whitespace
.9976	20 3d d6	jsr $d63d	                jsr is_whitespace
.9979	90 02		bcc $997d	                bcc _not_whitespace
.997b	80 0c		bra $9989	                bra _found_delimiter
.997d					_not_whitespace:
.997d	c5 2c		cmp $2c		                cmp tmptos
.997f	f0 08		beq $9989	                beq _found_delimiter
.9981	e6 26		inc $26		                inc tmp2
.9983	d0 dd		bne $9962	                bne _loop
.9985	e6 27		inc $27		                inc tmp2+1
.9987	80 d9		bra $9962	                bra _loop
.9989					_found_delimiter:
.9989	e6 2d		inc $2d		                inc tmptos+1
.998b					_eol:
.998b	a5 26		lda $26		                lda tmp2
.998d	38		sec		                sec
.998e	e5 24		sbc $24		                sbc tmp1
.9990	95 00		sta $00,x	                sta 0,x
.9992	a5 27		lda $27		                lda tmp2+1
.9994	e5 25		sbc $25		                sbc tmp1+1
.9996	95 01		sta $01,x	                sta 1,x
.9998	a5 26		lda $26		                lda tmp2
.999a	38		sec		                sec
.999b	e5 08		sbc $08		                sbc cib
.999d	85 0c		sta $0c		                sta toin
.999f	a5 27		lda $27		                lda tmp2+1
.99a1	e5 09		sbc $09		                sbc cib+1
.99a3	85 0d		sta $0d		                sta toin+1
.99a5	a5 0c		lda $0c		                lda toin
.99a7	18		clc		                clc
.99a8	65 2d		adc $2d		                adc tmptos+1
.99aa	85 0c		sta $0c		                sta toin
.99ac	a5 0d		lda $0d		                lda toin+1
.99ae	69 00		adc #$00	                adc #0          ; we only need the carry
.99b0	85 0d		sta $0d		                sta toin+1
.99b2					_done:
.99b2					z_parse_name:
.99b2	60		rts		z_parse:        rts
.99b3					xt_pick:
.99b3	16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99b5	8a		txa		                txa
.99b6	75 00		adc $00,x	                adc 0,x
.99b8	a8		tay		                tay
.99b9	b9 02 00	lda $0002,y	                lda 0002,y
.99bc	95 00		sta $00,x	                sta 0,x
.99be	b9 03 00	lda $0003,y	                lda 0003,y
.99c1	95 01		sta $01,x	                sta 1,x
.99c3	60		rts		z_pick:         rts
.99c4					xt_plus:
.99c4	20 4f d6	jsr $d64f	                jsr underflow_2
.99c7	18		clc		                clc
.99c8	b5 00		lda $00,x	                lda 0,x         ; LSB
.99ca	75 02		adc $02,x	                adc 2,x
.99cc	95 02		sta $02,x	                sta 2,x
.99ce	b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99d0	75 03		adc $03,x	                adc 3,x
.99d2	95 03		sta $03,x	                sta 3,x
.99d4	e8		inx		                inx
.99d5	e8		inx		                inx
.99d6	60		rts		z_plus:         rts
.99d7					xt_plus_store:
.99d7	20 4f d6	jsr $d64f	                jsr underflow_2
.99da	b5 00		lda $00,x	                lda 0,x
.99dc	85 24		sta $24		                sta tmp1
.99de	b5 01		lda $01,x	                lda 1,x
.99e0	85 25		sta $25		                sta tmp1+1
.99e2	a0 00		ldy #$00	                ldy #0          ; LSB
.99e4	b1 24		lda ($24),y	                lda (tmp1),y
.99e6	18		clc		                clc
.99e7	75 02		adc $02,x	                adc 2,x
.99e9	91 24		sta ($24),y	                sta (tmp1),y
.99eb	c8		iny		                iny             ; MSB
.99ec	b1 24		lda ($24),y	                lda (tmp1),y
.99ee	75 03		adc $03,x	                adc 3,x
.99f0	91 24		sta ($24),y	                sta (tmp1),y
.99f2	e8		inx		                inx
.99f3	e8		inx		                inx
.99f4	e8		inx		                inx
.99f5	e8		inx		                inx
.99f6	60		rts		z_plus_store:   rts
.99f7					xt_postpone:
.99f7	20 c0 98	jsr $98c0	                jsr xt_parse_name               ; ( -- addr n )
.99fa	b5 00		lda $00,x	                lda 0,x
.99fc	15 01		ora $01,x	                ora 1,x
.99fe	d0 05		bne $9a05	                bne +
.9a00	a9 05		lda #$05	                lda #err_noname
.9a02	4c 60 d6	jmp $d660	                jmp error
.9a05					+
.9a05	20 cb 8f	jsr $8fcb	                jsr xt_find_name                ; ( -- nt | 0 )
.9a08	d0 05		bne $9a0f	                bne +
.9a0a	a9 05		lda #$05	                lda #err_noname
.9a0c	4c 60 d6	jmp $d660	                jmp error
.9a0f					+
.9a0f	b5 00		lda $00,x	                lda 0,x
.9a11	85 24		sta $24		                sta tmp1
.9a13	b5 01		lda $01,x	                lda 1,x
.9a15	85 25		sta $25		                sta tmp1+1
.9a17	20 d1 95	jsr $95d1	                jsr xt_name_to_int              ; ( nt -- xt )
.9a1a	e6 24		inc $24		                inc tmp1
.9a1c	d0 02		bne $9a20	                bne +
.9a1e	e6 25		inc $25		                inc tmp1+1
.9a20					+
.9a20	b2 24		lda ($24)	                lda (tmp1)
.9a22	29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a24	f0 05		beq $9a2b	                beq _not_immediate
.9a26	20 dd 87	jsr $87dd	                jsr xt_compile_comma
.9a29	80 0a		bra $9a35	                bra _done
.9a2b					_not_immediate:
.9a2b	20 7a 93	jsr $937a	                jsr xt_literal
.9a2e	a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a30	a9 dd		lda #$dd	                lda #<xt_compile_comma
.9a32	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.9a35					_done:
.9a35	60		rts		z_postpone:     rts
.9a36					xt_previous:
.9a36	20 24 91	jsr $9124	                jsr xt_get_order
.9a39	20 32 96	jsr $9632	                jsr xt_nip
.9a3c	20 f2 97	jsr $97f2	                jsr xt_one_minus
.9a3f	20 fc 9c	jsr $9cfc	                jsr xt_set_order
.9a42	60		rts		z_previous:     rts
.9a43					xt_question:
.9a43	20 70 8f	jsr $8f70	                jsr xt_fetch
.9a46	20 26 8c	jsr $8c26	                jsr xt_dot
.9a49	60		rts		z_question:     rts
.9a4a					xt_question_dup:
.9a4a	20 4a d6	jsr $d64a	                jsr underflow_1
.9a4d	b5 00		lda $00,x	                lda 0,x
.9a4f	15 01		ora $01,x	                ora 1,x
.9a51	f0 0a		beq $9a5d	                beq _done
.9a53	ca		dex		                dex
.9a54	ca		dex		                dex
.9a55	b5 02		lda $02,x	                lda 2,x
.9a57	95 00		sta $00,x	                sta 0,x
.9a59	b5 03		lda $03,x	                lda 3,x
.9a5b	95 01		sta $01,x	                sta 1,x
.9a5d					_done:
.9a5d	60		rts		z_question_dup: rts
.9a5e					xt_r_fetch:
.9a5e	7a		ply		                ply             ; LSB
.9a5f	84 24		sty $24		                sty tmp1
.9a61	7a		ply		                ply             ; MSB
.9a62	ca		dex		                dex
.9a63	ca		dex		                dex
.9a64	68		pla		                pla             ; LSB
.9a65	95 00		sta $00,x	                sta 0,x
.9a67	68		pla		                pla             ; MSB
.9a68	95 01		sta $01,x	                sta 1,x
.9a6a	48		pha		                pha
.9a6b	b5 00		lda $00,x	                lda 0,x
.9a6d	48		pha		                pha
.9a6e	5a		phy		                phy             ; MSB
.9a6f	a4 24		ldy $24		                ldy tmp1
.9a71	5a		phy		                phy             ; LSB
.9a72	60		rts		z_r_fetch:      rts
.9a73					xt_r_from:
.9a73	68		pla		                pla             ; LSB
.9a74	85 2c		sta $2c		                sta tmptos
.9a76	7a		ply		                ply             ; MSB
.9a77	ca		dex		                dex
.9a78	ca		dex		                dex
.9a79	68		pla		                pla             ; LSB
.9a7a	95 00		sta $00,x	                sta 0,x
.9a7c	68		pla		                pla             ; MSB
.9a7d	95 01		sta $01,x	                sta 1,x
.9a7f	5a		phy		                phy             ; MSB
.9a80	a5 2c		lda $2c		                lda tmptos
.9a82	48		pha		                pha             ; LSB
.9a83	60		rts		z_r_from:       rts
.9a84					xt_r_to_input:
.9a84	68		pla		                pla
.9a85	85 24		sta $24		                sta tmp1
.9a87	68		pla		                pla
.9a88	85 25		sta $25		                sta tmp1+1
.9a8a	a0 00		ldy #$00	                ldy #0
.9a8c					_loop:
.9a8c	68		pla		                pla
.9a8d	99 06 00	sta $0006,y	                sta insrc,y
.9a90	c8		iny		                iny
.9a91	c0 08		cpy #$08	                cpy #8
.9a93	d0 f7		bne $9a8c	                bne _loop
.9a95	a5 25		lda $25		                lda tmp1+1
.9a97	48		pha		                pha
.9a98	a5 24		lda $24		                lda tmp1
.9a9a	48		pha		                pha
.9a9b	60		rts		z_r_to_input: 	rts
.9a9c					xt_recurse:
.9a9c	a0 00		ldy #$00	                ldy #0
.9a9e	a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9aa0	91 00		sta ($00),y	                sta (cp),y
.9aa2	c8		iny		                iny
.9aa3	24 20		bit $20		                bit status
.9aa5	70 0c		bvs $9ab3	                bvs _nt_in_workword
.9aa7	a5 04		lda $04		                lda workword
.9aa9	91 00		sta ($00),y	                sta (cp),y
.9aab	c8		iny		                iny
.9aac	a5 05		lda $05		                lda workword+1
.9aae	91 00		sta ($00),y	                sta (cp),y
.9ab0	c8		iny		                iny
.9ab1	80 1b		bra $9ace	                bra _update_cp
.9ab3					_nt_in_workword:
.9ab3	a5 04		lda $04		                lda workword            ; LSB
.9ab5	18		clc		                clc
.9ab6	69 04		adc #$04	                adc #4
.9ab8	85 24		sta $24		                sta tmp1
.9aba	a5 05		lda $05		                lda workword+1          ; MSB
.9abc	69 00		adc #$00	                adc #0
.9abe	85 25		sta $25		                sta tmp1+1
.9ac0	b2 24		lda ($24)	                lda (tmp1)
.9ac2	91 00		sta ($00),y	                sta (cp),y
.9ac4	5a		phy		                phy
.9ac5	a0 01		ldy #$01	                ldy #1
.9ac7	b1 24		lda ($24),y	                lda (tmp1),y
.9ac9	7a		ply		                ply
.9aca	c8		iny		                iny
.9acb	91 00		sta ($00),y	                sta (cp),y
.9acd	c8		iny		                iny
.9ace					_update_cp:
.9ace	98		tya		                tya
.9acf	18		clc		                clc
.9ad0	65 00		adc $00		                adc cp
.9ad2	85 00		sta $00		                sta cp
.9ad4	90 02		bcc $9ad8	                bcc _done
.9ad6	e6 01		inc $01		                inc cp+1
.9ad8					_done:
.9ad8	60		rts		z_recurse:      rts
.9ad9					xt_refill:
.9ad9	a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9adb	d0 2d		bne $9b0a	                bne _src_not_kbd
.9add	ca		dex		                dex
.9ade	ca		dex		                dex
.9adf	ca		dex		                dex
.9ae0	ca		dex		                dex
.9ae1	a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9ae3	95 02		sta $02,x	                sta 2,x
.9ae5	a5 09		lda $09		                lda cib+1
.9ae7	95 03		sta $03,x	                sta 3,x
.9ae9	64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9aeb	64 0b		stz $0b		                stz ciblen+1
.9aed	a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9aef	95 00		sta $00,x	                sta 0,x
.9af1	74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9af3	20 4e 81	jsr $814e	                jsr xt_accept           ; ( addr n1 -- n2)
.9af6	b5 00		lda $00,x	                lda 0,x
.9af8	85 0a		sta $0a		                sta ciblen
.9afa	b5 01		lda $01,x	                lda 1,x
.9afc	85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9afe	64 0c		stz $0c		                stz toin
.9b00	64 0d		stz $0d		                stz toin+1
.9b02	a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b04	95 00		sta $00,x	                sta 0,x
.9b06	95 01		sta $01,x	                sta 1,x
.9b08	80 10		bra $9b1a	                bra _done
.9b0a					_src_not_kbd:
.9b0a	1a		inc a		                ina
.9b0b	d0 08		bne $9b15	                bne _src_not_string
.9b0d	ca		dex		                dex
.9b0e	ca		dex		                dex
.9b0f	74 00		stz $00,x	                stz 0,x
.9b11	74 01		stz $01,x	                stz 1,x
.9b13	80 05		bra $9b1a	                bra z_refill
.9b15					_src_not_string:
.9b15	a9 01		lda #$01	                lda #err_badsource
.9b17	4c 60 d6	jmp $d660	                jmp error
.9b1a					_done:
.9b1a	60		rts		z_refill:       rts
.9b1b					xt_repeat:
.9b1b	20 89 82	jsr $8289	                jsr xt_again
.9b1e	20 62 91	jsr $9162	                jsr xt_here
.9b21	20 89 a1	jsr $a189	                jsr xt_swap
.9b24	20 68 a1	jsr $a168	                jsr xt_store
.9b27	60		rts		z_repeat:       rts
.9b28					xt_right_bracket:
.9b28	a9 ff		lda #$ff	                lda #$FF
.9b2a	85 16		sta $16		                sta state
.9b2c	85 17		sta $17		                sta state+1
.9b2e					z_right_bracket:
.9b2e	60		rts		                rts
.9b2f					xt_root_wordlist:
.9b2f	ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b30	ca		dex		                dex
.9b31	a9 03		lda #$03	                lda #3
.9b33	95 00		sta $00,x	                sta 0,x
.9b35	74 01		stz $01,x	                stz 1,x
.9b37					z_root_wordlist:
.9b37	60		rts		                rts
.9b38					xt_rot:
.9b38	20 54 d6	jsr $d654	                jsr underflow_3
.9b3b	b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b3d	b5 03		lda $03,x	                lda 3,x
.9b3f	95 05		sta $05,x	                sta 5,x
.9b41	b5 01		lda $01,x	                lda 1,x
.9b43	95 03		sta $03,x	                sta 3,x
.9b45	94 01		sty $01,x	                sty 1,x
.9b47	b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b49	b5 02		lda $02,x	                lda 2,x
.9b4b	95 04		sta $04,x	                sta 4,x
.9b4d	b5 00		lda $00,x	                lda 0,x
.9b4f	95 02		sta $02,x	                sta 2,x
.9b51	94 00		sty $00,x	                sty 0,x
.9b53	60		rts		z_rot:          rts
.9b54					xt_rshift:
.9b54	20 4f d6	jsr $d64f	                jsr underflow_2
.9b57	b5 00		lda $00,x	                lda 0,x
.9b59	29 0f		and #$0f	                and #%00001111
.9b5b	f0 08		beq $9b65	                beq _done               ; if 0 shifts, quit
.9b5d	a8		tay		                tay
.9b5e					_loop:
.9b5e	56 03		lsr $03,x	                lsr 3,x
.9b60	76 02		ror $02,x	                ror 2,x
.9b62	88		dey		                dey
.9b63	d0 f9		bne $9b5e	                bne _loop
.9b65					_done:
.9b65	e8		inx		                inx
.9b66	e8		inx		                inx
.9b67	60		rts		z_rshift:       rts
.9b68					xt_s_backslash_quote:
.9b68	a9 ff		lda #$ff	                lda #$FF
.9b6a	85 26		sta $26		                sta tmp2
.9b6c	64 27		stz $27		                stz tmp2+1
.9b6e	20 34 9d	jsr $9d34	                jsr s_quote_start
.9b71					_done:
.9b71					z_s_backslash_quote:
.9b71	60		rts		                rts
.9b72					convert_hex_value:
.9b72	c9 41		cmp #$41	        cmp #'A'
.9b74	90 07		bcc $9b7d	        bcc _digit
.9b76	29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b78	38		sec		        sec
.9b79	e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b7b	80 03		bra $9b80	        bra _done
.9b7d					_digit:
.9b7d	38		sec		        sec
.9b7e	e9 30		sbc #$30	        sbc #'0'
.9b80					_done:
.9b80	60		rts		        rts
.9b81					xt_search_wordlist:
.9b81	20 54 d6	jsr $d654	                jsr underflow_3
.9b84	a5 1e		lda $1e		                lda up
.9b86	18		clc		                clc
.9b87	69 06		adc #$06	                adc #wordlists_offset
.9b89	85 26		sta $26		                sta tmp2
.9b8b	a5 1f		lda $1f		                lda up+1
.9b8d	69 00		adc #$00	                adc #0          ; Adding carry
.9b8f	85 27		sta $27		                sta tmp2+1
.9b91	b5 00		lda $00,x	                lda 0,x
.9b93	0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9b94	65 26		adc $26		                adc tmp2
.9b96	85 26		sta $26		                sta tmp2
.9b98	90 02		bcc $9b9c	                bcc +
.9b9a	e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9b9c					+
.9b9c	e8		inx		                inx
.9b9d	e8		inx		                inx
.9b9e	b5 00		lda $00,x	                lda 0,x
.9ba0	15 01		ora $01,x	                ora 1,x
.9ba2	d0 03		bne $9ba7	                bne _check_wordlist
.9ba4	4c 5f 9c	jmp $9c5f	                jmp _done
.9ba7					_check_wordlist:
.9ba7	a5 26		lda $26		                lda tmp2
.9ba9	05 27		ora $27		                ora tmp2+1
.9bab	d0 03		bne $9bb0	                bne _have_string
.9bad	4c 5f 9c	jmp $9c5f	                jmp _done
.9bb0					_have_string:
.9bb0	b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9bb2	85 24		sta $24		                sta tmp1
.9bb4	e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9bb6	d0 02		bne $9bba	                bne +
.9bb8	e6 27		inc $27		                inc tmp2+1
.9bba					+
.9bba	b2 26		lda ($26)	                lda (tmp2)
.9bbc	85 25		sta $25		                sta tmp1+1
.9bbe	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9bc0	85 26		sta $26		                sta tmp2
.9bc2	b5 03		lda $03,x	                lda 3,x
.9bc4	85 27		sta $27		                sta tmp2+1
.9bc6					_loop:
.9bc6	b2 24		lda ($24)	                lda (tmp1)
.9bc8	d5 00		cmp $00,x	                cmp 0,x
.9bca	d0 7b		bne $9c47	                bne _next_entry
.9bcc					_compare_string:
.9bcc	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9bce	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bd0	b0 07		bcs $9bd9	                bcs _compare_first
.9bd2	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bd4	90 03		bcc $9bd9	                bcc _compare_first
.9bd6	18		clc		                clc
.9bd7	69 20		adc #$20	                adc #$20
.9bd9					_compare_first:
.9bd9	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9bdb	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9bdd	d0 68		bne $9c47	                bne _next_entry
.9bdf	b5 00		lda $00,x	                lda 0,x
.9be1	3a		dec a		                dea
.9be2	f0 2c		beq $9c10	                beq _success
.9be4	a5 24		lda $24		                lda tmp1
.9be6	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9be7	18		clc		                clc
.9be8	69 08		adc #$08	                adc #8
.9bea	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9bec	a5 25		lda $25		                lda tmp1+1
.9bee	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9bef	69 00		adc #$00	                adc #0          ; we only need the carry
.9bf1	85 25		sta $25		                sta tmp1+1
.9bf3	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9bf5	88		dey		                dey
.9bf6					_string_loop:
.9bf6	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9bf8	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9bfa	b0 07		bcs $9c03	                bcs _check_char
.9bfc	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bfe	90 03		bcc $9c03	                bcc _check_char
.9c00	18		clc		                clc
.9c01	69 20		adc #$20	                adc #$20
.9c03					_check_char:
.9c03	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c05	d0 3a		bne $9c41	                bne _next_entry_tmp1
.9c07	88		dey		                dey
.9c08	d0 ec		bne $9bf6	                bne _string_loop
.9c0a					_success_tmp1:
.9c0a	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c0b	85 25		sta $25		                sta tmp1+1
.9c0d	68		pla		                pla
.9c0e	85 24		sta $24		                sta tmp1
.9c10					_success:
.9c10	e8		inx		                inx
.9c11	e8		inx		                inx
.9c12	a5 24		lda $24		                lda tmp1
.9c14	95 00		sta $00,x	                sta 0,x
.9c16	a5 25		lda $25		                lda tmp1+1
.9c18	95 01		sta $01,x	                sta 1,x
.9c1a	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( nt nt )
.9c1d	20 d1 95	jsr $95d1	                jsr xt_name_to_int      ; ( nt xt )
.9c20	20 89 a1	jsr $a189	                jsr xt_swap             ; ( xt nt )
.9c23	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c25	f6 00		inc $00,x	                inc 0,x
.9c27	d0 02		bne $9c2b	                bne +
.9c29	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c2b					+
.9c2b	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c2d	29 04		and #$04	                and #IM
.9c2f	d0 08		bne $9c39	                bne _immediate          ; bit set, we're immediate
.9c31	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c33	95 00		sta $00,x	                sta 0,x
.9c35	95 01		sta $01,x	                sta 1,x
.9c37	80 28		bra $9c61	                bra _done_nodrop
.9c39					_immediate:
.9c39	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c3b	95 00		sta $00,x	                sta 0,x
.9c3d	74 01		stz $01,x	                stz 1,x
.9c3f	80 20		bra $9c61	                bra _done_nodrop
.9c41					_next_entry_tmp1:
.9c41	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c42	85 25		sta $25		                sta tmp1+1
.9c44	68		pla		                pla
.9c45	85 24		sta $24		                sta tmp1
.9c47					_next_entry:
.9c47	a0 02		ldy #$02	                ldy #2
.9c49	b1 24		lda ($24),y	                lda (tmp1),y
.9c4b	48		pha		                pha
.9c4c	c8		iny		                iny
.9c4d	b1 24		lda ($24),y	                lda (tmp1),y
.9c4f	85 25		sta $25		                sta tmp1+1
.9c51	68		pla		                pla
.9c52	85 24		sta $24		                sta tmp1
.9c54	05 25		ora $25		                ora tmp1+1
.9c56	f0 03		beq $9c5b	                beq _fail_done
.9c58	4c c6 9b	jmp $9bc6	                jmp _loop
.9c5b					_fail_done:
.9c5b	74 02		stz $02,x	                stz 2,x         ; failure flag
.9c5d	74 03		stz $03,x	                stz 3,x
.9c5f					_done:
.9c5f	e8		inx		                inx
.9c60	e8		inx		                inx
.9c61					_done_nodrop:
.9c61					z_search_wordlist:
.9c61	60		rts		                rts
.9c62					xt_see:
.9c62	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( addr u )
.9c65	20 cb 8f	jsr $8fcb	                jsr xt_find_name        ; ( nt | 0 )
.9c68	b5 00		lda $00,x	                lda 0,x
.9c6a	15 01		ora $01,x	                ora 1,x
.9c6c	d0 05		bne $9c73	                bne +
.9c6e	a9 05		lda #$05	                lda #err_noname
.9c70	4c 60 d6	jmp $d660	                jmp error
.9c73					+
.9c73	20 53 89	jsr $8953	                jsr xt_cr
.9c76	a5 18		lda $18		                lda base
.9c78	48		pha		                pha
.9c79	20 6d 91	jsr $916d	                jsr xt_hex
.9c7c	a9 0a		lda #$0a	                lda #str_see_nt
.9c7e	20 76 d6	jsr $d676	                jsr print_string_no_lf
.9c81	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( nt nt )
.9c84	20 09 a5	jsr $a509	                jsr xt_u_dot
.9c87	20 ff a0	jsr $a0ff	                jsr xt_space            ; ( nt )
.9c8a	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( nt nt )
.9c8d	20 d1 95	jsr $95d1	                jsr xt_name_to_int      ; ( nt xt )
.9c90	a9 0b		lda #$0b	                lda #str_see_xt
.9c92	20 76 d6	jsr $d676	                jsr print_string_no_lf
.9c95	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( nt xt xt )
.9c98	20 09 a5	jsr $a509	                jsr xt_u_dot
.9c9b	20 53 89	jsr $8953	                jsr xt_cr               ; ( nt xt )
.9c9e	a9 09		lda #$09	                lda #str_see_flags
.9ca0	20 76 d6	jsr $d676	                jsr print_string_no_lf
.9ca3	20 74 98	jsr $9874	                jsr xt_over             ; ( nt xt nt )
.9ca6	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9ca9	20 70 8f	jsr $8f70	                jsr xt_fetch            ; ( nt xt flags )
.9cac	b5 00		lda $00,x	                lda 0,x
.9cae	a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9cb0					_flag_loop:
.9cb0	48		pha		                pha
.9cb1	29 01		and #$01	                and #%00000001
.9cb3	18		clc		                clc
.9cb4	69 30		adc #$30	                adc #$30                ; ASCII "0"
.9cb6	20 e6 8d	jsr $8de6	                jsr emit_a
.9cb9	20 ff a0	jsr $a0ff	                jsr xt_space
.9cbc	68		pla		                pla
.9cbd	6a		ror a		                ror                     ; Next flag
.9cbe	88		dey		                dey
.9cbf	d0 ef		bne $9cb0	                bne _flag_loop
.9cc1	20 53 89	jsr $8953	                jsr xt_cr
.9cc4	e8		inx		                inx
.9cc5	e8		inx		                inx                     ; ( nt xt )
.9cc6	a9 0c		lda #$0c	                lda #str_see_size
.9cc8	20 76 d6	jsr $d676	                jsr print_string_no_lf
.9ccb	20 89 a1	jsr $a189	                jsr xt_swap             ; ( xt nt )
.9cce	20 4f a7	jsr $a74f	                jsr xt_wordsize         ; ( xt u )
.9cd1	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9cd4	20 95 8a	jsr $8a95	                jsr xt_decimal
.9cd7	20 09 a5	jsr $a509	                jsr xt_u_dot            ; ( xt u )
.9cda	20 6d 91	jsr $916d	                jsr xt_hex
.9cdd	20 53 89	jsr $8953	                jsr xt_cr
.9ce0	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( xt u xt u )
.9ce3	20 24 8d	jsr $8d24	                jsr xt_dump
.9ce6	20 53 89	jsr $8953	                jsr xt_cr
.9ce9	20 2a 8b	jsr $8b2a	                jsr xt_disasm
.9cec	68		pla		                pla
.9ced	85 18		sta $18		                sta base
.9cef	60		rts		z_see:          rts
.9cf0					xt_set_current:
.9cf0	20 4a d6	jsr $d64a	                jsr underflow_1
.9cf3	a0 04		ldy #$04	                ldy #current_offset
.9cf5	b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9cf7	91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9cf9	e8		inx		                inx
.9cfa	e8		inx		                inx
.9cfb	60		rts		z_set_current:  rts
.9cfc					xt_set_order:
.9cfc	a9 ff		lda #$ff	                lda #$FF
.9cfe	d5 01		cmp $01,x	                cmp 1,x
.9d00	d0 12		bne $9d14	                bne _start
.9d02	d5 00		cmp $00,x	                cmp 0,x
.9d04	d0 0e		bne $9d14	                bne _start
.9d06	ca		dex		                dex             ; Make room for the count.
.9d07	ca		dex		                dex
.9d08	74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d0a	a9 03		lda #$03	                lda #3
.9d0c	95 02		sta $02,x	                sta 2,x
.9d0e	74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d10	a9 01		lda #$01	                lda #1
.9d12	95 00		sta $00,x	                sta 0,x
.9d14					_start:
.9d14	a0 1e		ldy #$1e	                ldy #num_order_offset
.9d16	b5 00		lda $00,x	                lda 0,x
.9d18	91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d1a	85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d1c	e8		inx		                inx             ; Drop the count off the data stack.
.9d1d	e8		inx		                inx
.9d1e	a5 24		lda $24		                lda tmp1
.9d20	f0 0d		beq $9d2f	                beq _done       ; If zero, there are no wordlists.
.9d22	a0 1f		ldy #$1f	                ldy #search_order_offset
.9d24					_loop:
.9d24	b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d26	91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d28	c8		iny		                iny
.9d29	e8		inx		                inx
.9d2a	e8		inx		                inx
.9d2b	c6 24		dec $24		                dec tmp1
.9d2d	d0 f5		bne $9d24	                bne _loop
.9d2f					_done:
.9d2f	60		rts		z_set_order:    rts
.9d30					xt_s_quote:
.9d30	64 26		stz $26		                stz tmp2
.9d32	64 27		stz $27		                stz tmp2+1
.9d34					s_quote_start:
.9d34	ca		dex		                dex
.9d35	ca		dex		                dex
.9d36	ca		dex		                dex
.9d37	ca		dex		                dex
.9d38	a9 4c		lda #$4c	                lda #$4C
.9d3a	20 fd d4	jsr $d4fd	                jsr cmpl_a
.9d3d	20 fd d4	jsr $d4fd	                jsr cmpl_a
.9d40	20 fd d4	jsr $d4fd	                jsr cmpl_a
.9d43	a5 00		lda $00		                lda cp
.9d45	95 02		sta $02,x	                sta 2,x
.9d47	a5 01		lda $01		                lda cp+1
.9d49	95 03		sta $03,x	                sta 3,x
.9d4b					_savechars_loop:
.9d4b	a5 0d		lda $0d		                lda toin+1              ; MSB
.9d4d	c5 0b		cmp $0b		                cmp ciblen+1
.9d4f	90 2a		bcc $9d7b	                bcc _input_fine         ; unsigned comparison
.9d51	a5 0c		lda $0c		                lda toin                ; LSB
.9d53	c5 0a		cmp $0a		                cmp ciblen
.9d55	90 24		bcc $9d7b	                bcc _input_fine
.9d57	a5 26		lda $26		                lda tmp2
.9d59	48		pha		                pha
.9d5a	a5 27		lda $27		                lda tmp2+1
.9d5c	48		pha		                pha
.9d5d	a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d5f	48		pha		                pha
.9d60	20 d9 9a	jsr $9ad9	                jsr xt_refill           ; ( -- f )
.9d63	68		pla		                pla
.9d64	85 28		sta $28		                sta tmp3
.9d66	68		pla		                pla
.9d67	85 27		sta $27		                sta tmp2+1
.9d69	68		pla		                pla
.9d6a	85 26		sta $26		                sta tmp2
.9d6c	b5 00		lda $00,x	                lda 0,x
.9d6e	15 01		ora $01,x	                ora 1,x
.9d70	d0 05		bne $9d77	                bne _refill_ok
.9d72	a9 06		lda #$06	                lda #err_refill
.9d74	4c 60 d6	jmp $d660	                jmp error
.9d77					_refill_ok:
.9d77	e8		inx		                inx
.9d78	e8		inx		                inx
.9d79	80 d0		bra $9d4b	                bra _savechars_loop
.9d7b					_input_fine:
.9d7b	a5 08		lda $08		                lda cib
.9d7d	18		clc		                clc
.9d7e	65 0c		adc $0c		                adc toin        ; LSB
.9d80	85 24		sta $24		                sta tmp1
.9d82	a5 09		lda $09		                lda cib+1
.9d84	65 0d		adc $0d		                adc toin+1      ; MSB
.9d86	85 25		sta $25		                sta tmp1+1
.9d88	b2 24		lda ($24)	                lda (tmp1)
.9d8a	24 26		bit $26		                bit tmp2
.9d8c	30 03		bmi $9d91	                bmi _handle_escapes    ; Only checking bit 7
.9d8e	4c 49 9e	jmp $9e49	                jmp _regular_char
.9d91					_handle_escapes:
.9d91	24 27		bit $27		                bit tmp2+1
.9d93	30 03		bmi $9d98	                bmi _escaped
.9d95	4c 3f 9e	jmp $9e3f	                jmp _not_escaped
.9d98					_escaped:
.9d98	70 22		bvs $9dbc	                bvs _check_esc_chars
.9d9a	a9 01		lda #$01	                lda #1
.9d9c	24 27		bit $27		                bit tmp2+1
.9d9e	d0 10		bne $9db0	                bne _esc_x_second_digit
.9da0	e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9da2	b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9da4	20 72 9b	jsr $9b72	                jsr convert_hex_value
.9da7	0a		asl a		                asl
.9da8	0a		asl a		                asl
.9da9	0a		asl a		                asl
.9daa	0a		asl a		                asl
.9dab	85 28		sta $28		                sta tmp3    ; Save it for later.
.9dad	4c 50 9e	jmp $9e50	                jmp _next_character
.9db0					_esc_x_second_digit:
.9db0	64 27		stz $27		                stz tmp2+1
.9db2	b2 24		lda ($24)	                lda (tmp1)
.9db4	20 72 9b	jsr $9b72	                jsr convert_hex_value
.9db7	05 28		ora $28		                ora tmp3
.9db9	4c 4d 9e	jmp $9e4d	                jmp _save_character
.9dbc					_check_esc_chars:
.9dbc	64 27		stz $27		                stz tmp2+1
.9dbe					_check_esc_a:
.9dbe	c9 61		cmp #$61	                cmp #'a'
.9dc0	d0 05		bne $9dc7	                bne _check_esc_b
.9dc2	a9 07		lda #$07	                lda #7
.9dc4	4c 4d 9e	jmp $9e4d	                jmp _save_character
.9dc7					_check_esc_b:
.9dc7	c9 62		cmp #$62	                cmp #'b'
.9dc9	d0 05		bne $9dd0	                bne _check_esc_e
.9dcb	a9 08		lda #$08	                lda #8
.9dcd	4c 4d 9e	jmp $9e4d	                jmp _save_character
.9dd0					_check_esc_e:
.9dd0	c9 65		cmp #$65	                cmp #'e'
.9dd2	d0 04		bne $9dd8	                bne _check_esc_f
.9dd4	a9 1b		lda #$1b	                lda #27
.9dd6	80 75		bra $9e4d	                bra _save_character
.9dd8					_check_esc_f:
.9dd8	c9 66		cmp #$66	                cmp #'f'
.9dda	d0 04		bne $9de0	                bne _check_esc_l
.9ddc	a9 0c		lda #$0c	                lda #12
.9dde	80 6d		bra $9e4d	                bra _save_character
.9de0					_check_esc_l:
.9de0	c9 6c		cmp #$6c	                cmp #'l'
.9de2	d0 04		bne $9de8	                bne _check_esc_m
.9de4	a9 0a		lda #$0a	                lda #10
.9de6	80 65		bra $9e4d	                bra _save_character
.9de8					_check_esc_m:
.9de8	c9 6d		cmp #$6d	                cmp #'m'
.9dea	d0 09		bne $9df5	                bne _check_esc_n
.9dec	a9 0d		lda #$0d	                lda #13
.9dee	20 fd d4	jsr $d4fd	                jsr cmpl_a
.9df1	a9 0a		lda #$0a	                lda #10
.9df3	80 58		bra $9e4d	                bra _save_character
.9df5					_check_esc_n:
.9df5	c9 6e		cmp #$6e	                cmp #'n'
.9df7	d0 04		bne $9dfd	                bne _check_esc_q
.9df9	a9 0a		lda #$0a	                lda #10
.9dfb	80 50		bra $9e4d	                bra _save_character
.9dfd					_check_esc_q:
.9dfd	c9 71		cmp #$71	                cmp #'q'
.9dff	d0 04		bne $9e05	                bne _check_esc_r
.9e01	a9 22		lda #$22	                lda #34
.9e03	80 48		bra $9e4d	                bra _save_character
.9e05					_check_esc_r:
.9e05	c9 72		cmp #$72	                cmp #'r'
.9e07	d0 04		bne $9e0d	                bne _check_esc_t
.9e09	a9 0d		lda #$0d	                lda #13
.9e0b	80 40		bra $9e4d	                bra _save_character
.9e0d					_check_esc_t:
.9e0d	c9 74		cmp #$74	                cmp #'t'
.9e0f	d0 04		bne $9e15	                bne _check_esc_v
.9e11	a9 09		lda #$09	                lda #9
.9e13	80 38		bra $9e4d	                bra _save_character
.9e15					_check_esc_v:
.9e15	c9 76		cmp #$76	                cmp #'v'
.9e17	d0 04		bne $9e1d	                bne _check_esc_z
.9e19	a9 0b		lda #$0b	                lda #11
.9e1b	80 30		bra $9e4d	                bra _save_character
.9e1d					_check_esc_z:
.9e1d	c9 7a		cmp #$7a	                cmp #'z'
.9e1f	d0 04		bne $9e25	                bne _check_esc_quote
.9e21	a9 00		lda #$00	                lda #0
.9e23	80 28		bra $9e4d	                bra _save_character
.9e25					_check_esc_quote:
.9e25	c9 22		cmp #$22	                cmp #$22
.9e27	d0 04		bne $9e2d	                bne _check_esc_x
.9e29	a9 22		lda #$22	                lda #34
.9e2b	80 20		bra $9e4d	                bra _save_character
.9e2d					_check_esc_x:
.9e2d	c9 78		cmp #$78	                cmp #'x'
.9e2f	d0 06		bne $9e37	                bne _check_esc_backslash
.9e31	a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e33	85 27		sta $27		                sta tmp2+1
.9e35	80 19		bra $9e50	                bra _next_character
.9e37					_check_esc_backslash:
.9e37	c9 5c		cmp #$5c	                cmp #$5C
.9e39	d0 04		bne $9e3f	                bne _not_escaped
.9e3b	a9 5c		lda #$5c	                lda #92
.9e3d	80 0e		bra $9e4d	                bra _save_character
.9e3f					_not_escaped:
.9e3f	c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e41	d0 06		bne $9e49	                bne _regular_char
.9e43	a9 ff		lda #$ff	                lda #$FF
.9e45	85 27		sta $27		                sta tmp2+1
.9e47	80 07		bra $9e50	                bra _next_character
.9e49					_regular_char:
.9e49	c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e4b	f0 0c		beq $9e59	                beq _found_string_end
.9e4d					_save_character:
.9e4d	20 fd d4	jsr $d4fd	                jsr cmpl_a
.9e50					_next_character:
.9e50	e6 0c		inc $0c		                inc toin
.9e52	d0 02		bne $9e56	                bne _savechars_loop_longjump
.9e54	e6 0d		inc $0d		                inc toin+1
.9e56					_savechars_loop_longjump:
.9e56	4c 4b 9d	jmp $9d4b	                jmp _savechars_loop
.9e59					_found_string_end:
.9e59	e6 0c		inc $0c		                inc toin
.9e5b	d0 02		bne $9e5f	                bne +
.9e5d	e6 0d		inc $0d		                inc toin+1
.9e5f					+
.9e5f	a5 00		lda $00		                lda cp
.9e61	38		sec		                sec
.9e62	f5 02		sbc $02,x	                sbc 2,x
.9e64	95 00		sta $00,x	                sta 0,x         ; LSB
.9e66	a5 01		lda $01		                lda cp+1
.9e68	f5 03		sbc $03,x	                sbc 3,x
.9e6a	95 01		sta $01,x	                sta 1,x         ; MSB
.9e6c	b5 02		lda $02,x	                lda 2,x
.9e6e	38		sec		                sec
.9e6f	e9 02		sbc #$02	                sbc #2
.9e71	85 24		sta $24		                sta tmp1
.9e73	b5 03		lda $03,x	                lda 3,x
.9e75	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e77	85 25		sta $25		                sta tmp1+1
.9e79	a5 00		lda $00		                lda cp
.9e7b	92 24		sta ($24)	                sta (tmp1)
.9e7d	a0 01		ldy #$01	                ldy #1
.9e7f	a5 01		lda $01		                lda cp+1
.9e81	91 24		sta ($24),y	                sta (tmp1),y
.9e83	a5 16		lda $16		                lda state
.9e85	05 17		ora $17		                ora state+1             ; paranoid
.9e87	f0 03		beq $9e8c	                beq _done
.9e89	20 70 a0	jsr $a070	                jsr sliteral_const_str         ; ( addr u -- )
.9e8c					_done:
.9e8c	60		rts		z_s_quote:      rts
.9e8d					xt_s_to_d:
.9e8d	20 4a d6	jsr $d64a	                jsr underflow_1
.9e90	ca		dex		                dex
.9e91	ca		dex		                dex
.9e92	74 00		stz $00,x	                stz 0,x
.9e94	74 01		stz $01,x	                stz 1,x
.9e96	b5 03		lda $03,x	                lda 3,x
.9e98	10 04		bpl $9e9e	                bpl _done
.9e9a	d6 00		dec $00,x	                dec 0,x
.9e9c	d6 01		dec $01,x	                dec 1,x
.9e9e					_done:
.9e9e	60		rts		z_s_to_d:       rts
.9e9f					xt_save_buffers:
.9e9f	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9ea1	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9ea3	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9ea5	d0 12		bne $9eb9	                bne _done       ; Either not used or not dirty = done!
.9ea7	20 a3 83	jsr $83a3	                jsr xt_blkbuffer
.9eaa	20 95 85	jsr $8595	                jsr xt_buffblocknum
.9ead	20 70 8f	jsr $8f70	                jsr xt_fetch
.9eb0	20 50 85	jsr $8550	                jsr xt_block_write
.9eb3	a9 01		lda #$01	                lda #1
.9eb5	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9eb7	91 1e		sta ($1e),y	                sta (up),y
.9eb9					_done:
.9eb9	60		rts		z_save_buffers: rts
.9eba					xt_scr:
.9eba	ca		dex		                dex
.9ebb	ca		dex		                dex
.9ebc	18		clc		                clc
.9ebd	a5 1e		lda $1e		                lda up
.9ebf	69 02		adc #$02	                adc #scr_offset ; Add offset
.9ec1	95 00		sta $00,x	                sta 0,x
.9ec3	a5 1f		lda $1f		                lda up+1
.9ec5	69 00		adc #$00	                adc #0          ; Adding carry
.9ec7	95 01		sta $01,x	                sta 1,x
.9ec9	60		rts		z_scr:          rts
.9eca					xt_search:
.9eca	20 59 d6	jsr $d659	                jsr underflow_4
.9ecd	b5 00		lda $00,x	                lda 0,x
.9ecf	15 01		ora $01,x	                ora 1,x
.9ed1	d0 0b		bne $9ede	                bne _start_search
.9ed3	e8		inx		                inx             ; Remove u2
.9ed4	e8		inx		                inx
.9ed5	a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ed7	95 00		sta $00,x	                sta 0,x
.9ed9	95 01		sta $01,x	                sta 1,x
.9edb	4c 68 9f	jmp $9f68	                jmp z_search
.9ede					_start_search:
.9ede	20 82 a7	jsr $a782	                jsr xt_zero
.9ee1					_search_loop:
.9ee1	18		clc		                clc
.9ee2	b5 00		lda $00,x	                lda 0,x
.9ee4	75 02		adc $02,x	                adc 2,x
.9ee6	85 24		sta $24		                sta tmp1
.9ee8	b5 01		lda $01,x	                lda 1,x
.9eea	75 03		adc $03,x	                adc 3,x
.9eec	d5 07		cmp $07,x	                cmp 7,x
.9eee	90 12		bcc $9f02	                bcc _init_comparison ; Obviously less
.9ef0	d0 06		bne $9ef8	                bne _not_found
.9ef2	b5 06		lda $06,x	                lda 6,x
.9ef4	c5 24		cmp $24		                cmp tmp1
.9ef6	b0 0a		bcs $9f02	                bcs _init_comparison
.9ef8					_not_found:
.9ef8	e8		inx		                inx             ; Remove offset
.9ef9	e8		inx		                inx
.9efa	e8		inx		                inx             ; Remove u2
.9efb	e8		inx		                inx
.9efc	74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9efe	74 01		stz $01,x	                stz 1,x
.9f00	80 66		bra $9f68	                bra z_search
.9f02					_init_comparison:
.9f02	18		clc		                clc
.9f03	b5 08		lda $08,x	                lda 8,x
.9f05	75 00		adc $00,x	                adc 0,x
.9f07	85 24		sta $24		                sta tmp1
.9f09	b5 09		lda $09,x	                lda 9,x
.9f0b	75 01		adc $01,x	                adc 1,x
.9f0d	85 25		sta $25		                sta tmp1+1
.9f0f	b5 04		lda $04,x	                lda 4,x
.9f11	85 26		sta $26		                sta tmp2
.9f13	b5 05		lda $05,x	                lda 5,x
.9f15	85 27		sta $27		                sta tmp2+1
.9f17	b5 02		lda $02,x	                lda 2,x
.9f19	85 28		sta $28		                sta tmp3
.9f1b	b5 03		lda $03,x	                lda 3,x
.9f1d	85 29		sta $29		                sta tmp3+1
.9f1f					_comparison_loop:
.9f1f	b2 24		lda ($24)	                lda (tmp1)
.9f21	d2 26		cmp ($26)	                cmp (tmp2)
.9f23	f0 05		beq $9f2a	                beq _letters_match
.9f25	20 fe 97	jsr $97fe	                jsr xt_one_plus
.9f28	80 b7		bra $9ee1	                bra _search_loop
.9f2a					_letters_match:
.9f2a	e6 24		inc $24		                inc tmp1
.9f2c	d0 02		bne $9f30	                bne +
.9f2e	e6 25		inc $25		                inc tmp1+1
.9f30					+
.9f30	e6 26		inc $26		                inc tmp2
.9f32	d0 02		bne $9f36	                bne +
.9f34	e6 27		inc $27		                inc tmp2+1
.9f36					+
.9f36	a5 28		lda $28		                lda tmp3
.9f38	d0 02		bne $9f3c	                bne +
.9f3a	c6 29		dec $29		                dec tmp3+1
.9f3c					+
.9f3c	c6 28		dec $28		                dec tmp3
.9f3e	a5 28		lda $28		                lda tmp3
.9f40	05 29		ora $29		                ora tmp3+1
.9f42	d0 db		bne $9f1f	                bne _comparison_loop ; Check the next letter
.9f44	18		clc		                clc
.9f45	b5 00		lda $00,x	                lda 0,x
.9f47	75 08		adc $08,x	                adc 8,x
.9f49	95 08		sta $08,x	                sta 8,x
.9f4b	b5 01		lda $01,x	                lda 1,x
.9f4d	75 09		adc $09,x	                adc 9,x
.9f4f	95 09		sta $09,x	                sta 9,x
.9f51	38		sec		                sec
.9f52	b5 06		lda $06,x	                lda 6,x
.9f54	f5 00		sbc $00,x	                sbc 0,x
.9f56	95 06		sta $06,x	                sta 6,x
.9f58	b5 07		lda $07,x	                lda 7,x
.9f5a	f5 01		sbc $01,x	                sbc 1,x
.9f5c	95 07		sta $07,x	                sta 7,x
.9f5e	e8		inx		                inx             ; drop offset
.9f5f	e8		inx		                inx
.9f60	e8		inx		                inx             ; drop u2
.9f61	e8		inx		                inx
.9f62	a9 ff		lda #$ff	                lda #$FF
.9f64	95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f66	95 01		sta $01,x	                sta 1,x
.9f68	60		rts		z_search:       rts
.9f69					xt_semicolon:
.9f69	24 20		bit $20		                bit status
.9f6b	70 11		bvs $9f7e	                bvs _colonword
.9f6d	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f6f	20 fd d4	jsr $d4fd	                jsr cmpl_a
.9f72	ca		dex		                dex
.9f73	ca		dex		                dex
.9f74	a5 04		lda $04		                lda workword
.9f76	95 00		sta $00,x	                sta 0,x
.9f78	a5 05		lda $05		                lda workword+1
.9f7a	95 01		sta $01,x	                sta 1,x
.9f7c	80 45		bra $9fc3	                bra _semicolon_done
.9f7e					_colonword:
.9f7e	a0 06		ldy #$06	                ldy #6
.9f80	a5 00		lda $00		                lda cp
.9f82	91 04		sta ($04),y	                sta (workword),y
.9f84	c8		iny		                iny
.9f85	a5 01		lda $01		                lda cp+1
.9f87	91 04		sta ($04),y	                sta (workword),y
.9f89	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f8b	20 fd d4	jsr $d4fd	                jsr cmpl_a
.9f8e	24 20		bit $20		                bit status
.9f90	10 26		bpl $9fb8	                bpl _new_word   ; Bit 7 is clear = new word
.9f92	ca		dex		                dex
.9f93	ca		dex		                dex
.9f94	ca		dex		                dex
.9f95	ca		dex		                dex
.9f96	b2 04		lda ($04)	                lda (workword)
.9f98	95 00		sta $00,x	                sta 0,x
.9f9a	74 01		stz $01,x	                stz 1,x
.9f9c	a5 04		lda $04		                lda workword
.9f9e	18		clc		                clc
.9f9f	69 08		adc #$08	                adc #8
.9fa1	95 02		sta $02,x	                sta 2,x
.9fa3	a5 05		lda $05		                lda workword+1
.9fa5	69 00		adc #$00	                adc #0                  ; only want carry
.9fa7	95 03		sta $03,x	                sta 3,x
.9fa9	a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9fab	20 76 d6	jsr $d676	                jsr print_string_no_lf
.9fae	20 de a4	jsr $a4de	                jsr xt_type
.9fb1	20 ff a0	jsr $a0ff	                jsr xt_space
.9fb4	a9 80		lda #$80	                lda #%10000000
.9fb6	14 20		trb $20		                trb status
.9fb8					_new_word:
.9fb8	a5 04		lda $04		                lda workword
.9fba	85 02		sta $02		                sta dp
.9fbc	a5 05		lda $05		                lda workword+1
.9fbe	85 03		sta $03		                sta dp+1
.9fc0	20 9f d5	jsr $d59f	                jsr dp_to_current       ; Save the updated DP to the
.9fc3					_semicolon_done:
.9fc3	64 16		stz $16		                stz state
.9fc5	64 17		stz $17		                stz state+1
.9fc7	60		rts		z_semicolon:    rts
.9fc8					xt_sign:
.9fc8	20 4a d6	jsr $d64a	                jsr underflow_1
.9fcb	b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9fcd	30 04		bmi $9fd3	                bmi _minus
.9fcf	e8		inx		                inx
.9fd0	e8		inx		                inx
.9fd1	80 09		bra $9fdc	                bra _done
.9fd3					_minus:
.9fd3	a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9fd5	95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9fd7	74 01		stz $01,x	                stz 1,x         ; paranoid
.9fd9	20 c7 91	jsr $91c7	                jsr xt_hold
.9fdc					_done:
.9fdc	60		rts		z_sign:         rts
.9fdd					xt_slash:
.9fdd	a9 00		lda #$00	                lda #0
.9fdf	48		pha		                pha
.9fe0	80 03		bra $9fe5	                bra slashmod_common
.9fe2					xt_slash_mod:
.9fe2	a9 ff		lda #$ff	                lda #$FF
.9fe4	48		pha		                pha             ; falls through to _common
.9fe5					slashmod_common:
.9fe5	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R
.9fe8	20 8d 9e	jsr $9e8d	                jsr xt_s_to_d           ; S>D
.9feb	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R>
.9fee	20 b6 a0	jsr $a0b6	                jsr xt_sm_slash_rem     ; SM/REM
.9ff1	68		pla		                pla
.9ff2	d0 05		bne $9ff9	                bne _done
.9ff4	20 89 a1	jsr $a189	                jsr xt_swap
.9ff7	e8		inx		                inx             ; DROP
.9ff8	e8		inx		                inx
.9ff9					_done:
.9ff9					z_slash_mod:
.9ff9	60		rts		z_slash:        rts
.9ffa					xt_slash_string:
.9ffa	20 54 d6	jsr $d654	                jsr underflow_3
.9ffd	18		clc		                clc             ; 3OS+TOS
.9ffe	b5 00		lda $00,x	                lda 0,x
.a000	75 04		adc $04,x	                adc 4,x
.a002	95 04		sta $04,x	                sta 4,x
.a004	b5 01		lda $01,x	                lda 1,x
.a006	75 05		adc $05,x	                adc 5,x
.a008	95 05		sta $05,x	                sta 5,x
.a00a	38		sec		                sec             ; NOS-TOS
.a00b	b5 02		lda $02,x	                lda 2,x
.a00d	f5 00		sbc $00,x	                sbc 0,x
.a00f	95 02		sta $02,x	                sta 2,x
.a011	b5 03		lda $03,x	                lda 3,x
.a013	f5 01		sbc $01,x	                sbc 1,x
.a015	95 03		sta $03,x	                sta 3,x
.a017	e8		inx		                inx
.a018	e8		inx		                inx
.a019	60		rts		z_slash_string: rts
.a01a					xt_sliteral:
.a01a	20 4f d6	jsr $d64f	                jsr underflow_2
.a01d	a9 4c		lda #$4c	                lda #$4C
.a01f	20 fd d4	jsr $d4fd	                jsr cmpl_a
.a022	20 fd d4	jsr $d4fd	                jsr cmpl_a
.a025	20 fd d4	jsr $d4fd	                jsr cmpl_a
.a028	8a		txa		                txa
.a029	38		sec		                sec
.a02a	e9 06		sbc #$06	                sbc #6
.a02c	aa		tax		                tax
.a02d	b5 08		lda $08,x	                lda 8,x
.a02f	95 04		sta $04,x	                sta 4,x
.a031	b5 09		lda $09,x	                lda 9,x
.a033	95 05		sta $05,x	                sta 5,x
.a035	b5 06		lda $06,x	                lda 6,x
.a037	95 00		sta $00,x	                sta 0,x
.a039	b5 07		lda $07,x	                lda 7,x
.a03b	95 01		sta $01,x	                sta 1,x
.a03d	a5 00		lda $00		                lda cp
.a03f	95 08		sta $08,x	                sta 8,x
.a041	95 02		sta $02,x	                sta 2,x
.a043	a5 01		lda $01		                lda cp+1
.a045	95 09		sta $09,x	                sta 9,x
.a047	95 03		sta $03,x	                sta 3,x
.a049	20 b2 95	jsr $95b2	                jsr xt_move
.a04c	18		clc		                clc
.a04d	a5 00		lda $00		                lda cp
.a04f	75 00		adc $00,x	                adc 0,x
.a051	85 00		sta $00		                sta cp
.a053	a5 01		lda $01		                lda cp+1
.a055	75 01		adc $01,x	                adc 1,x
.a057	85 01		sta $01		                sta cp+1
.a059	b5 02		lda $02,x	                lda 2,x
.a05b	38		sec		                sec
.a05c	e9 02		sbc #$02	                sbc #2
.a05e	85 24		sta $24		                sta tmp1
.a060	b5 03		lda $03,x	                lda 3,x
.a062	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a064	85 25		sta $25		                sta tmp1+1
.a066	a5 00		lda $00		                lda cp
.a068	92 24		sta ($24)	                sta (tmp1)
.a06a	a0 01		ldy #$01	                ldy #1
.a06c	a5 01		lda $01		                lda cp+1
.a06e	91 24		sta ($24),y	                sta (tmp1),y
.a070					sliteral_const_str:
.a070	a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a072	a9 8a		lda #$8a	                lda #<sliteral_runtime
.a074	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.a077	b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a079	b5 02		lda $02,x	                lda 2,x                ; address LSB
.a07b	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.a07e	b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a080	b5 00		lda $00,x	                lda 0,x                ; length LSB
.a082	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.a085	e8		inx		                inx
.a086	e8		inx		                inx
.a087	e8		inx		                inx
.a088	e8		inx		                inx
.a089	60		rts		z_sliteral:     rts
.a08a					sliteral_runtime:
.a08a	ca		dex		                dex
.a08b	ca		dex		                dex
.a08c	ca		dex		                dex
.a08d	ca		dex		                dex
.a08e	68		pla		                pla
.a08f	85 24		sta $24		                sta tmp1        ; LSB of address
.a091	68		pla		                pla
.a092	85 25		sta $25		                sta tmp1+1      ; MSB of address
.a094	a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a096	b1 24		lda ($24),y	                lda (tmp1),y
.a098	95 02		sta $02,x	                sta 2,x         ; LSB of address
.a09a	c8		iny		                iny
.a09b	b1 24		lda ($24),y	                lda (tmp1),y
.a09d	95 03		sta $03,x	                sta 3,x         ; MSB of address
.a09f	c8		iny		                iny
.a0a0	b1 24		lda ($24),y	                lda (tmp1),y
.a0a2	95 00		sta $00,x	                sta 0,x         ; LSB of length
.a0a4	c8		iny		                iny
.a0a5	b1 24		lda ($24),y	                lda (tmp1),y
.a0a7	95 01		sta $01,x	                sta 1,x         ; MSB of length
.a0a9	18		clc		                clc
.a0aa	a5 24		lda $24		                lda tmp1
.a0ac	69 04		adc #$04	                adc #4
.a0ae	a8		tay		                tay             ; LSB
.a0af	a5 25		lda $25		                lda tmp1+1
.a0b1	69 00		adc #$00	                adc #0          ; we only need carry
.a0b3	48		pha		                pha             ; MSB
.a0b4	5a		phy		                phy
.a0b5	60		rts		                rts
.a0b6					xt_sm_slash_rem:
.a0b6	20 54 d6	jsr $d654	                jsr underflow_3 ; contains double number
.a0b9	b5 03		lda $03,x	                lda 3,x
.a0bb	48		pha		                pha
.a0bc	b5 01		lda $01,x	                lda 1,x
.a0be	55 03		eor $03,x	                eor 3,x
.a0c0	48		pha		                pha
.a0c1	20 39 81	jsr $8139	                jsr xt_abs
.a0c4	e8		inx		                inx             ; pretend we pushed n1 to R
.a0c5	e8		inx		                inx
.a0c6	20 76 8a	jsr $8a76	                jsr xt_dabs
.a0c9	ca		dex		                dex
.a0ca	ca		dex		                dex
.a0cb	20 95 a5	jsr $a595	                jsr xt_um_slash_mod     ; UM/MOD
.a0ce	68		pla		                pla
.a0cf	10 03		bpl $a0d4	                bpl +
.a0d1	20 13 96	jsr $9613	                jsr xt_negate
.a0d4					+
.a0d4	68		pla		                pla
.a0d5	10 07		bpl $a0de	                bpl _done
.a0d7	e8		inx		                inx             ; pretend we pushed quotient to R
.a0d8	e8		inx		                inx
.a0d9	20 13 96	jsr $9613	                jsr xt_negate
.a0dc	ca		dex		                dex
.a0dd	ca		dex		                dex
.a0de					_done:
.a0de	60		rts		z_sm_slash_rem: rts
.a0df					xt_source:
.a0df	ca		dex		                dex
.a0e0	ca		dex		                dex
.a0e1	a5 08		lda $08		                lda cib
.a0e3	95 00		sta $00,x	                sta 0,x
.a0e5	a5 09		lda $09		                lda cib+1
.a0e7	95 01		sta $01,x	                sta 1,x
.a0e9	ca		dex		                dex
.a0ea	ca		dex		                dex
.a0eb	a5 0a		lda $0a		                lda ciblen
.a0ed	95 00		sta $00,x	                sta 0,x
.a0ef	a5 0b		lda $0b		                lda ciblen+1
.a0f1	95 01		sta $01,x	                sta 1,x
.a0f3	60		rts		z_source:       rts
.a0f4					xt_source_id:
.a0f4	ca		dex		                dex
.a0f5	ca		dex		                dex
.a0f6	a5 06		lda $06		                lda insrc
.a0f8	95 00		sta $00,x	                sta 0,x
.a0fa	a5 07		lda $07		                lda insrc+1
.a0fc	95 01		sta $01,x	                sta 1,x
.a0fe	60		rts		z_source_id:    rts
.a0ff					xt_space:
.a0ff	a9 20		lda #$20	                lda #AscSP
.a101	20 e6 8d	jsr $8de6	                jsr emit_a
.a104	60		rts		z_space:        rts
.a105					xt_spaces:
.a105	20 4a d6	jsr $d64a	                jsr underflow_1
.a108	b5 00		lda $00,x	                lda 0,x
.a10a	15 01		ora $01,x	                ora 1,x
.a10c	f0 2a		beq $a138	                beq _done
.a10e	b4 01		ldy $01,x	                ldy 1,x
.a110	d0 0c		bne $a11e	                bne _lots_of_spaces
.a112	b4 00		ldy $00,x	                ldy 0,x
.a114					_quick_loop:
.a114	a9 20		lda #$20	                lda #AscSP
.a116	20 e6 8d	jsr $8de6	                jsr emit_a
.a119	88		dey		                dey
.a11a	f0 1c		beq $a138	                beq _done
.a11c	80 f6		bra $a114	                bra _quick_loop
.a11e					_lots_of_spaces:
.a11e	b4 00		ldy $00,x	                ldy 0,x
.a120					_first_slow_loop:
.a120	f0 08		beq $a12a	                beq _slow_outer_loop
.a122	a9 20		lda #$20	                lda #AscSP
.a124	20 e6 8d	jsr $8de6	                jsr emit_a
.a127	88		dey		                dey
.a128	80 f6		bra $a120	                bra _first_slow_loop
.a12a					_slow_outer_loop:
.a12a	a0 00		ldy #$00	                ldy #00
.a12c					_slow_inner_loop:
.a12c	a9 20		lda #$20	                lda #AscSP
.a12e	20 e6 8d	jsr $8de6	                jsr emit_a
.a131	88		dey		                dey
.a132	d0 f8		bne $a12c	                bne _slow_inner_loop
.a134	d6 01		dec $01,x	                dec 1,x
.a136	d0 f2		bne $a12a	                bne _slow_outer_loop
.a138					_done:
.a138	e8		inx		                inx             ; drop
.a139	e8		inx		                inx
.a13a	60		rts		z_spaces:       rts
.a13b					xt_star:
.a13b	20 4f d6	jsr $d64f	                jsr underflow_2
.a13e	20 d7 a5	jsr $a5d7	                jsr xt_um_star
.a141	e8		inx		                inx
.a142	e8		inx		                inx
.a143	60		rts		z_star:         rts
.a144					xt_star_slash:
.a144	20 4d a1	jsr $a14d	                jsr xt_star_slash_mod
.a147	20 89 a1	jsr $a189	                jsr xt_swap
.a14a	e8		inx		                inx
.a14b	e8		inx		                inx
.a14c					z_star_slash:
.a14c	60		rts		                rts
.a14d					xt_star_slash_mod:
.a14d	20 54 d6	jsr $d654	                jsr underflow_3
.a150	20 4b a3	jsr $a34b	                jsr xt_to_r
.a153	20 7e 94	jsr $947e	                jsr xt_m_star
.a156	20 73 9a	jsr $9a73	                jsr xt_r_from
.a159	20 b6 a0	jsr $a0b6	                jsr xt_sm_slash_rem
.a15c					z_star_slash_mod:
.a15c	60		rts		                rts
.a15d					xt_state:
.a15d	ca		dex		                dex
.a15e	ca		dex		                dex
.a15f	a9 16		lda #$16	                lda #<state
.a161	95 00		sta $00,x	                sta 0,x
.a163	a9 00		lda #$00	                lda #>state
.a165	95 01		sta $01,x	                sta 1,x
.a167	60		rts		z_state:        rts
.a168					xt_store:
.a168	20 4f d6	jsr $d64f	                jsr underflow_2
.a16b	b5 02		lda $02,x	                lda 2,x         ; LSB
.a16d	81 00		sta ($00,x)	                sta (0,x)
.a16f	f6 00		inc $00,x	                inc 0,x
.a171	d0 02		bne $a175	                bne +
.a173	f6 01		inc $01,x	                inc 1,x
.a175					+
.a175	b5 03		lda $03,x	                lda 3,x         ; MSB
.a177	81 00		sta ($00,x)	                sta (0,x)
.a179	e8		inx		                inx             ; 2DROP
.a17a	e8		inx		                inx
.a17b	e8		inx		                inx
.a17c	e8		inx		                inx
.a17d	60		rts		z_store:        rts
.a17e					xt_strip_underflow:
.a17e	ca		dex		                dex
.a17f	ca		dex		                dex
.a180	a9 1c		lda #$1c	                lda #<uf_strip
.a182	95 00		sta $00,x	                sta 0,x
.a184	a9 00		lda #$00	                lda #>uf_strip
.a186	95 01		sta $01,x	                sta 1,x
.a188					z_strip_underflow:
.a188	60		rts		                rts
.a189					xt_swap:
.a189	20 4f d6	jsr $d64f	                jsr underflow_2
.a18c	b5 00		lda $00,x	                lda 0,x         ; LSB
.a18e	b4 02		ldy $02,x	                ldy 2,x
.a190	95 02		sta $02,x	                sta 2,x
.a192	94 00		sty $00,x	                sty 0,x
.a194	b5 01		lda $01,x	                lda 1,x         ; MSB
.a196	b4 03		ldy $03,x	                ldy 3,x
.a198	95 03		sta $03,x	                sta 3,x
.a19a	94 01		sty $01,x	                sty 1,x
.a19c	60		rts		z_swap:         rts
.a19d					xt_then:
.a19d	20 62 91	jsr $9162	                jsr xt_here
.a1a0	20 89 a1	jsr $a189	                jsr xt_swap
.a1a3	20 68 a1	jsr $a168	                jsr xt_store
.a1a6	60		rts		z_then:         rts
.a1a7					xt_thru:
.a1a7	20 4f d6	jsr $d64f	                jsr underflow_2
.a1aa	b5 01		lda $01,x	                lda 1,x
.a1ac	48		pha		                pha
.a1ad	b5 00		lda $00,x	                lda 0,x
.a1af	48		pha		                pha
.a1b0	e8		inx		                inx
.a1b1	e8		inx		                inx
.a1b2					_thru_loop:
.a1b2	b5 01		lda $01,x	                lda 1,x
.a1b4	48		pha		                pha
.a1b5	b5 00		lda $00,x	                lda 0,x
.a1b7	48		pha		                pha
.a1b8	20 a7 93	jsr $93a7	                jsr xt_load
.a1bb	68		pla		                pla
.a1bc	85 24		sta $24		                sta tmp1
.a1be	68		pla		                pla
.a1bf	85 25		sta $25		                sta tmp1+1
.a1c1	68		pla		                pla
.a1c2	85 26		sta $26		                sta tmp2
.a1c4	68		pla		                pla
.a1c5	85 27		sta $27		                sta tmp2+1
.a1c7	c5 25		cmp $25		                cmp tmp1+1
.a1c9	d0 08		bne $a1d3	                bne _next_screen
.a1cb	a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a1cd	c5 24		cmp $24		                cmp tmp1
.a1cf	d0 02		bne $a1d3	                bne _next_screen
.a1d1	80 18		bra $a1eb	                bra _done       ; We just did the last screen.
.a1d3					_next_screen:
.a1d3	a5 27		lda $27		                lda tmp2+1
.a1d5	48		pha		                pha
.a1d6	a5 26		lda $26		                lda tmp2
.a1d8	48		pha		                pha
.a1d9	e6 24		inc $24		                inc tmp1
.a1db	d0 02		bne $a1df	                bne +
.a1dd	e6 25		inc $25		                inc tmp1+1
.a1df					+
.a1df	ca		dex		                dex
.a1e0	ca		dex		                dex
.a1e1	a5 24		lda $24		                lda tmp1
.a1e3	95 00		sta $00,x	                sta 0,x
.a1e5	a5 25		lda $25		                lda tmp1+1
.a1e7	95 01		sta $01,x	                sta 1,x
.a1e9	80 c7		bra $a1b2	                bra _thru_loop
.a1eb					_done:
.a1eb	60		rts		z_thru:         rts
.a1ec					xt_tick:
.a1ec	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( -- addr u )
.a1ef	b5 00		lda $00,x	                lda 0,x
.a1f1	15 01		ora $01,x	                ora 1,x
.a1f3	d0 05		bne $a1fa	                bne +
.a1f5	a9 05		lda #$05	                lda #err_noname
.a1f7	4c 60 d6	jmp $d660	                jmp error
.a1fa					+
.a1fa	20 cb 8f	jsr $8fcb	                jsr xt_find_name        ; ( addr u -- nt )
.a1fd	b5 00		lda $00,x	                lda 0,x
.a1ff	15 01		ora $01,x	                ora 1,x
.a201	d0 05		bne $a208	                bne +
.a203	a9 08		lda #$08	                lda #err_syntax
.a205	4c 60 d6	jmp $d660	                jmp error
.a208					+
.a208	20 d1 95	jsr $95d1	                jsr xt_name_to_int      ; ( nt -- xt )
.a20b	60		rts		z_tick:         rts
.a20c					xt_to:
.a20c	20 ec a1	jsr $a1ec	                jsr xt_tick             ; ( [n] xt )
.a20f	b5 00		lda $00,x	                lda 0,x                 ; LSB
.a211	18		clc		                clc
.a212	69 03		adc #$03	                adc #3
.a214	85 24		sta $24		                sta tmp1
.a216	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a218	69 00		adc #$00	                adc #0                  ; we just want the carry
.a21a	85 25		sta $25		                sta tmp1+1
.a21c	e8		inx		                inx
.a21d	e8		inx		                inx                     ; ( [n] )
.a21e	a5 16		lda $16		                lda state
.a220	05 17		ora $17		                ora state+1
.a222	f0 34		beq $a258	                beq _interpret
.a224	a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a226	a9 b5		lda #$b5	                lda #$B5
.a228	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.a22b	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a22d	20 fd d4	jsr $d4fd	                jsr cmpl_a
.a230	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a232	a5 24		lda $24		                lda tmp1
.a234	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.a237	a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a239	a9 b5		lda #$b5	                lda #$B5
.a23b	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.a23e	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a240	20 fd d4	jsr $d4fd	                jsr cmpl_a
.a243	e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a245	d0 02		bne $a249	                bne +
.a247	e6 25		inc $25		                inc tmp1+1
.a249					+
.a249	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a24b	a5 24		lda $24		                lda tmp1
.a24d	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.a250	a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a252	98		tya		                tya
.a253	20 f9 d4	jsr $d4f9	                jsr cmpl_word
.a256	80 0f		bra $a267	                bra _done
.a258					_interpret:
.a258	20 4a d6	jsr $d64a	                jsr underflow_1
.a25b	b5 00		lda $00,x	                lda 0,x
.a25d	92 24		sta ($24)	                sta (tmp1)              ; LSB
.a25f	a0 01		ldy #$01	                ldy #1
.a261	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a263	91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a265	e8		inx		                inx                     ; DROP
.a266	e8		inx		                inx
.a267					_done:
.a267	60		rts		z_to:           rts
.a268					xt_to_body:
.a268	20 4a d6	jsr $d64a	                jsr underflow_1
.a26b	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( xt xt )
.a26e	20 68 92	jsr $9268	                jsr xt_int_to_name      ; ( xt nt )
.a271	f6 00		inc $00,x	                inc 0,x
.a273	d0 02		bne $a277	                bne +
.a275	f6 01		inc $01,x	                inc 1,x
.a277					+
.a277	a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a279	29 20		and #$20	                and #HC
.a27b	f0 0d		beq $a28a	                beq _no_cfa
.a27d	18		clc		                clc
.a27e	b5 02		lda $02,x	                lda 2,x         ; LSB
.a280	69 03		adc #$03	                adc #3
.a282	95 02		sta $02,x	                sta 2,x
.a284	b5 03		lda $03,x	                lda 3,x         ; MSB
.a286	69 00		adc #$00	                adc #0          ; we conly care about the carry
.a288	95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a28a					_no_cfa:
.a28a	e8		inx		                inx             ; get rid of the nt
.a28b	e8		inx		                inx
.a28c					_done:
.a28c	60		rts		z_to_body:      rts
.a28d					xt_to_in:
.a28d	ca		dex		                dex
.a28e	ca		dex		                dex
.a28f	a9 0c		lda #$0c	                lda #<toin
.a291	95 00		sta $00,x	                sta 0,x
.a293	a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a295	95 01		sta $01,x	                sta 1,x
.a297	60		rts		z_to_in:        rts
.a298					xt_to_number:
.a298	20 59 d6	jsr $d659	                jsr underflow_4
.a29b	b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a29d	85 36		sta $36		                sta scratch
.a29f	b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a2a1	85 37		sta $37		                sta scratch+1
.a2a3	b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a2a5	85 38		sta $38		                sta scratch+2
.a2a7	b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a2a9	85 39		sta $39		                sta scratch+3
.a2ab	ca		dex		                dex
.a2ac	ca		dex		                dex
.a2ad					_loop:
.a2ad	a1 04		lda ($04,x)	                lda (4,x)
.a2af	95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a2b1	74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2b3	20 f5 8a	jsr $8af5	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a2b6	b5 00		lda $00,x	                lda 0,x
.a2b8	d0 04		bne $a2be	                bne _digit_ok
.a2ba	e8		inx		                inx
.a2bb	e8		inx		                inx
.a2bc	80 67		bra $a325	                bra _done       ; ( ud-lo ud-hi addr u char )
.a2be					_digit_ok:
.a2be	b5 02		lda $02,x	                lda 2,x
.a2c0	85 3a		sta $3a		                sta scratch+4
.a2c2	b5 03		lda $03,x	                lda 3,x
.a2c4	85 3b		sta $3b		                sta scratch+5
.a2c6	a5 38		lda $38		                lda scratch+2
.a2c8	95 02		sta $02,x	                sta 2,x         ; NOS
.a2ca	a5 39		lda $39		                lda scratch+3
.a2cc	95 03		sta $03,x	                sta 3,x
.a2ce	a5 18		lda $18		                lda base
.a2d0	95 00		sta $00,x	                sta 0,x         ; TOS
.a2d2	74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a2d4	20 d7 a5	jsr $a5d7	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2d7	b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a2d9	85 3c		sta $3c		                sta scratch+6
.a2db	b5 03		lda $03,x	                lda 3,x
.a2dd	85 3d		sta $3d		                sta scratch+7
.a2df	a5 36		lda $36		                lda scratch
.a2e1	95 02		sta $02,x	                sta 2,x
.a2e3	a5 37		lda $37		                lda scratch+1
.a2e5	95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a2e7	a5 18		lda $18		                lda base
.a2e9	95 00		sta $00,x	                sta 0,x
.a2eb	74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a2ed	20 d7 a5	jsr $a5d7	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a2f0	b5 00		lda $00,x	                lda 0,x
.a2f2	85 38		sta $38		                sta scratch+2
.a2f4	b5 01		lda $01,x	                lda 1,x
.a2f6	85 39		sta $39		                sta scratch+3
.a2f8	b5 02		lda $02,x	                lda 2,x
.a2fa	85 36		sta $36		                sta scratch
.a2fc	b5 03		lda $03,x	                lda 3,x
.a2fe	85 37		sta $37		                sta scratch+1
.a300	18		clc		                clc
.a301	a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a303	65 3a		adc $3a		                adc scratch+4   ; n LSB
.a305	85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a307	a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a309	65 3b		adc $3b		                adc scratch+5   ; n MSB
.a30b	85 37		sta $37		                sta scratch+1
.a30d	a5 38		lda $38		                lda scratch+2   ; LSB
.a30f	65 3c		adc $3c		                adc scratch+6
.a311	85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a313	a5 39		lda $39		                lda scratch+3   ; MSB
.a315	65 3d		adc $3d		                adc scratch+7
.a317	85 39		sta $39		                sta scratch+3
.a319	e8		inx		                inx
.a31a	e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a31b	f6 04		inc $04,x	                inc 4,x
.a31d	d0 02		bne $a321	                bne +
.a31f	f6 05		inc $05,x	                inc 5,x
.a321					+
.a321	d6 02		dec $02,x	                dec 2,x
.a323	d0 88		bne $a2ad	                bne _loop
.a325					_done:
.a325	e8		inx		                inx
.a326	e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a327	a5 36		lda $36		                lda scratch     ; new ud-lo
.a329	95 06		sta $06,x	                sta 6,x
.a32b	a5 37		lda $37		                lda scratch+1
.a32d	95 07		sta $07,x	                sta 7,x
.a32f	a5 38		lda $38		                lda scratch+2
.a331	95 04		sta $04,x	                sta 4,x
.a333	a5 39		lda $39		                lda scratch+3
.a335	95 05		sta $05,x	                sta 5,x
.a337	60		rts		z_to_number:    rts
.a338					xt_to_order:
.a338	20 4b a3	jsr $a34b	                jsr xt_to_r
.a33b	20 24 91	jsr $9124	                jsr xt_get_order
.a33e	20 73 9a	jsr $9a73	                jsr xt_r_from
.a341	20 89 a1	jsr $a189	                jsr xt_swap
.a344	20 fe 97	jsr $97fe	                jsr xt_one_plus
.a347	20 fc 9c	jsr $9cfc	                jsr xt_set_order
.a34a	60		rts		z_to_order:     rts
.a34b					xt_to_r:
.a34b	68		pla		                pla             ; LSB
.a34c	85 2c		sta $2c		                sta tmptos
.a34e	7a		ply		                ply             ; MSB
.a34f	20 4a d6	jsr $d64a	                jsr underflow_1
.a352	b5 01		lda $01,x	                lda 1,x         ; MSB
.a354	48		pha		                pha
.a355	b5 00		lda $00,x	                lda 0,x         ; LSB
.a357	48		pha		                pha
.a358	e8		inx		                inx
.a359	e8		inx		                inx
.a35a	5a		phy		                phy             ; MSB
.a35b	a5 2c		lda $2c		                lda tmptos
.a35d	48		pha		                pha             ; LSB
.a35e	60		rts		z_to_r:         rts
.a35f					xt_true:
.a35f	ca		dex		                dex
.a360	ca		dex		                dex
.a361	a9 ff		lda #$ff	                lda #$FF
.a363	95 00		sta $00,x	                sta 0,x
.a365	95 01		sta $01,x	                sta 1,x
.a367	60		rts		z_true:         rts
.a368					xt_tuck:
.a368	20 4f d6	jsr $d64f	                jsr underflow_2
.a36b	ca		dex		                dex
.a36c	ca		dex		                dex
.a36d	b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a36f	b5 02		lda $02,x	                lda 2,x
.a371	95 04		sta $04,x	                sta 4,x
.a373	94 02		sty $02,x	                sty 2,x
.a375	95 00		sta $00,x	                sta 0,x
.a377	b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a379	b5 03		lda $03,x	                lda 3,x
.a37b	95 05		sta $05,x	                sta 5,x
.a37d	94 03		sty $03,x	                sty 3,x         ; bba
.a37f	95 01		sta $01,x	                sta 1,x         ; baa
.a381	60		rts		z_tuck:         rts
.a382					xt_assembler_wordlist:
.a382					xt_two:
.a382	ca		dex		                dex
.a383	ca		dex		                dex
.a384	a9 02		lda #$02	                lda #2
.a386	95 00		sta $00,x	                sta 0,x
.a388	74 01		stz $01,x	                stz 1,x
.a38a					z_assembler_wordlist:
.a38a	60		rts		z_two:          rts
.a38b					xt_two_drop:
.a38b	20 4f d6	jsr $d64f	                jsr underflow_2
.a38e	e8		inx		                inx
.a38f	e8		inx		                inx
.a390	e8		inx		                inx
.a391	e8		inx		                inx
.a392	60		rts		z_two_drop:     rts
.a393					xt_two_dup:
.a393	20 4f d6	jsr $d64f	                jsr underflow_2
.a396	ca		dex		                dex
.a397	ca		dex		                dex
.a398	ca		dex		                dex
.a399	ca		dex		                dex
.a39a	b5 04		lda $04,x	                lda 4,x         ; TOS
.a39c	95 00		sta $00,x	                sta 0,x
.a39e	b5 05		lda $05,x	                lda 5,x
.a3a0	95 01		sta $01,x	                sta 1,x
.a3a2	b5 06		lda $06,x	                lda 6,x         ; NOS
.a3a4	95 02		sta $02,x	                sta 2,x
.a3a6	b5 07		lda $07,x	                lda 7,x
.a3a8	95 03		sta $03,x	                sta 3,x
.a3aa	60		rts		z_two_dup:      rts
.a3ab					xt_two_fetch:
.a3ab	20 4a d6	jsr $d64a	                jsr underflow_1
.a3ae	b5 00		lda $00,x	                lda 0,x
.a3b0	85 24		sta $24		                sta tmp1
.a3b2	b4 01		ldy $01,x	                ldy 1,x
.a3b4	84 25		sty $25		                sty tmp1+1
.a3b6	ca		dex		                dex             ; reuse one stack element
.a3b7	ca		dex		                dex
.a3b8	b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a3ba	95 00		sta $00,x	                sta 0,x
.a3bc	a0 01		ldy #$01	                ldy #1          ; copy next
.a3be	b1 24		lda ($24),y	                lda (tmp1),y
.a3c0	95 01		sta $01,x	                sta 1,x
.a3c2	c8		iny		                iny             ; copy next
.a3c3	b1 24		lda ($24),y	                lda (tmp1),y
.a3c5	95 02		sta $02,x	                sta 2,x
.a3c7	c8		iny		                iny             ; copy next
.a3c8	b1 24		lda ($24),y	                lda (tmp1),y
.a3ca	95 03		sta $03,x	                sta 3,x
.a3cc	60		rts		z_two_fetch:    rts
.a3cd					xt_two_over:
.a3cd	20 59 d6	jsr $d659	                jsr underflow_4
.a3d0	ca		dex		                dex
.a3d1	ca		dex		                dex
.a3d2	ca		dex		                dex
.a3d3	ca		dex		                dex
.a3d4	b5 08		lda $08,x	                lda 8,x
.a3d6	95 00		sta $00,x	                sta 0,x
.a3d8	b5 09		lda $09,x	                lda 9,x
.a3da	95 01		sta $01,x	                sta 1,x
.a3dc	b5 0a		lda $0a,x	                lda 10,x
.a3de	95 02		sta $02,x	                sta 2,x
.a3e0	b5 0b		lda $0b,x	                lda 11,x
.a3e2	95 03		sta $03,x	                sta 3,x
.a3e4	60		rts		z_two_over:     rts
.a3e5					xt_two_r_fetch:
.a3e5	ca		dex		                dex
.a3e6	ca		dex		                dex
.a3e7	ca		dex		                dex
.a3e8	ca		dex		                dex
.a3e9	8a		txa		                txa
.a3ea	ba		tsx		                tsx
.a3eb	da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a3ec	7a		ply		                ply
.a3ed	aa		tax		                tax
.a3ee	b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a3f1	95 00		sta $00,x	                sta 0,x
.a3f3	b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a3f6	95 01		sta $01,x	                sta 1,x
.a3f8	b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a3fb	95 02		sta $02,x	                sta 2,x
.a3fd	b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a400	95 03		sta $03,x	                sta 3,x
.a402	60		rts		z_two_r_fetch:  rts
.a403					xt_two_r_from:
.a403	68		pla		                pla                     ; LSB
.a404	85 24		sta $24		                sta tmp1
.a406	68		pla		                pla                     ; MSB
.a407	85 25		sta $25		                sta tmp1+1
.a409	ca		dex		                dex
.a40a	ca		dex		                dex
.a40b	ca		dex		                dex
.a40c	ca		dex		                dex
.a40d	68		pla		                pla                     ; LSB
.a40e	95 00		sta $00,x	                sta 0,x
.a410	68		pla		                pla                     ; MSB
.a411	95 01		sta $01,x	                sta 1,x
.a413	68		pla		                pla                     ; LSB
.a414	95 02		sta $02,x	                sta 2,x
.a416	68		pla		                pla                     ; MSB
.a417	95 03		sta $03,x	                sta 3,x
.a419	a5 25		lda $25		                lda tmp1+1              ; MSB
.a41b	48		pha		                pha
.a41c	a5 24		lda $24		                lda tmp1                ; LSB
.a41e	48		pha		                pha
.a41f	60		rts		z_two_r_from:   rts
.a420					xt_two_slash:
.a420	20 4a d6	jsr $d64a	                jsr underflow_1
.a423	b5 01		lda $01,x	                lda 1,x
.a425	0a		asl a		                asl                     ; save the sign
.a426	76 01		ror $01,x	                ror 1,x
.a428	76 00		ror $00,x	                ror 0,x
.a42a	60		rts		z_two_slash:    rts
.a42b					xt_two_star:
.a42b					xt_cells:
.a42b	20 4a d6	jsr $d64a	                jsr underflow_1
.a42e	16 00		asl $00,x	                asl 0,x
.a430	36 01		rol $01,x	                rol 1,x
.a432					z_cells:
.a432	60		rts		z_two_star:     rts
.a433					xt_two_store:
.a433	20 54 d6	jsr $d654	                jsr underflow_3
.a436	b5 00		lda $00,x	                lda 0,x
.a438	85 24		sta $24		                sta tmp1
.a43a	b4 01		ldy $01,x	                ldy 1,x
.a43c	84 25		sty $25		                sty tmp1+1
.a43e	e8		inx		                inx
.a43f	e8		inx		                inx
.a440	b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a442	92 24		sta ($24)	                sta (tmp1)
.a444	b5 01		lda $01,x	                lda 1,x         ; copy next
.a446	a0 01		ldy #$01	                ldy #1
.a448	91 24		sta ($24),y	                sta (tmp1),y
.a44a	b5 02		lda $02,x	                lda 2,x         ; copy next
.a44c	c8		iny		                iny
.a44d	91 24		sta ($24),y	                sta (tmp1),y
.a44f	b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a451	c8		iny		                iny
.a452	91 24		sta ($24),y	                sta (tmp1),y
.a454	e8		inx		                inx             ; 2DROP
.a455	e8		inx		                inx
.a456	e8		inx		                inx
.a457	e8		inx		                inx
.a458	60		rts		z_two_store:    rts
.a459					xt_two_swap:
.a459	20 59 d6	jsr $d659	                jsr underflow_4
.a45c	b5 00		lda $00,x	                lda 0,x
.a45e	b4 04		ldy $04,x	                ldy 4,x
.a460	95 04		sta $04,x	                sta 4,x
.a462	94 00		sty $00,x	                sty 0,x
.a464	b5 01		lda $01,x	                lda 1,x
.a466	b4 05		ldy $05,x	                ldy 5,x
.a468	95 05		sta $05,x	                sta 5,x
.a46a	94 01		sty $01,x	                sty 1,x
.a46c	b5 02		lda $02,x	                lda 2,x
.a46e	b4 06		ldy $06,x	                ldy 6,x
.a470	95 06		sta $06,x	                sta 6,x
.a472	94 02		sty $02,x	                sty 2,x
.a474	b5 03		lda $03,x	                lda 3,x
.a476	b4 07		ldy $07,x	                ldy 7,x
.a478	95 07		sta $07,x	                sta 7,x
.a47a	94 03		sty $03,x	                sty 3,x
.a47c	60		rts		z_two_swap:     rts
.a47d					xt_two_to_r:
.a47d	68		pla		                pla             ; LSB
.a47e	85 24		sta $24		                sta tmp1
.a480	68		pla		                pla             ; MSB
.a481	85 25		sta $25		                sta tmp1+1
.a483	20 4f d6	jsr $d64f	                jsr underflow_2
.a486	b5 03		lda $03,x	                lda 3,x         ; MSB
.a488	48		pha		                pha
.a489	b5 02		lda $02,x	                lda 2,x         ; LSB
.a48b	48		pha		                pha
.a48c	b5 01		lda $01,x	                lda 1,x         ; MSB
.a48e	48		pha		                pha
.a48f	b5 00		lda $00,x	                lda 0,x         ; LSB
.a491	48		pha		                pha
.a492	e8		inx		                inx
.a493	e8		inx		                inx
.a494	e8		inx		                inx
.a495	e8		inx		                inx
.a496	a5 25		lda $25		                lda tmp1+1      ; MSB
.a498	48		pha		                pha
.a499	a5 24		lda $24		                lda tmp1        ; LSB
.a49b	48		pha		                pha
.a49c	60		rts		z_two_to_r:     rts
.a49d					xt_two_constant:
.a49d	20 4f d6	jsr $d64f	                jsr underflow_2
.a4a0	20 59 89	jsr $8959	                jsr xt_create
.a4a3	20 89 a1	jsr $a189	                jsr xt_swap
.a4a6	20 5e 87	jsr $875e	                jsr xt_comma
.a4a9	20 5e 87	jsr $875e	                jsr xt_comma
.a4ac	20 f4 8b	jsr $8bf4	                jsr does_runtime    ; does> turns into these two routines.
.a4af	20 33 d5	jsr $d533	                jsr dodoes
.a4b2	20 9f 8d	jsr $8d9f	                jsr xt_dup
.a4b5	20 70 8f	jsr $8f70	                jsr xt_fetch
.a4b8	20 89 a1	jsr $a189	                jsr xt_swap
.a4bb	20 11 86	jsr $8611	                jsr xt_cell_plus
.a4be	20 70 8f	jsr $8f70	                jsr xt_fetch
.a4c1	60		rts		z_two_constant: rts
.a4c2					xt_two_literal:
.a4c2	20 4f d6	jsr $d64f	                jsr underflow_2 ; double number
.a4c5	20 89 a1	jsr $a189	                jsr xt_swap
.a4c8	20 7a 93	jsr $937a	                jsr xt_literal
.a4cb	20 7a 93	jsr $937a	                jsr xt_literal
.a4ce	60		rts		z_two_literal:  rts
.a4cf					xt_two_variable:
.a4cf	20 59 89	jsr $8959	                jsr xt_create
.a4d2	ca		dex		                dex
.a4d3	ca		dex		                dex
.a4d4	a9 04		lda #$04	                lda #4
.a4d6	95 00		sta $00,x	                sta 0,x
.a4d8	74 01		stz $01,x	                stz 1,x
.a4da	20 ab 82	jsr $82ab	                jsr xt_allot
.a4dd	60		rts		z_two_variable: rts
.a4de					xt_type:
.a4de	20 4f d6	jsr $d64f	                jsr underflow_2
.a4e1	b5 02		lda $02,x	                lda 2,x
.a4e3	85 24		sta $24		                sta tmp1
.a4e5	b5 03		lda $03,x	                lda 3,x
.a4e7	85 25		sta $25		                sta tmp1+1
.a4e9					_loop:
.a4e9	b5 00		lda $00,x	                lda 0,x
.a4eb	15 01		ora $01,x	                ora 1,x
.a4ed	f0 15		beq $a504	                beq _done
.a4ef	b2 24		lda ($24)	                lda (tmp1)
.a4f1	20 e6 8d	jsr $8de6	                jsr emit_a      ; avoids stack foolery
.a4f4	e6 24		inc $24		                inc tmp1
.a4f6	d0 02		bne $a4fa	                bne +
.a4f8	e6 25		inc $25		                inc tmp1+1
.a4fa					+
.a4fa	b5 00		lda $00,x	                lda 0,x
.a4fc	d0 02		bne $a500	                bne +
.a4fe	d6 01		dec $01,x	                dec 1,x
.a500					+
.a500	d6 00		dec $00,x	                dec 0,x
.a502	80 e5		bra $a4e9	                bra _loop
.a504					_done:
.a504	e8		inx		                inx
.a505	e8		inx		                inx
.a506	e8		inx		                inx
.a507	e8		inx		                inx
.a508	60		rts		z_type:         rts
.a509					xt_u_dot:
.a509	20 4a d6	jsr $d64a	                jsr underflow_1
.a50c	20 96 d6	jsr $d696	                jsr print_u
.a50f	a9 20		lda #$20	                lda #AscSP
.a511	20 e6 8d	jsr $8de6	                jsr emit_a
.a514	60		rts		z_u_dot:        rts
.a515					xt_u_dot_r:
.a515	20 4f d6	jsr $d64f	                jsr underflow_2
.a518	20 4b a3	jsr $a34b	                jsr xt_to_r
.a51b	20 82 a7	jsr $a782	                jsr xt_zero
.a51e	20 4a 93	jsr $934a	                jsr xt_less_number_sign
.a521	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.a524	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.a527	20 73 9a	jsr $9a73	                jsr xt_r_from
.a52a	20 74 98	jsr $9874	                jsr xt_over
.a52d	20 40 95	jsr $9540	                jsr xt_minus
.a530	20 05 a1	jsr $a105	                jsr xt_spaces
.a533	20 de a4	jsr $a4de	                jsr xt_type
.a536	60		rts		z_u_dot_r:      rts
.a537					xt_u_greater_than:
.a537	20 4f d6	jsr $d64f	                jsr underflow_2
.a53a	b5 00		lda $00,x	                lda 0,x
.a53c	d5 02		cmp $02,x	                cmp 2,x
.a53e	b5 01		lda $01,x	                lda 1,x
.a540	f5 03		sbc $03,x	                sbc 3,x
.a542	e8		inx		                inx
.a543	e8		inx		                inx
.a544	a9 00		lda #$00	                lda #0
.a546	69 ff		adc #$ff	                adc #$ff
.a548	95 00		sta $00,x	                sta 0,x         ; store flag
.a54a	95 01		sta $01,x	                sta 1,x
.a54c	60		rts		z_u_greater_than:    rts
.a54d					xt_u_less_than:
.a54d	20 4f d6	jsr $d64f	                jsr underflow_2
.a550	b5 02		lda $02,x	                lda 2,x
.a552	d5 00		cmp $00,x	                cmp 0,x
.a554	b5 03		lda $03,x	                lda 3,x
.a556	f5 01		sbc $01,x	                sbc 1,x
.a558	e8		inx		                inx
.a559	e8		inx		                inx
.a55a	a9 00		lda #$00	                lda #0
.a55c	69 ff		adc #$ff	                adc #$ff
.a55e	95 00		sta $00,x	                sta 0,x         ; store flag
.a560	95 01		sta $01,x	                sta 1,x
.a562	60		rts		z_u_less_than:    rts
.a563					xt_ud_dot:
.a563	20 4f d6	jsr $d64f	                jsr underflow_2 ; double number
.a566	20 4a 93	jsr $934a	                jsr xt_less_number_sign
.a569	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.a56c	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.a56f	20 de a4	jsr $a4de	                jsr xt_type
.a572	20 ff a0	jsr $a0ff	                jsr xt_space
.a575	60		rts		z_ud_dot:        rts
.a576					xt_ud_dot_r:
.a576	20 54 d6	jsr $d654	                jsr underflow_3
.a579	20 4b a3	jsr $a34b	                jsr xt_to_r
.a57c	20 4a 93	jsr $934a	                jsr xt_less_number_sign
.a57f	20 bf 97	jsr $97bf	                jsr xt_number_sign_s
.a582	20 9d 97	jsr $979d	                jsr xt_number_sign_greater
.a585	20 73 9a	jsr $9a73	                jsr xt_r_from
.a588	20 74 98	jsr $9874	                jsr xt_over
.a58b	20 40 95	jsr $9540	                jsr xt_minus
.a58e	20 05 a1	jsr $a105	                jsr xt_spaces
.a591	20 de a4	jsr $a4de	                jsr xt_type
.a594	60		rts		z_ud_dot_r:      rts
.a595					xt_um_slash_mod:
.a595	20 54 d6	jsr $d654	                jsr underflow_3
.a598	b5 00		lda $00,x	                lda 0,x
.a59a	15 01		ora $01,x	                ora 1,x
.a59c	d0 05		bne $a5a3	                bne _not_zero
.a59e	a9 04		lda #$04	                lda #err_divzero
.a5a0	4c 60 d6	jmp $d660	                jmp error
.a5a3					_not_zero:
.a5a3	a9 11		lda #$11	                lda #17
.a5a5	85 2c		sta $2c		                sta tmptos
.a5a7					_loop:
.a5a7	36 04		rol $04,x	                rol 4,x
.a5a9	36 05		rol $05,x	                rol 5,x
.a5ab	c6 2c		dec $2c		                dec tmptos
.a5ad	f0 22		beq $a5d1	                beq _done
.a5af	36 02		rol $02,x	                rol 2,x
.a5b1	36 03		rol $03,x	                rol 3,x
.a5b3	64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a5b5	26 24		rol $24		                rol tmp1
.a5b7	38		sec		                sec
.a5b8	b5 02		lda $02,x	                lda 2,x
.a5ba	f5 00		sbc $00,x	                sbc 0,x
.a5bc	85 25		sta $25		                sta tmp1+1
.a5be	b5 03		lda $03,x	                lda 3,x
.a5c0	f5 01		sbc $01,x	                sbc 1,x
.a5c2	a8		tay		                tay
.a5c3	a5 24		lda $24		                lda tmp1
.a5c5	e9 00		sbc #$00	                sbc #0
.a5c7	90 de		bcc $a5a7	                bcc _loop
.a5c9	a5 25		lda $25		                lda tmp1+1
.a5cb	95 02		sta $02,x	                sta 2,x
.a5cd	94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a5cf	80 d6		bra $a5a7	                bra _loop
.a5d1					_done:
.a5d1	e8		inx		                inx
.a5d2	e8		inx		                inx
.a5d3	20 89 a1	jsr $a189	                jsr xt_swap
.a5d6	60		rts		z_um_slash_mod: rts
.a5d7					xt_um_star:
.a5d7	20 4f d6	jsr $d64f	                jsr underflow_2
.a5da	18		clc		                clc
.a5db	b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a5dd	e9 00		sbc #$00	                sbc #0
.a5df	85 26		sta $26		                sta tmp2
.a5e1	b5 01		lda $01,x	                lda 1,x
.a5e3	e9 00		sbc #$00	                sbc #0
.a5e5	90 31		bcc $a618	                bcc _zero       ; is TOS zero?
.a5e7	85 27		sta $27		                sta tmp2+1
.a5e9	a9 00		lda #$00	                lda #0
.a5eb	85 24		sta $24		                sta tmp1
.a5ed	86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a5ef	ca		dex		                dex
.a5f0	ca		dex		                dex
.a5f1					_outer_loop:
.a5f1	a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a5f3	56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a5f5					_inner_loop:
.a5f5	90 0c		bcc $a603	                bcc _no_add
.a5f7	85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a5f9	a5 24		lda $24		                lda tmp1
.a5fb	65 26		adc $26		                adc tmp2
.a5fd	85 24		sta $24		                sta tmp1
.a5ff	a5 25		lda $25		                lda tmp1+1
.a601	65 27		adc $27		                adc tmp2+1
.a603					_no_add:
.a603	6a		ror a		                ror
.a604	66 24		ror $24		                ror tmp1
.a606	76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a608	88		dey		                dey
.a609	d0 ea		bne $a5f5	                bne _inner_loop ; go back for one more shift?
.a60b	e8		inx		                inx
.a60c	e4 28		cpx $28		                cpx tmp3
.a60e	d0 e1		bne $a5f1	                bne _outer_loop ; go back for eight more shifts?
.a610	95 01		sta $01,x	                sta 1,x
.a612	a5 24		lda $24		                lda tmp1
.a614	95 00		sta $00,x	                sta 0,x
.a616	80 04		bra $a61c	                bra _done
.a618					_zero:
.a618	74 02		stz $02,x	                stz 2,x
.a61a	74 03		stz $03,x	                stz 3,x
.a61c					_done:
.a61c	60		rts		z_um_star:      rts
.a61d					xt_unloop:
.a61d	68		pla		                pla
.a61e	68		pla		                pla
.a61f	68		pla		                pla
.a620	68		pla		                pla
.a621	68		pla		                pla
.a622	68		pla		                pla
.a623	60		rts		z_unloop:       rts
.a624					xt_until:
.a624	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a626	a9 04		lda #$04	                lda #<zero_branch_runtime
.a628	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.a62b	20 5e 87	jsr $875e	                jsr xt_comma
.a62e	60		rts		z_until:        rts
.a62f					xt_unused:
.a62f	ca		dex		                dex
.a630	ca		dex		                dex
.a631	a9 00		lda #$00	                lda #<cp_end
.a633	38		sec		                sec
.a634	e5 00		sbc $00		                sbc cp
.a636	95 00		sta $00,x	                sta 0,x
.a638	a9 7c		lda #$7c	                lda #>cp_end
.a63a	e5 01		sbc $01		                sbc cp+1
.a63c	95 01		sta $01,x	                sta 1,x
.a63e	60		rts		z_unused:       rts
.a63f					xt_update:
.a63f	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a641	b1 1e		lda ($1e),y	                lda (up),y
.a643	09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a645	91 1e		sta ($1e),y	                sta (up),y
.a647	60		rts		z_update:       rts
.a648					xt_useraddr:
.a648	ca		dex		                dex
.a649	ca		dex		                dex
.a64a	a9 1e		lda #$1e	                lda #<up
.a64c	95 00		sta $00,x	                sta 0,x
.a64e	a9 00		lda #$00	                lda #>up
.a650	95 01		sta $01,x	                sta 1,x
.a652	60		rts		z_useraddr:     rts
.a653					xt_variable:
.a653	20 59 89	jsr $8959	                jsr xt_create
.a656	a9 00		lda #$00	                lda #0
.a658	92 00		sta ($00)	                sta (cp)
.a65a	e6 00		inc $00		                inc cp
.a65c	d0 02		bne $a660	                bne +
.a65e	e6 01		inc $01		                inc cp+1
.a660					+
.a660	92 00		sta ($00)	                sta (cp)
.a662	e6 00		inc $00		                inc cp
.a664	d0 02		bne $a668	                bne +
.a666	e6 01		inc $01		                inc cp+1
.a668					+
.a668	20 21 89	jsr $8921	                jsr adjust_z
.a66b	60		rts		z_variable:     rts
.a66c					xt_while:
.a66c	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a66e	a9 04		lda #$04	                lda #<zero_branch_runtime
.a670	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.a673	20 62 91	jsr $9162	                jsr xt_here
.a676	20 82 a7	jsr $a782	                jsr xt_zero
.a679	20 5e 87	jsr $875e	                jsr xt_comma
.a67c	20 89 a1	jsr $a189	                jsr xt_swap
.a67f	60		rts		z_while:        rts
.a680					xt_within:
.a680	20 54 d6	jsr $d654	                jsr underflow_3
.a683	20 74 98	jsr $9874	                jsr xt_over
.a686	20 40 95	jsr $9540	                jsr xt_minus
.a689	20 4b a3	jsr $a34b	                jsr xt_to_r
.a68c	20 40 95	jsr $9540	                jsr xt_minus
.a68f	20 73 9a	jsr $9a73	                jsr xt_r_from
.a692	20 4d a5	jsr $a54d	                jsr xt_u_less_than
.a695	60		rts		z_within:       rts
.a696					xt_word:
.a696	20 4a d6	jsr $d64a	                jsr underflow_1
.a699	a4 0c		ldy $0c		                ldy toin                ; >IN
.a69b					_loop:
.a69b	c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a69d	f0 09		beq $a6a8	                beq _found_char
.a69f	b1 08		lda ($08),y	                lda (cib),y
.a6a1	d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a6a3	d0 03		bne $a6a8	                bne _found_char
.a6a5	c8		iny		                iny
.a6a6	80 f3		bra $a69b	                bra _loop
.a6a8					_found_char:
.a6a8	84 0c		sty $0c		                sty toin
.a6aa	20 1b 99	jsr $991b	                jsr xt_parse            ; Returns ( addr u )
.a6ad	b5 00		lda $00,x	                lda 0,x
.a6af	92 00		sta ($00)	                sta (cp)                ; Save length of string
.a6b1	48		pha		                pha                     ; Keep copy of length for later
.a6b2	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( addr u u )
.a6b5	a5 00		lda $00		                lda cp
.a6b7	18		clc		                clc
.a6b8	69 01		adc #$01	                adc #1
.a6ba	95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a6bc	a5 01		lda $01		                lda cp+1
.a6be	69 00		adc #$00	                adc #0
.a6c0	95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a6c2	20 b2 95	jsr $95b2	                jsr xt_move
.a6c5	ca		dex		                dex
.a6c6	ca		dex		                dex
.a6c7	a5 00		lda $00		                lda cp
.a6c9	95 00		sta $00,x	                sta 0,x
.a6cb	a5 01		lda $01		                lda cp+1
.a6cd	95 01		sta $01,x	                sta 1,x
.a6cf	68		pla		                pla                     ; length of string
.a6d0	18		clc		                clc
.a6d1	65 00		adc $00		                adc cp
.a6d3	85 00		sta $00		                sta cp
.a6d5	a5 01		lda $01		                lda cp+1
.a6d7	69 00		adc #$00	                adc #0                  ; we only need the carry
.a6d9	85 01		sta $01		                sta cp+1
.a6db	60		rts		z_word:         rts
.a6dc					xt_wordlist:
.a6dc	a0 05		ldy #$05	                ldy #num_wordlists_offset
.a6de	b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a6e0	c9 0c		cmp #$0c	                cmp #max_wordlists
.a6e2	d0 05		bne $a6e9	                bne _ok
.a6e4	a9 0b		lda #$0b	                lda #err_wordlist
.a6e6	4c 60 d6	jmp $d660	                jmp error
.a6e9					_ok:
.a6e9	1a		inc a		                ina             ; Increment the wordlist#
.a6ea	91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a6ec	ca		dex		                dex             ; and put it on the stack.
.a6ed	ca		dex		                dex
.a6ee	95 00		sta $00,x	                sta 0,x
.a6f0	74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a6f2	60		rts		z_wordlist:     rts
.a6f3					xt_words:
.a6f3	20 53 89	jsr $8953	                jsr xt_cr
.a6f6	a9 00		lda #$00	                lda #0
.a6f8	48		pha		                pha
.a6f9	ca		dex		                dex                     ; Make room on the stack for
.a6fa	ca		dex		                dex                     ; a dictionary pointer.
.a6fb	64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a6fd					_wordlist_loop:
.a6fd	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a6ff	a5 28		lda $28		                lda tmp3
.a701	d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a703	d0 02		bne $a707	                bne _have_wordlist
.a705	80 44		bra $a74b	                bra _words_done
.a707					_have_wordlist:
.a707	18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a708	69 1f		adc #$1f	                adc #search_order_offset
.a70a	a8		tay		                tay
.a70b	b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a70d	0a		asl a		                asl                     ; Turn offset into cells offset.
.a70e	18		clc		                clc
.a70f	69 06		adc #$06	                adc #wordlists_offset
.a711	a8		tay		                tay
.a712	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a714	95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a716	c8		iny		                iny
.a717	b1 1e		lda ($1e),y	                lda (up),y
.a719	95 01		sta $01,x	                sta 1,x
.a71b					_loop:
.a71b	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( nt nt )
.a71e	20 ee 95	jsr $95ee	                jsr xt_name_to_string   ; ( nt addr u )
.a721	68		pla		                pla
.a722	18		clc		                clc
.a723	75 00		adc $00,x	                adc 0,x
.a725	1a		inc a		                ina                     ; don't forget the space between words
.a726	c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a728	90 05		bcc $a72f	                bcc +
.a72a	20 53 89	jsr $8953	                jsr xt_cr
.a72d	a9 00		lda #$00	                lda #0
.a72f					+
.a72f	48		pha		                pha
.a730	20 de a4	jsr $a4de	                jsr xt_type             ; ( nt )
.a733	a9 20		lda #$20	                lda #AscSP
.a735	20 e6 8d	jsr $8de6	                jsr emit_a
.a738	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+
.a73b	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+
.a73e	20 70 8f	jsr $8f70	                jsr xt_fetch            ; @ ( nt+1 )
.a741	b5 00		lda $00,x	                lda 0,x
.a743	15 01		ora $01,x	                ora 1,x
.a745	d0 d4		bne $a71b	                bne _loop
.a747	e6 28		inc $28		                inc tmp3
.a749	80 b2		bra $a6fd	                bra _wordlist_loop
.a74b					_words_done:
.a74b	68		pla		                pla                     ; dump counter
.a74c	e8		inx		                inx
.a74d	e8		inx		                inx
.a74e	60		rts		z_words:        rts
.a74f					xt_wordsize:
.a74f	20 4a d6	jsr $d64a	                jsr underflow_1
.a752	b5 00		lda $00,x	                lda 0,x
.a754	85 24		sta $24		                sta tmp1
.a756	b5 01		lda $01,x	                lda 1,x
.a758	85 25		sta $25		                sta tmp1+1
.a75a	a0 06		ldy #$06	                ldy #6
.a75c	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a75e	88		dey		                dey
.a75f	88		dey		                dey
.a760	38		sec		                sec
.a761	f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a763	95 00		sta $00,x	                sta 0,x
.a765	a0 07		ldy #$07	                ldy #7
.a767	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a769	88		dey		                dey
.a76a	88		dey		                dey
.a76b	f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a76d	95 01		sta $01,x	                sta 1,x
.a76f	60		rts		z_wordsize:     rts
.a770					xt_xor:
.a770	20 4f d6	jsr $d64f	                jsr underflow_2
.a773	b5 00		lda $00,x	                lda 0,x
.a775	55 02		eor $02,x	                eor 2,x
.a777	95 02		sta $02,x	                sta 2,x
.a779	b5 01		lda $01,x	                lda 1,x
.a77b	55 03		eor $03,x	                eor 3,x
.a77d	95 03		sta $03,x	                sta 3,x
.a77f	e8		inx		                inx
.a780	e8		inx		                inx
.a781	60		rts		z_xor:          rts
.a782					xt_case:
.a782					xt_forth_wordlist:
.a782					xt_zero:
.a782	ca		dex		                dex             ; push
.a783	ca		dex		                dex
.a784	74 00		stz $00,x	                stz 0,x
.a786	74 01		stz $01,x	                stz 1,x
.a788					z_case:
.a788					z_forth_wordlist:
.a788					z_zero:
.a788	60		rts		                rts
.a789					xt_zero_equal:
.a789	20 4a d6	jsr $d64a	                jsr underflow_1
.a78c	b5 00		lda $00,x	                lda 0,x
.a78e	15 01		ora $01,x	                ora 1,x
.a790	f0 04		beq $a796	                beq _zero
.a792	a9 00		lda #$00	                lda #0
.a794	80 02		bra $a798	                bra _store
.a796					_zero:
.a796	a9 ff		lda #$ff	                lda #$ff
.a798					_store:
.a798	95 00		sta $00,x	                sta 0,x
.a79a	95 01		sta $01,x	                sta 1,x
.a79c	60		rts		z_zero_equal:   rts
.a79d					xt_zero_greater:
.a79d	20 4a d6	jsr $d64a	                jsr underflow_1
.a7a0	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a7a2	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7a4	30 05		bmi $a7ab	                bmi _done       ; TOS is negative, keep FLASE
.a7a6	15 00		ora $00,x	                ora 0,x
.a7a8	f0 01		beq $a7ab	                beq _done       ; TOS is zero, keep FALSE
.a7aa	88		dey		                dey             ; TOS is postive, make true
.a7ab					_done:
.a7ab	98		tya		                tya
.a7ac	95 00		sta $00,x	                sta 0,x
.a7ae	95 01		sta $01,x	                sta 1,x
.a7b0	60		rts		z_zero_greater: rts
.a7b1					xt_zero_less:
.a7b1	20 4a d6	jsr $d64a	                jsr underflow_1
.a7b4	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a7b6	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7b8	10 01		bpl $a7bb	                bpl _done       ; TOS is positive, so keep FALSE
.a7ba	88		dey		                dey             ; TOS is negative, make TRUE
.a7bb					_done:
.a7bb	98		tya		                tya
.a7bc	95 00		sta $00,x	                sta 0,x
.a7be	95 01		sta $01,x	                sta 1,x
.a7c0	60		rts		z_zero_less:    rts
.a7c1					xt_zero_unequal:
.a7c1	20 4a d6	jsr $d64a	                jsr underflow_1
.a7c4	a0 00		ldy #$00	                ldy #0          ; default false
.a7c6	b5 00		lda $00,x	                lda 0,x
.a7c8	15 01		ora $01,x	                ora 1,x
.a7ca	f0 01		beq $a7cd	                beq _got_zero
.a7cc	88		dey		                dey
.a7cd					_got_zero:
.a7cd	98		tya		                tya
.a7ce	95 00		sta $00,x	                sta 0,x
.a7d0	95 01		sta $01,x	                sta 1,x
.a7d2	60		rts		z_zero_unequal: rts
.a7d3					xt_editor_screen_helper:
.a7d3	20 9f 8d	jsr $8d9f	                jsr xt_dup
.a7d6	20 ba 9e	jsr $9eba	                jsr xt_scr
.a7d9	20 68 a1	jsr $a168	                jsr xt_store
.a7dc	20 a5 85	jsr $85a5	                jsr xt_buffer
.a7df					z_editor_screen_helper:
.a7df	60		rts		                rts
.a7e0					xt_editor_enter_screen:
.a7e0	20 d3 a7	jsr $a7d3	                jsr xt_editor_screen_helper
.a7e3	20 1e 8d	jsr $8d1e	                jsr xt_drop
.a7e6	64 2e		stz $2e		                stz editor1
.a7e8					_prompt_loop:
.a7e8	ca		dex		                dex
.a7e9	ca		dex		                dex
.a7ea	a5 2e		lda $2e		                lda editor1
.a7ec	95 00		sta $00,x	                sta 0,x
.a7ee	74 01		stz $01,x	                stz 1,x
.a7f0	20 b5 a8	jsr $a8b5	                jsr xt_editor_o
.a7f3	e6 2e		inc $2e		                inc editor1
.a7f5	a9 10		lda #$10	                lda #16
.a7f7	c5 2e		cmp $2e		                cmp editor1
.a7f9	d0 ed		bne $a7e8	                bne _prompt_loop
.a7fb					z_editor_enter_screen:
.a7fb	60		rts		                rts
.a7fc					xt_editor_erase_screen:
.a7fc	20 d3 a7	jsr $a7d3	                jsr xt_editor_screen_helper
.a7ff	ca		dex		                dex
.a800	ca		dex		                dex
.a801	74 00		stz $00,x	                stz 0,x
.a803	a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a805	95 01		sta $01,x	                sta 1,x
.a807	20 da 8e	jsr $8eda	                jsr xt_blank
.a80a	20 3f a6	jsr $a63f	                jsr xt_update
.a80d					z_editor_erase_screen:
.a80d	60		rts		                rts
.a80e					xt_editor_el:
.a80e	20 9c a8	jsr $a89c	                jsr xt_editor_line
.a811	ca		dex		                dex
.a812	ca		dex		                dex
.a813	a9 40		lda #$40	                lda #64
.a815	95 00		sta $00,x	                sta 0,x
.a817	74 01		stz $01,x	                stz 1,x
.a819	20 da 8e	jsr $8eda	                jsr xt_blank
.a81c	20 3f a6	jsr $a63f	                jsr xt_update
.a81f	60		rts		z_editor_el:    rts
.a820					xt_editor_l:
.a820	ca		dex		                dex             ; Put SCR on the stack.
.a821	ca		dex		                dex
.a822	a0 02		ldy #$02	                ldy #scr_offset
.a824	b1 1e		lda ($1e),y	                lda (up),y
.a826	95 00		sta $00,x	                sta 0,x
.a828	c8		iny		                iny
.a829	b1 1e		lda ($1e),y	                lda (up),y
.a82b	95 01		sta $01,x	                sta 1,x
.a82d	20 b1 83	jsr $83b1	                jsr xt_block    ; Get the current screen.
.a830	20 53 89	jsr $8953	                jsr xt_cr
.a833	80 08		bra $a83d	                bra _after_screen_msg
.a835					_screen_msg:
>a835	53 63 72 65 65 6e 20 23		                .text "Screen #"
.a83d					_after_screen_msg:
.a83d	20 8a a0	jsr $a08a	                jsr sliteral_runtime
>a840	35 a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a844	20 de a4	jsr $a4de	                jsr xt_type
.a847	20 ba 9e	jsr $9eba	                jsr xt_scr
.a84a	20 70 8f	jsr $8f70	                jsr xt_fetch
.a84d	ca		dex		                dex
.a84e	ca		dex		                dex
.a84f	a9 04		lda #$04	                lda #4          ; four spaces
.a851	95 00		sta $00,x	                sta 0,x
.a853	74 01		stz $01,x	                stz 1,x
.a855	20 15 a5	jsr $a515	                jsr xt_u_dot_r
.a858	64 28		stz $28		                stz tmp3
.a85a					_line_loop:
.a85a	20 53 89	jsr $8953	                jsr xt_cr
.a85d	ca		dex		                dex
.a85e	ca		dex		                dex
.a85f	ca		dex		                dex
.a860	ca		dex		                dex
.a861	74 03		stz $03,x	                stz 3,x
.a863	a5 28		lda $28		                lda tmp3
.a865	95 02		sta $02,x	                sta 2,x
.a867	74 01		stz $01,x	                stz 1,x
.a869	a9 02		lda #$02	                lda #2
.a86b	95 00		sta $00,x	                sta 0,x
.a86d	20 15 a5	jsr $a515	                jsr xt_u_dot_r
.a870	20 ff a0	jsr $a0ff	                jsr xt_space
.a873	20 9f 8d	jsr $8d9f	                jsr xt_dup
.a876	ca		dex		                dex
.a877	ca		dex		                dex
.a878	a9 40		lda #$40	                lda #64
.a87a	95 00		sta $00,x	                sta 0,x
.a87c	74 01		stz $01,x	                stz 1,x
.a87e	20 de a4	jsr $a4de	                jsr xt_type
.a881	18		clc		                clc
.a882	a9 40		lda #$40	                lda #64
.a884	75 00		adc $00,x	                adc 0,x
.a886	95 00		sta $00,x	                sta 0,x
.a888	b5 01		lda $01,x	                lda 1,x
.a88a	69 00		adc #$00	                adc #0      ; Add carry
.a88c	95 01		sta $01,x	                sta 1,x
.a88e	e6 28		inc $28		                inc tmp3
.a890	a5 28		lda $28		                lda tmp3
.a892	c9 10		cmp #$10	                cmp #16
.a894	d0 c4		bne $a85a	                bne _line_loop
.a896	20 53 89	jsr $8953	                jsr xt_cr
.a899	e8		inx		                inx
.a89a	e8		inx		                inx
.a89b	60		rts		z_editor_l:            rts
.a89c					xt_editor_line:
.a89c	20 4a d6	jsr $d64a	                jsr underflow_1
.a89f	a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a8a1					_shift_tos_left:
.a8a1	16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a8a3	36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a8a5	88		dey		                dey
.a8a6	d0 f9		bne $a8a1	                bne _shift_tos_left
.a8a8	20 ba 9e	jsr $9eba	                jsr xt_scr
.a8ab	20 70 8f	jsr $8f70	                jsr xt_fetch
.a8ae	20 b1 83	jsr $83b1	                jsr xt_block
.a8b1	20 c4 99	jsr $99c4	                jsr xt_plus
.a8b4	60		rts		z_editor_line:  rts
.a8b5					xt_editor_o:
.a8b5	20 53 89	jsr $8953	                jsr xt_cr
.a8b8	20 9f 8d	jsr $8d9f	                jsr xt_dup
.a8bb	20 82 a3	jsr $a382	                jsr xt_two
.a8be	20 15 a5	jsr $a515	                jsr xt_u_dot_r
.a8c1	20 ff a0	jsr $a0ff	                jsr xt_space
.a8c4	a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a8c6	20 e6 8d	jsr $8de6	                jsr emit_a
.a8c9	20 ff a0	jsr $a0ff	                jsr xt_space
.a8cc	20 9c a8	jsr $a89c	                jsr xt_editor_line
.a8cf	20 9f 8d	jsr $8d9f	                jsr xt_dup      ; Save a copy of the line address for later.
.a8d2	ca		dex		                dex
.a8d3	ca		dex		                dex
.a8d4	a9 40		lda #$40	                lda #64         ; chars/line
.a8d6	95 00		sta $00,x	                sta 0,x
.a8d8	74 01		stz $01,x	                stz 1,x
.a8da	20 4e 81	jsr $814e	                jsr xt_accept
.a8dd	20 9f 8d	jsr $8d9f	                jsr xt_dup
.a8e0	20 5e 96	jsr $965e	                jsr xt_not_rote ; -rot
.a8e3	20 c4 99	jsr $99c4	                jsr xt_plus
.a8e6	ca		dex		                dex
.a8e7	ca		dex		                dex
.a8e8	a9 40		lda #$40	                lda #64         ; chars/line
.a8ea	95 00		sta $00,x	                sta 0,x
.a8ec	74 01		stz $01,x	                stz 1,x
.a8ee	20 38 9b	jsr $9b38	                jsr xt_rot
.a8f1	20 40 95	jsr $9540	                jsr xt_minus
.a8f4	20 da 8e	jsr $8eda	                jsr xt_blank
.a8f7	20 3f a6	jsr $a63f	                jsr xt_update
.a8fa	60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a8fb					assembler:
.a8fb					xt_asm_adc_h:
.a8fb	a9 69		lda #$69	                lda #$69
.a8fd	4c 56 ac	jmp $ac56	                jmp asm_common
.a900					z_asm_adc_h:
.a900					xt_asm_adc_x:
.a900	a9 7d		lda #$7d	                lda #$7D
.a902	4c 56 ac	jmp $ac56	                jmp asm_common
.a905					z_asm_adc_x:
.a905					xt_asm_adc_y:
.a905	a9 79		lda #$79	                lda #$79
.a907	4c 56 ac	jmp $ac56	                jmp asm_common
.a90a					z_asm_adc_y:
.a90a					xt_asm_adc_z:
.a90a	a9 65		lda #$65	                lda #$65
.a90c	4c 56 ac	jmp $ac56	                jmp asm_common
.a90f					z_asm_adc_z:
.a90f					xt_asm_adc_zi:
.a90f	a9 72		lda #$72	                lda #$72
.a911	4c 56 ac	jmp $ac56	                jmp asm_common
.a914					z_asm_adc_zi:
.a914					xt_asm_adc_ziy:
.a914	a9 71		lda #$71	                lda #$71
.a916	4c 56 ac	jmp $ac56	                jmp asm_common
.a919					z_asm_adc_ziy:
.a919					xt_asm_adc_zx:
.a919	a9 75		lda #$75	                lda #$75
.a91b	4c 56 ac	jmp $ac56	                jmp asm_common
.a91e					z_asm_adc_zx:
.a91e					xt_asm_adc_zxi:
.a91e	a9 61		lda #$61	                lda #$61
.a920	4c 56 ac	jmp $ac56	                jmp asm_common
.a923					z_asm_adc_zxi:
.a923					xt_asm_and:
.a923	a9 2d		lda #$2d	                lda #$2D
.a925	4c 56 ac	jmp $ac56	                jmp asm_common
.a928					z_asm_and:
.a928					xt_asm_and_h:
.a928	a9 29		lda #$29	                lda #$29
.a92a	4c 56 ac	jmp $ac56	                jmp asm_common
.a92d					z_asm_and_h:
.a92d					xt_asm_and_x:
.a92d	a9 3d		lda #$3d	                lda #$3D
.a92f	4c 56 ac	jmp $ac56	                jmp asm_common
.a932					z_asm_and_x:
.a932					xt_asm_and_y:
.a932	a9 39		lda #$39	                lda #$39
.a934	4c 56 ac	jmp $ac56	                jmp asm_common
.a937					z_asm_and_y:
.a937					xt_asm_and_z:
.a937	a9 25		lda #$25	                lda #$25
.a939	4c 56 ac	jmp $ac56	                jmp asm_common
.a93c					z_asm_and_z:
.a93c					xt_asm_and_zi:
.a93c	a9 32		lda #$32	                lda #$32
.a93e	4c 56 ac	jmp $ac56	                jmp asm_common
.a941					z_asm_and_zi:
.a941					xt_asm_and_ziy:
.a941	a9 31		lda #$31	                lda #$31
.a943	4c 56 ac	jmp $ac56	                jmp asm_common
.a946					z_asm_and_ziy:
.a946					xt_asm_and_zx:
.a946	a9 35		lda #$35	                lda #$35
.a948	4c 56 ac	jmp $ac56	                jmp asm_common
.a94b					z_asm_and_zx:
.a94b					xt_asm_and_zxi:
.a94b	a9 21		lda #$21	                lda #$21
.a94d	4c 56 ac	jmp $ac56	                jmp asm_common
.a950					z_asm_and_zxi:
.a950					xt_asm_asl:
.a950	a9 0e		lda #$0e	                lda #$0E
.a952	4c 56 ac	jmp $ac56	                jmp asm_common
.a955					z_asm_asl:
.a955					xt_asm_asl_a:
.a955	a9 0a		lda #$0a	                lda #$0A
.a957	4c 56 ac	jmp $ac56	                jmp asm_common
.a95a					z_asm_asl_a:
.a95a					xt_asm_asl_x:
.a95a	a9 1e		lda #$1e	                lda #$1E
.a95c	4c 56 ac	jmp $ac56	                jmp asm_common
.a95f					z_asm_asl_x:
.a95f					xt_asm_asl_z:
.a95f	a9 06		lda #$06	                lda #$06
.a961	4c 56 ac	jmp $ac56	                jmp asm_common
.a964					z_asm_asl_z:
.a964					xt_asm_asl_zx:
.a964	a9 16		lda #$16	                lda #$16
.a966	4c 56 ac	jmp $ac56	                jmp asm_common
.a969					z_asm_asl_zx:
.a969					xt_asm_bcc:
.a969	a9 90		lda #$90	                lda #$90
.a96b	4c 56 ac	jmp $ac56	                jmp asm_common
.a96e					z_asm_bcc:
.a96e					xt_asm_bcs:
.a96e	a9 b0		lda #$b0	                lda #$B0
.a970	a0 02		ldy #$02	                ldy #2
.a972	4c 56 ac	jmp $ac56	                jmp asm_common
.a975					z_asm_bcs:
.a975					xt_asm_beq:
.a975	a9 f0		lda #$f0	                lda #$F0
.a977	4c 56 ac	jmp $ac56	                jmp asm_common
.a97a					z_asm_beq:
.a97a					xt_asm_bit:
.a97a	a9 2c		lda #$2c	                lda #$2C
.a97c	4c 56 ac	jmp $ac56	                jmp asm_common
.a97f					z_asm_bit:
.a97f					xt_asm_bit_h:
.a97f	a9 89		lda #$89	                lda #$89
.a981	4c 56 ac	jmp $ac56	                jmp asm_common
.a984					z_asm_bit_h:
.a984					xt_asm_bit_x:
.a984	a9 3c		lda #$3c	                lda #$3C
.a986	4c 56 ac	jmp $ac56	                jmp asm_common
.a989					z_asm_bit_x:
.a989					xt_asm_bit_z:
.a989	a9 24		lda #$24	                lda #$24
.a98b	4c 56 ac	jmp $ac56	                jmp asm_common
.a98e					z_asm_bit_z:
.a98e					xt_asm_bit_zx:
.a98e	a9 34		lda #$34	                lda #$34
.a990	4c 56 ac	jmp $ac56	                jmp asm_common
.a993					z_asm_bit_zx:
.a993					xt_asm_bmi:
.a993	a9 30		lda #$30	                lda #$30
.a995	4c 56 ac	jmp $ac56	                jmp asm_common
.a998					z_asm_bmi:
.a998					xt_asm_bne:
.a998	a9 d0		lda #$d0	                lda #$D0
.a99a	4c 56 ac	jmp $ac56	                jmp asm_common
.a99d					z_asm_bne:
.a99d					xt_asm_bpl:
.a99d	a9 10		lda #$10	                lda #$10
.a99f	4c 56 ac	jmp $ac56	                jmp asm_common
.a9a2					z_asm_bpl:
.a9a2					xt_asm_bra:
.a9a2	a9 80		lda #$80	                lda #$80
.a9a4	4c 56 ac	jmp $ac56	                jmp asm_common
.a9a7					z_asm_bra:
.a9a7					xt_asm_brk:
.a9a7	a9 00		lda #$00	                lda #$00
.a9a9	4c 56 ac	jmp $ac56	                jmp asm_common
.a9ac					z_asm_brk:
.a9ac					xt_asm_bvc:
.a9ac	a9 50		lda #$50	                lda #$50
.a9ae	4c 56 ac	jmp $ac56	                jmp asm_common
.a9b1					z_asm_bvc:
.a9b1					xt_asm_bvs:
.a9b1	a9 70		lda #$70	                lda #$70
.a9b3	4c 56 ac	jmp $ac56	                jmp asm_common
.a9b6					z_asm_bvs:
.a9b6					xt_asm_clc:
.a9b6	a9 18		lda #$18	                lda #$18
.a9b8	4c 56 ac	jmp $ac56	                jmp asm_common
.a9bb					z_asm_clc:
.a9bb					xt_asm_cld:
.a9bb	a9 d8		lda #$d8	                lda #$D8
.a9bd	4c 56 ac	jmp $ac56	                jmp asm_common
.a9c0					z_asm_cld:
.a9c0					xt_asm_cli:
.a9c0	a9 58		lda #$58	                lda #$58
.a9c2	4c 56 ac	jmp $ac56	                jmp asm_common
.a9c5					z_asm_cli:
.a9c5					xt_asm_clv:
.a9c5	a9 b8		lda #$b8	                lda #$B8
.a9c7	4c 56 ac	jmp $ac56	                jmp asm_common
.a9ca					z_asm_clv:
.a9ca					xt_asm_cmp:
.a9ca	a9 cd		lda #$cd	                lda #$CD
.a9cc	4c 56 ac	jmp $ac56	                jmp asm_common
.a9cf					z_asm_cmp:
.a9cf					xt_asm_cmp_h:
.a9cf	a9 c9		lda #$c9	                lda #$C9
.a9d1	4c 56 ac	jmp $ac56	                jmp asm_common
.a9d4					z_asm_cmp_h:
.a9d4					xt_asm_cmp_x:
.a9d4	a9 dd		lda #$dd	                lda #$DD
.a9d6	4c 56 ac	jmp $ac56	                jmp asm_common
.a9d9					z_asm_cmp_x:
.a9d9					xt_asm_cmp_y:
.a9d9	a9 d9		lda #$d9	                lda #$D9
.a9db	4c 56 ac	jmp $ac56	                jmp asm_common
.a9de					z_asm_cmp_y:
.a9de					xt_asm_cmp_z:
.a9de	a9 c5		lda #$c5	                lda #$C5
.a9e0	4c 56 ac	jmp $ac56	                jmp asm_common
.a9e3					z_asm_cmp_z:
.a9e3					xt_asm_cmp_zi:
.a9e3	a9 d2		lda #$d2	                lda #$D2
.a9e5	4c 56 ac	jmp $ac56	                jmp asm_common
.a9e8					z_asm_cmp_zi:
.a9e8					xt_asm_cmp_ziy:
.a9e8	a9 d1		lda #$d1	                lda #$D1
.a9ea	4c 56 ac	jmp $ac56	                jmp asm_common
.a9ed					z_asm_cmp_ziy:
.a9ed					xt_asm_cmp_zx:
.a9ed	a9 d5		lda #$d5	                lda #$D5
.a9ef	4c 56 ac	jmp $ac56	                jmp asm_common
.a9f2					z_asm_cmp_zx:
.a9f2					xt_asm_cmp_zxi:
.a9f2	a9 c1		lda #$c1	                lda #$C1
.a9f4	4c 56 ac	jmp $ac56	                jmp asm_common
.a9f7					z_asm_cmp_zxi:
.a9f7					xt_asm_cpx:
.a9f7	a9 ec		lda #$ec	                lda #$EC
.a9f9	4c 56 ac	jmp $ac56	                jmp asm_common
.a9fc					z_asm_cpx:
.a9fc					xt_asm_cpx_h:
.a9fc	a9 e0		lda #$e0	                lda #$E0
.a9fe	4c 56 ac	jmp $ac56	                jmp asm_common
.aa01					z_asm_cpx_h:
.aa01					xt_asm_cpx_z:
.aa01	a9 e4		lda #$e4	                lda #$E4
.aa03	4c 56 ac	jmp $ac56	                jmp asm_common
.aa06					z_asm_cpx_z:
.aa06					xt_asm_cpy:
.aa06	a9 cc		lda #$cc	                lda #$CC
.aa08	a0 03		ldy #$03	                ldy #3
.aa0a	4c 56 ac	jmp $ac56	                jmp asm_common
.aa0d					z_asm_cpy:
.aa0d					xt_asm_cpy_h:
.aa0d	a9 c0		lda #$c0	                lda #$C0
.aa0f	4c 56 ac	jmp $ac56	                jmp asm_common
.aa12					z_asm_cpy_h:
.aa12					xt_asm_cpy_z:
.aa12	a9 c4		lda #$c4	                lda #$C4
.aa14	4c 56 ac	jmp $ac56	                jmp asm_common
.aa17					z_asm_cpy_z:
.aa17					xt_asm_dec:
.aa17	a9 ce		lda #$ce	                lda #$CE
.aa19	4c 56 ac	jmp $ac56	                jmp asm_common
.aa1c					z_asm_dec:
.aa1c					xt_asm_dec_a:
.aa1c	a9 3a		lda #$3a	                lda #$3A
.aa1e	4c 56 ac	jmp $ac56	                jmp asm_common
.aa21					z_asm_dec_a:
.aa21					xt_asm_dec_x:
.aa21	a9 de		lda #$de	                lda #$DE
.aa23	4c 56 ac	jmp $ac56	                jmp asm_common
.aa26					z_asm_dec_x:
.aa26					xt_asm_dec_z:
.aa26	a9 c6		lda #$c6	                lda #$C6
.aa28	4c 56 ac	jmp $ac56	                jmp asm_common
.aa2b					z_asm_dec_z:
.aa2b					xt_asm_dec_zx:
.aa2b	a9 d6		lda #$d6	                lda #$D6
.aa2d	4c 56 ac	jmp $ac56	                jmp asm_common
.aa30					z_asm_dec_zx:
.aa30					xt_asm_dex:
.aa30	a9 ca		lda #$ca	                lda #$CA
.aa32	4c 56 ac	jmp $ac56	                jmp asm_common
.aa35					z_asm_dex:
.aa35					xt_asm_dey:
.aa35	a9 88		lda #$88	                lda #$88
.aa37	4c 56 ac	jmp $ac56	                jmp asm_common
.aa3a					z_asm_dey:
.aa3a					xt_asm_eor:
.aa3a	a9 4d		lda #$4d	                lda #$4D
.aa3c	4c 56 ac	jmp $ac56	                jmp asm_common
.aa3f					z_asm_eor:
.aa3f					xt_asm_eor_h:
.aa3f	a9 49		lda #$49	                lda #$49
.aa41	4c 56 ac	jmp $ac56	                jmp asm_common
.aa44					z_asm_eor_h:
.aa44					xt_asm_eor_x:
.aa44	a9 5d		lda #$5d	                lda #$5D
.aa46	4c 56 ac	jmp $ac56	                jmp asm_common
.aa49					z_asm_eor_x:
.aa49					xt_asm_eor_y:
.aa49	a9 59		lda #$59	                lda #$59
.aa4b	4c 56 ac	jmp $ac56	                jmp asm_common
.aa4e					z_asm_eor_y:
.aa4e					xt_asm_eor_z:
.aa4e	a9 45		lda #$45	                lda #$45
.aa50	4c 56 ac	jmp $ac56	                jmp asm_common
.aa53					z_asm_eor_z:
.aa53					xt_asm_eor_zi:
.aa53	a9 52		lda #$52	                lda #$52
.aa55	4c 56 ac	jmp $ac56	                jmp asm_common
.aa58					z_asm_eor_zi:
.aa58					xt_asm_eor_ziy:
.aa58	a9 51		lda #$51	                lda #$51
.aa5a	4c 56 ac	jmp $ac56	                jmp asm_common
.aa5d					z_asm_eor_ziy:
.aa5d					xt_asm_eor_zx:
.aa5d	a9 55		lda #$55	                lda #$55
.aa5f	4c 56 ac	jmp $ac56	                jmp asm_common
.aa62					z_asm_eor_zx:
.aa62					xt_asm_eor_zxi:
.aa62	a9 41		lda #$41	                lda #$41
.aa64	4c 56 ac	jmp $ac56	                jmp asm_common
.aa67					z_asm_eor_zxi:
.aa67					xt_asm_inc:
.aa67	a9 ee		lda #$ee	                lda #$EE
.aa69	4c 56 ac	jmp $ac56	                jmp asm_common
.aa6c					z_asm_inc:
.aa6c					xt_asm_inc_a:
.aa6c	a9 1a		lda #$1a	                lda #$1A
.aa6e	4c 56 ac	jmp $ac56	                jmp asm_common
.aa71					z_asm_inc_a:
.aa71					xt_asm_inc_x:
.aa71	a9 fe		lda #$fe	                lda #$FE
.aa73	4c 56 ac	jmp $ac56	                jmp asm_common
.aa76					z_asm_inc_x:
.aa76					xt_asm_inc_z:
.aa76	a9 e6		lda #$e6	                lda #$E6
.aa78	4c 56 ac	jmp $ac56	                jmp asm_common
.aa7b					z_asm_inc_z:
.aa7b					xt_asm_inc_zx:
.aa7b	a9 f6		lda #$f6	                lda #$F6
.aa7d	4c 56 ac	jmp $ac56	                jmp asm_common
.aa80					z_asm_inc_zx:
.aa80					xt_asm_inx:
.aa80	a9 e8		lda #$e8	                lda #$E8
.aa82	4c 56 ac	jmp $ac56	                jmp asm_common
.aa85					z_asm_inx:
.aa85					xt_asm_iny:
.aa85	a9 c8		lda #$c8	                lda #$C8
.aa87	4c 56 ac	jmp $ac56	                jmp asm_common
.aa8a					z_asm_iny:
.aa8a					xt_asm_jmp:
.aa8a	a9 4c		lda #$4c	                lda #$4C
.aa8c	4c 56 ac	jmp $ac56	                jmp asm_common
.aa8f					z_asm_jmp:
.aa8f					xt_asm_jmp_i:
.aa8f	a9 6c		lda #$6c	                lda #$6C
.aa91	4c 56 ac	jmp $ac56	                jmp asm_common
.aa94					z_asm_jmp_i:
.aa94					xt_asm_jmp_xi:
.aa94	a9 7c		lda #$7c	                lda #$7C
.aa96	4c 56 ac	jmp $ac56	                jmp asm_common
.aa99					z_asm_jmp_xi:
.aa99					xt_asm_jsr:
.aa99	a9 20		lda #$20	                lda #$20
.aa9b	4c 56 ac	jmp $ac56	                jmp asm_common
.aa9e					z_asm_jsr:
.aa9e					xt_asm_lda:
.aa9e	a9 ad		lda #$ad	                lda #$AD
.aaa0	4c 56 ac	jmp $ac56	                jmp asm_common
.aaa3					z_asm_lda:
.aaa3					xt_asm_lda_h:
.aaa3	a9 a9		lda #$a9	                lda #$A9
.aaa5	4c 56 ac	jmp $ac56	                jmp asm_common
.aaa8					z_asm_lda_h:
.aaa8					xt_asm_lda_x:
.aaa8	a9 bd		lda #$bd	                lda #$BD
.aaaa	4c 56 ac	jmp $ac56	                jmp asm_common
.aaad					z_asm_lda_x:
.aaad					xt_asm_lda_y:
.aaad	a9 b9		lda #$b9	                lda #$B9
.aaaf	4c 56 ac	jmp $ac56	                jmp asm_common
.aab2					z_asm_lda_y:
.aab2					xt_asm_lda_z:
.aab2	a9 a5		lda #$a5	                lda #$A5
.aab4	4c 56 ac	jmp $ac56	                jmp asm_common
.aab7					z_asm_lda_z:
.aab7					xt_asm_lda_zi:
.aab7	a9 b2		lda #$b2	                lda #$B2
.aab9	4c 56 ac	jmp $ac56	                jmp asm_common
.aabc					z_asm_lda_zi:
.aabc					xt_asm_lda_ziy:
.aabc	a9 b1		lda #$b1	                lda #$B1
.aabe	4c 56 ac	jmp $ac56	                jmp asm_common
.aac1					z_asm_lda_ziy:
.aac1					xt_asm_lda_zx:
.aac1	a9 b5		lda #$b5	                lda #$B5
.aac3	4c 56 ac	jmp $ac56	                jmp asm_common
.aac6					z_asm_lda_zx:
.aac6					xt_asm_lda_zxi:
.aac6	a9 a1		lda #$a1	                lda #$A1
.aac8	4c 56 ac	jmp $ac56	                jmp asm_common
.aacb					z_asm_lda_zxi:
.aacb					xt_asm_ldx:
.aacb	a9 ae		lda #$ae	                lda #$AE
.aacd	4c 56 ac	jmp $ac56	                jmp asm_common
.aad0					z_asm_ldx:
.aad0					xt_asm_ldx_h:
.aad0	a9 a2		lda #$a2	                lda #$A2
.aad2	4c 56 ac	jmp $ac56	                jmp asm_common
.aad5					z_asm_ldx_h:
.aad5					xt_asm_ldx_y:
.aad5	a9 be		lda #$be	                lda #$BE
.aad7	4c 56 ac	jmp $ac56	                jmp asm_common
.aada					z_asm_ldx_y:
.aada					xt_asm_ldx_z:
.aada	a9 a6		lda #$a6	                lda #$A6
.aadc	4c 56 ac	jmp $ac56	                jmp asm_common
.aadf					z_asm_ldx_z:
.aadf					xt_asm_ldx_zy:
.aadf	a9 b6		lda #$b6	                lda #$B6
.aae1	4c 56 ac	jmp $ac56	                jmp asm_common
.aae4					z_asm_ldx_zy:
.aae4					xt_asm_ldy:
.aae4	a9 ac		lda #$ac	                lda #$AC
.aae6	4c 56 ac	jmp $ac56	                jmp asm_common
.aae9					z_asm_ldy:
.aae9					xt_asm_ldy_h:
.aae9	a9 a0		lda #$a0	                lda #$A0
.aaeb	4c 56 ac	jmp $ac56	                jmp asm_common
.aaee					z_asm_ldy_h:
.aaee					xt_asm_ldy_x:
.aaee	a9 bc		lda #$bc	                lda #$BC
.aaf0	4c 56 ac	jmp $ac56	                jmp asm_common
.aaf3					z_asm_ldy_x:
.aaf3					xt_asm_ldy_z:
.aaf3	a9 a4		lda #$a4	                lda #$A4
.aaf5	4c 56 ac	jmp $ac56	                jmp asm_common
.aaf8					z_asm_ldy_z:
.aaf8					xt_asm_ldy_zx:
.aaf8	a9 b4		lda #$b4	                lda #$B4
.aafa	4c 56 ac	jmp $ac56	                jmp asm_common
.aafd					z_asm_ldy_zx:
.aafd					xt_asm_lsr:
.aafd	a9 4e		lda #$4e	                lda #$4E
.aaff	4c 56 ac	jmp $ac56	                jmp asm_common
.ab02					z_asm_lsr:
.ab02					xt_asm_lsr_a:
.ab02	a9 4a		lda #$4a	                lda #$4A
.ab04	4c 56 ac	jmp $ac56	                jmp asm_common
.ab07					z_asm_lsr_a:
.ab07					xt_asm_lsr_x:
.ab07	a9 5e		lda #$5e	                lda #$5E
.ab09	4c 56 ac	jmp $ac56	                jmp asm_common
.ab0c					z_asm_lsr_x:
.ab0c					xt_asm_lsr_z:
.ab0c	a9 46		lda #$46	                lda #$46
.ab0e	4c 56 ac	jmp $ac56	                jmp asm_common
.ab11					z_asm_lsr_z:
.ab11					xt_asm_lsr_zx:
.ab11	a9 56		lda #$56	                lda #$56
.ab13	4c 56 ac	jmp $ac56	                jmp asm_common
.ab16					z_asm_lsr_zx:
.ab16					xt_asm_nop:
.ab16	a9 ea		lda #$ea	                lda #$EA
.ab18	4c 56 ac	jmp $ac56	                jmp asm_common
.ab1b					z_asm_nop:
.ab1b					xt_asm_ora:
.ab1b	a9 0d		lda #$0d	                lda #$0D
.ab1d	4c 56 ac	jmp $ac56	                jmp asm_common
.ab20					z_asm_ora:
.ab20					xt_asm_ora_h:
.ab20	a9 09		lda #$09	                lda #$09
.ab22	4c 56 ac	jmp $ac56	                jmp asm_common
.ab25					z_asm_ora_h:
.ab25					xt_asm_ora_x:
.ab25	a9 1d		lda #$1d	                lda #$1D
.ab27	4c 56 ac	jmp $ac56	                jmp asm_common
.ab2a					z_asm_ora_x:
.ab2a					xt_asm_ora_y:
.ab2a	a9 19		lda #$19	                lda #$19
.ab2c	4c 56 ac	jmp $ac56	                jmp asm_common
.ab2f					z_asm_ora_y:
.ab2f					xt_asm_ora_z:
.ab2f	a9 05		lda #$05	                lda #$05
.ab31	4c 56 ac	jmp $ac56	                jmp asm_common
.ab34					z_asm_ora_z:
.ab34					xt_asm_ora_zi:
.ab34	a9 12		lda #$12	                lda #$12
.ab36	a0 02		ldy #$02	                ldy #2
.ab38	4c 56 ac	jmp $ac56	                jmp asm_common
.ab3b					z_asm_ora_zi:
.ab3b					xt_asm_ora_ziy:
.ab3b	a9 11		lda #$11	                lda #$11
.ab3d	4c 56 ac	jmp $ac56	                jmp asm_common
.ab40					z_asm_ora_ziy:
.ab40					xt_asm_ora_zx:
.ab40	a9 15		lda #$15	                lda #$15
.ab42	4c 56 ac	jmp $ac56	                jmp asm_common
.ab45					z_asm_ora_zx:
.ab45					xt_asm_ora_zxi:
.ab45	a9 01		lda #$01	                lda #$01
.ab47	4c 56 ac	jmp $ac56	                jmp asm_common
.ab4a					z_asm_ora_zxi:
.ab4a					xt_asm_pha:
.ab4a	a9 48		lda #$48	                lda #$48
.ab4c	4c 56 ac	jmp $ac56	                jmp asm_common
.ab4f					z_asm_pha:
.ab4f					xt_asm_php:
.ab4f	a9 08		lda #$08	                lda #$08
.ab51	4c 56 ac	jmp $ac56	                jmp asm_common
.ab54					z_asm_php:
.ab54					xt_asm_phx:
.ab54	a9 da		lda #$da	                lda #$DA
.ab56	4c 56 ac	jmp $ac56	                jmp asm_common
.ab59					z_asm_phx:
.ab59					xt_asm_phy:
.ab59	a9 5a		lda #$5a	                lda #$5A
.ab5b	4c 56 ac	jmp $ac56	                jmp asm_common
.ab5e					z_asm_phy:
.ab5e					xt_asm_pla:
.ab5e	a9 68		lda #$68	                lda #$68
.ab60	4c 56 ac	jmp $ac56	                jmp asm_common
.ab63					z_asm_pla:
.ab63					xt_asm_plp:
.ab63	a9 28		lda #$28	                lda #$28
.ab65	4c 56 ac	jmp $ac56	                jmp asm_common
.ab68					z_asm_plp:
.ab68					xt_asm_plx:
.ab68	a9 fa		lda #$fa	                lda #$FA
.ab6a	4c 56 ac	jmp $ac56	                jmp asm_common
.ab6d					z_asm_plx:
.ab6d					xt_asm_ply:
.ab6d	a9 7a		lda #$7a	                lda #$7A
.ab6f	4c 56 ac	jmp $ac56	                jmp asm_common
.ab72					z_asm_ply:
.ab72					xt_asm_rol:
.ab72	a9 2e		lda #$2e	                lda #$2E
.ab74	4c 56 ac	jmp $ac56	                jmp asm_common
.ab77					z_asm_rol:
.ab77					xt_asm_rol_a:
.ab77	a9 2a		lda #$2a	                lda #$2A
.ab79	4c 56 ac	jmp $ac56	                jmp asm_common
.ab7c					z_asm_rol_a:
.ab7c					xt_asm_rol_x:
.ab7c	a9 3e		lda #$3e	                lda #$3E
.ab7e	4c 56 ac	jmp $ac56	                jmp asm_common
.ab81					z_asm_rol_x:
.ab81					xt_asm_rol_z:
.ab81	a9 26		lda #$26	                lda #$26
.ab83	4c 56 ac	jmp $ac56	                jmp asm_common
.ab86					z_asm_rol_z:
.ab86					xt_asm_rol_zx:
.ab86	a9 36		lda #$36	                lda #$36
.ab88	4c 56 ac	jmp $ac56	                jmp asm_common
.ab8b					z_asm_rol_zx:
.ab8b					xt_asm_ror:
.ab8b	a9 6e		lda #$6e	                lda #$6E
.ab8d	4c 56 ac	jmp $ac56	                jmp asm_common
.ab90					z_asm_ror:
.ab90					xt_asm_ror_a:
.ab90	a9 6a		lda #$6a	                lda #$6A
.ab92	4c 56 ac	jmp $ac56	                jmp asm_common
.ab95					z_asm_ror_a:
.ab95					xt_asm_ror_x:
.ab95	a9 7e		lda #$7e	                lda #$7E
.ab97	4c 56 ac	jmp $ac56	                jmp asm_common
.ab9a					z_asm_ror_x:
.ab9a					xt_asm_ror_z:
.ab9a	a9 66		lda #$66	                lda #$66
.ab9c	4c 56 ac	jmp $ac56	                jmp asm_common
.ab9f					z_asm_ror_z:
.ab9f					xt_asm_ror_zx:
.ab9f	a9 76		lda #$76	                lda #$76
.aba1	4c 56 ac	jmp $ac56	                jmp asm_common
.aba4					z_asm_ror_zx:
.aba4					xt_asm_rti:
.aba4	a9 40		lda #$40	                lda #$40
.aba6	4c 56 ac	jmp $ac56	                jmp asm_common
.aba9					z_asm_rti:
.aba9					xt_asm_rts:
.aba9	a9 60		lda #$60	                lda #$60
.abab	4c 56 ac	jmp $ac56	                jmp asm_common
.abae					z_asm_rts:
.abae					xt_asm_sbc:
.abae	a9 ed		lda #$ed	                lda #$ED
.abb0	4c 56 ac	jmp $ac56	                jmp asm_common
.abb3					z_asm_sbc:
.abb3					xt_asm_sbc_h:
.abb3	a9 e9		lda #$e9	                lda #$E9
.abb5	4c 56 ac	jmp $ac56	                jmp asm_common
.abb8					z_asm_sbc_h:
.abb8					xt_asm_sbc_x:
.abb8	a9 fd		lda #$fd	                lda #$FD
.abba	4c 56 ac	jmp $ac56	                jmp asm_common
.abbd					z_asm_sbc_x:
.abbd					xt_asm_sbc_y:
.abbd	a9 f9		lda #$f9	                lda #$F9
.abbf	4c 56 ac	jmp $ac56	                jmp asm_common
.abc2					z_asm_sbc_y:
.abc2					xt_asm_sbc_z:
.abc2	a9 e5		lda #$e5	                lda #$E5
.abc4	4c 56 ac	jmp $ac56	                jmp asm_common
.abc7					z_asm_sbc_z:
.abc7					xt_asm_sbc_zi:
.abc7	a9 f2		lda #$f2	                lda #$F2
.abc9	4c 56 ac	jmp $ac56	                jmp asm_common
.abcc					z_asm_sbc_zi:
.abcc					xt_asm_sbc_ziy:
.abcc	a9 f1		lda #$f1	                lda #$F1
.abce	4c 56 ac	jmp $ac56	                jmp asm_common
.abd1					z_asm_sbc_ziy:
.abd1					xt_asm_sbc_zx:
.abd1	a9 f5		lda #$f5	                lda #$F5
.abd3	4c 56 ac	jmp $ac56	                jmp asm_common
.abd6					z_asm_sbc_zx:
.abd6					xt_asm_sbc_zxi:
.abd6	a9 e1		lda #$e1	                lda #$E1
.abd8	80 7c		bra $ac56	                bra asm_common  ; <-- limit for BRA instead of JMP
.abda					z_asm_sbc_zxi:
.abda					xt_asm_sec:
.abda	a9 38		lda #$38	                lda #$38
.abdc	80 78		bra $ac56	                bra asm_common
.abde					z_asm_sec:
.abde					xt_asm_sed:
.abde	a9 f8		lda #$f8	                lda #$F8
.abe0	80 74		bra $ac56	                bra asm_common
.abe2					z_asm_sed:
.abe2					xt_asm_sei:
.abe2	a9 78		lda #$78	                lda #$78
.abe4	80 70		bra $ac56	                bra asm_common
.abe6					z_asm_sei:
.abe6					xt_asm_sta:
.abe6	a9 8d		lda #$8d	                lda #$8D
.abe8	80 6c		bra $ac56	                bra asm_common
.abea					z_asm_sta:
.abea					xt_asm_sta_x:
.abea	a9 9d		lda #$9d	                lda #$9D
.abec	80 68		bra $ac56	                bra asm_common
.abee					z_asm_sta_x:
.abee					xt_asm_sta_y:
.abee	a9 99		lda #$99	                lda #$99
.abf0	80 64		bra $ac56	                bra asm_common
.abf2					z_asm_sta_y:
.abf2					xt_asm_sta_z:
.abf2	a9 85		lda #$85	                lda #$85
.abf4	80 60		bra $ac56	                bra asm_common
.abf6					z_asm_sta_z:
.abf6					xt_asm_sta_zi:
.abf6	a9 92		lda #$92	                lda #$92
.abf8	80 5c		bra $ac56	                bra asm_common
.abfa					z_asm_sta_zi:
.abfa					xt_asm_sta_ziy:
.abfa	a9 91		lda #$91	                lda #$91
.abfc	80 58		bra $ac56	                bra asm_common
.abfe					z_asm_sta_ziy:
.abfe					xt_asm_sta_zx:
.abfe	a9 95		lda #$95	                lda #$95
.ac00	80 54		bra $ac56	                bra asm_common
.ac02					z_asm_sta_zx:
.ac02					xt_asm_sta_zxi:
.ac02	a9 81		lda #$81	                lda #$81
.ac04	80 50		bra $ac56	                bra asm_common
.ac06					z_asm_sta_zxi:
.ac06					xt_asm_stx:
.ac06	a9 8e		lda #$8e	                lda #$8E
.ac08	80 4c		bra $ac56	                bra asm_common
.ac0a					z_asm_stx:
.ac0a					xt_asm_stx_z:
.ac0a	a9 86		lda #$86	                lda #$86
.ac0c	80 48		bra $ac56	                bra asm_common
.ac0e					z_asm_stx_z:
.ac0e					xt_asm_stx_zy:
.ac0e	a9 96		lda #$96	                lda #$96
.ac10	80 44		bra $ac56	                bra asm_common
.ac12					z_asm_stx_zy:
.ac12					xt_asm_sty:
.ac12	a9 8c		lda #$8c	                lda #$8C
.ac14	80 40		bra $ac56	                bra asm_common
.ac16					z_asm_sty:
.ac16					xt_asm_sty_z:
.ac16	a9 84		lda #$84	                lda #$84
.ac18	80 3c		bra $ac56	                bra asm_common
.ac1a					z_asm_sty_z:
.ac1a					xt_asm_sty_zx:
.ac1a	a9 94		lda #$94	                lda #$94
.ac1c	80 38		bra $ac56	                bra asm_common
.ac1e					z_asm_sty_zx:
.ac1e					xt_asm_stz:
.ac1e	a9 9c		lda #$9c	                lda #$9C
.ac20	80 34		bra $ac56	                bra asm_common
.ac22					z_asm_stz:
.ac22					xt_asm_stz_x:
.ac22	a9 9e		lda #$9e	                lda #$9E
.ac24	80 30		bra $ac56	                bra asm_common
.ac26					z_asm_stz_x:
.ac26					xt_asm_stz_z:
.ac26	a9 64		lda #$64	                lda #$64
.ac28	80 2c		bra $ac56	                bra asm_common
.ac2a					z_asm_stz_z:
.ac2a					xt_asm_stz_zx:
.ac2a	a9 74		lda #$74	                lda #$74
.ac2c	80 28		bra $ac56	                bra asm_common
.ac2e					z_asm_stz_zx:
.ac2e					xt_asm_tax:
.ac2e	a9 aa		lda #$aa	                lda #$AA
.ac30	80 24		bra $ac56	                bra asm_common
.ac32					z_asm_tax:
.ac32					xt_asm_tay:
.ac32	a9 a8		lda #$a8	                lda #$A8
.ac34	80 20		bra $ac56	                bra asm_common
.ac36					z_asm_tay:
.ac36					xt_asm_trb:
.ac36	a9 1c		lda #$1c	                lda #$1C
.ac38	80 1c		bra $ac56	                bra asm_common
.ac3a					z_asm_trb:
.ac3a					xt_asm_trb_z:
.ac3a	a9 14		lda #$14	                lda #$14
.ac3c	80 18		bra $ac56	                bra asm_common
.ac3e					z_asm_trb_z:
.ac3e					xt_asm_tsb:
.ac3e	a9 0c		lda #$0c	                lda #$0C
.ac40	80 14		bra $ac56	                bra asm_common
.ac42					z_asm_tsb:
.ac42					xt_asm_tsb_z:
.ac42	a9 04		lda #$04	                lda #$04
.ac44	80 10		bra $ac56	                bra asm_common
.ac46					z_asm_tsb_z:
.ac46					xt_asm_tsx:
.ac46	a9 ba		lda #$ba	                lda #$BA
.ac48	80 0c		bra $ac56	                bra asm_common
.ac4a					z_asm_tsx:
.ac4a					xt_asm_txa:
.ac4a	a9 8a		lda #$8a	                lda #$8A
.ac4c	80 08		bra $ac56	                bra asm_common
.ac4e					z_asm_txa:
.ac4e					xt_asm_txs:
.ac4e	a9 9a		lda #$9a	                lda #$9A
.ac50	80 04		bra $ac56	                bra asm_common
.ac52					z_asm_txs:
.ac52					xt_asm_tya:
.ac52	a9 98		lda #$98	                lda #$98
.ac54	80 00		bra $ac56	                bra asm_common
.ac56					z_asm_tya:
.ac56					asm_common:
.ac56	a8		tay		                tay
.ac57	20 fd d4	jsr $d4fd	                jsr cmpl_a
.ac5a	a9 55		lda #$55	                lda #<oc_index_table
.ac5c	85 26		sta $26		                sta tmp2
.ac5e	a9 ad		lda #$ad	                lda #>oc_index_table
.ac60	85 27		sta $27		                sta tmp2+1
.ac62	98		tya		                tya             ; retrieve opcode
.ac63	0a		asl a		                asl             ; times two for offset
.ac64	90 02		bcc $ac68	                bcc +
.ac66	e6 27		inc $27		                inc tmp2+1
.ac68					+
.ac68	a8		tay		                tay             ; use Y as the index
.ac69	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac6b	85 28		sta $28		                sta tmp3
.ac6d	c8		iny		                iny
.ac6e	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac70	85 29		sta $29		                sta tmp3+1
.ac72	b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac74	2a		rol a		                rol
.ac75	2a		rol a		                rol
.ac76	2a		rol a		                rol             ; Three times because we go through Carry
.ac77	29 03		and #$03	                and #%00000011
.ac79	a8		tay		                tay
.ac7a	88		dey		                dey
.ac7b	f0 12		beq $ac8f	                beq _done
.ac7d	20 4a d6	jsr $d64a	                jsr underflow_1
.ac80	b5 00		lda $00,x	                lda 0,x
.ac82	20 fd d4	jsr $d4fd	                jsr cmpl_a      ; does not use Y
.ac85	88		dey		                dey
.ac86	f0 05		beq $ac8d	                beq _done_drop
.ac88	b5 01		lda $01,x	                lda 1,x
.ac8a	20 fd d4	jsr $d4fd	                jsr cmpl_a      ; Fall through to _done_drop
.ac8d					_done_drop:
.ac8d	e8		inx		                inx
.ac8e	e8		inx		                inx             ; Fall through to _done
.ac8f					_done:
.ac8f	60		rts		                rts             ; Returns to original caller
.ac90					xt_asm_push_a:
.ac90	a0 00		ldy #$00	                ldy #0
.ac92					_loop:
.ac92	b9 a0 ac	lda $aca0,y	                lda asm_push_a_data,y
.ac95	c9 ff		cmp #$ff	                cmp #$FF
.ac97	f0 06		beq $ac9f	                beq _done
.ac99	20 fd d4	jsr $d4fd	                jsr cmpl_a      ; does not change Y
.ac9c	c8		iny		                iny
.ac9d	80 f3		bra $ac92	                bra _loop
.ac9f					_done:
.ac9f					z_asm_push_a:
.ac9f	60		rts		                rts
.aca0					asm_push_a_data:
>aca0	ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>aca6	ff				        .byte $FF               ; terminator
.aca7					xt_asm_back_jump:
.aca7					z_asm_back_jump:
.aca7	60		rts		                rts
.aca8					xt_asm_back_branch:
.aca8	20 62 91	jsr $9162	                jsr xt_here             ; ( addr-l addr-h )
.acab	20 40 95	jsr $9540	                jsr xt_minus            ; ( offset )
.acae	3a		dec a		                dea
.acaf	3a		dec a		                dea
.acb0					z_asm_back_branch:
.acb0	60		rts		                rts
.acb1					assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acb1					disassembler:
.acb1	20 53 89	jsr $8953	                jsr xt_cr       ; ( addr u )
.acb4					_byte_loop:
.acb4	20 74 98	jsr $9874	                jsr xt_over     ; ( addr u addr )
.acb7	20 09 a5	jsr $a509	                jsr xt_u_dot    ; ( addr u )
.acba	20 ff a0	jsr $a0ff	                jsr xt_space
.acbd	a9 55		lda #$55	                lda #<oc_index_table
.acbf	85 26		sta $26		                sta tmp2
.acc1	a9 ad		lda #$ad	                lda #>oc_index_table
.acc3	85 27		sta $27		                sta tmp2+1
.acc5	a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.acc7	0a		asl a		                asl             ; multiply by two for offset
.acc8	90 02		bcc $accc	                bcc +
.acca	e6 27		inc $27		                inc tmp2+1      ; we're on second page
.accc					+
.accc	a8		tay		                tay             ; use Y as the index
.accd	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.accf	85 28		sta $28		                sta tmp3
.acd1	48		pha		                pha
.acd2	c8		iny		                iny
.acd3	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acd5	85 29		sta $29		                sta tmp3+1
.acd7	48		pha		                pha
.acd8	b2 28		lda ($28)	                lda (tmp3)
.acda	a8		tay		                tay                     ; save copy of lengths byte
.acdb	10 38		bpl $ad15	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.acdd	20 82 a7	jsr $a782	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ace0	f6 04		inc $04,x	                inc 4,x
.ace2	d0 02		bne $ace6	                bne +
.ace4	f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ace6					+
.ace6	b5 02		lda $02,x	                lda 2,x
.ace8	d0 02		bne $acec	                bne +
.acea	d6 03		dec $03,x	                dec 3,x
.acec					+
.acec	d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.acee	a1 04		lda ($04,x)	                lda (4,x)
.acf0	95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.acf2	98		tya		                tya                     ; retrieve copy of lengths byte
.acf3	2a		rol a		                rol                     ; shift bit 6 to bit 7
.acf4	10 12		bpl $ad08	                bpl _print_operand
.acf6	f6 04		inc $04,x	                inc 4,x
.acf8	d0 02		bne $acfc	                bne +
.acfa	f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.acfc					+
.acfc	b5 02		lda $02,x	                lda 2,x
.acfe	d0 02		bne $ad02	                bne +
.ad00	d6 03		dec $03,x	                dec 3,x
.ad02					+
.ad02	d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad04	a1 04		lda ($04,x)	                lda (4,x)
.ad06	95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad08					_print_operand:
.ad08	ca		dex		                dex
.ad09	ca		dex		                dex
.ad0a	a9 05		lda #$05	                lda #5
.ad0c	95 00		sta $00,x	                sta 0,x
.ad0e	74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad10	20 15 a5	jsr $a515	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad13	80 0b		bra $ad20	                bra _print_mnemonic
.ad15					_no_operand:
.ad15	ca		dex		                dex
.ad16	ca		dex		                dex
.ad17	a9 05		lda #$05	                lda #5
.ad19	95 00		sta $00,x	                sta 0,x
.ad1b	74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad1d	20 05 a1	jsr $a105	                jsr xt_spaces           ; ( addr u )
.ad20					_print_mnemonic:
.ad20	20 ff a0	jsr $a0ff	                jsr xt_space
.ad23	ca		dex		                dex
.ad24	ca		dex		                dex                     ; ( addr u ? )
.ad25	68		pla		                pla                     ; MSB
.ad26	95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad28	68		pla		                pla                     ; LSB
.ad29	95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad2b	20 3f 89	jsr $893f	                jsr xt_count            ; ( addr u addr-o u-o )
.ad2e	74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad30	b5 00		lda $00,x	                lda 0,x
.ad32	29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad34	95 00		sta $00,x	                sta 0,x
.ad36	20 de a4	jsr $a4de	                jsr xt_type             ; ( addr u )
.ad39	20 53 89	jsr $8953	                jsr xt_cr
.ad3c	f6 02		inc $02,x	                inc 2,x
.ad3e	d0 02		bne $ad42	                bne +
.ad40	f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ad42					+
.ad42	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ad45	b5 00		lda $00,x	                lda 0,x                 ; All done?
.ad47	15 01		ora $01,x	                ora 1,x
.ad49	f0 07		beq $ad52	                beq _done
.ad4b	b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ad4d	30 03		bmi $ad52	                bmi _done
.ad4f	4c b4 ac	jmp $acb4	                jmp _byte_loop          ; out of range for BRA
.ad52					_done:
.ad52	4c 8b a3	jmp $a38b	                jmp xt_two_drop         ; JSR/RTS
.ad55					oc_index_table:
>ad55	55 af 59 af ed b3 ed b3		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>ad5d	61 af 67 af 6d af ed b3
>ad65	73 af 77 af 7d af ed b3		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>ad6d	83 af 87 af 8b af 8f af
>ad75	94 af 98 af a0 af ed b3		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>ad7d	a7 af ad af b4 af bb af
>ad85	c2 af c6 af cc af ed b3		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>ad8d	d2 af d6 af ed b3 dc af
>ad95	e2 af e6 af ed b3 ed b3		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>ad9d	ee af f4 af fa af 00 b0
>ada5	07 b0 0b b0 11 b0 ed b3		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>adad	17 b0 1b b0 20 b0 24 b0
>adb5	29 b0 2d b0 35 b0 ed b3		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>adbd	3c b0 44 b0 4b b0 52 b0
>adc5	59 b0 5d b0 63 b0 ed b3		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>adcd	69 b0 6f b0 75 b0 8f af
>add5	80 b0 84 b0 ed b3 ed b3		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>addd	ed b3 8c b0 92 b0 98 b0
>ade5	9f b0 a3 b0 a9 b0 ed b3		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>aded	af b0 b3 b0 b7 b0 bb b0
>adf5	c0 b0 c4 b0 cc b0 ed b3		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>adfd	ed b3 d3 b0 da b0 e1 b0
>ae05	e8 b0 ec b0 f2 b0 ed b3		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>ae0d	ed b3 ed b3 fc b0 02 b1
>ae15	07 b1 0b b1 ed b3 ed b3		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>ae1d	13 b1 19 b1 1f b1 25 b1
>ae25	2c b1 30 b1 36 b1 ed b3		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>ae2d	3c b1 42 b1 46 b1 4a b1
>ae35	4f b1 53 b1 5b b1 ed b3		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>ae3d	62 b1 69 b1 70 b1 77 b1
>ae45	7e b1 82 b1 88 b1 ed b3		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>ae4d	8c b1 93 b1 99 b1 9f b1
>ae55	a4 b1 a8 b1 ed b3 ed b3		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>ae5d	b0 b1 b6 b1 bc b1 ed b3
>ae65	c2 b1 c6 b1 cc b1 ed b3		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>ae6d	d0 b1 d4 b1 d8 b1 dc b1
>ae75	e1 b1 e5 b1 ed b1 ed b3		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>ae7d	f4 b1 fb b1 02 b2 09 b2
>ae85	10 b2 14 b2 1a b2 ed b3		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>ae8d	1e b2 22 b2 28 b2 2e b2
>ae95	33 b2 39 b2 41 b2 ed b3		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>ae9d	47 b2 4d b2 53 b2 59 b2
>aea5	60 b2 64 b2 6a b2 ed b3		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>aead	6e b2 72 b2 76 b2 7a b2
>aeb5	7f b2 83 b2 8b b2 ed b3		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>aebd	92 b2 99 b2 a0 b2 a7 b2
>aec5	ae b2 b2 b2 b8 b2 ed b3		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>aecd	bc b2 c2 b2 c8 b2 ce b2
>aed5	d3 b2 d9 b2 ed b3 ed b3		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>aedd	e1 b2 e7 b2 ed b2 f3 b2
>aee5	fa b2 fe b2 04 b3 ed b3		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>aeed	08 b3 0c b3 10 b3 14 b3
>aef5	19 b3 1d b3 25 b3 ed b3		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>aefd	ed b3 2c b3 33 b3 3a b3
>af05	41 b3 45 b3 4b b3 ed b3		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>af0d	ed b3 4f b3 55 b3 5b b3
>af15	60 b3 66 b3 ed b3 ed b3		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>af1d	6e b3 74 b3 7a b3 80 b3
>af25	87 b3 8b b3 91 b3 ed b3		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>af2d	95 b3 99 b3 9d b3 a1 b3
>af35	a6 b3 aa b3 b2 b3 ed b3		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>af3d	ed b3 b9 b3 c0 b3 c7 b3
>af45	ce b3 d2 b3 d8 b3 ed b3		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>af4d	ed b3 dc b3 e2 b3 e8 b3
.af55					oc_table:
>af55	83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>af59	87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>af61	85 74 73 62 2e 7a		        oc04:   .text 2*64+5, "tsb.z"
>af67	85 6f 72 64 2e 7a			oc05:	.text 2*64+5, "ord.z"
>af6d	85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>af73	43 70 68 70				oc08:	.text 1*64+3, "php"
>af77	85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>af7d	45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>af83	c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>af87	c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>af8b	c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>af8f	c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>af94	83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>af98	87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>afa0	86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>afa7	85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>afad	86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>afb4	86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>afbb	86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>afc2	43 63 6c 63				oc18:	.text 1*64+3, "clc"
>afc6	c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>afcc	45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>afd2	c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>afd6	c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>afdc	c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>afe2	c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>afe6	87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>afee	85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>aff4	85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>affa	85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b000	86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b007	43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b00b	85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b011	45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b017	c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b01b	c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b020	c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b024	c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b029	83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b02d	87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b035	86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b03c	87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b044	86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b04b	86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b052	86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b059	43 73 65 63				oc38:	.text 1*64+3, "sec"
>b05d	c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b063	45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b069	c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b06f	c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b075	c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b07b	c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b080	43 72 74 69				oc40:	.text 1*64+3, "rti"
>b084	87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b08c	85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b092	85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b098	86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b09f	43 70 68 61				oc48:	.text 1*64+3, "pha"
>b0a3	85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b0a9	45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b0af	c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b0b3	c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b0b7	c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b0bb	c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b0c0	83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b0c4	87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b0cc	86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b0d3	86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b0da	86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b0e1	86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b0e8	43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b0ec	c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b0f2	43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b0f6	c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b0fc	c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b102	c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b107	43 72 74 73				oc60:	.text 1*64+3, "rts"
>b10b	87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b113	85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b119	85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b11f	85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b125	86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b12c	43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b130	85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b136	45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b13c	c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b142	c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b146	c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b14a	c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b14f	83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b153	87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b15b	86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b162	86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b169	86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b170	86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b177	86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b17e	43 73 65 69				oc78:	.text 1*64+3, "sei"
>b182	c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b188	43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b18c	c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b193	c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b199	c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b19f	c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b1a4	83 62 72 61				oc80:	.text 2*64+3, "bra"
>b1a8	87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b1b0	85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b1b6	85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b1bc	85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b1c2	43 64 65 79				oc88:	.text 1*64+3, "dey"
>b1c6	85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b1cc	43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b1d0	c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b1d4	c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b1d8	c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b1dc	c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b1e1	83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b1e5	87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b1ed	86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b1f4	86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b1fb	86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b202	86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b209	86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b210	43 74 79 61				oc98:	.text 1*64+3, "tya"
>b214	c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b21a	43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b21e	c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b222	c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b228	c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b22e	c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b233	85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b239	87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b241	85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b247	85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b24d	85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b253	85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b259	86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b260	43 74 61 79				oca8:	.text 1*64+3, "tay"
>b264	85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b26a	43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b26e	c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b272	c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b276	c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b27a	c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b27f	83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b283	87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b28b	86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b292	86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b299	86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b2a0	86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b2a7	86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b2ae	43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b2b2	c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b2b8	43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b2bc	c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b2c2	c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b2c8	c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b2ce	c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b2d3	85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b2d9	87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b2e1	85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b2e7	85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b2ed	85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b2f3	86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b2fa	43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b2fe	85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b304	43 64 65 78				occa:	.text 1*64+3, "dex"
>b308	c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b30c	c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b310	c3 64 65 63				occe:	.text 3*64+3, "dec"
>b314	c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b319	83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b31d	87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b325	86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b32c	86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b333	86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b33a	86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b341	43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b345	c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b34b	43 70 68 78				ocda:	.text 1*64+3, "phx"
>b34f	c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b355	c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b35b	c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b360	85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b366	87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b36e	85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b374	85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b37a	85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b380	86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b387	43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b38b	85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b391	43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b395	c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b399	c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b39d	c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b3a1	c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b3a6	83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b3aa	87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b3b2	86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b3b9	86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b3c0	86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b3c7	86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b3ce	43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b3d2	c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b3d8	43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b3dc	c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b3e2	c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b3e8	c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b3ed	01 3f					oc__:	.text 1, "?"
.b3ef					disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=46					ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=48					ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=50					ed_flags = editor3  ; Flags used by ed, where
.b3ef					ed6502:
.b3ef	64 2e		stz $2e		                stz ed_head
.b3f1	64 2f		stz $2f		                stz ed_head+1
.b3f3	64 30		stz $30		                stz ed_cur
.b3f5	64 31		stz $31		                stz ed_cur+1
.b3f7	64 32		stz $32		                stz ed_flags
.b3f9	20 82 a7	jsr $a782	                jsr xt_zero
.b3fc	20 82 a7	jsr $a782	                jsr xt_zero             ; ( addr-t u-t )
.b3ff	20 53 89	jsr $8953	                jsr xt_cr
.b402					ed_input_loop:
.b402	a9 81		lda #$81	                lda #%10000001
.b404	14 32		trb $32		                trb ed_flags
.b406	20 cd b8	jsr $b8cd	                jsr ed_get_input
.b409	a5 0a		lda $0a		                lda ciblen
.b40b	d0 1f		bne $b42c	                bne _command_mode
.b40d	ca		dex		                dex
.b40e	ca		dex		                dex                     ; ( addr-t u-t ? )
.b40f	a5 30		lda $30		                lda ed_cur
.b411	95 00		sta $00,x	                sta 0,x
.b413	a5 31		lda $31		                lda ed_cur+1
.b415	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b417	a9 80		lda #$80	                lda #%10000000
.b419	04 32		tsb $32		                tsb ed_flags
.b41b	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b41e	20 e9 b8	jsr $b8e9	                jsr ed_is_valid_line
.b421	b0 03		bcs $b426	                bcs +
.b423	4c bd b8	jmp $b8bd	                jmp ed_error_1drop
.b426					+
.b426	20 82 a7	jsr $a782	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b429	4c f7 b4	jmp $b4f7	                jmp _line_number_only_from_external
.b42c					_command_mode:
.b42c	20 82 a7	jsr $a782	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b42f	20 82 a7	jsr $a782	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b432					_prefix_dot:
.b432	b2 08		lda ($08)	                lda (cib)
.b434	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b436	d0 3a		bne $b472	                bne _prefix_dollar
.b438	20 de b8	jsr $b8de	                jsr ed_have_text
.b43b	a5 30		lda $30		                lda ed_cur
.b43d	95 02		sta $02,x	                sta 2,x
.b43f	a5 31		lda $31		                lda ed_cur+1
.b441	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b443	a9 80		lda #$80	                lda #%10000000
.b445	04 32		tsb $32		                tsb ed_flags
.b447	a5 0a		lda $0a		                lda ciblen
.b449	3a		dec a		                dea                     ; sets Z if A was 1
.b44a	d0 03		bne $b44f	                bne +
.b44c	4c f7 b4	jmp $b4f7	                jmp _line_number_only_from_external
.b44f					+
.b44f	ca		dex		                dex
.b450	ca		dex		                dex
.b451	ca		dex		                dex
.b452	ca		dex		                dex
.b453	a5 08		lda $08		                lda cib
.b455	95 02		sta $02,x	                sta 2,x
.b457	a5 09		lda $09		                lda cib+1
.b459	95 03		sta $03,x	                sta 3,x
.b45b	a5 0a		lda $0a		                lda ciblen
.b45d	95 00		sta $00,x	                sta 0,x
.b45f	a5 0b		lda $0b		                lda ciblen+1
.b461	95 01		sta $01,x	                sta 1,x
.b463	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b466	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b469	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b46c	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b46f	4c 4f b5	jmp $b54f	                jmp _check_for_para2
.b472					_prefix_dollar:
.b472	b2 08		lda ($08)	                lda (cib)
.b474	c9 24		cmp #$24	                cmp #'$'
.b476	d0 1c		bne $b494	                bne _prefix_percent
.b478	20 de b8	jsr $b8de	                jsr ed_have_text
.b47b	e8		inx		                inx
.b47c	e8		inx		                inx                     ; ( addr-t u-t 0 )
.b47d	20 0b b9	jsr $b90b	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b480	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b483	a9 80		lda #$80	                lda #%10000000
.b485	04 32		tsb $32		                tsb ed_flags
.b487	a5 0a		lda $0a		                lda ciblen
.b489	3a		dec a		                dea                     ; sets Z if A was 1
.b48a	d0 03		bne $b48f	                bne +
.b48c	4c f7 b4	jmp $b4f7	                jmp _line_number_only_from_external
.b48f					+
.b48f	a0 01		ldy #$01	                ldy #01
.b491	4c cb b5	jmp $b5cb	                jmp _check_command
.b494					_prefix_percent:
.b494	b2 08		lda ($08)	                lda (cib)
.b496	c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b498	f0 04		beq $b49e	                beq _whole_text
.b49a	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b49c	d0 17		bne $b4b5	                bne _prefix_semicolon
.b49e					_whole_text:
.b49e	20 de b8	jsr $b8de	                jsr ed_have_text
.b4a1	a9 01		lda #$01	                lda #01
.b4a3	95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b4a5	74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b4a7					_semicolon_entry:
.b4a7	e8		inx		                inx
.b4a8	e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b4a9	20 0b b9	jsr $b90b	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b4ac	a9 80		lda #$80	                lda #%10000000
.b4ae	04 32		tsb $32		                tsb ed_flags
.b4b0	a0 01		ldy #$01	                ldy #01
.b4b2	4c cb b5	jmp $b5cb	                jmp _check_command
.b4b5					_prefix_semicolon:
.b4b5	b2 08		lda ($08)	                lda (cib)
.b4b7	c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b4b9	d0 0d		bne $b4c8	                bne _prefix_number
.b4bb	20 de b8	jsr $b8de	                jsr ed_have_text
.b4be	a5 30		lda $30		                lda ed_cur
.b4c0	95 02		sta $02,x	                sta 2,x
.b4c2	a5 31		lda $31		                lda ed_cur+1
.b4c4	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b4c6	80 df		bra $b4a7	                bra _semicolon_entry
.b4c8					_prefix_number:
.b4c8	20 82 a7	jsr $a782	                jsr xt_zero
.b4cb	20 82 a7	jsr $a782	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b4ce	ca		dex		                dex
.b4cf	ca		dex		                dex
.b4d0	ca		dex		                dex
.b4d1	ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b4d2	a5 08		lda $08		                lda cib
.b4d4	95 02		sta $02,x	                sta 2,x
.b4d6	a5 09		lda $09		                lda cib+1
.b4d8	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b4da	a5 0a		lda $0a		                lda ciblen
.b4dc	95 00		sta $00,x	                sta 0,x
.b4de	a5 0b		lda $0b		                lda ciblen+1
.b4e0	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b4e2	20 98 a2	jsr $a298	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b4e5	b5 00		lda $00,x	                lda 0,x
.b4e7	15 01		ora $01,x	                ora 1,x
.b4e9	d0 24		bne $b50f	                bne _have_unconverted_chars
.b4eb	e8		inx		                inx
.b4ec	e8		inx		                inx
.b4ed	e8		inx		                inx
.b4ee	e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b4ef	20 70 8a	jsr $8a70	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b4f2	20 5e 96	jsr $965e	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b4f5	e8		inx		                inx
.b4f6	e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b4f7					_line_number_only_from_external:
.b4f7	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b4fa	20 e9 b8	jsr $b8e9	                jsr ed_is_valid_line
.b4fd	b0 03		bcs $b502	                bcs +
.b4ff	4c bb b8	jmp $b8bb	                jmp ed_error_2drop
.b502					+
.b502	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b505	20 78 b9	jsr $b978	                jsr ed_para1_to_cur
.b508	a9 80		lda #$80	                lda #%10000000
.b50a	04 32		tsb $32		                tsb ed_flags
.b50c	4c a6 b7	jmp $b7a6	                jmp ed_cmd_p_from_external
.b50f					_have_unconverted_chars:
.b50f	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b512	ca		dex		                dex
.b513	ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b514	a5 0a		lda $0a		                lda ciblen
.b516	95 00		sta $00,x	                sta 0,x
.b518	a5 0b		lda $0b		                lda ciblen+1
.b51a	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b51c	20 be 8e	jsr $8ebe	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b51f	b5 00		lda $00,x	                lda 0,x
.b521	15 01		ora $01,x	                ora 1,x
.b523	f0 0e		beq $b533	                beq _no_command_yet
.b525	8a		txa		                txa
.b526	18		clc		                clc
.b527	69 0a		adc #$0a	                adc #10
.b529	aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b52a	a9 80		lda #$80	                lda #%10000000
.b52c	14 32		trb $32		                trb ed_flags
.b52e	a0 00		ldy #$00	                ldy #00
.b530	4c cb b5	jmp $b5cb	                jmp _check_command
.b533					_no_command_yet:
.b533	e8		inx		                inx
.b534	e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b535	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b538	20 5e 96	jsr $965e	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b53b	20 70 8a	jsr $8a70	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b53e	b5 00		lda $00,x	                lda 0,x                 ; LSB
.b540	95 06		sta $06,x	                sta 6,x
.b542	b5 01		lda $01,x	                lda 1,x                 ; MSB
.b544	95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b546	e8		inx		                inx
.b547	e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b548	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b54b	a9 80		lda #$80	                lda #%10000000
.b54d	04 32		tsb $32		                tsb ed_flags
.b54f					_check_for_para2:
.b54f	a1 02		lda ($02,x)	                lda (2,x)
.b551	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b553	f0 0d		beq $b562	                beq _got_comma
.b555	38		sec		                sec
.b556	a5 0a		lda $0a		                lda ciblen
.b558	f5 00		sbc $00,x	                sbc 0,x
.b55a	a8		tay		                tay
.b55b	e8		inx		                inx
.b55c	e8		inx		                inx
.b55d	e8		inx		                inx
.b55e	e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b55f	4c cb b5	jmp $b5cb	                jmp _check_command
.b562					_got_comma:
.b562	f6 02		inc $02,x	                inc 2,x
.b564	d0 02		bne $b568	                bne +
.b566	f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b568					+
.b568	b5 01		lda $01,x	                lda 1,x
.b56a	f0 02		beq $b56e	                beq +
.b56c	d6 01		dec $01,x	                dec 1,x
.b56e					+
.b56e	d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b570	a1 02		lda ($02,x)	                lda (2,x)
.b572	c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b574	d0 14		bne $b58a	                bne _para2_not_dollar
.b576	38		sec		                sec
.b577	a5 0a		lda $0a		                lda ciblen
.b579	f5 02		sbc $02,x	                sbc 2,x
.b57b	a8		tay		                tay
.b57c	c8		iny		                iny
.b57d	5a		phy		                phy
.b57e	8a		txa		                txa
.b57f	18		clc		                clc
.b580	69 06		adc #$06	                adc #06
.b582	aa		tax		                tax                     ; ( addr-t u-t para1 )
.b583	20 0b b9	jsr $b90b	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b586	7a		ply		                ply
.b587	4c cb b5	jmp $b5cb	                jmp _check_command
.b58a					_para2_not_dollar:
.b58a	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b58d	20 82 a7	jsr $a782	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b590	20 82 a7	jsr $a782	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b593	20 38 9b	jsr $9b38	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b596	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b599	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b59c	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b59f	20 98 a2	jsr $a298	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b5a2	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b5a5	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b5a8	20 be 8e	jsr $8ebe	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b5ab	b5 00		lda $00,x	                lda 0,x
.b5ad	15 01		ora $01,x	                ora 1,x
.b5af	f0 08		beq $b5b9	                beq _second_number
.b5b1	8a		txa		                txa
.b5b2	18		clc		                clc
.b5b3	69 0c		adc #$0c	                adc #12
.b5b5	aa		tax		                tax                     ; back to ( addr-t u-t )
.b5b6	4c bf b8	jmp $b8bf	                jmp ed_error
.b5b9					_second_number:
.b5b9	e8		inx		                inx
.b5ba	e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b5bb	38		sec		                sec
.b5bc	a5 0a		lda $0a		                lda ciblen
.b5be	f5 00		sbc $00,x	                sbc 0,x
.b5c0	48		pha		                pha
.b5c1	20 8b a3	jsr $a38b	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b5c4	20 70 8a	jsr $8a70	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b5c7	20 32 96	jsr $9632	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b5ca	7a		ply		                ply
.b5cb					_check_command:
.b5cb	b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b5cd	85 24		sta $24		                sta tmp1
.b5cf	da		phx		                phx
.b5d0	a2 00		ldx #$00	                ldx #00
.b5d2					_cmd_loop:
.b5d2	bd a3 b9	lda $b9a3,x	                lda ed_cmd_list,x
.b5d5	f0 07		beq $b5de	                beq _illegal_command    ; zero marks end of list
.b5d7	c5 24		cmp $24		                cmp tmp1
.b5d9	f0 07		beq $b5e2	                beq _found_cmd
.b5db	e8		inx		                inx
.b5dc	80 f4		bra $b5d2	                bra _cmd_loop
.b5de					_illegal_command:
.b5de	fa		plx		                plx
.b5df	4c bb b8	jmp $b8bb	                jmp ed_error_2drop
.b5e2					_found_cmd:
.b5e2	8a		txa		                txa
.b5e3	0a		asl a		                asl
.b5e4	aa		tax		                tax                     ; X * 2 for table
.b5e5	7c ae b9	jmp ($b9ae,x)	                jmp (ed_cmd_table,x)
.b5e8					ed_next_command:
.b5e8	e8		inx		                inx
.b5e9	e8		inx		                inx
.b5ea	e8		inx		                inx
.b5eb	e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b5ec					_next_command_empty:
.b5ec	4c 02 b4	jmp $b402	                jmp ed_input_loop
.b5ef					ed_all_done:
.b5ef	64 0a		stz $0a		                stz ciblen
.b5f1	64 0b		stz $0b		                stz ciblen+1
.b5f3	20 8b a3	jsr $a38b	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b5f6	60		rts		                rts
.b5f7					ed_cmd_a:
.b5f7	fa		plx		                plx
.b5f8	e8		inx		                inx
.b5f9	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b5fa	24 32		bit $32		                bit ed_flags
.b5fc	30 08		bmi $b606	                bmi ed_cmd_a_have_para
.b5fe	a5 30		lda $30		                lda ed_cur
.b600	95 00		sta $00,x	                sta 0,x
.b602	a5 31		lda $31		                lda ed_cur+1
.b604	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b606					ed_entry_cmd_i:
.b606					ed_cmd_a_have_para:
.b606	20 41 b9	jsr $b941	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b609	20 53 89	jsr $8953	                jsr xt_cr
.b60c					_next_string_loop:
.b60c	20 cd b8	jsr $b8cd	                jsr ed_get_input
.b60f	b2 08		lda ($08)	                lda (cib)
.b611	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b613	d0 16		bne $b62b	                bne _add_line
.b615	a4 0a		ldy $0a		                ldy ciblen
.b617	c0 01		cpy #$01	                cpy #01
.b619	d0 10		bne $b62b	                bne _add_line
.b61b	a4 0b		ldy $0b		                ldy ciblen+1
.b61d	d0 0c		bne $b62b	                bne _add_line
.b61f	e8		inx		                inx
.b620	e8		inx		                inx
.b621	a9 40		lda #$40	                lda #%01000000
.b623	04 32		tsb $32		                tsb ed_flags
.b625	20 53 89	jsr $8953	                jsr xt_cr
.b628	4c 02 b4	jmp $b402	                jmp ed_input_loop
.b62b					_add_line:
.b62b	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b62e	20 62 91	jsr $9162	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b631	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b634	20 70 8f	jsr $8f70	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b637	20 5e 87	jsr $875e	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b63a	20 68 a3	jsr $a368	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b63d	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b640	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-t u-t here )
.b643	20 62 91	jsr $9162	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b646	a5 00		lda $00		                lda cp
.b648	18		clc		                clc
.b649	69 04		adc #$04	                adc #04
.b64b	85 00		sta $00		                sta cp
.b64d	90 02		bcc $b651	                bcc +
.b64f	e6 01		inc $01		                inc cp+1
.b651					+
.b651	e6 30		inc $30		                inc ed_cur
.b653	d0 02		bne $b657	                bne +
.b655	e6 31		inc $31		                inc ed_cur+1
.b657					+
.b657	20 62 91	jsr $9162	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b65a	20 9f 8d	jsr $8d9f	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b65d	ca		dex		                dex
.b65e	ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b65f	a5 08		lda $08		                lda cib
.b661	95 00		sta $00,x	                sta 0,x
.b663	a5 09		lda $09		                lda cib+1
.b665	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b667	20 89 a1	jsr $a189	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b66a	ca		dex		                dex
.b66b	ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b66c	a5 0a		lda $0a		                lda ciblen
.b66e	95 00		sta $00,x	                sta 0,x
.b670	a5 0b		lda $0b		                lda ciblen+1
.b672	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b674	20 b2 95	jsr $95b2	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b677	18		clc		                clc
.b678	a5 00		lda $00		                lda cp
.b67a	65 0a		adc $0a		                adc ciblen
.b67c	85 00		sta $00		                sta cp
.b67e	90 06		bcc $b686	                bcc +
.b680	a5 01		lda $01		                lda cp+1
.b682	65 0b		adc $0b		                adc ciblen+1
.b684	85 01		sta $01		                sta cp+1
.b686					+
.b686	20 74 98	jsr $9874	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b689	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b68c	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+
.b68f	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b692	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b695	a5 0a		lda $0a		                lda ciblen
.b697	95 02		sta $02,x	                sta 2,x
.b699	a5 0b		lda $0b		                lda ciblen+1
.b69b	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b69d	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-t u-t here )
.b6a0	20 53 89	jsr $8953	                jsr xt_cr
.b6a3	4c 0c b6	jmp $b60c	                jmp _next_string_loop
.b6a6					ed_cmd_d:
.b6a6	fa		plx		                plx
.b6a7	20 de b8	jsr $b8de	                jsr ed_have_text
.b6aa	20 33 b9	jsr $b933	                jsr ed_no_line_zero
.b6ad	b5 00		lda $00,x	                lda 0,x
.b6af	15 01		ora $01,x	                ora 1,x
.b6b1	d0 08		bne $b6bb	                bne +
.b6b3	20 74 98	jsr $9874	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b6b6	20 f8 b6	jsr $b6f8	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b6b9	80 33		bra $b6ee	                bra _cmd_d_done
.b6bb					+
.b6bb	20 e9 b8	jsr $b8e9	                jsr ed_is_valid_line      ; result is in C flag
.b6be	b0 03		bcs $b6c3	                bcs _cmd_d_loop
.b6c0	4c bb b8	jmp $b8bb	                jmp ed_error_2drop
.b6c3					_cmd_d_loop:
.b6c3	20 93 a3	jsr $a393	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b6c6	20 4d 91	jsr $914d	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b6c9	b5 00		lda $00,x	                lda 0,x
.b6cb	15 01		ora $01,x	                ora 1,x
.b6cd	d0 0d		bne $b6dc	                bne _cmd_d_done_with_flag
.b6cf	e8		inx		                inx
.b6d0	e8		inx		                inx                     ; Get rid of the flag from >
.b6d1	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b6d4	20 f8 b6	jsr $b6f8	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b6d7	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b6da	80 e7		bra $b6c3	                bra _cmd_d_loop
.b6dc					_cmd_d_done_with_flag:
.b6dc	e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b6dd	e8		inx		                inx
.b6de	b5 02		lda $02,x	                lda 2,x
.b6e0	d0 02		bne $b6e4	                bne +
.b6e2	d6 03		dec $03,x	                dec 3,x
.b6e4					+
.b6e4	d6 02		dec $02,x	                dec 2,x
.b6e6	b5 02		lda $02,x	                lda 2,x
.b6e8	85 30		sta $30		                sta ed_cur
.b6ea	b5 03		lda $03,x	                lda 3,x
.b6ec	85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b6ee					_cmd_d_done:
.b6ee	a9 40		lda #$40	                lda #%01000000
.b6f0	04 32		tsb $32		                tsb ed_flags
.b6f2	20 53 89	jsr $8953	                jsr xt_cr
.b6f5	4c e8 b5	jmp $b5e8	                jmp ed_next_command
.b6f8					_cmd_d_common:
.b6f8	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b6fb	20 41 b9	jsr $b941	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b6fe	20 70 8f	jsr $8f70	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b701	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b704	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b707	20 41 b9	jsr $b941	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b70a	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-t u-t )
.b70d	60		rts		                rts
.b70e					ed_cmd_equ:
.b70e	fa		plx		                plx
.b70f	a5 2e		lda $2e		                lda ed_head
.b711	05 2f		ora $2f		                ora ed_head+1
.b713	d0 08		bne $b71d	                bne _cmd_equ_have_text
.b715	ca		dex		                dex
.b716	ca		dex		                dex
.b717	74 00		stz $00,x	                stz 0,x
.b719	74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b71b	80 21		bra $b73e	                bra _cmd_equ_done
.b71d					_cmd_equ_have_text:
.b71d	20 33 b9	jsr $b933	                jsr ed_no_line_zero
.b720	24 32		bit $32		                bit ed_flags
.b722	30 0c		bmi $b730	                bmi _cmd_equ_have_para
.b724	ca		dex		                dex
.b725	ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b726	a5 30		lda $30		                lda ed_cur
.b728	95 00		sta $00,x	                sta 0,x
.b72a	a5 31		lda $31		                lda ed_cur+1
.b72c	95 01		sta $01,x	                sta 1,x
.b72e	80 0e		bra $b73e	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b730					_cmd_equ_have_para:
.b730	b5 00		lda $00,x	                lda 0,x
.b732	15 01		ora $01,x	                ora 1,x
.b734	d0 05		bne $b73b	                bne _cmd_equ_two_paras
.b736	20 74 98	jsr $9874	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b739	80 03		bra $b73e	                bra _cmd_equ_done
.b73b					_cmd_equ_two_paras:
.b73b	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b73e					_cmd_equ_done:
.b73e	20 53 89	jsr $8953	                jsr xt_cr               ; number goes on new line
.b741	20 09 a5	jsr $a509	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b744	20 53 89	jsr $8953	                jsr xt_cr
.b747	4c e8 b5	jmp $b5e8	                jmp ed_next_command
.b74a					ed_cmd_f:
.b74a	fa		plx		                plx
.b74b	24 32		bit $32		                bit ed_flags
.b74d	30 17		bmi $b766	                bmi _cmd_f_have_para
.b74f	20 53 89	jsr $8953	                jsr xt_cr
.b752	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b755	20 38 9b	jsr $9b38	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b758	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b75b	20 09 a5	jsr $a509	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b75e	20 5e 96	jsr $965e	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b761	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b764	80 11		bra $b777	                bra _cmd_f_done
.b766					_cmd_f_have_para:
.b766	20 74 98	jsr $9874	                jsr xt_over
.b769	20 53 89	jsr $8953	                jsr xt_cr
.b76c	20 09 a5	jsr $a509	                jsr xt_u_dot
.b76f	b5 02		lda $02,x	                lda 2,x
.b771	95 06		sta $06,x	                sta 6,x
.b773	b5 03		lda $03,x	                lda 3,x
.b775	95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b777					_cmd_f_done:
.b777	20 53 89	jsr $8953	                jsr xt_cr
.b77a	4c e8 b5	jmp $b5e8	                jmp ed_next_command
.b77d					ed_cmd_i:
.b77d	fa		plx		                plx
.b77e	e8		inx		                inx
.b77f	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b780	24 32		bit $32		                bit ed_flags
.b782	30 08		bmi $b78c	                bmi _cmd_i_have_para
.b784	a5 30		lda $30		                lda ed_cur
.b786	95 00		sta $00,x	                sta 0,x
.b788	a5 31		lda $31		                lda ed_cur+1
.b78a	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b78c					_cmd_i_have_para:
.b78c	b5 00		lda $00,x	                lda 0,x
.b78e	15 01		ora $01,x	                ora 1,x
.b790	f0 09		beq $b79b	                beq _cmd_i_done
.b792	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b795	20 82 a7	jsr $a782	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b798	20 08 95	jsr $9508	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b79b					_cmd_i_done:
.b79b	4c 06 b6	jmp $b606	                jmp ed_entry_cmd_i
.b79e					ed_cmd_n:
.b79e	fa		plx		                plx
.b79f	a9 01		lda #$01	                lda #%00000001
.b7a1	04 32		tsb $32		                tsb ed_flags
.b7a3	80 05		bra $b7aa	                bra ed_cmd_p_entry_for_cmd_n
.b7a5					ed_cmd_p:
.b7a5	fa		plx		                plx
.b7a6					ed_cmd_p_from_external:
.b7a6	a9 01		lda #$01	                lda #%00000001
.b7a8	14 32		trb $32		                trb ed_flags
.b7aa					ed_cmd_p_entry_for_cmd_n:
.b7aa	20 de b8	jsr $b8de	                jsr ed_have_text
.b7ad	20 33 b9	jsr $b933	                jsr ed_no_line_zero
.b7b0	20 53 89	jsr $8953	                jsr xt_cr
.b7b3	b5 00		lda $00,x	                lda 0,x
.b7b5	15 01		ora $01,x	                ora 1,x
.b7b7	d0 08		bne $b7c1	                bne _cmd_p_loop
.b7b9	20 74 98	jsr $9874	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b7bc	20 e2 b7	jsr $b7e2	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b7bf	80 1e		bra $b7df	                bra _cmd_p_all_done
.b7c1					_cmd_p_loop:
.b7c1	20 93 a3	jsr $a393	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b7c4	20 4d 91	jsr $914d	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b7c7	b5 00		lda $00,x	                lda 0,x
.b7c9	15 01		ora $01,x	                ora 1,x
.b7cb	d0 10		bne $b7dd	                bne _cmd_p_done
.b7cd	e8		inx		                inx
.b7ce	e8		inx		                inx                     ; Get rid of the flag from >
.b7cf	20 74 98	jsr $9874	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b7d2	20 e2 b7	jsr $b7e2	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b7d5	f6 02		inc $02,x	                inc 2,x
.b7d7	d0 02		bne $b7db	                bne +
.b7d9	f6 03		inc $03,x	                inc 3,x
.b7db					+
.b7db	80 e4		bra $b7c1	                bra _cmd_p_loop
.b7dd					_cmd_p_done:
.b7dd	e8		inx		                inx
.b7de	e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b7df					_cmd_p_all_done:
.b7df	4c e8 b5	jmp $b5e8	                jmp ed_next_command
.b7e2					_cmd_p_common:
.b7e2	a5 32		lda $32		                lda ed_flags
.b7e4	4a		lsr a		                lsr                     ; bit 0 now in carry
.b7e5	90 0b		bcc $b7f2	                bcc _cmd_p_common_no_num
.b7e7	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b7ea	20 09 a5	jsr $a509	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b7ed	a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b7ef	20 e6 8d	jsr $8de6	                jsr emit_a
.b7f2					_cmd_p_common_no_num:
.b7f2	20 41 b9	jsr $b941	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b7f5	20 81 b9	jsr $b981	                jsr ed_print_addr
.b7f8	60		rts		                rts
.b7f9					ed_cmd_q:
.b7f9	fa		plx		                plx
.b7fa	24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b7fc	50 03		bvc $b801	                bvc +
.b7fe	4c bb b8	jmp $b8bb	                jmp ed_error_2drop
.b801					+
.b801	4c ef b5	jmp $b5ef	                jmp ed_all_done            ; can't fall thru because of PLX
.b804					ed_cmd_qq:
.b804	fa		plx		                plx
.b805	4c ef b5	jmp $b5ef	                jmp ed_all_done
.b808					ed_cmd_w:
.b808	fa		plx		                plx
.b809	20 de b8	jsr $b8de	                jsr ed_have_text
.b80c	24 32		bit $32		                bit ed_flags
.b80e	30 13		bmi $b823	                bmi _cmd_w_have_para
.b810	b5 06		lda $06,x	                lda 6,x
.b812	15 07		ora $07,x	                ora 7,x
.b814	d0 03		bne $b819	                bne +
.b816	4c bb b8	jmp $b8bb	                jmp ed_error_2drop
.b819					+
.b819	b5 06		lda $06,x	                lda 6,x
.b81b	95 02		sta $02,x	                sta 2,x
.b81d	b5 07		lda $07,x	                lda 7,x
.b81f	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b821	80 08		bra $b82b	                bra _cmd_w_para_ready
.b823					_cmd_w_have_para:
.b823	b5 02		lda $02,x	                lda 2,x
.b825	95 06		sta $06,x	                sta 6,x
.b827	b5 03		lda $03,x	                lda 3,x
.b829	95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b82b					_cmd_w_para_ready:
.b82b	a9 2e		lda #$2e	                lda #<ed_head
.b82d	95 00		sta $00,x	                sta 0,x
.b82f	a9 00		lda #$00	                lda #>ed_head
.b831	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.b833	20 74 98	jsr $9874	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.b836	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.b839					_cmd_w_loop:
.b839	20 70 8f	jsr $8f70	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.b83c	b5 00		lda $00,x	                lda 0,x
.b83e	15 01		ora $01,x	                ora 1,x
.b840	f0 55		beq $b897	                beq _cmd_w_eol
.b842	20 93 a3	jsr $a393	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.b845	20 7d a4	jsr $a47d	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.b848	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.b84b	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.b84e	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.b851	20 70 8f	jsr $8f70	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.b854	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.b857	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.b85a	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.b85d	20 70 8f	jsr $8f70	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.b860	20 5e 96	jsr $965e	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.b863	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.b866	20 38 9b	jsr $9b38	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.b869	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.b86c	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.b86f	20 b2 95	jsr $95b2	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.b872	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.b875	20 03 a4	jsr $a403	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.b878	20 5e 96	jsr $965e	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.b87b	20 c4 99	jsr $99c4	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.b87e	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.b881	ca		dex		                dex
.b882	ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.b883	a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.b885	95 00		sta $00,x	                sta 0,x
.b887	74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.b889	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.b88c	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.b88f	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.b892	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.b895	80 a2		bra $b839	                bra _cmd_w_loop
.b897					_cmd_w_eol:
.b897	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.b89a	20 73 9a	jsr $9a73	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.b89d	20 40 95	jsr $9540	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.b8a0	b5 00		lda $00,x	                lda 0,x
.b8a2	95 04		sta $04,x	                sta 4,x
.b8a4	b5 01		lda $01,x	                lda 1,x
.b8a6	95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.b8a8	20 53 89	jsr $8953	                jsr xt_cr
.b8ab	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.b8ae	20 09 a5	jsr $a509	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.b8b1	20 53 89	jsr $8953	                jsr xt_cr
.b8b4	a9 40		lda #$40	                lda #%01000000
.b8b6	14 32		trb $32		                trb ed_flags
.b8b8	4c e8 b5	jmp $b5e8	                jmp ed_next_command
.b8bb					ed_error_2drop:
.b8bb	e8		inx		                inx
.b8bc	e8		inx		                inx                     ; drop through to _error_1drop
.b8bd					ed_error_1drop:
.b8bd	e8		inx		                inx
.b8be	e8		inx		                inx                     ; drop through to _error
.b8bf					ed_error:
.b8bf	20 53 89	jsr $8953	                jsr xt_cr
.b8c2	a9 3f		lda #$3f	                lda #'?'
.b8c4	20 e6 8d	jsr $8de6	                jsr emit_a
.b8c7	20 53 89	jsr $8953	                jsr xt_cr
.b8ca	4c 02 b4	jmp $b402	                jmp ed_input_loop
.b8cd					ed_get_input:
.b8cd	20 d9 9a	jsr $9ad9	                jsr xt_refill           ;  ( addr-t u-t f )
.b8d0	b5 00		lda $00,x	                lda 0,x
.b8d2	15 01		ora $01,x	                ora 1,x
.b8d4	d0 05		bne $b8db	                bne +
.b8d6	7a		ply		                ply
.b8d7	7a		ply		                ply
.b8d8	4c bd b8	jmp $b8bd	                jmp ed_error_1drop
.b8db					+
.b8db	e8		inx		                inx
.b8dc	e8		inx		                inx
.b8dd	60		rts		                rts
.b8de					ed_have_text:
.b8de	a5 2e		lda $2e		                lda ed_head
.b8e0	05 2f		ora $2f		                ora ed_head+1
.b8e2	d0 04		bne $b8e8	                bne +
.b8e4	7a		ply		                ply
.b8e5	7a		ply		                ply
.b8e6	80 d7		bra $b8bf	                bra ed_error
.b8e8					+
.b8e8	60		rts		                rts
.b8e9					ed_is_valid_line:
.b8e9	38		sec		                sec                             ; default is legal line number
.b8ea	b5 00		lda $00,x	                lda 0,x
.b8ec	15 01		ora $01,x	                ora 1,x
.b8ee	f0 19		beq $b909	                beq _is_valid_line_nope_zero    ; ( n )
.b8f0	20 9f 8d	jsr $8d9f	                jsr xt_dup                      ; DUP ( n n )
.b8f3	20 0b b9	jsr $b90b	                jsr ed_last_line                  ; ( n n last )
.b8f6	20 89 a1	jsr $a189	                jsr xt_swap                     ; SWAP ( n last n )
.b8f9	20 58 93	jsr $9358	                jsr xt_less_than                ; < ( n f )
.b8fc	b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.b8fe	15 01		ora $01,x	                ora 1,x
.b900	d0 05		bne $b907	                bne _is_valid_line_too_small
.b902	e8		inx		                inx
.b903	e8		inx		                inx                     ; DROP flag ( n )
.b904	38		sec		                sec                     ; Who knows what's happened to C by now
.b905	80 03		bra $b90a	                bra _is_valid_line_done ; only one exit from this routine
.b907					_is_valid_line_too_small:
.b907	e8		inx		                inx
.b908	e8		inx		                inx                     ; drop through to _is_valid_line_zero
.b909					_is_valid_line_nope_zero:
.b909	18		clc		                clc                     ; drop through to _is_valid_line_done
.b90a					_is_valid_line_done:
.b90a	60		rts		                rts
.b90b					ed_last_line:
.b90b	64 24		stz $24		                stz tmp1
.b90d	64 25		stz $25		                stz tmp1+1
.b90f	ca		dex		                dex
.b910	ca		dex		                dex                     ; ( ? )
.b911	a9 2e		lda #$2e	                lda #<ed_head
.b913	95 00		sta $00,x	                sta 0,x
.b915	a9 00		lda #$00	                lda #>ed_head
.b917	95 01		sta $01,x	                sta 1,x                 ; ( addr )
.b919					_last_line_loop:
.b919	20 70 8f	jsr $8f70	                jsr xt_fetch            ; ( addr | 0 )
.b91c	b5 00		lda $00,x	                lda 0,x
.b91e	15 01		ora $01,x	                ora 1,x
.b920	f0 08		beq $b92a	                beq _last_line_done
.b922	e6 24		inc $24		                inc tmp1
.b924	d0 02		bne $b928	                bne +
.b926	e6 25		inc $25		                inc tmp1+1
.b928					+
.b928	80 ef		bra $b919	                bra _last_line_loop
.b92a					_last_line_done:
.b92a	a5 24		lda $24		                lda tmp1
.b92c	95 00		sta $00,x	                sta 0,x
.b92e	a5 25		lda $25		                lda tmp1+1
.b930	95 01		sta $01,x	                sta 1,x                 ; ( u )
.b932	60		rts		                rts
.b933					ed_no_line_zero:
.b933	b5 02		lda $02,x	                lda 2,x
.b935	15 03		ora $03,x	                ora 3,x
.b937	d0 07		bne $b940	                bne _no_line_zero_done
.b939	24 32		bit $32		                bit ed_flags
.b93b	10 03		bpl $b940	                bpl _no_line_zero_done
.b93d	4c bb b8	jmp $b8bb	                jmp ed_error_2drop
.b940					_no_line_zero_done:
.b940	60		rts		                rts
.b941					ed_num_to_addr:
.b941	ca		dex		                dex
.b942	ca		dex		                dex                     ; ( u ? )
.b943	a9 2e		lda #$2e	                lda #<ed_head
.b945	95 00		sta $00,x	                sta 0,x
.b947	a9 00		lda #$00	                lda #>ed_head
.b949	95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.b94b	b5 02		lda $02,x	                lda 2,x
.b94d	15 03		ora $03,x	                ora 3,x
.b94f	d0 05		bne $b956	                bne _num_to_addr_loop
.b951	20 32 96	jsr $9632	                jsr xt_nip              ; ( addr-h )
.b954	80 21		bra $b977	                bra _num_to_addr_done
.b956					_num_to_addr_loop:
.b956	20 70 8f	jsr $8f70	                jsr xt_fetch            ; @ ( u addr1 )
.b959	b5 00		lda $00,x	                lda 0,x
.b95b	15 01		ora $01,x	                ora 1,x
.b95d	d0 05		bne $b964	                bne +
.b95f	20 32 96	jsr $9632	                jsr xt_nip              ; NIP ( addr1 )
.b962	80 13		bra $b977	                bra _num_to_addr_done
.b964					+
.b964	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr1 u )
.b967	20 f2 97	jsr $97f2	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.b96a	b5 00		lda $00,x	                lda 0,x
.b96c	15 01		ora $01,x	                ora 1,x
.b96e	f0 05		beq $b975	                beq _num_to_addr_finished
.b970	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.b973	80 e1		bra $b956	                bra _num_to_addr_loop
.b975					_num_to_addr_finished:
.b975	e8		inx		                inx
.b976	e8		inx		                inx                     ; ( addr )
.b977					_num_to_addr_done:
.b977	60		rts		                rts
.b978					ed_para1_to_cur:
.b978	b5 02		lda $02,x	                lda 2,x
.b97a	85 30		sta $30		                sta ed_cur
.b97c	b5 03		lda $03,x	                lda 3,x
.b97e	85 31		sta $31		                sta ed_cur+1
.b980	60		rts		                rts
.b981					ed_print_addr:
.b981	20 fe 97	jsr $97fe	                jsr xt_one_plus
.b984	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( addr+2 )
.b987	20 9f 8d	jsr $8d9f	                jsr xt_dup              ; ( addr+2 addr+2 )
.b98a	20 fe 97	jsr $97fe	                jsr xt_one_plus
.b98d	20 fe 97	jsr $97fe	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.b990	20 70 8f	jsr $8f70	                jsr xt_fetch            ; ( addr+2 u-s )
.b993	20 89 a1	jsr $a189	                jsr xt_swap             ; ( u-s addr+2 )
.b996	20 70 8f	jsr $8f70	                jsr xt_fetch            ; ( u-s addr-s )
.b999	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-s u-s )
.b99c	20 de a4	jsr $a4de	                jsr xt_type
.b99f	20 53 89	jsr $8953	                jsr xt_cr
.b9a2	60		rts		                rts
>b9a3	61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>b9ab	71 51 00
.b9ae					ed_cmd_table:
>b9ae	f7 b5 4a b7 7d b7 a6 b6		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>b9b6	a5 b7 9e b7
>b9ba	0e b7 08 b8 f9 b7 04 b8		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.b9c2					ed6502_end:

;******  Return to file: platform/../taliforth.asm

.b9c2					forth_words_start:
>b9c2	20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>b9ca	61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>b9da	74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>b9ea	20 56 65 72 73 69 6f 6e 20 31 2e 30 20 32 34 2e
>b9fa	20 4a 61 6e 20 32 30 32 30 20 29 20 63 72 20 2e
>ba0a	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>ba1a	2d 32 30 32 30 20 53 63 6f 74 20 57 2e 20 53 74
>ba2a	65 76 65 6e 73 6f 6e 29 20 63 72 20 2e 28 20 54
>ba3a	61 6c 69 20 46 6f 72 74 68 20 32 20 63 6f 6d 65
>ba4a	73 20 77 69 74 68 20 61 62 73 6f 6c 75 74 65 6c
>ba5a	79 20 4e 4f 20 57 41 52 52 41 4e 54 59 29 20 63
>ba6a	72 20 2e 28 20 54 79 70 65 20 27 62 79 65 27 20
>ba7a	74 6f 20 65 78 69 74 29 20 63 72 20
.ba86					forth_words_end:
.ba86					user_words_start:
>ba86	20 20				.binary "user_words.asc"
.ba88					user_words_end:

;******  Processing file: platform/../headers.asm

.ba88					dictionary_start:
.ba88					nt_drop:
>ba88	04 10				        .byte 4, UF
>ba8a	94 ba 1e 8d 23 8d		        .word nt_dup, xt_drop, z_drop
>ba90	64 72 6f 70			        .text "drop"
.ba94					nt_dup:
>ba94	03 10				        .byte 3, UF
>ba96	9f ba 9f 8d ac 8d		        .word nt_swap, xt_dup, z_dup
>ba9c	64 75 70			        .text "dup"
.ba9f					nt_swap:
>ba9f	04 10				        .byte 4, UF
>baa1	ab ba 89 a1 9c a1		        .word nt_store, xt_swap, z_swap
>baa7	73 77 61 70			        .text "swap"
.baab					nt_store:
>baab	01 10				        .byte 1, UF
>baad	b4 ba 68 a1 7d a1		        .word nt_fetch, xt_store, z_store
>bab3	21				        .text "!"
.bab4					nt_fetch:
>bab4	01 10				        .byte 1, UF
>bab6	bd ba 70 8f 82 8f		        .word nt_over, xt_fetch, z_fetch
>babc	40				        .text "@"
.babd					nt_over:
>babd	04 10				        .byte 4, UF
>babf	c9 ba 74 98 81 98		        .word nt_to_r, xt_over, z_over
>bac5	6f 76 65 72			        .text "over"
.bac9					nt_to_r:
>bac9	02 11				        .byte 2, CO+UF ; native is special case
>bacb	d3 ba 4b a3 5e a3		        .word nt_r_from, xt_to_r, z_to_r
>bad1	3e 72				        .text ">r"
.bad3					nt_r_from:
>bad3	02 01				        .byte 2, CO    ; native is special case
>bad5	dd ba 73 9a 83 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>badb	72 3e				        .text "r>"
.badd					nt_r_fetch:
>badd	02 01				        .byte 2, CO    ; native is special case
>badf	e7 ba 5e 9a 72 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bae5	72 40				        .text "r@"
.bae7					nt_nip:
>bae7	03 10				        .byte 3, UF
>bae9	f2 ba 32 96 3f 96		        .word nt_rot, xt_nip, z_nip
>baef	6e 69 70			        .text "nip"
.baf2					nt_rot:
>baf2	03 10				        .byte 3, UF
>baf4	fd ba 38 9b 53 9b		        .word nt_not_rote, xt_rot, z_rot
>bafa	72 6f 74			        .text "rot"
.bafd					nt_not_rote:
>bafd	04 10				        .byte 4, UF
>baff	09 bb 5e 96 79 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bb05	2d 72 6f 74			        .text "-rot"
.bb09					nt_tuck:
>bb09	04 10				        .byte 4, UF
>bb0b	15 bb 68 a3 81 a3		        .word nt_comma, xt_tuck, z_tuck
>bb11	74 75 63 6b			        .text "tuck"
.bb15					nt_comma:
>bb15	01 10				        .byte 1, UF
>bb17	1e bb 5e 87 77 87		        .word nt_c_fetch, xt_comma, z_comma
>bb1d	2c				        .text ","
.bb1e					nt_c_fetch:
>bb1e	02 10				        .byte 2, UF
>bb20	28 bb fb 85 04 86		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bb26	63 40				        .text "c@"
.bb28					nt_c_store:
>bb28	02 10				        .byte 2, UF
>bb2a	32 bb 05 86 10 86		        .word nt_plus_store, xt_c_store, z_c_store
>bb30	63 21				        .text "c!"
.bb32					nt_plus_store:
>bb32	02 10				        .byte 2, UF
>bb34	3c bb d7 99 f6 99		        .word nt_execute, xt_plus_store, z_plus_store
>bb3a	2b 21				        .text "+!"
.bb3c					nt_execute:
>bb3c	07 10				        .byte 7, UF
>bb3e	4b bb 2d 8f 33 8f		        .word nt_emit, xt_execute, z_execute
>bb44	65 78 65 63 75 74 65		        .text "execute"
.bb4b					nt_emit:
>bb4b	04 18				        .byte 4, NN+UF
>bb4d	57 bb df 8d e9 8d		        .word nt_type, xt_emit, z_emit
>bb53	65 6d 69 74			        .text "emit"
.bb57					nt_type:
>bb57	04 10				        .byte 4, UF
>bb59	63 bb de a4 08 a5		        .word nt_dot, xt_type, z_type
>bb5f	74 79 70 65			        .text "type"
.bb63					nt_dot:
>bb63	01 10				        .byte 1, UF
>bb65	6c bb 26 8c 47 8c		        .word nt_u_dot, xt_dot, z_dot
>bb6b	2e				        .text "."
.bb6c					nt_u_dot:
>bb6c	02 10				        .byte 2, UF
>bb6e	76 bb 09 a5 14 a5		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bb74	75 2e				        .text "u."
.bb76					nt_u_dot_r:
>bb76	03 10				        .byte 3, UF
>bb78	81 bb 15 a5 36 a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bb7e	75 2e 72			        .text "u.r"
.bb81					nt_dot_r:
>bb81	02 10				        .byte 2, UF
>bb83	8b bb 62 8c 8f 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bb89	2e 72				        .text ".r"
.bb8b					nt_d_dot:
>bb8b	02 10				        .byte 2, UF
>bb8d	95 bb d4 8c f2 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bb93	64 2e				        .text "d."
.bb95					nt_d_dot_r:
>bb95	03 10				        .byte 3, UF
>bb97	a0 bb f3 8c 1d 8d		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bb9d	64 2e 72			        .text "d.r"
.bba0					nt_ud_dot:
>bba0	03 10				        .byte 3, UF
>bba2	ab bb 63 a5 75 a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bba8	75 64 2e			        .text "ud."
.bbab					nt_ud_dot_r:
>bbab	04 10				        .byte 4, UF
>bbad	b7 bb 76 a5 94 a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bbb3	75 64 2e 72			        .text "ud.r"
.bbb7					nt_question:
>bbb7	01 00				        .byte 1, 0
>bbb9	c0 bb 43 9a 49 9a		        .word nt_false, xt_question, z_question
>bbbf	3f				        .text "?"
.bbc0					nt_false:
>bbc0	05 00				        .byte 5, 0
>bbc2	cd bb 69 8f 6f 8f		        .word nt_true, xt_false, z_false
>bbc8	66 61 6c 73 65			        .text "false"
.bbcd					nt_true:
>bbcd	04 00				        .byte 4, 0
>bbcf	d9 bb 5f a3 67 a3		        .word nt_space, xt_true, z_true
>bbd5	74 72 75 65			        .text "true"
.bbd9					nt_space:
>bbd9	05 00				        .byte 5, 0
>bbdb	e6 bb ff a0 04 a1		        .word nt_zero, xt_space, z_space
>bbe1	73 70 61 63 65			        .text "space"
.bbe6					nt_zero:
>bbe6	01 00				        .byte 1, 0
>bbe8	ef bb 82 a7 88 a7		        .word nt_one, xt_zero, z_zero
>bbee	30				        .text "0"
.bbef					nt_one:
>bbef	01 00				        .byte 1, 0
>bbf1	f8 bb e9 97 f1 97		        .word nt_two, xt_one, z_one
>bbf7	31				        .text "1"
.bbf8					nt_two:
>bbf8	01 00				        .byte 1, 0
>bbfa	01 bc 82 a3 8a a3		        .word nt_two_dup, xt_two, z_two
>bc00	32				        .text "2"
.bc01					nt_two_dup:
>bc01	04 10				        .byte 4, UF
>bc03	0d bc 93 a3 aa a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bc09	32 64 75 70			        .text "2dup"
.bc0d					nt_question_dup:
>bc0d	04 10				        .byte 4, UF
>bc0f	19 bc 4a 9a 5d 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bc15	3f 64 75 70			        .text "?dup"
.bc19					nt_plus:
>bc19	01 10				        .byte 1, UF
>bc1b	22 bc c4 99 d6 99		        .word nt_minus, xt_plus, z_plus
>bc21	2b				        .text "+"
.bc22					nt_minus:
>bc22	01 10				        .byte 1, UF
>bc24	2b bc 40 95 52 95		        .word nt_abs, xt_minus, z_minus
>bc2a	2d				        .text "-"
.bc2b					nt_abs:
>bc2b	03 10				        .byte 3, UF
>bc2d	36 bc 39 81 4d 81		        .word nt_dabs, xt_abs, z_abs
>bc33	61 62 73			        .text "abs"
.bc36					nt_dabs:
>bc36	04 10				        .byte 4, UF
>bc38	42 bc 76 8a 94 8a		        .word nt_and, xt_dabs, z_dabs
>bc3e	64 61 62 73			        .text "dabs"
.bc42					nt_and:
>bc42	03 10				        .byte 3, UF
>bc44	4d bc 3e 83 4f 83		        .word nt_or, xt_and, z_and
>bc4a	61 6e 64			        .text "and"
.bc4d					nt_or:
>bc4d	02 10				        .byte 2, UF
>bc4f	57 bc 14 98 25 98		        .word nt_xor, xt_or, z_or
>bc55	6f 72				        .text "or"
.bc57					nt_xor:
>bc57	03 10				        .byte 3, UF
>bc59	62 bc 70 a7 81 a7		        .word nt_rshift, xt_xor, z_xor
>bc5f	78 6f 72			        .text "xor"
.bc62					nt_rshift:
>bc62	06 10				        .byte 6, UF
>bc64	70 bc 54 9b 67 9b		        .word nt_lshift, xt_rshift, z_rshift
>bc6a	72 73 68 69 66 74		        .text "rshift"
.bc70					nt_lshift:
>bc70	06 10				        .byte 6, UF
>bc72	7e bc 6a 94 7d 94		        .word nt_pick, xt_lshift, z_lshift
>bc78	6c 73 68 69 66 74		        .text "lshift"
.bc7e					nt_pick:
>bc7e	04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bc80	8a bc b3 99 c3 99		        .word nt_char, xt_pick, z_pick
>bc86	70 69 63 6b			        .text "pick"
.bc8a					nt_char:
>bc8a	04 00				        .byte 4, 0
>bc8c	96 bc 21 86 37 86		        .word nt_bracket_char, xt_char, z_char
>bc92	63 68 61 72			        .text "char"
.bc96					nt_bracket_char:
>bc96	06 05				        .byte 6, CO+IM
>bc98	a4 bc 87 85 8d 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bc9e	5b 63 68 61 72 5d		        .text "[char]"
.bca4					nt_char_plus:
>bca4	05 00				        .byte 5, 0
>bca6	b1 bc fe 97 07 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bcac	63 68 61 72 2b			        .text "char+"
.bcb1					nt_chars:
>bcb1	05 12				        .byte 5, AN+UF   ; deleted during compile
>bcb3	be bc 38 86 3b 86		        .word nt_cells, xt_chars, z_chars
>bcb9	63 68 61 72 73			        .text "chars"
.bcbe					nt_cells:
>bcbe	05 00				        .byte 5, 0
>bcc0	cb bc 2b a4 32 a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bcc6	63 65 6c 6c 73			        .text "cells"
.bccb					nt_cell_plus:
>bccb	05 10				        .byte 5, UF
>bccd	d8 bc 11 86 20 86		        .word nt_here, xt_cell_plus, z_cell_plus
>bcd3	63 65 6c 6c 2b			        .text "cell+"
.bcd8					nt_here:
>bcd8	04 00				        .byte 4, 0
>bcda	e4 bc 62 91 6c 91		        .word nt_one_minus, xt_here, z_here
>bce0	68 65 72 65			        .text "here"
.bce4					nt_one_minus:
>bce4	02 10				        .byte 2, UF
>bce6	ee bc f2 97 fd 97		        .word nt_one_plus, xt_one_minus, z_one_minus
>bcec	31 2d				        .text "1-"
.bcee					nt_one_plus:
>bcee	02 10				        .byte 2, UF
>bcf0	f8 bc fe 97 07 98		        .word nt_two_star, xt_one_plus, z_one_plus
>bcf6	31 2b				        .text "1+"
.bcf8					nt_two_star:
>bcf8	02 10				        .byte 2, UF
>bcfa	02 bd 2b a4 32 a4		        .word nt_two_slash, xt_two_star, z_two_star
>bd00	32 2a				        .text "2*"
.bd02					nt_two_slash:
>bd02	02 10				        .byte 2, UF
>bd04	0c bd 20 a4 2a a4		        .word nt_equal, xt_two_slash, z_two_slash
>bd0a	32 2f				        .text "2/"
.bd0c					nt_equal:
>bd0c	01 10				        .byte 1, UF
>bd0e	15 bd be 8e d9 8e		        .word nt_not_equals, xt_equal, z_equal
>bd14	3d				        .text "="
.bd15					nt_not_equals:
>bd15	02 10				        .byte 2, UF
>bd17	1f bd 40 96 5d 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bd1d	3c 3e				        .text "<>"
.bd1f					nt_less_than:
>bd1f	01 10				        .byte 1, UF
>bd21	28 bd 58 93 6c 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bd27	3c				        .text "<"
.bd28					nt_u_less_than:
>bd28	02 10				        .byte 2, UF
>bd2a	32 bd 4d a5 62 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bd30	75 3c				        .text "u<"
.bd32					nt_u_greater_than:
>bd32	02 10				        .byte 2, UF
>bd34	3c bd 37 a5 4c a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bd3a	75 3e				        .text "u>"
.bd3c					nt_greater_than:
>bd3c	01 10				        .byte 1, UF
>bd3e	45 bd 4d 91 61 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bd44	3e				        .text ">"
.bd45					nt_zero_equal:
>bd45	02 10				        .byte 2, UF
>bd47	4f bd 89 a7 9c a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bd4d	30 3d				        .text "0="
.bd4f					nt_zero_unequal:
>bd4f	03 10				        .byte 3, UF
>bd51	5a bd c1 a7 d2 a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bd57	30 3c 3e			        .text "0<>"
.bd5a					nt_zero_greater:
>bd5a	02 10				        .byte 2, UF
>bd5c	64 bd 9d a7 b0 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bd62	30 3e				        .text "0>"
.bd64					nt_zero_less:
>bd64	02 10				        .byte 2, UF
>bd66	6e bd b1 a7 c0 a7		        .word nt_min, xt_zero_less, z_zero_less
>bd6c	30 3c				        .text "0<"
.bd6e					nt_min:
>bd6e	03 10				        .byte 3, UF
>bd70	79 bd 24 95 3f 95		        .word nt_max, xt_min, z_min
>bd76	6d 69 6e			        .text "min"
.bd79					nt_max:
>bd79	03 10				        .byte 3, UF
>bd7b	84 bd 08 95 23 95		        .word nt_two_drop, xt_max, z_max
>bd81	6d 61 78			        .text "max"
.bd84					nt_two_drop:
>bd84	05 10				        .byte 5, UF
>bd86	91 bd 8b a3 92 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bd8c	32 64 72 6f 70			        .text "2drop"
.bd91					nt_two_swap:
>bd91	05 10				        .byte 5, UF
>bd93	9e bd 59 a4 7c a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bd99	32 73 77 61 70			        .text "2swap"
.bd9e					nt_two_over:
>bd9e	05 10				        .byte 5, UF
>bda0	ab bd cd a3 e4 a3		        .word nt_two_store, xt_two_over, z_two_over
>bda6	32 6f 76 65 72			        .text "2over"
.bdab					nt_two_store:
>bdab	02 10				        .byte 2, UF
>bdad	b5 bd 33 a4 58 a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bdb3	32 21				        .text "2!"
.bdb5					nt_two_fetch:
>bdb5	02 10				        .byte 2, UF
>bdb7	bf bd ab a3 cc a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bdbd	32 40				        .text "2@"
.bdbf					nt_two_variable:
>bdbf	09 00				        .byte 9, 0
>bdc1	d0 bd cf a4 dd a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>bdc7	32 76 61 72 69 61 62 6c		        .text "2variable"
>bdcf	65
.bdd0					nt_two_constant:
>bdd0	09 10				        .byte 9, UF
>bdd2	e1 bd 9d a4 c1 a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bdd8	32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bde0	74
.bde1					nt_two_literal:
>bde1	08 14				        .byte 8, UF+IM
>bde3	f1 bd c2 a4 ce a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bde9	32 6c 69 74 65 72 61 6c		        .text "2literal"
.bdf1					nt_two_r_fetch:
>bdf1	03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bdf3	fc bd e5 a3 02 a4		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bdf9	32 72 40			        .text "2r@"
.bdfc					nt_two_r_from:
>bdfc	03 01				        .byte 3, CO             ; native is special case
>bdfe	07 be 03 a4 1f a4		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>be04	32 72 3e			        .text "2r>"
.be07					nt_two_to_r:
>be07	03 11				        .byte 3, CO+UF          ; native is special case
>be09	12 be 7d a4 9c a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>be0f	32 3e 72			        .text "2>r"
.be12					nt_invert:
>be12	06 10				        .byte 6, UF
>be14	20 be db 92 ea 92		        .word nt_negate, xt_invert, z_invert
>be1a	69 6e 76 65 72 74		        .text "invert"
.be20					nt_negate:
>be20	06 10				        .byte 6, UF
>be22	2e be 13 96 23 96		        .word nt_dnegate, xt_negate, z_negate
>be28	6e 65 67 61 74 65		        .text "negate"
.be2e					nt_dnegate:
>be2e	07 10				        .byte 7, UF
>be30	3d be 31 8b 4b 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>be36	64 6e 65 67 61 74 65		        .text "dnegate"
.be3d					nt_c_comma:
>be3d	02 10				        .byte 2, UF
>be3f	47 be f0 85 fa 85		        .word nt_bounds, xt_c_comma, z_c_comma
>be45	63 2c				        .text "c,"
.be47					nt_bounds:
>be47	06 10				        .byte 6, UF
>be49	55 be 6e 85 86 85		        .word nt_spaces, xt_bounds, z_bounds
>be4f	62 6f 75 6e 64 73		        .text "bounds"
.be55					nt_spaces:
>be55	06 10				        .byte 6, UF
>be57	63 be 05 a1 3a a1		        .word nt_bl, xt_spaces, z_spaces
>be5d	73 70 61 63 65 73		        .text "spaces"
.be63					nt_bl:
>be63	02 00				        .byte 2, 0
>be65	6d be 8a 83 92 83		        .word nt_minus_trailing, xt_bl, z_bl
>be6b	62 6c				        .text "bl"
.be6d					nt_minus_trailing:
>be6d	09 10				        .byte 9, UF
>be6f	7e be 6c 95 a8 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>be75	2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>be7d	67
.be7e					nt_minus_leading:
>be7e	08 10				        .byte 8, UF
>be80	8e be 53 95 6b 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>be86	2d 6c 65 61 64 69 6e 67		        .text "-leading"
.be8e					nt_slash_string:
>be8e	07 10				        .byte 7, UF
>be90	9d be fa 9f 19 a0		        .word nt_refill, xt_slash_string, z_slash_string
>be96	2f 73 74 72 69 6e 67		        .text "/string"
.be9d					nt_refill:
>be9d	06 00				        .byte 6, 0
>be9f	ab be d9 9a 1a 9b		        .word nt_accept, xt_refill, z_refill
>bea5	72 65 66 69 6c 6c		        .text "refill"
.beab					nt_accept:
>beab	06 18				        .byte 6, UF+NN
>bead	b9 be 4e 81 46 82		        .word nt_input_to_r, xt_accept, z_accept
>beb3	61 63 63 65 70 74		        .text "accept"
.beb9					nt_input_to_r:
>beb9	07 08				        .byte 7, NN
>bebb	c8 be 52 92 67 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>bec1	69 6e 70 75 74 3e 72		        .text "input>r"
.bec8					nt_r_to_input:
>bec8	07 08				        .byte 7, NN
>beca	d7 be 84 9a 9b 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>bed0	72 3e 69 6e 70 75 74		        .text "r>input"
.bed7					nt_unused:
>bed7	06 00				        .byte 6, 0
>bed9	e5 be 2f a6 3e a6		        .word nt_depth, xt_unused, z_unused
>bedf	75 6e 75 73 65 64		        .text "unused"
.bee5					nt_depth:
>bee5	05 00				        .byte 5, 0
>bee7	f2 be e6 8a f4 8a		        .word nt_key, xt_depth, z_depth
>beed	64 65 70 74 68			        .text "depth"
.bef2					nt_key:
>bef2	03 00				        .byte 3, 0
>bef4	fd be 1e 93 27 93		        .word nt_allot, xt_key, z_key
>befa	6b 65 79			        .text "key"
.befd					nt_allot:
>befd	05 10				        .byte 5, UF
>beff	0a bf ab 82 13 83		        .word nt_create, xt_allot, z_allot
>bf05	61 6c 6c 6f 74			        .text "allot"
.bf0a					nt_create:
>bf0a	06 00				        .byte 6, 0
>bf0c	18 bf 59 89 2d 8a		        .word nt_does, xt_create, z_create
>bf12	63 72 65 61 74 65		        .text "create"
.bf18					nt_does:
>bf18	05 05				        .byte 5, CO+IM
>bf1a	25 bf e5 8b f3 8b		        .word nt_variable, xt_does, z_does
>bf20	64 6f 65 73 3e			        .text "does>"
.bf25					nt_variable:
>bf25	08 00				        .byte 8, 0
>bf27	35 bf 53 a6 6b a6		        .word nt_constant, xt_variable, z_variable
>bf2d	76 61 72 69 61 62 6c 65		        .text "variable"
.bf35					nt_constant:
>bf35	08 10				        .byte 8, UF
>bf37	45 bf 01 89 3e 89		        .word nt_value, xt_constant, z_constant
>bf3d	63 6f 6e 73 74 61 6e 74		        .text "constant"
.bf45					nt_value:
>bf45	05 10				        .byte 5, UF
>bf47	52 bf 01 89 3e 89		        .word nt_to, xt_constant, z_constant
>bf4d	76 61 6c 75 65			        .text "value"
.bf52					nt_to:
>bf52	02 0c				        .byte 2, NN+IM
>bf54	5c bf 0c a2 67 a2		        .word nt_s_to_d, xt_to, z_to
>bf5a	74 6f				        .text "to"
.bf5c					nt_s_to_d:
>bf5c	03 10				        .byte 3, UF
>bf5e	67 bf 8d 9e 9e 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>bf64	73 3e 64			        .text "s>d"
.bf67					nt_d_to_s:
>bf67	03 10				        .byte 3, UF
>bf69	72 bf 70 8a 75 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>bf6f	64 3e 73			        .text "d>s"
.bf72					nt_d_minus:
>bf72	02 10				        .byte 2, UF
>bf74	7c bf 2e 8a 4e 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>bf7a	64 2d				        .text "d-"
.bf7c					nt_d_plus:
>bf7c	02 10				        .byte 2, UF
>bf7e	86 bf 4f 8a 6f 8a		        .word nt_erase, xt_d_plus, z_d_plus
>bf84	64 2b				        .text "d+"
.bf86					nt_erase:
>bf86	05 00				        .byte 5, 0      ; underflow checked by FILL
>bf88	93 bf e4 8e 2c 8f		        .word nt_blank, xt_erase, z_erase
>bf8e	65 72 61 73 65			        .text "erase"
.bf93					nt_blank:
>bf93	05 00				        .byte 5, 0     ; underflow checked by FILL
>bf95	a0 bf da 8e 2c 8f		        .word nt_fill, xt_blank, z_blank
>bf9b	62 6c 61 6e 6b			        .text "blank"
.bfa0					nt_fill:
>bfa0	04 10				        .byte 4, UF
>bfa2	ac bf ea 8e 2c 8f		        .word nt_find_name, xt_fill, z_fill
>bfa8	66 69 6c 6c			        .text "fill"
.bfac					nt_find_name:
>bfac	09 10				        .byte 9, UF
>bfae	bd bf cb 8f 76 90		        .word nt_tick, xt_find_name, z_find_name
>bfb4	66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>bfbc	65
.bfbd					nt_tick:
>bfbd	01 00				        .byte 1, 0
>bfbf	c6 bf ec a1 0b a2		        .word nt_bracket_tick, xt_tick, z_tick
>bfc5	27				        .text "'"
.bfc6					nt_bracket_tick:
>bfc6	03 05				        .byte 3, CO+IM
>bfc8	d1 bf 8e 85 94 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>bfce	5b 27 5d			        .text "[']"
.bfd1					nt_name_to_int:
>bfd1	08 10				        .byte 8, UF
>bfd3	e1 bf d1 95 ed 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>bfd9	6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.bfe1					nt_int_to_name:
>bfe1	08 10				        .byte 8, UF
>bfe3	f1 bf 68 92 da 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>bfe9	69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.bff1					nt_name_to_string:
>bff1	0b 10				        .byte 11, UF
>bff3	04 c0 ee 95 07 96		        .word nt_to_body, xt_name_to_string, z_name_to_string
>bff9	6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c001	69 6e 67
.c004					nt_to_body:
>c004	05 10				        .byte 5, UF
>c006	11 c0 68 a2 8c a2		        .word nt_defer, xt_to_body, z_to_body
>c00c	3e 62 6f 64 79			        .text ">body"
.c011					nt_defer:
>c011	05 00				        .byte 5, 0
>c013	1e c0 9c 8a ce 8a		        .word nt_latestxt, xt_defer, z_defer
>c019	64 65 66 65 72			        .text "defer"
.c01e					nt_latestxt:
>c01e	08 00				        .byte 8, 0
>c020	2e c0 39 93 3f 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c026	6c 61 74 65 73 74 78 74		        .text "latestxt"
.c02e					nt_latestnt:
>c02e	08 00				        .byte 8, 0
>c030	3e c0 2b 93 38 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c036	6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c03e					nt_parse_name:
>c03e	0a 08				        .byte 10, NN
>c040	50 c0 c0 98 b2 99		        .word nt_parse, xt_parse_name, z_parse_name
>c046	70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c04e	6d 65
.c050					nt_parse:
>c050	05 10				        .byte 5, UF
>c052	5d c0 1b 99 b2 99		        .word nt_execute_parsing, xt_parse, z_parse
>c058	70 61 72 73 65			        .text "parse"
.c05d					nt_execute_parsing:
>c05d	0f 10				        .byte 15, UF
>c05f	74 c0 41 8f 67 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c065	65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c06d	70 61 72 73 69 6e 67
.c074					nt_source:
>c074	06 00				        .byte 6, 0
>c076	82 c0 df a0 f3 a0		        .word nt_source_id, xt_source, z_source
>c07c	73 6f 75 72 63 65		        .text "source"
.c082					nt_source_id:
>c082	09 00				        .byte 9, 0
>c084	93 c0 f4 a0 fe a0		        .word nt_colon, xt_source_id, z_source_id
>c08a	73 6f 75 72 63 65 2d 69		        .text "source-id"
>c092	64
.c093					nt_colon:
>c093	01 00				        .byte 1, 0
>c095	9c c0 ff 86 41 87		        .word nt_semicolon, xt_colon, z_colon
>c09b	3a				        .text ":"
.c09c					nt_semicolon:
>c09c	01 05				        .byte 1, CO+IM
>c09e	a5 c0 69 9f c7 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c0a4	3b				        .text ";"
.c0a5					nt_colon_noname:
>c0a5	07 00				        .byte 7, 0
>c0a7	b4 c0 42 87 5d 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c0ad	3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c0b4					nt_compile_comma:
>c0b4	08 18				        .byte 8, UF+NN
>c0b6	c4 c0 dd 87 f4 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c0bc	63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c0c4					nt_left_bracket:
>c0c4	01 05				        .byte 1, IM+CO
>c0c6	cd c0 45 93 49 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c0cc	5b				        .text "["
.c0cd					nt_right_bracket:
>c0cd	01 04				        .byte 1, IM
>c0cf	d6 c0 28 9b 2e 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c0d5	5d				        .text "]"
.c0d6					nt_literal:
>c0d6	07 15				        .byte 7, IM+CO+UF
>c0d8	e5 c0 7a 93 87 93		        .word nt_sliteral, xt_literal, z_literal
>c0de	6c 69 74 65 72 61 6c		        .text "literal"
.c0e5					nt_sliteral:
>c0e5	08 15				        .byte 8, CO+IM+UF
>c0e7	f5 c0 1a a0 89 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c0ed	73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c0f5					nt_dot_quote:
>c0f5	02 05				        .byte 2, CO+IM
>c0f7	ff c0 57 8c 61 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c0fd	2e 22				        .text ".", $22
.c0ff					nt_s_quote:
>c0ff	02 0c				        .byte 2, IM+NN
>c101	09 c1 30 9d 8c 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c107	73 22				        .text "s", $22
.c109					nt_s_backslash_quote:
>c109	03 04				        .byte 3, IM
>c10b	14 c1 68 9b 71 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c111	73 5c 22			        .text "s", $5C, $22
.c114					nt_postpone:
>c114	08 05				        .byte 8, IM+CO
>c116	24 c1 f7 99 35 9a		        .word nt_immediate, xt_postpone, z_postpone
>c11c	70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c124					nt_immediate:
>c124	09 00				        .byte 9, 0
>c126	35 c1 3b 92 46 92		        .word nt_compile_only, xt_immediate, z_immediate
>c12c	69 6d 6d 65 64 69 61 74		        .text "immediate"
>c134	65
.c135					nt_compile_only:
>c135	0c 00				        .byte 12, 0
>c137	49 c1 f5 88 00 89		        .word nt_never_native, xt_compile_only, z_compile_only
>c13d	63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c145	6f 6e 6c 79
.c149					nt_never_native:
>c149	0c 00				        .byte 12, 0
>c14b	5d c1 24 96 31 96		        .word nt_always_native, xt_never_native, z_never_native
>c151	6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c159	74 69 76 65
.c15d					nt_always_native:
>c15d	0d 00				        .byte 13, 0
>c15f	72 c1 30 83 3d 83		        .word nt_allow_native, xt_always_native, z_always_native
>c165	61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c16d	61 74 69 76 65
.c172					nt_allow_native:
>c172	0c 00				        .byte 12, 0
>c174	86 c1 14 83 1f 83		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c17a	61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c182	74 69 76 65
.c186					nt_nc_limit:
>c186	08 00				        .byte 8, 0
>c188	96 c1 08 96 12 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c18e	6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c196					nt_strip_underflow:
>c196	0f 00				        .byte 15, 0
>c198	ad c1 7e a1 88 a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c19e	73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c1a6	64 65 72 66 6c 6f 77
.c1ad					nt_abort:
>c1ad	05 00				        .byte 5, 0
>c1af	ba c1 81 80 c5 80		        .word nt_abort_quote, xt_abort, z_abort
>c1b5	61 62 6f 72 74			        .text "abort"
.c1ba					nt_abort_quote:
>c1ba	06 0d				        .byte 6, CO+IM+NN
>c1bc	c8 c1 19 81 23 81		        .word nt_do, xt_abort_quote, z_abort_quote
>c1c2	61 62 6f 72 74 22		        .text "abort", $22
.c1c8					nt_do:
>c1c8	02 0d				        .byte 2, CO+IM+NN
>c1ca	d2 c1 52 8b ac 8b		        .word nt_question_do, xt_do, z_do
>c1d0	64 6f				        .text "do"
.c1d2					nt_question_do:
>c1d2	03 0d				        .byte 3, CO+IM+NN
>c1d4	dd c1 4c 8b ac 8b		        .word nt_i, xt_question_do, z_question_do
>c1da	3f 64 6f			        .text "?do"
.c1dd					nt_i:
>c1dd	01 03				        .byte 1, AN+CO
>c1df	e6 c1 d9 91 f2 91		        .word nt_j, xt_i, z_i
>c1e5	69				        .text "i"
.c1e6					nt_j:
>c1e6	01 03				        .byte 1, AN+CO
>c1e8	ef c1 04 93 1d 93		        .word nt_loop, xt_j, z_j
>c1ee	6a				        .text "j"
.c1ef					nt_loop:
>c1ef	04 05				        .byte 4, CO+IM
>c1f1	fb c1 eb 93 58 94		        .word nt_plus_loop, xt_loop, z_loop
>c1f7	6c 6f 6f 70			        .text "loop"
.c1fb					nt_plus_loop:
>c1fb	05 05				        .byte 5, CO+IM
>c1fd	08 c2 f2 93 58 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c203	2b 6c 6f 6f 70			        .text "+loop"
.c208					nt_exit:
>c208	04 03				        .byte 4, AN+CO
>c20a	14 c2 68 8f 69 8f		        .word nt_unloop, xt_exit, z_exit
>c210	65 78 69 74			        .text "exit"
.c214					nt_unloop:
>c214	06 03				        .byte 6, AN+CO
>c216	22 c2 1d a6 23 a6		        .word nt_leave, xt_unloop, z_unloop
>c21c	75 6e 6c 6f 6f 70		        .text "unloop"
.c222					nt_leave:
>c222	05 03				        .byte 5, AN+CO
>c224	2f c2 40 93 45 93		        .word nt_recurse, xt_leave, z_leave
>c22a	6c 65 61 76 65			        .text "leave"
.c22f					nt_recurse:
>c22f	07 0d				        .byte 7, CO+IM+NN
>c231	3e c2 9c 9a d8 9a		        .word nt_quit, xt_recurse, z_recurse
>c237	72 65 63 75 72 73 65		        .text "recurse"
.c23e					nt_quit:
>c23e	04 00				        .byte 4, 0
>c240	4a c2 83 80 c5 80		        .word nt_begin, xt_quit, z_quit
>c246	71 75 69 74			        .text "quit"
.c24a					nt_begin:
>c24a	05 07				        .byte 5, AN+CO+IM
>c24c	57 c2 80 83 83 83		        .word nt_again, xt_begin, z_begin
>c252	62 65 67 69 6e			        .text "begin"
.c257					nt_again:
>c257	05 17				        .byte 5, AN+CO+IM+UF
>c259	64 c2 89 82 a9 82		        .word nt_state, xt_again, z_again
>c25f	61 67 61 69 6e			        .text "again"
.c264					nt_state:
>c264	05 00				        .byte 5, 0
>c266	71 c2 5d a1 67 a1		        .word nt_evaluate, xt_state, z_state
>c26c	73 74 61 74 65			        .text "state"
.c271					nt_evaluate:
>c271	08 10				        .byte 8, UF
>c273	81 c2 c5 90 18 91		        .word nt_base, xt_evaluate, z_evaluate
>c279	65 76 61 6c 75 61 74 65		        .text "evaluate"
.c281					nt_base:
>c281	04 00				        .byte 4, 0
>c283	8d c2 77 83 7f 83		        .word nt_digit_question, xt_base, z_base
>c289	62 61 73 65			        .text "base"
.c28d					nt_digit_question:
>c28d	06 10				        .byte 6, UF
>c28f	9b c2 f5 8a 29 8b		        .word nt_number, xt_digit_question, z_digit_question
>c295	64 69 67 69 74 3f		        .text "digit?"
.c29b					nt_number:
>c29b	06 10				        .byte 6, UF
>c29d	a9 c2 7a 96 67 97		        .word nt_to_number, xt_number, z_number
>c2a3	6e 75 6d 62 65 72		        .text "number"
.c2a9					nt_to_number:
>c2a9	07 10				        .byte 7, UF
>c2ab	b8 c2 98 a2 37 a3		        .word nt_hex, xt_to_number, z_to_number
>c2b1	3e 6e 75 6d 62 65 72		        .text ">number"
.c2b8					nt_hex:
>c2b8	03 00				        .byte 3, 0
>c2ba	c3 c2 6d 91 73 91		        .word nt_decimal, xt_hex, z_hex
>c2c0	68 65 78			        .text "hex"
.c2c3					nt_decimal:
>c2c3	07 00				        .byte 7, 0
>c2c5	d2 c2 95 8a 9b 8a		        .word nt_count, xt_decimal, z_decimal
>c2cb	64 65 63 69 6d 61 6c		        .text "decimal"
.c2d2					nt_count:
>c2d2	05 10				        .byte 5, UF
>c2d4	df c2 3f 89 52 89		        .word nt_m_star, xt_count, z_count
>c2da	63 6f 75 6e 74			        .text "count"
.c2df					nt_m_star:
>c2df	02 10				        .byte 2, UF
>c2e1	e9 c2 7e 94 98 94		        .word nt_um_star, xt_m_star, z_m_star
>c2e7	6d 2a				        .text "m*"
.c2e9					nt_um_star:
>c2e9	03 10				        .byte 3, UF
>c2eb	f4 c2 d7 a5 1c a6		        .word nt_star, xt_um_star, z_um_star
>c2f1	75 6d 2a			        .text "um*"
.c2f4					nt_star:
>c2f4	01 10				        .byte 1, UF
>c2f6	fd c2 3b a1 43 a1		        .word nt_um_slash_mod, xt_star, z_star
>c2fc	2a				        .text "*"
.c2fd					nt_um_slash_mod:
>c2fd	06 10				        .byte 6, UF
>c2ff	0b c3 95 a5 d6 a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c305	75 6d 2f 6d 6f 64		        .text "um/mod"
.c30b					nt_sm_slash_rem:
>c30b	06 10				        .byte 6, UF
>c30d	19 c3 b6 a0 de a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c313	73 6d 2f 72 65 6d		        .text "sm/rem"
.c319					nt_fm_slash_mod:
>c319	06 10				        .byte 6, UF
>c31b	27 c3 81 90 b7 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c321	66 6d 2f 6d 6f 64		        .text "fm/mod"
.c327					nt_slash:
>c327	01 10				        .byte 1, UF
>c329	30 c3 dd 9f f9 9f		        .word nt_slash_mod, xt_slash, z_slash
>c32f	2f				        .text "/"
.c330					nt_slash_mod:
>c330	04 10				        .byte 4, UF
>c332	3c c3 e2 9f f9 9f		        .word nt_mod, xt_slash_mod, z_slash_mod
>c338	2f 6d 6f 64			        .text "/mod"
.c33c					nt_mod:
>c33c	03 10				        .byte 3, UF
>c33e	47 c3 a9 95 b1 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c344	6d 6f 64			        .text "mod"
.c347					nt_star_slash_mod:
>c347	05 10				        .byte 5, UF
>c349	54 c3 4d a1 5c a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c34f	2a 2f 6d 6f 64			        .text "*/mod"
.c354					nt_star_slash:
>c354	02 10				        .byte 2, UF
>c356	5e c3 44 a1 4c a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c35c	2a 2f				        .text "*/"
.c35e					nt_backslash:
>c35e	01 04				        .byte 1, IM
>c360	67 c3 6e 83 76 83		        .word nt_move, xt_backslash, z_backslash
>c366	5c				        .byte $5c
.c367					nt_move:
>c367	04 18				        .byte 4, NN+UF
>c369	73 c3 b2 95 d0 95		        .word nt_cmove_up, xt_move, z_move
>c36f	6d 6f 76 65			        .text "move"
.c373					nt_cmove_up:
>c373	06 10				        .byte 6, UF
>c375	81 c3 c4 86 fe 86		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c37b	63 6d 6f 76 65 3e		        .text "cmove>"
.c381					nt_cmove:
>c381	05 10				        .byte 5, UF
>c383	8e c3 89 86 c3 86		        .word nt_pad, xt_cmove, z_cmove
>c389	63 6d 6f 76 65			        .text "cmove"
.c38e					nt_pad:
>c38e	03 00				        .byte 3, 0
>c390	99 c3 82 98 91 98		        .word nt_cleave, xt_pad, z_pad
>c396	70 61 64			        .text "pad"
.c399					nt_cleave:
>c399	06 10				        .byte 6, UF
>c39b	a7 c3 3c 86 88 86		        .word nt_hexstore, xt_cleave, z_cleave
>c3a1	63 6c 65 61 76 65		        .text "cleave"
.c3a7					nt_hexstore:
>c3a7	08 10				        .byte 8, UF
>c3a9	b7 c3 74 91 c6 91		        .word nt_within, xt_hexstore, z_hexstore
>c3af	68 65 78 73 74 6f 72 65		        .text "hexstore"
.c3b7					nt_within:
>c3b7	06 10				        .byte 6, UF
>c3b9	c5 c3 80 a6 95 a6		        .word nt_to_in, xt_within, z_within
>c3bf	77 69 74 68 69 6e		        .text "within"
.c3c5					nt_to_in:
>c3c5	03 00				        .byte 3, 0
>c3c7	d0 c3 8d a2 97 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c3cd	3e 69 6e			        .text ">in"
.c3d0					nt_less_number_sign:
>c3d0	02 00				        .byte 2, 0
>c3d2	da c3 4a 93 57 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c3d8	3c 23				        .text "<#"
.c3da					nt_number_sign:
>c3da	01 10				        .byte 1, UF
>c3dc	e3 c3 68 97 9c 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c3e2	23				        .text "#"
.c3e3					nt_number_sign_s:
>c3e3	02 10				        .byte 2, UF
>c3e5	ed c3 bf 97 cf 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c3eb	23 73				        .text "#s"
.c3ed					nt_number_sign_greater:
>c3ed	02 10				        .byte 2, UF
>c3ef	f7 c3 9d 97 be 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c3f5	23 3e				        .text "#>"
.c3f7					nt_hold:
>c3f7	04 10				        .byte 4, UF
>c3f9	03 c4 c7 91 d8 91		        .word nt_sign, xt_hold, z_hold
>c3ff	68 6f 6c 64			        .text "hold"
.c403					nt_sign:
>c403	04 10				        .byte 4, UF
>c405	0f c4 c8 9f dc 9f		        .word nt_output, xt_sign, z_sign
>c40b	73 69 67 6e			        .text "sign"
.c40f					nt_output:
>c40f	06 00				        .byte 6, 0
>c411	1d c4 69 98 73 98		        .word nt_input, xt_output, z_output
>c417	6f 75 74 70 75 74		        .text "output"
.c41d					nt_input:
>c41d	05 00				        .byte 5, 0
>c41f	2a c4 47 92 51 92		        .word nt_cr, xt_input, z_input
>c425	69 6e 70 75 74			        .text "input"
.c42a					nt_cr:
>c42a	02 00				        .byte 2, 0
>c42c	34 c4 53 89 58 89		        .word nt_page, xt_cr, z_cr
>c432	63 72				        .text "cr"
.c434					nt_page:
>c434	04 00				        .byte 4, 0
>c436	40 c4 92 98 af 98		        .word nt_at_xy, xt_page, z_page
>c43c	70 61 67 65			        .text "page"
.c440					nt_at_xy:
>c440	05 10				        .byte 5, UF
>c442	4d c4 50 83 6d 83		        .word nt_marker, xt_at_xy, z_at_xy
>c448	61 74 2d 78 79			        .text "at-xy"
.c44d					nt_marker:
>c44d	06 04				        .byte 6, IM
>c44f	5b c4 99 94 d6 94		        .word nt_words, xt_marker, z_marker
>c455	6d 61 72 6b 65 72		        .text "marker"
.c45b					nt_words:
>c45b	05 00				        .byte 5, 0
>c45d	68 c4 f3 a6 4e a7		        .word nt_wordsize, xt_words, z_words
>c463	77 6f 72 64 73			        .text "words"
.c468					nt_wordsize:
>c468	08 10				        .byte 8, UF
>c46a	78 c4 4f a7 6f a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c470	77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c478					nt_aligned:
>c478	07 00				        .byte 7, 0
>c47a	87 c4 aa 82 aa 82		        .word nt_align, xt_align, z_align
>c480	61 6c 69 67 6e 65 64		        .text "aligned"
.c487					nt_align:
>c487	05 00				        .byte 5, 0
>c489	94 c4 aa 82 aa 82		        .word nt_bell, xt_align, z_align
>c48f	61 6c 69 67 6e			        .text "align"
.c494					nt_bell:
>c494	04 00				        .byte 4, 0
>c496	a0 c4 84 83 89 83		        .word nt_dump, xt_bell, z_bell
>c49c	62 65 6c 6c			        .text "bell"
.c4a0					nt_dump:
>c4a0	04 10				        .byte 4, UF
>c4a2	ac c4 24 8d 8a 8d		        .word nt_dot_s, xt_dump, z_dump
>c4a8	64 75 6d 70			        .text "dump"
.c4ac					nt_dot_s:
>c4ac	02 00				        .byte 2, 0
>c4ae	b6 c4 90 8c d3 8c		        .word nt_disasm, xt_dot_s, z_dot_s
>c4b4	2e 73				        .text ".s"
.c4b6					nt_disasm:
>c4b6	06 10				        .byte 6, UF
>c4b8	c4 c4 2a 8b 30 8b		        .word nt_compare, xt_disasm, z_disasm
>c4be	64 69 73 61 73 6d		        .text "disasm"
.c4c4					nt_compare:
>c4c4	07 10				        .byte 7, UF
>c4c6	d3 c4 78 87 dc 87		        .word nt_search, xt_compare, z_compare
>c4cc	63 6f 6d 70 61 72 65		        .text "compare"
.c4d3					nt_search:
>c4d3	06 18				        .byte 6, UF+NN
>c4d5	e1 c4 ca 9e 68 9f		        .word +, xt_search, z_search
>c4db	73 65 61 72 63 68		        .text "search"
.c4e1					+
.c4e1					nt_environment_q:
>c4e1	0c 10				        .byte 12, UF
>c4e3	f5 c4 05 8e 81 8e		        .word +, xt_environment_q, z_environment_q
>c4e9	65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c4f1	65 6e 74 3f
.c4f5					+
.c4f5					nt_find:
>c4f5	04 10				        .byte 4, UF
>c4f7	01 c5 83 8f ca 8f		        .word nt_word, xt_find, z_find
>c4fd	66 69 6e 64			        .text "find"
.c501					nt_word:
>c501	04 10				        .byte 4, UF
>c503	0d c5 96 a6 db a6		        .word nt_paren, xt_word, z_word
>c509	77 6f 72 64			        .text "word"
.c50d					nt_paren:
>c50d	01 04				        .byte 1, IM
>c50f	16 c5 b0 98 bf 98		        .word nt_dot_paren, xt_paren, z_paren
>c515	28				        .text "("
.c516					nt_dot_paren:
>c516	02 04				        .byte 2, IM
>c518	20 c5 48 8c 56 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c51e	2e 28				        .text ".("
.c520					nt_if:
>c520	02 0d				        .byte 2, IM+CO+NN
>c522	2a c5 f3 91 03 92		        .word nt_then, xt_if, z_if
>c528	69 66				        .text "if"
.c52a					nt_then:
>c52a	04 0d				        .byte 4, IM+CO+NN
>c52c	36 c5 9d a1 a6 a1		        .word nt_else, xt_then, z_then
>c532	74 68 65 6e			        .text "then"
.c536					nt_else:
>c536	04 0d				        .byte 4, IM+CO+NN
>c538	42 c5 b1 8d ca 8d		        .word nt_repeat, xt_else, z_else
>c53e	65 6c 73 65			        .text "else"
.c542					nt_repeat:
>c542	06 0d				        .byte 6, IM+CO+NN
>c544	50 c5 1b 9b 27 9b		        .word nt_until, xt_repeat, z_repeat
>c54a	72 65 70 65 61 74		        .text "repeat"
.c550					nt_until:
>c550	05 0d				        .byte 5, IM+CO+NN
>c552	5d c5 24 a6 2e a6		        .word nt_while, xt_until, z_until
>c558	75 6e 74 69 6c			        .text "until"
.c55d					nt_while:
>c55d	05 0d				        .byte 5, IM+CO+NN
>c55f	6a c5 6c a6 7f a6		        .word nt_case, xt_while, z_while
>c565	77 68 69 6c 65			        .text "while"
.c56a					nt_case:
>c56a	04 0d				        .byte 4, IM+CO+NN
>c56c	76 c5 82 a7 88 a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c572	63 61 73 65			        .text "case"
.c576					nt_of:
>c576	02 0d				        .byte 2, IM+CO+NN
>c578	80 c5 d0 97 e8 97		        .word nt_endof, xt_of, z_of
>c57e	6f 66				        .text "of"
.c580					nt_endof:
>c580	05 0d				        .byte 5, IM+CO+NN
>c582	8d c5 b1 8d ca 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c588	65 6e 64 6f 66			        .text "endof"
.c58d					nt_endcase:
>c58d	07 0d				        .byte 7, IM+CO+NN
>c58f	9c c5 f0 8d 04 8e		        .word nt_defer_fetch, xt_endcase, z_endcase
>c595	65 6e 64 63 61 73 65		        .text "endcase"
.c59c					nt_defer_fetch:
>c59c	06 00				        .byte 6, 0
>c59e	aa c5 cf 8a d5 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c5a4	64 65 66 65 72 40		        .text "defer@"
.c5aa					nt_defer_store:
>c5aa	06 00				        .byte 6, 0
>c5ac	b8 c5 d6 8a dc 8a		        .word nt_is, xt_defer_store, z_defer_store
>c5b2	64 65 66 65 72 21		        .text "defer!"
.c5b8					nt_is:
>c5b8	02 04				        .byte 2, IM
>c5ba	c2 c5 eb 92 03 93		        .word nt_action_of, xt_is, z_is
>c5c0	69 73				        .text "is"
.c5c2					nt_action_of:
>c5c2	09 04				        .byte 9, IM
>c5c4	d3 c5 70 82 88 82		        .word nt_useraddr, xt_action_of, z_action_of
>c5ca	61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c5d2	66
.c5d3					nt_useraddr:
>c5d3	08 00				        .byte 8, 0
>c5d5	e3 c5 48 a6 52 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c5db	75 73 65 72 61 64 64 72		        .text "useraddr"
.c5e3					nt_buffer_colon:
>c5e3	07 00				        .byte 7, 0
>c5e5	f2 c5 d6 85 dc 85		        .word +, xt_buffer_colon, z_buffer_colon
>c5eb	62 75 66 66 65 72 3a		        .text "buffer:"
.c5f2					+
.c5f2					nt_buffstatus:
>c5f2	0a 00				        .byte 10, 0
>c5f4	04 c6 dd 85 ec 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c5fa	62 75 66 66 73 74 61 74		        .text "buffstatus"
>c602	75 73
.c604					nt_buffblocknum:
>c604	0c 00				        .byte 12, 0
>c606	18 c6 95 85 a4 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c60c	62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c614	6b 6e 75 6d
.c618					nt_blkbuffer:
>c618	09 00				        .byte 9, 0
>c61a	29 c6 a3 83 b0 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c620	62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c628	72
.c629					nt_scr:
>c629	03 00				        .byte 3, 0
>c62b	34 c6 ba 9e c9 9e		        .word nt_blk, xt_scr, z_scr
>c631	73 63 72			        .text "scr"
.c634					nt_blk:
>c634	03 00				        .byte 3, 0
>c636	3f c6 93 83 a2 83		        .word nt_block_write, xt_blk, z_blk
>c63c	62 6c 6b			        .text "blk"
.c63f					nt_block_write:
>c63f	0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c641	52 c6 50 85 5e 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c647	62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c64f	69 74 65
.c652					nt_block_write_vector:
>c652	12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c654	6c c6 5e 85 6d 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c65a	62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c662	69 74 65 2d 76 65 63 74 6f 72
.c66c					nt_block_read:
>c66c	0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c66e	7e c6 2d 85 3b 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c674	62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c67c	61 64
.c67e					nt_block_read_vector:
>c67e	11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c680	97 c6 3b 85 4a 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c686	62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c68e	61 64 2d 76 65 63 74 6f 72
.c697					nt_save_buffers:
>c697	0c 00				        .byte 12, 0
>c699	ab c6 9f 9e b9 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c69f	73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c6a7	66 65 72 73
.c6ab					nt_block:
>c6ab	05 00				        .byte 5, 0
>c6ad	b8 c6 b1 83 03 84		        .word nt_update, xt_block, z_block
>c6b3	62 6c 6f 63 6b			        .text "block"
.c6b8					nt_update:
>c6b8	06 00				        .byte 6, 0
>c6ba	c6 c6 3f a6 47 a6		        .word nt_buffer, xt_update, z_update
>c6c0	75 70 64 61 74 65		        .text "update"
.c6c6					nt_buffer:
>c6c6	06 00				        .byte 6, 0
>c6c8	d4 c6 a5 85 d5 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c6ce	62 75 66 66 65 72		        .text "buffer"
.c6d4					nt_empty_buffers:
>c6d4	0d 00				        .byte 13, 0
>c6d6	e9 c6 e9 8d ef 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c6dc	65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c6e4	66 66 65 72 73
.c6e9					nt_flush:
>c6e9	05 00				        .byte 5, 0
>c6eb	f6 c6 77 90 80 90		        .word nt_load, xt_flush, z_flush
>c6f1	66 6c 75 73 68			        .text "flush"
.c6f6					nt_load:
>c6f6	04 10				        .byte 4, UF
>c6f8	02 c7 a7 93 ea 93		        .word nt_thru, xt_load, z_load
>c6fe	6c 6f 61 64			        .text "load"
.c702					nt_thru:
>c702	04 10				        .byte 4, UF
>c704	0e c7 a7 a1 eb a1		        .word nt_list, xt_thru, z_thru
>c70a	74 68 72 75			        .text "thru"
.c70e					nt_list:
>c70e	04 10				        .byte 4, UF
>c710	1a c7 6d 93 79 93		        .word +, xt_list, z_list
>c716	6c 69 73 74			        .text "list"
.c71a					+
.c71a					nt_block_ramdrive_init:
>c71a	13 10				        .byte 19, UF
>c71c	35 c7 04 84 2c 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c722	62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c72a	6d 64 72 69 76 65 2d 69 6e 69 74
.c735					+
.c735					nt_definitions:
>c735	0b 00				        .byte 11, 0
>c737	48 c7 dd 8a e5 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c73d	64 65 66 69 6e 69 74 69		        .text "definitions"
>c745	6f 6e 73
.c748					nt_wordlist:
>c748	08 00				        .byte 8, 0
>c74a	58 c7 dc a6 f2 a6		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c750	77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c758					nt_search_wordlist:
>c758	0f 10				        .byte 15, UF
>c75a	6f c7 81 9b 61 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c760	73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c768	6f 72 64 6c 69 73 74
.c76f					nt_set_current:
>c76f	0b 10				        .byte 11, UF
>c771	82 c7 f0 9c fb 9c		        .word nt_get_current, xt_set_current, z_set_current
>c777	73 65 74 2d 63 75 72 72		        .text "set-current"
>c77f	65 6e 74
.c782					nt_get_current:
>c782	0b 00				        .byte 11, 0
>c784	95 c7 19 91 23 91		        .word nt_set_order, xt_get_current, z_get_current
>c78a	67 65 74 2d 63 75 72 72		        .text "get-current"
>c792	65 6e 74
.c795					nt_set_order:
>c795	09 00				        .byte 9, 0
>c797	a6 c7 fc 9c 2f 9d		        .word nt_get_order, xt_set_order, z_set_order
>c79d	73 65 74 2d 6f 72 64 65		        .text "set-order"
>c7a5	72
.c7a6					nt_get_order:
>c7a6	09 00				        .byte 9, 0
>c7a8	b7 c7 24 91 4c 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c7ae	67 65 74 2d 6f 72 64 65		        .text "get-order"
>c7b6	72
.c7b7					nt_root_wordlist:
>c7b7	0d 00				        .byte 13, 0
>c7b9	cc c7 2f 9b 37 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c7bf	72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c7c7	64 6c 69 73 74
.c7cc					+
.c7cc					nt_assembler_wordlist:
>c7cc	12 00				        .byte 18, 0
>c7ce	e6 c7 82 a3 8a a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c7d4	61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c7dc	72 2d 77 6f 72 64 6c 69 73 74
.c7e6					+
.c7e6					nt_editor_wordlist:
>c7e6	0f 00				        .byte 15, 0
>c7e8	fd c7 e9 97 f1 97		        .word +, xt_editor_wordlist, z_editor_wordlist
>c7ee	65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c7f6	6f 72 64 6c 69 73 74
.c7fd					+
.c7fd					nt_forth_wordlist:
>c7fd	0e 00				        .byte 14, 0
>c7ff	13 c8 82 a7 88 a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c805	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c80d	72 64 6c 69 73 74
.c813					nt_only:
>c813	04 00				        .byte 4, 0
>c815	1f c8 08 98 13 98		        .word nt_also, xt_only, z_only
>c81b	6f 6e 6c 79			        .text "only"
.c81f					nt_also:
>c81f	04 00				        .byte 4, 0
>c821	2b c8 20 83 2f 83		        .word nt_previous, xt_also, z_also
>c827	61 6c 73 6f			        .text "also"
.c82b					nt_previous:
>c82b	08 00				        .byte 8, 0
>c82d	3b c8 36 9a 42 9a		        .word nt_to_order, xt_previous, z_previous
>c833	70 72 65 76 69 6f 75 73		        .text "previous"
.c83b					nt_to_order:
>c83b	06 00				        .byte 6, 0
>c83d	49 c8 38 a3 4a a3		        .word nt_order, xt_to_order, z_to_order
>c843	3e 6f 72 64 65 72		        .text ">order"
.c849					nt_order:
>c849	05 00				        .byte 5, 0
>c84b	56 c8 26 98 50 98		        .word nt_forth, xt_order, z_order
>c851	6f 72 64 65 72			        .text "order"
.c856					nt_forth:
>c856	05 00				        .byte 5, 0
>c858	63 c8 b8 90 be 90		        .word +, xt_forth, z_forth
>c85e	66 6f 72 74 68			        .text "forth"
.c863					+
>c863	03 08				nt_see: .byte 3, NN
>c865	6e c8 62 9c ef 9c		        .word +, xt_see, z_see
>c86b	73 65 65			        .text "see"
.c86e					+
.c86e					nt_ed:
>c86e	02 08				        .byte 2, NN
>c870	78 c8 ad 8d b0 8d		        .word +, xt_ed, z_ed
>c876	65 64				        .text "ed"
.c878					+
.c878					nt_cold:
>c878	04 00				        .byte 4, 0
>c87a	84 c8 00 80 c5 80		        .word nt_bye, xt_cold, z_cold
>c880	63 6f 6c 64			        .text "cold"
.c884					nt_bye:
>c884	03				        .byte 3         ; length of word strings
>c885	00				        .byte 0         ; status byte
>c886	00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>c888	ed 85				        .word xt_bye    ; start of code block (xt of this word)
>c88a	f0 85				        .word z_bye     ; end of code (RTS)
>c88c	62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.c88f					root_dictionary_start:
.c88f					nt_root_set_order:
>c88f	09 00				        .byte 9, 0
>c891	a0 c8 fc 9c 2f 9d		        .word nt_root_forth, xt_set_order, z_set_order
>c897	73 65 74 2d 6f 72 64 65		        .text "set-order"
>c89f	72
.c8a0					nt_root_forth:
>c8a0	05 00				        .byte 5, 0
>c8a2	ad c8 b8 90 be 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>c8a8	66 6f 72 74 68			        .text "forth"
.c8ad					nt_root_forth_wordlist:
>c8ad	0e 00				        .byte 14, 0
>c8af	c3 c8 82 a7 88 a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>c8b5	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c8bd	72 64 6c 69 73 74
.c8c3					nt_root_words:
>c8c3	05 00				        .byte 5, 0
>c8c5	00 00 f3 a6 4e a7		        .word 0000, xt_words, z_words
>c8cb	77 6f 72 64 73			        .text "words"
.c8d0					editor_dictionary_start:
.c8d0					nt_editor_o:
>c8d0	01 00				        .byte 1, 0
>c8d2	d9 c8 b5 a8 fa a8		        .word nt_editor_line, xt_editor_o, z_editor_o
>c8d8	6f				        .text "o"
.c8d9					nt_editor_line:
>c8d9	04 10				        .byte 4, UF
>c8db	e5 c8 9c a8 b4 a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>c8e1	6c 69 6e 65			        .text "line"
.c8e5					nt_editor_l:
>c8e5	01 00				        .byte 1, 0
>c8e7	ee c8 20 a8 9b a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>c8ed	6c				        .text "l"
.c8ee					nt_editor_el:
>c8ee	02 00				        .byte 2, 0
>c8f0	f8 c8 0e a8 1f a8		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>c8f6	65 6c				        .text "el"
.c8f8					nt_editor_erase_screen:
>c8f8	0c 00				        .byte 12, 0
>c8fa	0c c9 fc a7 0d a8		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>c900	65 72 61 73 65 2d 73 63		        .text "erase-screen"
>c908	72 65 65 6e
.c90c					nt_editor_enter_screen:
>c90c	0c 00				        .byte 12, 0
>c90e	00 00 e0 a7 fb a7		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>c914	65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>c91c	72 65 65 6e
.c920					assembler_dictionary_start:
.c920					nt_asm_adc_h:
>c920	05 04						.byte 5, IM
>c922	2d c9				                .word nt_asm_adc_x
>c924	fb a8 00 a9					.word xt_asm_adc_h, z_asm_adc_h
>c928	61 64 63 2e 23					.text "adc.#"
.c92d					nt_asm_adc_x:
>c92d	05 04						.byte 5, IM
>c92f	3a c9				                .word nt_asm_adc_y
>c931	00 a9 05 a9					.word xt_asm_adc_x, z_asm_adc_x
>c935	61 64 63 2e 78					.text "adc.x"
.c93a					nt_asm_adc_y:
>c93a	05 04						.byte 5, IM
>c93c	47 c9				                .word nt_asm_adc_z
>c93e	05 a9 0a a9					.word xt_asm_adc_y, z_asm_adc_y
>c942	61 64 63 2e 79					.text "adc.y"
.c947					nt_asm_adc_z:
>c947	05 04						.byte 5, IM
>c949	54 c9				                .word nt_asm_adc_zi
>c94b	0a a9 0f a9					.word xt_asm_adc_z, z_asm_adc_z
>c94f	61 64 63 2e 7a					.text "adc.z"
.c954					nt_asm_adc_zi:
>c954	06 04						.byte 6, IM
>c956	62 c9				                .word nt_asm_adc_ziy
>c958	0f a9 14 a9					.word xt_asm_adc_zi, z_asm_adc_zi
>c95c	61 64 63 2e 7a 69				.text "adc.zi"
.c962					nt_asm_adc_ziy:
>c962	07 04						.byte 7, IM
>c964	71 c9				                .word nt_asm_adc_zx
>c966	14 a9 19 a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>c96a	61 64 63 2e 7a 69 79				.text "adc.ziy"
.c971					nt_asm_adc_zx:
>c971	06 04						.byte 6, IM
>c973	7f c9				                .word nt_asm_adc_zxi
>c975	19 a9 1e a9					.word xt_asm_adc_zx, z_asm_adc_zx
>c979	61 64 63 2e 7a 78				.text "adc.zx"
.c97f					nt_asm_adc_zxi:
>c97f	07 04						.byte 7, IM
>c981	8e c9				                .word nt_asm_and
>c983	1e a9 23 a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>c987	61 64 63 2e 7a 78 69				.text "adc.zxi"
.c98e					nt_asm_and:
>c98e	04 04						.byte 4, IM
>c990	9a c9				                .word nt_asm_and_h
>c992	23 a9 28 a9					.word xt_asm_and, z_asm_and
>c996	61 6e 64 2e					.text "and."
.c99a					nt_asm_and_h:
>c99a	05 04						.byte 5, IM
>c99c	a7 c9				                .word nt_asm_and_x
>c99e	28 a9 2d a9					.word xt_asm_and_h, z_asm_and_h
>c9a2	61 6e 64 2e 23					.text "and.#"
.c9a7					nt_asm_and_x:
>c9a7	05 04						.byte 5, IM
>c9a9	b4 c9				                .word nt_asm_and_y
>c9ab	2d a9 32 a9					.word xt_asm_and_x, z_asm_and_x
>c9af	61 6e 64 2e 78					.text "and.x"
.c9b4					nt_asm_and_y:
>c9b4	05 04						.byte 5, IM
>c9b6	c1 c9				                .word nt_asm_and_z
>c9b8	32 a9 37 a9					.word xt_asm_and_y, z_asm_and_y
>c9bc	61 6e 64 2e 79					.text "and.y"
.c9c1					nt_asm_and_z:
>c9c1	05 04						.byte 5, IM
>c9c3	ce c9				                .word nt_asm_and_zi
>c9c5	37 a9 3c a9					.word xt_asm_and_z, z_asm_and_z
>c9c9	61 6e 64 2e 7a					.text "and.z"
.c9ce					nt_asm_and_zi:
>c9ce	06 04						.byte 6, IM
>c9d0	dc c9				                .word nt_asm_and_ziy
>c9d2	3c a9 41 a9					.word xt_asm_and_zi, z_asm_and_zi
>c9d6	61 6e 64 2e 7a 69				.text "and.zi"
.c9dc					nt_asm_and_ziy:
>c9dc	07 04						.byte 7, IM
>c9de	eb c9				                .word nt_asm_and_zx
>c9e0	41 a9 46 a9					.word xt_asm_and_ziy, z_asm_and_ziy
>c9e4	61 6e 64 2e 7a 69 79				.text "and.ziy"
.c9eb					nt_asm_and_zx:
>c9eb	06 04						.byte 6, IM
>c9ed	f9 c9				                .word nt_asm_and_zxi
>c9ef	46 a9 4b a9					.word xt_asm_and_zx, z_asm_and_zx
>c9f3	61 6e 64 2e 7a 78				.text "and.zx"
.c9f9					nt_asm_and_zxi:
>c9f9	07 04						.byte 7, IM
>c9fb	08 ca				                .word nt_asm_asl
>c9fd	4b a9 50 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>ca01	61 6e 64 2e 7a 78 69				.text "and.zxi"
.ca08					nt_asm_asl:
>ca08	03 04						.byte 3, IM
>ca0a	13 ca				                .word nt_asm_asl_a
>ca0c	50 a9 55 a9					.word xt_asm_asl, z_asm_asl
>ca10	61 73 6c					.text "asl"
.ca13					nt_asm_asl_a:
>ca13	05 04						.byte 5, IM
>ca15	20 ca				                .word nt_asm_asl_x
>ca17	55 a9 5a a9					.word xt_asm_asl_a, z_asm_asl_a
>ca1b	61 73 6c 2e 61					.text "asl.a"
.ca20					nt_asm_asl_x:
>ca20	05 04						.byte 5, IM
>ca22	2d ca				                .word nt_asm_asl_z
>ca24	5a a9 5f a9					.word xt_asm_asl_x, z_asm_asl_x
>ca28	61 73 6c 2e 78					.text "asl.x"
.ca2d					nt_asm_asl_z:
>ca2d	05 04						.byte 5, IM
>ca2f	3a ca				                .word nt_asm_asl_zx
>ca31	5f a9 64 a9					.word xt_asm_asl_z, z_asm_asl_z
>ca35	61 73 6c 2e 7a					.text "asl.z"
.ca3a					nt_asm_asl_zx:
>ca3a	06 04						.byte 6, IM
>ca3c	48 ca				                .word nt_asm_bcc
>ca3e	64 a9 69 a9					.word xt_asm_asl_zx, z_asm_asl_zx
>ca42	61 73 6c 2e 7a 78				.text "asl.zx"
.ca48					nt_asm_bcc:
>ca48	03 04						.byte 3, IM
>ca4a	53 ca				                .word nt_asm_bcs
>ca4c	69 a9 6e a9					.word xt_asm_bcc, z_asm_bcc
>ca50	62 63 63					.text "bcc"
.ca53					nt_asm_bcs:
>ca53	03 04						.byte 3, IM
>ca55	5e ca				                .word nt_asm_beq
>ca57	6e a9 75 a9					.word xt_asm_bcs, z_asm_bcs
>ca5b	62 63 73					.text "bcs"
.ca5e					nt_asm_beq:
>ca5e	03 04						.byte 3, IM
>ca60	69 ca				                .word nt_asm_bit
>ca62	75 a9 7a a9					.word xt_asm_beq, z_asm_beq
>ca66	62 65 71					.text "beq"
.ca69					nt_asm_bit:
>ca69	03 04						.byte 3, IM
>ca6b	74 ca				                .word nt_asm_bit_h
>ca6d	7a a9 7f a9					.word xt_asm_bit, z_asm_bit
>ca71	62 69 74					.text "bit"
.ca74					nt_asm_bit_h:
>ca74	05 04						.byte 5, IM
>ca76	81 ca				                .word nt_asm_bit_x
>ca78	7f a9 84 a9					.word xt_asm_bit_h, z_asm_bit_h
>ca7c	62 69 74 2e 23					.text "bit.#"
.ca81					nt_asm_bit_x:
>ca81	05 04						.byte 5, IM
>ca83	8e ca				                .word nt_asm_bit_z
>ca85	84 a9 89 a9					.word xt_asm_bit_x, z_asm_bit_x
>ca89	62 69 74 2e 78					.text "bit.x"
.ca8e					nt_asm_bit_z:
>ca8e	05 04						.byte 5, IM
>ca90	9b ca				                .word nt_asm_bit_zx
>ca92	89 a9 8e a9					.word xt_asm_bit_z, z_asm_bit_z
>ca96	62 69 74 2e 7a					.text "bit.z"
.ca9b					nt_asm_bit_zx:
>ca9b	06 04						.byte 6, IM
>ca9d	a9 ca				                .word nt_asm_bmi
>ca9f	8e a9 93 a9					.word xt_asm_bit_zx, z_asm_bit_zx
>caa3	62 69 74 2e 7a 78				.text "bit.zx"
.caa9					nt_asm_bmi:
>caa9	03 04						.byte 3, IM
>caab	b4 ca				                .word nt_asm_bne
>caad	93 a9 98 a9					.word xt_asm_bmi, z_asm_bmi
>cab1	62 6d 69					.text "bmi"
.cab4					nt_asm_bne:
>cab4	03 04						.byte 3, IM
>cab6	bf ca				                .word nt_asm_bpl
>cab8	98 a9 9d a9					.word xt_asm_bne, z_asm_bne
>cabc	62 6e 65					.text "bne"
.cabf					nt_asm_bpl:
>cabf	03 04						.byte 3, IM
>cac1	ca ca				                .word nt_asm_bra
>cac3	9d a9 a2 a9					.word xt_asm_bpl, z_asm_bpl
>cac7	62 70 6c					.text "bpl"
.caca					nt_asm_bra:
>caca	03 04						.byte 3, IM
>cacc	d5 ca				                .word nt_asm_brk
>cace	a2 a9 a7 a9					.word xt_asm_bra, z_asm_bra
>cad2	62 72 61					.text "bra"
.cad5					nt_asm_brk:
>cad5	03 04						.byte 3, IM
>cad7	e0 ca				                .word nt_asm_bvc
>cad9	a7 a9 ac a9					.word xt_asm_brk, z_asm_brk
>cadd	62 72 6b					.text "brk"
.cae0					nt_asm_bvc:
>cae0	03 04						.byte 3, IM
>cae2	eb ca				                .word nt_asm_bvs
>cae4	ac a9 b1 a9					.word xt_asm_bvc, z_asm_bvc
>cae8	62 76 63					.text "bvc"
.caeb					nt_asm_bvs:
>caeb	03 04						.byte 3, IM
>caed	f6 ca				                .word nt_asm_clc
>caef	b1 a9 b6 a9					.word xt_asm_bvs, z_asm_bvs
>caf3	62 76 73					.text "bvs"
.caf6					nt_asm_clc:
>caf6	03 04						.byte 3, IM
>caf8	01 cb				                .word nt_asm_cld
>cafa	b6 a9 bb a9					.word xt_asm_clc, z_asm_clc
>cafe	63 6c 63					.text "clc"
.cb01					nt_asm_cld:
>cb01	03 04						.byte 3, IM
>cb03	0c cb				                .word nt_asm_cli
>cb05	bb a9 c0 a9					.word xt_asm_cld, z_asm_cld
>cb09	63 6c 64					.text "cld"
.cb0c					nt_asm_cli:
>cb0c	03 04						.byte 3, IM
>cb0e	17 cb				                .word nt_asm_clv
>cb10	c0 a9 c5 a9					.word xt_asm_cli, z_asm_cli
>cb14	63 6c 69					.text "cli"
.cb17					nt_asm_clv:
>cb17	03 04						.byte 3, IM
>cb19	22 cb				                .word nt_asm_cmp
>cb1b	c5 a9 ca a9					.word xt_asm_clv, z_asm_clv
>cb1f	63 6c 76					.text "clv"
.cb22					nt_asm_cmp:
>cb22	03 04						.byte 3, IM
>cb24	2d cb				                .word nt_asm_cmp_h
>cb26	ca a9 cf a9					.word xt_asm_cmp, z_asm_cmp
>cb2a	63 6d 70					.text "cmp"
.cb2d					nt_asm_cmp_h:
>cb2d	05 04						.byte 5, IM
>cb2f	3a cb				                .word nt_asm_cmp_x
>cb31	cf a9 d4 a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cb35	63 6d 70 2e 23					.text "cmp.#"
.cb3a					nt_asm_cmp_x:
>cb3a	05 04						.byte 5, IM
>cb3c	47 cb				                .word nt_asm_cmp_y
>cb3e	d4 a9 d9 a9					.word xt_asm_cmp_x, z_asm_cmp_x
>cb42	63 6d 70 2e 78					.text "cmp.x"
.cb47					nt_asm_cmp_y:
>cb47	05 04						.byte 5, IM
>cb49	54 cb				                .word nt_asm_cmp_z
>cb4b	d9 a9 de a9					.word xt_asm_cmp_y, z_asm_cmp_y
>cb4f	63 6d 70 2e 79					.text "cmp.y"
.cb54					nt_asm_cmp_z:
>cb54	05 04						.byte 5, IM
>cb56	61 cb				                .word nt_asm_cmp_zi
>cb58	de a9 e3 a9					.word xt_asm_cmp_z, z_asm_cmp_z
>cb5c	63 6d 70 2e 7a					.text "cmp.z"
.cb61					nt_asm_cmp_zi:
>cb61	06 04						.byte 6, IM
>cb63	6f cb				                .word nt_asm_cmp_ziy
>cb65	e3 a9 e8 a9					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cb69	63 6d 70 2e 7a 69				.text "cmp.zi"
.cb6f					nt_asm_cmp_ziy:
>cb6f	07 04						.byte 7, IM
>cb71	7e cb				                .word nt_asm_cmp_zx
>cb73	e8 a9 ed a9					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cb77	63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cb7e					nt_asm_cmp_zx:
>cb7e	06 04						.byte 6, IM
>cb80	8c cb				                .word nt_asm_cmp_zxi
>cb82	ed a9 f2 a9					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cb86	63 6d 70 2e 7a 78				.text "cmp.zx"
.cb8c					nt_asm_cmp_zxi:
>cb8c	07 04						.byte 7, IM
>cb8e	9b cb				                .word nt_asm_cpx
>cb90	f2 a9 f7 a9					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cb94	63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cb9b					nt_asm_cpx:
>cb9b	03 04						.byte 3, IM
>cb9d	a6 cb				                .word nt_asm_cpx_h
>cb9f	f7 a9 fc a9					.word xt_asm_cpx, z_asm_cpx
>cba3	63 70 78					.text "cpx"
.cba6					nt_asm_cpx_h:
>cba6	05 04						.byte 5, IM
>cba8	b3 cb				                .word nt_asm_cpx_z
>cbaa	fc a9 01 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>cbae	63 70 78 2e 23					.text "cpx.#"
.cbb3					nt_asm_cpx_z:
>cbb3	05 04						.byte 5, IM
>cbb5	c0 cb				                .word nt_asm_cpy
>cbb7	01 aa 06 aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cbbb	63 70 78 2e 7a					.text "cpx.z"
.cbc0					nt_asm_cpy:
>cbc0	03 04						.byte 3, IM
>cbc2	cb cb				                .word nt_asm_cpy_h
>cbc4	06 aa 0d aa					.word xt_asm_cpy, z_asm_cpy
>cbc8	63 70 79					.text "cpy"
.cbcb					nt_asm_cpy_h:
>cbcb	05 04						.byte 5, IM
>cbcd	d8 cb				                .word nt_asm_cpy_z
>cbcf	0d aa 12 aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cbd3	63 70 79 2e 23					.text "cpy.#"
.cbd8					nt_asm_cpy_z:
>cbd8	05 04						.byte 5, IM
>cbda	e5 cb				                .word nt_asm_dec
>cbdc	12 aa 17 aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cbe0	63 70 79 2e 7a					.text "cpy.z"
.cbe5					nt_asm_dec:
>cbe5	03 04						.byte 3, IM
>cbe7	f0 cb				                .word nt_asm_dec_a
>cbe9	17 aa 1c aa					.word xt_asm_dec, z_asm_dec
>cbed	64 65 63					.text "dec"
.cbf0					nt_asm_dec_a:
>cbf0	05 04						.byte 5, IM
>cbf2	fd cb				                .word nt_asm_dec_x
>cbf4	1c aa 21 aa					.word xt_asm_dec_a, z_asm_dec_a
>cbf8	64 65 63 2e 61					.text "dec.a"
.cbfd					nt_asm_dec_x:
>cbfd	05 04						.byte 5, IM
>cbff	0a cc				                .word nt_asm_dec_z
>cc01	21 aa 26 aa					.word xt_asm_dec_x, z_asm_dec_x
>cc05	64 65 63 2e 78					.text "dec.x"
.cc0a					nt_asm_dec_z:
>cc0a	05 04						.byte 5, IM
>cc0c	17 cc				                .word nt_asm_dec_zx
>cc0e	26 aa 2b aa					.word xt_asm_dec_z, z_asm_dec_z
>cc12	64 65 63 2e 7a					.text "dec.z"
.cc17					nt_asm_dec_zx:
>cc17	06 04						.byte 6, IM
>cc19	25 cc				                .word nt_asm_dex
>cc1b	2b aa 30 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cc1f	64 65 63 2e 7a 78				.text "dec.zx"
.cc25					nt_asm_dex:
>cc25	03 04						.byte 3, IM
>cc27	30 cc				                .word nt_asm_dey
>cc29	30 aa 35 aa					.word xt_asm_dex, z_asm_dex
>cc2d	64 65 78					.text "dex"
.cc30					nt_asm_dey:
>cc30	03 04						.byte 3, IM
>cc32	3b cc				                .word nt_asm_eor
>cc34	35 aa 3a aa					.word xt_asm_dey, z_asm_dey
>cc38	64 65 79					.text "dey"
.cc3b					nt_asm_eor:
>cc3b	03 04						.byte 3, IM
>cc3d	46 cc				                .word nt_asm_eor_h
>cc3f	3a aa 3f aa					.word xt_asm_eor, z_asm_eor
>cc43	65 6f 72					.text "eor"
.cc46					nt_asm_eor_h:
>cc46	05 04						.byte 5, IM
>cc48	53 cc				                .word nt_asm_eor_x
>cc4a	3f aa 44 aa					.word xt_asm_eor_h, z_asm_eor_h
>cc4e	65 6f 72 2e 23					.text "eor.#"
.cc53					nt_asm_eor_x:
>cc53	05 04						.byte 5, IM
>cc55	60 cc				                .word nt_asm_eor_y
>cc57	44 aa 49 aa					.word xt_asm_eor_x, z_asm_eor_x
>cc5b	65 6f 72 2e 78					.text "eor.x"
.cc60					nt_asm_eor_y:
>cc60	05 04						.byte 5, IM
>cc62	6d cc				                .word nt_asm_eor_z
>cc64	49 aa 4e aa					.word xt_asm_eor_y, z_asm_eor_y
>cc68	65 6f 72 2e 79					.text "eor.y"
.cc6d					nt_asm_eor_z:
>cc6d	05 04						.byte 5, IM
>cc6f	7a cc				                .word nt_asm_eor_zi
>cc71	4e aa 53 aa					.word xt_asm_eor_z, z_asm_eor_z
>cc75	65 6f 72 2e 7a					.text "eor.z"
.cc7a					nt_asm_eor_zi:
>cc7a	06 04						.byte 6, IM
>cc7c	88 cc				                .word nt_asm_eor_ziy
>cc7e	53 aa 58 aa					.word xt_asm_eor_zi, z_asm_eor_zi
>cc82	65 6f 72 2e 7a 69				.text "eor.zi"
.cc88					nt_asm_eor_ziy:
>cc88	07 04						.byte 7, IM
>cc8a	97 cc				                .word nt_asm_eor_zx
>cc8c	58 aa 5d aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cc90	65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cc97					nt_asm_eor_zx:
>cc97	06 04						.byte 6, IM
>cc99	a5 cc				                .word nt_asm_eor_zxi
>cc9b	5d aa 62 aa					.word xt_asm_eor_zx, z_asm_eor_zx
>cc9f	65 6f 72 2e 7a 78				.text "eor.zx"
.cca5					nt_asm_eor_zxi:
>cca5	07 04						.byte 7, IM
>cca7	b4 cc				                .word nt_asm_inc
>cca9	62 aa 67 aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ccad	65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ccb4					nt_asm_inc:
>ccb4	03 04						.byte 3, IM
>ccb6	bf cc				                .word nt_asm_inc_a
>ccb8	67 aa 6c aa					.word xt_asm_inc, z_asm_inc
>ccbc	69 6e 63					.text "inc"
.ccbf					nt_asm_inc_a:
>ccbf	05 04						.byte 5, IM
>ccc1	cc cc				                .word nt_asm_inc_x
>ccc3	6c aa 71 aa					.word xt_asm_inc_a, z_asm_inc_a
>ccc7	69 6e 63 2e 61					.text "inc.a"
.cccc					nt_asm_inc_x:
>cccc	05 04						.byte 5, IM
>ccce	d9 cc				                .word nt_asm_inc_z
>ccd0	71 aa 76 aa					.word xt_asm_inc_x, z_asm_inc_x
>ccd4	69 6e 63 2e 78					.text "inc.x"
.ccd9					nt_asm_inc_z:
>ccd9	05 04						.byte 5, IM
>ccdb	e6 cc				                .word nt_asm_inc_zx
>ccdd	76 aa 7b aa					.word xt_asm_inc_z, z_asm_inc_z
>cce1	69 6e 63 2e 7a					.text "inc.z"
.cce6					nt_asm_inc_zx:
>cce6	06 04						.byte 6, IM
>cce8	f4 cc				                .word nt_asm_inx
>ccea	7b aa 80 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>ccee	69 6e 63 2e 7a 78				.text "inc.zx"
.ccf4					nt_asm_inx:
>ccf4	03 04						.byte 3, IM
>ccf6	ff cc				                .word nt_asm_iny
>ccf8	80 aa 85 aa					.word xt_asm_inx, z_asm_inx
>ccfc	69 6e 78					.text "inx"
.ccff					nt_asm_iny:
>ccff	03 04						.byte 3, IM
>cd01	0a cd				                .word nt_asm_jmp
>cd03	85 aa 8a aa					.word xt_asm_iny, z_asm_iny
>cd07	69 6e 79					.text "iny"
.cd0a					nt_asm_jmp:
>cd0a	03 04						.byte 3, IM
>cd0c	15 cd				                .word nt_asm_jmp_i
>cd0e	8a aa 8f aa					.word xt_asm_jmp, z_asm_jmp
>cd12	6a 6d 70					.text "jmp"
.cd15					nt_asm_jmp_i:
>cd15	05 04						.byte 5, IM
>cd17	22 cd				                .word nt_asm_jmp_xi
>cd19	8f aa 94 aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cd1d	6a 6d 70 2e 69					.text "jmp.i"
.cd22					nt_asm_jmp_xi:
>cd22	06 04						.byte 6, IM
>cd24	30 cd				                .word nt_asm_jsr
>cd26	94 aa 99 aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cd2a	6a 6d 70 2e 78 69				.text "jmp.xi"
.cd30					nt_asm_jsr:
>cd30	03 04						.byte 3, IM
>cd32	3b cd				                .word nt_asm_lda
>cd34	99 aa 9e aa					.word xt_asm_jsr, z_asm_jsr
>cd38	6a 73 72					.text "jsr"
.cd3b					nt_asm_lda:
>cd3b	03 04						.byte 3, IM
>cd3d	46 cd				                .word nt_asm_lda_h
>cd3f	9e aa a3 aa					.word xt_asm_lda, z_asm_lda
>cd43	6c 64 61					.text "lda"
.cd46					nt_asm_lda_h:
>cd46	05 04						.byte 5, IM
>cd48	53 cd				                .word nt_asm_lda_x
>cd4a	a3 aa a8 aa					.word xt_asm_lda_h, z_asm_lda_h
>cd4e	6c 64 61 2e 23					.text "lda.#"
.cd53					nt_asm_lda_x:
>cd53	05 04						.byte 5, IM
>cd55	60 cd				                .word nt_asm_lda_y
>cd57	a8 aa ad aa					.word xt_asm_lda_x, z_asm_lda_x
>cd5b	6c 64 61 2e 78					.text "lda.x"
.cd60					nt_asm_lda_y:
>cd60	05 04						.byte 5, IM
>cd62	6d cd				                .word nt_asm_lda_z
>cd64	ad aa b2 aa					.word xt_asm_lda_y, z_asm_lda_y
>cd68	6c 64 61 2e 79					.text "lda.y"
.cd6d					nt_asm_lda_z:
>cd6d	05 04						.byte 5, IM
>cd6f	7a cd				                .word nt_asm_lda_zi
>cd71	b2 aa b7 aa					.word xt_asm_lda_z, z_asm_lda_z
>cd75	6c 64 61 2e 7a					.text "lda.z"
.cd7a					nt_asm_lda_zi:
>cd7a	06 04						.byte 6, IM
>cd7c	88 cd				                .word nt_asm_lda_ziy
>cd7e	b7 aa bc aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cd82	6c 64 61 2e 7a 69				.text "lda.zi"
.cd88					nt_asm_lda_ziy:
>cd88	07 04						.byte 7, IM
>cd8a	97 cd				                .word nt_asm_lda_zx
>cd8c	bc aa c1 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cd90	6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cd97					nt_asm_lda_zx:
>cd97	06 04						.byte 6, IM
>cd99	a5 cd				                .word nt_asm_lda_zxi
>cd9b	c1 aa c6 aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cd9f	6c 64 61 2e 7a 78				.text "lda.zx"
.cda5					nt_asm_lda_zxi:
>cda5	07 04						.byte 7, IM
>cda7	b4 cd				                .word nt_asm_ldx
>cda9	c6 aa cb aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cdad	6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cdb4					nt_asm_ldx:
>cdb4	03 04						.byte 3, IM
>cdb6	bf cd				                .word nt_asm_ldx_h
>cdb8	cb aa d0 aa					.word xt_asm_ldx, z_asm_ldx
>cdbc	6c 64 78					.text "ldx"
.cdbf					nt_asm_ldx_h:
>cdbf	05 04						.byte 5, IM
>cdc1	cc cd				                .word nt_asm_ldx_y
>cdc3	d0 aa d5 aa					.word xt_asm_ldx_h, z_asm_ldx_h
>cdc7	6c 64 78 2e 23					.text "ldx.#"
.cdcc					nt_asm_ldx_y:
>cdcc	05 04						.byte 5, IM
>cdce	d9 cd				                .word nt_asm_ldx_z
>cdd0	d5 aa da aa					.word xt_asm_ldx_y, z_asm_ldx_y
>cdd4	6c 64 78 2e 79					.text "ldx.y"
.cdd9					nt_asm_ldx_z:
>cdd9	05 04						.byte 5, IM
>cddb	e6 cd				                .word nt_asm_ldx_zy
>cddd	da aa df aa					.word xt_asm_ldx_z, z_asm_ldx_z
>cde1	6c 64 78 2e 7a					.text "ldx.z"
.cde6					nt_asm_ldx_zy:
>cde6	06 04						.byte 6, IM
>cde8	f4 cd				                .word nt_asm_ldy
>cdea	df aa e4 aa					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cdee	6c 64 78 2e 7a 79				.text "ldx.zy"
.cdf4					nt_asm_ldy:
>cdf4	03 04						.byte 3, IM
>cdf6	ff cd				                .word nt_asm_ldy_h
>cdf8	e4 aa e9 aa					.word xt_asm_ldy, z_asm_ldy
>cdfc	6c 64 79					.text "ldy"
.cdff					nt_asm_ldy_h:
>cdff	05 04						.byte 5, IM
>ce01	0c ce				                .word nt_asm_ldy_x
>ce03	e9 aa ee aa					.word xt_asm_ldy_h, z_asm_ldy_h
>ce07	6c 64 79 2e 23					.text "ldy.#"
.ce0c					nt_asm_ldy_x:
>ce0c	05 04						.byte 5, IM
>ce0e	19 ce				                .word nt_asm_ldy_z
>ce10	ee aa f3 aa					.word xt_asm_ldy_x, z_asm_ldy_x
>ce14	6c 64 79 2e 78					.text "ldy.x"
.ce19					nt_asm_ldy_z:
>ce19	05 04						.byte 5, IM
>ce1b	26 ce				                .word nt_asm_ldy_zx
>ce1d	f3 aa f8 aa					.word xt_asm_ldy_z, z_asm_ldy_z
>ce21	6c 64 79 2e 7a					.text "ldy.z"
.ce26					nt_asm_ldy_zx:
>ce26	06 04						.byte 6, IM
>ce28	34 ce				                .word nt_asm_lsr
>ce2a	f8 aa fd aa					.word xt_asm_ldy_zx, z_asm_ldy_zx
>ce2e	6c 64 79 2e 7a 78				.text "ldy.zx"
.ce34					nt_asm_lsr:
>ce34	03 04						.byte 3, IM
>ce36	3f ce				                .word nt_asm_lsr_a
>ce38	fd aa 02 ab					.word xt_asm_lsr, z_asm_lsr
>ce3c	6c 73 72					.text "lsr"
.ce3f					nt_asm_lsr_a:
>ce3f	05 04						.byte 5, IM
>ce41	4c ce				                .word nt_asm_lsr_x
>ce43	02 ab 07 ab					.word xt_asm_lsr_a, z_asm_lsr_a
>ce47	6c 73 72 2e 61					.text "lsr.a"
.ce4c					nt_asm_lsr_x:
>ce4c	05 04						.byte 5, IM
>ce4e	59 ce				                .word nt_asm_lsr_z
>ce50	07 ab 0c ab					.word xt_asm_lsr_x, z_asm_lsr_x
>ce54	6c 73 72 2e 78					.text "lsr.x"
.ce59					nt_asm_lsr_z:
>ce59	05 04						.byte 5, IM
>ce5b	66 ce				                .word nt_asm_lsr_zx
>ce5d	0c ab 11 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>ce61	6c 73 72 2e 7a					.text "lsr.z"
.ce66					nt_asm_lsr_zx:
>ce66	06 04						.byte 6, IM
>ce68	74 ce				                .word nt_asm_nop
>ce6a	11 ab 16 ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>ce6e	6c 73 72 2e 7a 78				.text "lsr.zx"
.ce74					nt_asm_nop:
>ce74	03 04						.byte 3, IM
>ce76	7f ce				                .word nt_asm_ora
>ce78	16 ab 1b ab					.word xt_asm_nop, z_asm_nop
>ce7c	6e 6f 70					.text "nop"
.ce7f					nt_asm_ora:
>ce7f	03 04						.byte 3, IM
>ce81	8a ce				                .word nt_asm_ora_h
>ce83	1b ab 20 ab					.word xt_asm_ora, z_asm_ora
>ce87	6f 72 61					.text "ora"
.ce8a					nt_asm_ora_h:
>ce8a	05 04						.byte 5, IM
>ce8c	97 ce				                .word nt_asm_ora_x
>ce8e	20 ab 25 ab					.word xt_asm_ora_h, z_asm_ora_h
>ce92	6f 72 61 2e 23					.text "ora.#"
.ce97					nt_asm_ora_x:
>ce97	05 04						.byte 5, IM
>ce99	a4 ce				                .word nt_asm_ora_y
>ce9b	25 ab 2a ab					.word xt_asm_ora_x, z_asm_ora_x
>ce9f	6f 72 61 2e 78					.text "ora.x"
.cea4					nt_asm_ora_y:
>cea4	05 04						.byte 5, IM
>cea6	b1 ce				                .word nt_asm_ora_z
>cea8	2a ab 2f ab					.word xt_asm_ora_y, z_asm_ora_y
>ceac	6f 72 61 2e 79					.text "ora.y"
.ceb1					nt_asm_ora_z:
>ceb1	05 04						.byte 5, IM
>ceb3	be ce				                .word nt_asm_ora_zi
>ceb5	2f ab 34 ab					.word xt_asm_ora_z, z_asm_ora_z
>ceb9	6f 72 61 2e 7a					.text "ora.z"
.cebe					nt_asm_ora_zi:
>cebe	06 04						.byte 6, IM
>cec0	cc ce				                .word nt_asm_ora_ziy
>cec2	34 ab 3b ab					.word xt_asm_ora_zi, z_asm_ora_zi
>cec6	6f 72 61 2e 7a 69				.text "ora.zi"
.cecc					nt_asm_ora_ziy:
>cecc	07 04						.byte 7, IM
>cece	db ce				                .word nt_asm_ora_zx
>ced0	3b ab 40 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>ced4	6f 72 61 2e 7a 69 79				.text "ora.ziy"
.cedb					nt_asm_ora_zx:
>cedb	06 04						.byte 6, IM
>cedd	e9 ce				                .word nt_asm_ora_zxi
>cedf	40 ab 45 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>cee3	6f 72 61 2e 7a 78				.text "ora.zx"
.cee9					nt_asm_ora_zxi:
>cee9	07 04						.byte 7, IM
>ceeb	f8 ce				                .word nt_asm_pha
>ceed	45 ab 4a ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>cef1	6f 72 61 2e 7a 78 69				.text "ora.zxi"
.cef8					nt_asm_pha:
>cef8	03 04						.byte 3, IM
>cefa	03 cf				                .word nt_asm_php
>cefc	4a ab 4f ab					.word xt_asm_pha, z_asm_pha
>cf00	70 68 61					.text "pha"
.cf03					nt_asm_php:
>cf03	03 04						.byte 3, IM
>cf05	0e cf				                .word nt_asm_phx
>cf07	4f ab 54 ab					.word xt_asm_php, z_asm_php
>cf0b	70 68 70					.text "php"
.cf0e					nt_asm_phx:
>cf0e	03 04						.byte 3, IM
>cf10	19 cf				                .word nt_asm_phy
>cf12	54 ab 59 ab					.word xt_asm_phx, z_asm_phx
>cf16	70 68 78					.text "phx"
.cf19					nt_asm_phy:
>cf19	03 04						.byte 3, IM
>cf1b	24 cf				                .word nt_asm_pla
>cf1d	59 ab 5e ab					.word xt_asm_phy, z_asm_phy
>cf21	70 68 79					.text "phy"
.cf24					nt_asm_pla:
>cf24	03 04						.byte 3, IM
>cf26	2f cf				                .word nt_asm_plp
>cf28	5e ab 63 ab					.word xt_asm_pla, z_asm_pla
>cf2c	70 6c 61					.text "pla"
.cf2f					nt_asm_plp:
>cf2f	03 04						.byte 3, IM
>cf31	3a cf				                .word nt_asm_plx
>cf33	63 ab 68 ab					.word xt_asm_plp, z_asm_plp
>cf37	70 6c 70					.text "plp"
.cf3a					nt_asm_plx:
>cf3a	03 04						.byte 3, IM
>cf3c	45 cf				                .word nt_asm_ply
>cf3e	68 ab 6d ab					.word xt_asm_plx, z_asm_plx
>cf42	70 6c 78					.text "plx"
.cf45					nt_asm_ply:
>cf45	03 04						.byte 3, IM
>cf47	50 cf				                .word nt_asm_rol
>cf49	6d ab 72 ab					.word xt_asm_ply, z_asm_ply
>cf4d	70 6c 79					.text "ply"
.cf50					nt_asm_rol:
>cf50	03 04						.byte 3, IM
>cf52	5b cf				                .word nt_asm_rol_a
>cf54	72 ab 77 ab					.word xt_asm_rol, z_asm_rol
>cf58	72 6f 6c					.text "rol"
.cf5b					nt_asm_rol_a:
>cf5b	05 04						.byte 5, IM
>cf5d	68 cf				                .word nt_asm_rol_x
>cf5f	77 ab 7c ab					.word xt_asm_rol_a, z_asm_rol_a
>cf63	72 6f 6c 2e 61					.text "rol.a"
.cf68					nt_asm_rol_x:
>cf68	05 04						.byte 5, IM
>cf6a	75 cf				                .word nt_asm_rol_z
>cf6c	7c ab 81 ab					.word xt_asm_rol_x, z_asm_rol_x
>cf70	72 6f 6c 2e 78					.text "rol.x"
.cf75					nt_asm_rol_z:
>cf75	05 04						.byte 5, IM
>cf77	82 cf				                .word nt_asm_rol_zx
>cf79	81 ab 86 ab					.word xt_asm_rol_z, z_asm_rol_z
>cf7d	72 6f 6c 2e 7a					.text "rol.z"
.cf82					nt_asm_rol_zx:
>cf82	06 04						.byte 6, IM
>cf84	90 cf				                .word nt_asm_ror
>cf86	86 ab 8b ab					.word xt_asm_rol_zx, z_asm_rol_zx
>cf8a	72 6f 6c 2e 7a 78				.text "rol.zx"
.cf90					nt_asm_ror:
>cf90	03 04						.byte 3, IM
>cf92	9b cf				                .word nt_asm_ror_a
>cf94	8b ab 90 ab					.word xt_asm_ror, z_asm_ror
>cf98	72 6f 72					.text "ror"
.cf9b					nt_asm_ror_a:
>cf9b	05 04						.byte 5, IM
>cf9d	a8 cf				                .word nt_asm_ror_x
>cf9f	90 ab 95 ab					.word xt_asm_ror_a, z_asm_ror_a
>cfa3	72 6f 72 2e 61					.text "ror.a"
.cfa8					nt_asm_ror_x:
>cfa8	05 04						.byte 5, IM
>cfaa	b5 cf				                .word nt_asm_ror_z
>cfac	95 ab 9a ab					.word xt_asm_ror_x, z_asm_ror_x
>cfb0	72 6f 72 2e 78					.text "ror.x"
.cfb5					nt_asm_ror_z:
>cfb5	05 04						.byte 5, IM
>cfb7	c2 cf				                .word nt_asm_ror_zx
>cfb9	9a ab 9f ab					.word xt_asm_ror_z, z_asm_ror_z
>cfbd	72 6f 72 2e 7a					.text "ror.z"
.cfc2					nt_asm_ror_zx:
>cfc2	06 04						.byte 6, IM
>cfc4	d0 cf				                .word nt_asm_rti
>cfc6	9f ab a4 ab					.word xt_asm_ror_zx, z_asm_ror_zx
>cfca	72 6f 72 2e 7a 78				.text "ror.zx"
.cfd0					nt_asm_rti:
>cfd0	03 04						.byte 3, IM
>cfd2	db cf				                .word nt_asm_rts
>cfd4	a4 ab a9 ab					.word xt_asm_rti, z_asm_rti
>cfd8	72 74 69					.text "rti"
.cfdb					nt_asm_rts:
>cfdb	03 04						.byte 3, IM
>cfdd	e6 cf				                .word nt_asm_sbc
>cfdf	a9 ab ae ab					.word xt_asm_rts, z_asm_rts
>cfe3	72 74 73					.text "rts"
.cfe6					nt_asm_sbc:
>cfe6	03 04						.byte 3, IM
>cfe8	f1 cf				                .word nt_asm_sbc_h
>cfea	ae ab b3 ab					.word xt_asm_sbc, z_asm_sbc
>cfee	73 62 63					.text "sbc"
.cff1					nt_asm_sbc_h:
>cff1	05 04						.byte 5, IM
>cff3	fe cf				                .word nt_asm_sbc_x
>cff5	b3 ab b8 ab					.word xt_asm_sbc_h, z_asm_sbc_h
>cff9	73 62 63 2e 23					.text "sbc.#"
.cffe					nt_asm_sbc_x:
>cffe	05 04						.byte 5, IM
>d000	0b d0				                .word nt_asm_sbc_y
>d002	b8 ab bd ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d006	73 62 63 2e 78					.text "sbc.x"
.d00b					nt_asm_sbc_y:
>d00b	05 04						.byte 5, IM
>d00d	18 d0				                .word nt_asm_sbc_z
>d00f	bd ab c2 ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d013	73 62 63 2e 79					.text "sbc.y"
.d018					nt_asm_sbc_z:
>d018	05 04						.byte 5, IM
>d01a	25 d0				                .word nt_asm_sbc_zi
>d01c	c2 ab c7 ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d020	73 62 63 2e 7a					.text "sbc.z"
.d025					nt_asm_sbc_zi:
>d025	06 04						.byte 6, IM
>d027	33 d0				                .word nt_asm_sbc_ziy
>d029	c7 ab cc ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d02d	73 62 63 2e 7a 69				.text "sbc.zi"
.d033					nt_asm_sbc_ziy:
>d033	07 04						.byte 7, IM
>d035	42 d0				                .word nt_asm_sbc_zx
>d037	cc ab d1 ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d03b	73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d042					nt_asm_sbc_zx:
>d042	06 04						.byte 6, IM
>d044	50 d0				                .word nt_asm_sbc_zxi
>d046	d1 ab d6 ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d04a	73 62 63 2e 7a 78				.text "sbc.zx"
.d050					nt_asm_sbc_zxi:
>d050	07 04						.byte 7, IM
>d052	5f d0				                .word nt_asm_sec
>d054	d6 ab da ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d058	73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d05f					nt_asm_sec:
>d05f	03 04						.byte 3, IM
>d061	6a d0				                .word nt_asm_sed
>d063	da ab de ab					.word xt_asm_sec, z_asm_sec
>d067	73 65 63					.text "sec"
.d06a					nt_asm_sed:
>d06a	03 04						.byte 3, IM
>d06c	75 d0				                .word nt_asm_sei
>d06e	de ab e2 ab					.word xt_asm_sed, z_asm_sed
>d072	73 65 64					.text "sed"
.d075					nt_asm_sei:
>d075	03 04						.byte 3, IM
>d077	80 d0				                .word nt_asm_sta
>d079	e2 ab e6 ab					.word xt_asm_sei, z_asm_sei
>d07d	73 65 69					.text "sei"
.d080					nt_asm_sta:
>d080	03 04						.byte 3, IM
>d082	8b d0				                .word nt_asm_sta_x
>d084	e6 ab ea ab					.word xt_asm_sta, z_asm_sta
>d088	73 74 61					.text "sta"
.d08b					nt_asm_sta_x:
>d08b	05 04						.byte 5, IM
>d08d	98 d0				                .word nt_asm_sta_y
>d08f	ea ab ee ab					.word xt_asm_sta_x, z_asm_sta_x
>d093	73 74 61 2e 78					.text "sta.x"
.d098					nt_asm_sta_y:
>d098	05 04						.byte 5, IM
>d09a	a5 d0				                .word nt_asm_sta_z
>d09c	ee ab f2 ab					.word xt_asm_sta_y, z_asm_sta_y
>d0a0	73 74 61 2e 79					.text "sta.y"
.d0a5					nt_asm_sta_z:
>d0a5	05 04						.byte 5, IM
>d0a7	b2 d0				                .word nt_asm_sta_zi
>d0a9	f2 ab f6 ab					.word xt_asm_sta_z, z_asm_sta_z
>d0ad	73 74 61 2e 7a					.text "sta.z"
.d0b2					nt_asm_sta_zi:
>d0b2	06 04						.byte 6, IM
>d0b4	c0 d0				                .word nt_asm_sta_ziy
>d0b6	f6 ab fa ab					.word xt_asm_sta_zi, z_asm_sta_zi
>d0ba	73 74 61 2e 7a 69				.text "sta.zi"
.d0c0					nt_asm_sta_ziy:
>d0c0	07 04						.byte 7, IM
>d0c2	cf d0				                .word nt_asm_sta_zx
>d0c4	fa ab fe ab					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d0c8	73 74 61 2e 7a 69 79				.text "sta.ziy"
.d0cf					nt_asm_sta_zx:
>d0cf	06 04						.byte 6, IM
>d0d1	dd d0				                .word nt_asm_sta_zxi
>d0d3	fe ab 02 ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d0d7	73 74 61 2e 7a 78				.text "sta.zx"
.d0dd					nt_asm_sta_zxi:
>d0dd	07 04						.byte 7, IM
>d0df	ec d0				                .word nt_asm_stx
>d0e1	02 ac 06 ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d0e5	73 74 61 2e 7a 78 69				.text "sta.zxi"
.d0ec					nt_asm_stx:
>d0ec	03 04						.byte 3, IM
>d0ee	f7 d0				                .word nt_asm_stx_z
>d0f0	06 ac 0a ac					.word xt_asm_stx, z_asm_stx
>d0f4	73 74 78					.text "stx"
.d0f7					nt_asm_stx_z:
>d0f7	05 04						.byte 5, IM
>d0f9	04 d1				                .word nt_asm_stx_zy
>d0fb	0a ac 0e ac					.word xt_asm_stx_z, z_asm_stx_z
>d0ff	73 74 78 2e 7a					.text "stx.z"
.d104					nt_asm_stx_zy:
>d104	06 04						.byte 6, IM
>d106	12 d1				                .word nt_asm_sty
>d108	0e ac 12 ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d10c	73 74 78 2e 7a 79				.text "stx.zy"
.d112					nt_asm_sty:
>d112	03 04						.byte 3, IM
>d114	1d d1				                .word nt_asm_sty_z
>d116	12 ac 16 ac					.word xt_asm_sty, z_asm_sty
>d11a	73 74 79					.text "sty"
.d11d					nt_asm_sty_z:
>d11d	05 04						.byte 5, IM
>d11f	2a d1				                .word nt_asm_sty_zx
>d121	16 ac 1a ac					.word xt_asm_sty_z, z_asm_sty_z
>d125	73 74 79 2e 7a					.text "sty.z"
.d12a					nt_asm_sty_zx:
>d12a	06 04						.byte 6, IM
>d12c	38 d1				                .word nt_asm_stz
>d12e	1a ac 1e ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d132	73 74 79 2e 7a 78				.text "sty.zx"
.d138					nt_asm_stz:
>d138	03 04						.byte 3, IM
>d13a	43 d1				                .word nt_asm_stz_x
>d13c	1e ac 22 ac					.word xt_asm_stz, z_asm_stz
>d140	73 74 7a					.text "stz"
.d143					nt_asm_stz_x:
>d143	05 04						.byte 5, IM
>d145	50 d1				                .word nt_asm_stz_z
>d147	22 ac 26 ac					.word xt_asm_stz_x, z_asm_stz_x
>d14b	73 74 7a 2e 78					.text "stz.x"
.d150					nt_asm_stz_z:
>d150	05 04						.byte 5, IM
>d152	5d d1				                .word nt_asm_stz_zx
>d154	26 ac 2a ac					.word xt_asm_stz_z, z_asm_stz_z
>d158	73 74 7a 2e 7a					.text "stz.z"
.d15d					nt_asm_stz_zx:
>d15d	06 04						.byte 6, IM
>d15f	6b d1				                .word nt_asm_tax
>d161	2a ac 2e ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d165	73 74 7a 2e 7a 78				.text "stz.zx"
.d16b					nt_asm_tax:
>d16b	03 04						.byte 3, IM
>d16d	76 d1				                .word nt_asm_tay
>d16f	2e ac 32 ac					.word xt_asm_tax, z_asm_tax
>d173	74 61 78					.text "tax"
.d176					nt_asm_tay:
>d176	03 04						.byte 3, IM
>d178	81 d1				                .word nt_asm_trb
>d17a	32 ac 36 ac					.word xt_asm_tay, z_asm_tay
>d17e	74 61 79					.text "tay"
.d181					nt_asm_trb:
>d181	03 04						.byte 3, IM
>d183	8c d1				                .word nt_asm_trb_z
>d185	36 ac 3a ac					.word xt_asm_trb, z_asm_trb
>d189	74 72 62					.text "trb"
.d18c					nt_asm_trb_z:
>d18c	05 04						.byte 5, IM
>d18e	99 d1				                .word nt_asm_tsb
>d190	3a ac 3e ac					.word xt_asm_trb_z, z_asm_trb_z
>d194	74 72 62 2e 7a					.text "trb.z"
.d199					nt_asm_tsb:
>d199	03 04						.byte 3, IM
>d19b	a4 d1				                .word nt_asm_tsb_z
>d19d	3e ac 42 ac					.word xt_asm_tsb, z_asm_tsb
>d1a1	74 73 62					.text "tsb"
.d1a4					nt_asm_tsb_z:
>d1a4	05 04						.byte 5, IM
>d1a6	b1 d1				                .word nt_asm_tsx
>d1a8	42 ac 46 ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d1ac	74 73 62 2e 7a					.text "tsb.z"
.d1b1					nt_asm_tsx:
>d1b1	03 04						.byte 3, IM
>d1b3	bc d1				                .word nt_asm_txa
>d1b5	46 ac 4a ac					.word xt_asm_tsx, z_asm_tsx
>d1b9	74 73 78					.text "tsx"
.d1bc					nt_asm_txa:
>d1bc	03 04						.byte 3, IM
>d1be	c7 d1				                .word nt_asm_txs
>d1c0	4a ac 4e ac					.word xt_asm_txa, z_asm_txa
>d1c4	74 78 61					.text "txa"
.d1c7					nt_asm_txs:
>d1c7	03 04						.byte 3, IM
>d1c9	d2 d1				                .word nt_asm_tya
>d1cb	4e ac 52 ac					.word xt_asm_txs, z_asm_txs
>d1cf	74 78 73					.text "txs"
.d1d2					nt_asm_tya:
>d1d2	03 04						.byte 3, IM
>d1d4	dd d1				                .word nt_asm_arrow
>d1d6	52 ac 56 ac					.word xt_asm_tya, z_asm_tya
>d1da	74 79 61					.text "tya"
.d1dd					nt_asm_arrow:
>d1dd	03 04				                .byte 3, IM
>d1df	e8 d1				                .word nt_asm_back_jump
>d1e1	62 91 6c 91			                .word xt_asm_arrow, z_asm_arrow
>d1e5	2d 2d 3e			                .text "-->"
.d1e8					nt_asm_back_jump:
>d1e8	02 04				                .byte 2, IM
>d1ea	f2 d1				                .word nt_asm_back_branch
>d1ec	a7 ac a7 ac			                .word xt_asm_back_jump, z_asm_back_jump
>d1f0	3c 6a				                .text "<j"
.d1f2					nt_asm_back_branch:
>d1f2	02 04				                .byte 2, IM
>d1f4	fc d1				                .word nt_asm_push_a
>d1f6	a8 ac b0 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d1fa	3c 62				                .text "<b"
.d1fc					nt_asm_push_a:
>d1fc	06 04				                .byte 6, IM
>d1fe	00 00				                .word 0000
>d200	90 ac 9f ac			                .word xt_asm_push_a, z_asm_push_a
>d204	70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0					str_ok             =  0
=1					str_compile        =  1
=2					str_redefined      =  2
=3					str_wid_forth      =  3
=4					str_abc_lower      =  4
=5					str_abc_upper      =  5
=6					str_wid_editor     =  6
=7					str_wid_assembler  =  7
=8					str_wid_root       =  8
=9					str_see_flags      =  9
=10					str_see_nt         = 10
=11					str_see_xt         = 11
=12					str_see_size       = 12
.d20a					string_table:
>d20a	24 d2 28 d2 32 d2 98 d2		        .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
>d212	3d d2
>d214	61 d2 90 d2 85 d2 9f d2		        .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
>d21c	a5 d2 c1 d2 c6 d2 cb d2		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
>d224	20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d228	20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d230	64 00
>d232	72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d23a	64 20 00
>d23d	30 31 32 33 34 35 36 37		s_abc_lower:  .text "0123456789abcdefghijklmnopqrstuvwxyz"
>d245	38 39 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e
>d255	6f 70 71 72 73 74 75 76 77 78 79 7a
>d261	30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d269	38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d279	4f 50 51 52 53 54 55 56 57 58 59 5a
>d285	41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d28d	72 20 00
>d290	45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d298	46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d29f	52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d2a5	66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d2ad	4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d2bd	29 3a 20 00
>d2c1	6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d2c6	78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d2cb	73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d2d3	63 69 6d 61 6c 29 3a 20 00
=0					err_allot        = 0
=1					err_badsource    = 1
=2					err_compileonly  = 2
=3					err_defer        = 3
=4					err_divzero      = 4
=5					err_noname       = 5
=6					err_refill       = 6
=7					err_state        = 7
=8					err_syntax       = 8
=9					err_underflow    = 9
=10					err_negallot     = 10
=11					err_wordlist     = 11
=12					err_blockwords   = 12
.d2dc					error_table:
>d2dc	f6 d2 17 d3 37 d3 58 d3		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d2e4	75 d3 86 d3 96 d3 c4 d3		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d2ec	dc d3 eb d3 fb d3 17 d4		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d2f4	2e d4				        .word es_blockwords                                    ; 12
>d2f6	41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d2fe	69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d30e	65 20 6d 65 6d 6f 72 79 00
>d317	49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d31f	53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d32f	20 52 45 46 49 4c 4c 00
>d337	49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d33f	74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d34f	6e 6c 79 20 77 6f 72 64 00
>d358	44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d360	77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d370	20 79 65 74 00
>d375	44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d37d	20 62 79 20 7a 65 72 6f 00
>d386	50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d38e	66 61 69 6c 75 72 65 00
>d396	51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d39e	6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d3ae	20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d3be	64 20 2d 31 29 00
>d3c4	41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d3cc	69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d3dc	55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word", 0
>d3e4	64 20 77 6f 72 64 00
>d3eb	53 74 61 63 6b 20 75 6e		es_underflow:   .text "Stack underflow", 0
>d3f3	64 65 72 66 6c 6f 77 00
>d3fb	4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d403	72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d413	4c 4f 54 00
>d417	4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d41f	69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d42e	50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d436	73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d446	4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d456	61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d466	56 45 43 54 4f 52 00
>d46d	0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d475	44 2d 53 54 52 49 4e 47
>d47d	05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d483	04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d488	11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d490	2d 55 4e 49 54 2d 42 49 54 53
>d49a	07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d4a2	08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d4aa	52
>d4ab	05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d4b1	05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d4b7	12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d4bf	53 54 41 43 4b 2d 43 45 4c 4c 53
>d4ca	0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d4d2	45 4c 4c 53
>d4d6	09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d4de	54 53
>d4e0	05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d4e6	06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d4ed					cmpl_subroutine:
.d4ed	48		pha		                pha             ; save LSB of address
.d4ee	a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d4f0	80 03		bra $d4f5	                bra cmpl_common
.d4f2					cmpl_jump:
.d4f2	48		pha		                pha             ; save LSB of address
.d4f3	a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d4f5					cmpl_common:
.d4f5	20 fd d4	jsr $d4fd	                jsr cmpl_a      ; compile opcode
.d4f8	68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d4f9					cmpl_word:
.d4f9	20 fd d4	jsr $d4fd	                jsr cmpl_a      ; compile LSB of address
.d4fc	98		tya		                tya             ; fall thru for MSB
.d4fd					cmpl_a:
.d4fd	92 00		sta ($00)	                sta (cp)
.d4ff	e6 00		inc $00		                inc cp
.d501	d0 02		bne $d505	                bne _done
.d503	e6 01		inc $01		                inc cp+1
.d505					_done:
.d505	60		rts		                rts
.d506					doconst:
.d506	ca		dex		                dex             ; make room for constant
.d507	ca		dex		                dex
.d508	68		pla		                pla             ; LSB of return address
.d509	85 24		sta $24		                sta tmp1
.d50b	68		pla		                pla             ; MSB of return address
.d50c	85 25		sta $25		                sta tmp1+1
.d50e	a0 01		ldy #$01	                ldy #1
.d510	b1 24		lda ($24),y	                lda (tmp1),y
.d512	95 00		sta $00,x	                sta 0,x
.d514	c8		iny		                iny
.d515	b1 24		lda ($24),y	                lda (tmp1),y
.d517	95 01		sta $01,x	                sta 1,x
.d519	60		rts		                rts
.d51a					dodefer:
.d51a	68		pla		                pla             ; LSB
.d51b	85 24		sta $24		                sta tmp1
.d51d	68		pla		                pla             ; MSB
.d51e	85 25		sta $25		                sta tmp1+1
.d520	a0 01		ldy #$01	                ldy #1
.d522	b1 24		lda ($24),y	                lda (tmp1),y
.d524	85 26		sta $26		                sta tmp2
.d526	c8		iny		                iny
.d527	b1 24		lda ($24),y	                lda (tmp1),y
.d529	85 27		sta $27		                sta tmp2+1
.d52b	6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d52e					defer_error:
.d52e	a9 03		lda #$03	                lda #err_defer
.d530	4c 60 d6	jmp $d660	                jmp error
.d533					dodoes:
.d533	7a		ply		                ply             ; LSB
.d534	68		pla		                pla             ; MSB
.d535	c8		iny		                iny
.d536	d0 01		bne $d539	                bne +
.d538	1a		inc a		                ina
.d539					+
.d539	84 26		sty $26		                sty tmp2
.d53b	85 27		sta $27		                sta tmp2+1
.d53d	ca		dex		                dex
.d53e	ca		dex		                dex
.d53f	7a		ply		                ply
.d540	68		pla		                pla
.d541	c8		iny		                iny
.d542	d0 01		bne $d545	                bne +
.d544	1a		inc a		                ina
.d545					+
.d545	94 00		sty $00,x	                sty 0,x         ; LSB
.d547	95 01		sta $01,x	                sta 1,x         ; MSB
.d549	6c 26 00	jmp ($0026)	                jmp (tmp2)
.d54c					dovar:
.d54c	7a		ply		                ply             ; LSB
.d54d	68		pla		                pla             ; MSB
.d54e	c8		iny		                iny
.d54f	d0 01		bne $d552	                bne +
.d551	1a		inc a		                ina
.d552					+
.d552	ca		dex		                dex
.d553	ca		dex		                dex
.d554	95 01		sta $01,x	                sta 1,x
.d556	98		tya		                tya
.d557	95 00		sta $00,x	                sta 0,x
.d559	60		rts		                rts
.d55a					byte_to_ascii:
.d55a	48		pha		                pha
.d55b	4a		lsr a		                lsr             ; convert high nibble first
.d55c	4a		lsr a		                lsr
.d55d	4a		lsr a		                lsr
.d55e	4a		lsr a		                lsr
.d55f	20 63 d5	jsr $d563	                jsr _nibble_to_ascii
.d562	68		pla		                pla
.d563					_nibble_to_ascii:
.d563	29 0f		and #$0f	                and #$0F
.d565	09 30		ora #$30	                ora #'0'
.d567	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d569	90 02		bcc $d56d	                bcc +
.d56b	69 06		adc #$06	                adc #$06
.d56d	4c e6 8d	jmp $8de6	+               jmp emit_a
.d570	60		rts		                rts
.d571					compare_16bit:
.d571	b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d573	d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d575	f0 0a		beq $d581	                beq _equal
.d577	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d579	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d57b	09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d57d	70 08		bvs $d587	                bvs _overflow
.d57f	80 08		bra $d589	                bra _not_equal
.d581					_equal:
.d581	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d583	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d585	50 04		bvc $d58b	                bvc _done
.d587					_overflow:
.d587	49 80		eor #$80	                eor #$80                ; complement negative flag
.d589					_not_equal:
.d589	09 01		ora #$01	                ora #1                  ; if overflow, we can't be eqal
.d58b					_done:
.d58b	60		rts		                rts
.d58c					current_to_dp:
.d58c	a0 04		ldy #$04	                ldy #current_offset
.d58e	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d590	0a		asl a		                asl             ; turn it into an offset (in cells)
.d591	18		clc		                clc
.d592	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d594	a8		tay		                tay
.d595	b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d597	85 02		sta $02		                sta dp
.d599	c8		iny		                iny
.d59a	b1 1e		lda ($1e),y	                lda (up),y
.d59c	85 03		sta $03		                sta dp+1
.d59e	60		rts		                rts
.d59f					dp_to_current:
.d59f	a0 04		ldy #$04	                ldy #current_offset
.d5a1	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d5a3	0a		asl a		                asl             ; turn it into an offset (in cells)
.d5a4	18		clc		                clc
.d5a5	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d5a7	a8		tay		                tay
.d5a8	a5 02		lda $02		                lda dp
.d5aa	91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d5ac	c8		iny		                iny
.d5ad	a5 03		lda $03		                lda dp+1
.d5af	91 1e		sta ($1e),y	                sta (up),y
.d5b1	60		rts		                rts
.d5b2					interpret:
.d5b2					_loop:
.d5b2	20 c0 98	jsr $98c0	                jsr xt_parse_name       ; ( "string" -- addr u )
.d5b5	b5 00		lda $00,x	                lda 0,x
.d5b7	15 01		ora $01,x	                ora 1,x
.d5b9	f0 70		beq $d62b	                beq _line_done
.d5bb	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d5be	20 cb 8f	jsr $8fcb	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d5c1	b5 00		lda $00,x	                lda 0,x
.d5c3	15 01		ora $01,x	                ora 1,x
.d5c5	d0 28		bne $d5ef	                bne _got_name_token
.d5c7	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d5c8	e8		inx		                inx
.d5c9	20 7a 96	jsr $967a	                jsr xt_number           ; ( addr u -- u|d )
.d5cc	a5 16		lda $16		                lda state
.d5ce	f0 e2		beq $d5b2	                beq _loop
.d5d0	a9 20		lda #$20	                lda #$20
.d5d2	24 20		bit $20		                bit status
.d5d4	f0 0d		beq $d5e3	                beq _single_number
.d5d6	20 89 a1	jsr $a189	                jsr xt_swap
.d5d9	a0 93		ldy #$93	                ldy #>literal_runtime
.d5db	a9 88		lda #$88	                lda #<literal_runtime
.d5dd	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.d5e0	20 5e 87	jsr $875e	                jsr xt_comma
.d5e3					_single_number:
.d5e3	a0 93		ldy #$93	                ldy #>literal_runtime
.d5e5	a9 88		lda #$88	                lda #<literal_runtime
.d5e7	20 ed d4	jsr $d4ed	                jsr cmpl_subroutine
.d5ea	20 5e 87	jsr $875e	                jsr xt_comma
.d5ed	80 c3		bra $d5b2	                bra _loop
.d5ef					_got_name_token:
.d5ef	b5 00		lda $00,x	                lda 0,x
.d5f1	95 04		sta $04,x	                sta 4,x
.d5f3	b5 01		lda $01,x	                lda 1,x
.d5f5	95 05		sta $05,x	                sta 5,x
.d5f7	e8		inx		                inx
.d5f8	e8		inx		                inx
.d5f9	e8		inx		                inx
.d5fa	e8		inx		                inx                     ; ( nt )
.d5fb	b5 00		lda $00,x	                lda 0,x
.d5fd	85 22		sta $22		                sta tmpbranch
.d5ff	b5 01		lda $01,x	                lda 1,x
.d601	85 23		sta $23		                sta tmpbranch+1
.d603	20 d1 95	jsr $95d1	                jsr xt_name_to_int      ; ( nt - xt )
.d606	a5 16		lda $16		                lda state
.d608	d0 13		bne $d61d	                bne _compile
.d60a	a0 01		ldy #$01	                ldy #1
.d60c	b1 22		lda ($22),y	                lda (tmpbranch),y
.d60e	29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d610	f0 05		beq $d617	                beq _interpret
.d612	a9 02		lda #$02	                lda #err_compileonly
.d614	4c 60 d6	jmp $d660	                jmp error
.d617					_interpret:
.d617	20 2d 8f	jsr $8f2d	                jsr xt_execute
.d61a	4c b2 d5	jmp $d5b2	                jmp _loop
.d61d					_compile:
.d61d	a0 01		ldy #$01	                ldy #1
.d61f	b1 22		lda ($22),y	                lda (tmpbranch),y
.d621	29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d623	d0 f2		bne $d617	                bne _interpret          ; IMMEDIATE word, execute right now
.d625	20 dd 87	jsr $87dd	                jsr xt_compile_comma
.d628	4c b2 d5	jmp $d5b2	                jmp _loop
.d62b					_line_done:
.d62b	e8		inx		                inx
.d62c	e8		inx		                inx
.d62d	e8		inx		                inx
.d62e	e8		inx		                inx
.d62f	60		rts		                rts
.d630					is_printable:
.d630	c9 20		cmp #$20	                cmp #AscSP              ; $20
.d632	90 08		bcc $d63c	                bcc _done
.d634	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d636	b0 03		bcs $d63b	                bcs _failed
.d638	38		sec		                sec
.d639	80 01		bra $d63c	                bra _done
.d63b					_failed:
.d63b	18		clc		                clc
.d63c					_done:
.d63c	60		rts		                rts
.d63d					is_whitespace:
.d63d	c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d63f	90 08		bcc $d649	                bcc _done
.d641	c9 21		cmp #$21	                cmp #AscSP+1
.d643	b0 03		bcs $d648	                bcs _failed
.d645	38		sec		                sec
.d646	80 01		bra $d649	                bra _done
.d648					_failed:
.d648	18		clc		                clc
.d649					_done:
.d649	60		rts		                rts
.d64a					underflow_1:
.d64a	e0 77		cpx #$77	                cpx #dsp0-1
.d64c	10 10		bpl $d65e	                bpl underflow_error
.d64e	60		rts		                rts
.d64f					underflow_2:
.d64f	e0 75		cpx #$75	                cpx #dsp0-3
.d651	10 0b		bpl $d65e	                bpl underflow_error
.d653	60		rts		                rts
.d654					underflow_3:
.d654	e0 73		cpx #$73	                cpx #dsp0-5
.d656	10 06		bpl $d65e	                bpl underflow_error
.d658	60		rts		                rts
.d659					underflow_4:
.d659	e0 71		cpx #$71	                cpx #dsp0-7
.d65b	10 01		bpl $d65e	                bpl underflow_error
.d65d	60		rts		                rts
.d65e					underflow_error:
.d65e	a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d660					error:
.d660	0a		asl a		                asl
.d661	a8		tay		                tay
.d662	b9 dc d2	lda $d2dc,y	                lda error_table,y
.d665	85 28		sta $28		                sta tmp3                ; LSB
.d667	c8		iny		                iny
.d668	b9 dc d2	lda $d2dc,y	                lda error_table,y
.d66b	85 29		sta $29		                sta tmp3+1              ; MSB
.d66d	20 83 d6	jsr $d683	                jsr print_common
.d670	20 53 89	jsr $8953	                jsr xt_cr
.d673	4c 81 80	jmp $8081	                jmp xt_abort            ; no jsr, as we clobber return stack
.d676					print_string_no_lf:
.d676	0a		asl a		                asl
.d677	a8		tay		                tay
.d678	b9 0a d2	lda $d20a,y	                lda string_table,y
.d67b	85 28		sta $28		                sta tmp3                ; LSB
.d67d	c8		iny		                iny
.d67e	b9 0a d2	lda $d20a,y	                lda string_table,y
.d681	85 29		sta $29		                sta tmp3+1              ; MSB
.d683					print_common:
.d683	a0 00		ldy #$00	                ldy #0
.d685					_loop:
.d685	b1 28		lda ($28),y	                lda (tmp3),y
.d687	f0 06		beq $d68f	                beq _done               ; strings are zero-terminated
.d689	20 e6 8d	jsr $8de6	                jsr emit_a              ; allows vectoring via output
.d68c	c8		iny		                iny
.d68d	80 f6		bra $d685	                bra _loop
.d68f					_done:
.d68f	60		rts		                rts
.d690					print_string:
.d690	20 76 d6	jsr $d676	                jsr print_string_no_lf
.d693	4c 53 89	jmp $8953	                jmp xt_cr               ; JSR/RTS because never compiled
.d696					print_u:
.d696	20 82 a7	jsr $a782	                jsr xt_zero                     ; 0
.d699	20 4a 93	jsr $934a	                jsr xt_less_number_sign         ; <#
.d69c	20 bf 97	jsr $97bf	                jsr xt_number_sign_s            ; #S
.d69f	20 9d 97	jsr $979d	                jsr xt_number_sign_greater      ; #>
.d6a2	4c de a4	jmp $a4de	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp forth
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (18. Feb 2018)", AscLF, 0
>f034	74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044	6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054	28 31 38 2e 20 46 65 62 20 32 30 31 38 29 0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
