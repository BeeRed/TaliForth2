
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Tue Mar 26 20:19:36 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000					ram_start = $0000          ; start of installed 32 KiB of RAM
=32767					ram_end   = $8000-1        ; end of installed RAM
=$0000					zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f					zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100					stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744					hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000					user0     = zpage            ; TaliForth2 system variables
=$ff					rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff					bsize     = $ff              ; size of input/output buffers
=512					buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768					cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744					cp_end    = hist_buff        ; Last RAM byte available for code
=$ff					padoffset = $ff              ; offset from CP to PAD (holds number strings)
=					TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]					TALI_OPTION_CR_EOL := [ "lf" ]
=1					TALI_OPTION_HISTORY := 1
=0					TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000					code0:

;******  Processing file: platform/../definitions.asm

=0					cp        = user0+0   ; Compiler Pointer
=2					dp        = user0+2   ; Dictionary Pointer
=4					workword  = user0+4   ; nt (not xt!) of word being compiled, except in
=6					insrc     = user0+6   ; input Source for SOURCE-ID
=8					cib       = user0+8   ; address of current input buffer
=10					ciblen    = user0+10  ; length of current input buffer
=12					toin      = user0+12  ; pointer to CIB (>IN in Forth)
=14					ip        = user0+14  ; Instruction Pointer (current xt)
=16					output    = user0+16  ; vector for EMIT
=18					input     = user0+18  ; vector for KEY
=20					havekey   = user0+20  ; vector for KEY?
=22					state     = user0+22  ; STATE: -1 compile, 0 interpret
=24					base      = user0+24  ; number radix, default decimal
=26					nc_limit  = user0+26  ; limit for Native Compile size
=28					uf_strip  = user0+28  ; flag to strip underflow detection code
=30					up        = user0+30  ; User Pointer (Address of user variables)
=32					status    = user0+32  ; internal status information
=34					tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
=36					tmp1      = user0+36  ; temporary storage
=38					tmp2      = user0+38  ; temporary storage
=40					tmp3      = user0+40  ; temporary storage (especially for print)
=42					tmpdsp    = user0+42  ; temporary DSP (X) storage (two bytes)
=44					tmptos    = user0+44  ; temporary TOS storage
=46					editor1   = user0+46  ; temporary for editors
=48					editor2   = user0+48  ; temporary for editors
=50					editor3   = user0+50  ; temporary for editors
=52					tohold    = user0+52  ; pointer for formatted output
=54					scratch   = user0+54  ; 8 byte scratchpad (see UM/MOD)
=120					dsp0      = zpage_end-7    ; initial Data Stack Pointer
=0					blk_offset = 0        ; BLK : UP + 0
=2					scr_offset = 2        ; SCR : UP + 2
=4					current_offset = 4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
=5					num_wordlists_offset = 5
=6					wordlists_offset = 6  ; WORDLISTS (cells) : UP + 6 to UP + 29
=30					num_order_offset = 30 ; #ORDER (byte) : UP + 30
=31					search_order_offset = 31
=12					max_wordlists = 12    ; Maximum number of wordlists supported
=40					blkbuffer_offset    = 40   ; Address of buffer
=42					buffblocknum_offset = 42   ; Block number current in buffer
=44					buffstatus_offset   = 44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
=46					blockread_offset    = 46   ; Vector to block reading routine
=48					blockwrite_offset   = 48   ; Vector to block writing routine
=$03					AscCC   = $03  ; break (CTRL-c)
=$07					AscBELL = $07  ; bell sound
=$08					AscBS   = $08  ; backspace
=$0a					AscLF   = $0a  ; line feed
=$0d					AscCR   = $0d  ; carriage return
=$1b					AscESC  = $1b  ; escape
=$20					AscSP   = $20  ; space
=$7f					AscDEL  = $7f  ; delete (CTRL-h)
=$10					AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e					AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1					CO = 1  ; Compile Only
=2					AN = 2  ; Always Native Compile
=4					IM = 4  ; Immediate Word
=8					NN = 8  ; Never Native Compile
=16					UF = 16 ; Includes Underflow Check (RESERVED)
=32					HC = 32 ; Word has Code Field Area (CFA)
=79					MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm

.8000					forth:

;******  Processing file: platform/../native_words.asm

.8000					xt_cold:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 10		sta $10		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 11		sta $11		                sta output+1
.8009	a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b					_load_zp_loop:
.800b	bd ad 80	lda $80ad,x	                lda cold_zp_table,x
.800e	95 00		sta $00,x	                sta zpage,x
.8010	ca		dex		                dex
.8011	d0 f8		bne $800b	                bne _load_zp_loop
.8013	ad ad 80	lda $80ad	                lda cold_zp_table
.8016	85 00		sta $00		                sta zpage
.8018	a2 ff		ldx #$ff	                ldx #rsp0
.801a	9a		txs		                txs
.801b	a2 78		ldx #$78	                ldx #dsp0
.801d	a0 33		ldy #$33	                ldy #cold_user_table_end-cold_user_table-1
.801f	a9 00		lda #$00	                lda #0
.8021					_load_user_vars_loop:
.8021	b9 cf 80	lda $80cf,y	                lda cold_user_table,y
.8024	91 1e		sta ($1e),y	                sta (up),y
.8026	88		dey		                dey
.8027	d0 f8		bne $8021	                bne _load_user_vars_loop
.8029	ad cf 80	lda $80cf	                lda cold_user_table
.802c	92 1e		sta ($1e)	                sta (up)
.802e	20 80 89	jsr $8980	                jsr xt_cr
.8031	ca		dex		                dex
.8032	ca		dex		                dex
.8033	ca		dex		                dex
.8034	ca		dex		                dex
.8035	a9 85		lda #$85	                lda #<forth_words_start
.8037	95 02		sta $02,x	                sta 2,x
.8039	a9 bb		lda #$bb	                lda #>forth_words_start
.803b	95 03		sta $03,x	                sta 3,x
.803d	a9 d3		lda #$d3	                lda #<(user_words_end-forth_words_start)
.803f	95 00		sta $00,x	                sta 0,x
.8041	a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043	95 01		sta $01,x	                sta 1,x
.8045	20 de 90	jsr $90de	                jsr xt_evaluate
.8048	9c 00 7c	stz $7c00	                stz hist_buff
.804b	9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e	9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051	9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054	9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057	9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a	9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d	9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060					xt_abort:
.8060	a2 78		ldx #$78	                ldx #dsp0
.8062					xt_quit:
.8062	8a		txa		                txa             ; Save the DSP that we just defined
.8063	a2 ff		ldx #$ff	                ldx #rsp0
.8065	9a		txs		                txs
.8066	aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067	64 0e		stz $0e		                stz ip
.8069	64 0f		stz $0f		                stz ip+1
.806b	64 06		stz $06		                stz insrc
.806d	64 07		stz $07		                stz insrc+1
.806f	a9 00		lda #$00	                lda #0
.8071	a0 00		ldy #$00	                ldy #blk_offset
.8073	91 1e		sta ($1e),y	                sta (up),y
.8075	c8		iny		                iny
.8076	91 1e		sta ($1e),y	                sta (up),y
.8078	64 16		stz $16		                stz state
.807a	64 17		stz $17		                stz state+1
.807c					_get_line:
.807c	a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.807e	85 08		sta $08		                sta cib
.8080	a9 02		lda #$02	                lda #>buffer0
.8082	85 09		sta $09		                sta cib+1
.8084	64 0a		stz $0a		                stz ciblen
.8086	64 0b		stz $0b		                stz ciblen+1
.8088	20 02 9b	jsr $9b02	                jsr xt_refill           ; ( -- f )
.808b	b5 00		lda $00,x	                lda 0,x
.808d	d0 05		bne $8094	                bne _success
.808f	a9 06		lda #$06	                lda #err_refill
.8091	4c 5a d8	jmp $d85a	                jmp error
.8094					_success:
.8094	e8		inx		                inx                     ; drop
.8095	e8		inx		                inx
.8096	20 ac d7	jsr $d7ac	                jsr interpret
.8099	e0 78		cpx #$78	                cpx #dsp0
.809b	f0 05		beq $80a2	                beq _stack_ok
.809d	90 03		bcc $80a2	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.809f	4c 58 d8	jmp $d858	                jmp underflow_error
.80a2					_stack_ok:
.80a2	a5 16		lda $16		                lda state
.80a4	f0 02		beq $80a8	                beq _print
.80a6	a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80a8					_print:
.80a8	20 ab d8	jsr $d8ab	                jsr print_string
.80ab	80 cf		bra $807c	                bra _get_line
.80ad					z_cold:
.80ad					z_abort:
.80ad					z_quit:
.80ad					cold_zp_table:
>80ad	00 08				        .word cp0+256+1024      ; cp moved to make room for user vars and
>80af	58 bc				        .word dictionary_start  ; dp
>80b1	00 00				        .word 0                 ; workword
>80b3	00 00				        .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
>80b5	00 02				        .word buffer0           ; cib
>80b7	00 00				        .word 0                 ; ciblen
>80b9	00 00				        .word 0                 ; toin
>80bb	00 00				        .word 0                 ; ip
>80bd	27 f0				        .word kernel_putc       ; output
>80bf	21 f0				        .word kernel_getc       ; input
>80c1	00 00				        .word 0                 ; havekey
>80c3	00 00				        .word 0                 ; state (0 = interpret)
>80c5	0a 00				        .word 10                ; base
>80c7	14 00				        .word 20                ; nc-limit
>80c9	00 00				        .word 0                 ; uf_strip (off by default)
>80cb	00 03				        .word cp0               ; up (user vars put right at beginning of
>80cd	00 00				        .word 0                 ; status
.80cf					cold_zp_table_end:
.80cf					cold_user_table:
>80cf	00 00				        .word 0                         ;  0 BLK
>80d1	00 00				        .word 0                         ;  2 SCR
>80d3	00				        .byte 0                         ;  4 CURRENT = FORTH-WORDLIST
>80d4	04				        .byte 4                         ;  5 #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>80d5	58 bc				        .word dictionary_start          ;  6 FORTH-WORDLIST
>80d7	a0 ca				        .word editor_dictionary_start   ;  8 EDITOR-WORDLIST
>80d9	f0 ca				        .word assembler_dictionary_start ; a ASSEMBLER-WORDLIST
>80db	5f ca				        .word root_dictionary_start     ;  c ROOT-WORDLIST
>80dd	00 00 00 00 00 00 00 00		        .word 0,0,0,0,0,0,0,0           ;  e User wordlists
>80e5	00 00 00 00 00 00 00 00
>80ed	01				        .byte 1                         ; 1e #ORDER
>80ee	00 00 00 00 00 00 00 00		        .byte 0,0,0,0,0,0,0,0,0         ; 1f search-order
>80f6	00
>80f7	00 04				        .word cp0+256                   ; 28 Address of buffer (right after USER vars)
>80f9	00 00				        .word 0                         ; 2a block in buffer
>80fb	00 00				        .word 0                         ; 2c buffer status (not in use)
>80fd	67 85				        .word xt_block_word_error       ; 2e block-read vector
>80ff	67 85				        .word xt_block_word_error       ; 30 block-write vector
>8101	00 00				        .word 0                         ; 32 'COLD
.8103					cold_user_table_end:
.8103					xt_abort_quote:
.8103	20 59 9d	jsr $9d59	                jsr xt_s_quote          ; S"
.8106	a0 81		ldy #$81	                ldy #>abort_quote_runtime
.8108	a9 0e		lda #$0e	                lda #<abort_quote_runtime
.810a	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.810d	60		rts		z_abort_quote:  rts
.810e					abort_quote_runtime:
.810e	b5 04		lda $04,x	                lda 4,x
.8110	15 05		ora $05,x	                ora 5,x
.8112	f0 09		beq $811d	                beq _done       ; if FALSE, we're done
.8114	20 de a4	jsr $a4de	                jsr xt_type
.8117	20 80 89	jsr $8980	                jsr xt_cr
.811a	4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.811d					_done:
.811d	8a		txa		                txa
.811e	18		clc		                clc
.811f	69 06		adc #$06	                adc #6
.8121	aa		tax		                tax
.8122	60		rts		                rts
.8123					xt_abs:
.8123	20 44 d8	jsr $d844	                jsr underflow_1
.8126	b5 01		lda $01,x	                lda 1,x
.8128	10 0d		bpl $8137	                bpl _done       ; positive number, easy money!
.812a	38		sec		                sec
.812b	a9 00		lda #$00	                lda #0
.812d	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.812f	95 00		sta $00,x	                sta 0,x
.8131	a9 00		lda #$00	                lda #0          ; MSB
.8133	f5 01		sbc $01,x	                sbc 1,x
.8135	95 01		sta $01,x	                sta 1,x
.8137					_done:
.8137	60		rts		z_abs:          rts
.8138					xt_accept:
.8138	20 49 d8	jsr $d849	                jsr underflow_2
.813b	b5 00		lda $00,x	                lda 0,x
.813d	15 01		ora $01,x	                ora 1,x
.813f	d0 09		bne $814a	                bne _not_zero
.8141	e8		inx		                inx
.8142	e8		inx		                inx
.8143	74 00		stz $00,x	                stz 0,x
.8145	74 01		stz $01,x	                stz 1,x
.8147	4c 16 82	jmp $8216	                jmp accept_done
.814a					_not_zero:
.814a	b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.814c	85 26		sta $26		                sta tmp2
.814e	64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.8150	b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8152	85 24		sta $24		                sta tmp1
.8154	b5 03		lda $03,x	                lda 3,x
.8156	85 25		sta $25		                sta tmp1+1
.8158	e8		inx		                inx
.8159	e8		inx		                inx
.815a	a0 00		ldy #$00	                ldy #0
.815c	a5 20		lda $20		                lda status
.815e	29 f7		and #$f7	                and #$f7
.8160	1a		inc a		               ina
.8161	09 08		ora #$08	                ora #$08
.8163	85 20		sta $20		                sta status
.8165					accept_loop:
.8165	20 3f 93	jsr $933f	                jsr key_a
.8168	c9 0a		cmp #$0a	                cmp #AscLF
.816a	f0 20		beq $818c	                beq _eol
.816c	c9 0d		cmp #$0d	                cmp #AscCR
.816e	f0 1c		beq $818c	                beq _eol
.8170	c9 08		cmp #$08	                cmp #AscBS
.8172	f0 22		beq $8196	                beq _backspace
.8174	c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8176	f0 1e		beq $8196	                beq _backspace
.8178	c9 10		cmp #$10	                cmp #AscCP
.817a	f0 36		beq $81b2	                beq _ctrl_p
.817c	c9 0e		cmp #$0e	                cmp #AscCN
.817e	f0 44		beq $81c4	                beq _ctrl_n
.8180	91 24		sta ($24),y	                sta (tmp1),y
.8182	c8		iny		                iny
.8183	20 ff 8d	jsr $8dff	                jsr emit_a
.8186	c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.8188	d0 db		bne $8165	                bne accept_loop       ; fall through if buffer limit reached
.818a	80 03		bra $818f	                bra _buffer_full
.818c					_eol:
.818c	20 f9 a0	jsr $a0f9	                jsr xt_space    ; print final space
.818f					_buffer_full:
.818f	94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.8191	74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.8193	4c 16 82	jmp $8216	                jmp accept_done
.8196					_backspace:
.8196	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8198	d0 06		bne $81a0	                bne +
.819a	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.819c	20 ff 8d	jsr $8dff	                jsr emit_a
.819f	c8		iny		                iny
.81a0					+
.81a0	88		dey		                dey
.81a1	a9 08		lda #$08	                lda #AscBS      ; move back one
.81a3	20 ff 8d	jsr $8dff	                jsr emit_a
.81a6	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.81a8	20 ff 8d	jsr $8dff	                jsr emit_a
.81ab	a9 08		lda #$08	                lda #AscBS      ; move back over space
.81ad	20 ff 8d	jsr $8dff	                jsr emit_a
.81b0	80 b3		bra $8165	                bra accept_loop
.81b2					_ctrl_p:
.81b2	a5 20		lda $20		                lda status
.81b4	29 07		and #$07	                and #7
.81b6	d0 08		bne $81c0	                bne _ctrl_p_dec
.81b8	a5 20		lda $20		                lda status
.81ba	09 07		ora #$07	                ora #7
.81bc	85 20		sta $20		                sta status
.81be	80 11		bra $81d1	                bra _recall_history
.81c0					_ctrl_p_dec:
.81c0	c6 20		dec $20		                dec status
.81c2	80 0d		bra $81d1	                bra _recall_history
.81c4					_ctrl_n:
.81c4	a9 08		lda #$08	                lda #$8
.81c6	24 20		bit $20		                bit status
.81c8	d0 07		bne $81d1	                bne _recall_history
.81ca	a5 20		lda $20		                lda status
.81cc	29 f7		and #$f7	                and #$f7
.81ce	1a		inc a		               ina
.81cf	85 20		sta $20		                sta status
.81d1					_recall_history:
.81d1	a9 08		lda #$08	                lda #%00001000
.81d3	14 20		trb $20		                trb status
.81d5	20 31 82	jsr $8231	                jsr accept_total_recall
.81d8	a9 0d		lda #$0d	                lda #AscCR
.81da	20 ff 8d	jsr $8dff	                jsr emit_a
.81dd					input_clear:
.81dd	c0 00		cpy #$00	                cpy #0
.81df	f0 08		beq $81e9	                beq input_cleared
.81e1	a9 20		lda #$20	                lda #AscSP
.81e3	20 ff 8d	jsr $8dff	                jsr emit_a
.81e6	88		dey		                dey
.81e7	80 f4		bra $81dd	                bra input_clear
.81e9					input_cleared:
.81e9	a9 0d		lda #$0d	                lda #AscCR
.81eb	20 ff 8d	jsr $8dff	                jsr emit_a
.81ee	b1 28		lda ($28),y	                lda (tmp3),y
.81f0	85 21		sta $21		                sta status+1
.81f2	e6 28		inc $28		                inc tmp3
.81f4	d0 02		bne $81f8	                bne +           ; Increment the upper byte on carry.
.81f6	e6 29		inc $29		                inc tmp3+1
.81f8					+
.81f8	a9 0d		lda #$0d	                lda #AscCR
.81fa	20 ff 8d	jsr $8dff	                jsr emit_a
.81fd					_history_loop:
.81fd	c4 21		cpy $21		                cpy status+1
.81ff	d0 03		bne $8204	                bne +
.8201	4c 65 81	jmp $8165	                jmp accept_loop       ; Needs a long jump
.8204					+
.8204	c4 26		cpy $26		                cpy tmp2
.8206	f0 0a		beq $8212	                beq _hist_filled_buffer
.8208	b1 28		lda ($28),y	                lda (tmp3),y
.820a	91 24		sta ($24),y	                sta (tmp1),y
.820c	20 ff 8d	jsr $8dff	                jsr emit_a
.820f	c8		iny		                iny
.8210	80 eb		bra $81fd	                bra _history_loop
.8212					_hist_filled_buffer:
.8212	88		dey		                dey
.8213	4c 65 81	jmp $8165	                jmp accept_loop
.8216					accept_done:
.8216	20 31 82	jsr $8231	                jsr accept_total_recall
.8219	85 21		sta $21		                sta status+1
.821b	a0 00		ldy #$00	                ldy #0
.821d	91 28		sta ($28),y	                sta (tmp3),y
.821f	e6 28		inc $28		                inc tmp3
.8221	d0 02		bne $8225	                bne +           ; Increment the upper byte on carry.
.8223	e6 29		inc $29		                inc tmp3+1
.8225					+
.8225					_save_history_loop:
.8225	c4 21		cpy $21		                cpy status+1
.8227	f0 07		beq $8230	                beq _save_history_done
.8229	b1 24		lda ($24),y	                lda (tmp1),y
.822b	91 28		sta ($28),y	                sta (tmp3),y
.822d	c8		iny		                iny
.822e	80 f5		bra $8225	                bra _save_history_loop
.8230					_save_history_done:
.8230					z_accept:
.8230	60		rts		                rts
.8231					accept_total_recall:
.8231	a9 00		lda #$00	                lda #<hist_buff
.8233	85 28		sta $28		                sta tmp3
.8235	a9 7c		lda #$7c	                lda #>hist_buff
.8237	85 29		sta $29		                sta tmp3+1
.8239	a5 20		lda $20		                lda status
.823b	6a		ror a		                ror
.823c	29 03		and #$03	                and #3
.823e	18		clc		                clc
.823f	65 29		adc $29		                adc tmp3+1
.8241	85 29		sta $29		                sta tmp3+1
.8243	a5 20		lda $20		                lda status
.8245	6a		ror a		                ror             ; Rotate through carry into msb.
.8246	6a		ror a		                ror
.8247	29 80		and #$80	                and #$80
.8249	18		clc		                clc
.824a	65 28		adc $28		                adc tmp3
.824c	85 28		sta $28		                sta tmp3
.824e	90 02		bcc $8252	                bcc +           ; Increment the upper byte on carry.
.8250	e6 29		inc $29		                inc tmp3+1
.8252					+
.8252	98		tya		                tya
.8253	c9 80		cmp #$80	                cmp #$80
.8255	90 02		bcc $8259	                bcc +
.8257	a9 7f		lda #$7f	                lda #$7F
.8259					+
.8259	60		rts		                rts
.825a					xt_action_of:
.825a	a5 16		lda $16		                lda state
.825c	05 17		ora $17		                ora state+1
.825e	f0 0c		beq $826c	                beq _interpreting
.8260					_compiling:
.8260	20 aa 85	jsr $85aa	                jsr xt_bracket_tick
.8263	a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.8265	a9 fc		lda #$fc	                lda #<xt_defer_fetch
.8267	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.826a	80 06		bra $8272	                bra _done
.826c					_interpreting:
.826c	20 ec a1	jsr $a1ec	                jsr xt_tick
.826f	20 fc 8a	jsr $8afc	                jsr xt_defer_fetch
.8272					_done:
.8272	60		rts		z_action_of:           rts
.8273					xt_again:
.8273	20 44 d8	jsr $d844	                jsr underflow_1
.8276	a0 00		ldy #$00	                ldy #0
.8278	a9 4c		lda #$4c	                lda #$4C        ; JMP
.827a	91 00		sta ($00),y	                sta (cp),y
.827c	c8		iny		                iny
.827d	b5 00		lda $00,x	                lda 0,x         ; LSB of address
.827f	91 00		sta ($00),y	                sta (cp),y
.8281	c8		iny		                iny
.8282	b5 01		lda $01,x	                lda 1,x         ; MSB of address
.8284	91 00		sta ($00),y	                sta (cp),y
.8286	c8		iny		                iny
.8287	98		tya		                tya
.8288	18		clc		                clc
.8289	65 00		adc $00		                adc cp
.828b	85 00		sta $00		                sta cp
.828d	90 02		bcc $8291	                bcc _done
.828f	e6 01		inc $01		                inc cp+1
.8291					_done:
.8291	e8		inx		                inx
.8292	e8		inx		                inx
.8293	60		rts		z_again:        rts
.8294					xt_align:
.8294					xt_aligned:
.8294					z_align:
.8294	60		rts		z_aligned:      rts             ; stripped out during native compile
.8295					xt_allot:
.8295	20 44 d8	jsr $d844	                jsr underflow_1
.8298	b5 01		lda $01,x	                lda 1,x
.829a	30 22		bmi $82be	                bmi _release
.829c	18		clc		                clc
.829d	a5 00		lda $00		                lda cp
.829f	75 00		adc $00,x	                adc 0,x
.82a1	85 00		sta $00		                sta cp
.82a3	a5 01		lda $01		                lda cp+1
.82a5	75 01		adc $01,x	                adc 1,x
.82a7	85 01		sta $01		                sta cp+1
.82a9	a0 00		ldy #$00	                ldy #<cp_end
.82ab	c4 00		cpy $00		                cpy cp
.82ad	a9 7c		lda #$7c	                lda #>cp_end
.82af	e5 01		sbc $01		                sbc cp+1
.82b1	b0 48		bcs $82fb	                bcs _done               ; we're fine.
.82b3	84 00		sty $00		                sty cp                  ; still #<cp_end
.82b5	a9 7c		lda #$7c	                lda #>cp_end
.82b7	85 01		sta $01		                sta cp+1
.82b9	a9 00		lda #$00	                lda #err_allot
.82bb	4c 5a d8	jmp $d85a	                jmp error
.82be					_release:
.82be	ca		dex		                dex
.82bf	ca		dex		                dex
.82c0	a5 00		lda $00		                lda cp
.82c2	95 00		sta $00,x	                sta 0,x
.82c4	a5 01		lda $01		                lda cp+1
.82c6	95 01		sta $01,x	                sta 1,x
.82c8	20 ed 99	jsr $99ed	                jsr xt_plus                     ; new CP is now TOS
.82cb	ca		dex		                dex
.82cc	ca		dex		                dex                             ; new CP now NOS
.82cd	a9 00		lda #$00	                lda #<cp0
.82cf	95 00		sta $00,x	                sta 0,x
.82d1	a9 03		lda #$03	                lda #>cp0
.82d3	95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.82d5	20 6b d7	jsr $d76b	                jsr compare_16bit               ; still ( CP CP0 )
.82d8	f0 17		beq $82f1	                beq _nega_done
.82da	30 15		bmi $82f1	                bmi _nega_done
.82dc	a9 00		lda #$00	                lda #<cp0
.82de	85 00		sta $00		                sta cp
.82e0	a9 03		lda #$03	                lda #>cp0
.82e2	85 01		sta $01		                sta cp+1
.82e4	a9 58		lda #$58	                lda #<dictionary_start
.82e6	85 02		sta $02		                sta dp
.82e8	a9 bc		lda #$bc	                lda #>dictionary_start
.82ea	85 03		sta $03		                sta dp+1
.82ec	a9 0a		lda #$0a	                lda #err_negallot
.82ee	4c 5a d8	jmp $d85a	                jmp error
.82f1					_nega_done:
.82f1	b5 02		lda $02,x	                lda 2,x
.82f3	85 00		sta $00		                sta cp
.82f5	b5 03		lda $03,x	                lda 3,x
.82f7	85 01		sta $01		                sta cp+1
.82f9	e8		inx		                inx
.82fa	e8		inx		                inx                     ; drop through to _done
.82fb					_done:
.82fb	e8		inx		                inx
.82fc	e8		inx		                inx
.82fd					z_allot:
.82fd	60		rts		                rts
.82fe					xt_allow_native:
.82fe	20 86 d7	jsr $d786	                jsr current_to_dp
.8301	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8303	b1 02		lda ($02),y	                lda (dp),y
.8305	29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.8307	91 02		sta ($02),y	                sta (dp),y
.8309					z_allow_native:
.8309	60		rts		                rts
.830a					xt_also:
.830a	20 3d 91	jsr $913d	                jsr xt_get_order
.830d	20 9d 98	jsr $989d	                jsr xt_over
.8310	20 89 a1	jsr $a189	                jsr xt_swap
.8313	20 27 98	jsr $9827	                jsr xt_one_plus
.8316	20 25 9d	jsr $9d25	                jsr xt_set_order
.8319	60		rts		z_also:         rts
.831a					xt_always_native:
.831a	20 86 d7	jsr $d786	                jsr current_to_dp
.831d	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.831f	b1 02		lda ($02),y	                lda (dp),y
.8321	09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.8323	29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.8325	91 02		sta ($02),y	                sta (dp),y
.8327					z_always_native:
.8327	60		rts		                rts
.8328					xt_and:
.8328	20 49 d8	jsr $d849	                jsr underflow_2
.832b	b5 00		lda $00,x	                lda 0,x
.832d	35 02		and $02,x	                and 2,x
.832f	95 02		sta $02,x	                sta 2,x
.8331	b5 01		lda $01,x	                lda 1,x
.8333	35 03		and $03,x	                and 3,x
.8335	95 03		sta $03,x	                sta 3,x
.8337	e8		inx		                inx
.8338	e8		inx		                inx
.8339	60		rts		z_and:          rts
.833a					xt_at_xy:
.833a	20 49 d8	jsr $d849	                jsr underflow_2
.833d	a5 18		lda $18		                lda base
.833f	48		pha		                pha
.8340	a9 0a		lda #$0a	                lda #10
.8342	85 18		sta $18		                sta base
.8344	a9 1b		lda #$1b	                lda #AscESC
.8346	20 ff 8d	jsr $8dff	                jsr emit_a
.8349	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.834b	20 ff 8d	jsr $8dff	                jsr emit_a
.834e	20 27 98	jsr $9827	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8351	20 b1 d8	jsr $d8b1	                jsr print_u
.8354	a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8356	20 ff 8d	jsr $8dff	                jsr emit_a
.8359	20 27 98	jsr $9827	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.835c	20 b1 d8	jsr $d8b1	                jsr print_u
.835f	a9 48		lda #$48	                lda #'H'
.8361	20 ff 8d	jsr $8dff	                jsr emit_a
.8364	68		pla		                pla
.8365	85 18		sta $18		                sta base
.8367	60		rts		z_at_xy:        rts
.8368					xt_backslash:
.8368	a0 00		ldy #$00	                ldy #blk_offset
.836a	b1 1e		lda ($1e),y	                lda (up),y
.836c	c8		iny		                iny
.836d	11 1e		ora ($1e),y	                ora (up),y
.836f	f0 19		beq $838a	                beq backslash_not_block
.8371	a5 0c		lda $0c		                lda toin
.8373	29 3f		and #$3f	                and #$3F
.8375	f0 1b		beq $8392	                beq z_backslash
.8377	c9 01		cmp #$01	                cmp #$01
.8379	f0 17		beq $8392	                beq z_backslash
.837b	a5 0c		lda $0c		                lda toin
.837d	29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.837f	18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.8380	69 40		adc #$40	                adc #$40
.8382	85 0c		sta $0c		                sta toin
.8384	90 0c		bcc $8392	                bcc z_backslash
.8386	e6 0d		inc $0d		                inc toin+1
.8388	80 08		bra $8392	                bra z_backslash
.838a					backslash_not_block:
.838a	a5 0a		lda $0a		                lda ciblen
.838c	85 0c		sta $0c		                sta toin
.838e	a5 0b		lda $0b		                lda ciblen+1
.8390	85 0d		sta $0d		                sta toin+1
.8392	60		rts		z_backslash:    rts
.8393					xt_base:
.8393	ca		dex		                dex
.8394	ca		dex		                dex
.8395	a9 18		lda #$18	                lda #<base
.8397	95 00		sta $00,x	                sta 0,x         ; LSB
.8399	74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.839b	60		rts		z_base:         rts
.839c					xt_begin:
.839c	20 7b 91	jsr $917b	                jsr xt_here
.839f	60		rts		z_begin:        rts
.83a0					xt_bell:
.83a0	a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.83a2	20 ff 8d	jsr $8dff	                jsr emit_a
.83a5	60		rts		z_bell:         rts
.83a6					xt_bl:
.83a6	ca		dex		                dex
.83a7	ca		dex		                dex
.83a8	a9 20		lda #$20	                lda #AscSP
.83aa	95 00		sta $00,x	                sta 0,x
.83ac	74 01		stz $01,x	                stz 1,x
.83ae	60		rts		z_bl:           rts
.83af					xt_blk:
.83af	ca		dex		                dex
.83b0	ca		dex		                dex
.83b1	18		clc		                clc
.83b2	a5 1e		lda $1e		                lda up
.83b4	69 00		adc #$00	                adc #blk_offset ; Add offset
.83b6	95 00		sta $00,x	                sta 0,x
.83b8	a5 1f		lda $1f		                lda up+1
.83ba	69 00		adc #$00	                adc #0          ; Adding carry
.83bc	95 01		sta $01,x	                sta 1,x
.83be	60		rts		z_blk:          rts
.83bf					xt_blkbuffer:
.83bf	ca		dex		                dex
.83c0	ca		dex		                dex
.83c1	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83c3	b1 1e		lda ($1e),y	                lda (up),y
.83c5	95 00		sta $00,x	                sta 0,x
.83c7	c8		iny		                iny             ; Move along to the next byte
.83c8	b1 1e		lda ($1e),y	                lda (up),y
.83ca	95 01		sta $01,x	                sta 1,x
.83cc	60		rts		z_blkbuffer:    rts
.83cd					xt_block:
.83cd	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83cf	b1 1e		lda ($1e),y	                lda (up),y
.83d1	d5 00		cmp $00,x	                cmp 0,x
.83d3	d0 0f		bne $83e4	                bne _not_in_buffer
.83d5	c8		iny		                iny
.83d6	b1 1e		lda ($1e),y	                lda (up),y
.83d8	d5 01		cmp $01,x	                cmp 1,x
.83da	d0 08		bne $83e4	                bne _not_in_buffer
.83dc	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83de	b1 1e		lda ($1e),y	                lda (up),y
.83e0	29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.83e2	d0 30		bne $8414	                bne _done       ; It's already in the buffer and in use.
.83e4					_not_in_buffer:
.83e4	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83e6	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.83e8	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.83ea	d0 0c		bne $83f8	                bne _buffer_available ; Unused or not dirty = available
.83ec	20 bf 83	jsr $83bf	                jsr xt_blkbuffer
.83ef	20 b1 85	jsr $85b1	                jsr xt_buffblocknum
.83f2	20 89 8f	jsr $8f89	                jsr xt_fetch
.83f5	20 6c 85	jsr $856c	                jsr xt_block_write
.83f8					_buffer_available:
.83f8	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83fa	b5 00		lda $00,x	                lda 0,x
.83fc	91 1e		sta ($1e),y	                sta (up),y
.83fe	c8		iny		                iny
.83ff	b5 01		lda $01,x	                lda 1,x
.8401	91 1e		sta ($1e),y	                sta (up),y
.8403	20 bf 83	jsr $83bf	                jsr xt_blkbuffer
.8406	20 89 a1	jsr $a189	                jsr xt_swap
.8409	20 49 85	jsr $8549	                jsr xt_block_read
.840c	a9 01		lda #$01	                lda #1
.840e	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8410	91 1e		sta ($1e),y	                sta (up),y
.8412	ca		dex		                dex
.8413	ca		dex		                dex
.8414					_done:
.8414	a0 28		ldy #$28	                ldy #blkbuffer_offset
.8416	b1 1e		lda ($1e),y	                lda (up),y
.8418	95 00		sta $00,x	                sta 0,x
.841a	c8		iny		                iny
.841b	b1 1e		lda ($1e),y	                lda (up),y
.841d	95 01		sta $01,x	                sta 1,x
.841f	60		rts		z_block:        rts
.8420					xt_block_ramdrive_init:
.8420	20 44 d8	jsr $d844	                jsr underflow_1
.8423	4c 3e 85	jmp $853e	                jmp _after_ramdrive_code
.8426					_ramdrive_code:
>8426	62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>842e	77 61 70 20 64 65 63 69 6d 61 6c
>8439	20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>8440	20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>8444	20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>844c	20 72 61 6d 64 72 69 76 65
>8455	20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>845d	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>846b	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8473	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8483	73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>8493	20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>849b	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>84aa	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>84b2	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>84c2	31 30 32 34 20 6d 6f 76 65 20 3b
>84cd	20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>84d5	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>84e5	6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>84f5	20 21
>84f7	20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84ff	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>850f	62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>851f	6f 72 20 21
>8523	20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>852b	65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>853b	65 20 21
.853e					_after_ramdrive_code:
.853e	20 84 a0	jsr $a084	                jsr sliteral_runtime
>8541	26 84 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.8545	20 de 90	jsr $90de	                jsr xt_evaluate
.8548					z_block_ramdrive_init:
.8548	60		rts		                rts
.8549					xt_block_read:
.8549	a0 2e		ldy #$2e	                ldy #blockread_offset
.854b	b1 1e		lda ($1e),y	                lda (up),y
.854d	85 24		sta $24		                sta tmp1
.854f	c8		iny		                iny
.8550	b1 1e		lda ($1e),y	                lda (up),y
.8552	85 25		sta $25		                sta tmp1+1
.8554	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8557					z_block_read:
.8557					xt_block_read_vector:
.8557	ca		dex		                dex
.8558	ca		dex		                dex
.8559	18		clc		                clc
.855a	a5 1e		lda $1e		                lda up
.855c	69 2e		adc #$2e	                adc #blockread_offset
.855e	95 00		sta $00,x	                sta 0,x
.8560	a5 1f		lda $1f		                lda up+1
.8562	69 00		adc #$00	                adc #0          ; Add carry
.8564	95 01		sta $01,x	                sta 1,x
.8566					z_block_read_vector:
.8566	60		rts		                rts
.8567					xt_block_word_error:
.8567	a9 0c		lda #$0c	                lda #err_blockwords
.8569	4c 5a d8	jmp $d85a	                jmp error       ; no RTS needed
.856c					z_block_word_error:
.856c					xt_block_write:
.856c	a0 30		ldy #$30	                ldy #blockwrite_offset
.856e	b1 1e		lda ($1e),y	                lda (up),y
.8570	85 24		sta $24		                sta tmp1
.8572	c8		iny		                iny
.8573	b1 1e		lda ($1e),y	                lda (up),y
.8575	85 25		sta $25		                sta tmp1+1
.8577	6c 24 00	jmp ($0024)	                jmp (tmp1)
.857a					z_block_write:
.857a					xt_block_write_vector:
.857a	ca		dex		                dex
.857b	ca		dex		                dex
.857c	18		clc		                clc
.857d	a5 1e		lda $1e		                lda up
.857f	69 30		adc #$30	                adc #blockwrite_offset
.8581	95 00		sta $00,x	                sta 0,x
.8583	a5 1f		lda $1f		                lda up+1
.8585	69 00		adc #$00	                adc #0          ; Add carry
.8587	95 01		sta $01,x	                sta 1,x
.8589					z_block_write_vector:
.8589	60		rts		                rts
.858a					xt_bounds:
.858a	20 49 d8	jsr $d849	                jsr underflow_2
.858d	18		clc		                clc
.858e	b5 00		lda $00,x	                lda 0,x                 ; LSB u
.8590	b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.8592	75 02		adc $02,x	                adc 2,x
.8594	95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.8596	94 00		sty $00,x	                sty 0,x
.8598	b5 01		lda $01,x	                lda 1,x                 ; MSB u
.859a	b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.859c	75 03		adc $03,x	                adc 3,x
.859e	95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.85a0	94 01		sty $01,x	                sty 1,x
.85a2	60		rts		z_bounds:       rts
.85a3					xt_bracket_char:
.85a3	20 3d 86	jsr $863d	                jsr xt_char
.85a6	20 91 93	jsr $9391	                jsr xt_literal
.85a9	60		rts		z_bracket_char: rts
.85aa					xt_bracket_tick:
.85aa	20 ec a1	jsr $a1ec	                jsr xt_tick
.85ad	20 91 93	jsr $9391	                jsr xt_literal
.85b0	60		rts		z_bracket_tick: rts
.85b1					xt_buffblocknum:
.85b1	ca		dex		                dex
.85b2	ca		dex		                dex
.85b3	18		clc		                clc
.85b4	a5 1e		lda $1e		                lda up
.85b6	69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.85b8	95 00		sta $00,x	                sta 0,x
.85ba	a5 1f		lda $1f		                lda up+1
.85bc	69 00		adc #$00	                adc #0                          ; Adding carry
.85be	95 01		sta $01,x	                sta 1,x
.85c0	60		rts		z_buffblocknum: rts
.85c1					xt_buffer:
.85c1	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85c3	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.85c5	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.85c7	d0 0c		bne $85d5	                bne _buffer_available ; Unused or not dirty = available
.85c9	20 bf 83	jsr $83bf	                jsr xt_blkbuffer
.85cc	20 b1 85	jsr $85b1	                jsr xt_buffblocknum
.85cf	20 89 8f	jsr $8f89	                jsr xt_fetch
.85d2	20 6c 85	jsr $856c	                jsr xt_block_write
.85d5					_buffer_available:
.85d5	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.85d7	b5 00		lda $00,x	                lda 0,x
.85d9	91 1e		sta ($1e),y	                sta (up),y
.85db	c8		iny		                iny
.85dc	b5 01		lda $01,x	                lda 1,x
.85de	91 1e		sta ($1e),y	                sta (up),y
.85e0	a9 01		lda #$01	                lda #1
.85e2	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85e4	91 1e		sta ($1e),y	                sta (up),y
.85e6					_done:
.85e6	a0 28		ldy #$28	                ldy #blkbuffer_offset
.85e8	b1 1e		lda ($1e),y	                lda (up),y
.85ea	95 00		sta $00,x	                sta 0,x
.85ec	c8		iny		                iny
.85ed	b1 1e		lda ($1e),y	                lda (up),y
.85ef	95 01		sta $01,x	                sta 1,x
.85f1	60		rts		z_buffer:       rts
.85f2					xt_buffer_colon:
.85f2	20 86 89	jsr $8986	                jsr xt_create
.85f5	20 95 82	jsr $8295	                jsr xt_allot
.85f8	60		rts		z_buffer_colon: rts
.85f9					xt_buffstatus:
.85f9	ca		dex		                dex
.85fa	ca		dex		                dex
.85fb	18		clc		                clc
.85fc	a5 1e		lda $1e		                lda up
.85fe	69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.8600	95 00		sta $00,x	                sta 0,x
.8602	a5 1f		lda $1f		                lda up+1
.8604	69 00		adc #$00	                adc #0                  ; Adding carry
.8606	95 01		sta $01,x	                sta 1,x
.8608	60		rts		z_buffstatus:   rts
.8609					xt_bye:
.8609	4c 2b f0	jmp $f02b	                jmp platform_bye
.860c					z_bye:
.860c					xt_c_comma:
.860c	20 44 d8	jsr $d844	                jsr underflow_1
.860f	b5 00		lda $00,x	                lda 0,x
.8611	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.8614	e8		inx		                inx
.8615	e8		inx		                inx
.8616	60		rts		z_c_comma:      rts
.8617					xt_c_fetch:
.8617	20 44 d8	jsr $d844	                jsr underflow_1
.861a	a1 00		lda ($00,x)	                lda (0,x)
.861c	95 00		sta $00,x	                sta 0,x
.861e	74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8620	60		rts		z_c_fetch:      rts
.8621					xt_c_store:
.8621	20 49 d8	jsr $d849	                jsr underflow_2
.8624	b5 02		lda $02,x	                lda 2,x
.8626	81 00		sta ($00,x)	                sta (0,x)
.8628	e8		inx		                inx
.8629	e8		inx		                inx
.862a	e8		inx		                inx
.862b	e8		inx		                inx
.862c	60		rts		z_c_store:      rts
.862d					xt_cell_plus:
.862d	20 44 d8	jsr $d844	                jsr underflow_1
.8630	f6 00		inc $00,x	                inc 0,x
.8632	d0 02		bne $8636	                bne +
.8634	f6 01		inc $01,x	                inc 1,x
.8636					+
.8636	f6 00		inc $00,x	                inc 0,x
.8638	d0 02		bne $863c	                bne _done
.863a	f6 01		inc $01,x	                inc 1,x
.863c					_done:
.863c	60		rts		z_cell_plus:    rts
.863d					xt_char:
.863d	20 e9 98	jsr $98e9	                jsr xt_parse_name
.8640	b5 00		lda $00,x	                lda 0,x
.8642	15 01		ora $01,x	                ora 1,x
.8644	d0 05		bne $864b	                bne _not_empty
.8646	a9 05		lda #$05	                lda #err_noname
.8648	4c 5a d8	jmp $d85a	                jmp error
.864b					_not_empty:
.864b	e8		inx		                inx             ; drop number of characters, leave addr
.864c	e8		inx		                inx
.864d	a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.864f	95 00		sta $00,x	                sta 0,x
.8651	74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8653	60		rts		z_char:         rts
.8654					xt_chars:
.8654	20 44 d8	jsr $d844	                jsr underflow_1
.8657	60		rts		z_chars:        rts
.8658					xt_cleave:
.8658	20 49 d8	jsr $d849	                jsr underflow_2
.865b	20 6d 95	jsr $956d	                jsr xt_minus_leading    ; -LEADING ( addr u )
.865e	20 69 92	jsr $9269	                jsr xt_input_to_r       ; save old imput state
.8661	b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.8663	85 0a		sta $0a		                sta ciblen
.8665	b5 01		lda $01,x	                lda 1,x
.8667	85 0b		sta $0b		                sta ciblen+1
.8669	b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.866b	85 08		sta $08		                sta cib
.866d	b5 03		lda $03,x	                lda 3,x
.866f	85 09		sta $09		                sta cib+1
.8671	64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.8673	64 0d		stz $0d		                stz toin+1
.8675	20 e9 98	jsr $98e9	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.8678	b5 00		lda $00,x	                lda 0,x
.867a	15 01		ora $01,x	                ora 1,x
.867c	f0 23		beq $86a1	                beq _done
.867e	b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.8680	38		sec		                sec
.8681	f5 00		sbc $00,x	                sbc 0,x
.8683	95 04		sta $04,x	                sta 4,x
.8685	b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.8687	f5 01		sbc $01,x	                sbc 1,x
.8689	95 05		sta $05,x	                sta 5,x
.868b	b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.868d	18		clc		                clc
.868e	75 00		adc $00,x	                adc 0,x
.8690	95 06		sta $06,x	                sta 6,x
.8692	b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.8694	75 01		adc $01,x	                adc 1,x
.8696	95 07		sta $07,x	                sta 7,x
.8698	20 59 a4	jsr $a459	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.869b	20 6d 95	jsr $956d	                jsr xt_minus_leading
.869e	20 59 a4	jsr $a459	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.86a1					_done:
.86a1	20 ad 9a	jsr $9aad	                jsr xt_r_to_input
.86a4	60		rts		z_cleave:       rts
.86a5					xt_cmove:
.86a5	20 4e d8	jsr $d84e	                jsr underflow_3
.86a8	b5 02		lda $02,x	                lda 2,x
.86aa	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86ac	b5 03		lda $03,x	                lda 3,x
.86ae	85 27		sta $27		                sta tmp2+1
.86b0	b5 04		lda $04,x	                lda 4,x
.86b2	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86b4	b5 05		lda $05,x	                lda 5,x
.86b6	85 25		sta $25		                sta tmp1+1
.86b8	a0 00		ldy #$00	                ldy #0
.86ba	b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.86bc	f0 0f		beq $86cd	                beq _dopartial
.86be					_page:
.86be	b1 24		lda ($24),y	                lda (tmp1),y
.86c0	91 26		sta ($26),y	                sta (tmp2),y
.86c2	c8		iny		                iny
.86c3	d0 f9		bne $86be	                bne _page
.86c5	e6 25		inc $25		                inc tmp1+1
.86c7	e6 27		inc $27		                inc tmp2+1
.86c9	d6 01		dec $01,x	                dec 1,x
.86cb	d0 f1		bne $86be	                bne _page
.86cd					_dopartial:
.86cd	b5 00		lda $00,x	                lda 0,x         ; length of last page
.86cf	f0 09		beq $86da	                beq _done
.86d1					_partial:
.86d1	b1 24		lda ($24),y	                lda (tmp1),y
.86d3	91 26		sta ($26),y	                sta (tmp2),y
.86d5	c8		iny		                iny
.86d6	d6 00		dec $00,x	                dec 0,x
.86d8	d0 f7		bne $86d1	                bne _partial
.86da					_done:
.86da	8a		txa		                txa
.86db	18		clc		                clc
.86dc	69 06		adc #$06	                adc #6
.86de	aa		tax		                tax
.86df	60		rts		z_cmove:        rts
.86e0					xt_cmove_up:
.86e0	20 4e d8	jsr $d84e	                jsr underflow_3
.86e3	b5 02		lda $02,x	                lda 2,x
.86e5	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86e7	b5 03		lda $03,x	                lda 3,x
.86e9	18		clc		                clc
.86ea	75 01		adc $01,x	                adc 1,x
.86ec	85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.86ee	b5 04		lda $04,x	                lda 4,x
.86f0	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86f2	b5 05		lda $05,x	                lda 5,x
.86f4	18		clc		                clc
.86f5	75 01		adc $01,x	                adc 1,x
.86f7	85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86f9	f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86fb	b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86fd	f0 0e		beq $870d	                beq _nopartial
.86ff					_outerloop:
.86ff	88		dey		                dey
.8700	f0 07		beq $8709	                beq _finishpage
.8702					_innerloop:
.8702	b1 24		lda ($24),y	                lda (tmp1),y
.8704	91 26		sta ($26),y	                sta (tmp2),y
.8706	88		dey		                dey
.8707	d0 f9		bne $8702	                bne _innerloop
.8709					_finishpage:
.8709	b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.870b	92 26		sta ($26)	                sta (tmp2)
.870d					_nopartial:
.870d	c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.870f	c6 27		dec $27		                dec tmp2+1
.8711	d6 01		dec $01,x	                dec 1,x
.8713	d0 ea		bne $86ff	                bne _outerloop
.8715					_done:
.8715	8a		txa		                txa
.8716	18		clc		                clc
.8717	69 06		adc #$06	                adc #6
.8719	aa		tax		                tax
.871a	60		rts		z_cmove_up:     rts
.871b					xt_colon:
.871b	a5 16		lda $16		                lda state
.871d	05 17		ora $17		                ora state+1
.871f	f0 05		beq $8726	                beq +
.8721	a9 07		lda #$07	                lda #err_state
.8723	4c 5a d8	jmp $d85a	                jmp error
.8726					+
.8726	c6 16		dec $16		                dec state
.8728	c6 17		dec $17		                dec state+1
.872a	a9 40		lda #$40	                lda #%01000000
.872c	04 20		tsb $20		                tsb status
.872e	20 86 d7	jsr $d786	                jsr current_to_dp
.8731	a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8733	48		pha		                pha
.8734	a5 02		lda $02		                lda dp
.8736	48		pha		                pha
.8737	a9 80		lda #$80	                lda #%10000000
.8739	04 20		tsb $20		                tsb status
.873b	20 86 89	jsr $8986	                jsr xt_create
.873e	20 86 d7	jsr $d786	                jsr current_to_dp   ; This might be able to be omitted
.8741	a5 02		lda $02		                lda dp
.8743	85 04		sta $04		                sta workword
.8745	a5 03		lda $03		                lda dp+1
.8747	85 05		sta $05		                sta workword+1
.8749	68		pla		                pla
.874a	85 02		sta $02		                sta dp
.874c	68		pla		                pla
.874d	85 03		sta $03		                sta dp+1
.874f	20 99 d7	jsr $d799	                jsr dp_to_current
.8752	a5 00		lda $00		                lda cp
.8754	38		sec		                sec
.8755	e9 03		sbc #$03	                sbc #3
.8757	85 00		sta $00		                sta cp
.8759	b0 02		bcs $875d	                bcs _done
.875b	c6 01		dec $01		                dec cp+1
.875d					_done:
.875d	60		rts		z_colon:        rts
.875e					xt_colon_noname:
.875e	a5 16		lda $16		                lda state
.8760	05 17		ora $17		                ora state+1
.8762	f0 05		beq $8769	                beq +
.8764	a9 07		lda #$07	                lda #err_state
.8766	4c 5a d8	jmp $d85a	                jmp error
.8769					+
.8769	c6 16		dec $16		                dec state
.876b	c6 17		dec $17		                dec state+1
.876d	a9 40		lda #$40	                lda #%01000000
.876f	14 20		trb $20		                trb status
.8771	a5 00		lda $00		                lda cp
.8773	85 04		sta $04		                sta workword
.8775	a5 01		lda $01		                lda cp+1
.8777	85 05		sta $05		                sta workword+1
.8779					_done:
.8779	60		rts		z_colon_noname:        rts
.877a					xt_comma:
.877a	20 44 d8	jsr $d844	                jsr underflow_1
.877d	b5 00		lda $00,x	                lda 0,x
.877f	92 00		sta ($00)	                sta (cp)
.8781	e6 00		inc $00		                inc cp
.8783	d0 02		bne $8787	                bne +
.8785	e6 01		inc $01		                inc cp+1
.8787					+
.8787	b5 01		lda $01,x	                lda 1,x
.8789	92 00		sta ($00)	                sta (cp)
.878b	e6 00		inc $00		                inc cp
.878d	d0 02		bne $8791	                bne _done
.878f	e6 01		inc $01		                inc cp+1
.8791					_done:
.8791	e8		inx		                inx
.8792	e8		inx		                inx
.8793	60		rts		z_comma:        rts
.8794					xt_compare:
.8794	20 53 d8	jsr $d853	                jsr underflow_4
.8797	b5 02		lda $02,x	                lda 2,x
.8799	85 26		sta $26		                sta tmp2
.879b	b5 03		lda $03,x	                lda 3,x
.879d	85 27		sta $27		                sta tmp2+1
.879f	b5 06		lda $06,x	                lda 6,x
.87a1	85 24		sta $24		                sta tmp1
.87a3	b5 07		lda $07,x	                lda 7,x
.87a5	85 25		sta $25		                sta tmp1+1
.87a7					_compare_loop:
.87a7	b5 04		lda $04,x	                lda 4,x
.87a9	15 05		ora $05,x	                ora 5,x
.87ab	f0 2c		beq $87d9	                beq _str1_done
.87ad	b5 00		lda $00,x	                lda 0,x
.87af	15 01		ora $01,x	                ora 1,x
.87b1	f0 3a		beq $87ed	                beq _greater    ; Str2 empty first
.87b3					_check_letter:
.87b3	b2 24		lda ($24)	                lda (tmp1)
.87b5	d2 26		cmp ($26)	                cmp (tmp2)
.87b7	90 26		bcc $87df	                bcc _less
.87b9	d0 32		bne $87ed	                bne _greater
.87bb					_next_letter:
.87bb	e6 24		inc $24		                inc tmp1
.87bd	d0 02		bne $87c1	                bne +
.87bf	e6 25		inc $25		                inc tmp1+1
.87c1					+
.87c1	e6 26		inc $26		                inc tmp2
.87c3	d0 02		bne $87c7	                bne +
.87c5	e6 27		inc $27		                inc tmp2+1
.87c7					+
.87c7	b5 04		lda $04,x	                lda 4,x
.87c9	d0 02		bne $87cd	                bne +
.87cb	d6 05		dec $05,x	                dec 5,x
.87cd					+
.87cd	d6 04		dec $04,x	                dec 4,x
.87cf	b5 00		lda $00,x	                lda 0,x
.87d1	d0 02		bne $87d5	                bne +
.87d3	d6 01		dec $01,x	                dec 1,x
.87d5					+
.87d5	d6 00		dec $00,x	                dec 0,x
.87d7	80 ce		bra $87a7	                bra _compare_loop
.87d9					_str1_done:
.87d9	b5 00		lda $00,x	                lda 0,x
.87db	15 01		ora $01,x	                ora 1,x
.87dd	f0 08		beq $87e7	                beq _equal      ; Both out of letters
.87df					_less:
.87df	a9 ff		lda #$ff	                lda #$FF
.87e1	95 06		sta $06,x	                sta 6,x
.87e3	95 07		sta $07,x	                sta 7,x
.87e5	80 0c		bra $87f3	                bra _done
.87e7					_equal:
.87e7	74 06		stz $06,x	                stz 6,x
.87e9	74 07		stz $07,x	                stz 7,x
.87eb	80 06		bra $87f3	                bra _done
.87ed					_greater:
.87ed	a9 01		lda #$01	                lda #1
.87ef	95 06		sta $06,x	                sta 6,x
.87f1	74 07		stz $07,x	                stz 7,x
.87f3					_done:
.87f3	8a		txa		                txa
.87f4	18		clc		                clc
.87f5	69 06		adc #$06	                adc #6
.87f7	aa		tax		                tax
.87f8	60		rts		z_compare:      rts
.87f9					xt_compile_comma:
.87f9	20 44 d8	jsr $d844	                jsr underflow_1
.87fc	b5 01		lda $01,x	                lda 1,x                 ; MSB
.87fe	48		pha		                pha
.87ff	b5 00		lda $00,x	                lda 0,x
.8801	48		pha		                pha                     ; LSB
.8802	20 7f 92	jsr $927f	                jsr xt_int_to_name      ; ( xt -- nt )
.8805	b5 00		lda $00,x	                lda 0,x
.8807	15 01		ora $01,x	                ora 1,x
.8809	d0 03		bne $880e	                bne _check_nt
.880b	4c 07 89	jmp $8907	                jmp compile_as_jump
.880e					_check_nt:
.880e	b5 00		lda $00,x	                lda 0,x
.8810	85 2c		sta $2c		                sta tmptos
.8812	b5 01		lda $01,x	                lda 1,x
.8814	85 2d		sta $2d		                sta tmptos+1
.8816	f6 00		inc $00,x	                inc 0,x
.8818	d0 02		bne $881c	                bne +
.881a	f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.881c					+
.881c	a1 00		lda ($00,x)	                lda (0,x)
.881e	85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.8820	29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8822	f0 0d		beq $8831	                beq _compile_check
.8824	a5 2c		lda $2c		                lda tmptos
.8826	95 00		sta $00,x	                sta 0,x
.8828	a5 2d		lda $2d		                lda tmptos+1
.882a	95 01		sta $01,x	                sta 1,x
.882c	20 50 a7	jsr $a750	                jsr xt_wordsize         ; ( nt -- u )
.882f	80 27		bra $8858	                bra _compile_as_code
.8831					_compile_check:
.8831	a5 28		lda $28		                lda tmp3
.8833	29 08		and #$08	                and #NN
.8835	f0 03		beq $883a	                beq _check_size_limit
.8837	4c 07 89	jmp $8907	                jmp compile_as_jump    ; too far for BRA
.883a					_check_size_limit:
.883a	a5 2c		lda $2c		                lda tmptos
.883c	95 00		sta $00,x	                sta 0,x
.883e	a5 2d		lda $2d		                lda tmptos+1
.8840	95 01		sta $01,x	                sta 1,x
.8842	20 50 a7	jsr $a750	                jsr xt_wordsize         ; ( nt -- u )
.8845	b5 01		lda $01,x	                lda 1,x
.8847	c5 1b		cmp $1b		                cmp nc_limit+1
.8849	90 0d		bcc $8858	                bcc _compile_as_code    ; user-defined limit MSB
.884b	d0 08		bne $8855	                bne _jumpto_compile_as_jump
.884d	b5 00		lda $00,x	                lda 0,x
.884f	c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.8851	90 05		bcc $8858	                bcc _compile_as_code    ; Allow native compiling for less
.8853	f0 03		beq $8858	                beq _compile_as_code    ; than or equal to the limit.
.8855					_jumpto_compile_as_jump:
.8855	4c 07 89	jmp $8907	                jmp compile_as_jump    ; too far for BRA
.8858					_compile_as_code:
.8858	ca		dex		                dex
.8859	ca		dex		                dex                     ; ( -- u ? )
.885a	ca		dex		                dex
.885b	ca		dex		                dex                     ; ( -- u ? ? )
.885c	b5 04		lda $04,x	                lda 4,x
.885e	95 00		sta $00,x	                sta 0,x                 ; LSB of u
.8860	b5 05		lda $05,x	                lda 5,x
.8862	95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.8864	68		pla		                pla
.8865	95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8867	68		pla		                pla
.8868	95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.886a	a5 00		lda $00		                lda cp                  ; LSB of cp
.886c	95 02		sta $02,x	                sta 2,x
.886e	a5 01		lda $01		                lda cp+1
.8870	95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.8872	a0 00		ldy #$00	                ldy #0
.8874					_strip_loop:
.8874	b9 f5 88	lda $88f5,y	                lda strip_table,y      ; LSB of first word
.8877	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8879	d0 07		bne $8882	                bne _next_entry
.887b	b9 f6 88	lda $88f6,y	                lda strip_table+1,y
.887e	d5 05		cmp $05,x	                cmp 5,x
.8880	f0 0c		beq $888e	                beq _found_entry
.8882					_next_entry:
.8882	b9 f5 88	lda $88f5,y	                lda strip_table,y      ; pointing to LSB
.8885	19 f6 88	ora $88f6,y	                ora strip_table+1,y    ; get MSB
.8888	f0 22		beq $88ac	                beq _underflow_strip    ; table done, let's get out of here
.888a	c8		iny		                iny
.888b	c8		iny		                iny
.888c	80 e6		bra $8874	                bra _strip_loop
.888e					_found_entry:
.888e	98		tya		                tya
.888f	4a		lsr a		                lsr
.8890	a8		tay		                tay
.8891	b9 01 89	lda $8901,y	                lda strip_size,y
.8894	85 2c		sta $2c		                sta tmptos              ; save a copy
.8896	18		clc		                clc
.8897	75 04		adc $04,x	                adc 4,x
.8899	95 04		sta $04,x	                sta 4,x
.889b	90 02		bcc $889f	                bcc+
.889d	f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.889f					+
.889f	06 2c		asl $2c		                asl tmptos
.88a1	38		sec		                sec
.88a2	b5 00		lda $00,x	                lda 0,x
.88a4	e5 2c		sbc $2c		                sbc tmptos
.88a6	95 00		sta $00,x	                sta 0,x
.88a8	b0 02		bcs $88ac	                bcs +
.88aa	d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.88ac					+
.88ac					_underflow_strip:
.88ac	a5 1c		lda $1c		                lda uf_strip
.88ae	05 1d		ora $1d		                ora uf_strip+1
.88b0	f0 1c		beq $88ce	                beq cmpl_inline
.88b2	a5 28		lda $28		                lda tmp3
.88b4	29 10		and #$10	                and #UF
.88b6	f0 16		beq $88ce	                beq cmpl_inline
.88b8	18		clc		                clc
.88b9	b5 04		lda $04,x	                lda 4,x
.88bb	69 03		adc #$03	                adc #3
.88bd	95 04		sta $04,x	                sta 4,x
.88bf	90 02		bcc $88c3	                bcc +
.88c1	f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.88c3					+
.88c3	38		sec		                sec
.88c4	b5 00		lda $00,x	                lda 0,x
.88c6	e9 03		sbc #$03	                sbc #3
.88c8	95 00		sta $00,x	                sta 0,x
.88ca	b0 02		bcs $88ce	                bcs +
.88cc	d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.88ce					+
.88ce					cmpl_inline:
.88ce	b5 01		lda $01,x	                lda 1,x                 ; MSB
.88d0	48		pha		                pha
.88d1	b5 00		lda $00,x	                lda 0,x                 ; LSB
.88d3	48		pha		                pha
.88d4	20 cc 95	jsr $95cc	                jsr xt_move
.88d7	18		clc		                clc
.88d8	68		pla		                pla                     ; LSB
.88d9	65 00		adc $00		                adc cp
.88db	85 00		sta $00		                sta cp
.88dd	68		pla		                pla                     ; MSB
.88de	65 01		adc $01		                adc cp+1
.88e0	85 01		sta $01		                sta cp+1
.88e2	60		rts		                rts
.88e3					cmpl_inline_y:
.88e3	ca		dex		                dex             ; set up stack as ( src dst n -- )
.88e4	ca		dex		                dex
.88e5	ca		dex		                dex
.88e6	ca		dex		                dex
.88e7	94 00		sty $00,x	                sty 0,x
.88e9	74 01		stz $01,x	                stz 1,x             ; assume < 256 bytes
.88eb	a5 00		lda $00		                lda cp
.88ed	95 02		sta $02,x	                sta 2,x
.88ef	a5 01		lda $01		                lda cp+1
.88f1	95 03		sta $03,x	                sta 3,x
.88f3	80 d9		bra $88ce	                bra cmpl_inline
.88f5					strip_table:
>88f5	9c 9a 87 9a 4b a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88fb	7d a4 03 a4 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.8901					strip_size:
>8901	04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.8907					compile_as_jump:
.8907	a9 20		lda #$20	                lda #$20
.8909	92 00		sta ($00)	                sta (cp)
.890b	a0 01		ldy #$01	                ldy #1
.890d	68		pla		                pla             ; LSB
.890e	91 00		sta ($00),y	                sta (cp),y
.8910	c8		iny		                iny
.8911	68		pla		                pla             ; MSB
.8912	91 00		sta ($00),y	                sta (cp),y
.8914	a9 03		lda #$03	                lda #3
.8916	18		clc		                clc
.8917	65 00		adc $00		                adc cp
.8919	85 00		sta $00		                sta cp
.891b	90 02		bcc $891f	                bcc +
.891d	e6 01		inc $01		                inc cp+1
.891f					+
.891f	e8		inx		                inx             ; drop xt
.8920	e8		inx		                inx
.8921					z_compile_comma:
.8921	60		rts		                rts
.8922					xt_compile_only:
.8922	20 86 d7	jsr $d786	                jsr current_to_dp
.8925	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8927	b1 02		lda ($02),y	                lda (dp),y
.8929	09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.892b	91 02		sta ($02),y	                sta (dp),y
.892d	60		rts		z_compile_only: rts
.892e					xt_value:
.892e					xt_constant:
.892e	20 44 d8	jsr $d844	                jsr underflow_1
.8931	20 86 89	jsr $8986	                jsr xt_create
.8934	38		sec		                sec
.8935	a5 00		lda $00		                lda cp
.8937	e9 02		sbc #$02	                sbc #2
.8939	85 24		sta $24		                sta tmp1
.893b	a5 01		lda $01		                lda cp+1
.893d	e9 00		sbc #$00	                sbc #0
.893f	85 25		sta $25		                sta tmp1+1
.8941	a9 00		lda #$00	                lda #<doconst           ; LSB of DOCONST
.8943	92 24		sta ($24)	                sta (tmp1)
.8945	a0 01		ldy #$01	                ldy #1
.8947	a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.8949	91 24		sta ($24),y	                sta (tmp1),y
.894b	20 7a 87	jsr $877a	                jsr xt_comma            ; drop through to adjust_z
.894e					adjust_z:
.894e	20 42 93	jsr $9342	                jsr xt_latestnt         ; gives us ( -- nt )
.8951	b5 00		lda $00,x	                lda 0,x
.8953	85 24		sta $24		                sta tmp1
.8955	b5 01		lda $01,x	                lda 1,x
.8957	85 25		sta $25		                sta tmp1+1
.8959	a0 06		ldy #$06	                ldy #6
.895b	b1 24		lda ($24),y	                lda (tmp1),y
.895d	18		clc		                clc
.895e	69 02		adc #$02	                adc #2
.8960	91 24		sta ($24),y	                sta (tmp1),y
.8962	c8		iny		                iny
.8963	b1 24		lda ($24),y	                lda (tmp1),y
.8965	69 00		adc #$00	                adc #0                  ; only need carry
.8967	91 24		sta ($24),y	                sta (tmp1),y
.8969	e8		inx		                inx
.896a	e8		inx		                inx
.896b					z_value:
.896b	60		rts		z_constant:     rts
.896c					xt_count:
.896c	20 44 d8	jsr $d844	                jsr underflow_1
.896f	a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.8971	a8		tay		                tay
.8972	f6 00		inc $00,x	                inc 0,x         ; LSB
.8974	d0 02		bne $8978	                bne +
.8976	f6 01		inc $01,x	                inc 1,x         ; MSB
.8978	98		tya		+               tya
.8979	ca		dex		                dex
.897a	ca		dex		                dex
.897b	95 00		sta $00,x	                sta 0,x         ; LSB
.897d	74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.897f	60		rts		z_count:        rts
.8980					xt_cr:
.8980	a9 0a		lda #$0a	                lda #AscLF
.8982	20 ff 8d	jsr $8dff	                jsr emit_a
.8985	60		rts		z_cr:           rts
.8986					xt_create:
.8986	20 e9 98	jsr $98e9	                jsr xt_parse_name       ; ( addr u )
.8989	b5 00		lda $00,x	                lda 0,x
.898b	15 01		ora $01,x	                ora 1,x
.898d	d0 05		bne $8994	                bne _got_name
.898f	a9 05		lda #$05	                lda #err_noname
.8991	4c 5a d8	jmp $d85a	                jmp error
.8994					_got_name:
.8994	74 01		stz $01,x	                stz 1,x
.8996	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( addr u addr u )
.8999	20 e4 8f	jsr $8fe4	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.899c	b5 00		lda $00,x	                lda 0,x
.899e	15 01		ora $01,x	                ora 1,x
.89a0	f0 1e		beq $89c0	                beq _new_name           ; We haven't seen this one before.
.89a2	e8		inx		                inx                     ; Drop flag (nt) from find-name.
.89a3	e8		inx		                inx
.89a4	24 20		bit $20		                bit status
.89a6	10 08		bpl $89b0	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.89a8	a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.89aa	05 20		ora $20		                ora status
.89ac	85 20		sta $20		                sta status
.89ae	80 18		bra $89c8	                bra _process_name
.89b0					_redefined_name:
.89b0	a9 02		lda #$02	                lda #str_redefined
.89b2	20 80 d8	jsr $d880	                jsr print_string_no_lf
.89b5	20 93 a3	jsr $a393	                jsr xt_two_dup           ; ( addr u addr u )
.89b8	20 de a4	jsr $a4de	                jsr xt_type
.89bb	20 f9 a0	jsr $a0f9	                jsr xt_space
.89be	80 08		bra $89c8	                bra _process_name
.89c0					_new_name:
.89c0	e8		inx		                inx                     ; Drop flag (0) from find-name.
.89c1	e8		inx		                inx
.89c2	a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.89c4	25 20		and $20		                and status
.89c6	85 20		sta $20		                sta status
.89c8					_process_name:
.89c8	b5 00		lda $00,x	                lda 0,x
.89ca	85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.89cc	a5 00		lda $00		                lda cp
.89ce	85 24		sta $24		                sta tmp1
.89d0	a5 01		lda $01		                lda cp+1
.89d2	85 25		sta $25		                sta tmp1+1
.89d4	b5 00		lda $00,x	                lda 0,x
.89d6	18		clc		                clc
.89d7	69 08		adc #$08	                adc #8
.89d9	85 28		sta $28		                sta tmp3                ; total header length
.89db	18		clc		                clc
.89dc	69 03		adc #$03	                adc #3
.89de	95 00		sta $00,x	                sta 0,x
.89e0	74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.89e2	20 95 82	jsr $8295	                jsr xt_allot    ; ( addr )
.89e5	20 86 d7	jsr $d786	                jsr current_to_dp
.89e8	a0 00		ldy #$00	                ldy #0
.89ea	a5 26		lda $26		                lda tmp2
.89ec	91 24		sta ($24),y	                sta (tmp1),y
.89ee	a9 08		lda #$08	                lda #NN
.89f0	09 20		ora #$20	                ora #HC
.89f2	c8		iny		                iny
.89f3	91 24		sta ($24),y	                sta (tmp1),y
.89f5	c8		iny		                iny
.89f6	a5 02		lda $02		                lda dp
.89f8	91 24		sta ($24),y	                sta (tmp1),y
.89fa	c8		iny		                iny
.89fb	a5 03		lda $03		                lda dp+1
.89fd	91 24		sta ($24),y	                sta (tmp1),y
.89ff	c8		iny		                iny
.8a00	a5 25		lda $25		                lda tmp1+1
.8a02	85 03		sta $03		                sta dp+1
.8a04	a5 24		lda $24		                lda tmp1
.8a06	85 02		sta $02		                sta dp
.8a08	18		clc		                clc
.8a09	65 28		adc $28		                adc tmp3        ; add total header length
.8a0b	91 24		sta ($24),y	                sta (tmp1),y
.8a0d	48		pha		                pha             ; we need this in the next step
.8a0e	c8		iny		                iny
.8a0f	a5 25		lda $25		                lda tmp1+1
.8a11	69 00		adc #$00	                adc #0          ; only need the carry
.8a13	91 24		sta ($24),y	                sta (tmp1),y
.8a15	c8		iny		                iny
.8a16	68		pla		                pla             ; LSB of "z_" address
.8a17	18		clc		                clc
.8a18	69 03		adc #$03	                adc #3
.8a1a	91 24		sta ($24),y	                sta (tmp1),y
.8a1c	88		dey		                dey             ; get the MSB of xt back
.8a1d	b1 24		lda ($24),y	                lda (tmp1),y
.8a1f	69 00		adc #$00	                adc #0          ; only need the carry
.8a21	c8		iny		                iny
.8a22	c8		iny		                iny
.8a23	91 24		sta ($24),y	                sta (tmp1),y
.8a25	c8		iny		                iny
.8a26	b5 00		lda $00,x	                lda 0,x
.8a28	38		sec		                sec
.8a29	e9 08		sbc #$08	                sbc #8
.8a2b	85 2c		sta $2c		                sta tmptos
.8a2d	b5 01		lda $01,x	                lda 1,x
.8a2f	e9 00		sbc #$00	                sbc #0          ; only need carry
.8a31	85 2d		sta $2d		                sta tmptos+1
.8a33					_name_loop:
.8a33	b1 2c		lda ($2c),y	                lda (tmptos),y
.8a35	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8a37	b0 07		bcs $8a40	                bcs _store_name
.8a39	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8a3b	90 03		bcc $8a40	                bcc _store_name
.8a3d	18		clc		                clc
.8a3e	69 20		adc #$20	                adc #$20
.8a40					_store_name:
.8a40	91 24		sta ($24),y	                sta (tmp1),y
.8a42	c8		iny		                iny
.8a43	c6 26		dec $26		                dec tmp2
.8a45	d0 ec		bne $8a33	                bne _name_loop
.8a47	a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a49	91 24		sta ($24),y	                sta (tmp1),y
.8a4b	c8		iny		                iny
.8a4c	a9 46		lda #$46	                lda #<dovar
.8a4e	91 24		sta ($24),y	                sta (tmp1),y
.8a50	c8		iny		                iny
.8a51	a9 d7		lda #$d7	                lda #>dovar
.8a53	91 24		sta ($24),y	                sta (tmp1),y
.8a55	20 99 d7	jsr $d799	                jsr dp_to_current
.8a58	e8		inx		                inx
.8a59	e8		inx		                inx
.8a5a	60		rts		z_create:       rts
.8a5b					xt_d_minus:
.8a5b	20 53 d8	jsr $d853	                jsr underflow_4 ; two double numbers
.8a5e	38		sec		                sec
.8a5f	b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a61	f5 02		sbc $02,x	                sbc 2,x
.8a63	95 06		sta $06,x	                sta 6,x
.8a65	b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a67	f5 03		sbc $03,x	                sbc 3,x
.8a69	95 07		sta $07,x	                sta 7,x
.8a6b	b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a6d	f5 00		sbc $00,x	                sbc 0,x
.8a6f	95 04		sta $04,x	                sta 4,x
.8a71	b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a73	f5 01		sbc $01,x	                sbc 1,x
.8a75	95 05		sta $05,x	                sta 5,x
.8a77	e8		inx		                inx
.8a78	e8		inx		                inx
.8a79	e8		inx		                inx
.8a7a	e8		inx		                inx
.8a7b	60		rts		z_d_minus:      rts
.8a7c					xt_d_plus:
.8a7c	20 53 d8	jsr $d853	                jsr underflow_4 ; two double numbers
.8a7f	18		clc		                clc
.8a80	b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a82	75 06		adc $06,x	                adc 6,x
.8a84	95 06		sta $06,x	                sta 6,x
.8a86	b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a88	75 07		adc $07,x	                adc 7,x
.8a8a	95 07		sta $07,x	                sta 7,x
.8a8c	b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a8e	75 04		adc $04,x	                adc 4,x
.8a90	95 04		sta $04,x	                sta 4,x
.8a92	b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a94	75 05		adc $05,x	                adc 5,x
.8a96	95 05		sta $05,x	                sta 5,x
.8a98	e8		inx		                inx
.8a99	e8		inx		                inx
.8a9a	e8		inx		                inx
.8a9b	e8		inx		                inx
.8a9c	60		rts		z_d_plus:       rts
.8a9d					xt_d_to_s:
.8a9d	20 49 d8	jsr $d849	                jsr underflow_2
.8aa0	e8		inx		                inx
.8aa1	e8		inx		                inx
.8aa2	60		rts		z_d_to_s:       rts
.8aa3					xt_dabs:
.8aa3	20 49 d8	jsr $d849	                jsr underflow_2 ; double number
.8aa6	b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8aa8	10 17		bpl $8ac1	                bpl _done       ; positive, we get off light
.8aaa	a0 00		ldy #$00	                ldy #0
.8aac	38		sec		                sec
.8aad	98		tya		                tya
.8aae	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8ab0	95 02		sta $02,x	                sta 2,x
.8ab2	98		tya		                tya
.8ab3	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8ab5	95 03		sta $03,x	                sta 3,x
.8ab7	98		tya		                tya
.8ab8	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8aba	95 00		sta $00,x	                sta 0,x
.8abc	98		tya		                tya
.8abd	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8abf	95 01		sta $01,x	                sta 1,x
.8ac1					_done:
.8ac1	60		rts		z_dabs:         rts
.8ac2					xt_decimal:
.8ac2	a9 0a		lda #$0a	                lda #10
.8ac4	85 18		sta $18		                sta base
.8ac6	64 19		stz $19		                stz base+1              ; paranoid
.8ac8	60		rts		z_decimal:      rts
.8ac9					xt_defer:
.8ac9	20 86 89	jsr $8986	                jsr xt_create
.8acc	a5 00		lda $00		                lda cp          ; LSB
.8ace	38		sec		                sec
.8acf	e9 02		sbc #$02	                sbc #2
.8ad1	85 24		sta $24		                sta tmp1
.8ad3	a5 01		lda $01		                lda cp+1        ; MSB
.8ad5	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8ad7	85 25		sta $25		                sta tmp1+1
.8ad9	a0 00		ldy #$00	                ldy #0
.8adb	a9 14		lda #$14	                lda #<dodefer   ; LSB
.8add	91 24		sta ($24),y	                sta (tmp1),y
.8adf	c8		iny		                iny
.8ae0	a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8ae2	91 24		sta ($24),y	                sta (tmp1),y
.8ae4	a9 28		lda #$28	                lda #<defer_error
.8ae6	92 00		sta ($00)	                sta (cp)
.8ae8	e6 00		inc $00		                inc cp
.8aea	d0 02		bne $8aee	                bne +
.8aec	e6 01		inc $01		                inc cp+1
.8aee					+
.8aee	a9 d7		lda #$d7	                lda #>defer_error
.8af0	92 00		sta ($00)	                sta (cp)
.8af2	e6 00		inc $00		                inc cp
.8af4	d0 02		bne $8af8	                bne +
.8af6	e6 01		inc $01		                inc cp+1
.8af8					+
.8af8	20 4e 89	jsr $894e	                jsr adjust_z    ; adjust header to correct length
.8afb	60		rts		z_defer:        rts
.8afc					xt_defer_fetch:
.8afc	20 68 a2	jsr $a268	                jsr xt_to_body
.8aff	20 89 8f	jsr $8f89	                jsr xt_fetch
.8b02	60		rts		z_defer_fetch:  rts
.8b03					xt_defer_store:
.8b03	20 68 a2	jsr $a268	                jsr xt_to_body
.8b06	20 68 a1	jsr $a168	                jsr xt_store
.8b09	60		rts		z_defer_store:  rts
.8b0a					xt_definitions:
.8b0a	a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8b0c	b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8b0e	a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8b10	91 1e		sta ($1e),y	                sta (up),y
.8b12	60		rts		z_definitions:  rts
.8b13					xt_depth:
.8b13	a9 78		lda #$78	                lda #dsp0
.8b15	86 2a		stx $2a		                stx tmpdsp
.8b17	38		sec		                sec
.8b18	e5 2a		sbc $2a		                sbc tmpdsp
.8b1a	4a		lsr a		                lsr
.8b1b	ca		dex		                dex
.8b1c	ca		dex		                dex
.8b1d	95 00		sta $00,x	                sta 0,x
.8b1f	74 01		stz $01,x	                stz 1,x
.8b21	60		rts		z_depth:        rts
.8b22					xt_digit_question:
.8b22	20 44 d8	jsr $d844	                jsr underflow_1
.8b25	ca		dex		                dex
.8b26	ca		dex		                dex
.8b27	74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8b29	74 01		stz $01,x	                stz 1,x
.8b2b	74 03		stz $03,x	                stz 3,x                 ; paranoid
.8b2d	b5 02		lda $02,x	                lda 2,x
.8b2f	c9 30		cmp #$30	                cmp #'0'
.8b31	90 23		bcc $8b56	                bcc _done               ; failure flag already set
.8b33	c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8b35	90 12		bcc $8b49	                bcc _checkbase
.8b37	c9 41		cmp #$41	                cmp #'A'
.8b39	90 1b		bcc $8b56	                bcc _done               ; failure flag is already set
.8b3b	c9 61		cmp #$61	                cmp #'a'
.8b3d	90 07		bcc $8b46	                bcc _case_done          ; not lower case, too low
.8b3f	c9 7b		cmp #$7b	                cmp #'z'+1
.8b41	b0 03		bcs $8b46	                bcs _case_done          ; not lower case, too high
.8b43	18		clc		                clc                     ; just right
.8b44	69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b46					_case_done:
.8b46	38		sec		                sec
.8b47	e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b49					_checkbase:
.8b49	38		sec		                sec
.8b4a	e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b4c	c5 18		cmp $18		                cmp base
.8b4e	b0 06		bcs $8b56	                bcs _done               ; already have false flag
.8b50	95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b52	d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b54	d6 01		dec $01,x	                dec 1,x
.8b56					_done:
.8b56					z_digit_question:
.8b56	60		rts		                rts
.8b57					xt_disasm:
.8b57	20 49 d8	jsr $d849	                jsr underflow_2
.8b5a	20 ae ac	jsr $acae	                jsr disassembler
.8b5d	60		rts		z_disasm:       rts
.8b5e					xt_dnegate:
.8b5e	20 49 d8	jsr $d849	                jsr underflow_2 ; double number
.8b61	a0 00		ldy #$00	     		ldy #0
.8b63	38		sec		                sec
.8b64	98		tya		                tya
.8b65	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b67	95 02		sta $02,x	                sta 2,x
.8b69	98		tya		                tya
.8b6a	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b6c	95 03		sta $03,x	                sta 3,x
.8b6e	98		tya		                tya
.8b6f	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b71	95 00		sta $00,x	                sta 0,x
.8b73	98		tya		                tya
.8b74	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b76	95 01		sta $01,x	                sta 1,x
.8b78	60		rts		z_dnegate:      rts
.8b79					xt_question_do:
.8b79	a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b7b	85 24		sta $24		                sta tmp1
.8b7d	80 02		bra $8b81	                bra do_common           ; skip flag for DO
.8b7f					xt_do:
.8b7f	64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b81					do_common:
.8b81	ca		dex		                dex
.8b82	ca		dex		                dex
.8b83	a5 01		lda $01		                lda cp+1
.8b85	95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b87	a5 00		lda $00		                lda cp
.8b89	95 00		sta $00,x	                sta 0,x                 ; LSB
.8b8b	18		clc		                clc
.8b8c	69 06		adc #$06	                adc #6
.8b8e	85 00		sta $00		                sta cp
.8b90	90 02		bcc $8b94	                bcc +
.8b92	e6 01		inc $01		                inc cp+1
.8b94					+
.8b94	a5 24		lda $24		                lda tmp1
.8b96	f0 0f		beq $8ba7	                beq _compile_do
.8b98	ca		dex		                dex
.8b99	ca		dex		                dex
.8b9a	a9 ea		lda #$ea	                lda #<question_do_runtime
.8b9c	95 00		sta $00,x	                sta 0,x
.8b9e	a9 8b		lda #$8b	                lda #>question_do_runtime
.8ba0	95 01		sta $01,x	                sta 1,x
.8ba2	a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8ba4	20 e3 88	jsr $88e3	                jsr cmpl_inline_y
.8ba7					_compile_do:
.8ba7	a0 8b		ldy #$8b	                ldy #>do_runtime
.8ba9	a9 b9		lda #$b9	                lda #<do_runtime
.8bab	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8bae	ca		dex		                dex
.8baf	ca		dex		                dex
.8bb0	a5 00		lda $00		                lda CP          ; LSB
.8bb2	95 00		sta $00,x	                sta 0,x
.8bb4	a5 01		lda $01		                lda CP+1        ; MSB
.8bb6	95 01		sta $01,x	                sta 1,x
.8bb8					z_question_do:
.8bb8	60		rts		z_do:           rts
.8bb9					do_runtime:
.8bb9	68		pla		                pla
.8bba	85 24		sta $24		                sta tmp1
.8bbc	68		pla		                pla
.8bbd	85 25		sta $25		                sta tmp1+1
.8bbf	38		sec		                sec
.8bc0	a9 00		lda #$00	                lda #0
.8bc2	f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8bc4	95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8bc6	a9 80		lda #$80	                lda #$80
.8bc8	f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8bca	95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8bcc	48		pha		                pha             ; FUFA replaces limit on R stack
.8bcd	b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8bcf	48		pha		                pha
.8bd0	18		clc		                clc
.8bd1	b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8bd3	75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8bd5	95 00		sta $00,x	                sta 0,x
.8bd7	b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8bd9	75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8bdb	48		pha		                pha
.8bdc	b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8bde	48		pha		                pha
.8bdf	e8		inx		                inx
.8be0	e8		inx		                inx
.8be1	e8		inx		                inx
.8be2	e8		inx		                inx
.8be3	a5 25		lda $25		                lda tmp1+1
.8be5	48		pha		                pha
.8be6	a5 24		lda $24		                lda tmp1
.8be8	48		pha		                pha
.8be9	60		rts		                rts
.8bea					question_do_runtime:
.8bea	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8bed	20 d7 8e	jsr $8ed7	                jsr xt_equal            ; ( -- n1 n2 f )
.8bf0	b5 00		lda $00,x	                lda 0,x
.8bf2	15 01		ora $01,x	                ora 1,x
.8bf4	f0 06		beq $8bfc	                beq _do_do
.8bf6	8a		txa		                txa
.8bf7	18		clc		                clc
.8bf8	69 06		adc #$06	                adc #6
.8bfa	aa		tax		                tax
.8bfb	60		rts		                rts
.8bfc					_do_do:
.8bfc	e8		inx		                inx             ; clear flag from EQUAL off stack
.8bfd	e8		inx		                inx             ; no RTS because this is copied into code
.8bfe					question_do_runtime_end:
.8bfe					xt_does:
.8bfe	a0 8c		ldy #$8c	                ldy #>does_runtime
.8c00	a9 0d		lda #$0d	                lda #<does_runtime
.8c02	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8c05	a0 d7		ldy #$d7	                ldy #>dodoes
.8c07	a9 2d		lda #$2d	                lda #<dodoes
.8c09	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8c0c	60		rts		z_does:         rts
.8c0d					does_runtime:
.8c0d	7a		ply		                ply             ; LSB
.8c0e	68		pla		                pla             ; MSB
.8c0f	c8		iny		                iny
.8c10	d0 01		bne $8c13	                bne +
.8c12	1a		inc a		                ina
.8c13					+
.8c13	84 24		sty $24		                sty tmp1
.8c15	85 25		sta $25		                sta tmp1+1
.8c17	20 86 d7	jsr $d786	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8c1a	a5 02		lda $02		                lda dp
.8c1c	18		clc		                clc
.8c1d	69 04		adc #$04	                adc #4
.8c1f	85 26		sta $26		                sta tmp2
.8c21	a5 03		lda $03		                lda dp+1
.8c23	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c25	85 27		sta $27		                sta tmp2+1
.8c27	b2 26		lda ($26)	                lda (tmp2)
.8c29	18		clc		                clc
.8c2a	69 01		adc #$01	                adc #1
.8c2c	85 28		sta $28		                sta tmp3
.8c2e	a0 01		ldy #$01	                ldy #1
.8c30	b1 26		lda ($26),y	                lda (tmp2),y
.8c32	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c34	85 29		sta $29		                sta tmp3+1
.8c36	a5 24		lda $24		                lda tmp1        ; LSB
.8c38	92 28		sta ($28)	                sta (tmp3)
.8c3a	a5 25		lda $25		                lda tmp1+1
.8c3c	91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8c3e	60		rts		                rts
.8c3f					xt_dot:
.8c3f	20 44 d8	jsr $d844	                jsr underflow_1
.8c42	20 b8 8d	jsr $8db8	                jsr xt_dup                      ; ( n n )
.8c45	20 23 81	jsr $8123	                jsr xt_abs                      ; ( n u )
.8c48	20 83 a7	jsr $a783	                jsr xt_zero                     ; ( n u 0 )
.8c4b	20 61 93	jsr $9361	                jsr xt_less_number_sign         ; ( n u 0 )
.8c4e	20 e8 97	jsr $97e8	                jsr xt_number_sign_s            ; ( n ud )
.8c51	20 61 9b	jsr $9b61	                jsr xt_rot                      ; ( ud n )
.8c54	20 c2 9f	jsr $9fc2	                jsr xt_sign                     ; ( ud )
.8c57	20 c6 97	jsr $97c6	                jsr xt_number_sign_greater      ; ( addr u )
.8c5a	20 de a4	jsr $a4de	                jsr xt_type
.8c5d	20 f9 a0	jsr $a0f9	                jsr xt_space
.8c60	60		rts		z_dot:          rts
.8c61					xt_dot_paren:
.8c61	ca		dex		                dex
.8c62	ca		dex		                dex
.8c63	a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c65	95 00		sta $00,x	                sta 0,x
.8c67	74 01		stz $01,x	                stz 1,x
.8c69	20 44 99	jsr $9944	                jsr xt_parse
.8c6c	20 de a4	jsr $a4de	                jsr xt_type
.8c6f	60		rts		z_dot_paren:    rts
.8c70					xt_dot_quote:
.8c70	20 59 9d	jsr $9d59	                jsr xt_s_quote
.8c73	a0 a4		ldy #$a4	                ldy #>xt_type
.8c75	a9 de		lda #$de	                lda #<xt_type
.8c77	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8c7a	60		rts		z_dot_quote:    rts
.8c7b					xt_dot_r:
.8c7b	20 49 d8	jsr $d849	                jsr underflow_2
.8c7e	20 4b a3	jsr $a34b	                jsr xt_to_r
.8c81	20 b8 8d	jsr $8db8	                jsr xt_dup
.8c84	20 23 81	jsr $8123	                jsr xt_abs
.8c87	20 83 a7	jsr $a783	                jsr xt_zero
.8c8a	20 61 93	jsr $9361	                jsr xt_less_number_sign
.8c8d	20 e8 97	jsr $97e8	                jsr xt_number_sign_s
.8c90	20 61 9b	jsr $9b61	                jsr xt_rot
.8c93	20 c2 9f	jsr $9fc2	                jsr xt_sign
.8c96	20 c6 97	jsr $97c6	                jsr xt_number_sign_greater
.8c99	20 9c 9a	jsr $9a9c	                jsr xt_r_from
.8c9c	20 9d 98	jsr $989d	                jsr xt_over
.8c9f	20 5a 95	jsr $955a	                jsr xt_minus
.8ca2	20 ff a0	jsr $a0ff	                jsr xt_spaces
.8ca5	20 de a4	jsr $a4de	                jsr xt_type
.8ca8	60		rts		z_dot_r:        rts
.8ca9					xt_dot_s:
.8ca9	20 13 8b	jsr $8b13	                jsr xt_depth    ; ( -- u )
.8cac	a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8cae	20 ff 8d	jsr $8dff	                jsr emit_a
.8cb1	b5 00		lda $00,x	                lda 0,x
.8cb3	48		pha		                pha
.8cb4	ca		dex		                dex             ; DUP
.8cb5	ca		dex		                dex
.8cb6	95 00		sta $00,x	                sta 0,x
.8cb8	74 01		stz $01,x	                stz 1,x
.8cba	20 b1 d8	jsr $d8b1	                jsr print_u
.8cbd	a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8cbf	20 ff 8d	jsr $8dff	                jsr emit_a
.8cc2	a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8cc4	20 ff 8d	jsr $8dff	                jsr emit_a
.8cc7	e8		inx		                inx
.8cc8	e8		inx		                inx
.8cc9	e0 78		cpx #$78	                cpx #dsp0
.8ccb	f0 1e		beq $8ceb	                beq _done
.8ccd					_have_stack:
.8ccd	7a		ply		                ply
.8cce	a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8cd0	85 28		sta $28		                sta tmp3
.8cd2	64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8cd4					_loop:
.8cd4	ca		dex		                dex
.8cd5	ca		dex		                dex
.8cd6	b2 28		lda ($28)	                lda (tmp3)
.8cd8	95 01		sta $01,x	                sta 1,x
.8cda	c6 28		dec $28		                dec tmp3
.8cdc	b2 28		lda ($28)	                lda (tmp3)
.8cde	95 00		sta $00,x	                sta 0,x
.8ce0	c6 28		dec $28		                dec tmp3
.8ce2	5a		phy		                phy
.8ce3	20 3f 8c	jsr $8c3f	                jsr xt_dot
.8ce6	7a		ply		                ply
.8ce7	88		dey		                dey
.8ce8	d0 ea		bne $8cd4	                bne _loop
.8cea	48		pha		                pha             ; dummy to balance stack
.8ceb					_done:
.8ceb	68		pla		                pla
.8cec	60		rts		z_dot_s:        rts
.8ced					xt_d_dot:
.8ced	20 49 d8	jsr $d849	                jsr underflow_2
.8cf0	20 68 a3	jsr $a368	                jsr xt_tuck
.8cf3	20 a3 8a	jsr $8aa3	                jsr xt_dabs
.8cf6	20 61 93	jsr $9361	                jsr xt_less_number_sign
.8cf9	20 e8 97	jsr $97e8	                jsr xt_number_sign_s
.8cfc	20 61 9b	jsr $9b61	                jsr xt_rot
.8cff	20 c2 9f	jsr $9fc2	                jsr xt_sign
.8d02	20 c6 97	jsr $97c6	                jsr xt_number_sign_greater
.8d05	20 de a4	jsr $a4de	                jsr xt_type
.8d08	20 f9 a0	jsr $a0f9	                jsr xt_space
.8d0b	60		rts		z_d_dot:        rts
.8d0c					xt_d_dot_r:
.8d0c	20 4e d8	jsr $d84e	                jsr underflow_3
.8d0f	20 4b a3	jsr $a34b	                jsr xt_to_r
.8d12	20 68 a3	jsr $a368	                jsr xt_tuck
.8d15	20 a3 8a	jsr $8aa3	                jsr xt_dabs
.8d18	20 61 93	jsr $9361	                jsr xt_less_number_sign
.8d1b	20 e8 97	jsr $97e8	                jsr xt_number_sign_s
.8d1e	20 61 9b	jsr $9b61	                jsr xt_rot
.8d21	20 c2 9f	jsr $9fc2	                jsr xt_sign
.8d24	20 c6 97	jsr $97c6	                jsr xt_number_sign_greater
.8d27	20 9c 9a	jsr $9a9c	                jsr xt_r_from
.8d2a	20 9d 98	jsr $989d	                jsr xt_over
.8d2d	20 5a 95	jsr $955a	                jsr xt_minus
.8d30	20 ff a0	jsr $a0ff	                jsr xt_spaces
.8d33	20 de a4	jsr $a4de	                jsr xt_type
.8d36	60		rts		z_d_dot_r:      rts
.8d37					xt_drop:
.8d37	20 44 d8	jsr $d844	                jsr underflow_1
.8d3a	e8		inx		                inx
.8d3b	e8		inx		                inx
.8d3c	60		rts		z_drop:         rts
.8d3d					xt_dump:
.8d3d	20 49 d8	jsr $d849	                jsr underflow_2
.8d40					_row:
.8d40	a0 10		ldy #$10	                ldy #16
.8d42	64 26		stz $26		                stz tmp2
.8d44	20 80 89	jsr $8980	                jsr xt_cr
.8d47	b5 03		lda $03,x	                lda 3,x
.8d49	20 54 d7	jsr $d754	                jsr byte_to_ascii
.8d4c	b5 02		lda $02,x	                lda 2,x
.8d4e	20 54 d7	jsr $d754	                jsr byte_to_ascii
.8d51	20 f9 a0	jsr $a0f9	                jsr xt_space
.8d54	20 f9 a0	jsr $a0f9	                jsr xt_space
.8d57					_loop:
.8d57	b5 00		lda $00,x	                lda 0,x
.8d59	15 01		ora $01,x	                ora 1,x
.8d5b	f0 39		beq $8d96	                beq _all_printed
.8d5d	a1 02		lda ($02,x)	                lda (2,x)
.8d5f	48		pha		                pha                     ; byte_to_ascii destroys A
.8d60	20 54 d7	jsr $d754	                jsr byte_to_ascii
.8d63	20 f9 a0	jsr $a0f9	                jsr xt_space
.8d66	68		pla		                pla
.8d67	20 2a d8	jsr $d82a	                jsr is_printable
.8d6a	b0 02		bcs $8d6e	                bcs _printable
.8d6c	a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d6e					_printable:
.8d6e	5a		phy		                phy                     ; save counter
.8d6f	a4 26		ldy $26		                ldy tmp2
.8d71	91 00		sta ($00),y	                sta (cp),y
.8d73	e6 26		inc $26		                inc tmp2
.8d75	7a		ply		                ply
.8d76	c0 09		cpy #$09	                cpy #9
.8d78	d0 03		bne $8d7d	                bne _next_char
.8d7a	20 f9 a0	jsr $a0f9	                jsr xt_space
.8d7d					_next_char:
.8d7d	f6 02		inc $02,x	                inc 2,x
.8d7f	d0 02		bne $8d83	                bne _counter
.8d81	f6 03		inc $03,x	                inc 3,x
.8d83					_counter:
.8d83	b5 00		lda $00,x	                lda 0,x
.8d85	d0 02		bne $8d89	                bne +
.8d87	d6 01		dec $01,x	                dec 1,x
.8d89					+
.8d89	d6 00		dec $00,x	                dec 0,x
.8d8b	88		dey		                dey
.8d8c	d0 c9		bne $8d57	                bne _loop               ; next byte
.8d8e	20 f9 a0	jsr $a0f9	                jsr xt_space
.8d91	20 a4 8d	jsr $8da4	                jsr dump_print_ascii
.8d94	80 aa		bra $8d40	                bra _row                ; new row
.8d96					_all_printed:
.8d96	a5 26		lda $26		                lda tmp2
.8d98	f0 06		beq $8da0	                beq _done
.8d9a	20 f9 a0	jsr $a0f9	                jsr xt_space
.8d9d	20 a4 8d	jsr $8da4	                jsr dump_print_ascii
.8da0					_done:
.8da0	20 8b a3	jsr $a38b	                jsr xt_two_drop         ; one byte less than 4x INX
.8da3	60		rts		z_dump:         rts
.8da4					dump_print_ascii:
.8da4	a0 00		ldy #$00	                ldy #0
.8da6					_ascii_loop:
.8da6	b1 00		lda ($00),y	                lda (cp),y
.8da8	20 ff 8d	jsr $8dff	                jsr emit_a
.8dab	c8		iny		                iny
.8dac	c0 08		cpy #$08	                cpy #8
.8dae	d0 03		bne $8db3	                bne +
.8db0	20 f9 a0	jsr $a0f9	                jsr xt_space
.8db3					+
.8db3	c6 26		dec $26		                dec tmp2
.8db5	d0 ef		bne $8da6	                bne _ascii_loop
.8db7	60		rts		                rts
.8db8					xt_dup:
.8db8	20 44 d8	jsr $d844	                jsr underflow_1
.8dbb	ca		dex		                dex
.8dbc	ca		dex		                dex
.8dbd	b5 02		lda $02,x	                lda 2,x         ; LSB
.8dbf	95 00		sta $00,x	                sta 0,x
.8dc1	b5 03		lda $03,x	                lda 3,x         ; MSB
.8dc3	95 01		sta $01,x	                sta 1,x
.8dc5	60		rts		z_dup:          rts
.8dc6					xt_ed:
.8dc6	20 96 b5	jsr $b596	                jsr ed6502      ; kept in separate file
.8dc9	60		rts		z_ed:           rts
.8dca					xt_else:
.8dca					xt_endof:
.8dca	a0 8d		ldy #$8d	                ldy #>branch_runtime
.8dcc	a9 e4		lda #$e4	                lda #<branch_runtime
.8dce	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8dd1	20 7b 91	jsr $917b	                jsr xt_here
.8dd4	20 83 a7	jsr $a783	                jsr xt_zero
.8dd7	20 7a 87	jsr $877a	                jsr xt_comma
.8dda	20 7b 91	jsr $917b	                jsr xt_here
.8ddd	20 61 9b	jsr $9b61	                jsr xt_rot
.8de0	20 68 a1	jsr $a168	                jsr xt_store
.8de3					z_else:
.8de3					z_endof:
.8de3	60		rts		                rts
.8de4					branch_runtime:
.8de4	68		pla		                pla
.8de5	85 22		sta $22		                sta tmpbranch
.8de7	68		pla		                pla
.8de8	85 23		sta $23		                sta tmpbranch+1
.8dea	a0 01		ldy #$01	                ldy #1
.8dec	b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8dee	85 24		sta $24		                sta tmp1
.8df0	c8		iny		                iny
.8df1	b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8df3	85 25		sta $25		                sta tmp1+1
.8df5	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8df8					xt_emit:
.8df8	20 44 d8	jsr $d844	                jsr underflow_1
.8dfb	b5 00		lda $00,x	                lda 0,x
.8dfd	e8		inx		                inx
.8dfe	e8		inx		                inx
.8dff					emit_a:
.8dff	6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8e02					z_emit:
.8e02					xt_empty_buffers:
.8e02	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8e04	a9 00		lda #$00	                lda #0
.8e06	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8e08					z_empty_buffers:
.8e08	60		rts		                rts
.8e09					xt_endcase:
.8e09	a0 8d		ldy #$8d	                ldy #>xt_drop
.8e0b	a9 37		lda #$37	                lda #<xt_drop
.8e0d	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8e10					_endcase_loop:
.8e10	b5 00		lda $00,x	                lda 0,x
.8e12	15 01		ora $01,x	                ora 1,x
.8e14	f0 05		beq $8e1b	                beq _done
.8e16	20 9d a1	jsr $a19d	                jsr xt_then
.8e19	80 f5		bra $8e10	                bra _endcase_loop
.8e1b					_done:
.8e1b	e8		inx		                inx
.8e1c	e8		inx		                inx
.8e1d	60		rts		z_endcase:      rts
.8e1e					xt_environment_q:
.8e1e	20 44 d8	jsr $d844	                jsr underflow_1
.8e21	a0 00		ldy #$00	                ldy #00                 ; counter for table
.8e23	5a		phy		                phy
.8e24					_table_loop:
.8e24	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e27	ca		dex		                dex
.8e28	ca		dex		                dex                     ; ( addr u addr u ? )
.8e29	b9 9b 8e	lda $8e9b,y	                lda env_table_single,y
.8e2c	95 00		sta $00,x	                sta 0,x
.8e2e	c8		iny		                iny
.8e2f	b9 9b 8e	lda $8e9b,y	                lda env_table_single,y
.8e32	95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e34	c8		iny		                iny
.8e35	15 00		ora $00,x	                ora 0,x
.8e37	f0 4d		beq $8e86	                beq _table_done
.8e39	5a		phy		                phy                     ; save Y, which is used by COUNT
.8e3a	20 6c 89	jsr $896c	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e3d	20 94 87	jsr $8794	                jsr xt_compare          ; ( addr u f )
.8e40	7a		ply		                ply
.8e41	b5 00		lda $00,x	                lda 0,x
.8e43	15 01		ora $01,x	                ora 1,x
.8e45	f0 04		beq $8e4b	                beq _got_result
.8e47	e8		inx		                inx                     ; DROP, now ( addr u )
.8e48	e8		inx		                inx
.8e49	80 d9		bra $8e24	                bra _table_loop
.8e4b					_got_result:
.8e4b	e8		inx		                inx                     ; drop flag, now ( addr u )
.8e4c	e8		inx		                inx
.8e4d	88		dey		                dey                     ; go back to index we had
.8e4e	88		dey		                dey
.8e4f	68		pla		                pla
.8e50	d0 0d		bne $8e5f	                bne _double_result
.8e52	b9 b9 8e	lda $8eb9,y	                lda env_results_single,y
.8e55	95 02		sta $02,x	                sta 2,x
.8e57	c8		iny		                iny
.8e58	b9 b9 8e	lda $8eb9,y	                lda env_results_single,y
.8e5b	95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e5d	80 1f		bra $8e7e	                bra _set_flag
.8e5f					_double_result:
.8e5f	ca		dex		                dex                     ; ( addr u ? )
.8e60	ca		dex		                dex
.8e61	98		tya		                tya
.8e62	38		sec		                sec
.8e63	e9 18		sbc #$18	                sbc #24
.8e65	0a		asl a		                asl
.8e66	a8		tay		                tay
.8e67	b9 cf 8e	lda $8ecf,y	                lda env_results_double,y
.8e6a	95 02		sta $02,x	                sta 2,x
.8e6c	c8		iny		                iny
.8e6d	b9 cf 8e	lda $8ecf,y	                lda env_results_double,y
.8e70	95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e72	c8		iny		                iny
.8e73	b9 cf 8e	lda $8ecf,y	                lda env_results_double,y
.8e76	95 04		sta $04,x	                sta 4,x
.8e78	c8		iny		                iny
.8e79	b9 cf 8e	lda $8ecf,y	                lda env_results_double,y
.8e7c	95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e7e					_set_flag:
.8e7e	a9 ff		lda #$ff	                lda #$ff
.8e80	95 00		sta $00,x	                sta 0,x
.8e82	95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e84	80 14		bra $8e9a	                bra _done
.8e86					_table_done:
.8e86	68		pla		                pla
.8e87	d0 09		bne $8e92	                bne _no_match
.8e89	1a		inc a		                ina
.8e8a	48		pha		                pha
.8e8b	8a		txa		                txa
.8e8c	18		clc		                clc
.8e8d	69 06		adc #$06	                adc #6                  ; skip six bytes
.8e8f	aa		tax		                tax                     ; ( addr u )
.8e90	80 92		bra $8e24	                bra _table_loop
.8e92					_no_match:
.8e92	8a		txa		                txa
.8e93	18		clc		                clc
.8e94	69 0a		adc #$0a	                adc #10
.8e96	aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e97	20 82 8f	jsr $8f82	                jsr xt_false
.8e9a					_done:
.8e9a					z_environment_q:
.8e9a	60		rts		                rts
.8e9b					env_table_single:
>8e9b	67 d6 77 d6 7d d6 82 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8ea3	94 d6
>8ea5	9c d6 a5 d6 ab d6 b1 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8ead	c4 d6 d0 d6 00 00		        .word envs_sc, envs_wl, 0000
.8eb3					env_table_double:
>8eb3	da d6 e0 d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8eb9					env_results_single:
>8eb9	ff 00				        .word $00FF     ; /COUNTED-STRING
>8ebb	ff 00				        .word $00FF     ; /HOLD
>8ebd	54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8ebf	08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8ec1	00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8ec3	ff 00				        .word $00FF     ; MAX-CHAR
>8ec5	ff 7f				        .word $7FFF     ; MAX-N
>8ec7	ff ff				        .word $FFFF     ; MAX-U
>8ec9	80 00				        .word $0080     ; RETURN-STACK-CELLS
>8ecb	20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8ecd	09 00				        .word $0009     ; WORDLISTS
.8ecf					env_results_double:
>8ecf	ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8ed3	ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8ed7					xt_equal:
.8ed7	20 49 d8	jsr $d849	                jsr underflow_2
.8eda	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8edc	d5 02		cmp $02,x	                cmp 2,x
.8ede	d0 0a		bne $8eea	                bne _false
.8ee0	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8ee2	d5 03		cmp $03,x	                cmp 3,x
.8ee4	d0 04		bne $8eea	                bne _false
.8ee6	a9 ff		lda #$ff	                lda #$ff
.8ee8	80 02		bra $8eec	                bra _done
.8eea	a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8eec	95 02		sta $02,x	_done:          sta 2,x
.8eee	95 03		sta $03,x	                sta 3,x
.8ef0	e8		inx		                inx
.8ef1	e8		inx		                inx
.8ef2	60		rts		z_equal:        rts
.8ef3					xt_blank:
.8ef3	ca		dex		                dex
.8ef4	ca		dex		                dex
.8ef5	a9 20		lda #$20	                lda #AscSP
.8ef7	95 00		sta $00,x	                sta 0,x
.8ef9	74 01		stz $01,x	                stz 1,x
.8efb	80 06		bra $8f03	                bra xt_fill     ; skip over code for ERASE
.8efd					xt_erase:
.8efd	ca		dex		                dex
.8efe	ca		dex		                dex
.8eff	74 00		stz $00,x	                stz 0,x
.8f01	74 01		stz $01,x	                stz 1,x
.8f03					xt_fill:
.8f03	20 4e d8	jsr $d84e	                jsr underflow_3
.8f06	b5 04		lda $04,x	                lda 4,x         ; LSB
.8f08	85 24		sta $24		                sta tmp1
.8f0a	b5 05		lda $05,x	                lda 5,x
.8f0c	85 25		sta $25		                sta tmp1+1
.8f0e	b5 02		lda $02,x	                lda 2,x
.8f10	85 26		sta $26		                sta tmp2
.8f12	b5 03		lda $03,x	                lda 3,x
.8f14	85 27		sta $27		                sta tmp2+1
.8f16	b5 00		lda $00,x	                lda 0,x
.8f18	a8		tay		                tay
.8f19					_loop:
.8f19	a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8f1b	c5 25		cmp $25		                cmp tmp1+1
.8f1d	90 21		bcc $8f40	                bcc _done               ; RAM_END < TMP1, so leave
.8f1f	d0 06		bne $8f27	                bne _check_counter      ; RAM_END is not smaller and not equal
.8f21	a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8f23	c5 24		cmp $24		                cmp tmp1
.8f25	90 19		bcc $8f40	                bcc _done               ; RAM_END < TMP1, so leave
.8f27					_check_counter:
.8f27	a5 26		lda $26		                lda tmp2
.8f29	05 27		ora $27		                ora tmp2+1
.8f2b	f0 13		beq $8f40	                beq _done
.8f2d	98		tya		                tya
.8f2e	92 24		sta ($24)	                sta (tmp1)
.8f30	a5 26		lda $26		                lda tmp2
.8f32	d0 02		bne $8f36	                bne +
.8f34	c6 27		dec $27		                dec tmp2+1
.8f36	c6 26		dec $26		+               dec tmp2
.8f38	e6 24		inc $24		                inc tmp1
.8f3a	d0 dd		bne $8f19	                bne _loop
.8f3c	e6 25		inc $25		                inc tmp1+1
.8f3e	80 d9		bra $8f19	                bra _loop
.8f40					_done:
.8f40	8a		txa		                txa
.8f41	18		clc		                clc
.8f42	69 06		adc #$06	                adc #6
.8f44	aa		tax		                tax
.8f45					z_blank:
.8f45					z_erase:
.8f45	60		rts		z_fill:         rts
.8f46					xt_execute:
.8f46	20 44 d8	jsr $d844	                jsr underflow_1
.8f49	20 4d 8f	jsr $8f4d	                jsr doexecute   ; do not combine to JMP (native coding)
.8f4c	60		rts		z_execute:      rts
.8f4d					doexecute:
.8f4d	b5 00		lda $00,x	                lda 0,x
.8f4f	85 0e		sta $0e		                sta ip
.8f51	b5 01		lda $01,x	                lda 1,x
.8f53	85 0f		sta $0f		                sta ip+1
.8f55	e8		inx		                inx
.8f56	e8		inx		                inx
.8f57	6c 0e 00	jmp ($000e)	                jmp (ip)
.8f5a					xt_execute_parsing:
.8f5a	20 4e d8	jsr $d84e	                jsr underflow_3
.8f5d	20 69 92	jsr $9269	                jsr xt_input_to_r       ; save normal input for later
.8f60	20 78 96	jsr $9678	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f63	b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f65	85 0a		sta $0a		                sta ciblen
.8f67	b5 01		lda $01,x	                lda 1,x
.8f69	85 0b		sta $0b		                sta ciblen+1
.8f6b	b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f6d	85 08		sta $08		                sta cib
.8f6f	b5 03		lda $03,x	                lda 3,x
.8f71	85 09		sta $09		                sta cib+1
.8f73	64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f75	64 0d		stz $0d		                stz toin+1
.8f77	20 8b a3	jsr $a38b	                jsr xt_two_drop         ; 2DROP ( xt )
.8f7a	20 46 8f	jsr $8f46	                jsr xt_execute
.8f7d	20 ad 9a	jsr $9aad	                jsr xt_r_to_input
.8f80					z_execute_parsing:
.8f80	60		rts		                rts
.8f81					xt_exit:
.8f81	60		rts		                rts             ; keep before z_exit
.8f82					z_exit:
.8f82					xt_false:
.8f82	ca		dex		                dex
.8f83	ca		dex		                dex
.8f84	74 00		stz $00,x	                stz 0,x
.8f86	74 01		stz $01,x	                stz 1,x
.8f88	60		rts		z_false:        rts
.8f89					xt_fetch:
.8f89	20 44 d8	jsr $d844	                jsr underflow_1
.8f8c	a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f8e	a8		tay		                tay
.8f8f	f6 00		inc $00,x	                inc 0,x
.8f91	d0 02		bne $8f95	                bne +
.8f93	f6 01		inc $01,x	                inc 1,x
.8f95					+
.8f95	a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f97	95 01		sta $01,x	                sta 1,x
.8f99	94 00		sty $00,x	                sty 0,x
.8f9b	60		rts		z_fetch:        rts
.8f9c					xt_find:
.8f9c	20 44 d8	jsr $d844	                jsr underflow_1
.8f9f	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8fa1	48		pha		                pha
.8fa2	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8fa4	48		pha		                pha
.8fa5	20 6c 89	jsr $896c	                jsr xt_count            ; ( caddr -- addr u )
.8fa8	20 e4 8f	jsr $8fe4	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8fab	b5 00		lda $00,x	                lda 0,x
.8fad	15 01		ora $01,x	                ora 1,x
.8faf	d0 0b		bne $8fbc	                bne _found_word
.8fb1	20 82 8f	jsr $8f82	                jsr xt_false            ; ( 0 0 )
.8fb4	68		pla		                pla                     ; LSB of address
.8fb5	95 02		sta $02,x	                sta 2,x
.8fb7	68		pla		                pla
.8fb8	95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8fba	80 27		bra $8fe3	                bra _done               ; ( addr 0 )
.8fbc					_found_word:
.8fbc	68		pla		                pla
.8fbd	68		pla		                pla
.8fbe	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( nt nt )
.8fc1	20 eb 95	jsr $95eb	                jsr xt_name_to_int      ; ( nt xt )
.8fc4	20 89 a1	jsr $a189	                jsr xt_swap             ; ( xt nt )
.8fc7	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fc9	f6 00		inc $00,x	                inc 0,x
.8fcb	d0 02		bne $8fcf	                bne +
.8fcd	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fcf					+
.8fcf	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fd1	29 04		and #$04	                and #IM
.8fd3	d0 08		bne $8fdd	                bne _immediate          ; bit set, we're immediate
.8fd5	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8fd7	95 00		sta $00,x	                sta 0,x
.8fd9	95 01		sta $01,x	                sta 1,x
.8fdb	80 06		bra $8fe3	                bra _done
.8fdd					_immediate:
.8fdd	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8fdf	95 00		sta $00,x	                sta 0,x
.8fe1	74 01		stz $01,x	                stz 1,x
.8fe3					_done:
.8fe3	60		rts		z_find:         rts
.8fe4					xt_find_name:
.8fe4	20 49 d8	jsr $d849	                jsr underflow_2
.8fe7	b5 00		lda $00,x	                lda 0,x
.8fe9	15 01		ora $01,x	                ora 1,x
.8feb	d0 03		bne $8ff0	                bne _nonempty
.8fed	4c 89 90	jmp $9089	                jmp _fail_done
.8ff0					_nonempty:
.8ff0	64 28		stz $28		                stz tmp3                ; Start at the beginning
.8ff2					_wordlist_loop:
.8ff2	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8ff4	a5 28		lda $28		                lda tmp3
.8ff6	d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8ff8	d0 03		bne $8ffd	                bne _have_string
.8ffa	4c 89 90	jmp $9089	                jmp _fail_done
.8ffd					_have_string:
.8ffd	18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8ffe	69 1f		adc #$1f	                adc #search_order_offset
.9000	a8		tay		                tay
.9001	b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.9003	0a		asl a		                asl                     ; Turn offset into cells offset.
.9004	18		clc		                clc
.9005	69 06		adc #$06	                adc #wordlists_offset
.9007	a8		tay		                tay
.9008	b1 1e		lda ($1e),y	                lda (up),y
.900a	85 24		sta $24		                sta tmp1
.900c	c8		iny		                iny
.900d	b1 1e		lda ($1e),y	                lda (up),y
.900f	85 25		sta $25		                sta tmp1+1
.9011	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9013	85 26		sta $26		                sta tmp2
.9015	b5 03		lda $03,x	                lda 3,x
.9017	85 27		sta $27		                sta tmp2+1
.9019					_loop:
.9019	b2 24		lda ($24)	                lda (tmp1)
.901b	d5 00		cmp $00,x	                cmp 0,x
.901d	d0 54		bne $9073	                bne _next_entry
.901f					_compare_string:
.901f	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9021	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9023	b0 07		bcs $902c	                bcs _compare_first
.9025	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9027	90 03		bcc $902c	                bcc _compare_first
.9029	18		clc		                clc
.902a	69 20		adc #$20	                adc #$20
.902c					_compare_first:
.902c	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.902e	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9030	d0 41		bne $9073	                bne _next_entry
.9032	b5 00		lda $00,x	                lda 0,x
.9034	3a		dec a		                dea
.9035	f0 2c		beq $9063	                beq _success
.9037	a5 24		lda $24		                lda tmp1
.9039	48		pha		                pha             ; Preserve tmp1 on the return stack.
.903a	18		clc		                clc
.903b	69 08		adc #$08	                adc #8
.903d	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.903f	a5 25		lda $25		                lda tmp1+1
.9041	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9042	69 00		adc #$00	                adc #0          ; we only need the carry
.9044	85 25		sta $25		                sta tmp1+1
.9046	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9048	88		dey		                dey
.9049					_string_loop:
.9049	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.904b	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.904d	b0 07		bcs $9056	                bcs _check_char
.904f	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9051	90 03		bcc $9056	                bcc _check_char
.9053	18		clc		                clc
.9054	69 20		adc #$20	                adc #$20
.9056					_check_char:
.9056	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9058	d0 13		bne $906d	                bne _next_entry_tmp1
.905a	88		dey		                dey
.905b	d0 ec		bne $9049	                bne _string_loop
.905d					_success_tmp1:
.905d	68		pla		                pla             ; Restore tmp1 from the return stack.
.905e	85 25		sta $25		                sta tmp1+1
.9060	68		pla		                pla
.9061	85 24		sta $24		                sta tmp1
.9063					_success:
.9063	a5 24		lda $24		                lda tmp1
.9065	95 02		sta $02,x	                sta 2,x
.9067	a5 25		lda $25		                lda tmp1+1
.9069	95 03		sta $03,x	                sta 3,x
.906b	80 20		bra $908d	                bra _done
.906d					_next_entry_tmp1:
.906d	68		pla		                pla             ; Restore tmp1 from the return stack.
.906e	85 25		sta $25		                sta tmp1+1
.9070	68		pla		                pla
.9071	85 24		sta $24		                sta tmp1
.9073					_next_entry:
.9073	a0 02		ldy #$02	                ldy #2
.9075	b1 24		lda ($24),y	                lda (tmp1),y
.9077	48		pha		                pha
.9078	c8		iny		                iny
.9079	b1 24		lda ($24),y	                lda (tmp1),y
.907b	85 25		sta $25		                sta tmp1+1
.907d	68		pla		                pla
.907e	85 24		sta $24		                sta tmp1
.9080	05 25		ora $25		                ora tmp1+1
.9082	d0 95		bne $9019	                bne _loop
.9084	e6 28		inc $28		                inc tmp3
.9086	4c f2 8f	jmp $8ff2	                jmp _wordlist_loop
.9089					_fail_done:
.9089	74 02		stz $02,x	                stz 2,x         ; failure flag
.908b	74 03		stz $03,x	                stz 3,x
.908d					_done:
.908d	e8		inx		                inx
.908e	e8		inx		                inx
.908f	60		rts		z_find_name:    rts
.9090					xt_flush:
.9090	20 99 9e	jsr $9e99	                jsr xt_save_buffers
.9093	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9095	a9 00		lda #$00	                lda #0
.9097	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.9099					z_flush:
.9099	60		rts		                rts
.909a					xt_fm_slash_mod:
.909a	20 4e d8	jsr $d84e	                jsr underflow_3
.909d	64 26		stz $26		                stz tmp2        ; default: n is positive
.909f	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90a1	10 0e		bpl $90b1	                bpl _check_d
.90a3	e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.90a5	20 2d 96	jsr $962d	                jsr xt_negate   ; NEGATE
.90a8	20 4b a3	jsr $a34b	                jsr xt_to_r     ; >R
.90ab	20 5e 8b	jsr $8b5e	                jsr xt_dnegate  ; DNEGATE
.90ae	20 9c 9a	jsr $9a9c	                jsr xt_r_from   ; R>
.90b1					_check_d:
.90b1	b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.90b3	10 0d		bpl $90c2	                bpl _multiply
.90b5	18		clc		                clc
.90b6	b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.90b8	75 02		adc $02,x	                adc 2,x         ; LSB of dh
.90ba	95 02		sta $02,x	                sta 2,x
.90bc	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90be	75 03		adc $03,x	                adc 3,x         ; MSB of dh
.90c0	95 03		sta $03,x	                sta 3,x
.90c2					_multiply:
.90c2	20 95 a5	jsr $a595	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90c5	a5 26		lda $26		                lda tmp2
.90c7	f0 07		beq $90d0	                beq _done
.90c9	e8		inx		                inx             ; pretend that we SWAP
.90ca	e8		inx		                inx
.90cb	20 2d 96	jsr $962d	                jsr xt_negate
.90ce	ca		dex		                dex
.90cf	ca		dex		                dex
.90d0					_done:
.90d0	60		rts		z_fm_slash_mod: rts
.90d1					xt_forth:
.90d1	a0 1f		ldy #$1f	                ldy #search_order_offset
.90d3	a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90d5	91 1e		sta ($1e),y	                sta (up),y
.90d7					z_forth:
.90d7	60		rts		                rts
.90d8					load_evaluate:
.90d8	a9 ff		lda #$ff	                lda #$FF
.90da	85 24		sta $24		                sta tmp1
.90dc	80 11		bra $90ef	                bra load_evaluate_start
.90de					xt_evaluate:
.90de	20 49 d8	jsr $d849	                jsr underflow_2
.90e1	64 24		stz $24		                stz tmp1
.90e3	b5 00		lda $00,x	                lda 0,x
.90e5	15 01		ora $01,x	                ora 1,x
.90e7	d0 06		bne $90ef	                bne evaluate_got_work
.90e9	e8		inx		                inx
.90ea	e8		inx		                inx
.90eb	e8		inx		                inx
.90ec	e8		inx		                inx
.90ed	80 42		bra $9131	                bra evaluate_done
.90ef					load_evaluate_start:
.90ef					evaluate_got_work:
.90ef	a0 01		ldy #$01	                ldy #blk_offset+1
.90f1	b1 1e		lda ($1e),y	                lda (up),y
.90f3	48		pha		                pha
.90f4	88		dey		                dey
.90f5	b1 1e		lda ($1e),y	                lda (up),y
.90f7	48		pha		                pha
.90f8	a5 24		lda $24		                lda tmp1
.90fa	d0 05		bne $9101	                bne _nozero
.90fc	91 1e		sta ($1e),y	                sta (up),y
.90fe	c8		iny		                iny
.90ff	91 1e		sta ($1e),y	                sta (up),y
.9101					_nozero:
.9101	20 69 92	jsr $9269	                jsr xt_input_to_r
.9104	a9 ff		lda #$ff	                lda #$ff
.9106	85 06		sta $06		                sta insrc
.9108	85 07		sta $07		                sta insrc+1
.910a	64 0c		stz $0c		                stz toin
.910c	64 0d		stz $0d		                stz toin+1
.910e	b5 00		lda $00,x	                lda 0,x
.9110	85 0a		sta $0a		                sta ciblen
.9112	b5 01		lda $01,x	                lda 1,x
.9114	85 0b		sta $0b		                sta ciblen+1
.9116	b5 02		lda $02,x	                lda 2,x
.9118	85 08		sta $08		                sta cib
.911a	b5 03		lda $03,x	                lda 3,x
.911c	85 09		sta $09		                sta cib+1
.911e	e8		inx		                inx             ; A clean stack is a clean mind
.911f	e8		inx		                inx
.9120	e8		inx		                inx
.9121	e8		inx		                inx
.9122	20 ac d7	jsr $d7ac	                jsr interpret   ; ( -- )
.9125	20 ad 9a	jsr $9aad	                jsr xt_r_to_input
.9128	a0 00		ldy #$00	                ldy #blk_offset
.912a	68		pla		                pla
.912b	91 1e		sta ($1e),y	                sta (up),y
.912d	c8		iny		                iny
.912e	68		pla		                pla
.912f	91 1e		sta ($1e),y	                sta (up),y
.9131					evaluate_done:
.9131	60		rts		z_evaluate:     rts
.9132					xt_get_current:
.9132	ca		dex		                dex
.9133	ca		dex		                dex
.9134	a0 04		ldy #$04	                ldy #current_offset
.9136	b1 1e		lda ($1e),y	                lda (up),y
.9138	95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.913a	74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.913c	60		rts		z_get_current:  rts
.913d					xt_get_order:
.913d	a0 1e		ldy #$1e	                ldy #num_order_offset
.913f	b1 1e		lda ($1e),y	                lda (up),y
.9141	85 24		sta $24		                sta tmp1
.9143	f0 16		beq $915b	                beq _done       ; If zero, there are no wordlists.
.9145					_loop:
.9145	c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.9147	a9 1f		lda #$1f	                lda #search_order_offset
.9149	18		clc		                clc
.914a	65 24		adc $24		                adc tmp1
.914c	a8		tay		                tay
.914d	ca		dex		                dex
.914e	ca		dex		                dex
.914f	b1 1e		lda ($1e),y	                lda (up),y
.9151	95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.9153	74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.9155	a9 00		lda #$00	                lda #0
.9157	c5 24		cmp $24		                cmp tmp1
.9159	d0 ea		bne $9145	                bne _loop
.915b					_done:
.915b	ca		dex		                dex
.915c	ca		dex		                dex
.915d	a0 1e		ldy #$1e	                ldy #num_order_offset
.915f	b1 1e		lda ($1e),y	                lda (up),y
.9161	95 00		sta $00,x	                sta 0,x
.9163	74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.9165	60		rts		z_get_order:    rts
.9166					xt_greater_than:
.9166	20 49 d8	jsr $d849	                jsr underflow_2
.9169	a0 00		ldy #$00	                ldy #0          ; default false
.916b	20 6b d7	jsr $d76b	                jsr compare_16bit
.916e	f0 03		beq $9173	                beq _false
.9170	10 01		bpl $9173	                bpl _false
.9172	88		dey		                dey
.9173					_false:
.9173	98		tya		                tya
.9174	e8		inx		                inx
.9175	e8		inx		                inx
.9176	95 00		sta $00,x	                sta 0,x
.9178	95 01		sta $01,x	                sta 1,x
.917a	60		rts		z_greater_than: rts
.917b					xt_here:
.917b					xt_asm_arrow:
.917b	ca		dex		                dex
.917c	ca		dex		                dex
.917d	a5 00		lda $00		                lda cp
.917f	95 00		sta $00,x	                sta 0,x
.9181	a5 01		lda $01		                lda cp+1
.9183	95 01		sta $01,x	                sta 1,x
.9185					z_asm_arrow:
.9185	60		rts		z_here:         rts
.9186					xt_hex:
.9186	a9 10		lda #$10	                lda #16
.9188	85 18		sta $18		                sta base
.918a	64 19		stz $19		                stz base+1              ; paranoid
.918c	60		rts		z_hex:          rts
.918d					xt_hexstore:
.918d	20 4e d8	jsr $d84e	                jsr underflow_3
.9190	20 b8 8d	jsr $8db8	                jsr xt_dup              ; Save copy of original address
.9193	20 7d a4	jsr $a47d	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9196					_loop:
.9196	b5 00		lda $00,x	                lda 0,x
.9198	15 01		ora $01,x	                ora 1,x
.919a	f0 36		beq $91d2	                beq _done
.919c	20 58 86	jsr $8658	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.919f	20 7d a4	jsr $a47d	                jsr xt_two_to_r
.91a2	20 83 a7	jsr $a783	                jsr xt_zero
.91a5	20 83 a7	jsr $a783	                jsr xt_zero
.91a8	20 03 a4	jsr $a403	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.91ab	20 98 a2	jsr $a298	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.91ae	b5 00		lda $00,x	                lda 0,x
.91b0	15 01		ora $01,x	                ora 1,x
.91b2	d0 17		bne $91cb	                bne _have_chars_left
.91b4	20 8b a3	jsr $a38b	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.91b7	20 9d 8a	jsr $8a9d	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.91ba	20 87 9a	jsr $9a87	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.91bd	20 21 86	jsr $8621	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.91c0	20 9c 9a	jsr $9a9c	                jsr xt_r_from           ; R>
.91c3	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+
.91c6	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91c9	80 cb		bra $9196	                bra _loop
.91cb					_have_chars_left:
.91cb	8a		txa		                txa
.91cc	18		clc		                clc
.91cd	69 08		adc #$08	                adc #8
.91cf	aa		tax		                tax
.91d0	80 c4		bra $9196	                bra _loop
.91d2					_done:
.91d2	e8		inx		                inx
.91d3	e8		inx		                inx
.91d4	e8		inx		                inx
.91d5	e8		inx		                inx                     ; 2DROP
.91d6	20 03 a4	jsr $a403	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91d9	20 89 a1	jsr $a189	                jsr xt_swap
.91dc	20 5a 95	jsr $955a	                jsr xt_minus            ; ( n )
.91df	60		rts		z_hexstore:     rts
.91e0					xt_hold:
.91e0	20 44 d8	jsr $d844	                jsr underflow_1
.91e3	a5 34		lda $34		                lda tohold
.91e5	d0 02		bne $91e9	                bne +
.91e7	c6 35		dec $35		                dec tohold+1
.91e9					+
.91e9	c6 34		dec $34		                dec tohold
.91eb	b5 00		lda $00,x	                lda 0,x
.91ed	92 34		sta ($34)	                sta (tohold)
.91ef	e8		inx		                inx
.91f0	e8		inx		                inx
.91f1	60		rts		z_hold:         rts
.91f2					xt_i:
.91f2	ca		dex		                dex
.91f3	ca		dex		                dex
.91f4	da		phx		                phx
.91f5	ba		tsx		                tsx
.91f6	38		sec		                sec
.91f7	bd 02 01	lda $0102,x	                lda $0102,x     ; LSB
.91fa	fd 04 01	sbc $0104,x	                sbc $0104,x
.91fd	a8		tay		                tay
.91fe	bd 03 01	lda $0103,x	                lda $0103,x     ; MSB
.9201	fd 05 01	sbc $0105,x	                sbc $0105,x
.9204	fa		plx		                plx
.9205	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.9207	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.9209	60		rts		z_i:            rts
.920a					xt_if:
.920a	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.920c	a9 1b		lda #$1b	                lda #<zero_branch_runtime
.920e	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.9211	20 7b 91	jsr $917b	                jsr xt_here
.9214	20 83 a7	jsr $a783	                jsr xt_zero
.9217	20 7a 87	jsr $877a	                jsr xt_comma
.921a	60		rts		z_if:           rts
.921b					zero_branch_runtime:
.921b	68		pla		                pla
.921c	85 22		sta $22		                sta tmpbranch
.921e	68		pla		                pla
.921f	85 23		sta $23		                sta tmpbranch+1
.9221	b5 00		lda $00,x	                lda 0,x
.9223	15 01		ora $01,x	                ora 1,x
.9225	f0 0f		beq $9236	                beq _zero
.9227	a5 22		lda $22		                lda tmpbranch   ; LSB
.9229	18		clc		                clc
.922a	69 02		adc #$02	                adc #2
.922c	85 24		sta $24		                sta tmp1
.922e	a5 23		lda $23		                lda tmpbranch+1 ; MSB
.9230	69 00		adc #$00	                adc #0          ; For carry
.9232	85 25		sta $25		                sta tmp1+1
.9234	80 13		bra $9249	                bra _done
.9236					_zero:
.9236	a0 01		ldy #$01	                ldy #1
.9238	b1 22		lda ($22),y	                lda (tmpbranch),y
.923a	85 24		sta $24		                sta tmp1
.923c	c8		iny		                iny
.923d	b1 22		lda ($22),y	                lda (tmpbranch),y
.923f	85 25		sta $25		                sta tmp1+1
.9241	a5 24		lda $24		                lda tmp1
.9243	d0 02		bne $9247	                bne +
.9245	c6 25		dec $25		                dec tmp1+1
.9247					+
.9247	c6 24		dec $24		                dec tmp1
.9249					_done:
.9249	a5 25		lda $25		                lda tmp1+1
.924b	48		pha		                pha             ; MSB first
.924c	a5 24		lda $24		                lda tmp1
.924e	48		pha		                pha
.924f	e8		inx		                inx
.9250	e8		inx		                inx
.9251	60		rts		                rts
.9252					xt_immediate:
.9252	20 86 d7	jsr $d786	                jsr current_to_dp
.9255	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9257	b1 02		lda ($02),y	                lda (dp),y
.9259	09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.925b	91 02		sta ($02),y	                sta (dp),y
.925d	60		rts		z_immediate:    rts
.925e					xt_input:
.925e	ca		dex		                dex
.925f	ca		dex		                dex
.9260	a9 12		lda #$12	                lda #<input
.9262	95 00		sta $00,x	                sta 0,x
.9264	a9 00		lda #$00	                lda #>input
.9266	95 01		sta $01,x	                sta 1,x
.9268	60		rts		z_input:        rts
.9269					xt_input_to_r:
.9269	68		pla		                pla
.926a	85 24		sta $24		                sta tmp1
.926c	68		pla		                pla
.926d	85 25		sta $25		                sta tmp1+1
.926f	a0 07		ldy #$07	                ldy #7
.9271					_loop:
.9271	b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.9274	48		pha		                pha
.9275	88		dey		                dey
.9276	10 f9		bpl $9271	                bpl _loop
.9278	a5 25		lda $25		                lda tmp1+1
.927a	48		pha		                pha
.927b	a5 24		lda $24		                lda tmp1
.927d	48		pha		                pha
.927e	60		rts		z_input_to_r: 	rts
.927f					xt_int_to_name:
.927f	20 44 d8	jsr $d844	                jsr underflow_1
.9282	ca		dex		                dex
.9283	ca		dex		                dex
.9284	74 00		stz $00,x	                stz 0,x
.9286	74 01		stz $01,x	                stz 1,x
.9288					_wordlist_loop:
.9288	b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.928a	0a		asl a		                asl                     ; Turn offset into cells offset.
.928b	18		clc		                clc
.928c	69 06		adc #$06	                adc #wordlists_offset
.928e	a8		tay		                tay
.928f	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.9291	85 26		sta $26		                sta tmp2                ; into tmp2
.9293	c8		iny		                iny
.9294	b1 1e		lda ($1e),y	                lda (up),y
.9296	85 27		sta $27		                sta tmp2+1
.9298	a5 26		lda $26		                lda tmp2
.929a	05 27		ora $27		                ora tmp2+1
.929c	f0 38		beq $92d6	                beq _next_wordlist
.929e	b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.92a0	85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.92a2	b5 03		lda $03,x	                lda 3,x
.92a4	85 29		sta $29		                sta tmp3+1
.92a6					_loop:
.92a6	a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.92a8	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.92aa	c5 28		cmp $28		                cmp tmp3
.92ac	d0 07		bne $92b5	                bne _no_match
.92ae	c8		iny		                iny
.92af	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.92b1	c5 29		cmp $29		                cmp tmp3+1
.92b3	f0 32		beq $92e7	                beq _match
.92b5					_no_match:
.92b5	18		clc		                clc
.92b6	a5 26		lda $26		                lda tmp2
.92b8	69 02		adc #$02	                adc #2
.92ba	85 26		sta $26		                sta tmp2
.92bc	a5 27		lda $27		                lda tmp2+1
.92be	69 00		adc #$00	                adc #0          ; only care about carry
.92c0	85 27		sta $27		                sta tmp2+1
.92c2	a0 00		ldy #$00	                ldy #0
.92c4	b1 26		lda ($26),y	                lda (tmp2),y
.92c6	48		pha		                pha
.92c7	c8		iny		                iny
.92c8	11 26		ora ($26),y	                ora (tmp2),y
.92ca	f0 09		beq $92d5	                beq _zero
.92cc	b1 26		lda ($26),y	                lda (tmp2),y
.92ce	85 27		sta $27		                sta tmp2+1
.92d0	68		pla		                pla
.92d1	85 26		sta $26		                sta tmp2
.92d3	80 d1		bra $92a6	                bra _loop
.92d5					_zero:
.92d5	68		pla		                pla             ; Leftover from above loop
.92d6					_next_wordlist:
.92d6	b5 00		lda $00,x	                lda 0,x
.92d8	1a		inc a		                ina
.92d9	95 00		sta $00,x	                sta 0,x
.92db	c9 0c		cmp #$0c	                cmp #max_wordlists
.92dd	d0 a9		bne $9288	                bne _wordlist_loop
.92df	e8		inx		                inx
.92e0	e8		inx		                inx
.92e1	74 00		stz $00,x	                stz 0,x
.92e3	74 01		stz $01,x	                stz 1,x
.92e5	80 0a		bra $92f1	                bra z_int_to_name
.92e7					_match:
.92e7	e8		inx		                inx
.92e8	e8		inx		                inx
.92e9	a5 26		lda $26		                lda tmp2
.92eb	95 00		sta $00,x	                sta 0,x
.92ed	a5 27		lda $27		                lda tmp2+1
.92ef	95 01		sta $01,x	                sta 1,x
.92f1	60		rts		z_int_to_name:  rts
.92f2					xt_invert:
.92f2	20 44 d8	jsr $d844	                jsr underflow_1
.92f5	a9 ff		lda #$ff	                lda #$FF
.92f7	55 00		eor $00,x	                eor 0,x         ; LSB
.92f9	95 00		sta $00,x	                sta 0,x
.92fb	a9 ff		lda #$ff	                lda #$FF
.92fd	55 01		eor $01,x	                eor 1,x         ; MSB
.92ff	95 01		sta $01,x	                sta 1,x
.9301	60		rts		z_invert:       rts
.9302					xt_is:
.9302	a5 16		lda $16		                lda state
.9304	05 17		ora $17		                ora state+1
.9306	f0 0c		beq $9314	                beq _interpreting
.9308					_compiling:
.9308	20 aa 85	jsr $85aa	                jsr xt_bracket_tick
.930b	a0 8b		ldy #$8b	                ldy #>xt_defer_store
.930d	a9 03		lda #$03	                lda #<xt_defer_store
.930f	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.9312	80 06		bra $931a	                bra _done
.9314					_interpreting:
.9314	20 ec a1	jsr $a1ec	                jsr xt_tick
.9317	20 03 8b	jsr $8b03	                jsr xt_defer_store
.931a					_done:
.931a	60		rts		z_is:           rts
.931b					xt_j:
.931b	ca		dex		                dex
.931c	ca		dex		                dex
.931d	86 2a		stx $2a		                stx tmpdsp
.931f	ba		tsx		                tsx
.9320	38		sec		                sec
.9321	bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.9324	fd 09 01	sbc $0109,x	                sbc $0109,x
.9327	a8		tay		                tay
.9328	bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.932b	fd 0a 01	sbc $010a,x	                sbc $010A,x
.932e	a6 2a		ldx $2a		                ldx tmpdsp
.9330	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.9332	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.9334	60		rts		z_j:            rts
.9335					xt_key:
.9335	20 3f 93	jsr $933f	                jsr key_a               ; returns char in A
.9338	ca		dex		                dex
.9339	ca		dex		                dex
.933a	95 00		sta $00,x	                sta 0,x
.933c	74 01		stz $01,x	                stz 1,x
.933e	60		rts		z_key:          rts
.933f					key_a:
.933f	6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.9342					xt_latestnt:
.9342	ca		dex		                dex
.9343	ca		dex		                dex
.9344	20 86 d7	jsr $d786	                jsr current_to_dp
.9347	a5 02		lda $02		                lda dp
.9349	95 00		sta $00,x	                sta 0,x
.934b	a5 03		lda $03		                lda dp+1
.934d	95 01		sta $01,x	                sta 1,x
.934f	60		rts		z_latestnt:     rts
.9350					xt_latestxt:
.9350	20 42 93	jsr $9342	                jsr xt_latestnt         ; ( nt )
.9353	20 eb 95	jsr $95eb	                jsr xt_name_to_int      ; ( xt )
.9356	60		rts		z_latestxt:     rts
.9357					xt_leave:
.9357	68		pla		                pla
.9358	68		pla		                pla
.9359	68		pla		                pla
.935a	68		pla		                pla
.935b	60		rts		                rts             ; this must be compiled, so keep before z_leave
.935c					z_leave:
.935c					xt_left_bracket:
.935c	64 16		stz $16		                stz state
.935e	64 17		stz $17		                stz state+1
.9360	60		rts		z_left_bracket: rts
.9361					xt_less_number_sign:
.9361	20 ab 98	jsr $98ab	                jsr xt_pad      ; ( addr )
.9364	b5 00		lda $00,x	                lda 0,x
.9366	85 34		sta $34		                sta tohold
.9368	b5 01		lda $01,x	                lda 1,x
.936a	85 35		sta $35		                sta tohold+1
.936c	e8		inx		                inx
.936d	e8		inx		                inx
.936e					z_less_number_sign:
.936e	60		rts		                rts
.936f					xt_less_than:
.936f	20 49 d8	jsr $d849	                jsr underflow_2
.9372	a0 00		ldy #$00	                ldy #0          ; default false
.9374	20 6b d7	jsr $d76b	                jsr compare_16bit
.9377	f0 03		beq $937c	                beq _false
.9379	30 01		bmi $937c	                bmi _false
.937b	88		dey		                dey
.937c					_false:
.937c	98		tya		                tya
.937d	e8		inx		                inx
.937e	e8		inx		                inx
.937f	95 00		sta $00,x	                sta 0,x
.9381	95 01		sta $01,x	                sta 1,x
.9383	60		rts		z_less_than:    rts
.9384					xt_list:
.9384	20 44 d8	jsr $d844	                jsr underflow_1
.9387	20 b4 9e	jsr $9eb4	                jsr xt_scr
.938a	20 68 a1	jsr $a168	                jsr xt_store
.938d	20 1d a8	jsr $a81d	                jsr xt_editor_l
.9390	60		rts		z_list:         rts
.9391					xt_literal:
.9391	20 44 d8	jsr $d844	                jsr underflow_1
.9394	a0 93		ldy #$93	                ldy #>literal_runtime
.9396	a9 9f		lda #$9f	                lda #<literal_runtime
.9398	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.939b	20 7a 87	jsr $877a	                jsr xt_comma
.939e	60		rts		z_literal:      rts
.939f					literal_runtime:
.939f	ca		dex		                dex
.93a0	ca		dex		                dex
.93a1	68		pla		                pla             ; LSB
.93a2	85 24		sta $24		                sta tmp1
.93a4	68		pla		                pla             ; MSB
.93a5	85 25		sta $25		                sta tmp1+1
.93a7	a0 01		ldy #$01	                ldy #1
.93a9	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.93ab	95 00		sta $00,x	                sta 0,x
.93ad	c8		iny		                iny
.93ae	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.93b0	95 01		sta $01,x	                sta 1,x
.93b2	98		tya		                tya
.93b3	18		clc		                clc
.93b4	65 24		adc $24		                adc tmp1
.93b6	a8		tay		                tay
.93b7	a5 25		lda $25		                lda tmp1+1
.93b9	69 00		adc #$00	                adc #0
.93bb	48		pha		                pha
.93bc	5a		phy		                phy
.93bd	60		rts		                rts
.93be					xt_load:
.93be	20 44 d8	jsr $d844	                jsr underflow_1
.93c1	a0 01		ldy #$01	                ldy #blk_offset+1
.93c3	b1 1e		lda ($1e),y	                lda (up),y
.93c5	48		pha		                pha
.93c6	88		dey		                dey
.93c7	b1 1e		lda ($1e),y	                lda (up),y
.93c9	48		pha		                pha
.93ca	b5 00		lda $00,x	                lda 0,x
.93cc	91 1e		sta ($1e),y	                sta (up),y
.93ce	c8		iny		                iny
.93cf	b5 01		lda $01,x	                lda 1,x
.93d1	91 1e		sta ($1e),y	                sta (up),y
.93d3	20 cd 83	jsr $83cd	                jsr xt_block
.93d6	ca		dex		                dex
.93d7	ca		dex		                dex
.93d8	a9 04		lda #$04	                lda #4
.93da	95 01		sta $01,x	                sta 1,x
.93dc	74 00		stz $00,x	                stz 0,x
.93de	20 d8 90	jsr $90d8	                jsr load_evaluate
.93e1	a0 00		ldy #$00	                ldy #blk_offset
.93e3	68		pla		                pla
.93e4	91 1e		sta ($1e),y	                sta (up),y
.93e6	c8		iny		                iny
.93e7	68		pla		                pla
.93e8	91 1e		sta ($1e),y	                sta (up),y
.93ea	88		dey		                dey
.93eb	11 1e		ora ($1e),y	                ora (up),y
.93ed	f0 12		beq $9401	                beq _done
.93ef	ca		dex		                dex
.93f0	ca		dex		                dex
.93f1	a0 00		ldy #$00	                ldy #blk_offset
.93f3	b1 1e		lda ($1e),y	                lda (up),y
.93f5	95 00		sta $00,x	                sta 0,x
.93f7	c8		iny		                iny
.93f8	b1 1e		lda ($1e),y	                lda (up),y
.93fa	95 01		sta $01,x	                sta 1,x
.93fc	20 cd 83	jsr $83cd	                jsr xt_block
.93ff	e8		inx		                inx
.9400	e8		inx		                inx
.9401					_done:
.9401	60		rts		z_load:         rts
.9402					xt_loop:
.9402	ca		dex		                dex
.9403	ca		dex		                dex
.9404	a0 0e		ldy #$0e	                ldy #loop_runtime_end-loop_runtime
.9406	a9 76		lda #$76	                lda #<loop_runtime
.9408	95 00		sta $00,x	                sta 0,x
.940a	a9 94		lda #$94	                lda #>loop_runtime
.940c	95 01		sta $01,x	                sta 1,x
.940e	20 e3 88	jsr $88e3	                jsr cmpl_inline_y
.9411	80 0f		bra $9422	                bra xt_loop_common
.9413					xt_plus_loop:
.9413	ca		dex		                dex
.9414	ca		dex		                dex
.9415	a0 10		ldy #$10	                ldy #plus_loop_runtime_end-plus_loop_runtime
.9417	a9 66		lda #$66	                lda #<plus_loop_runtime
.9419	95 00		sta $00,x	                sta 0,x
.941b	a9 94		lda #$94	                lda #>plus_loop_runtime
.941d	95 01		sta $01,x	                sta 1,x
.941f	20 e3 88	jsr $88e3	                jsr cmpl_inline_y
.9422					xt_loop_common:
.9422	20 7a 87	jsr $877a	                jsr xt_comma
.9425	a9 68		lda #$68	                lda #$68                ; opcode for PLA
.9427	a0 06		ldy #$06	                ldy #6
.9429					-
.9429	91 00		sta ($00),y	                sta (cp),y
.942b	88		dey		                dey
.942c	10 fb		bpl $9429	                bpl -
.942e	a9 06		lda #$06	                lda #6
.9430	18		clc		                clc
.9431	65 00		adc $00		                adc cp
.9433	85 00		sta $00		                sta cp
.9435	a5 01		lda $01		                lda cp+1
.9437	69 00		adc #$00	                adc #0                  ; only need carry
.9439	85 01		sta $01		                sta cp+1
.943b	b5 00		lda $00,x	                lda 0,x
.943d	85 24		sta $24		                sta tmp1
.943f	b5 01		lda $01,x	                lda 1,x
.9441	85 25		sta $25		                sta tmp1+1
.9443	e8		inx		                inx
.9444	e8		inx		                inx
.9445	a5 00		lda $00		                lda cp
.9447	38		sec		                sec
.9448	e9 01		sbc #$01	                sbc #1
.944a	48		pha		                pha             ; lsb
.944b	a5 01		lda $01		                lda cp+1
.944d	e9 00		sbc #$00	                sbc #0
.944f	48		pha		                pha             ; msb
.9450	a0 00		ldy #$00	                ldy #0
.9452					-
.9452	b9 60 94	lda $9460,y	                lda loop_epilogue,y
.9455	d0 01		bne $9458	                bne +
.9457	68		pla		                pla
.9458					+
.9458	91 24		sta ($24),y	                sta (tmp1),y
.945a	c8		iny		                iny
.945b	c0 06		cpy #$06	                cpy #(loop_epilogue_end-loop_epilogue)
.945d	d0 f3		bne $9452	                bne -
.945f					z_loop:
.945f	60		rts		z_plus_loop:    rts
.9460					loop_epilogue:
.9460	a9 00		lda #$00	                lda #0
.9462	48		pha		                pha
.9463	a9 00		lda #$00	                lda #0
.9465	48		pha		                pha
.9466					loop_epilogue_end:
.9466					plus_loop_runtime:
.9466	18		clc		                clc
.9467	68		pla		                pla             ; LSB of index
.9468	75 00		adc $00,x	                adc 0,x         ; LSB of step
.946a	a8		tay		                tay             ; temporary storage of LSB
.946b	b8		clv		                clv
.946c	68		pla		                pla             ; MSB of index
.946d	75 01		adc $01,x	                adc 1,x         ; MSB of step
.946f	48		pha		                pha             ; put MSB of index back on stack
.9470	5a		phy		                phy             ; put LSB of index back on stack
.9471	e8		inx		                inx             ; dump step from TOS
.9472	e8		inx		                inx
.9473	70 03		bvs $9478	                bvs _hack+3     ; skip over JMP instruction
.9475					_hack:
>9475	4c				                .byte $4C
.9476					plus_loop_runtime_end:
.9476					loop_runtime:
.9476	b8		clv		                clv             ; note inc doesn't affect V
.9477	7a		ply		                ply             ; LSB of index
.9478	c8		iny		                iny             ; add one
.9479	d0 05		bne $9480	                bne _skip_msb   ; definitely not done
.947b	68		pla		                pla             ; MSB of index
.947c	18		clc		                clc
.947d	69 01		adc #$01	                adc #1          ; use adc to get V flag
.947f	48		pha		                pha             ; put MSB of index back on stack
.9480	5a		phy		_skip_msb:      phy             ; put LSB of index back on stack
.9481	70 03		bvs $9486	                bvs _hack+3     ; skip over JMP instruction
.9483					_hack:
>9483	4c				                .byte $4C
.9484					loop_runtime_end:
.9484					xt_lshift:
.9484	20 49 d8	jsr $d849	                jsr underflow_2
.9487	b5 00		lda $00,x	                lda 0,x
.9489	29 0f		and #$0f	                and #%00001111
.948b	f0 08		beq $9495	                beq _done
.948d	a8		tay		                tay
.948e					_loop:
.948e	16 02		asl $02,x	                asl 2,x
.9490	36 03		rol $03,x	                rol 3,x
.9492	88		dey		                dey
.9493	d0 f9		bne $948e	                bne _loop
.9495					_done:
.9495	e8		inx		                inx
.9496	e8		inx		                inx
.9497	60		rts		z_lshift:       rts
.9498					xt_m_star:
.9498	20 49 d8	jsr $d849	                jsr underflow_2
.949b	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.949d	55 03		eor $03,x	                eor 3,x         ; MSB of n2
.949f	48		pha		                pha
.94a0	20 23 81	jsr $8123	                jsr xt_abs
.94a3	20 89 a1	jsr $a189	                jsr xt_swap
.94a6	20 23 81	jsr $8123	                jsr xt_abs
.94a9	20 d7 a5	jsr $a5d7	                jsr xt_um_star          ; ( d )
.94ac	68		pla		                pla
.94ad	10 03		bpl $94b2	                bpl _done
.94af	20 5e 8b	jsr $8b5e	                jsr xt_dnegate
.94b2					_done:
.94b2	60		rts		z_m_star:       rts
.94b3					xt_marker:
.94b3	20 86 d7	jsr $d786	                jsr current_to_dp
.94b6	a5 02		lda $02		                lda dp
.94b8	48		pha		                pha
.94b9	a5 03		lda $03		                lda dp+1
.94bb	48		pha		                pha
.94bc	a5 00		lda $00		                lda cp
.94be	48		pha		                pha
.94bf	a5 01		lda $01		                lda cp+1
.94c1	48		pha		                pha
.94c2	20 86 89	jsr $8986	                jsr xt_create
.94c5	a5 00		lda $00		                lda cp          ; LSB
.94c7	38		sec		                sec
.94c8	e9 02		sbc #$02	                sbc #2
.94ca	85 00		sta $00		                sta cp
.94cc	a5 01		lda $01		                lda cp+1        ; MSB
.94ce	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94d0	85 01		sta $01		                sta cp+1
.94d2	a0 94		ldy #$94	                ldy #>marker_runtime
.94d4	a9 f1		lda #$f1	                lda #<marker_runtime
.94d6	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.94d9	7a		ply		                ply                     ; MSB
.94da	68		pla		                pla                     ; LSB
.94db	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.94de	7a		ply		                ply                     ; MSB
.94df	68		pla		                pla                     ; LSB
.94e0	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.94e3	a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94e5					_marker_loop:
.94e5	b1 1e		lda ($1e),y	                lda (up),y
.94e7	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.94ea	c8		iny		                iny
.94eb	98		tya		                tya
.94ec	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94ee	d0 f5		bne $94e5	                bne _marker_loop
.94f0	60		rts		z_marker:       rts
.94f1					marker_runtime:
.94f1	68		pla		                pla
.94f2	85 24		sta $24		                sta tmp1        ; LSB of address
.94f4	68		pla		                pla
.94f5	85 25		sta $25		                sta tmp1+1      ; MSB of address
.94f7	e6 24		inc $24		                inc tmp1
.94f9	d0 02		bne $94fd	                bne +
.94fb	e6 25		inc $25		                inc tmp1+1
.94fd					+
.94fd	a0 00		ldy #$00	                ldy #0
.94ff	b1 24		lda ($24),y	                lda (tmp1),y
.9501	85 00		sta $00		                sta cp
.9503	c8		iny		                iny
.9504	b1 24		lda ($24),y	                lda (tmp1),y
.9506	85 01		sta $01		                sta cp+1
.9508	c8		iny		                iny
.9509	b1 24		lda ($24),y	                lda (tmp1),y
.950b	85 02		sta $02		                sta dp
.950d	c8		iny		                iny
.950e	b1 24		lda ($24),y	                lda (tmp1),y
.9510	85 03		sta $03		                sta dp+1
.9512	a0 04		ldy #$04	                ldy #4
.9514					_marker_restore_loop:
.9514	b1 24		lda ($24),y	                lda (tmp1), y
.9516	91 1e		sta ($1e),y	                sta (up), y
.9518	c8		iny		                iny
.9519	98		tya		                tya
.951a	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.951c	d0 f6		bne $9514	                bne _marker_restore_loop
.951e	20 99 d7	jsr $d799	                jsr dp_to_current       ; Move the CURRENT DP back.
.9521	60		rts		                rts
.9522					xt_max:
.9522	20 49 d8	jsr $d849	                jsr underflow_2
.9525	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9527	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.9529	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.952b	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.952d	50 02		bvc $9531	                bvc _no_overflow
.952f	49 80		eor #$80	                eor #$80        ; complement negative flag
.9531					_no_overflow:
.9531	30 08		bmi $953b	                bmi _keep_nos
.9533	b5 00		lda $00,x	                lda 0,x
.9535	95 02		sta $02,x	                sta 2,x
.9537	b5 01		lda $01,x	                lda 1,x
.9539	95 03		sta $03,x	                sta 3,x
.953b					_keep_nos:
.953b	e8		inx		                inx
.953c	e8		inx		                inx
.953d	60		rts		z_max:          rts
.953e					xt_min:
.953e	20 49 d8	jsr $d849	                jsr underflow_2
.9541	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9543	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.9545	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9547	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9549	50 02		bvc $954d	                bvc _no_overflow
.954b	49 80		eor #$80	                eor #$80
.954d					_no_overflow:
.954d	10 08		bpl $9557	                bpl _keep_nos
.954f	b5 00		lda $00,x	                lda 0,x
.9551	95 02		sta $02,x	                sta 2,x
.9553	b5 01		lda $01,x	                lda 1,x
.9555	95 03		sta $03,x	                sta 3,x
.9557					_keep_nos:
.9557	e8		inx		                inx
.9558	e8		inx		                inx
.9559	60		rts		z_min:          rts
.955a					xt_minus:
.955a	20 49 d8	jsr $d849	                jsr underflow_2
.955d	38		sec		                sec
.955e	b5 02		lda $02,x	                lda 2,x         ; LSB
.9560	f5 00		sbc $00,x	                sbc 0,x
.9562	95 02		sta $02,x	                sta 2,x
.9564	b5 03		lda $03,x	                lda 3,x         ; MSB
.9566	f5 01		sbc $01,x	                sbc 1,x
.9568	95 03		sta $03,x	                sta 3,x
.956a	e8		inx		                inx
.956b	e8		inx		                inx
.956c	60		rts		z_minus:        rts
.956d					xt_minus_leading:
.956d	20 49 d8	jsr $d849	                jsr underflow_2
.9570					_loop:
.9570	b5 00		lda $00,x	                lda 0,x
.9572	15 01		ora $01,x	                ora 1,x
.9574	f0 0f		beq $9585	                beq _done
.9576	a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.9578	20 37 d8	jsr $d837	                jsr is_whitespace
.957b	90 08		bcc $9585	                bcc _done
.957d	20 12 98	jsr $9812	                jsr xt_one              ; ( addr u 1 )
.9580	20 f4 9f	jsr $9ff4	                jsr xt_slash_string     ; ( addr+ u-1 )
.9583	80 eb		bra $9570	                bra _loop
.9585					_done:
.9585					z_minus_leading:
.9585	60		rts		                rts
.9586					xt_minus_trailing:
.9586	20 49 d8	jsr $d849	                jsr underflow_2
.9589	b5 00		lda $00,x	                lda 0,x         ; LSB of n
.958b	15 01		ora $01,x	                ora 1,x         ; MSB of n
.958d	f0 33		beq $95c2	                beq _done
.958f	18		clc		                clc
.9590	b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.9592	75 00		adc $00,x	                adc 0,x
.9594	85 24		sta $24		                sta tmp1
.9596	b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.9598	75 01		adc $01,x	                adc 1,x
.959a	85 25		sta $25		                sta tmp1+1
.959c	a5 24		lda $24		                lda tmp1
.959e	d0 02		bne $95a2	                bne +
.95a0	c6 25		dec $25		                dec tmp1+1
.95a2					+
.95a2	c6 24		dec $24		                dec tmp1
.95a4					_loop:
.95a4	b2 24		lda ($24)	                lda (tmp1)
.95a6	c9 20		cmp #$20	                cmp #AscSP
.95a8	d0 18		bne $95c2	                bne _done
.95aa	a5 24		lda $24		                lda tmp1
.95ac	d0 02		bne $95b0	                bne +
.95ae	c6 25		dec $25		                dec tmp1+1
.95b0					+
.95b0	c6 24		dec $24		                dec tmp1
.95b2	b5 00		lda $00,x	                lda 0,x
.95b4	d0 02		bne $95b8	                bne +
.95b6	d6 01		dec $01,x	                dec 1,x
.95b8					+
.95b8	d6 00		dec $00,x	                dec 0,x
.95ba	b5 00		lda $00,x	                lda 0,x
.95bc	15 01		ora $01,x	                ora 1,x
.95be	f0 02		beq $95c2	                beq _done       ; Count has reached zero - we're done!
.95c0	80 e2		bra $95a4	                bra _loop
.95c2					_done:
.95c2					z_minus_trailing:
.95c2	60		rts		                rts
.95c3					xt_mod:
.95c3	20 49 d8	jsr $d849	                jsr underflow_2
.95c6	20 dc 9f	jsr $9fdc	                jsr xt_slash_mod
.95c9	e8		inx		                inx             ; DROP
.95ca	e8		inx		                inx
.95cb					z_mod:
.95cb	60		rts		                rts
.95cc					xt_move:
.95cc	b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95ce	d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95d0	f0 05		beq $95d7	                beq _lsb                ; wasn't helpful, move to LSB
.95d2	b0 0e		bcs $95e2	                bcs _to_move_up         ; we want CMOVE>
.95d4	4c a5 86	jmp $86a5	                jmp xt_cmove            ; JSR/RTS
.95d7					_lsb:
.95d7	b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95d9	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95db	f0 08		beq $95e5	                beq _equal              ; LSB is equal as well
.95dd	b0 03		bcs $95e2	                bcs _to_move_up         ; we want CMOVE>
.95df	4c a5 86	jmp $86a5	                jmp xt_cmove            ; JSR/RTS
.95e2					_to_move_up:
.95e2	4c e0 86	jmp $86e0	                jmp xt_cmove_up         ; JSR/RTS
.95e5					_equal:
.95e5	8a		txa		                txa
.95e6	18		clc		                clc
.95e7	69 06		adc #$06	                adc #6
.95e9	aa		tax		                tax
.95ea	60		rts		z_move:         rts
.95eb					xt_name_to_int:
.95eb	20 44 d8	jsr $d844	                jsr underflow_1
.95ee	b5 00		lda $00,x	                lda 0,x
.95f0	18		clc		                clc
.95f1	69 04		adc #$04	                adc #4
.95f3	85 28		sta $28		                sta tmp3
.95f5	b5 01		lda $01,x	                lda 1,x
.95f7	90 01		bcc $95fa	                bcc _done
.95f9	1a		inc a		                ina
.95fa					_done:
.95fa	85 29		sta $29		                sta tmp3+1
.95fc	a0 00		ldy #$00	                ldy #0
.95fe	b1 28		lda ($28),y	                lda (tmp3),y
.9600	95 00		sta $00,x	                sta 0,x
.9602	c8		iny		                iny
.9603	b1 28		lda ($28),y	                lda (tmp3),y
.9605	95 01		sta $01,x	                sta 1,x
.9607	60		rts		z_name_to_int:  rts
.9608					xt_name_to_string:
.9608	20 44 d8	jsr $d844	                jsr underflow_1
.960b	ca		dex		                dex
.960c	ca		dex		                dex
.960d	a1 02		lda ($02,x)	                lda (2,x)
.960f	95 00		sta $00,x	                sta 0,x
.9611	74 01		stz $01,x	                stz 1,x
.9613	b5 02		lda $02,x	                lda 2,x         ; LSB
.9615	18		clc		                clc
.9616	69 08		adc #$08	                adc #8
.9618	a8		tay		                tay
.9619	b5 03		lda $03,x	                lda 3,x         ; MSB
.961b	69 00		adc #$00	                adc #0          ; just need carry
.961d	95 03		sta $03,x	                sta 3,x
.961f	94 02		sty $02,x	                sty 2,x
.9621					z_name_to_string:
.9621	60		rts		                rts
.9622					xt_nc_limit:
.9622	ca		dex		                dex
.9623	ca		dex		                dex
.9624	a9 1a		lda #$1a	                lda #<nc_limit
.9626	95 00		sta $00,x	                sta 0,x
.9628	a9 00		lda #$00	                lda #>nc_limit
.962a	95 01		sta $01,x	                sta 1,x
.962c	60		rts		z_nc_limit:     rts
.962d					xt_negate:
.962d	20 44 d8	jsr $d844	                jsr underflow_1
.9630	a9 00		lda #$00	        	lda #0
.9632	38		sec		                sec
.9633	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.9635	95 00		sta $00,x	                sta 0,x
.9637	a9 00		lda #$00	                lda #0
.9639	f5 01		sbc $01,x	                sbc 1,x         ; MSB
.963b	95 01		sta $01,x	                sta 1,x
.963d	60		rts		z_negate:       rts
.963e					xt_never_native:
.963e	20 86 d7	jsr $d786	                jsr current_to_dp
.9641	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9643	b1 02		lda ($02),y	                lda (dp),y
.9645	09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9647	29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.9649	91 02		sta ($02),y	                sta (dp),y
.964b					z_never_native:
.964b	60		rts		                rts
.964c					xt_nip:
.964c	20 49 d8	jsr $d849	                jsr underflow_2
.964f	b5 00		lda $00,x	                lda 0,x         ; LSB
.9651	95 02		sta $02,x	                sta 2,x
.9653	b5 01		lda $01,x	                lda 1,x         ; MSB
.9655	95 03		sta $03,x	                sta 3,x
.9657	e8		inx		                inx
.9658	e8		inx		                inx
.9659	60		rts		z_nip:          rts
.965a					xt_not_equals:
.965a	20 49 d8	jsr $d849	                jsr underflow_2
.965d	a0 00		ldy #$00	                ldy #0                  ; default is true
.965f	b5 00		lda $00,x	                lda 0,x                 ; LSB
.9661	d5 02		cmp $02,x	                cmp 2,x
.9663	d0 0a		bne $966f	                bne _not_equal
.9665	b5 01		lda $01,x	                lda 1,x                 ; MSB
.9667	d5 03		cmp $03,x	                cmp 3,x
.9669	d0 04		bne $966f	                bne _not_equal
.966b	a9 ff		lda #$ff	                lda #$FF
.966d	80 01		bra $9670	                bra _done
.966f					_not_equal:
.966f	88		dey		                dey                     ; drop thru to done
.9670					_done:
.9670	98		tya		                tya
.9671	e8		inx		                inx
.9672	e8		inx		                inx
.9673	95 00		sta $00,x	                sta 0,x
.9675	95 01		sta $01,x	                sta 1,x
.9677	60		rts		z_not_equals:   rts
.9678					xt_not_rote:
.9678	20 4e d8	jsr $d84e	                jsr underflow_3
.967b	b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.967d	b5 03		lda $03,x	                lda 3,x
.967f	95 01		sta $01,x	                sta 1,x
.9681	b5 05		lda $05,x	                lda 5,x
.9683	95 03		sta $03,x	                sta 3,x
.9685	94 05		sty $05,x	                sty 5,x
.9687	b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9689	b5 02		lda $02,x	                lda 2,x
.968b	95 00		sta $00,x	                sta 0,x
.968d	b5 04		lda $04,x	                lda 4,x
.968f	95 02		sta $02,x	                sta 2,x
.9691	94 04		sty $04,x	                sty 4,x
.9693	60		rts		z_not_rote:     rts
.9694					xt_number:
.9694	20 49 d8	jsr $d849	                jsr underflow_2
.9697	64 2a		stz $2a		                stz tmpdsp      ; flag for double
.9699	64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.969b	a5 18		lda $18		                lda base
.969d	48		pha		                pha
.969e	20 93 a3	jsr $a393	                jsr xt_two_dup
.96a1	a1 02		lda ($02,x)	                lda (2,x)
.96a3					_check_dec:
.96a3	c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.96a5	d0 04		bne $96ab	                bne _check_hex
.96a7	a9 0a		lda #$0a	                lda #$0A
.96a9	80 42		bra $96ed	                bra _base_changed
.96ab					_check_hex:
.96ab	c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.96ad	d0 04		bne $96b3	                bne _check_binary
.96af	a9 10		lda #$10	                lda #$10
.96b1	80 3a		bra $96ed	                bra _base_changed
.96b3					_check_binary:
.96b3	c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.96b5	d0 04		bne $96bb	                bne _check_char
.96b7	a9 02		lda #$02	                lda #$02
.96b9	80 32		bra $96ed	                bra _base_changed
.96bb					_check_char:
.96bb	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96bd	d0 3a		bne $96f9	                bne _check_minus
.96bf	b5 00		lda $00,x	                lda 0,x         ; Get the length
.96c1	c9 03		cmp #$03	                cmp #$03
.96c3	d0 26		bne $96eb	                bne _not_a_char
.96c5	b5 01		lda $01,x	                lda 1,x
.96c7	d0 22		bne $96eb	                bne _not_a_char ; No compare needed to check for non-zero.
.96c9	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96cb	18		clc		                clc
.96cc	69 02		adc #$02	                adc #2          ; length of string
.96ce	85 2c		sta $2c		                sta tmptos
.96d0	b5 03		lda $03,x	                lda 3,x
.96d2	69 00		adc #$00	                adc #0          ; only need carry
.96d4	85 2d		sta $2d		                sta tmptos+1
.96d6	b2 2c		lda ($2c)	                lda (tmptos)
.96d8	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96da	d0 0f		bne $96eb	                bne _not_a_char
.96dc	f6 02		inc $02,x	                inc 2,x
.96de	d0 02		bne $96e2	                bne +
.96e0	f6 03		inc $03,x	                inc 3,x
.96e2					+
.96e2	a1 02		lda ($02,x)	                lda (2,x)
.96e4	95 02		sta $02,x	                sta 2,x
.96e6	74 03		stz $03,x	                stz 3,x
.96e8	4c 69 97	jmp $9769	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.96eb					_not_a_char:
.96eb	80 5a		bra $9747	                bra _number_error
.96ed					_base_changed:
.96ed	85 18		sta $18		                sta base        ; Switch to the new base
.96ef	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96f1	d0 02		bne $96f5	                bne +
.96f3	f6 03		inc $03,x	                inc 3,x
.96f5					+
.96f5	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96f7	a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96f9					_check_minus:
.96f9	c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96fb	d0 0a		bne $9707	                bne _check_dot
.96fd	c6 2b		dec $2b		                dec tmpdsp+1
.96ff	f6 02		inc $02,x	                inc 2,x         ; start one character later
.9701	d0 02		bne $9705	                bne +
.9703	f6 03		inc $03,x	                inc 3,x
.9705					+
.9705	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9707					_check_dot:
.9707	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9709	18		clc		                clc
.970a	75 00		adc $00,x	                adc 0,x         ; length of string
.970c	85 2c		sta $2c		                sta tmptos
.970e	b5 03		lda $03,x	                lda 3,x
.9710	69 00		adc #$00	                adc #0          ; only need carry
.9712	85 2d		sta $2d		                sta tmptos+1
.9714	a5 2c		lda $2c		                lda tmptos
.9716	d0 02		bne $971a	                bne +
.9718	c6 2d		dec $2d		                dec tmptos+1
.971a					+
.971a	c6 2c		dec $2c		                dec tmptos
.971c	b2 2c		lda ($2c)	                lda (tmptos)
.971e	c9 2e		cmp #$2e	                cmp #'.'
.9720	d0 04		bne $9726	                bne _main
.9722	c6 2a		dec $2a		                dec tmpdsp
.9724	d6 00		dec $00,x	                dec 0,x
.9726					_main:
.9726	ca		dex		                dex
.9727	ca		dex		                dex
.9728	ca		dex		                dex
.9729	ca		dex		                dex
.972a	b5 04		lda $04,x	                lda 4,x         ; LSB of length
.972c	95 00		sta $00,x	                sta 0,x
.972e	74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9730	b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9732	95 02		sta $02,x	                sta 2,x
.9734	b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9736	95 03		sta $03,x	                sta 3,x
.9738	74 04		stz $04,x	                stz 4,x         ; clear space for ud
.973a	74 05		stz $05,x	                stz 5,x
.973c	74 06		stz $06,x	                stz 6,x
.973e	74 07		stz $07,x	                stz 7,x
.9740	20 98 a2	jsr $a298	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9743	b5 00		lda $00,x	                lda 0,x
.9745	f0 1e		beq $9765	                beq _all_converted
.9747					_number_error:
.9747	20 8b a3	jsr $a38b	                jsr xt_two_drop ; >NUMBER modified addr u
.974a	20 8b a3	jsr $a38b	                jsr xt_two_drop ; ud   (partially converted number)
.974d	a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.974f	20 ff 8d	jsr $8dff	                jsr emit_a
.9752	20 de a4	jsr $a4de	                jsr xt_type
.9755	a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.9757	20 ff 8d	jsr $8dff	                jsr emit_a
.975a	20 f9 a0	jsr $a0f9	                jsr xt_space
.975d	68		pla		                pla
.975e	85 18		sta $18		                sta base
.9760	a9 08		lda #$08	                lda #err_syntax
.9762	4c 5a d8	jmp $d85a	                jmp error
.9765					_all_converted:
.9765	e8		inx		                inx ; Drop the current addr u
.9766	e8		inx		                inx
.9767	e8		inx		                inx
.9768	e8		inx		                inx
.9769					_drop_original_string:
.9769	20 59 a4	jsr $a459	                jsr xt_two_swap  ; Drop the original addr u
.976c	20 8b a3	jsr $a38b	                jsr xt_two_drop  ; (was saved for unknown word error message)
.976f	a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9771	f0 0d		beq $9780	                beq _single
.9773	a9 20		lda #$20	                lda #%00100000
.9775	04 20		tsb $20		                tsb status
.9777	a5 2b		lda $2b		                lda tmpdsp+1
.9779	f0 12		beq $978d	                beq _done       ; no minus, all done
.977b	20 5e 8b	jsr $8b5e	                jsr xt_dnegate
.977e	80 0d		bra $978d	                bra _done
.9780					_single:
.9780	e8		inx		                inx
.9781	e8		inx		                inx
.9782	a9 20		lda #$20	                lda #%00100000
.9784	14 20		trb $20		                trb status
.9786	a5 2b		lda $2b		                lda tmpdsp+1
.9788	f0 03		beq $978d	                beq _done       ; no minus, all done
.978a	20 2d 96	jsr $962d	                jsr xt_negate
.978d					_done:
.978d	68		pla		                pla
.978e	85 18		sta $18		                sta base
.9790	60		rts		z_number:       rts
.9791					xt_number_sign:
.9791	20 49 d8	jsr $d849	                jsr underflow_2         ; double number
.9794	20 93 83	jsr $8393	                jsr xt_base
.9797	20 89 8f	jsr $8f89	                jsr xt_fetch            ; ( ud1 base )
.979a	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >r
.979d	20 83 a7	jsr $a783	                jsr xt_zero             ; 0
.97a0	20 87 9a	jsr $9a87	                jsr xt_r_fetch          ; r@
.97a3	20 95 a5	jsr $a595	                jsr xt_um_slash_mod     ; um/mod
.97a6	20 61 9b	jsr $9b61	                jsr xt_rot              ; rot
.97a9	20 61 9b	jsr $9b61	                jsr xt_rot              ; rot
.97ac	20 9c 9a	jsr $9a9c	                jsr xt_r_from           ; r>
.97af	20 95 a5	jsr $a595	                jsr xt_um_slash_mod     ; um/mod
.97b2	20 61 9b	jsr $9b61	                jsr xt_rot              ; rot
.97b5	20 61 9b	jsr $9b61	                jsr xt_rot              ; ( ud rem )
.97b8	b5 00		lda $00,x	                lda 0,x
.97ba	a8		tay		                tay
.97bb	b9 11 d4	lda $d411,y	                lda s_abc_upper,y
.97be	95 00		sta $00,x	                sta 0,x
.97c0	74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.97c2	20 e0 91	jsr $91e0	                jsr xt_hold
.97c5					z_number_sign:
.97c5	60		rts		                rts
.97c6					xt_number_sign_greater:
.97c6	20 49 d8	jsr $d849	                jsr underflow_2         ; double number
.97c9	a5 34		lda $34		                lda tohold
.97cb	95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97cd	95 02		sta $02,x	                sta 2,x
.97cf	a5 35		lda $35		                lda tohold+1
.97d1	95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97d3	95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97d5	20 ab 98	jsr $98ab	                jsr xt_pad      ; ( addr addr pad )
.97d8	38		sec		                sec
.97d9	b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97db	f5 02		sbc $02,x	                sbc 2,x
.97dd	95 02		sta $02,x	                sta 2,x
.97df	b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97e1	f5 03		sbc $03,x	                sbc 3,x
.97e3	95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97e5	e8		inx		                inx
.97e6	e8		inx		                inx
.97e7					z_number_sign_greater:
.97e7	60		rts		                rts
.97e8					xt_number_sign_s:
.97e8	20 49 d8	jsr $d849	                jsr underflow_2
.97eb					_loop:
.97eb	20 91 97	jsr $9791	                jsr xt_number_sign
.97ee	b5 00		lda $00,x	                lda 0,x
.97f0	15 01		ora $01,x	                ora 1,x
.97f2	15 02		ora $02,x	                ora 2,x
.97f4	15 03		ora $03,x	                ora 3,x
.97f6	d0 f3		bne $97eb	                bne _loop
.97f8					z_number_sign_s:
.97f8	60		rts		                rts
.97f9					xt_of:
.97f9	a0 98		ldy #$98	                ldy #>xt_over
.97fb	a9 9d		lda #$9d	                lda #<xt_over
.97fd	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.9800	a0 8e		ldy #$8e	                ldy #>xt_equal
.9802	a9 d7		lda #$d7	                lda #<xt_equal
.9804	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.9807	20 0a 92	jsr $920a	                jsr xt_if
.980a	a0 8d		ldy #$8d	                ldy #>xt_drop
.980c	a9 37		lda #$37	                lda #<xt_drop
.980e	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.9811	60		rts		z_of:           rts
.9812					xt_editor_wordlist:
.9812					xt_one:
.9812	ca		dex		                dex
.9813	ca		dex		                dex
.9814	a9 01		lda #$01	                lda #1
.9816	95 00		sta $00,x	                sta 0,x
.9818	74 01		stz $01,x	                stz 1,x
.981a					z_editor_wordlist:
.981a					z_one:
.981a	60		rts		                rts
.981b					xt_one_minus:
.981b	20 44 d8	jsr $d844	                jsr underflow_1
.981e	b5 00		lda $00,x	                lda 0,x
.9820	d0 02		bne $9824	                bne +
.9822	d6 01		dec $01,x	                dec 1,x
.9824					+
.9824	d6 00		dec $00,x	                dec 0,x
.9826	60		rts		z_one_minus:    rts
.9827					xt_char_plus:
.9827					xt_one_plus:
.9827	20 44 d8	jsr $d844	                jsr underflow_1
.982a	f6 00		inc $00,x	                inc 0,x
.982c	d0 02		bne $9830	                bne _done
.982e	f6 01		inc $01,x	                inc 1,x
.9830					_done:
.9830					z_char_plus:
.9830	60		rts		z_one_plus:     rts
.9831					xt_only:
.9831	ca		dex		                dex
.9832	ca		dex		                dex
.9833	a9 ff		lda #$ff	                lda #$FF
.9835	95 00		sta $00,x	                sta 0,x
.9837	95 01		sta $01,x	                sta 1,x
.9839	20 25 9d	jsr $9d25	                jsr xt_set_order
.983c	60		rts		z_only:         rts
.983d					xt_or:
.983d	20 49 d8	jsr $d849	                jsr underflow_2
.9840	b5 00		lda $00,x	                lda 0,x
.9842	15 02		ora $02,x	                ora 2,x
.9844	95 02		sta $02,x	                sta 2,x
.9846	b5 01		lda $01,x	                lda 1,x
.9848	15 03		ora $03,x	                ora 3,x
.984a	95 03		sta $03,x	                sta 3,x
.984c	e8		inx		                inx
.984d	e8		inx		                inx
.984e	60		rts		z_or:           rts
.984f					xt_order:
.984f	20 80 89	jsr $8980	                jsr xt_cr
.9852	20 3d 91	jsr $913d	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.9855	b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9857	f0 1e		beq $9877	                beq _drop_done
.9859					_have_wordlists:
.9859	a8		tay		                tay
.985a					_loop:
.985a	e8		inx		                inx
.985b	e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.985c	b5 00		lda $00,x	                lda 0,x
.985e	5a		phy		                phy
.985f	20 7a 98	jsr $987a	                jsr order_print_wid_string   ; internal helper function
.9862	7a		ply		                ply
.9863	88		dey		                dey
.9864	d0 f4		bne $985a	                bne _loop
.9866	20 f9 a0	jsr $a0f9	                jsr xt_space
.9869	20 f9 a0	jsr $a0f9	                jsr xt_space
.986c	20 32 91	jsr $9132	                jsr xt_get_current      ; ( wid )
.986f	b5 00		lda $00,x	                lda 0,x
.9871	20 7a 98	jsr $987a	                jsr order_print_wid_string
.9874	20 80 89	jsr $8980	                jsr xt_cr
.9877					_drop_done:
.9877	e8		inx		                inx
.9878	e8		inx		                inx
.9879					z_order:
.9879	60		rts		                rts
.987a					order_print_wid_string:
.987a	c9 04		cmp #$04	                cmp #4
.987c	90 09		bcc $9887	                bcc _output_string      ; less than 4, print a real string
.987e	ca		dex		                dex
.987f	ca		dex		                dex
.9880	95 00		sta $00,x	                sta 0,x
.9882	74 01		stz $01,x	                stz 1,x
.9884	4c 09 a5	jmp $a509	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.9887					_output_string:
.9887	a8		tay		                tay
.9888	b9 8e 98	lda $988e,y	                lda _wid_data,y
.988b	4c 80 d8	jmp $d880	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.988e					_wid_data:
>988e	04				        .byte str_wid_forth            ; WID 0: "Forth"
>988f	05				        .byte str_wid_editor           ; WID 1: "Editor"
>9890	06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>9891	07				        .byte str_wid_root             ; WID 3: "Root"
.9892					xt_output:
.9892	ca		dex		                dex
.9893	ca		dex		                dex
.9894	a9 10		lda #$10	                lda #<output
.9896	95 00		sta $00,x	                sta 0,x
.9898	a9 00		lda #$00	                lda #>output
.989a	95 01		sta $01,x	                sta 1,x
.989c	60		rts		z_output:       rts
.989d					xt_over:
.989d	20 49 d8	jsr $d849	                jsr underflow_2
.98a0	ca		dex		                dex
.98a1	ca		dex		                dex
.98a2	b5 04		lda $04,x	                lda 4,x         ; LSB
.98a4	95 00		sta $00,x	                sta 0,x
.98a6	b5 05		lda $05,x	                lda 5,x         ; MSB
.98a8	95 01		sta $01,x	                sta 1,x
.98aa	60		rts		z_over:         rts
.98ab					xt_pad:
.98ab	ca		dex		                dex
.98ac	ca		dex		                dex
.98ad	a5 00		lda $00		                lda cp
.98af	18		clc		                clc
.98b0	69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.98b2	95 00		sta $00,x	                sta 0,x
.98b4	a5 01		lda $01		                lda cp+1
.98b6	69 00		adc #$00	                adc #0          ; only need carry
.98b8	95 01		sta $01,x	                sta 1,x
.98ba	60		rts		z_pad:          rts
.98bb					xt_page:
.98bb	a9 1b		lda #$1b	                lda #AscESC
.98bd	20 ff 8d	jsr $8dff	                jsr emit_a
.98c0	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.98c2	20 ff 8d	jsr $8dff	                jsr emit_a
.98c5	a9 32		lda #$32	                lda #'2'
.98c7	20 ff 8d	jsr $8dff	                jsr emit_a
.98ca	a9 4a		lda #$4a	                lda #'J'
.98cc	20 ff 8d	jsr $8dff	                jsr emit_a
.98cf	20 83 a7	jsr $a783	                jsr xt_zero
.98d2	20 83 a7	jsr $a783	                jsr xt_zero
.98d5	20 3a 83	jsr $833a	                jsr xt_at_xy
.98d8	60		rts		z_page:         rts
.98d9					xt_paren:
.98d9	ca		dex		                dex
.98da	ca		dex		                dex
.98db	a9 29		lda #$29	                lda #41     ; Right parenthesis
.98dd	95 00		sta $00,x	                sta 0,x
.98df	74 01		stz $01,x	                stz 1,x
.98e1	20 44 99	jsr $9944	                jsr xt_parse
.98e4	e8		inx		                inx
.98e5	e8		inx		                inx
.98e6	e8		inx		                inx
.98e7	e8		inx		                inx
.98e8	60		rts		z_paren:        rts
.98e9					xt_parse_name:
.98e9	a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98eb	38		sec		                sec
.98ec	e5 0c		sbc $0c		                sbc toin
.98ee	85 24		sta $24		                sta tmp1
.98f0	a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98f2	e5 0d		sbc $0d		                sbc toin+1
.98f4	85 25		sta $25		                sta tmp1+1
.98f6	a5 24		lda $24		                lda tmp1
.98f8	05 25		ora $25		                ora tmp1+1
.98fa	f0 28		beq $9924	                beq _empty_line
.98fc	a5 08		lda $08		                lda cib
.98fe	18		clc		                clc
.98ff	65 0c		adc $0c		                adc toin
.9901	85 26		sta $26		                sta tmp2                ; LSB of first character
.9903	a5 09		lda $09		                lda cib+1
.9905	65 0d		adc $0d		                adc toin+1
.9907	85 27		sta $27		                sta tmp2+1              ; MSB
.9909					_skip_loop:
.9909	b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.990b	20 37 d8	jsr $d837	                jsr is_whitespace
.990e	90 1f		bcc $992f	                bcc _char_found
.9910	e6 26		inc $26		                inc tmp2
.9912	d0 02		bne $9916	                bne +
.9914	e6 27		inc $27		                inc tmp2+1
.9916					+
.9916	a5 24		lda $24		                lda tmp1
.9918	d0 02		bne $991c	                bne +
.991a	c6 25		dec $25		                dec tmp1+1
.991c	c6 24		dec $24		+               dec tmp1
.991e	a5 24		lda $24		                lda tmp1
.9920	05 25		ora $25		                ora tmp1+1
.9922	d0 e5		bne $9909	                bne _skip_loop          ; fall through if empty line
.9924					_empty_line:
.9924	ca		dex		                dex
.9925	ca		dex		                dex
.9926	ca		dex		                dex
.9927	ca		dex		                dex
.9928	74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.992a	74 01		stz $01,x	                stz 1,x
.992c	4c db 99	jmp $99db	                jmp z_parse_name        ; skip over PARSE
.992f					_char_found:
.992f	a5 26		lda $26		                lda tmp2
.9931	38		sec		                sec
.9932	e5 08		sbc $08		                sbc cib
.9934	85 0c		sta $0c		                sta toin
.9936	a5 27		lda $27		                lda tmp2+1
.9938	e5 09		sbc $09		                sbc cib+1
.993a	85 0d		sta $0d		                sta toin+1
.993c	ca		dex		                dex
.993d	ca		dex		                dex
.993e	a9 20		lda #$20	                lda #AscSP
.9940	95 00		sta $00,x	                sta 0,x
.9942	74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.9944					xt_parse:
.9944	20 44 d8	jsr $d844	                jsr underflow_1
.9947	a5 0a		lda $0a		                lda ciblen
.9949	05 0b		ora $0b		                ora ciblen+1
.994b	f0 0c		beq $9959	                beq _abort_parse
.994d	a5 0d		lda $0d		                lda toin+1              ; MSB
.994f	c5 0b		cmp $0b		                cmp ciblen+1
.9951	90 0e		bcc $9961	                bcc _go_parse           ; unsigned comparison
.9953	a5 0c		lda $0c		                lda toin                ; LSB
.9955	c5 0a		cmp $0a		                cmp ciblen
.9957	90 08		bcc $9961	                bcc _go_parse
.9959					_abort_parse:
.9959	ca		dex		                dex
.995a	ca		dex		                dex
.995b	74 00		stz $00,x	                stz 0,x
.995d	74 01		stz $01,x	                stz 1,x
.995f	80 7a		bra $99db	                bra _done
.9961					_go_parse:
.9961	b5 00		lda $00,x	                lda 0,x
.9963	85 2c		sta $2c		                sta tmptos
.9965	ca		dex		                dex
.9966	ca		dex		                dex
.9967	a5 08		lda $08		                lda cib
.9969	18		clc		                clc
.996a	65 0c		adc $0c		                adc toin        ; LSB
.996c	85 24		sta $24		                sta tmp1
.996e	85 26		sta $26		                sta tmp2
.9970	95 02		sta $02,x	                sta 2,x
.9972	a5 09		lda $09		                lda cib+1
.9974	65 0d		adc $0d		                adc toin+1      ; MSB
.9976	85 25		sta $25		                sta tmp1+1
.9978	85 27		sta $27		                sta tmp2+1
.997a	95 03		sta $03,x	                sta 3,x
.997c	a5 08		lda $08		                lda cib
.997e	18		clc		                clc
.997f	65 0a		adc $0a		                adc ciblen
.9981	85 28		sta $28		                sta tmp3
.9983	a5 09		lda $09		                lda cib+1
.9985	65 0b		adc $0b		                adc ciblen+1
.9987	85 29		sta $29		                sta tmp3+1
.9989	64 2d		stz $2d		                stz tmptos+1
.998b					_loop:
.998b	a5 26		lda $26		                lda tmp2
.998d	c5 28		cmp $28		                cmp tmp3
.998f	d0 06		bne $9997	                bne _not_empty
.9991	a5 27		lda $27		                lda tmp2+1
.9993	c5 29		cmp $29		                cmp tmp3+1
.9995	f0 1d		beq $99b4	                beq _eol
.9997					_not_empty:
.9997	b2 26		lda ($26)	                lda (tmp2)
.9999	a4 2c		ldy $2c		                ldy tmptos
.999b	c0 20		cpy #$20	                cpy #AscSP
.999d	d0 07		bne $99a6	                bne _not_whitespace
.999f	20 37 d8	jsr $d837	                jsr is_whitespace
.99a2	90 02		bcc $99a6	                bcc _not_whitespace
.99a4	80 0c		bra $99b2	                bra _found_delimiter
.99a6					_not_whitespace:
.99a6	c5 2c		cmp $2c		                cmp tmptos
.99a8	f0 08		beq $99b2	                beq _found_delimiter
.99aa	e6 26		inc $26		                inc tmp2
.99ac	d0 dd		bne $998b	                bne _loop
.99ae	e6 27		inc $27		                inc tmp2+1
.99b0	80 d9		bra $998b	                bra _loop
.99b2					_found_delimiter:
.99b2	e6 2d		inc $2d		                inc tmptos+1
.99b4					_eol:
.99b4	a5 26		lda $26		                lda tmp2
.99b6	38		sec		                sec
.99b7	e5 24		sbc $24		                sbc tmp1
.99b9	95 00		sta $00,x	                sta 0,x
.99bb	a5 27		lda $27		                lda tmp2+1
.99bd	e5 25		sbc $25		                sbc tmp1+1
.99bf	95 01		sta $01,x	                sta 1,x
.99c1	a5 26		lda $26		                lda tmp2
.99c3	38		sec		                sec
.99c4	e5 08		sbc $08		                sbc cib
.99c6	85 0c		sta $0c		                sta toin
.99c8	a5 27		lda $27		                lda tmp2+1
.99ca	e5 09		sbc $09		                sbc cib+1
.99cc	85 0d		sta $0d		                sta toin+1
.99ce	a5 0c		lda $0c		                lda toin
.99d0	18		clc		                clc
.99d1	65 2d		adc $2d		                adc tmptos+1
.99d3	85 0c		sta $0c		                sta toin
.99d5	a5 0d		lda $0d		                lda toin+1
.99d7	69 00		adc #$00	                adc #0          ; we only need the carry
.99d9	85 0d		sta $0d		                sta toin+1
.99db					_done:
.99db					z_parse_name:
.99db	60		rts		z_parse:        rts
.99dc					xt_pick:
.99dc	16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99de	8a		txa		                txa
.99df	75 00		adc $00,x	                adc 0,x
.99e1	a8		tay		                tay
.99e2	b9 02 00	lda $0002,y	                lda 0002,y
.99e5	95 00		sta $00,x	                sta 0,x
.99e7	b9 03 00	lda $0003,y	                lda 0003,y
.99ea	95 01		sta $01,x	                sta 1,x
.99ec	60		rts		z_pick:         rts
.99ed					xt_plus:
.99ed	20 49 d8	jsr $d849	                jsr underflow_2
.99f0	18		clc		                clc
.99f1	b5 00		lda $00,x	                lda 0,x         ; LSB
.99f3	75 02		adc $02,x	                adc 2,x
.99f5	95 02		sta $02,x	                sta 2,x
.99f7	b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99f9	75 03		adc $03,x	                adc 3,x
.99fb	95 03		sta $03,x	                sta 3,x
.99fd	e8		inx		                inx
.99fe	e8		inx		                inx
.99ff	60		rts		z_plus:         rts
.9a00					xt_plus_store:
.9a00	20 49 d8	jsr $d849	                jsr underflow_2
.9a03	b5 00		lda $00,x	                lda 0,x
.9a05	85 24		sta $24		                sta tmp1
.9a07	b5 01		lda $01,x	                lda 1,x
.9a09	85 25		sta $25		                sta tmp1+1
.9a0b	a0 00		ldy #$00	                ldy #0          ; LSB
.9a0d	b1 24		lda ($24),y	                lda (tmp1),y
.9a0f	18		clc		                clc
.9a10	75 02		adc $02,x	                adc 2,x
.9a12	91 24		sta ($24),y	                sta (tmp1),y
.9a14	c8		iny		                iny             ; MSB
.9a15	b1 24		lda ($24),y	                lda (tmp1),y
.9a17	75 03		adc $03,x	                adc 3,x
.9a19	91 24		sta ($24),y	                sta (tmp1),y
.9a1b	e8		inx		                inx
.9a1c	e8		inx		                inx
.9a1d	e8		inx		                inx
.9a1e	e8		inx		                inx
.9a1f	60		rts		z_plus_store:   rts
.9a20					xt_postpone:
.9a20	20 e9 98	jsr $98e9	                jsr xt_parse_name               ; ( -- addr n )
.9a23	b5 00		lda $00,x	                lda 0,x
.9a25	15 01		ora $01,x	                ora 1,x
.9a27	d0 05		bne $9a2e	                bne +
.9a29	a9 05		lda #$05	                lda #err_noname
.9a2b	4c 5a d8	jmp $d85a	                jmp error
.9a2e					+
.9a2e	20 e4 8f	jsr $8fe4	                jsr xt_find_name                ; ( -- nt | 0 )
.9a31	d0 05		bne $9a38	                bne +
.9a33	a9 05		lda #$05	                lda #err_noname
.9a35	4c 5a d8	jmp $d85a	                jmp error
.9a38					+
.9a38	b5 00		lda $00,x	                lda 0,x
.9a3a	85 24		sta $24		                sta tmp1
.9a3c	b5 01		lda $01,x	                lda 1,x
.9a3e	85 25		sta $25		                sta tmp1+1
.9a40	20 eb 95	jsr $95eb	                jsr xt_name_to_int              ; ( nt -- xt )
.9a43	e6 24		inc $24		                inc tmp1
.9a45	d0 02		bne $9a49	                bne +
.9a47	e6 25		inc $25		                inc tmp1+1
.9a49					+
.9a49	b2 24		lda ($24)	                lda (tmp1)
.9a4b	29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a4d	f0 05		beq $9a54	                beq _not_immediate
.9a4f	20 f9 87	jsr $87f9	                jsr xt_compile_comma
.9a52	80 0a		bra $9a5e	                bra _done
.9a54					_not_immediate:
.9a54	20 91 93	jsr $9391	                jsr xt_literal
.9a57	a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a59	a9 f9		lda #$f9	                lda #<xt_compile_comma
.9a5b	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.9a5e					_done:
.9a5e	60		rts		z_postpone:     rts
.9a5f					xt_previous:
.9a5f	20 3d 91	jsr $913d	                jsr xt_get_order
.9a62	20 4c 96	jsr $964c	                jsr xt_nip
.9a65	20 1b 98	jsr $981b	                jsr xt_one_minus
.9a68	20 25 9d	jsr $9d25	                jsr xt_set_order
.9a6b	60		rts		z_previous:     rts
.9a6c					xt_question:
.9a6c	20 89 8f	jsr $8f89	                jsr xt_fetch
.9a6f	20 3f 8c	jsr $8c3f	                jsr xt_dot
.9a72	60		rts		z_question:     rts
.9a73					xt_question_dup:
.9a73	20 44 d8	jsr $d844	                jsr underflow_1
.9a76	b5 00		lda $00,x	                lda 0,x
.9a78	15 01		ora $01,x	                ora 1,x
.9a7a	f0 0a		beq $9a86	                beq _done
.9a7c	ca		dex		                dex
.9a7d	ca		dex		                dex
.9a7e	b5 02		lda $02,x	                lda 2,x
.9a80	95 00		sta $00,x	                sta 0,x
.9a82	b5 03		lda $03,x	                lda 3,x
.9a84	95 01		sta $01,x	                sta 1,x
.9a86					_done:
.9a86	60		rts		z_question_dup: rts
.9a87					xt_r_fetch:
.9a87	7a		ply		                ply             ; LSB
.9a88	84 24		sty $24		                sty tmp1
.9a8a	7a		ply		                ply             ; MSB
.9a8b	ca		dex		                dex
.9a8c	ca		dex		                dex
.9a8d	68		pla		                pla             ; LSB
.9a8e	95 00		sta $00,x	                sta 0,x
.9a90	68		pla		                pla             ; MSB
.9a91	95 01		sta $01,x	                sta 1,x
.9a93	48		pha		                pha
.9a94	b5 00		lda $00,x	                lda 0,x
.9a96	48		pha		                pha
.9a97	5a		phy		                phy             ; MSB
.9a98	a4 24		ldy $24		                ldy tmp1
.9a9a	5a		phy		                phy             ; LSB
.9a9b	60		rts		z_r_fetch:      rts
.9a9c					xt_r_from:
.9a9c	68		pla		                pla             ; LSB
.9a9d	85 2c		sta $2c		                sta tmptos
.9a9f	7a		ply		                ply             ; MSB
.9aa0	ca		dex		                dex
.9aa1	ca		dex		                dex
.9aa2	68		pla		                pla             ; LSB
.9aa3	95 00		sta $00,x	                sta 0,x
.9aa5	68		pla		                pla             ; MSB
.9aa6	95 01		sta $01,x	                sta 1,x
.9aa8	5a		phy		                phy             ; MSB
.9aa9	a5 2c		lda $2c		                lda tmptos
.9aab	48		pha		                pha             ; LSB
.9aac	60		rts		z_r_from:       rts
.9aad					xt_r_to_input:
.9aad	68		pla		                pla
.9aae	85 24		sta $24		                sta tmp1
.9ab0	68		pla		                pla
.9ab1	85 25		sta $25		                sta tmp1+1
.9ab3	a0 00		ldy #$00	                ldy #0
.9ab5					_loop:
.9ab5	68		pla		                pla
.9ab6	99 06 00	sta $0006,y	                sta insrc,y
.9ab9	c8		iny		                iny
.9aba	c0 08		cpy #$08	                cpy #8
.9abc	d0 f7		bne $9ab5	                bne _loop
.9abe	a5 25		lda $25		                lda tmp1+1
.9ac0	48		pha		                pha
.9ac1	a5 24		lda $24		                lda tmp1
.9ac3	48		pha		                pha
.9ac4	60		rts		z_r_to_input: 	rts
.9ac5					xt_recurse:
.9ac5	a0 00		ldy #$00	                ldy #0
.9ac7	a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9ac9	91 00		sta ($00),y	                sta (cp),y
.9acb	c8		iny		                iny
.9acc	24 20		bit $20		                bit status
.9ace	70 0c		bvs $9adc	                bvs _nt_in_workword
.9ad0	a5 04		lda $04		                lda workword
.9ad2	91 00		sta ($00),y	                sta (cp),y
.9ad4	c8		iny		                iny
.9ad5	a5 05		lda $05		                lda workword+1
.9ad7	91 00		sta ($00),y	                sta (cp),y
.9ad9	c8		iny		                iny
.9ada	80 1b		bra $9af7	                bra _update_cp
.9adc					_nt_in_workword:
.9adc	a5 04		lda $04		                lda workword            ; LSB
.9ade	18		clc		                clc
.9adf	69 04		adc #$04	                adc #4
.9ae1	85 24		sta $24		                sta tmp1
.9ae3	a5 05		lda $05		                lda workword+1          ; MSB
.9ae5	69 00		adc #$00	                adc #0
.9ae7	85 25		sta $25		                sta tmp1+1
.9ae9	b2 24		lda ($24)	                lda (tmp1)
.9aeb	91 00		sta ($00),y	                sta (cp),y
.9aed	5a		phy		                phy
.9aee	a0 01		ldy #$01	                ldy #1
.9af0	b1 24		lda ($24),y	                lda (tmp1),y
.9af2	7a		ply		                ply
.9af3	c8		iny		                iny
.9af4	91 00		sta ($00),y	                sta (cp),y
.9af6	c8		iny		                iny
.9af7					_update_cp:
.9af7	98		tya		                tya
.9af8	18		clc		                clc
.9af9	65 00		adc $00		                adc cp
.9afb	85 00		sta $00		                sta cp
.9afd	90 02		bcc $9b01	                bcc _done
.9aff	e6 01		inc $01		                inc cp+1
.9b01					_done:
.9b01	60		rts		z_recurse:      rts
.9b02					xt_refill:
.9b02	a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9b04	d0 2d		bne $9b33	                bne _src_not_kbd
.9b06	ca		dex		                dex
.9b07	ca		dex		                dex
.9b08	ca		dex		                dex
.9b09	ca		dex		                dex
.9b0a	a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9b0c	95 02		sta $02,x	                sta 2,x
.9b0e	a5 09		lda $09		                lda cib+1
.9b10	95 03		sta $03,x	                sta 3,x
.9b12	64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9b14	64 0b		stz $0b		                stz ciblen+1
.9b16	a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9b18	95 00		sta $00,x	                sta 0,x
.9b1a	74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9b1c	20 38 81	jsr $8138	                jsr xt_accept           ; ( addr n1 -- n2)
.9b1f	b5 00		lda $00,x	                lda 0,x
.9b21	85 0a		sta $0a		                sta ciblen
.9b23	b5 01		lda $01,x	                lda 1,x
.9b25	85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9b27	64 0c		stz $0c		                stz toin
.9b29	64 0d		stz $0d		                stz toin+1
.9b2b	a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b2d	95 00		sta $00,x	                sta 0,x
.9b2f	95 01		sta $01,x	                sta 1,x
.9b31	80 10		bra $9b43	                bra _done
.9b33					_src_not_kbd:
.9b33	1a		inc a		                ina
.9b34	d0 08		bne $9b3e	                bne _src_not_string
.9b36	ca		dex		                dex
.9b37	ca		dex		                dex
.9b38	74 00		stz $00,x	                stz 0,x
.9b3a	74 01		stz $01,x	                stz 1,x
.9b3c	80 05		bra $9b43	                bra z_refill
.9b3e					_src_not_string:
.9b3e	a9 01		lda #$01	                lda #err_badsource
.9b40	4c 5a d8	jmp $d85a	                jmp error
.9b43					_done:
.9b43	60		rts		z_refill:       rts
.9b44					xt_repeat:
.9b44	20 73 82	jsr $8273	                jsr xt_again
.9b47	20 7b 91	jsr $917b	                jsr xt_here
.9b4a	20 89 a1	jsr $a189	                jsr xt_swap
.9b4d	20 68 a1	jsr $a168	                jsr xt_store
.9b50	60		rts		z_repeat:       rts
.9b51					xt_right_bracket:
.9b51	a9 ff		lda #$ff	                lda #$FF
.9b53	85 16		sta $16		                sta state
.9b55	85 17		sta $17		                sta state+1
.9b57					z_right_bracket:
.9b57	60		rts		                rts
.9b58					xt_root_wordlist:
.9b58	ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b59	ca		dex		                dex
.9b5a	a9 03		lda #$03	                lda #3
.9b5c	95 00		sta $00,x	                sta 0,x
.9b5e	74 01		stz $01,x	                stz 1,x
.9b60					z_root_wordlist:
.9b60	60		rts		                rts
.9b61					xt_rot:
.9b61	20 4e d8	jsr $d84e	                jsr underflow_3
.9b64	b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b66	b5 03		lda $03,x	                lda 3,x
.9b68	95 05		sta $05,x	                sta 5,x
.9b6a	b5 01		lda $01,x	                lda 1,x
.9b6c	95 03		sta $03,x	                sta 3,x
.9b6e	94 01		sty $01,x	                sty 1,x
.9b70	b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b72	b5 02		lda $02,x	                lda 2,x
.9b74	95 04		sta $04,x	                sta 4,x
.9b76	b5 00		lda $00,x	                lda 0,x
.9b78	95 02		sta $02,x	                sta 2,x
.9b7a	94 00		sty $00,x	                sty 0,x
.9b7c	60		rts		z_rot:          rts
.9b7d					xt_rshift:
.9b7d	20 49 d8	jsr $d849	                jsr underflow_2
.9b80	b5 00		lda $00,x	                lda 0,x
.9b82	29 0f		and #$0f	                and #%00001111
.9b84	f0 08		beq $9b8e	                beq _done               ; if 0 shifts, quit
.9b86	a8		tay		                tay
.9b87					_loop:
.9b87	56 03		lsr $03,x	                lsr 3,x
.9b89	76 02		ror $02,x	                ror 2,x
.9b8b	88		dey		                dey
.9b8c	d0 f9		bne $9b87	                bne _loop
.9b8e					_done:
.9b8e	e8		inx		                inx
.9b8f	e8		inx		                inx
.9b90	60		rts		z_rshift:       rts
.9b91					xt_s_backslash_quote:
.9b91	a9 ff		lda #$ff	                lda #$FF
.9b93	85 26		sta $26		                sta tmp2
.9b95	64 27		stz $27		                stz tmp2+1
.9b97	20 5d 9d	jsr $9d5d	                jsr s_quote_start
.9b9a					_done:
.9b9a					z_s_backslash_quote:
.9b9a	60		rts		                rts
.9b9b					convert_hex_value:
.9b9b	c9 41		cmp #$41	        cmp #'A'
.9b9d	90 07		bcc $9ba6	        bcc _digit
.9b9f	29 df		and #$df	        and #$DF                ; Make it uppercase.
.9ba1	38		sec		        sec
.9ba2	e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9ba4	80 03		bra $9ba9	        bra _done
.9ba6					_digit:
.9ba6	38		sec		        sec
.9ba7	e9 30		sbc #$30	        sbc #'0'
.9ba9					_done:
.9ba9	60		rts		        rts
.9baa					xt_search_wordlist:
.9baa	20 4e d8	jsr $d84e	                jsr underflow_3
.9bad	a5 1e		lda $1e		                lda up
.9baf	18		clc		                clc
.9bb0	69 06		adc #$06	                adc #wordlists_offset
.9bb2	85 26		sta $26		                sta tmp2
.9bb4	a5 1f		lda $1f		                lda up+1
.9bb6	69 00		adc #$00	                adc #0          ; Adding carry
.9bb8	85 27		sta $27		                sta tmp2+1
.9bba	b5 00		lda $00,x	                lda 0,x
.9bbc	0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9bbd	65 26		adc $26		                adc tmp2
.9bbf	85 26		sta $26		                sta tmp2
.9bc1	90 02		bcc $9bc5	                bcc +
.9bc3	e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9bc5					+
.9bc5	e8		inx		                inx
.9bc6	e8		inx		                inx
.9bc7	b5 00		lda $00,x	                lda 0,x
.9bc9	15 01		ora $01,x	                ora 1,x
.9bcb	d0 03		bne $9bd0	                bne _check_wordlist
.9bcd	4c 88 9c	jmp $9c88	                jmp _done
.9bd0					_check_wordlist:
.9bd0	a5 26		lda $26		                lda tmp2
.9bd2	05 27		ora $27		                ora tmp2+1
.9bd4	d0 03		bne $9bd9	                bne _have_string
.9bd6	4c 88 9c	jmp $9c88	                jmp _done
.9bd9					_have_string:
.9bd9	b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9bdb	85 24		sta $24		                sta tmp1
.9bdd	e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9bdf	d0 02		bne $9be3	                bne +
.9be1	e6 27		inc $27		                inc tmp2+1
.9be3					+
.9be3	b2 26		lda ($26)	                lda (tmp2)
.9be5	85 25		sta $25		                sta tmp1+1
.9be7	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9be9	85 26		sta $26		                sta tmp2
.9beb	b5 03		lda $03,x	                lda 3,x
.9bed	85 27		sta $27		                sta tmp2+1
.9bef					_loop:
.9bef	b2 24		lda ($24)	                lda (tmp1)
.9bf1	d5 00		cmp $00,x	                cmp 0,x
.9bf3	d0 7b		bne $9c70	                bne _next_entry
.9bf5					_compare_string:
.9bf5	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9bf7	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bf9	b0 07		bcs $9c02	                bcs _compare_first
.9bfb	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bfd	90 03		bcc $9c02	                bcc _compare_first
.9bff	18		clc		                clc
.9c00	69 20		adc #$20	                adc #$20
.9c02					_compare_first:
.9c02	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9c04	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9c06	d0 68		bne $9c70	                bne _next_entry
.9c08	b5 00		lda $00,x	                lda 0,x
.9c0a	3a		dec a		                dea
.9c0b	f0 2c		beq $9c39	                beq _success
.9c0d	a5 24		lda $24		                lda tmp1
.9c0f	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9c10	18		clc		                clc
.9c11	69 08		adc #$08	                adc #8
.9c13	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9c15	a5 25		lda $25		                lda tmp1+1
.9c17	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9c18	69 00		adc #$00	                adc #0          ; we only need the carry
.9c1a	85 25		sta $25		                sta tmp1+1
.9c1c	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9c1e	88		dey		                dey
.9c1f					_string_loop:
.9c1f	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9c21	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9c23	b0 07		bcs $9c2c	                bcs _check_char
.9c25	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9c27	90 03		bcc $9c2c	                bcc _check_char
.9c29	18		clc		                clc
.9c2a	69 20		adc #$20	                adc #$20
.9c2c					_check_char:
.9c2c	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c2e	d0 3a		bne $9c6a	                bne _next_entry_tmp1
.9c30	88		dey		                dey
.9c31	d0 ec		bne $9c1f	                bne _string_loop
.9c33					_success_tmp1:
.9c33	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c34	85 25		sta $25		                sta tmp1+1
.9c36	68		pla		                pla
.9c37	85 24		sta $24		                sta tmp1
.9c39					_success:
.9c39	e8		inx		                inx
.9c3a	e8		inx		                inx
.9c3b	a5 24		lda $24		                lda tmp1
.9c3d	95 00		sta $00,x	                sta 0,x
.9c3f	a5 25		lda $25		                lda tmp1+1
.9c41	95 01		sta $01,x	                sta 1,x
.9c43	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( nt nt )
.9c46	20 eb 95	jsr $95eb	                jsr xt_name_to_int      ; ( nt xt )
.9c49	20 89 a1	jsr $a189	                jsr xt_swap             ; ( xt nt )
.9c4c	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c4e	f6 00		inc $00,x	                inc 0,x
.9c50	d0 02		bne $9c54	                bne +
.9c52	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c54					+
.9c54	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c56	29 04		and #$04	                and #IM
.9c58	d0 08		bne $9c62	                bne _immediate          ; bit set, we're immediate
.9c5a	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c5c	95 00		sta $00,x	                sta 0,x
.9c5e	95 01		sta $01,x	                sta 1,x
.9c60	80 28		bra $9c8a	                bra _done_nodrop
.9c62					_immediate:
.9c62	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c64	95 00		sta $00,x	                sta 0,x
.9c66	74 01		stz $01,x	                stz 1,x
.9c68	80 20		bra $9c8a	                bra _done_nodrop
.9c6a					_next_entry_tmp1:
.9c6a	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c6b	85 25		sta $25		                sta tmp1+1
.9c6d	68		pla		                pla
.9c6e	85 24		sta $24		                sta tmp1
.9c70					_next_entry:
.9c70	a0 02		ldy #$02	                ldy #2
.9c72	b1 24		lda ($24),y	                lda (tmp1),y
.9c74	48		pha		                pha
.9c75	c8		iny		                iny
.9c76	b1 24		lda ($24),y	                lda (tmp1),y
.9c78	85 25		sta $25		                sta tmp1+1
.9c7a	68		pla		                pla
.9c7b	85 24		sta $24		                sta tmp1
.9c7d	05 25		ora $25		                ora tmp1+1
.9c7f	f0 03		beq $9c84	                beq _fail_done
.9c81	4c ef 9b	jmp $9bef	                jmp _loop
.9c84					_fail_done:
.9c84	74 02		stz $02,x	                stz 2,x         ; failure flag
.9c86	74 03		stz $03,x	                stz 3,x
.9c88					_done:
.9c88	e8		inx		                inx
.9c89	e8		inx		                inx
.9c8a					_done_nodrop:
.9c8a					z_search_wordlist:
.9c8a	60		rts		                rts
.9c8b					xt_see:
.9c8b	20 e9 98	jsr $98e9	                jsr xt_parse_name       ; ( addr u )
.9c8e	20 e4 8f	jsr $8fe4	                jsr xt_find_name        ; ( nt | 0 )
.9c91	b5 00		lda $00,x	                lda 0,x
.9c93	15 01		ora $01,x	                ora 1,x
.9c95	d0 05		bne $9c9c	                bne +
.9c97	a9 05		lda #$05	                lda #err_noname
.9c99	4c 5a d8	jmp $d85a	                jmp error
.9c9c					+
.9c9c	20 80 89	jsr $8980	                jsr xt_cr
.9c9f	a5 18		lda $18		                lda base
.9ca1	48		pha		                pha
.9ca2	20 86 91	jsr $9186	                jsr xt_hex
.9ca5	a9 09		lda #$09	                lda #str_see_nt
.9ca7	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9caa	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( nt nt )
.9cad	20 09 a5	jsr $a509	                jsr xt_u_dot
.9cb0	20 f9 a0	jsr $a0f9	                jsr xt_space            ; ( nt )
.9cb3	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( nt nt )
.9cb6	20 eb 95	jsr $95eb	                jsr xt_name_to_int      ; ( nt xt )
.9cb9	a9 0a		lda #$0a	                lda #str_see_xt
.9cbb	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9cbe	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( nt xt xt )
.9cc1	20 09 a5	jsr $a509	                jsr xt_u_dot
.9cc4	20 80 89	jsr $8980	                jsr xt_cr               ; ( nt xt )
.9cc7	a9 08		lda #$08	                lda #str_see_flags
.9cc9	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9ccc	20 9d 98	jsr $989d	                jsr xt_over             ; ( nt xt nt )
.9ccf	20 27 98	jsr $9827	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9cd2	20 89 8f	jsr $8f89	                jsr xt_fetch            ; ( nt xt flags )
.9cd5	b5 00		lda $00,x	                lda 0,x
.9cd7	a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9cd9					_flag_loop:
.9cd9	48		pha		                pha
.9cda	29 01		and #$01	                and #%00000001
.9cdc	18		clc		                clc
.9cdd	69 30		adc #$30	                adc #$30                ; ASCII "0"
.9cdf	20 ff 8d	jsr $8dff	                jsr emit_a
.9ce2	20 f9 a0	jsr $a0f9	                jsr xt_space
.9ce5	68		pla		                pla
.9ce6	6a		ror a		                ror                     ; Next flag
.9ce7	88		dey		                dey
.9ce8	d0 ef		bne $9cd9	                bne _flag_loop
.9cea	20 80 89	jsr $8980	                jsr xt_cr
.9ced	e8		inx		                inx
.9cee	e8		inx		                inx                     ; ( nt xt )
.9cef	a9 0b		lda #$0b	                lda #str_see_size
.9cf1	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9cf4	20 89 a1	jsr $a189	                jsr xt_swap             ; ( xt nt )
.9cf7	20 50 a7	jsr $a750	                jsr xt_wordsize         ; ( xt u )
.9cfa	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9cfd	20 c2 8a	jsr $8ac2	                jsr xt_decimal
.9d00	20 09 a5	jsr $a509	                jsr xt_u_dot            ; ( xt u )
.9d03	20 86 91	jsr $9186	                jsr xt_hex
.9d06	20 80 89	jsr $8980	                jsr xt_cr
.9d09	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( xt u xt u )
.9d0c	20 3d 8d	jsr $8d3d	                jsr xt_dump
.9d0f	20 80 89	jsr $8980	                jsr xt_cr
.9d12	20 57 8b	jsr $8b57	                jsr xt_disasm
.9d15	68		pla		                pla
.9d16	85 18		sta $18		                sta base
.9d18	60		rts		z_see:          rts
.9d19					xt_set_current:
.9d19	20 44 d8	jsr $d844	                jsr underflow_1
.9d1c	a0 04		ldy #$04	                ldy #current_offset
.9d1e	b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9d20	91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9d22	e8		inx		                inx
.9d23	e8		inx		                inx
.9d24	60		rts		z_set_current:  rts
.9d25					xt_set_order:
.9d25	a9 ff		lda #$ff	                lda #$FF
.9d27	d5 01		cmp $01,x	                cmp 1,x
.9d29	d0 12		bne $9d3d	                bne _start
.9d2b	d5 00		cmp $00,x	                cmp 0,x
.9d2d	d0 0e		bne $9d3d	                bne _start
.9d2f	ca		dex		                dex             ; Make room for the count.
.9d30	ca		dex		                dex
.9d31	74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d33	a9 03		lda #$03	                lda #3
.9d35	95 02		sta $02,x	                sta 2,x
.9d37	74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d39	a9 01		lda #$01	                lda #1
.9d3b	95 00		sta $00,x	                sta 0,x
.9d3d					_start:
.9d3d	a0 1e		ldy #$1e	                ldy #num_order_offset
.9d3f	b5 00		lda $00,x	                lda 0,x
.9d41	91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d43	85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d45	e8		inx		                inx             ; Drop the count off the data stack.
.9d46	e8		inx		                inx
.9d47	a5 24		lda $24		                lda tmp1
.9d49	f0 0d		beq $9d58	                beq _done       ; If zero, there are no wordlists.
.9d4b	a0 1f		ldy #$1f	                ldy #search_order_offset
.9d4d					_loop:
.9d4d	b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d4f	91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d51	c8		iny		                iny
.9d52	e8		inx		                inx
.9d53	e8		inx		                inx
.9d54	c6 24		dec $24		                dec tmp1
.9d56	d0 f5		bne $9d4d	                bne _loop
.9d58					_done:
.9d58	60		rts		z_set_order:    rts
.9d59					xt_s_quote:
.9d59	64 26		stz $26		                stz tmp2
.9d5b	64 27		stz $27		                stz tmp2+1
.9d5d					s_quote_start:
.9d5d	ca		dex		                dex
.9d5e	ca		dex		                dex
.9d5f	ca		dex		                dex
.9d60	ca		dex		                dex
.9d61	a9 4c		lda #$4c	                lda #$4C
.9d63	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9d66	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9d69	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9d6c	a5 00		lda $00		                lda cp
.9d6e	95 02		sta $02,x	                sta 2,x
.9d70	a5 01		lda $01		                lda cp+1
.9d72	95 03		sta $03,x	                sta 3,x
.9d74					_savechars_loop:
.9d74	a5 0d		lda $0d		                lda toin+1              ; MSB
.9d76	c5 0b		cmp $0b		                cmp ciblen+1
.9d78	90 2a		bcc $9da4	                bcc _input_fine         ; unsigned comparison
.9d7a	a5 0c		lda $0c		                lda toin                ; LSB
.9d7c	c5 0a		cmp $0a		                cmp ciblen
.9d7e	90 24		bcc $9da4	                bcc _input_fine
.9d80	a5 26		lda $26		                lda tmp2
.9d82	48		pha		                pha
.9d83	a5 27		lda $27		                lda tmp2+1
.9d85	48		pha		                pha
.9d86	a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d88	48		pha		                pha
.9d89	20 02 9b	jsr $9b02	                jsr xt_refill           ; ( -- f )
.9d8c	68		pla		                pla
.9d8d	85 28		sta $28		                sta tmp3
.9d8f	68		pla		                pla
.9d90	85 27		sta $27		                sta tmp2+1
.9d92	68		pla		                pla
.9d93	85 26		sta $26		                sta tmp2
.9d95	b5 00		lda $00,x	                lda 0,x
.9d97	15 01		ora $01,x	                ora 1,x
.9d99	d0 05		bne $9da0	                bne _refill_ok
.9d9b	a9 06		lda #$06	                lda #err_refill
.9d9d	4c 5a d8	jmp $d85a	                jmp error
.9da0					_refill_ok:
.9da0	e8		inx		                inx
.9da1	e8		inx		                inx
.9da2	80 d0		bra $9d74	                bra _savechars_loop
.9da4					_input_fine:
.9da4	a5 08		lda $08		                lda cib
.9da6	18		clc		                clc
.9da7	65 0c		adc $0c		                adc toin        ; LSB
.9da9	85 24		sta $24		                sta tmp1
.9dab	a5 09		lda $09		                lda cib+1
.9dad	65 0d		adc $0d		                adc toin+1      ; MSB
.9daf	85 25		sta $25		                sta tmp1+1
.9db1	b2 24		lda ($24)	                lda (tmp1)
.9db3	24 26		bit $26		                bit tmp2
.9db5	30 03		bmi $9dba	                bmi _handle_escapes    ; Only checking bit 7
.9db7	4c 43 9e	jmp $9e43	                jmp _regular_char
.9dba					_handle_escapes:
.9dba	24 27		bit $27		                bit tmp2+1
.9dbc	30 03		bmi $9dc1	                bmi _escaped
.9dbe	4c 39 9e	jmp $9e39	                jmp _not_escaped
.9dc1					_escaped:
.9dc1	70 3c		bvs $9dff	                bvs _check_esc_chars
.9dc3	a9 01		lda #$01	                lda #1
.9dc5	24 27		bit $27		                bit tmp2+1
.9dc7	d0 10		bne $9dd9	                bne _esc_x_second_digit
.9dc9	e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9dcb	b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9dcd	20 9b 9b	jsr $9b9b	                jsr convert_hex_value
.9dd0	0a		asl a		                asl
.9dd1	0a		asl a		                asl
.9dd2	0a		asl a		                asl
.9dd3	0a		asl a		                asl
.9dd4	85 28		sta $28		                sta tmp3    ; Save it for later.
.9dd6	4c 4a 9e	jmp $9e4a	                jmp _next_character
.9dd9					_esc_x_second_digit:
.9dd9	64 27		stz $27		                stz tmp2+1
.9ddb	b2 24		lda ($24)	                lda (tmp1)
.9ddd	20 9b 9b	jsr $9b9b	                jsr convert_hex_value
.9de0	05 28		ora $28		                ora tmp3
.9de2	4c 47 9e	jmp $9e47	                jmp _save_character
.9de5					_esc_tr_table:
>9de5	07				    .byte   7               ; a -> BEL (ASCII value 7)
>9de6	08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9de7	00 00				    .byte   0,0             ; c, d no escape
>9de9	1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9dea	0c				    .byte   12              ; f -> FF (ASCII value 12)
>9deb	00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9df0	0a				    .byte   10              ; l -> LF (ASCII value 10)
>9df1	8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9df2	0a				    .byte   10              ; n behaves like l --> lf
>9df3	00 00				    .byte   0,0             ; o,p
>9df5	22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9df6	0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9df7	00				    .byte   0               ; s
>9df8	09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9df9	00				    .byte   0               ; u
>9dfa	0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9dfb	00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9dfe	80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9dff					_check_esc_chars:
.9dff	64 27		stz $27		                stz tmp2+1
.9e01	c9 61		cmp #$61	                cmp #'a'
.9e03	30 1a		bmi $9e1f	                bmi _check_esc_quote
.9e05	c9 7b		cmp #$7b	                cmp #'z'+1
.9e07	10 16		bpl $9e1f	                bpl _check_esc_quote
.9e09	a8		tay		                tay
.9e0a	b9 84 9d	lda $9d84,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9e0d	d0 03		bne $9e12	                bne _esc_replace
.9e0f	98		tya		                tya                     ; revert if no translation
.9e10	80 0d		bra $9e1f	                bra _check_esc_quote
.9e12	10 33		bpl $9e47	_esc_replace:   bpl _save_character     ; simple replacement
.9e14	29 7f		and #$7f	                and #$7f                ; clear hi bit
.9e16	f0 2f		beq $9e47	                beq _save_character     ; NUL we can just output
.9e18	20 f7 d6	jsr $d6f7	                jsr cmpl_a              ; else output first char (CR)
.9e1b	a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9e1d	80 28		bra $9e47	                bra _save_character
.9e1f					_check_esc_quote:
.9e1f	c9 22		cmp #$22	                cmp #$22
.9e21	d0 04		bne $9e27	                bne _check_esc_x
.9e23	a9 22		lda #$22	                lda #34
.9e25	80 20		bra $9e47	                bra _save_character
.9e27					_check_esc_x:
.9e27	c9 78		cmp #$78	                cmp #'x'
.9e29	d0 06		bne $9e31	                bne _check_esc_backslash
.9e2b	a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e2d	85 27		sta $27		                sta tmp2+1
.9e2f	80 19		bra $9e4a	                bra _next_character
.9e31					_check_esc_backslash:
.9e31	c9 5c		cmp #$5c	                cmp #$5C
.9e33	d0 04		bne $9e39	                bne _not_escaped
.9e35	a9 5c		lda #$5c	                lda #92
.9e37	80 0e		bra $9e47	                bra _save_character
.9e39					_not_escaped:
.9e39	c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e3b	d0 06		bne $9e43	                bne _regular_char
.9e3d	a9 ff		lda #$ff	                lda #$FF
.9e3f	85 27		sta $27		                sta tmp2+1
.9e41	80 07		bra $9e4a	                bra _next_character
.9e43					_regular_char:
.9e43	c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e45	f0 0c		beq $9e53	                beq _found_string_end
.9e47					_save_character:
.9e47	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9e4a					_next_character:
.9e4a	e6 0c		inc $0c		                inc toin
.9e4c	d0 02		bne $9e50	                bne _savechars_loop_longjump
.9e4e	e6 0d		inc $0d		                inc toin+1
.9e50					_savechars_loop_longjump:
.9e50	4c 74 9d	jmp $9d74	                jmp _savechars_loop
.9e53					_found_string_end:
.9e53	e6 0c		inc $0c		                inc toin
.9e55	d0 02		bne $9e59	                bne +
.9e57	e6 0d		inc $0d		                inc toin+1
.9e59					+
.9e59	a5 00		lda $00		                lda cp
.9e5b	38		sec		                sec
.9e5c	f5 02		sbc $02,x	                sbc 2,x
.9e5e	95 00		sta $00,x	                sta 0,x         ; LSB
.9e60	a5 01		lda $01		                lda cp+1
.9e62	f5 03		sbc $03,x	                sbc 3,x
.9e64	95 01		sta $01,x	                sta 1,x         ; MSB
.9e66	b5 02		lda $02,x	                lda 2,x
.9e68	38		sec		                sec
.9e69	e9 02		sbc #$02	                sbc #2
.9e6b	85 24		sta $24		                sta tmp1
.9e6d	b5 03		lda $03,x	                lda 3,x
.9e6f	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e71	85 25		sta $25		                sta tmp1+1
.9e73	a5 00		lda $00		                lda cp
.9e75	92 24		sta ($24)	                sta (tmp1)
.9e77	a0 01		ldy #$01	                ldy #1
.9e79	a5 01		lda $01		                lda cp+1
.9e7b	91 24		sta ($24),y	                sta (tmp1),y
.9e7d	a5 16		lda $16		                lda state
.9e7f	05 17		ora $17		                ora state+1             ; paranoid
.9e81	f0 03		beq $9e86	                beq _done
.9e83	20 6a a0	jsr $a06a	                jsr sliteral_const_str         ; ( addr u -- )
.9e86					_done:
.9e86	60		rts		z_s_quote:      rts
.9e87					xt_s_to_d:
.9e87	20 44 d8	jsr $d844	                jsr underflow_1
.9e8a	ca		dex		                dex
.9e8b	ca		dex		                dex
.9e8c	74 00		stz $00,x	                stz 0,x
.9e8e	74 01		stz $01,x	                stz 1,x
.9e90	b5 03		lda $03,x	                lda 3,x
.9e92	10 04		bpl $9e98	                bpl _done
.9e94	d6 00		dec $00,x	                dec 0,x
.9e96	d6 01		dec $01,x	                dec 1,x
.9e98					_done:
.9e98	60		rts		z_s_to_d:       rts
.9e99					xt_save_buffers:
.9e99	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e9b	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9e9d	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9e9f	d0 12		bne $9eb3	                bne _done       ; Either not used or not dirty = done!
.9ea1	20 bf 83	jsr $83bf	                jsr xt_blkbuffer
.9ea4	20 b1 85	jsr $85b1	                jsr xt_buffblocknum
.9ea7	20 89 8f	jsr $8f89	                jsr xt_fetch
.9eaa	20 6c 85	jsr $856c	                jsr xt_block_write
.9ead	a9 01		lda #$01	                lda #1
.9eaf	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9eb1	91 1e		sta ($1e),y	                sta (up),y
.9eb3					_done:
.9eb3	60		rts		z_save_buffers: rts
.9eb4					xt_scr:
.9eb4	ca		dex		                dex
.9eb5	ca		dex		                dex
.9eb6	18		clc		                clc
.9eb7	a5 1e		lda $1e		                lda up
.9eb9	69 02		adc #$02	                adc #scr_offset ; Add offset
.9ebb	95 00		sta $00,x	                sta 0,x
.9ebd	a5 1f		lda $1f		                lda up+1
.9ebf	69 00		adc #$00	                adc #0          ; Adding carry
.9ec1	95 01		sta $01,x	                sta 1,x
.9ec3	60		rts		z_scr:          rts
.9ec4					xt_search:
.9ec4	20 53 d8	jsr $d853	                jsr underflow_4
.9ec7	b5 00		lda $00,x	                lda 0,x
.9ec9	15 01		ora $01,x	                ora 1,x
.9ecb	d0 0b		bne $9ed8	                bne _start_search
.9ecd	e8		inx		                inx             ; Remove u2
.9ece	e8		inx		                inx
.9ecf	a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ed1	95 00		sta $00,x	                sta 0,x
.9ed3	95 01		sta $01,x	                sta 1,x
.9ed5	4c 62 9f	jmp $9f62	                jmp z_search
.9ed8					_start_search:
.9ed8	20 83 a7	jsr $a783	                jsr xt_zero
.9edb					_search_loop:
.9edb	18		clc		                clc
.9edc	b5 00		lda $00,x	                lda 0,x
.9ede	75 02		adc $02,x	                adc 2,x
.9ee0	85 24		sta $24		                sta tmp1
.9ee2	b5 01		lda $01,x	                lda 1,x
.9ee4	75 03		adc $03,x	                adc 3,x
.9ee6	d5 07		cmp $07,x	                cmp 7,x
.9ee8	90 12		bcc $9efc	                bcc _init_comparison ; Obviously less
.9eea	d0 06		bne $9ef2	                bne _not_found
.9eec	b5 06		lda $06,x	                lda 6,x
.9eee	c5 24		cmp $24		                cmp tmp1
.9ef0	b0 0a		bcs $9efc	                bcs _init_comparison
.9ef2					_not_found:
.9ef2	e8		inx		                inx             ; Remove offset
.9ef3	e8		inx		                inx
.9ef4	e8		inx		                inx             ; Remove u2
.9ef5	e8		inx		                inx
.9ef6	74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9ef8	74 01		stz $01,x	                stz 1,x
.9efa	80 66		bra $9f62	                bra z_search
.9efc					_init_comparison:
.9efc	18		clc		                clc
.9efd	b5 08		lda $08,x	                lda 8,x
.9eff	75 00		adc $00,x	                adc 0,x
.9f01	85 24		sta $24		                sta tmp1
.9f03	b5 09		lda $09,x	                lda 9,x
.9f05	75 01		adc $01,x	                adc 1,x
.9f07	85 25		sta $25		                sta tmp1+1
.9f09	b5 04		lda $04,x	                lda 4,x
.9f0b	85 26		sta $26		                sta tmp2
.9f0d	b5 05		lda $05,x	                lda 5,x
.9f0f	85 27		sta $27		                sta tmp2+1
.9f11	b5 02		lda $02,x	                lda 2,x
.9f13	85 28		sta $28		                sta tmp3
.9f15	b5 03		lda $03,x	                lda 3,x
.9f17	85 29		sta $29		                sta tmp3+1
.9f19					_comparison_loop:
.9f19	b2 24		lda ($24)	                lda (tmp1)
.9f1b	d2 26		cmp ($26)	                cmp (tmp2)
.9f1d	f0 05		beq $9f24	                beq _letters_match
.9f1f	20 27 98	jsr $9827	                jsr xt_one_plus
.9f22	80 b7		bra $9edb	                bra _search_loop
.9f24					_letters_match:
.9f24	e6 24		inc $24		                inc tmp1
.9f26	d0 02		bne $9f2a	                bne +
.9f28	e6 25		inc $25		                inc tmp1+1
.9f2a					+
.9f2a	e6 26		inc $26		                inc tmp2
.9f2c	d0 02		bne $9f30	                bne +
.9f2e	e6 27		inc $27		                inc tmp2+1
.9f30					+
.9f30	a5 28		lda $28		                lda tmp3
.9f32	d0 02		bne $9f36	                bne +
.9f34	c6 29		dec $29		                dec tmp3+1
.9f36					+
.9f36	c6 28		dec $28		                dec tmp3
.9f38	a5 28		lda $28		                lda tmp3
.9f3a	05 29		ora $29		                ora tmp3+1
.9f3c	d0 db		bne $9f19	                bne _comparison_loop ; Check the next letter
.9f3e	18		clc		                clc
.9f3f	b5 00		lda $00,x	                lda 0,x
.9f41	75 08		adc $08,x	                adc 8,x
.9f43	95 08		sta $08,x	                sta 8,x
.9f45	b5 01		lda $01,x	                lda 1,x
.9f47	75 09		adc $09,x	                adc 9,x
.9f49	95 09		sta $09,x	                sta 9,x
.9f4b	38		sec		                sec
.9f4c	b5 06		lda $06,x	                lda 6,x
.9f4e	f5 00		sbc $00,x	                sbc 0,x
.9f50	95 06		sta $06,x	                sta 6,x
.9f52	b5 07		lda $07,x	                lda 7,x
.9f54	f5 01		sbc $01,x	                sbc 1,x
.9f56	95 07		sta $07,x	                sta 7,x
.9f58	e8		inx		                inx             ; drop offset
.9f59	e8		inx		                inx
.9f5a	e8		inx		                inx             ; drop u2
.9f5b	e8		inx		                inx
.9f5c	a9 ff		lda #$ff	                lda #$FF
.9f5e	95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f60	95 01		sta $01,x	                sta 1,x
.9f62	60		rts		z_search:       rts
.9f63					xt_semicolon:
.9f63	24 20		bit $20		                bit status
.9f65	70 11		bvs $9f78	                bvs _colonword
.9f67	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f69	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9f6c	ca		dex		                dex
.9f6d	ca		dex		                dex
.9f6e	a5 04		lda $04		                lda workword
.9f70	95 00		sta $00,x	                sta 0,x
.9f72	a5 05		lda $05		                lda workword+1
.9f74	95 01		sta $01,x	                sta 1,x
.9f76	80 45		bra $9fbd	                bra _semicolon_done
.9f78					_colonword:
.9f78	a0 06		ldy #$06	                ldy #6
.9f7a	a5 00		lda $00		                lda cp
.9f7c	91 04		sta ($04),y	                sta (workword),y
.9f7e	c8		iny		                iny
.9f7f	a5 01		lda $01		                lda cp+1
.9f81	91 04		sta ($04),y	                sta (workword),y
.9f83	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f85	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9f88	24 20		bit $20		                bit status
.9f8a	10 26		bpl $9fb2	                bpl _new_word   ; Bit 7 is clear = new word
.9f8c	ca		dex		                dex
.9f8d	ca		dex		                dex
.9f8e	ca		dex		                dex
.9f8f	ca		dex		                dex
.9f90	b2 04		lda ($04)	                lda (workword)
.9f92	95 00		sta $00,x	                sta 0,x
.9f94	74 01		stz $01,x	                stz 1,x
.9f96	a5 04		lda $04		                lda workword
.9f98	18		clc		                clc
.9f99	69 08		adc #$08	                adc #8
.9f9b	95 02		sta $02,x	                sta 2,x
.9f9d	a5 05		lda $05		                lda workword+1
.9f9f	69 00		adc #$00	                adc #0                  ; only want carry
.9fa1	95 03		sta $03,x	                sta 3,x
.9fa3	a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9fa5	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9fa8	20 de a4	jsr $a4de	                jsr xt_type
.9fab	20 f9 a0	jsr $a0f9	                jsr xt_space
.9fae	a9 80		lda #$80	                lda #%10000000
.9fb0	14 20		trb $20		                trb status
.9fb2					_new_word:
.9fb2	a5 04		lda $04		                lda workword
.9fb4	85 02		sta $02		                sta dp
.9fb6	a5 05		lda $05		                lda workword+1
.9fb8	85 03		sta $03		                sta dp+1
.9fba	20 99 d7	jsr $d799	                jsr dp_to_current       ; Save the updated DP to the
.9fbd					_semicolon_done:
.9fbd	64 16		stz $16		                stz state
.9fbf	64 17		stz $17		                stz state+1
.9fc1	60		rts		z_semicolon:    rts
.9fc2					xt_sign:
.9fc2	20 44 d8	jsr $d844	                jsr underflow_1
.9fc5	b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9fc7	30 04		bmi $9fcd	                bmi _minus
.9fc9	e8		inx		                inx
.9fca	e8		inx		                inx
.9fcb	80 09		bra $9fd6	                bra _done
.9fcd					_minus:
.9fcd	a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9fcf	95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9fd1	74 01		stz $01,x	                stz 1,x         ; paranoid
.9fd3	20 e0 91	jsr $91e0	                jsr xt_hold
.9fd6					_done:
.9fd6	60		rts		z_sign:         rts
.9fd7					xt_slash:
.9fd7	a9 00		lda #$00	                lda #0
.9fd9	48		pha		                pha
.9fda	80 03		bra $9fdf	                bra slashmod_common
.9fdc					xt_slash_mod:
.9fdc	a9 ff		lda #$ff	                lda #$FF
.9fde	48		pha		                pha             ; falls through to _common
.9fdf					slashmod_common:
.9fdf	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R
.9fe2	20 87 9e	jsr $9e87	                jsr xt_s_to_d           ; S>D
.9fe5	20 9c 9a	jsr $9a9c	                jsr xt_r_from           ; R>
.9fe8	20 b0 a0	jsr $a0b0	                jsr xt_sm_slash_rem     ; SM/REM
.9feb	68		pla		                pla
.9fec	d0 05		bne $9ff3	                bne _done
.9fee	20 89 a1	jsr $a189	                jsr xt_swap
.9ff1	e8		inx		                inx             ; DROP
.9ff2	e8		inx		                inx
.9ff3					_done:
.9ff3					z_slash_mod:
.9ff3	60		rts		z_slash:        rts
.9ff4					xt_slash_string:
.9ff4	20 4e d8	jsr $d84e	                jsr underflow_3
.9ff7	18		clc		                clc             ; 3OS+TOS
.9ff8	b5 00		lda $00,x	                lda 0,x
.9ffa	75 04		adc $04,x	                adc 4,x
.9ffc	95 04		sta $04,x	                sta 4,x
.9ffe	b5 01		lda $01,x	                lda 1,x
.a000	75 05		adc $05,x	                adc 5,x
.a002	95 05		sta $05,x	                sta 5,x
.a004	38		sec		                sec             ; NOS-TOS
.a005	b5 02		lda $02,x	                lda 2,x
.a007	f5 00		sbc $00,x	                sbc 0,x
.a009	95 02		sta $02,x	                sta 2,x
.a00b	b5 03		lda $03,x	                lda 3,x
.a00d	f5 01		sbc $01,x	                sbc 1,x
.a00f	95 03		sta $03,x	                sta 3,x
.a011	e8		inx		                inx
.a012	e8		inx		                inx
.a013	60		rts		z_slash_string: rts
.a014					xt_sliteral:
.a014	20 49 d8	jsr $d849	                jsr underflow_2
.a017	a9 4c		lda #$4c	                lda #$4C
.a019	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a01c	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a01f	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a022	8a		txa		                txa
.a023	38		sec		                sec
.a024	e9 06		sbc #$06	                sbc #6
.a026	aa		tax		                tax
.a027	b5 08		lda $08,x	                lda 8,x
.a029	95 04		sta $04,x	                sta 4,x
.a02b	b5 09		lda $09,x	                lda 9,x
.a02d	95 05		sta $05,x	                sta 5,x
.a02f	b5 06		lda $06,x	                lda 6,x
.a031	95 00		sta $00,x	                sta 0,x
.a033	b5 07		lda $07,x	                lda 7,x
.a035	95 01		sta $01,x	                sta 1,x
.a037	a5 00		lda $00		                lda cp
.a039	95 08		sta $08,x	                sta 8,x
.a03b	95 02		sta $02,x	                sta 2,x
.a03d	a5 01		lda $01		                lda cp+1
.a03f	95 09		sta $09,x	                sta 9,x
.a041	95 03		sta $03,x	                sta 3,x
.a043	20 cc 95	jsr $95cc	                jsr xt_move
.a046	18		clc		                clc
.a047	a5 00		lda $00		                lda cp
.a049	75 00		adc $00,x	                adc 0,x
.a04b	85 00		sta $00		                sta cp
.a04d	a5 01		lda $01		                lda cp+1
.a04f	75 01		adc $01,x	                adc 1,x
.a051	85 01		sta $01		                sta cp+1
.a053	b5 02		lda $02,x	                lda 2,x
.a055	38		sec		                sec
.a056	e9 02		sbc #$02	                sbc #2
.a058	85 24		sta $24		                sta tmp1
.a05a	b5 03		lda $03,x	                lda 3,x
.a05c	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a05e	85 25		sta $25		                sta tmp1+1
.a060	a5 00		lda $00		                lda cp
.a062	92 24		sta ($24)	                sta (tmp1)
.a064	a0 01		ldy #$01	                ldy #1
.a066	a5 01		lda $01		                lda cp+1
.a068	91 24		sta ($24),y	                sta (tmp1),y
.a06a					sliteral_const_str:
.a06a	a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a06c	a9 84		lda #$84	                lda #<sliteral_runtime
.a06e	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.a071	b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a073	b5 02		lda $02,x	                lda 2,x                ; address LSB
.a075	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a078	b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a07a	b5 00		lda $00,x	                lda 0,x                ; length LSB
.a07c	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a07f	e8		inx		                inx
.a080	e8		inx		                inx
.a081	e8		inx		                inx
.a082	e8		inx		                inx
.a083	60		rts		z_sliteral:     rts
.a084					sliteral_runtime:
.a084	ca		dex		                dex
.a085	ca		dex		                dex
.a086	ca		dex		                dex
.a087	ca		dex		                dex
.a088	68		pla		                pla
.a089	85 24		sta $24		                sta tmp1        ; LSB of address
.a08b	68		pla		                pla
.a08c	85 25		sta $25		                sta tmp1+1      ; MSB of address
.a08e	a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a090	b1 24		lda ($24),y	                lda (tmp1),y
.a092	95 02		sta $02,x	                sta 2,x         ; LSB of address
.a094	c8		iny		                iny
.a095	b1 24		lda ($24),y	                lda (tmp1),y
.a097	95 03		sta $03,x	                sta 3,x         ; MSB of address
.a099	c8		iny		                iny
.a09a	b1 24		lda ($24),y	                lda (tmp1),y
.a09c	95 00		sta $00,x	                sta 0,x         ; LSB of length
.a09e	c8		iny		                iny
.a09f	b1 24		lda ($24),y	                lda (tmp1),y
.a0a1	95 01		sta $01,x	                sta 1,x         ; MSB of length
.a0a3	18		clc		                clc
.a0a4	a5 24		lda $24		                lda tmp1
.a0a6	69 04		adc #$04	                adc #4
.a0a8	a8		tay		                tay             ; LSB
.a0a9	a5 25		lda $25		                lda tmp1+1
.a0ab	69 00		adc #$00	                adc #0          ; we only need carry
.a0ad	48		pha		                pha             ; MSB
.a0ae	5a		phy		                phy
.a0af	60		rts		                rts
.a0b0					xt_sm_slash_rem:
.a0b0	20 4e d8	jsr $d84e	                jsr underflow_3 ; contains double number
.a0b3	b5 03		lda $03,x	                lda 3,x
.a0b5	48		pha		                pha
.a0b6	b5 01		lda $01,x	                lda 1,x
.a0b8	55 03		eor $03,x	                eor 3,x
.a0ba	48		pha		                pha
.a0bb	20 23 81	jsr $8123	                jsr xt_abs
.a0be	e8		inx		                inx             ; pretend we pushed n1 to R
.a0bf	e8		inx		                inx
.a0c0	20 a3 8a	jsr $8aa3	                jsr xt_dabs
.a0c3	ca		dex		                dex
.a0c4	ca		dex		                dex
.a0c5	20 95 a5	jsr $a595	                jsr xt_um_slash_mod     ; UM/MOD
.a0c8	68		pla		                pla
.a0c9	10 03		bpl $a0ce	                bpl +
.a0cb	20 2d 96	jsr $962d	                jsr xt_negate
.a0ce					+
.a0ce	68		pla		                pla
.a0cf	10 07		bpl $a0d8	                bpl _done
.a0d1	e8		inx		                inx             ; pretend we pushed quotient to R
.a0d2	e8		inx		                inx
.a0d3	20 2d 96	jsr $962d	                jsr xt_negate
.a0d6	ca		dex		                dex
.a0d7	ca		dex		                dex
.a0d8					_done:
.a0d8	60		rts		z_sm_slash_rem: rts
.a0d9					xt_source:
.a0d9	ca		dex		                dex
.a0da	ca		dex		                dex
.a0db	a5 08		lda $08		                lda cib
.a0dd	95 00		sta $00,x	                sta 0,x
.a0df	a5 09		lda $09		                lda cib+1
.a0e1	95 01		sta $01,x	                sta 1,x
.a0e3	ca		dex		                dex
.a0e4	ca		dex		                dex
.a0e5	a5 0a		lda $0a		                lda ciblen
.a0e7	95 00		sta $00,x	                sta 0,x
.a0e9	a5 0b		lda $0b		                lda ciblen+1
.a0eb	95 01		sta $01,x	                sta 1,x
.a0ed	60		rts		z_source:       rts
.a0ee					xt_source_id:
.a0ee	ca		dex		                dex
.a0ef	ca		dex		                dex
.a0f0	a5 06		lda $06		                lda insrc
.a0f2	95 00		sta $00,x	                sta 0,x
.a0f4	a5 07		lda $07		                lda insrc+1
.a0f6	95 01		sta $01,x	                sta 1,x
.a0f8	60		rts		z_source_id:    rts
.a0f9					xt_space:
.a0f9	a9 20		lda #$20	                lda #AscSP
.a0fb	20 ff 8d	jsr $8dff	                jsr emit_a
.a0fe	60		rts		z_space:        rts
.a0ff					xt_spaces:
.a0ff	20 44 d8	jsr $d844	                jsr underflow_1
.a102	20 83 a7	jsr $a783	                jsr xt_zero
.a105	20 22 95	jsr $9522	                jsr xt_max
.a108	b5 00		lda $00,x	                lda 0,x
.a10a	15 01		ora $01,x	                ora 1,x
.a10c	f0 2a		beq $a138	                beq _done
.a10e	b4 01		ldy $01,x	                ldy 1,x
.a110	d0 0c		bne $a11e	                bne _lots_of_spaces
.a112	b4 00		ldy $00,x	                ldy 0,x
.a114					_quick_loop:
.a114	a9 20		lda #$20	                lda #AscSP
.a116	20 ff 8d	jsr $8dff	                jsr emit_a
.a119	88		dey		                dey
.a11a	f0 1c		beq $a138	                beq _done
.a11c	80 f6		bra $a114	                bra _quick_loop
.a11e					_lots_of_spaces:
.a11e	b4 00		ldy $00,x	                ldy 0,x
.a120					_first_slow_loop:
.a120	f0 08		beq $a12a	                beq _slow_outer_loop
.a122	a9 20		lda #$20	                lda #AscSP
.a124	20 ff 8d	jsr $8dff	                jsr emit_a
.a127	88		dey		                dey
.a128	80 f6		bra $a120	                bra _first_slow_loop
.a12a					_slow_outer_loop:
.a12a	a0 00		ldy #$00	                ldy #00
.a12c					_slow_inner_loop:
.a12c	a9 20		lda #$20	                lda #AscSP
.a12e	20 ff 8d	jsr $8dff	                jsr emit_a
.a131	88		dey		                dey
.a132	d0 f8		bne $a12c	                bne _slow_inner_loop
.a134	d6 01		dec $01,x	                dec 1,x
.a136	d0 f2		bne $a12a	                bne _slow_outer_loop
.a138					_done:
.a138	e8		inx		                inx             ; drop
.a139	e8		inx		                inx
.a13a	60		rts		z_spaces:       rts
.a13b					xt_star:
.a13b	20 49 d8	jsr $d849	                jsr underflow_2
.a13e	20 d7 a5	jsr $a5d7	                jsr xt_um_star
.a141	e8		inx		                inx
.a142	e8		inx		                inx
.a143	60		rts		z_star:         rts
.a144					xt_star_slash:
.a144	20 4d a1	jsr $a14d	                jsr xt_star_slash_mod
.a147	20 89 a1	jsr $a189	                jsr xt_swap
.a14a	e8		inx		                inx
.a14b	e8		inx		                inx
.a14c					z_star_slash:
.a14c	60		rts		                rts
.a14d					xt_star_slash_mod:
.a14d	20 4e d8	jsr $d84e	                jsr underflow_3
.a150	20 4b a3	jsr $a34b	                jsr xt_to_r
.a153	20 98 94	jsr $9498	                jsr xt_m_star
.a156	20 9c 9a	jsr $9a9c	                jsr xt_r_from
.a159	20 b0 a0	jsr $a0b0	                jsr xt_sm_slash_rem
.a15c					z_star_slash_mod:
.a15c	60		rts		                rts
.a15d					xt_state:
.a15d	ca		dex		                dex
.a15e	ca		dex		                dex
.a15f	a9 16		lda #$16	                lda #<state
.a161	95 00		sta $00,x	                sta 0,x
.a163	a9 00		lda #$00	                lda #>state
.a165	95 01		sta $01,x	                sta 1,x
.a167	60		rts		z_state:        rts
.a168					xt_store:
.a168	20 49 d8	jsr $d849	                jsr underflow_2
.a16b	b5 02		lda $02,x	                lda 2,x         ; LSB
.a16d	81 00		sta ($00,x)	                sta (0,x)
.a16f	f6 00		inc $00,x	                inc 0,x
.a171	d0 02		bne $a175	                bne +
.a173	f6 01		inc $01,x	                inc 1,x
.a175					+
.a175	b5 03		lda $03,x	                lda 3,x         ; MSB
.a177	81 00		sta ($00,x)	                sta (0,x)
.a179	e8		inx		                inx             ; 2DROP
.a17a	e8		inx		                inx
.a17b	e8		inx		                inx
.a17c	e8		inx		                inx
.a17d	60		rts		z_store:        rts
.a17e					xt_strip_underflow:
.a17e	ca		dex		                dex
.a17f	ca		dex		                dex
.a180	a9 1c		lda #$1c	                lda #<uf_strip
.a182	95 00		sta $00,x	                sta 0,x
.a184	a9 00		lda #$00	                lda #>uf_strip
.a186	95 01		sta $01,x	                sta 1,x
.a188					z_strip_underflow:
.a188	60		rts		                rts
.a189					xt_swap:
.a189	20 49 d8	jsr $d849	                jsr underflow_2
.a18c	b5 00		lda $00,x	                lda 0,x         ; LSB
.a18e	b4 02		ldy $02,x	                ldy 2,x
.a190	95 02		sta $02,x	                sta 2,x
.a192	94 00		sty $00,x	                sty 0,x
.a194	b5 01		lda $01,x	                lda 1,x         ; MSB
.a196	b4 03		ldy $03,x	                ldy 3,x
.a198	95 03		sta $03,x	                sta 3,x
.a19a	94 01		sty $01,x	                sty 1,x
.a19c	60		rts		z_swap:         rts
.a19d					xt_then:
.a19d	20 7b 91	jsr $917b	                jsr xt_here
.a1a0	20 89 a1	jsr $a189	                jsr xt_swap
.a1a3	20 68 a1	jsr $a168	                jsr xt_store
.a1a6	60		rts		z_then:         rts
.a1a7					xt_thru:
.a1a7	20 49 d8	jsr $d849	                jsr underflow_2
.a1aa	b5 01		lda $01,x	                lda 1,x
.a1ac	48		pha		                pha
.a1ad	b5 00		lda $00,x	                lda 0,x
.a1af	48		pha		                pha
.a1b0	e8		inx		                inx
.a1b1	e8		inx		                inx
.a1b2					_thru_loop:
.a1b2	b5 01		lda $01,x	                lda 1,x
.a1b4	48		pha		                pha
.a1b5	b5 00		lda $00,x	                lda 0,x
.a1b7	48		pha		                pha
.a1b8	20 be 93	jsr $93be	                jsr xt_load
.a1bb	68		pla		                pla
.a1bc	85 24		sta $24		                sta tmp1
.a1be	68		pla		                pla
.a1bf	85 25		sta $25		                sta tmp1+1
.a1c1	68		pla		                pla
.a1c2	85 26		sta $26		                sta tmp2
.a1c4	68		pla		                pla
.a1c5	85 27		sta $27		                sta tmp2+1
.a1c7	c5 25		cmp $25		                cmp tmp1+1
.a1c9	d0 08		bne $a1d3	                bne _next_screen
.a1cb	a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a1cd	c5 24		cmp $24		                cmp tmp1
.a1cf	d0 02		bne $a1d3	                bne _next_screen
.a1d1	80 18		bra $a1eb	                bra _done       ; We just did the last screen.
.a1d3					_next_screen:
.a1d3	a5 27		lda $27		                lda tmp2+1
.a1d5	48		pha		                pha
.a1d6	a5 26		lda $26		                lda tmp2
.a1d8	48		pha		                pha
.a1d9	e6 24		inc $24		                inc tmp1
.a1db	d0 02		bne $a1df	                bne +
.a1dd	e6 25		inc $25		                inc tmp1+1
.a1df					+
.a1df	ca		dex		                dex
.a1e0	ca		dex		                dex
.a1e1	a5 24		lda $24		                lda tmp1
.a1e3	95 00		sta $00,x	                sta 0,x
.a1e5	a5 25		lda $25		                lda tmp1+1
.a1e7	95 01		sta $01,x	                sta 1,x
.a1e9	80 c7		bra $a1b2	                bra _thru_loop
.a1eb					_done:
.a1eb	60		rts		z_thru:         rts
.a1ec					xt_tick:
.a1ec	20 e9 98	jsr $98e9	                jsr xt_parse_name       ; ( -- addr u )
.a1ef	b5 00		lda $00,x	                lda 0,x
.a1f1	15 01		ora $01,x	                ora 1,x
.a1f3	d0 05		bne $a1fa	                bne +
.a1f5	a9 05		lda #$05	                lda #err_noname
.a1f7	4c 5a d8	jmp $d85a	                jmp error
.a1fa					+
.a1fa	20 e4 8f	jsr $8fe4	                jsr xt_find_name        ; ( addr u -- nt )
.a1fd	b5 00		lda $00,x	                lda 0,x
.a1ff	15 01		ora $01,x	                ora 1,x
.a201	d0 05		bne $a208	                bne +
.a203	a9 08		lda #$08	                lda #err_syntax
.a205	4c 5a d8	jmp $d85a	                jmp error
.a208					+
.a208	20 eb 95	jsr $95eb	                jsr xt_name_to_int      ; ( nt -- xt )
.a20b	60		rts		z_tick:         rts
.a20c					xt_to:
.a20c	20 ec a1	jsr $a1ec	                jsr xt_tick             ; ( [n] xt )
.a20f	b5 00		lda $00,x	                lda 0,x                 ; LSB
.a211	18		clc		                clc
.a212	69 03		adc #$03	                adc #3
.a214	85 24		sta $24		                sta tmp1
.a216	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a218	69 00		adc #$00	                adc #0                  ; we just want the carry
.a21a	85 25		sta $25		                sta tmp1+1
.a21c	e8		inx		                inx
.a21d	e8		inx		                inx                     ; ( [n] )
.a21e	a5 16		lda $16		                lda state
.a220	05 17		ora $17		                ora state+1
.a222	f0 34		beq $a258	                beq _interpret
.a224	a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a226	a9 b5		lda #$b5	                lda #$B5
.a228	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a22b	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a22d	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a230	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a232	a5 24		lda $24		                lda tmp1
.a234	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a237	a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a239	a9 b5		lda #$b5	                lda #$B5
.a23b	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a23e	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a240	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a243	e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a245	d0 02		bne $a249	                bne +
.a247	e6 25		inc $25		                inc tmp1+1
.a249					+
.a249	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a24b	a5 24		lda $24		                lda tmp1
.a24d	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a250	a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a252	98		tya		                tya
.a253	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a256	80 0f		bra $a267	                bra _done
.a258					_interpret:
.a258	20 44 d8	jsr $d844	                jsr underflow_1
.a25b	b5 00		lda $00,x	                lda 0,x
.a25d	92 24		sta ($24)	                sta (tmp1)              ; LSB
.a25f	a0 01		ldy #$01	                ldy #1
.a261	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a263	91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a265	e8		inx		                inx                     ; DROP
.a266	e8		inx		                inx
.a267					_done:
.a267	60		rts		z_to:           rts
.a268					xt_to_body:
.a268	20 44 d8	jsr $d844	                jsr underflow_1
.a26b	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( xt xt )
.a26e	20 7f 92	jsr $927f	                jsr xt_int_to_name      ; ( xt nt )
.a271	f6 00		inc $00,x	                inc 0,x
.a273	d0 02		bne $a277	                bne +
.a275	f6 01		inc $01,x	                inc 1,x
.a277					+
.a277	a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a279	29 20		and #$20	                and #HC
.a27b	f0 0d		beq $a28a	                beq _no_cfa
.a27d	18		clc		                clc
.a27e	b5 02		lda $02,x	                lda 2,x         ; LSB
.a280	69 03		adc #$03	                adc #3
.a282	95 02		sta $02,x	                sta 2,x
.a284	b5 03		lda $03,x	                lda 3,x         ; MSB
.a286	69 00		adc #$00	                adc #0          ; we conly care about the carry
.a288	95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a28a					_no_cfa:
.a28a	e8		inx		                inx             ; get rid of the nt
.a28b	e8		inx		                inx
.a28c					_done:
.a28c	60		rts		z_to_body:      rts
.a28d					xt_to_in:
.a28d	ca		dex		                dex
.a28e	ca		dex		                dex
.a28f	a9 0c		lda #$0c	                lda #<toin
.a291	95 00		sta $00,x	                sta 0,x
.a293	a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a295	95 01		sta $01,x	                sta 1,x
.a297	60		rts		z_to_in:        rts
.a298					xt_to_number:
.a298	20 53 d8	jsr $d853	                jsr underflow_4
.a29b	b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a29d	85 36		sta $36		                sta scratch
.a29f	b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a2a1	85 37		sta $37		                sta scratch+1
.a2a3	b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a2a5	85 38		sta $38		                sta scratch+2
.a2a7	b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a2a9	85 39		sta $39		                sta scratch+3
.a2ab	ca		dex		                dex
.a2ac	ca		dex		                dex
.a2ad					_loop:
.a2ad	a1 04		lda ($04,x)	                lda (4,x)
.a2af	95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a2b1	74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2b3	20 22 8b	jsr $8b22	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a2b6	b5 00		lda $00,x	                lda 0,x
.a2b8	d0 04		bne $a2be	                bne _digit_ok
.a2ba	e8		inx		                inx
.a2bb	e8		inx		                inx
.a2bc	80 67		bra $a325	                bra _done       ; ( ud-lo ud-hi addr u char )
.a2be					_digit_ok:
.a2be	b5 02		lda $02,x	                lda 2,x
.a2c0	85 3a		sta $3a		                sta scratch+4
.a2c2	b5 03		lda $03,x	                lda 3,x
.a2c4	85 3b		sta $3b		                sta scratch+5
.a2c6	a5 38		lda $38		                lda scratch+2
.a2c8	95 02		sta $02,x	                sta 2,x         ; NOS
.a2ca	a5 39		lda $39		                lda scratch+3
.a2cc	95 03		sta $03,x	                sta 3,x
.a2ce	a5 18		lda $18		                lda base
.a2d0	95 00		sta $00,x	                sta 0,x         ; TOS
.a2d2	74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a2d4	20 d7 a5	jsr $a5d7	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2d7	b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a2d9	85 3c		sta $3c		                sta scratch+6
.a2db	b5 03		lda $03,x	                lda 3,x
.a2dd	85 3d		sta $3d		                sta scratch+7
.a2df	a5 36		lda $36		                lda scratch
.a2e1	95 02		sta $02,x	                sta 2,x
.a2e3	a5 37		lda $37		                lda scratch+1
.a2e5	95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a2e7	a5 18		lda $18		                lda base
.a2e9	95 00		sta $00,x	                sta 0,x
.a2eb	74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a2ed	20 d7 a5	jsr $a5d7	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a2f0	b5 00		lda $00,x	                lda 0,x
.a2f2	85 38		sta $38		                sta scratch+2
.a2f4	b5 01		lda $01,x	                lda 1,x
.a2f6	85 39		sta $39		                sta scratch+3
.a2f8	b5 02		lda $02,x	                lda 2,x
.a2fa	85 36		sta $36		                sta scratch
.a2fc	b5 03		lda $03,x	                lda 3,x
.a2fe	85 37		sta $37		                sta scratch+1
.a300	18		clc		                clc
.a301	a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a303	65 3a		adc $3a		                adc scratch+4   ; n LSB
.a305	85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a307	a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a309	65 3b		adc $3b		                adc scratch+5   ; n MSB
.a30b	85 37		sta $37		                sta scratch+1
.a30d	a5 38		lda $38		                lda scratch+2   ; LSB
.a30f	65 3c		adc $3c		                adc scratch+6
.a311	85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a313	a5 39		lda $39		                lda scratch+3   ; MSB
.a315	65 3d		adc $3d		                adc scratch+7
.a317	85 39		sta $39		                sta scratch+3
.a319	e8		inx		                inx
.a31a	e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a31b	f6 04		inc $04,x	                inc 4,x
.a31d	d0 02		bne $a321	                bne +
.a31f	f6 05		inc $05,x	                inc 5,x
.a321					+
.a321	d6 02		dec $02,x	                dec 2,x
.a323	d0 88		bne $a2ad	                bne _loop
.a325					_done:
.a325	e8		inx		                inx
.a326	e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a327	a5 36		lda $36		                lda scratch     ; new ud-lo
.a329	95 06		sta $06,x	                sta 6,x
.a32b	a5 37		lda $37		                lda scratch+1
.a32d	95 07		sta $07,x	                sta 7,x
.a32f	a5 38		lda $38		                lda scratch+2
.a331	95 04		sta $04,x	                sta 4,x
.a333	a5 39		lda $39		                lda scratch+3
.a335	95 05		sta $05,x	                sta 5,x
.a337	60		rts		z_to_number:    rts
.a338					xt_to_order:
.a338	20 4b a3	jsr $a34b	                jsr xt_to_r
.a33b	20 3d 91	jsr $913d	                jsr xt_get_order
.a33e	20 9c 9a	jsr $9a9c	                jsr xt_r_from
.a341	20 89 a1	jsr $a189	                jsr xt_swap
.a344	20 27 98	jsr $9827	                jsr xt_one_plus
.a347	20 25 9d	jsr $9d25	                jsr xt_set_order
.a34a	60		rts		z_to_order:     rts
.a34b					xt_to_r:
.a34b	68		pla		                pla             ; LSB
.a34c	85 2c		sta $2c		                sta tmptos
.a34e	7a		ply		                ply             ; MSB
.a34f	20 44 d8	jsr $d844	                jsr underflow_1
.a352	b5 01		lda $01,x	                lda 1,x         ; MSB
.a354	48		pha		                pha
.a355	b5 00		lda $00,x	                lda 0,x         ; LSB
.a357	48		pha		                pha
.a358	e8		inx		                inx
.a359	e8		inx		                inx
.a35a	5a		phy		                phy             ; MSB
.a35b	a5 2c		lda $2c		                lda tmptos
.a35d	48		pha		                pha             ; LSB
.a35e	60		rts		z_to_r:         rts
.a35f					xt_true:
.a35f	ca		dex		                dex
.a360	ca		dex		                dex
.a361	a9 ff		lda #$ff	                lda #$FF
.a363	95 00		sta $00,x	                sta 0,x
.a365	95 01		sta $01,x	                sta 1,x
.a367	60		rts		z_true:         rts
.a368					xt_tuck:
.a368	20 49 d8	jsr $d849	                jsr underflow_2
.a36b	ca		dex		                dex
.a36c	ca		dex		                dex
.a36d	b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a36f	b5 02		lda $02,x	                lda 2,x
.a371	95 04		sta $04,x	                sta 4,x
.a373	94 02		sty $02,x	                sty 2,x
.a375	95 00		sta $00,x	                sta 0,x
.a377	b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a379	b5 03		lda $03,x	                lda 3,x
.a37b	95 05		sta $05,x	                sta 5,x
.a37d	94 03		sty $03,x	                sty 3,x         ; bba
.a37f	95 01		sta $01,x	                sta 1,x         ; baa
.a381	60		rts		z_tuck:         rts
.a382					xt_assembler_wordlist:
.a382					xt_two:
.a382	ca		dex		                dex
.a383	ca		dex		                dex
.a384	a9 02		lda #$02	                lda #2
.a386	95 00		sta $00,x	                sta 0,x
.a388	74 01		stz $01,x	                stz 1,x
.a38a					z_assembler_wordlist:
.a38a	60		rts		z_two:          rts
.a38b					xt_two_drop:
.a38b	20 49 d8	jsr $d849	                jsr underflow_2
.a38e	e8		inx		                inx
.a38f	e8		inx		                inx
.a390	e8		inx		                inx
.a391	e8		inx		                inx
.a392	60		rts		z_two_drop:     rts
.a393					xt_two_dup:
.a393	20 49 d8	jsr $d849	                jsr underflow_2
.a396	ca		dex		                dex
.a397	ca		dex		                dex
.a398	ca		dex		                dex
.a399	ca		dex		                dex
.a39a	b5 04		lda $04,x	                lda 4,x         ; TOS
.a39c	95 00		sta $00,x	                sta 0,x
.a39e	b5 05		lda $05,x	                lda 5,x
.a3a0	95 01		sta $01,x	                sta 1,x
.a3a2	b5 06		lda $06,x	                lda 6,x         ; NOS
.a3a4	95 02		sta $02,x	                sta 2,x
.a3a6	b5 07		lda $07,x	                lda 7,x
.a3a8	95 03		sta $03,x	                sta 3,x
.a3aa	60		rts		z_two_dup:      rts
.a3ab					xt_two_fetch:
.a3ab	20 44 d8	jsr $d844	                jsr underflow_1
.a3ae	b5 00		lda $00,x	                lda 0,x
.a3b0	85 24		sta $24		                sta tmp1
.a3b2	b4 01		ldy $01,x	                ldy 1,x
.a3b4	84 25		sty $25		                sty tmp1+1
.a3b6	ca		dex		                dex             ; reuse one stack element
.a3b7	ca		dex		                dex
.a3b8	b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a3ba	95 00		sta $00,x	                sta 0,x
.a3bc	a0 01		ldy #$01	                ldy #1          ; copy next
.a3be	b1 24		lda ($24),y	                lda (tmp1),y
.a3c0	95 01		sta $01,x	                sta 1,x
.a3c2	c8		iny		                iny             ; copy next
.a3c3	b1 24		lda ($24),y	                lda (tmp1),y
.a3c5	95 02		sta $02,x	                sta 2,x
.a3c7	c8		iny		                iny             ; copy next
.a3c8	b1 24		lda ($24),y	                lda (tmp1),y
.a3ca	95 03		sta $03,x	                sta 3,x
.a3cc	60		rts		z_two_fetch:    rts
.a3cd					xt_two_over:
.a3cd	20 53 d8	jsr $d853	                jsr underflow_4
.a3d0	ca		dex		                dex
.a3d1	ca		dex		                dex
.a3d2	ca		dex		                dex
.a3d3	ca		dex		                dex
.a3d4	b5 08		lda $08,x	                lda 8,x
.a3d6	95 00		sta $00,x	                sta 0,x
.a3d8	b5 09		lda $09,x	                lda 9,x
.a3da	95 01		sta $01,x	                sta 1,x
.a3dc	b5 0a		lda $0a,x	                lda 10,x
.a3de	95 02		sta $02,x	                sta 2,x
.a3e0	b5 0b		lda $0b,x	                lda 11,x
.a3e2	95 03		sta $03,x	                sta 3,x
.a3e4	60		rts		z_two_over:     rts
.a3e5					xt_two_r_fetch:
.a3e5	ca		dex		                dex
.a3e6	ca		dex		                dex
.a3e7	ca		dex		                dex
.a3e8	ca		dex		                dex
.a3e9	8a		txa		                txa
.a3ea	ba		tsx		                tsx
.a3eb	da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a3ec	7a		ply		                ply
.a3ed	aa		tax		                tax
.a3ee	b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a3f1	95 00		sta $00,x	                sta 0,x
.a3f3	b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a3f6	95 01		sta $01,x	                sta 1,x
.a3f8	b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a3fb	95 02		sta $02,x	                sta 2,x
.a3fd	b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a400	95 03		sta $03,x	                sta 3,x
.a402	60		rts		z_two_r_fetch:  rts
.a403					xt_two_r_from:
.a403	68		pla		                pla                     ; LSB
.a404	85 24		sta $24		                sta tmp1
.a406	68		pla		                pla                     ; MSB
.a407	85 25		sta $25		                sta tmp1+1
.a409	ca		dex		                dex
.a40a	ca		dex		                dex
.a40b	ca		dex		                dex
.a40c	ca		dex		                dex
.a40d	68		pla		                pla                     ; LSB
.a40e	95 00		sta $00,x	                sta 0,x
.a410	68		pla		                pla                     ; MSB
.a411	95 01		sta $01,x	                sta 1,x
.a413	68		pla		                pla                     ; LSB
.a414	95 02		sta $02,x	                sta 2,x
.a416	68		pla		                pla                     ; MSB
.a417	95 03		sta $03,x	                sta 3,x
.a419	a5 25		lda $25		                lda tmp1+1              ; MSB
.a41b	48		pha		                pha
.a41c	a5 24		lda $24		                lda tmp1                ; LSB
.a41e	48		pha		                pha
.a41f	60		rts		z_two_r_from:   rts
.a420					xt_two_slash:
.a420	20 44 d8	jsr $d844	                jsr underflow_1
.a423	b5 01		lda $01,x	                lda 1,x
.a425	0a		asl a		                asl                     ; save the sign
.a426	76 01		ror $01,x	                ror 1,x
.a428	76 00		ror $00,x	                ror 0,x
.a42a	60		rts		z_two_slash:    rts
.a42b					xt_two_star:
.a42b					xt_cells:
.a42b	20 44 d8	jsr $d844	                jsr underflow_1
.a42e	16 00		asl $00,x	                asl 0,x
.a430	36 01		rol $01,x	                rol 1,x
.a432					z_cells:
.a432	60		rts		z_two_star:     rts
.a433					xt_two_store:
.a433	20 4e d8	jsr $d84e	                jsr underflow_3
.a436	b5 00		lda $00,x	                lda 0,x
.a438	85 24		sta $24		                sta tmp1
.a43a	b4 01		ldy $01,x	                ldy 1,x
.a43c	84 25		sty $25		                sty tmp1+1
.a43e	e8		inx		                inx
.a43f	e8		inx		                inx
.a440	b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a442	92 24		sta ($24)	                sta (tmp1)
.a444	b5 01		lda $01,x	                lda 1,x         ; copy next
.a446	a0 01		ldy #$01	                ldy #1
.a448	91 24		sta ($24),y	                sta (tmp1),y
.a44a	b5 02		lda $02,x	                lda 2,x         ; copy next
.a44c	c8		iny		                iny
.a44d	91 24		sta ($24),y	                sta (tmp1),y
.a44f	b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a451	c8		iny		                iny
.a452	91 24		sta ($24),y	                sta (tmp1),y
.a454	e8		inx		                inx             ; 2DROP
.a455	e8		inx		                inx
.a456	e8		inx		                inx
.a457	e8		inx		                inx
.a458	60		rts		z_two_store:    rts
.a459					xt_two_swap:
.a459	20 53 d8	jsr $d853	                jsr underflow_4
.a45c	b5 00		lda $00,x	                lda 0,x
.a45e	b4 04		ldy $04,x	                ldy 4,x
.a460	95 04		sta $04,x	                sta 4,x
.a462	94 00		sty $00,x	                sty 0,x
.a464	b5 01		lda $01,x	                lda 1,x
.a466	b4 05		ldy $05,x	                ldy 5,x
.a468	95 05		sta $05,x	                sta 5,x
.a46a	94 01		sty $01,x	                sty 1,x
.a46c	b5 02		lda $02,x	                lda 2,x
.a46e	b4 06		ldy $06,x	                ldy 6,x
.a470	95 06		sta $06,x	                sta 6,x
.a472	94 02		sty $02,x	                sty 2,x
.a474	b5 03		lda $03,x	                lda 3,x
.a476	b4 07		ldy $07,x	                ldy 7,x
.a478	95 07		sta $07,x	                sta 7,x
.a47a	94 03		sty $03,x	                sty 3,x
.a47c	60		rts		z_two_swap:     rts
.a47d					xt_two_to_r:
.a47d	68		pla		                pla             ; LSB
.a47e	85 24		sta $24		                sta tmp1
.a480	68		pla		                pla             ; MSB
.a481	85 25		sta $25		                sta tmp1+1
.a483	20 49 d8	jsr $d849	                jsr underflow_2
.a486	b5 03		lda $03,x	                lda 3,x         ; MSB
.a488	48		pha		                pha
.a489	b5 02		lda $02,x	                lda 2,x         ; LSB
.a48b	48		pha		                pha
.a48c	b5 01		lda $01,x	                lda 1,x         ; MSB
.a48e	48		pha		                pha
.a48f	b5 00		lda $00,x	                lda 0,x         ; LSB
.a491	48		pha		                pha
.a492	e8		inx		                inx
.a493	e8		inx		                inx
.a494	e8		inx		                inx
.a495	e8		inx		                inx
.a496	a5 25		lda $25		                lda tmp1+1      ; MSB
.a498	48		pha		                pha
.a499	a5 24		lda $24		                lda tmp1        ; LSB
.a49b	48		pha		                pha
.a49c	60		rts		z_two_to_r:     rts
.a49d					xt_two_constant:
.a49d	20 49 d8	jsr $d849	                jsr underflow_2
.a4a0	20 86 89	jsr $8986	                jsr xt_create
.a4a3	20 89 a1	jsr $a189	                jsr xt_swap
.a4a6	20 7a 87	jsr $877a	                jsr xt_comma
.a4a9	20 7a 87	jsr $877a	                jsr xt_comma
.a4ac	20 0d 8c	jsr $8c0d	                jsr does_runtime    ; does> turns into these two routines.
.a4af	20 2d d7	jsr $d72d	                jsr dodoes
.a4b2	20 b8 8d	jsr $8db8	                jsr xt_dup
.a4b5	20 89 8f	jsr $8f89	                jsr xt_fetch
.a4b8	20 89 a1	jsr $a189	                jsr xt_swap
.a4bb	20 2d 86	jsr $862d	                jsr xt_cell_plus
.a4be	20 89 8f	jsr $8f89	                jsr xt_fetch
.a4c1	60		rts		z_two_constant: rts
.a4c2					xt_two_literal:
.a4c2	20 49 d8	jsr $d849	                jsr underflow_2 ; double number
.a4c5	20 89 a1	jsr $a189	                jsr xt_swap
.a4c8	20 91 93	jsr $9391	                jsr xt_literal
.a4cb	20 91 93	jsr $9391	                jsr xt_literal
.a4ce	60		rts		z_two_literal:  rts
.a4cf					xt_two_variable:
.a4cf	20 86 89	jsr $8986	                jsr xt_create
.a4d2	ca		dex		                dex
.a4d3	ca		dex		                dex
.a4d4	a9 04		lda #$04	                lda #4
.a4d6	95 00		sta $00,x	                sta 0,x
.a4d8	74 01		stz $01,x	                stz 1,x
.a4da	20 95 82	jsr $8295	                jsr xt_allot
.a4dd	60		rts		z_two_variable: rts
.a4de					xt_type:
.a4de	20 49 d8	jsr $d849	                jsr underflow_2
.a4e1	b5 02		lda $02,x	                lda 2,x
.a4e3	85 24		sta $24		                sta tmp1
.a4e5	b5 03		lda $03,x	                lda 3,x
.a4e7	85 25		sta $25		                sta tmp1+1
.a4e9					_loop:
.a4e9	b5 00		lda $00,x	                lda 0,x
.a4eb	15 01		ora $01,x	                ora 1,x
.a4ed	f0 15		beq $a504	                beq _done
.a4ef	b2 24		lda ($24)	                lda (tmp1)
.a4f1	20 ff 8d	jsr $8dff	                jsr emit_a      ; avoids stack foolery
.a4f4	e6 24		inc $24		                inc tmp1
.a4f6	d0 02		bne $a4fa	                bne +
.a4f8	e6 25		inc $25		                inc tmp1+1
.a4fa					+
.a4fa	b5 00		lda $00,x	                lda 0,x
.a4fc	d0 02		bne $a500	                bne +
.a4fe	d6 01		dec $01,x	                dec 1,x
.a500					+
.a500	d6 00		dec $00,x	                dec 0,x
.a502	80 e5		bra $a4e9	                bra _loop
.a504					_done:
.a504	e8		inx		                inx
.a505	e8		inx		                inx
.a506	e8		inx		                inx
.a507	e8		inx		                inx
.a508	60		rts		z_type:         rts
.a509					xt_u_dot:
.a509	20 44 d8	jsr $d844	                jsr underflow_1
.a50c	20 b1 d8	jsr $d8b1	                jsr print_u
.a50f	a9 20		lda #$20	                lda #AscSP
.a511	20 ff 8d	jsr $8dff	                jsr emit_a
.a514	60		rts		z_u_dot:        rts
.a515					xt_u_dot_r:
.a515	20 49 d8	jsr $d849	                jsr underflow_2
.a518	20 4b a3	jsr $a34b	                jsr xt_to_r
.a51b	20 83 a7	jsr $a783	                jsr xt_zero
.a51e	20 61 93	jsr $9361	                jsr xt_less_number_sign
.a521	20 e8 97	jsr $97e8	                jsr xt_number_sign_s
.a524	20 c6 97	jsr $97c6	                jsr xt_number_sign_greater
.a527	20 9c 9a	jsr $9a9c	                jsr xt_r_from
.a52a	20 9d 98	jsr $989d	                jsr xt_over
.a52d	20 5a 95	jsr $955a	                jsr xt_minus
.a530	20 ff a0	jsr $a0ff	                jsr xt_spaces
.a533	20 de a4	jsr $a4de	                jsr xt_type
.a536	60		rts		z_u_dot_r:      rts
.a537					xt_u_greater_than:
.a537	20 49 d8	jsr $d849	                jsr underflow_2
.a53a	b5 00		lda $00,x	                lda 0,x
.a53c	d5 02		cmp $02,x	                cmp 2,x
.a53e	b5 01		lda $01,x	                lda 1,x
.a540	f5 03		sbc $03,x	                sbc 3,x
.a542	e8		inx		                inx
.a543	e8		inx		                inx
.a544	a9 00		lda #$00	                lda #0
.a546	69 ff		adc #$ff	                adc #$ff
.a548	95 00		sta $00,x	                sta 0,x         ; store flag
.a54a	95 01		sta $01,x	                sta 1,x
.a54c	60		rts		z_u_greater_than:    rts
.a54d					xt_u_less_than:
.a54d	20 49 d8	jsr $d849	                jsr underflow_2
.a550	b5 02		lda $02,x	                lda 2,x
.a552	d5 00		cmp $00,x	                cmp 0,x
.a554	b5 03		lda $03,x	                lda 3,x
.a556	f5 01		sbc $01,x	                sbc 1,x
.a558	e8		inx		                inx
.a559	e8		inx		                inx
.a55a	a9 00		lda #$00	                lda #0
.a55c	69 ff		adc #$ff	                adc #$ff
.a55e	95 00		sta $00,x	                sta 0,x         ; store flag
.a560	95 01		sta $01,x	                sta 1,x
.a562	60		rts		z_u_less_than:    rts
.a563					xt_ud_dot:
.a563	20 49 d8	jsr $d849	                jsr underflow_2 ; double number
.a566	20 61 93	jsr $9361	                jsr xt_less_number_sign
.a569	20 e8 97	jsr $97e8	                jsr xt_number_sign_s
.a56c	20 c6 97	jsr $97c6	                jsr xt_number_sign_greater
.a56f	20 de a4	jsr $a4de	                jsr xt_type
.a572	20 f9 a0	jsr $a0f9	                jsr xt_space
.a575	60		rts		z_ud_dot:        rts
.a576					xt_ud_dot_r:
.a576	20 4e d8	jsr $d84e	                jsr underflow_3
.a579	20 4b a3	jsr $a34b	                jsr xt_to_r
.a57c	20 61 93	jsr $9361	                jsr xt_less_number_sign
.a57f	20 e8 97	jsr $97e8	                jsr xt_number_sign_s
.a582	20 c6 97	jsr $97c6	                jsr xt_number_sign_greater
.a585	20 9c 9a	jsr $9a9c	                jsr xt_r_from
.a588	20 9d 98	jsr $989d	                jsr xt_over
.a58b	20 5a 95	jsr $955a	                jsr xt_minus
.a58e	20 ff a0	jsr $a0ff	                jsr xt_spaces
.a591	20 de a4	jsr $a4de	                jsr xt_type
.a594	60		rts		z_ud_dot_r:      rts
.a595					xt_um_slash_mod:
.a595	20 4e d8	jsr $d84e	                jsr underflow_3
.a598	b5 00		lda $00,x	                lda 0,x
.a59a	15 01		ora $01,x	                ora 1,x
.a59c	d0 05		bne $a5a3	                bne _not_zero
.a59e	a9 04		lda #$04	                lda #err_divzero
.a5a0	4c 5a d8	jmp $d85a	                jmp error
.a5a3					_not_zero:
.a5a3	a9 11		lda #$11	                lda #17
.a5a5	85 2c		sta $2c		                sta tmptos
.a5a7					_loop:
.a5a7	36 04		rol $04,x	                rol 4,x
.a5a9	36 05		rol $05,x	                rol 5,x
.a5ab	c6 2c		dec $2c		                dec tmptos
.a5ad	f0 22		beq $a5d1	                beq _done
.a5af	36 02		rol $02,x	                rol 2,x
.a5b1	36 03		rol $03,x	                rol 3,x
.a5b3	64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a5b5	26 24		rol $24		                rol tmp1
.a5b7	38		sec		                sec
.a5b8	b5 02		lda $02,x	                lda 2,x
.a5ba	f5 00		sbc $00,x	                sbc 0,x
.a5bc	85 25		sta $25		                sta tmp1+1
.a5be	b5 03		lda $03,x	                lda 3,x
.a5c0	f5 01		sbc $01,x	                sbc 1,x
.a5c2	a8		tay		                tay
.a5c3	a5 24		lda $24		                lda tmp1
.a5c5	e9 00		sbc #$00	                sbc #0
.a5c7	90 de		bcc $a5a7	                bcc _loop
.a5c9	a5 25		lda $25		                lda tmp1+1
.a5cb	95 02		sta $02,x	                sta 2,x
.a5cd	94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a5cf	80 d6		bra $a5a7	                bra _loop
.a5d1					_done:
.a5d1	e8		inx		                inx
.a5d2	e8		inx		                inx
.a5d3	20 89 a1	jsr $a189	                jsr xt_swap
.a5d6	60		rts		z_um_slash_mod: rts
.a5d7					xt_um_star:
.a5d7	20 49 d8	jsr $d849	                jsr underflow_2
.a5da	18		clc		                clc
.a5db	b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a5dd	e9 00		sbc #$00	                sbc #0
.a5df	85 26		sta $26		                sta tmp2
.a5e1	b5 01		lda $01,x	                lda 1,x
.a5e3	e9 00		sbc #$00	                sbc #0
.a5e5	90 31		bcc $a618	                bcc _zero       ; is TOS zero?
.a5e7	85 27		sta $27		                sta tmp2+1
.a5e9	a9 00		lda #$00	                lda #0
.a5eb	85 24		sta $24		                sta tmp1
.a5ed	86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a5ef	ca		dex		                dex
.a5f0	ca		dex		                dex
.a5f1					_outer_loop:
.a5f1	a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a5f3	56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a5f5					_inner_loop:
.a5f5	90 0c		bcc $a603	                bcc _no_add
.a5f7	85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a5f9	a5 24		lda $24		                lda tmp1
.a5fb	65 26		adc $26		                adc tmp2
.a5fd	85 24		sta $24		                sta tmp1
.a5ff	a5 25		lda $25		                lda tmp1+1
.a601	65 27		adc $27		                adc tmp2+1
.a603					_no_add:
.a603	6a		ror a		                ror
.a604	66 24		ror $24		                ror tmp1
.a606	76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a608	88		dey		                dey
.a609	d0 ea		bne $a5f5	                bne _inner_loop ; go back for one more shift?
.a60b	e8		inx		                inx
.a60c	e4 28		cpx $28		                cpx tmp3
.a60e	d0 e1		bne $a5f1	                bne _outer_loop ; go back for eight more shifts?
.a610	95 01		sta $01,x	                sta 1,x
.a612	a5 24		lda $24		                lda tmp1
.a614	95 00		sta $00,x	                sta 0,x
.a616	80 04		bra $a61c	                bra _done
.a618					_zero:
.a618	74 02		stz $02,x	                stz 2,x
.a61a	74 03		stz $03,x	                stz 3,x
.a61c					_done:
.a61c	60		rts		z_um_star:      rts
.a61d					xt_unloop:
.a61d	68		pla		                pla
.a61e	68		pla		                pla
.a61f	68		pla		                pla
.a620	68		pla		                pla
.a621	68		pla		                pla
.a622	68		pla		                pla
.a623	60		rts		z_unloop:       rts
.a624					xt_until:
.a624	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a626	a9 1b		lda #$1b	                lda #<zero_branch_runtime
.a628	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.a62b	20 7a 87	jsr $877a	                jsr xt_comma
.a62e	60		rts		z_until:        rts
.a62f					xt_unused:
.a62f	ca		dex		                dex
.a630	ca		dex		                dex
.a631	a9 00		lda #$00	                lda #<cp_end
.a633	38		sec		                sec
.a634	e5 00		sbc $00		                sbc cp
.a636	95 00		sta $00,x	                sta 0,x
.a638	a9 7c		lda #$7c	                lda #>cp_end
.a63a	e5 01		sbc $01		                sbc cp+1
.a63c	95 01		sta $01,x	                sta 1,x
.a63e	60		rts		z_unused:       rts
.a63f					xt_update:
.a63f	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a641	b1 1e		lda ($1e),y	                lda (up),y
.a643	09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a645	91 1e		sta ($1e),y	                sta (up),y
.a647	60		rts		z_update:       rts
.a648					xt_useraddr:
.a648	ca		dex		                dex
.a649	ca		dex		                dex
.a64a	a9 1e		lda #$1e	                lda #<up
.a64c	95 00		sta $00,x	                sta 0,x
.a64e	a9 00		lda #$00	                lda #>up
.a650	95 01		sta $01,x	                sta 1,x
.a652	60		rts		z_useraddr:     rts
.a653					xt_variable:
.a653	20 86 89	jsr $8986	                jsr xt_create
.a656	a9 00		lda #$00	                lda #0
.a658	92 00		sta ($00)	                sta (cp)
.a65a	e6 00		inc $00		                inc cp
.a65c	d0 02		bne $a660	                bne +
.a65e	e6 01		inc $01		                inc cp+1
.a660					+
.a660	92 00		sta ($00)	                sta (cp)
.a662	e6 00		inc $00		                inc cp
.a664	d0 02		bne $a668	                bne +
.a666	e6 01		inc $01		                inc cp+1
.a668					+
.a668	20 4e 89	jsr $894e	                jsr adjust_z
.a66b	60		rts		z_variable:     rts
.a66c					xt_while:
.a66c	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a66e	a9 1b		lda #$1b	                lda #<zero_branch_runtime
.a670	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.a673	20 7b 91	jsr $917b	                jsr xt_here
.a676	20 83 a7	jsr $a783	                jsr xt_zero
.a679	20 7a 87	jsr $877a	                jsr xt_comma
.a67c	20 89 a1	jsr $a189	                jsr xt_swap
.a67f	60		rts		z_while:        rts
.a680					xt_within:
.a680	20 4e d8	jsr $d84e	                jsr underflow_3
.a683	20 9d 98	jsr $989d	                jsr xt_over
.a686	20 5a 95	jsr $955a	                jsr xt_minus
.a689	20 4b a3	jsr $a34b	                jsr xt_to_r
.a68c	20 5a 95	jsr $955a	                jsr xt_minus
.a68f	20 9c 9a	jsr $9a9c	                jsr xt_r_from
.a692	20 4d a5	jsr $a54d	                jsr xt_u_less_than
.a695	60		rts		z_within:       rts
.a696					xt_word:
.a696	20 44 d8	jsr $d844	                jsr underflow_1
.a699	a4 0c		ldy $0c		                ldy toin                ; >IN
.a69b					_loop:
.a69b	c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a69d	f0 09		beq $a6a8	                beq _found_char
.a69f	b1 08		lda ($08),y	                lda (cib),y
.a6a1	d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a6a3	d0 03		bne $a6a8	                bne _found_char
.a6a5	c8		iny		                iny
.a6a6	80 f3		bra $a69b	                bra _loop
.a6a8					_found_char:
.a6a8	84 0c		sty $0c		                sty toin
.a6aa	20 44 99	jsr $9944	                jsr xt_parse            ; Returns ( addr u )
.a6ad	b5 00		lda $00,x	                lda 0,x
.a6af	92 00		sta ($00)	                sta (cp)                ; Save length of string
.a6b1	48		pha		                pha                     ; Keep copy of length for later
.a6b2	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( addr u u )
.a6b5	a5 00		lda $00		                lda cp
.a6b7	18		clc		                clc
.a6b8	69 01		adc #$01	                adc #1
.a6ba	95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a6bc	a5 01		lda $01		                lda cp+1
.a6be	69 00		adc #$00	                adc #0
.a6c0	95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a6c2	20 cc 95	jsr $95cc	                jsr xt_move
.a6c5	ca		dex		                dex
.a6c6	ca		dex		                dex
.a6c7	a5 00		lda $00		                lda cp
.a6c9	95 00		sta $00,x	                sta 0,x
.a6cb	a5 01		lda $01		                lda cp+1
.a6cd	95 01		sta $01,x	                sta 1,x
.a6cf	68		pla		                pla                     ; length of string
.a6d0	18		clc		                clc
.a6d1	65 00		adc $00		                adc cp
.a6d3	85 00		sta $00		                sta cp
.a6d5	a5 01		lda $01		                lda cp+1
.a6d7	69 00		adc #$00	                adc #0                  ; we only need the carry
.a6d9	85 01		sta $01		                sta cp+1
.a6db	60		rts		z_word:         rts
.a6dc					xt_wordlist:
.a6dc	a0 05		ldy #$05	                ldy #num_wordlists_offset
.a6de	b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a6e0	c9 0c		cmp #$0c	                cmp #max_wordlists
.a6e2	d0 05		bne $a6e9	                bne _ok
.a6e4	a9 0b		lda #$0b	                lda #err_wordlist
.a6e6	4c 5a d8	jmp $d85a	                jmp error
.a6e9					_ok:
.a6e9	1a		inc a		                ina             ; Increment the wordlist#
.a6ea	91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a6ec	ca		dex		                dex             ; and put it on the stack.
.a6ed	ca		dex		                dex
.a6ee	95 00		sta $00,x	                sta 0,x
.a6f0	74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a6f2	60		rts		z_wordlist:     rts
.a6f3					xt_words:
.a6f3	20 80 89	jsr $8980	                jsr xt_cr
.a6f6	a9 00		lda #$00	                lda #0
.a6f8	48		pha		                pha
.a6f9	ca		dex		                dex                     ; Make room on the stack for
.a6fa	ca		dex		                dex                     ; a dictionary pointer.
.a6fb	64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a6fd					_wordlist_loop:
.a6fd	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a6ff	a5 28		lda $28		                lda tmp3
.a701	d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a703	d0 02		bne $a707	                bne _have_wordlist
.a705	80 45		bra $a74c	                bra _words_done
.a707					_have_wordlist:
.a707	18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a708	69 1f		adc #$1f	                adc #search_order_offset
.a70a	a8		tay		                tay
.a70b	b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a70d	0a		asl a		                asl                     ; Turn offset into cells offset.
.a70e	18		clc		                clc
.a70f	69 06		adc #$06	                adc #wordlists_offset
.a711	a8		tay		                tay
.a712	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a714	95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a716	c8		iny		                iny
.a717	b1 1e		lda ($1e),y	                lda (up),y
.a719	95 01		sta $01,x	                sta 1,x
.a71b					_loop:
.a71b	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( nt nt )
.a71e	20 08 96	jsr $9608	                jsr xt_name_to_string   ; ( nt addr u )
.a721	68		pla		                pla
.a722	18		clc		                clc
.a723	75 00		adc $00,x	                adc 0,x
.a725	1a		inc a		                ina                     ; don't forget the space between words
.a726	c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a728	90 06		bcc $a730	                bcc +
.a72a	20 80 89	jsr $8980	                jsr xt_cr
.a72d	b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a72f	1a		inc a		                ina                     ; with length of this word.
.a730					+
.a730	48		pha		                pha
.a731	20 de a4	jsr $a4de	                jsr xt_type             ; ( nt )
.a734	a9 20		lda #$20	                lda #AscSP
.a736	20 ff 8d	jsr $8dff	                jsr emit_a
.a739	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+
.a73c	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+
.a73f	20 89 8f	jsr $8f89	                jsr xt_fetch            ; @ ( nt+1 )
.a742	b5 00		lda $00,x	                lda 0,x
.a744	15 01		ora $01,x	                ora 1,x
.a746	d0 d3		bne $a71b	                bne _loop
.a748	e6 28		inc $28		                inc tmp3
.a74a	80 b1		bra $a6fd	                bra _wordlist_loop
.a74c					_words_done:
.a74c	68		pla		                pla                     ; dump counter
.a74d	e8		inx		                inx
.a74e	e8		inx		                inx
.a74f	60		rts		z_words:        rts
.a750					xt_wordsize:
.a750	20 44 d8	jsr $d844	                jsr underflow_1
.a753	b5 00		lda $00,x	                lda 0,x
.a755	85 24		sta $24		                sta tmp1
.a757	b5 01		lda $01,x	                lda 1,x
.a759	85 25		sta $25		                sta tmp1+1
.a75b	a0 06		ldy #$06	                ldy #6
.a75d	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a75f	88		dey		                dey
.a760	88		dey		                dey
.a761	38		sec		                sec
.a762	f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a764	95 00		sta $00,x	                sta 0,x
.a766	a0 07		ldy #$07	                ldy #7
.a768	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a76a	88		dey		                dey
.a76b	88		dey		                dey
.a76c	f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a76e	95 01		sta $01,x	                sta 1,x
.a770	60		rts		z_wordsize:     rts
.a771					xt_xor:
.a771	20 49 d8	jsr $d849	                jsr underflow_2
.a774	b5 00		lda $00,x	                lda 0,x
.a776	55 02		eor $02,x	                eor 2,x
.a778	95 02		sta $02,x	                sta 2,x
.a77a	b5 01		lda $01,x	                lda 1,x
.a77c	55 03		eor $03,x	                eor 3,x
.a77e	95 03		sta $03,x	                sta 3,x
.a780	e8		inx		                inx
.a781	e8		inx		                inx
.a782	60		rts		z_xor:          rts
.a783					xt_case:
.a783					xt_forth_wordlist:
.a783					xt_zero:
.a783	ca		dex		                dex             ; push
.a784	ca		dex		                dex
.a785	74 00		stz $00,x	                stz 0,x
.a787	74 01		stz $01,x	                stz 1,x
.a789					z_case:
.a789					z_forth_wordlist:
.a789					z_zero:
.a789	60		rts		                rts
.a78a					xt_zero_equal:
.a78a	20 44 d8	jsr $d844	                jsr underflow_1
.a78d	b5 00		lda $00,x	                lda 0,x
.a78f	15 01		ora $01,x	                ora 1,x
.a791	f0 02		beq $a795	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.a793	a9 ff		lda #$ff	                lda #$ff        ; else set A inverse of the FALSE (0) we want
.a795					_zero:
.a795	49 ff		eor #$ff	                eor #$ff        ; now just invert
.a797					_store:
.a797	95 00		sta $00,x	                sta 0,x
.a799	95 01		sta $01,x	                sta 1,x
.a79b	60		rts		z_zero_equal:   rts
.a79c					xt_zero_greater:
.a79c	20 44 d8	jsr $d844	                jsr underflow_1
.a79f	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a7a1	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7a3	30 05		bmi $a7aa	                bmi _done       ; TOS is negative, keep FLASE
.a7a5	15 00		ora $00,x	                ora 0,x
.a7a7	f0 01		beq $a7aa	                beq _done       ; TOS is zero, keep FALSE
.a7a9	88		dey		                dey             ; TOS is postive, make true
.a7aa					_done:
.a7aa	98		tya		                tya
.a7ab	95 00		sta $00,x	                sta 0,x
.a7ad	95 01		sta $01,x	                sta 1,x
.a7af	60		rts		z_zero_greater: rts
.a7b0					xt_zero_less:
.a7b0	20 44 d8	jsr $d844	                jsr underflow_1
.a7b3	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a7b5	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7b7	10 01		bpl $a7ba	                bpl _done       ; TOS is positive, so keep FALSE
.a7b9	88		dey		                dey             ; TOS is negative, make TRUE
.a7ba					_done:
.a7ba	98		tya		                tya
.a7bb	95 00		sta $00,x	                sta 0,x
.a7bd	95 01		sta $01,x	                sta 1,x
.a7bf	60		rts		z_zero_less:    rts
.a7c0					xt_zero_unequal:
.a7c0	20 44 d8	jsr $d844	                jsr underflow_1
.a7c3	b5 00		lda $00,x	                lda 0,x
.a7c5	15 01		ora $01,x	                ora 1,x
.a7c7	f0 02		beq $a7cb	                beq _zero
.a7c9	a9 ff		lda #$ff	                lda #$ff
.a7cb					_zero:
.a7cb	95 00		sta $00,x	                sta 0,x
.a7cd	95 01		sta $01,x	                sta 1,x
.a7cf	60		rts		z_zero_unequal: rts
.a7d0					xt_editor_screen_helper:
.a7d0	20 b8 8d	jsr $8db8	                jsr xt_dup
.a7d3	20 b4 9e	jsr $9eb4	                jsr xt_scr
.a7d6	20 68 a1	jsr $a168	                jsr xt_store
.a7d9	20 c1 85	jsr $85c1	                jsr xt_buffer
.a7dc					z_editor_screen_helper:
.a7dc	60		rts		                rts
.a7dd					xt_editor_enter_screen:
.a7dd	20 d0 a7	jsr $a7d0	                jsr xt_editor_screen_helper
.a7e0	20 37 8d	jsr $8d37	                jsr xt_drop
.a7e3	64 2e		stz $2e		                stz editor1
.a7e5					_prompt_loop:
.a7e5	ca		dex		                dex
.a7e6	ca		dex		                dex
.a7e7	a5 2e		lda $2e		                lda editor1
.a7e9	95 00		sta $00,x	                sta 0,x
.a7eb	74 01		stz $01,x	                stz 1,x
.a7ed	20 b2 a8	jsr $a8b2	                jsr xt_editor_o
.a7f0	e6 2e		inc $2e		                inc editor1
.a7f2	a9 10		lda #$10	                lda #16
.a7f4	c5 2e		cmp $2e		                cmp editor1
.a7f6	d0 ed		bne $a7e5	                bne _prompt_loop
.a7f8					z_editor_enter_screen:
.a7f8	60		rts		                rts
.a7f9					xt_editor_erase_screen:
.a7f9	20 d0 a7	jsr $a7d0	                jsr xt_editor_screen_helper
.a7fc	ca		dex		                dex
.a7fd	ca		dex		                dex
.a7fe	74 00		stz $00,x	                stz 0,x
.a800	a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a802	95 01		sta $01,x	                sta 1,x
.a804	20 f3 8e	jsr $8ef3	                jsr xt_blank
.a807	20 3f a6	jsr $a63f	                jsr xt_update
.a80a					z_editor_erase_screen:
.a80a	60		rts		                rts
.a80b					xt_editor_el:
.a80b	20 99 a8	jsr $a899	                jsr xt_editor_line
.a80e	ca		dex		                dex
.a80f	ca		dex		                dex
.a810	a9 40		lda #$40	                lda #64
.a812	95 00		sta $00,x	                sta 0,x
.a814	74 01		stz $01,x	                stz 1,x
.a816	20 f3 8e	jsr $8ef3	                jsr xt_blank
.a819	20 3f a6	jsr $a63f	                jsr xt_update
.a81c	60		rts		z_editor_el:    rts
.a81d					xt_editor_l:
.a81d	ca		dex		                dex             ; Put SCR on the stack.
.a81e	ca		dex		                dex
.a81f	a0 02		ldy #$02	                ldy #scr_offset
.a821	b1 1e		lda ($1e),y	                lda (up),y
.a823	95 00		sta $00,x	                sta 0,x
.a825	c8		iny		                iny
.a826	b1 1e		lda ($1e),y	                lda (up),y
.a828	95 01		sta $01,x	                sta 1,x
.a82a	20 cd 83	jsr $83cd	                jsr xt_block    ; Get the current screen.
.a82d	20 80 89	jsr $8980	                jsr xt_cr
.a830	80 08		bra $a83a	                bra _after_screen_msg
.a832					_screen_msg:
>a832	53 63 72 65 65 6e 20 23		                .text "Screen #"
.a83a					_after_screen_msg:
.a83a	20 84 a0	jsr $a084	                jsr sliteral_runtime
>a83d	32 a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a841	20 de a4	jsr $a4de	                jsr xt_type
.a844	20 b4 9e	jsr $9eb4	                jsr xt_scr
.a847	20 89 8f	jsr $8f89	                jsr xt_fetch
.a84a	ca		dex		                dex
.a84b	ca		dex		                dex
.a84c	a9 04		lda #$04	                lda #4          ; four spaces
.a84e	95 00		sta $00,x	                sta 0,x
.a850	74 01		stz $01,x	                stz 1,x
.a852	20 15 a5	jsr $a515	                jsr xt_u_dot_r
.a855	64 28		stz $28		                stz tmp3
.a857					_line_loop:
.a857	20 80 89	jsr $8980	                jsr xt_cr
.a85a	ca		dex		                dex
.a85b	ca		dex		                dex
.a85c	ca		dex		                dex
.a85d	ca		dex		                dex
.a85e	74 03		stz $03,x	                stz 3,x
.a860	a5 28		lda $28		                lda tmp3
.a862	95 02		sta $02,x	                sta 2,x
.a864	74 01		stz $01,x	                stz 1,x
.a866	a9 02		lda #$02	                lda #2
.a868	95 00		sta $00,x	                sta 0,x
.a86a	20 15 a5	jsr $a515	                jsr xt_u_dot_r
.a86d	20 f9 a0	jsr $a0f9	                jsr xt_space
.a870	20 b8 8d	jsr $8db8	                jsr xt_dup
.a873	ca		dex		                dex
.a874	ca		dex		                dex
.a875	a9 40		lda #$40	                lda #64
.a877	95 00		sta $00,x	                sta 0,x
.a879	74 01		stz $01,x	                stz 1,x
.a87b	20 de a4	jsr $a4de	                jsr xt_type
.a87e	18		clc		                clc
.a87f	a9 40		lda #$40	                lda #64
.a881	75 00		adc $00,x	                adc 0,x
.a883	95 00		sta $00,x	                sta 0,x
.a885	b5 01		lda $01,x	                lda 1,x
.a887	69 00		adc #$00	                adc #0      ; Add carry
.a889	95 01		sta $01,x	                sta 1,x
.a88b	e6 28		inc $28		                inc tmp3
.a88d	a5 28		lda $28		                lda tmp3
.a88f	c9 10		cmp #$10	                cmp #16
.a891	d0 c4		bne $a857	                bne _line_loop
.a893	20 80 89	jsr $8980	                jsr xt_cr
.a896	e8		inx		                inx
.a897	e8		inx		                inx
.a898	60		rts		z_editor_l:            rts
.a899					xt_editor_line:
.a899	20 44 d8	jsr $d844	                jsr underflow_1
.a89c	a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a89e					_shift_tos_left:
.a89e	16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a8a0	36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a8a2	88		dey		                dey
.a8a3	d0 f9		bne $a89e	                bne _shift_tos_left
.a8a5	20 b4 9e	jsr $9eb4	                jsr xt_scr
.a8a8	20 89 8f	jsr $8f89	                jsr xt_fetch
.a8ab	20 cd 83	jsr $83cd	                jsr xt_block
.a8ae	20 ed 99	jsr $99ed	                jsr xt_plus
.a8b1	60		rts		z_editor_line:  rts
.a8b2					xt_editor_o:
.a8b2	20 80 89	jsr $8980	                jsr xt_cr
.a8b5	20 b8 8d	jsr $8db8	                jsr xt_dup
.a8b8	20 82 a3	jsr $a382	                jsr xt_two
.a8bb	20 15 a5	jsr $a515	                jsr xt_u_dot_r
.a8be	20 f9 a0	jsr $a0f9	                jsr xt_space
.a8c1	a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a8c3	20 ff 8d	jsr $8dff	                jsr emit_a
.a8c6	20 f9 a0	jsr $a0f9	                jsr xt_space
.a8c9	20 99 a8	jsr $a899	                jsr xt_editor_line
.a8cc	20 b8 8d	jsr $8db8	                jsr xt_dup      ; Save a copy of the line address for later.
.a8cf	ca		dex		                dex
.a8d0	ca		dex		                dex
.a8d1	a9 40		lda #$40	                lda #64         ; chars/line
.a8d3	95 00		sta $00,x	                sta 0,x
.a8d5	74 01		stz $01,x	                stz 1,x
.a8d7	20 38 81	jsr $8138	                jsr xt_accept
.a8da	20 b8 8d	jsr $8db8	                jsr xt_dup
.a8dd	20 78 96	jsr $9678	                jsr xt_not_rote ; -rot
.a8e0	20 ed 99	jsr $99ed	                jsr xt_plus
.a8e3	ca		dex		                dex
.a8e4	ca		dex		                dex
.a8e5	a9 40		lda #$40	                lda #64         ; chars/line
.a8e7	95 00		sta $00,x	                sta 0,x
.a8e9	74 01		stz $01,x	                stz 1,x
.a8eb	20 61 9b	jsr $9b61	                jsr xt_rot
.a8ee	20 5a 95	jsr $955a	                jsr xt_minus
.a8f1	20 f3 8e	jsr $8ef3	                jsr xt_blank
.a8f4	20 3f a6	jsr $a63f	                jsr xt_update
.a8f7	60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a8f8					assembler:
.a8f8					xt_asm_adc_h:
.a8f8	a9 69		lda #$69	                lda #$69
.a8fa	4c 53 ac	jmp $ac53	                jmp asm_common
.a8fd					z_asm_adc_h:
.a8fd					xt_asm_adc_x:
.a8fd	a9 7d		lda #$7d	                lda #$7D
.a8ff	4c 53 ac	jmp $ac53	                jmp asm_common
.a902					z_asm_adc_x:
.a902					xt_asm_adc_y:
.a902	a9 79		lda #$79	                lda #$79
.a904	4c 53 ac	jmp $ac53	                jmp asm_common
.a907					z_asm_adc_y:
.a907					xt_asm_adc_z:
.a907	a9 65		lda #$65	                lda #$65
.a909	4c 53 ac	jmp $ac53	                jmp asm_common
.a90c					z_asm_adc_z:
.a90c					xt_asm_adc_zi:
.a90c	a9 72		lda #$72	                lda #$72
.a90e	4c 53 ac	jmp $ac53	                jmp asm_common
.a911					z_asm_adc_zi:
.a911					xt_asm_adc_ziy:
.a911	a9 71		lda #$71	                lda #$71
.a913	4c 53 ac	jmp $ac53	                jmp asm_common
.a916					z_asm_adc_ziy:
.a916					xt_asm_adc_zx:
.a916	a9 75		lda #$75	                lda #$75
.a918	4c 53 ac	jmp $ac53	                jmp asm_common
.a91b					z_asm_adc_zx:
.a91b					xt_asm_adc_zxi:
.a91b	a9 61		lda #$61	                lda #$61
.a91d	4c 53 ac	jmp $ac53	                jmp asm_common
.a920					z_asm_adc_zxi:
.a920					xt_asm_and:
.a920	a9 2d		lda #$2d	                lda #$2D
.a922	4c 53 ac	jmp $ac53	                jmp asm_common
.a925					z_asm_and:
.a925					xt_asm_and_h:
.a925	a9 29		lda #$29	                lda #$29
.a927	4c 53 ac	jmp $ac53	                jmp asm_common
.a92a					z_asm_and_h:
.a92a					xt_asm_and_x:
.a92a	a9 3d		lda #$3d	                lda #$3D
.a92c	4c 53 ac	jmp $ac53	                jmp asm_common
.a92f					z_asm_and_x:
.a92f					xt_asm_and_y:
.a92f	a9 39		lda #$39	                lda #$39
.a931	4c 53 ac	jmp $ac53	                jmp asm_common
.a934					z_asm_and_y:
.a934					xt_asm_and_z:
.a934	a9 25		lda #$25	                lda #$25
.a936	4c 53 ac	jmp $ac53	                jmp asm_common
.a939					z_asm_and_z:
.a939					xt_asm_and_zi:
.a939	a9 32		lda #$32	                lda #$32
.a93b	4c 53 ac	jmp $ac53	                jmp asm_common
.a93e					z_asm_and_zi:
.a93e					xt_asm_and_ziy:
.a93e	a9 31		lda #$31	                lda #$31
.a940	4c 53 ac	jmp $ac53	                jmp asm_common
.a943					z_asm_and_ziy:
.a943					xt_asm_and_zx:
.a943	a9 35		lda #$35	                lda #$35
.a945	4c 53 ac	jmp $ac53	                jmp asm_common
.a948					z_asm_and_zx:
.a948					xt_asm_and_zxi:
.a948	a9 21		lda #$21	                lda #$21
.a94a	4c 53 ac	jmp $ac53	                jmp asm_common
.a94d					z_asm_and_zxi:
.a94d					xt_asm_asl:
.a94d	a9 0e		lda #$0e	                lda #$0E
.a94f	4c 53 ac	jmp $ac53	                jmp asm_common
.a952					z_asm_asl:
.a952					xt_asm_asl_a:
.a952	a9 0a		lda #$0a	                lda #$0A
.a954	4c 53 ac	jmp $ac53	                jmp asm_common
.a957					z_asm_asl_a:
.a957					xt_asm_asl_x:
.a957	a9 1e		lda #$1e	                lda #$1E
.a959	4c 53 ac	jmp $ac53	                jmp asm_common
.a95c					z_asm_asl_x:
.a95c					xt_asm_asl_z:
.a95c	a9 06		lda #$06	                lda #$06
.a95e	4c 53 ac	jmp $ac53	                jmp asm_common
.a961					z_asm_asl_z:
.a961					xt_asm_asl_zx:
.a961	a9 16		lda #$16	                lda #$16
.a963	4c 53 ac	jmp $ac53	                jmp asm_common
.a966					z_asm_asl_zx:
.a966					xt_asm_bcc:
.a966	a9 90		lda #$90	                lda #$90
.a968	4c 53 ac	jmp $ac53	                jmp asm_common
.a96b					z_asm_bcc:
.a96b					xt_asm_bcs:
.a96b	a9 b0		lda #$b0	                lda #$B0
.a96d	a0 02		ldy #$02	                ldy #2
.a96f	4c 53 ac	jmp $ac53	                jmp asm_common
.a972					z_asm_bcs:
.a972					xt_asm_beq:
.a972	a9 f0		lda #$f0	                lda #$F0
.a974	4c 53 ac	jmp $ac53	                jmp asm_common
.a977					z_asm_beq:
.a977					xt_asm_bit:
.a977	a9 2c		lda #$2c	                lda #$2C
.a979	4c 53 ac	jmp $ac53	                jmp asm_common
.a97c					z_asm_bit:
.a97c					xt_asm_bit_h:
.a97c	a9 89		lda #$89	                lda #$89
.a97e	4c 53 ac	jmp $ac53	                jmp asm_common
.a981					z_asm_bit_h:
.a981					xt_asm_bit_x:
.a981	a9 3c		lda #$3c	                lda #$3C
.a983	4c 53 ac	jmp $ac53	                jmp asm_common
.a986					z_asm_bit_x:
.a986					xt_asm_bit_z:
.a986	a9 24		lda #$24	                lda #$24
.a988	4c 53 ac	jmp $ac53	                jmp asm_common
.a98b					z_asm_bit_z:
.a98b					xt_asm_bit_zx:
.a98b	a9 34		lda #$34	                lda #$34
.a98d	4c 53 ac	jmp $ac53	                jmp asm_common
.a990					z_asm_bit_zx:
.a990					xt_asm_bmi:
.a990	a9 30		lda #$30	                lda #$30
.a992	4c 53 ac	jmp $ac53	                jmp asm_common
.a995					z_asm_bmi:
.a995					xt_asm_bne:
.a995	a9 d0		lda #$d0	                lda #$D0
.a997	4c 53 ac	jmp $ac53	                jmp asm_common
.a99a					z_asm_bne:
.a99a					xt_asm_bpl:
.a99a	a9 10		lda #$10	                lda #$10
.a99c	4c 53 ac	jmp $ac53	                jmp asm_common
.a99f					z_asm_bpl:
.a99f					xt_asm_bra:
.a99f	a9 80		lda #$80	                lda #$80
.a9a1	4c 53 ac	jmp $ac53	                jmp asm_common
.a9a4					z_asm_bra:
.a9a4					xt_asm_brk:
.a9a4	a9 00		lda #$00	                lda #$00
.a9a6	4c 53 ac	jmp $ac53	                jmp asm_common
.a9a9					z_asm_brk:
.a9a9					xt_asm_bvc:
.a9a9	a9 50		lda #$50	                lda #$50
.a9ab	4c 53 ac	jmp $ac53	                jmp asm_common
.a9ae					z_asm_bvc:
.a9ae					xt_asm_bvs:
.a9ae	a9 70		lda #$70	                lda #$70
.a9b0	4c 53 ac	jmp $ac53	                jmp asm_common
.a9b3					z_asm_bvs:
.a9b3					xt_asm_clc:
.a9b3	a9 18		lda #$18	                lda #$18
.a9b5	4c 53 ac	jmp $ac53	                jmp asm_common
.a9b8					z_asm_clc:
.a9b8					xt_asm_cld:
.a9b8	a9 d8		lda #$d8	                lda #$D8
.a9ba	4c 53 ac	jmp $ac53	                jmp asm_common
.a9bd					z_asm_cld:
.a9bd					xt_asm_cli:
.a9bd	a9 58		lda #$58	                lda #$58
.a9bf	4c 53 ac	jmp $ac53	                jmp asm_common
.a9c2					z_asm_cli:
.a9c2					xt_asm_clv:
.a9c2	a9 b8		lda #$b8	                lda #$B8
.a9c4	4c 53 ac	jmp $ac53	                jmp asm_common
.a9c7					z_asm_clv:
.a9c7					xt_asm_cmp:
.a9c7	a9 cd		lda #$cd	                lda #$CD
.a9c9	4c 53 ac	jmp $ac53	                jmp asm_common
.a9cc					z_asm_cmp:
.a9cc					xt_asm_cmp_h:
.a9cc	a9 c9		lda #$c9	                lda #$C9
.a9ce	4c 53 ac	jmp $ac53	                jmp asm_common
.a9d1					z_asm_cmp_h:
.a9d1					xt_asm_cmp_x:
.a9d1	a9 dd		lda #$dd	                lda #$DD
.a9d3	4c 53 ac	jmp $ac53	                jmp asm_common
.a9d6					z_asm_cmp_x:
.a9d6					xt_asm_cmp_y:
.a9d6	a9 d9		lda #$d9	                lda #$D9
.a9d8	4c 53 ac	jmp $ac53	                jmp asm_common
.a9db					z_asm_cmp_y:
.a9db					xt_asm_cmp_z:
.a9db	a9 c5		lda #$c5	                lda #$C5
.a9dd	4c 53 ac	jmp $ac53	                jmp asm_common
.a9e0					z_asm_cmp_z:
.a9e0					xt_asm_cmp_zi:
.a9e0	a9 d2		lda #$d2	                lda #$D2
.a9e2	4c 53 ac	jmp $ac53	                jmp asm_common
.a9e5					z_asm_cmp_zi:
.a9e5					xt_asm_cmp_ziy:
.a9e5	a9 d1		lda #$d1	                lda #$D1
.a9e7	4c 53 ac	jmp $ac53	                jmp asm_common
.a9ea					z_asm_cmp_ziy:
.a9ea					xt_asm_cmp_zx:
.a9ea	a9 d5		lda #$d5	                lda #$D5
.a9ec	4c 53 ac	jmp $ac53	                jmp asm_common
.a9ef					z_asm_cmp_zx:
.a9ef					xt_asm_cmp_zxi:
.a9ef	a9 c1		lda #$c1	                lda #$C1
.a9f1	4c 53 ac	jmp $ac53	                jmp asm_common
.a9f4					z_asm_cmp_zxi:
.a9f4					xt_asm_cpx:
.a9f4	a9 ec		lda #$ec	                lda #$EC
.a9f6	4c 53 ac	jmp $ac53	                jmp asm_common
.a9f9					z_asm_cpx:
.a9f9					xt_asm_cpx_h:
.a9f9	a9 e0		lda #$e0	                lda #$E0
.a9fb	4c 53 ac	jmp $ac53	                jmp asm_common
.a9fe					z_asm_cpx_h:
.a9fe					xt_asm_cpx_z:
.a9fe	a9 e4		lda #$e4	                lda #$E4
.aa00	4c 53 ac	jmp $ac53	                jmp asm_common
.aa03					z_asm_cpx_z:
.aa03					xt_asm_cpy:
.aa03	a9 cc		lda #$cc	                lda #$CC
.aa05	a0 03		ldy #$03	                ldy #3
.aa07	4c 53 ac	jmp $ac53	                jmp asm_common
.aa0a					z_asm_cpy:
.aa0a					xt_asm_cpy_h:
.aa0a	a9 c0		lda #$c0	                lda #$C0
.aa0c	4c 53 ac	jmp $ac53	                jmp asm_common
.aa0f					z_asm_cpy_h:
.aa0f					xt_asm_cpy_z:
.aa0f	a9 c4		lda #$c4	                lda #$C4
.aa11	4c 53 ac	jmp $ac53	                jmp asm_common
.aa14					z_asm_cpy_z:
.aa14					xt_asm_dec:
.aa14	a9 ce		lda #$ce	                lda #$CE
.aa16	4c 53 ac	jmp $ac53	                jmp asm_common
.aa19					z_asm_dec:
.aa19					xt_asm_dec_a:
.aa19	a9 3a		lda #$3a	                lda #$3A
.aa1b	4c 53 ac	jmp $ac53	                jmp asm_common
.aa1e					z_asm_dec_a:
.aa1e					xt_asm_dec_x:
.aa1e	a9 de		lda #$de	                lda #$DE
.aa20	4c 53 ac	jmp $ac53	                jmp asm_common
.aa23					z_asm_dec_x:
.aa23					xt_asm_dec_z:
.aa23	a9 c6		lda #$c6	                lda #$C6
.aa25	4c 53 ac	jmp $ac53	                jmp asm_common
.aa28					z_asm_dec_z:
.aa28					xt_asm_dec_zx:
.aa28	a9 d6		lda #$d6	                lda #$D6
.aa2a	4c 53 ac	jmp $ac53	                jmp asm_common
.aa2d					z_asm_dec_zx:
.aa2d					xt_asm_dex:
.aa2d	a9 ca		lda #$ca	                lda #$CA
.aa2f	4c 53 ac	jmp $ac53	                jmp asm_common
.aa32					z_asm_dex:
.aa32					xt_asm_dey:
.aa32	a9 88		lda #$88	                lda #$88
.aa34	4c 53 ac	jmp $ac53	                jmp asm_common
.aa37					z_asm_dey:
.aa37					xt_asm_eor:
.aa37	a9 4d		lda #$4d	                lda #$4D
.aa39	4c 53 ac	jmp $ac53	                jmp asm_common
.aa3c					z_asm_eor:
.aa3c					xt_asm_eor_h:
.aa3c	a9 49		lda #$49	                lda #$49
.aa3e	4c 53 ac	jmp $ac53	                jmp asm_common
.aa41					z_asm_eor_h:
.aa41					xt_asm_eor_x:
.aa41	a9 5d		lda #$5d	                lda #$5D
.aa43	4c 53 ac	jmp $ac53	                jmp asm_common
.aa46					z_asm_eor_x:
.aa46					xt_asm_eor_y:
.aa46	a9 59		lda #$59	                lda #$59
.aa48	4c 53 ac	jmp $ac53	                jmp asm_common
.aa4b					z_asm_eor_y:
.aa4b					xt_asm_eor_z:
.aa4b	a9 45		lda #$45	                lda #$45
.aa4d	4c 53 ac	jmp $ac53	                jmp asm_common
.aa50					z_asm_eor_z:
.aa50					xt_asm_eor_zi:
.aa50	a9 52		lda #$52	                lda #$52
.aa52	4c 53 ac	jmp $ac53	                jmp asm_common
.aa55					z_asm_eor_zi:
.aa55					xt_asm_eor_ziy:
.aa55	a9 51		lda #$51	                lda #$51
.aa57	4c 53 ac	jmp $ac53	                jmp asm_common
.aa5a					z_asm_eor_ziy:
.aa5a					xt_asm_eor_zx:
.aa5a	a9 55		lda #$55	                lda #$55
.aa5c	4c 53 ac	jmp $ac53	                jmp asm_common
.aa5f					z_asm_eor_zx:
.aa5f					xt_asm_eor_zxi:
.aa5f	a9 41		lda #$41	                lda #$41
.aa61	4c 53 ac	jmp $ac53	                jmp asm_common
.aa64					z_asm_eor_zxi:
.aa64					xt_asm_inc:
.aa64	a9 ee		lda #$ee	                lda #$EE
.aa66	4c 53 ac	jmp $ac53	                jmp asm_common
.aa69					z_asm_inc:
.aa69					xt_asm_inc_a:
.aa69	a9 1a		lda #$1a	                lda #$1A
.aa6b	4c 53 ac	jmp $ac53	                jmp asm_common
.aa6e					z_asm_inc_a:
.aa6e					xt_asm_inc_x:
.aa6e	a9 fe		lda #$fe	                lda #$FE
.aa70	4c 53 ac	jmp $ac53	                jmp asm_common
.aa73					z_asm_inc_x:
.aa73					xt_asm_inc_z:
.aa73	a9 e6		lda #$e6	                lda #$E6
.aa75	4c 53 ac	jmp $ac53	                jmp asm_common
.aa78					z_asm_inc_z:
.aa78					xt_asm_inc_zx:
.aa78	a9 f6		lda #$f6	                lda #$F6
.aa7a	4c 53 ac	jmp $ac53	                jmp asm_common
.aa7d					z_asm_inc_zx:
.aa7d					xt_asm_inx:
.aa7d	a9 e8		lda #$e8	                lda #$E8
.aa7f	4c 53 ac	jmp $ac53	                jmp asm_common
.aa82					z_asm_inx:
.aa82					xt_asm_iny:
.aa82	a9 c8		lda #$c8	                lda #$C8
.aa84	4c 53 ac	jmp $ac53	                jmp asm_common
.aa87					z_asm_iny:
.aa87					xt_asm_jmp:
.aa87	a9 4c		lda #$4c	                lda #$4C
.aa89	4c 53 ac	jmp $ac53	                jmp asm_common
.aa8c					z_asm_jmp:
.aa8c					xt_asm_jmp_i:
.aa8c	a9 6c		lda #$6c	                lda #$6C
.aa8e	4c 53 ac	jmp $ac53	                jmp asm_common
.aa91					z_asm_jmp_i:
.aa91					xt_asm_jmp_xi:
.aa91	a9 7c		lda #$7c	                lda #$7C
.aa93	4c 53 ac	jmp $ac53	                jmp asm_common
.aa96					z_asm_jmp_xi:
.aa96					xt_asm_jsr:
.aa96	a9 20		lda #$20	                lda #$20
.aa98	4c 53 ac	jmp $ac53	                jmp asm_common
.aa9b					z_asm_jsr:
.aa9b					xt_asm_lda:
.aa9b	a9 ad		lda #$ad	                lda #$AD
.aa9d	4c 53 ac	jmp $ac53	                jmp asm_common
.aaa0					z_asm_lda:
.aaa0					xt_asm_lda_h:
.aaa0	a9 a9		lda #$a9	                lda #$A9
.aaa2	4c 53 ac	jmp $ac53	                jmp asm_common
.aaa5					z_asm_lda_h:
.aaa5					xt_asm_lda_x:
.aaa5	a9 bd		lda #$bd	                lda #$BD
.aaa7	4c 53 ac	jmp $ac53	                jmp asm_common
.aaaa					z_asm_lda_x:
.aaaa					xt_asm_lda_y:
.aaaa	a9 b9		lda #$b9	                lda #$B9
.aaac	4c 53 ac	jmp $ac53	                jmp asm_common
.aaaf					z_asm_lda_y:
.aaaf					xt_asm_lda_z:
.aaaf	a9 a5		lda #$a5	                lda #$A5
.aab1	4c 53 ac	jmp $ac53	                jmp asm_common
.aab4					z_asm_lda_z:
.aab4					xt_asm_lda_zi:
.aab4	a9 b2		lda #$b2	                lda #$B2
.aab6	4c 53 ac	jmp $ac53	                jmp asm_common
.aab9					z_asm_lda_zi:
.aab9					xt_asm_lda_ziy:
.aab9	a9 b1		lda #$b1	                lda #$B1
.aabb	4c 53 ac	jmp $ac53	                jmp asm_common
.aabe					z_asm_lda_ziy:
.aabe					xt_asm_lda_zx:
.aabe	a9 b5		lda #$b5	                lda #$B5
.aac0	4c 53 ac	jmp $ac53	                jmp asm_common
.aac3					z_asm_lda_zx:
.aac3					xt_asm_lda_zxi:
.aac3	a9 a1		lda #$a1	                lda #$A1
.aac5	4c 53 ac	jmp $ac53	                jmp asm_common
.aac8					z_asm_lda_zxi:
.aac8					xt_asm_ldx:
.aac8	a9 ae		lda #$ae	                lda #$AE
.aaca	4c 53 ac	jmp $ac53	                jmp asm_common
.aacd					z_asm_ldx:
.aacd					xt_asm_ldx_h:
.aacd	a9 a2		lda #$a2	                lda #$A2
.aacf	4c 53 ac	jmp $ac53	                jmp asm_common
.aad2					z_asm_ldx_h:
.aad2					xt_asm_ldx_y:
.aad2	a9 be		lda #$be	                lda #$BE
.aad4	4c 53 ac	jmp $ac53	                jmp asm_common
.aad7					z_asm_ldx_y:
.aad7					xt_asm_ldx_z:
.aad7	a9 a6		lda #$a6	                lda #$A6
.aad9	4c 53 ac	jmp $ac53	                jmp asm_common
.aadc					z_asm_ldx_z:
.aadc					xt_asm_ldx_zy:
.aadc	a9 b6		lda #$b6	                lda #$B6
.aade	4c 53 ac	jmp $ac53	                jmp asm_common
.aae1					z_asm_ldx_zy:
.aae1					xt_asm_ldy:
.aae1	a9 ac		lda #$ac	                lda #$AC
.aae3	4c 53 ac	jmp $ac53	                jmp asm_common
.aae6					z_asm_ldy:
.aae6					xt_asm_ldy_h:
.aae6	a9 a0		lda #$a0	                lda #$A0
.aae8	4c 53 ac	jmp $ac53	                jmp asm_common
.aaeb					z_asm_ldy_h:
.aaeb					xt_asm_ldy_x:
.aaeb	a9 bc		lda #$bc	                lda #$BC
.aaed	4c 53 ac	jmp $ac53	                jmp asm_common
.aaf0					z_asm_ldy_x:
.aaf0					xt_asm_ldy_z:
.aaf0	a9 a4		lda #$a4	                lda #$A4
.aaf2	4c 53 ac	jmp $ac53	                jmp asm_common
.aaf5					z_asm_ldy_z:
.aaf5					xt_asm_ldy_zx:
.aaf5	a9 b4		lda #$b4	                lda #$B4
.aaf7	4c 53 ac	jmp $ac53	                jmp asm_common
.aafa					z_asm_ldy_zx:
.aafa					xt_asm_lsr:
.aafa	a9 4e		lda #$4e	                lda #$4E
.aafc	4c 53 ac	jmp $ac53	                jmp asm_common
.aaff					z_asm_lsr:
.aaff					xt_asm_lsr_a:
.aaff	a9 4a		lda #$4a	                lda #$4A
.ab01	4c 53 ac	jmp $ac53	                jmp asm_common
.ab04					z_asm_lsr_a:
.ab04					xt_asm_lsr_x:
.ab04	a9 5e		lda #$5e	                lda #$5E
.ab06	4c 53 ac	jmp $ac53	                jmp asm_common
.ab09					z_asm_lsr_x:
.ab09					xt_asm_lsr_z:
.ab09	a9 46		lda #$46	                lda #$46
.ab0b	4c 53 ac	jmp $ac53	                jmp asm_common
.ab0e					z_asm_lsr_z:
.ab0e					xt_asm_lsr_zx:
.ab0e	a9 56		lda #$56	                lda #$56
.ab10	4c 53 ac	jmp $ac53	                jmp asm_common
.ab13					z_asm_lsr_zx:
.ab13					xt_asm_nop:
.ab13	a9 ea		lda #$ea	                lda #$EA
.ab15	4c 53 ac	jmp $ac53	                jmp asm_common
.ab18					z_asm_nop:
.ab18					xt_asm_ora:
.ab18	a9 0d		lda #$0d	                lda #$0D
.ab1a	4c 53 ac	jmp $ac53	                jmp asm_common
.ab1d					z_asm_ora:
.ab1d					xt_asm_ora_h:
.ab1d	a9 09		lda #$09	                lda #$09
.ab1f	4c 53 ac	jmp $ac53	                jmp asm_common
.ab22					z_asm_ora_h:
.ab22					xt_asm_ora_x:
.ab22	a9 1d		lda #$1d	                lda #$1D
.ab24	4c 53 ac	jmp $ac53	                jmp asm_common
.ab27					z_asm_ora_x:
.ab27					xt_asm_ora_y:
.ab27	a9 19		lda #$19	                lda #$19
.ab29	4c 53 ac	jmp $ac53	                jmp asm_common
.ab2c					z_asm_ora_y:
.ab2c					xt_asm_ora_z:
.ab2c	a9 05		lda #$05	                lda #$05
.ab2e	4c 53 ac	jmp $ac53	                jmp asm_common
.ab31					z_asm_ora_z:
.ab31					xt_asm_ora_zi:
.ab31	a9 12		lda #$12	                lda #$12
.ab33	a0 02		ldy #$02	                ldy #2
.ab35	4c 53 ac	jmp $ac53	                jmp asm_common
.ab38					z_asm_ora_zi:
.ab38					xt_asm_ora_ziy:
.ab38	a9 11		lda #$11	                lda #$11
.ab3a	4c 53 ac	jmp $ac53	                jmp asm_common
.ab3d					z_asm_ora_ziy:
.ab3d					xt_asm_ora_zx:
.ab3d	a9 15		lda #$15	                lda #$15
.ab3f	4c 53 ac	jmp $ac53	                jmp asm_common
.ab42					z_asm_ora_zx:
.ab42					xt_asm_ora_zxi:
.ab42	a9 01		lda #$01	                lda #$01
.ab44	4c 53 ac	jmp $ac53	                jmp asm_common
.ab47					z_asm_ora_zxi:
.ab47					xt_asm_pha:
.ab47	a9 48		lda #$48	                lda #$48
.ab49	4c 53 ac	jmp $ac53	                jmp asm_common
.ab4c					z_asm_pha:
.ab4c					xt_asm_php:
.ab4c	a9 08		lda #$08	                lda #$08
.ab4e	4c 53 ac	jmp $ac53	                jmp asm_common
.ab51					z_asm_php:
.ab51					xt_asm_phx:
.ab51	a9 da		lda #$da	                lda #$DA
.ab53	4c 53 ac	jmp $ac53	                jmp asm_common
.ab56					z_asm_phx:
.ab56					xt_asm_phy:
.ab56	a9 5a		lda #$5a	                lda #$5A
.ab58	4c 53 ac	jmp $ac53	                jmp asm_common
.ab5b					z_asm_phy:
.ab5b					xt_asm_pla:
.ab5b	a9 68		lda #$68	                lda #$68
.ab5d	4c 53 ac	jmp $ac53	                jmp asm_common
.ab60					z_asm_pla:
.ab60					xt_asm_plp:
.ab60	a9 28		lda #$28	                lda #$28
.ab62	4c 53 ac	jmp $ac53	                jmp asm_common
.ab65					z_asm_plp:
.ab65					xt_asm_plx:
.ab65	a9 fa		lda #$fa	                lda #$FA
.ab67	4c 53 ac	jmp $ac53	                jmp asm_common
.ab6a					z_asm_plx:
.ab6a					xt_asm_ply:
.ab6a	a9 7a		lda #$7a	                lda #$7A
.ab6c	4c 53 ac	jmp $ac53	                jmp asm_common
.ab6f					z_asm_ply:
.ab6f					xt_asm_rol:
.ab6f	a9 2e		lda #$2e	                lda #$2E
.ab71	4c 53 ac	jmp $ac53	                jmp asm_common
.ab74					z_asm_rol:
.ab74					xt_asm_rol_a:
.ab74	a9 2a		lda #$2a	                lda #$2A
.ab76	4c 53 ac	jmp $ac53	                jmp asm_common
.ab79					z_asm_rol_a:
.ab79					xt_asm_rol_x:
.ab79	a9 3e		lda #$3e	                lda #$3E
.ab7b	4c 53 ac	jmp $ac53	                jmp asm_common
.ab7e					z_asm_rol_x:
.ab7e					xt_asm_rol_z:
.ab7e	a9 26		lda #$26	                lda #$26
.ab80	4c 53 ac	jmp $ac53	                jmp asm_common
.ab83					z_asm_rol_z:
.ab83					xt_asm_rol_zx:
.ab83	a9 36		lda #$36	                lda #$36
.ab85	4c 53 ac	jmp $ac53	                jmp asm_common
.ab88					z_asm_rol_zx:
.ab88					xt_asm_ror:
.ab88	a9 6e		lda #$6e	                lda #$6E
.ab8a	4c 53 ac	jmp $ac53	                jmp asm_common
.ab8d					z_asm_ror:
.ab8d					xt_asm_ror_a:
.ab8d	a9 6a		lda #$6a	                lda #$6A
.ab8f	4c 53 ac	jmp $ac53	                jmp asm_common
.ab92					z_asm_ror_a:
.ab92					xt_asm_ror_x:
.ab92	a9 7e		lda #$7e	                lda #$7E
.ab94	4c 53 ac	jmp $ac53	                jmp asm_common
.ab97					z_asm_ror_x:
.ab97					xt_asm_ror_z:
.ab97	a9 66		lda #$66	                lda #$66
.ab99	4c 53 ac	jmp $ac53	                jmp asm_common
.ab9c					z_asm_ror_z:
.ab9c					xt_asm_ror_zx:
.ab9c	a9 76		lda #$76	                lda #$76
.ab9e	4c 53 ac	jmp $ac53	                jmp asm_common
.aba1					z_asm_ror_zx:
.aba1					xt_asm_rti:
.aba1	a9 40		lda #$40	                lda #$40
.aba3	4c 53 ac	jmp $ac53	                jmp asm_common
.aba6					z_asm_rti:
.aba6					xt_asm_rts:
.aba6	a9 60		lda #$60	                lda #$60
.aba8	4c 53 ac	jmp $ac53	                jmp asm_common
.abab					z_asm_rts:
.abab					xt_asm_sbc:
.abab	a9 ed		lda #$ed	                lda #$ED
.abad	4c 53 ac	jmp $ac53	                jmp asm_common
.abb0					z_asm_sbc:
.abb0					xt_asm_sbc_h:
.abb0	a9 e9		lda #$e9	                lda #$E9
.abb2	4c 53 ac	jmp $ac53	                jmp asm_common
.abb5					z_asm_sbc_h:
.abb5					xt_asm_sbc_x:
.abb5	a9 fd		lda #$fd	                lda #$FD
.abb7	4c 53 ac	jmp $ac53	                jmp asm_common
.abba					z_asm_sbc_x:
.abba					xt_asm_sbc_y:
.abba	a9 f9		lda #$f9	                lda #$F9
.abbc	4c 53 ac	jmp $ac53	                jmp asm_common
.abbf					z_asm_sbc_y:
.abbf					xt_asm_sbc_z:
.abbf	a9 e5		lda #$e5	                lda #$E5
.abc1	4c 53 ac	jmp $ac53	                jmp asm_common
.abc4					z_asm_sbc_z:
.abc4					xt_asm_sbc_zi:
.abc4	a9 f2		lda #$f2	                lda #$F2
.abc6	4c 53 ac	jmp $ac53	                jmp asm_common
.abc9					z_asm_sbc_zi:
.abc9					xt_asm_sbc_ziy:
.abc9	a9 f1		lda #$f1	                lda #$F1
.abcb	4c 53 ac	jmp $ac53	                jmp asm_common
.abce					z_asm_sbc_ziy:
.abce					xt_asm_sbc_zx:
.abce	a9 f5		lda #$f5	                lda #$F5
.abd0	4c 53 ac	jmp $ac53	                jmp asm_common
.abd3					z_asm_sbc_zx:
.abd3					xt_asm_sbc_zxi:
.abd3	a9 e1		lda #$e1	                lda #$E1
.abd5	80 7c		bra $ac53	                bra asm_common  ; <-- limit for BRA instead of JMP
.abd7					z_asm_sbc_zxi:
.abd7					xt_asm_sec:
.abd7	a9 38		lda #$38	                lda #$38
.abd9	80 78		bra $ac53	                bra asm_common
.abdb					z_asm_sec:
.abdb					xt_asm_sed:
.abdb	a9 f8		lda #$f8	                lda #$F8
.abdd	80 74		bra $ac53	                bra asm_common
.abdf					z_asm_sed:
.abdf					xt_asm_sei:
.abdf	a9 78		lda #$78	                lda #$78
.abe1	80 70		bra $ac53	                bra asm_common
.abe3					z_asm_sei:
.abe3					xt_asm_sta:
.abe3	a9 8d		lda #$8d	                lda #$8D
.abe5	80 6c		bra $ac53	                bra asm_common
.abe7					z_asm_sta:
.abe7					xt_asm_sta_x:
.abe7	a9 9d		lda #$9d	                lda #$9D
.abe9	80 68		bra $ac53	                bra asm_common
.abeb					z_asm_sta_x:
.abeb					xt_asm_sta_y:
.abeb	a9 99		lda #$99	                lda #$99
.abed	80 64		bra $ac53	                bra asm_common
.abef					z_asm_sta_y:
.abef					xt_asm_sta_z:
.abef	a9 85		lda #$85	                lda #$85
.abf1	80 60		bra $ac53	                bra asm_common
.abf3					z_asm_sta_z:
.abf3					xt_asm_sta_zi:
.abf3	a9 92		lda #$92	                lda #$92
.abf5	80 5c		bra $ac53	                bra asm_common
.abf7					z_asm_sta_zi:
.abf7					xt_asm_sta_ziy:
.abf7	a9 91		lda #$91	                lda #$91
.abf9	80 58		bra $ac53	                bra asm_common
.abfb					z_asm_sta_ziy:
.abfb					xt_asm_sta_zx:
.abfb	a9 95		lda #$95	                lda #$95
.abfd	80 54		bra $ac53	                bra asm_common
.abff					z_asm_sta_zx:
.abff					xt_asm_sta_zxi:
.abff	a9 81		lda #$81	                lda #$81
.ac01	80 50		bra $ac53	                bra asm_common
.ac03					z_asm_sta_zxi:
.ac03					xt_asm_stx:
.ac03	a9 8e		lda #$8e	                lda #$8E
.ac05	80 4c		bra $ac53	                bra asm_common
.ac07					z_asm_stx:
.ac07					xt_asm_stx_z:
.ac07	a9 86		lda #$86	                lda #$86
.ac09	80 48		bra $ac53	                bra asm_common
.ac0b					z_asm_stx_z:
.ac0b					xt_asm_stx_zy:
.ac0b	a9 96		lda #$96	                lda #$96
.ac0d	80 44		bra $ac53	                bra asm_common
.ac0f					z_asm_stx_zy:
.ac0f					xt_asm_sty:
.ac0f	a9 8c		lda #$8c	                lda #$8C
.ac11	80 40		bra $ac53	                bra asm_common
.ac13					z_asm_sty:
.ac13					xt_asm_sty_z:
.ac13	a9 84		lda #$84	                lda #$84
.ac15	80 3c		bra $ac53	                bra asm_common
.ac17					z_asm_sty_z:
.ac17					xt_asm_sty_zx:
.ac17	a9 94		lda #$94	                lda #$94
.ac19	80 38		bra $ac53	                bra asm_common
.ac1b					z_asm_sty_zx:
.ac1b					xt_asm_stz:
.ac1b	a9 9c		lda #$9c	                lda #$9C
.ac1d	80 34		bra $ac53	                bra asm_common
.ac1f					z_asm_stz:
.ac1f					xt_asm_stz_x:
.ac1f	a9 9e		lda #$9e	                lda #$9E
.ac21	80 30		bra $ac53	                bra asm_common
.ac23					z_asm_stz_x:
.ac23					xt_asm_stz_z:
.ac23	a9 64		lda #$64	                lda #$64
.ac25	80 2c		bra $ac53	                bra asm_common
.ac27					z_asm_stz_z:
.ac27					xt_asm_stz_zx:
.ac27	a9 74		lda #$74	                lda #$74
.ac29	80 28		bra $ac53	                bra asm_common
.ac2b					z_asm_stz_zx:
.ac2b					xt_asm_tax:
.ac2b	a9 aa		lda #$aa	                lda #$AA
.ac2d	80 24		bra $ac53	                bra asm_common
.ac2f					z_asm_tax:
.ac2f					xt_asm_tay:
.ac2f	a9 a8		lda #$a8	                lda #$A8
.ac31	80 20		bra $ac53	                bra asm_common
.ac33					z_asm_tay:
.ac33					xt_asm_trb:
.ac33	a9 1c		lda #$1c	                lda #$1C
.ac35	80 1c		bra $ac53	                bra asm_common
.ac37					z_asm_trb:
.ac37					xt_asm_trb_z:
.ac37	a9 14		lda #$14	                lda #$14
.ac39	80 18		bra $ac53	                bra asm_common
.ac3b					z_asm_trb_z:
.ac3b					xt_asm_tsb:
.ac3b	a9 0c		lda #$0c	                lda #$0C
.ac3d	80 14		bra $ac53	                bra asm_common
.ac3f					z_asm_tsb:
.ac3f					xt_asm_tsb_z:
.ac3f	a9 04		lda #$04	                lda #$04
.ac41	80 10		bra $ac53	                bra asm_common
.ac43					z_asm_tsb_z:
.ac43					xt_asm_tsx:
.ac43	a9 ba		lda #$ba	                lda #$BA
.ac45	80 0c		bra $ac53	                bra asm_common
.ac47					z_asm_tsx:
.ac47					xt_asm_txa:
.ac47	a9 8a		lda #$8a	                lda #$8A
.ac49	80 08		bra $ac53	                bra asm_common
.ac4b					z_asm_txa:
.ac4b					xt_asm_txs:
.ac4b	a9 9a		lda #$9a	                lda #$9A
.ac4d	80 04		bra $ac53	                bra asm_common
.ac4f					z_asm_txs:
.ac4f					xt_asm_tya:
.ac4f	a9 98		lda #$98	                lda #$98
.ac51	80 00		bra $ac53	                bra asm_common
.ac53					z_asm_tya:
.ac53					asm_common:
.ac53	a8		tay		                tay
.ac54	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.ac57	a9 fc		lda #$fc	                lda #<oc_index_table
.ac59	85 26		sta $26		                sta tmp2
.ac5b	a9 ae		lda #$ae	                lda #>oc_index_table
.ac5d	85 27		sta $27		                sta tmp2+1
.ac5f	98		tya		                tya             ; retrieve opcode
.ac60	0a		asl a		                asl             ; times two for offset
.ac61	90 02		bcc $ac65	                bcc +
.ac63	e6 27		inc $27		                inc tmp2+1
.ac65					+
.ac65	a8		tay		                tay             ; use Y as the index
.ac66	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac68	85 28		sta $28		                sta tmp3
.ac6a	c8		iny		                iny
.ac6b	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac6d	85 29		sta $29		                sta tmp3+1
.ac6f	b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac71	2a		rol a		                rol
.ac72	2a		rol a		                rol
.ac73	2a		rol a		                rol             ; Three times because we go through Carry
.ac74	29 03		and #$03	                and #%00000011
.ac76	a8		tay		                tay
.ac77	88		dey		                dey
.ac78	f0 12		beq $ac8c	                beq _done
.ac7a	20 44 d8	jsr $d844	                jsr underflow_1
.ac7d	b5 00		lda $00,x	                lda 0,x
.ac7f	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; does not use Y
.ac82	88		dey		                dey
.ac83	f0 05		beq $ac8a	                beq _done_drop
.ac85	b5 01		lda $01,x	                lda 1,x
.ac87	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; Fall through to _done_drop
.ac8a					_done_drop:
.ac8a	e8		inx		                inx
.ac8b	e8		inx		                inx             ; Fall through to _done
.ac8c					_done:
.ac8c	60		rts		                rts             ; Returns to original caller
.ac8d					xt_asm_push_a:
.ac8d	a0 00		ldy #$00	                ldy #0
.ac8f					_loop:
.ac8f	b9 9d ac	lda $ac9d,y	                lda asm_push_a_data,y
.ac92	c9 ff		cmp #$ff	                cmp #$FF
.ac94	f0 06		beq $ac9c	                beq _done
.ac96	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; does not change Y
.ac99	c8		iny		                iny
.ac9a	80 f3		bra $ac8f	                bra _loop
.ac9c					_done:
.ac9c					z_asm_push_a:
.ac9c	60		rts		                rts
.ac9d					asm_push_a_data:
>ac9d	ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>aca3	ff				        .byte $FF               ; terminator
.aca4					xt_asm_back_jump:
.aca4					z_asm_back_jump:
.aca4	60		rts		                rts
.aca5					xt_asm_back_branch:
.aca5	20 7b 91	jsr $917b	                jsr xt_here             ; ( addr-l addr-h )
.aca8	20 5a 95	jsr $955a	                jsr xt_minus            ; ( offset )
.acab	3a		dec a		                dea
.acac	3a		dec a		                dea
.acad					z_asm_back_branch:
.acad	60		rts		                rts
.acae					assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acae					disassembler:
.acae	20 80 89	jsr $8980	                jsr xt_cr       ; ( addr u )
.acb1					_byte_loop:
.acb1	20 9d 98	jsr $989d	                jsr xt_over     ; ( addr u addr )
.acb4	20 09 a5	jsr $a509	                jsr xt_u_dot    ; ( addr u )
.acb7	20 f9 a0	jsr $a0f9	                jsr xt_space
.acba	a9 fc		lda #$fc	                lda #<oc_index_table
.acbc	85 26		sta $26		                sta tmp2
.acbe	a9 ae		lda #$ae	                lda #>oc_index_table
.acc0	85 27		sta $27		                sta tmp2+1
.acc2	a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.acc4	85 36		sta $36		                sta scratch     ; Save opcode
.acc6	0a		asl a		                asl             ; multiply by two for offset
.acc7	90 02		bcc $accb	                bcc +
.acc9	e6 27		inc $27		                inc tmp2+1      ; we're on second page
.accb					+
.accb	a8		tay		                tay             ; use Y as the index
.accc	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.acce	85 28		sta $28		                sta tmp3
.acd0	48		pha		                pha
.acd1	c8		iny		                iny
.acd2	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acd4	85 29		sta $29		                sta tmp3+1
.acd6	48		pha		                pha
.acd7	b2 28		lda ($28)	                lda (tmp3)
.acd9	a8		tay		                tay                     ; save copy of lengths byte
.acda	10 3c		bpl $ad18	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.acdc	20 83 a7	jsr $a783	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.acdf	f6 04		inc $04,x	                inc 4,x
.ace1	d0 02		bne $ace5	                bne +
.ace3	f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ace5					+
.ace5	b5 02		lda $02,x	                lda 2,x
.ace7	d0 02		bne $aceb	                bne +
.ace9	d6 03		dec $03,x	                dec 3,x
.aceb					+
.aceb	d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.aced	a1 04		lda ($04,x)	                lda (4,x)
.acef	95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.acf1	85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.acf3	98		tya		                tya                     ; retrieve copy of lengths byte
.acf4	2a		rol a		                rol                     ; shift bit 6 to bit 7
.acf5	10 14		bpl $ad0b	                bpl _print_operand
.acf7	f6 04		inc $04,x	                inc 4,x
.acf9	d0 02		bne $acfd	                bne +
.acfb	f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.acfd					+
.acfd	b5 02		lda $02,x	                lda 2,x
.acff	d0 02		bne $ad03	                bne +
.ad01	d6 03		dec $03,x	                dec 3,x
.ad03					+
.ad03	d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad05	a1 04		lda ($04,x)	                lda (4,x)
.ad07	95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad09	85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad0b					_print_operand:
.ad0b	ca		dex		                dex
.ad0c	ca		dex		                dex
.ad0d	a9 05		lda #$05	                lda #5
.ad0f	95 00		sta $00,x	                sta 0,x
.ad11	74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad13	20 15 a5	jsr $a515	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad16	80 0b		bra $ad23	                bra _print_mnemonic
.ad18					_no_operand:
.ad18	ca		dex		                dex
.ad19	ca		dex		                dex
.ad1a	a9 05		lda #$05	                lda #5
.ad1c	95 00		sta $00,x	                sta 0,x
.ad1e	74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad20	20 ff a0	jsr $a0ff	                jsr xt_spaces           ; ( addr u )
.ad23					_print_mnemonic:
.ad23	20 f9 a0	jsr $a0f9	                jsr xt_space
.ad26	ca		dex		                dex
.ad27	ca		dex		                dex                     ; ( addr u ? )
.ad28	68		pla		                pla                     ; MSB
.ad29	95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad2b	68		pla		                pla                     ; LSB
.ad2c	95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad2e	20 6c 89	jsr $896c	                jsr xt_count            ; ( addr u addr-o u-o )
.ad31	74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad33	b5 00		lda $00,x	                lda 0,x
.ad35	29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad37	95 00		sta $00,x	                sta 0,x
.ad39	20 de a4	jsr $a4de	                jsr xt_type             ; ( addr u )
.ad3c	a5 36		lda $36		                lda scratch
.ad3e	c9 20		cmp #$20	                cmp #$20
.ad40	d0 4e		bne $ad90	                bne _not_jsr
.ad42	ca		dex		                dex
.ad43	ca		dex		                dex
.ad44	a9 05		lda #$05	                lda #5
.ad46	95 00		sta $00,x	                sta 0,x
.ad48	74 01		stz $01,x	                stz 1,x
.ad4a	20 ff a0	jsr $a0ff	                jsr xt_spaces
.ad4d	a0 10		ldy #$10	                ldy #(_end_handlers - _special_handlers - 4)
.ad4f	b9 7c ad	lda $ad7c,y	_check_handler: lda _special_handlers,y
.ad52	c5 37		cmp $37		                cmp scratch+1
.ad54	d0 07		bne $ad5d	                bne _next_handler
.ad56	b9 7d ad	lda $ad7d,y	                lda _special_handlers+1,y
.ad59	c5 38		cmp $38		                cmp scratch+2
.ad5b	f0 0c		beq $ad69	                beq _run_handler
.ad5d	88		dey		_next_handler:  dey
.ad5e	88		dey		                dey
.ad5f	88		dey		                dey
.ad60	88		dey		                dey
.ad61	10 ec		bpl $ad4f	                bpl _check_handler
.ad63					_not_special:
.ad63	20 ac ae	jsr $aeac	                jsr disasm_jsr
.ad66	4c fa ad	jmp $adfa	                jmp _printing_done
.ad69					_run_handler:
.ad69	b9 7e ad	lda $ad7e,y	                lda _special_handlers+2,y
.ad6c	85 39		sta $39		                sta scratch+3
.ad6e	b9 7f ad	lda $ad7f,y	                lda _special_handlers+3,y
.ad71	85 3a		sta $3a		                sta scratch+4
.ad73	20 79 ad	jsr $ad79	                jsr _dispatch_handler
.ad76	4c fa ad	jmp $adfa	                jmp _printing_done
.ad79					_dispatch_handler:
.ad79	6c 39 00	jmp ($0039)	                jmp (scratch+3)
.ad7c					_special_handlers:
>ad7c	9f 93 8e ae			    .word literal_runtime,      disasm_literal
>ad80	84 a0 40 ae			    .word sliteral_runtime,     disasm_sliteral
>ad84	1b 92 77 ae			    .word zero_branch_runtime,  disasm_0branch
>ad88	e4 8d 7c ae			    .word branch_runtime,       disasm_branch
>ad8c	b9 8b 83 ae			    .word do_runtime,           disasm_do
.ad90					_end_handlers:
.ad90					_not_jsr:
.ad90	c9 4c		cmp #$4c	                cmp #$4C
.ad92	d0 2c		bne $adc0	                bne _not_jmp
.ad94	a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.ad96	85 39		sta $39		                sta scratch+3
.ad98	a5 38		lda $38		                lda scratch+2
.ad9a	85 3a		sta $3a		                sta scratch+4
.ad9c	b2 39		lda ($39)	                lda (scratch+3)
.ad9e	c9 20		cmp #$20	                cmp #$20 ; check for JSR
.ada0	d0 58		bne $adfa	                bne _printing_done
.ada2	e6 39		inc $39		                inc scratch+3
.ada4	d0 02		bne $ada8	                bne +
.ada6	e6 3a		inc $3a		                inc scratch+4
.ada8					+
.ada8	b2 39		lda ($39)	                lda (scratch+3)
.adaa	c9 84		cmp #$84	                cmp #<sliteral_runtime
.adac	d0 4c		bne $adfa	                bne _printing_done
.adae	e6 39		inc $39		                inc scratch+3
.adb0	d0 02		bne $adb4	                bne +
.adb2	e6 3a		inc $3a		                inc scratch+4
.adb4					+
.adb4	b2 39		lda ($39)	                lda (scratch+3)
.adb6	c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.adb8	d0 40		bne $adfa	                bne _printing_done
.adba	20 16 ae	jsr $ae16	                jsr disasm_sliteral_jump
.adbd	4c fa ad	jmp $adfa	                jmp _printing_done
.adc0					_not_jmp:
.adc0	c9 80		cmp #$80	                cmp #$80            ; is it bra?
.adc2	f0 06		beq $adca	                beq _is_rel
.adc4	29 1f		and #$1f	                and #$1f
.adc6	49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.adc8	d0 30		bne $adfa	                bne _printing_done
.adca					_is_rel:
.adca	a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.adcc	ca		dex		                dex
.adcd	ca		dex		                dex
.adce	74 01		stz $01,x	                stz 1,x
.add0	a5 37		lda $37		                lda scratch+1
.add2	95 00		sta $00,x	                sta 0,x
.add4	10 04		bpl $adda	                bpl +
.add6	d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.add8	a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.adda	38		sec		+               sec                 ; start counting from address after opcode
.addb	75 04		adc $04,x	                adc 4,x
.addd	95 00		sta $00,x	                sta 0,x
.addf	b5 01		lda $01,x	                lda 1,x
.ade1	75 05		adc $05,x	                adc 5,x
.ade3	95 01		sta $01,x	                sta 1,x
.ade5	5a		phy		                phy                 ; save the direction indicator
.ade6	ca		dex		                dex
.ade7	ca		dex		                dex
.ade8	a9 09		lda #$09	                lda #9
.adea	95 00		sta $00,x	                sta 0,x
.adec	74 01		stz $01,x	                stz 1,x
.adee	20 15 a5	jsr $a515	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.adf1	a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.adf3	20 ff 8d	jsr $8dff	                jsr emit_a
.adf6	68		pla		                pla
.adf7	20 ff 8d	jsr $8dff	                jsr emit_a
.adfa					_printing_done:
.adfa	20 80 89	jsr $8980	                jsr xt_cr
.adfd	f6 02		inc $02,x	                inc 2,x
.adff	d0 02		bne $ae03	                bne +
.ae01	f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ae03					+
.ae03	20 1b 98	jsr $981b	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ae06	b5 00		lda $00,x	                lda 0,x                 ; All done?
.ae08	15 01		ora $01,x	                ora 1,x
.ae0a	f0 07		beq $ae13	                beq _done
.ae0c	b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae0e	30 03		bmi $ae13	                bmi _done
.ae10	4c b1 ac	jmp $acb1	                jmp _byte_loop          ; out of range for BRA
.ae13					_done:
.ae13	4c 8b a3	jmp $a38b	                jmp xt_two_drop         ; JSR/RTS
.ae16					disasm_sliteral_jump:
.ae16	20 89 a1	jsr $a189	                jsr xt_swap
.ae19	ca		dex		                dex
.ae1a	ca		dex		                dex
.ae1b	a5 37		lda $37		                lda scratch+1
.ae1d	95 00		sta $00,x	                sta 0,x
.ae1f	a5 38		lda $38		                lda scratch+2
.ae21	95 01		sta $01,x	                sta 1,x
.ae23	20 89 a1	jsr $a189	                jsr xt_swap
.ae26	20 5a 95	jsr $955a	                jsr xt_minus
.ae29	20 1b 98	jsr $981b	                jsr xt_one_minus
.ae2c	20 5a 95	jsr $955a	                jsr xt_minus
.ae2f	ca		dex		                dex
.ae30	ca		dex		                dex
.ae31	a5 37		lda $37		                lda scratch+1
.ae33	95 00		sta $00,x	                sta 0,x
.ae35	a5 38		lda $38		                lda scratch+2
.ae37	95 01		sta $01,x	                sta 1,x
.ae39	20 1b 98	jsr $981b	                jsr xt_one_minus
.ae3c	20 89 a1	jsr $a189	                jsr xt_swap ; ( new_addr new_n )
.ae3f	60		rts		                rts
.ae40					disasm_sliteral:
.ae40	a9 53		lda #$53	                lda #'S'
.ae42	20 ff 8d	jsr $8dff	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae45	a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.ae47	20 80 d8	jsr $d880	                jsr print_string_no_lf
.ae4a	20 89 a1	jsr $a189	                jsr xt_swap             ; switch to (u addr)
.ae4d	20 27 98	jsr $9827	                jsr xt_one_plus
.ae50	20 b8 8d	jsr $8db8	                jsr xt_dup
.ae53	20 89 8f	jsr $8f89	                jsr xt_fetch
.ae56	20 09 a5	jsr $a509	                jsr xt_u_dot            ; Print the address of the string
.ae59	20 82 a3	jsr $a382	                jsr xt_two
.ae5c	20 ed 99	jsr $99ed	                jsr xt_plus
.ae5f	20 b8 8d	jsr $8db8	                jsr xt_dup
.ae62	20 6c 9a	jsr $9a6c	                jsr xt_question         ; Print the length of the string
.ae65	20 27 98	jsr $9827	                jsr xt_one_plus
.ae68	20 89 a1	jsr $a189	                jsr xt_swap            ; ( addr+4 u )
.ae6b	ca		dex		                dex
.ae6c	ca		dex		                dex
.ae6d	a9 04		lda #$04	                lda #4
.ae6f	95 00		sta $00,x	                sta 0,x
.ae71	74 01		stz $01,x	                stz 1,x
.ae73	20 5a 95	jsr $955a	                jsr xt_minus            ; ( addr+4 u-4 )
.ae76	60		rts		                rts
.ae77					disasm_0branch:
.ae77	a9 30		lda #$30	                lda #'0'
.ae79	20 ff 8d	jsr $8dff	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ae7c					disasm_branch:
.ae7c	a9 0e		lda #$0e	                lda #str_disasm_bra
.ae7e	20 80 d8	jsr $d880	                jsr print_string_no_lf ; "BRANCH "
.ae81	80 10		bra $ae93	                bra disasm_print_literal
.ae83					disasm_do:
.ae83	a9 44		lda #$44	                lda #'D'
.ae85	20 ff 8d	jsr $8dff	                jsr emit_a
.ae88	a9 4f		lda #$4f	                lda #'O'
.ae8a	20 ff 8d	jsr $8dff	                jsr emit_a
.ae8d	60		rts		                rts
.ae8e					disasm_literal:
.ae8e	a9 0c		lda #$0c	                lda #str_disasm_lit
.ae90	20 80 d8	jsr $d880	                jsr print_string_no_lf ; "LITERAL "
.ae93					disasm_print_literal:
.ae93	20 89 a1	jsr $a189	                jsr xt_swap ; switch to (u addr)
.ae96	20 27 98	jsr $9827	                jsr xt_one_plus
.ae99	20 b8 8d	jsr $8db8	                jsr xt_dup
.ae9c	20 6c 9a	jsr $9a6c	                jsr xt_question ; Print the value at the address
.ae9f	20 27 98	jsr $9827	                jsr xt_one_plus
.aea2	20 89 a1	jsr $a189	                jsr xt_swap ; (addr+2 u)
.aea5	20 1b 98	jsr $981b	                jsr xt_one_minus
.aea8	20 1b 98	jsr $981b	                jsr xt_one_minus ; (addr+2 u-2)
.aeab	60		rts		                rts
.aeac					disasm_jsr:
.aeac	ca		dex		                dex
.aead	ca		dex		                dex
.aeae	a5 37		lda $37		                lda scratch+1
.aeb0	95 00		sta $00,x	                sta 0,x
.aeb2	a5 38		lda $38		                lda scratch+2
.aeb4	95 01		sta $01,x	                sta 1,x
.aeb6	20 7f 92	jsr $927f	                jsr xt_int_to_name
.aeb9	b5 00		lda $00,x	                lda 0,x
.aebb	15 01		ora $01,x	                ora 1,x
.aebd	f0 07		beq $aec6	                beq _disasm_no_nt
.aebf	20 08 96	jsr $9608	                jsr xt_name_to_string
.aec2	20 de a4	jsr $a4de	                jsr xt_type
.aec5	60		rts		                rts
.aec6					_disasm_no_nt:
.aec6	20 37 8d	jsr $8d37	                jsr xt_drop ; the 0 indicating no name token
.aec9	ca		dex		                dex
.aeca	ca		dex		                dex
.aecb	a5 37		lda $37		                lda scratch+1
.aecd	95 00		sta $00,x	                sta 0,x
.aecf	a5 38		lda $38		                lda scratch+2
.aed1	95 01		sta $01,x	                sta 1,x
.aed3	ca		dex		                dex
.aed4	ca		dex		                dex
.aed5	a9 44		lda #$44	                lda #<underflow_1
.aed7	95 00		sta $00,x	                sta 0,x
.aed9	a9 d8		lda #$d8	                lda #>underflow_1
.aedb	95 01		sta $01,x	                sta 1,x
.aedd	20 6b d7	jsr $d76b	                jsr compare_16bit
.aee0	f0 02		beq $aee4	                beq _disasm_jsr_uflow_check_upper
.aee2	b0 14		bcs $aef8	                bcs _disasm_jsr_unknown
.aee4					_disasm_jsr_uflow_check_upper:
.aee4	a9 53		lda #$53	                lda #<underflow_4
.aee6	95 00		sta $00,x	                sta 0,x
.aee8	a9 d8		lda #$d8	                lda #>underflow_4
.aeea	95 01		sta $01,x	                sta 1,x
.aeec	20 6b d7	jsr $d76b	                jsr compare_16bit
.aeef	f0 02		beq $aef3	                beq _disasm_jsr_soc
.aef1	90 05		bcc $aef8	                bcc _disasm_jsr_unknown
.aef3					_disasm_jsr_soc:
.aef3	a9 0d		lda #$0d	                lda #str_disasm_sdc
.aef5	20 80 d8	jsr $d880	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.aef8					_disasm_jsr_unknown:
.aef8	20 8b a3	jsr $a38b	                jsr xt_two_drop
.aefb	60		rts		                rts
.aefc					oc_index_table:
>aefc	fc b0 00 b1 94 b5 94 b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>af04	08 b1 0e b1 14 b1 94 b5
>af0c	1a b1 1e b1 24 b1 94 b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af14	2a b1 2e b1 32 b1 36 b1
>af1c	3b b1 3f b1 47 b1 94 b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af24	4e b1 54 b1 5b b1 62 b1
>af2c	69 b1 6d b1 73 b1 94 b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af34	79 b1 7d b1 94 b5 83 b1
>af3c	89 b1 8d b1 94 b5 94 b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af44	95 b1 9b b1 a1 b1 a7 b1
>af4c	ae b1 b2 b1 b8 b1 94 b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af54	be b1 c2 b1 c7 b1 cb b1
>af5c	d0 b1 d4 b1 dc b1 94 b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af64	e3 b1 eb b1 f2 b1 f9 b1
>af6c	00 b2 04 b2 0a b2 94 b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af74	10 b2 16 b2 1c b2 36 b1
>af7c	27 b2 2b b2 94 b5 94 b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>af84	94 b5 33 b2 39 b2 3f b2
>af8c	46 b2 4a b2 50 b2 94 b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>af94	56 b2 5a b2 5e b2 62 b2
>af9c	67 b2 6b b2 73 b2 94 b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>afa4	94 b5 7a b2 81 b2 88 b2
>afac	8f b2 93 b2 99 b2 94 b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>afb4	94 b5 94 b5 a3 b2 a9 b2
>afbc	ae b2 b2 b2 94 b5 94 b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>afc4	ba b2 c0 b2 c6 b2 cc b2
>afcc	d3 b2 d7 b2 dd b2 94 b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>afd4	e3 b2 e9 b2 ed b2 f1 b2
>afdc	f6 b2 fa b2 02 b3 94 b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>afe4	09 b3 10 b3 17 b3 1e b3
>afec	25 b3 29 b3 2f b3 94 b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>aff4	33 b3 3a b3 40 b3 46 b3
>affc	4b b3 4f b3 94 b5 94 b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b004	57 b3 5d b3 63 b3 94 b5
>b00c	69 b3 6d b3 73 b3 94 b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b014	77 b3 7b b3 7f b3 83 b3
>b01c	88 b3 8c b3 94 b3 94 b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b024	9b b3 a2 b3 a9 b3 b0 b3
>b02c	b7 b3 bb b3 c1 b3 94 b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b034	c5 b3 c9 b3 cf b3 d5 b3
>b03c	da b3 e0 b3 e8 b3 94 b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b044	ee b3 f4 b3 fa b3 00 b4
>b04c	07 b4 0b b4 11 b4 94 b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b054	15 b4 19 b4 1d b4 21 b4
>b05c	26 b4 2a b4 32 b4 94 b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b064	39 b4 40 b4 47 b4 4e b4
>b06c	55 b4 59 b4 5f b4 94 b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b074	63 b4 69 b4 6f b4 75 b4
>b07c	7a b4 80 b4 94 b5 94 b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b084	88 b4 8e b4 94 b4 9a b4
>b08c	a1 b4 a5 b4 ab b4 94 b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b094	af b4 b3 b4 b7 b4 bb b4
>b09c	c0 b4 c4 b4 cc b4 94 b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b0a4	94 b5 d3 b4 da b4 e1 b4
>b0ac	e8 b4 ec b4 f2 b4 94 b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0b4	94 b5 f6 b4 fc b4 02 b5
>b0bc	07 b5 0d b5 94 b5 94 b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b0c4	15 b5 1b b5 21 b5 27 b5
>b0cc	2e b5 32 b5 38 b5 94 b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b0d4	3c b5 40 b5 44 b5 48 b5
>b0dc	4d b5 51 b5 59 b5 94 b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b0e4	94 b5 60 b5 67 b5 6e b5
>b0ec	75 b5 79 b5 7f b5 94 b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b0f4	94 b5 83 b5 89 b5 8f b5
.b0fc					oc_table:
>b0fc	83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b100	87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b108	85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b10e	85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b114	85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b11a	43 70 68 70				oc08:	.text 1*64+3, "php"
>b11e	85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b124	45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b12a	c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b12e	c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b132	c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b136	c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b13b	83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b13f	87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b147	86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b14e	85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b154	86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b15b	86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b162	86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b169	43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b16d	c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b173	45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b179	c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b17d	c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b183	c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b189	c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b18d	87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b195	85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b19b	85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b1a1	85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b1a7	86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b1ae	43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b1b2	85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1b8	45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b1be	c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b1c2	c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b1c7	c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b1cb	c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1d0	83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b1d4	87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b1dc	86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b1e3	87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b1eb	86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b1f2	86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b1f9	86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b200	43 73 65 63				oc38:	.text 1*64+3, "sec"
>b204	c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b20a	45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b210	c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b216	c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b21c	c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b222	c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b227	43 72 74 69				oc40:	.text 1*64+3, "rti"
>b22b	87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b233	85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b239	85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b23f	86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b246	43 70 68 61				oc48:	.text 1*64+3, "pha"
>b24a	85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b250	45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b256	c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b25a	c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b25e	c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b262	c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b267	83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b26b	87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b273	86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b27a	86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b281	86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b288	86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b28f	43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b293	c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b299	43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b29d	c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b2a3	c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b2a9	c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b2ae	43 72 74 73				oc60:	.text 1*64+3, "rts"
>b2b2	87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b2ba	85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b2c0	85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b2c6	85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b2cc	86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b2d3	43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b2d7	85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b2dd	45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b2e3	c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b2e9	c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b2ed	c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b2f1	c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b2f6	83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b2fa	87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b302	86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b309	86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b310	86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b317	86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b31e	86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b325	43 73 65 69				oc78:	.text 1*64+3, "sei"
>b329	c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b32f	43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b333	c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b33a	c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b340	c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b346	c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b34b	83 62 72 61				oc80:	.text 2*64+3, "bra"
>b34f	87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b357	85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b35d	85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b363	85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b369	43 64 65 79				oc88:	.text 1*64+3, "dey"
>b36d	85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b373	43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b377	c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b37b	c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b37f	c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b383	c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b388	83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b38c	87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b394	86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b39b	86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b3a2	86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b3a9	86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b3b0	86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3b7	43 74 79 61				oc98:	.text 1*64+3, "tya"
>b3bb	c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b3c1	43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b3c5	c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b3c9	c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3cf	c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b3d5	c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b3da	85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b3e0	87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b3e8	85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b3ee	85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b3f4	85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b3fa	85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b400	86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b407	43 74 61 79				oca8:	.text 1*64+3, "tay"
>b40b	85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b411	43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b415	c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b419	c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b41d	c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b421	c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b426	83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b42a	87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b432	86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b439	86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b440	86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b447	86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b44e	86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b455	43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b459	c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b45f	43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b463	c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b469	c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b46f	c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b475	c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b47a	85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b480	87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b488	85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b48e	85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b494	85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b49a	86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b4a1	43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b4a5	85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b4ab	43 64 65 78				occa:	.text 1*64+3, "dex"
>b4af	c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b4b3	c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4b7	c3 64 65 63				occe:	.text 3*64+3, "dec"
>b4bb	c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b4c0	83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b4c4	87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b4cc	86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b4d3	86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b4da	86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b4e1	86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b4e8	43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b4ec	c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b4f2	43 70 68 78				ocda:	.text 1*64+3, "phx"
>b4f6	c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b4fc	c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b502	c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b507	85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b50d	87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b515	85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b51b	85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b521	85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b527	86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b52e	43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b532	85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b538	43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b53c	c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b540	c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b544	c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b548	c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b54d	83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b551	87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b559	86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b560	86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b567	86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b56e	86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b575	43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b579	c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b57f	43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b583	c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b589	c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b58f	c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b594	01 3f					oc__:	.text 1, "?"
.b596					disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=46					ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=48					ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=50					ed_flags = editor3  ; Flags used by ed, where
.b596					ed6502:
.b596	a5 18		lda $18		                lda base
.b598	85 33		sta $33		                sta editor3+1
.b59a	a9 0a		lda #$0a	                lda #10
.b59c	85 18		sta $18		                sta base
.b59e	64 2e		stz $2e		                stz ed_head
.b5a0	64 2f		stz $2f		                stz ed_head+1
.b5a2	64 30		stz $30		                stz ed_cur
.b5a4	64 31		stz $31		                stz ed_cur+1
.b5a6	64 32		stz $32		                stz ed_flags
.b5a8	20 83 a7	jsr $a783	                jsr xt_zero
.b5ab	20 83 a7	jsr $a783	                jsr xt_zero             ; ( addr-t u-t )
.b5ae	20 80 89	jsr $8980	                jsr xt_cr
.b5b1					ed_input_loop:
.b5b1	a9 81		lda #$81	                lda #%10000001
.b5b3	14 32		trb $32		                trb ed_flags
.b5b5	20 90 ba	jsr $ba90	                jsr ed_get_input
.b5b8	a5 0a		lda $0a		                lda ciblen
.b5ba	d0 1f		bne $b5db	                bne _command_mode
.b5bc	ca		dex		                dex
.b5bd	ca		dex		                dex                     ; ( addr-t u-t ? )
.b5be	a5 30		lda $30		                lda ed_cur
.b5c0	95 00		sta $00,x	                sta 0,x
.b5c2	a5 31		lda $31		                lda ed_cur+1
.b5c4	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b5c6	a9 80		lda #$80	                lda #%10000000
.b5c8	04 32		tsb $32		                tsb ed_flags
.b5ca	20 27 98	jsr $9827	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b5cd	20 ac ba	jsr $baac	                jsr ed_is_valid_line
.b5d0	b0 03		bcs $b5d5	                bcs +
.b5d2	4c 80 ba	jmp $ba80	                jmp ed_error_1drop
.b5d5					+
.b5d5	20 83 a7	jsr $a783	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b5d8	4c a6 b6	jmp $b6a6	                jmp _line_number_only_from_external
.b5db					_command_mode:
.b5db	20 83 a7	jsr $a783	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b5de	20 83 a7	jsr $a783	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b5e1					_prefix_dot:
.b5e1	b2 08		lda ($08)	                lda (cib)
.b5e3	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b5e5	d0 3a		bne $b621	                bne _prefix_dollar
.b5e7	20 a1 ba	jsr $baa1	                jsr ed_have_text
.b5ea	a5 30		lda $30		                lda ed_cur
.b5ec	95 02		sta $02,x	                sta 2,x
.b5ee	a5 31		lda $31		                lda ed_cur+1
.b5f0	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b5f2	a9 80		lda #$80	                lda #%10000000
.b5f4	04 32		tsb $32		                tsb ed_flags
.b5f6	a5 0a		lda $0a		                lda ciblen
.b5f8	3a		dec a		                dea                     ; sets Z if A was 1
.b5f9	d0 03		bne $b5fe	                bne +
.b5fb	4c a6 b6	jmp $b6a6	                jmp _line_number_only_from_external
.b5fe					+
.b5fe	ca		dex		                dex
.b5ff	ca		dex		                dex
.b600	ca		dex		                dex
.b601	ca		dex		                dex
.b602	a5 08		lda $08		                lda cib
.b604	95 02		sta $02,x	                sta 2,x
.b606	a5 09		lda $09		                lda cib+1
.b608	95 03		sta $03,x	                sta 3,x
.b60a	a5 0a		lda $0a		                lda ciblen
.b60c	95 00		sta $00,x	                sta 0,x
.b60e	a5 0b		lda $0b		                lda ciblen+1
.b610	95 01		sta $01,x	                sta 1,x
.b612	20 1b 98	jsr $981b	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b615	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b618	20 27 98	jsr $9827	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b61b	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b61e	4c fe b6	jmp $b6fe	                jmp _check_for_para2
.b621					_prefix_dollar:
.b621	b2 08		lda ($08)	                lda (cib)
.b623	c9 24		cmp #$24	                cmp #'$'
.b625	d0 1c		bne $b643	                bne _prefix_percent
.b627	20 a1 ba	jsr $baa1	                jsr ed_have_text
.b62a	e8		inx		                inx
.b62b	e8		inx		                inx                     ; ( addr-t u-t 0 )
.b62c	20 ce ba	jsr $bace	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b62f	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b632	a9 80		lda #$80	                lda #%10000000
.b634	04 32		tsb $32		                tsb ed_flags
.b636	a5 0a		lda $0a		                lda ciblen
.b638	3a		dec a		                dea                     ; sets Z if A was 1
.b639	d0 03		bne $b63e	                bne +
.b63b	4c a6 b6	jmp $b6a6	                jmp _line_number_only_from_external
.b63e					+
.b63e	a0 01		ldy #$01	                ldy #01
.b640	4c 7a b7	jmp $b77a	                jmp _check_command
.b643					_prefix_percent:
.b643	b2 08		lda ($08)	                lda (cib)
.b645	c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b647	f0 04		beq $b64d	                beq _whole_text
.b649	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b64b	d0 17		bne $b664	                bne _prefix_semicolon
.b64d					_whole_text:
.b64d	20 a1 ba	jsr $baa1	                jsr ed_have_text
.b650	a9 01		lda #$01	                lda #01
.b652	95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b654	74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b656					_semicolon_entry:
.b656	e8		inx		                inx
.b657	e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b658	20 ce ba	jsr $bace	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b65b	a9 80		lda #$80	                lda #%10000000
.b65d	04 32		tsb $32		                tsb ed_flags
.b65f	a0 01		ldy #$01	                ldy #01
.b661	4c 7a b7	jmp $b77a	                jmp _check_command
.b664					_prefix_semicolon:
.b664	b2 08		lda ($08)	                lda (cib)
.b666	c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b668	d0 0d		bne $b677	                bne _prefix_number
.b66a	20 a1 ba	jsr $baa1	                jsr ed_have_text
.b66d	a5 30		lda $30		                lda ed_cur
.b66f	95 02		sta $02,x	                sta 2,x
.b671	a5 31		lda $31		                lda ed_cur+1
.b673	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b675	80 df		bra $b656	                bra _semicolon_entry
.b677					_prefix_number:
.b677	20 83 a7	jsr $a783	                jsr xt_zero
.b67a	20 83 a7	jsr $a783	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b67d	ca		dex		                dex
.b67e	ca		dex		                dex
.b67f	ca		dex		                dex
.b680	ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b681	a5 08		lda $08		                lda cib
.b683	95 02		sta $02,x	                sta 2,x
.b685	a5 09		lda $09		                lda cib+1
.b687	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b689	a5 0a		lda $0a		                lda ciblen
.b68b	95 00		sta $00,x	                sta 0,x
.b68d	a5 0b		lda $0b		                lda ciblen+1
.b68f	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b691	20 98 a2	jsr $a298	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b694	b5 00		lda $00,x	                lda 0,x
.b696	15 01		ora $01,x	                ora 1,x
.b698	d0 24		bne $b6be	                bne _have_unconverted_chars
.b69a	e8		inx		                inx
.b69b	e8		inx		                inx
.b69c	e8		inx		                inx
.b69d	e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b69e	20 9d 8a	jsr $8a9d	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b6a1	20 78 96	jsr $9678	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b6a4	e8		inx		                inx
.b6a5	e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b6a6					_line_number_only_from_external:
.b6a6	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b6a9	20 ac ba	jsr $baac	                jsr ed_is_valid_line
.b6ac	b0 03		bcs $b6b1	                bcs +
.b6ae	4c 7e ba	jmp $ba7e	                jmp ed_error_2drop
.b6b1					+
.b6b1	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6b4	20 3b bb	jsr $bb3b	                jsr ed_para1_to_cur
.b6b7	a9 80		lda #$80	                lda #%10000000
.b6b9	04 32		tsb $32		                tsb ed_flags
.b6bb	4c 59 b9	jmp $b959	                jmp ed_cmd_p_from_external
.b6be					_have_unconverted_chars:
.b6be	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b6c1	ca		dex		                dex
.b6c2	ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b6c3	a5 0a		lda $0a		                lda ciblen
.b6c5	95 00		sta $00,x	                sta 0,x
.b6c7	a5 0b		lda $0b		                lda ciblen+1
.b6c9	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b6cb	20 d7 8e	jsr $8ed7	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b6ce	b5 00		lda $00,x	                lda 0,x
.b6d0	15 01		ora $01,x	                ora 1,x
.b6d2	f0 0e		beq $b6e2	                beq _no_command_yet
.b6d4	8a		txa		                txa
.b6d5	18		clc		                clc
.b6d6	69 0a		adc #$0a	                adc #10
.b6d8	aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b6d9	a9 80		lda #$80	                lda #%10000000
.b6db	14 32		trb $32		                trb ed_flags
.b6dd	a0 00		ldy #$00	                ldy #00
.b6df	4c 7a b7	jmp $b77a	                jmp _check_command
.b6e2					_no_command_yet:
.b6e2	e8		inx		                inx
.b6e3	e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b6e4	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b6e7	20 78 96	jsr $9678	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b6ea	20 9d 8a	jsr $8a9d	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b6ed	b5 00		lda $00,x	                lda 0,x                 ; LSB
.b6ef	95 06		sta $06,x	                sta 6,x
.b6f1	b5 01		lda $01,x	                lda 1,x                 ; MSB
.b6f3	95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b6f5	e8		inx		                inx
.b6f6	e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b6f7	20 9c 9a	jsr $9a9c	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b6fa	a9 80		lda #$80	                lda #%10000000
.b6fc	04 32		tsb $32		                tsb ed_flags
.b6fe					_check_for_para2:
.b6fe	a1 02		lda ($02,x)	                lda (2,x)
.b700	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b702	f0 0d		beq $b711	                beq _got_comma
.b704	38		sec		                sec
.b705	a5 0a		lda $0a		                lda ciblen
.b707	f5 00		sbc $00,x	                sbc 0,x
.b709	a8		tay		                tay
.b70a	e8		inx		                inx
.b70b	e8		inx		                inx
.b70c	e8		inx		                inx
.b70d	e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b70e	4c 7a b7	jmp $b77a	                jmp _check_command
.b711					_got_comma:
.b711	f6 02		inc $02,x	                inc 2,x
.b713	d0 02		bne $b717	                bne +
.b715	f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b717					+
.b717	b5 01		lda $01,x	                lda 1,x
.b719	f0 02		beq $b71d	                beq +
.b71b	d6 01		dec $01,x	                dec 1,x
.b71d					+
.b71d	d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b71f	a1 02		lda ($02,x)	                lda (2,x)
.b721	c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b723	d0 14		bne $b739	                bne _para2_not_dollar
.b725	38		sec		                sec
.b726	a5 0a		lda $0a		                lda ciblen
.b728	f5 02		sbc $02,x	                sbc 2,x
.b72a	a8		tay		                tay
.b72b	c8		iny		                iny
.b72c	5a		phy		                phy
.b72d	8a		txa		                txa
.b72e	18		clc		                clc
.b72f	69 06		adc #$06	                adc #06
.b731	aa		tax		                tax                     ; ( addr-t u-t para1 )
.b732	20 ce ba	jsr $bace	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b735	7a		ply		                ply
.b736	4c 7a b7	jmp $b77a	                jmp _check_command
.b739					_para2_not_dollar:
.b739	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b73c	20 83 a7	jsr $a783	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b73f	20 83 a7	jsr $a783	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b742	20 61 9b	jsr $9b61	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b745	20 9c 9a	jsr $9a9c	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b748	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b74b	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b74e	20 98 a2	jsr $a298	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b751	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b754	20 9c 9a	jsr $9a9c	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b757	20 d7 8e	jsr $8ed7	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b75a	b5 00		lda $00,x	                lda 0,x
.b75c	15 01		ora $01,x	                ora 1,x
.b75e	f0 08		beq $b768	                beq _second_number
.b760	8a		txa		                txa
.b761	18		clc		                clc
.b762	69 0c		adc #$0c	                adc #12
.b764	aa		tax		                tax                     ; back to ( addr-t u-t )
.b765	4c 82 ba	jmp $ba82	                jmp ed_error
.b768					_second_number:
.b768	e8		inx		                inx
.b769	e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b76a	38		sec		                sec
.b76b	a5 0a		lda $0a		                lda ciblen
.b76d	f5 00		sbc $00,x	                sbc 0,x
.b76f	48		pha		                pha
.b770	20 8b a3	jsr $a38b	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b773	20 9d 8a	jsr $8a9d	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b776	20 4c 96	jsr $964c	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b779	7a		ply		                ply
.b77a					_check_command:
.b77a	24 32		bit $32		                bit ed_flags
.b77c	30 08		bmi $b786	                bmi _check_command_have_arg
.b77e	a5 30		lda $30		                lda ed_cur
.b780	95 02		sta $02,x	                sta 2,x
.b782	a5 31		lda $31		                lda ed_cur+1
.b784	95 03		sta $03,x	                sta 3,x
.b786					_check_command_have_arg:
.b786	b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b788	85 24		sta $24		                sta tmp1
.b78a	da		phx		                phx
.b78b	a2 00		ldx #$00	                ldx #00
.b78d					_cmd_loop:
.b78d	bd 66 bb	lda $bb66,x	                lda ed_cmd_list,x
.b790	f0 07		beq $b799	                beq _illegal_command    ; zero marks end of list
.b792	c5 24		cmp $24		                cmp tmp1
.b794	f0 07		beq $b79d	                beq _found_cmd
.b796	e8		inx		                inx
.b797	80 f4		bra $b78d	                bra _cmd_loop
.b799					_illegal_command:
.b799	fa		plx		                plx
.b79a	4c 7e ba	jmp $ba7e	                jmp ed_error_2drop
.b79d					_found_cmd:
.b79d	8a		txa		                txa
.b79e	0a		asl a		                asl
.b79f	aa		tax		                tax                     ; X * 2 for table
.b7a0	7c 71 bb	jmp ($bb71,x)	                jmp (ed_cmd_table,x)
.b7a3					ed_next_command:
.b7a3	e8		inx		                inx
.b7a4	e8		inx		                inx
.b7a5	e8		inx		                inx
.b7a6	e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b7a7					_next_command_empty:
.b7a7	4c b1 b5	jmp $b5b1	                jmp ed_input_loop
.b7aa					ed_all_done:
.b7aa	64 0a		stz $0a		                stz ciblen
.b7ac	64 0b		stz $0b		                stz ciblen+1
.b7ae	20 8b a3	jsr $a38b	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b7b1	a5 33		lda $33		                lda editor3+1
.b7b3	85 18		sta $18		                sta base
.b7b5	60		rts		                rts
.b7b6					ed_cmd_a:
.b7b6	fa		plx		                plx
.b7b7	e8		inx		                inx
.b7b8	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7b9					ed_entry_cmd_i:
.b7b9					ed_cmd_a_have_para:
.b7b9	20 04 bb	jsr $bb04	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b7bc	20 80 89	jsr $8980	                jsr xt_cr
.b7bf					_next_string_loop:
.b7bf	20 90 ba	jsr $ba90	                jsr ed_get_input
.b7c2	b2 08		lda ($08)	                lda (cib)
.b7c4	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b7c6	d0 16		bne $b7de	                bne _add_line
.b7c8	a4 0a		ldy $0a		                ldy ciblen
.b7ca	c0 01		cpy #$01	                cpy #01
.b7cc	d0 10		bne $b7de	                bne _add_line
.b7ce	a4 0b		ldy $0b		                ldy ciblen+1
.b7d0	d0 0c		bne $b7de	                bne _add_line
.b7d2	e8		inx		                inx
.b7d3	e8		inx		                inx
.b7d4	a9 40		lda #$40	                lda #%01000000
.b7d6	04 32		tsb $32		                tsb ed_flags
.b7d8	20 80 89	jsr $8980	                jsr xt_cr
.b7db	4c b1 b5	jmp $b5b1	                jmp ed_input_loop
.b7de					_add_line:
.b7de	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b7e1	20 7b 91	jsr $917b	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b7e4	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b7e7	20 89 8f	jsr $8f89	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b7ea	20 7a 87	jsr $877a	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b7ed	20 68 a3	jsr $a368	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b7f0	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b7f3	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-t u-t here )
.b7f6	20 7b 91	jsr $917b	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b7f9	a5 00		lda $00		                lda cp
.b7fb	18		clc		                clc
.b7fc	69 04		adc #$04	                adc #04
.b7fe	85 00		sta $00		                sta cp
.b800	90 02		bcc $b804	                bcc +
.b802	e6 01		inc $01		                inc cp+1
.b804					+
.b804	e6 30		inc $30		                inc ed_cur
.b806	d0 02		bne $b80a	                bne +
.b808	e6 31		inc $31		                inc ed_cur+1
.b80a					+
.b80a	20 7b 91	jsr $917b	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b80d	20 b8 8d	jsr $8db8	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b810	ca		dex		                dex
.b811	ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b812	a5 08		lda $08		                lda cib
.b814	95 00		sta $00,x	                sta 0,x
.b816	a5 09		lda $09		                lda cib+1
.b818	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b81a	20 89 a1	jsr $a189	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b81d	ca		dex		                dex
.b81e	ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b81f	a5 0a		lda $0a		                lda ciblen
.b821	95 00		sta $00,x	                sta 0,x
.b823	a5 0b		lda $0b		                lda ciblen+1
.b825	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b827	20 cc 95	jsr $95cc	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b82a	18		clc		                clc
.b82b	a5 00		lda $00		                lda cp
.b82d	65 0a		adc $0a		                adc ciblen
.b82f	85 00		sta $00		                sta cp
.b831	90 06		bcc $b839	                bcc +
.b833	a5 01		lda $01		                lda cp+1
.b835	65 0b		adc $0b		                adc ciblen+1
.b837	85 01		sta $01		                sta cp+1
.b839					+
.b839	20 9d 98	jsr $989d	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b83c	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b83f	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+
.b842	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b845	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b848	a5 0a		lda $0a		                lda ciblen
.b84a	95 02		sta $02,x	                sta 2,x
.b84c	a5 0b		lda $0b		                lda ciblen+1
.b84e	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b850	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-t u-t here )
.b853	20 80 89	jsr $8980	                jsr xt_cr
.b856	4c bf b7	jmp $b7bf	                jmp _next_string_loop
.b859					ed_cmd_d:
.b859	fa		plx		                plx
.b85a	20 a1 ba	jsr $baa1	                jsr ed_have_text
.b85d	20 f6 ba	jsr $baf6	                jsr ed_no_line_zero
.b860	b5 00		lda $00,x	                lda 0,x
.b862	15 01		ora $01,x	                ora 1,x
.b864	d0 08		bne $b86e	                bne +
.b866	20 9d 98	jsr $989d	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b869	20 ab b8	jsr $b8ab	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b86c	80 33		bra $b8a1	                bra _cmd_d_done
.b86e					+
.b86e	20 ac ba	jsr $baac	                jsr ed_is_valid_line      ; result is in C flag
.b871	b0 03		bcs $b876	                bcs _cmd_d_loop
.b873	4c 7e ba	jmp $ba7e	                jmp ed_error_2drop
.b876					_cmd_d_loop:
.b876	20 93 a3	jsr $a393	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b879	20 66 91	jsr $9166	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b87c	b5 00		lda $00,x	                lda 0,x
.b87e	15 01		ora $01,x	                ora 1,x
.b880	d0 0d		bne $b88f	                bne _cmd_d_done_with_flag
.b882	e8		inx		                inx
.b883	e8		inx		                inx                     ; Get rid of the flag from >
.b884	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b887	20 ab b8	jsr $b8ab	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b88a	20 1b 98	jsr $981b	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b88d	80 e7		bra $b876	                bra _cmd_d_loop
.b88f					_cmd_d_done_with_flag:
.b88f	e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b890	e8		inx		                inx
.b891	b5 02		lda $02,x	                lda 2,x
.b893	d0 02		bne $b897	                bne +
.b895	d6 03		dec $03,x	                dec 3,x
.b897					+
.b897	d6 02		dec $02,x	                dec 2,x
.b899	b5 02		lda $02,x	                lda 2,x
.b89b	85 30		sta $30		                sta ed_cur
.b89d	b5 03		lda $03,x	                lda 3,x
.b89f	85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b8a1					_cmd_d_done:
.b8a1	a9 40		lda #$40	                lda #%01000000
.b8a3	04 32		tsb $32		                tsb ed_flags
.b8a5	20 80 89	jsr $8980	                jsr xt_cr
.b8a8	4c a3 b7	jmp $b7a3	                jmp ed_next_command
.b8ab					_cmd_d_common:
.b8ab	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b8ae	20 04 bb	jsr $bb04	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b8b1	20 89 8f	jsr $8f89	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8b4	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8b7	20 1b 98	jsr $981b	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b8ba	20 04 bb	jsr $bb04	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b8bd	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-t u-t )
.b8c0	60		rts		                rts
.b8c1					ed_cmd_equ:
.b8c1	fa		plx		                plx
.b8c2	a5 2e		lda $2e		                lda ed_head
.b8c4	05 2f		ora $2f		                ora ed_head+1
.b8c6	d0 08		bne $b8d0	                bne _cmd_equ_have_text
.b8c8	ca		dex		                dex
.b8c9	ca		dex		                dex
.b8ca	74 00		stz $00,x	                stz 0,x
.b8cc	74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b8ce	80 21		bra $b8f1	                bra _cmd_equ_done
.b8d0					_cmd_equ_have_text:
.b8d0	20 f6 ba	jsr $baf6	                jsr ed_no_line_zero
.b8d3	24 32		bit $32		                bit ed_flags
.b8d5	30 0c		bmi $b8e3	                bmi _cmd_equ_have_para
.b8d7	ca		dex		                dex
.b8d8	ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b8d9	a5 30		lda $30		                lda ed_cur
.b8db	95 00		sta $00,x	                sta 0,x
.b8dd	a5 31		lda $31		                lda ed_cur+1
.b8df	95 01		sta $01,x	                sta 1,x
.b8e1	80 0e		bra $b8f1	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b8e3					_cmd_equ_have_para:
.b8e3	b5 00		lda $00,x	                lda 0,x
.b8e5	15 01		ora $01,x	                ora 1,x
.b8e7	d0 05		bne $b8ee	                bne _cmd_equ_two_paras
.b8e9	20 9d 98	jsr $989d	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b8ec	80 03		bra $b8f1	                bra _cmd_equ_done
.b8ee					_cmd_equ_two_paras:
.b8ee	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b8f1					_cmd_equ_done:
.b8f1	20 80 89	jsr $8980	                jsr xt_cr               ; number goes on new line
.b8f4	20 09 a5	jsr $a509	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b8f7	20 80 89	jsr $8980	                jsr xt_cr
.b8fa	4c a3 b7	jmp $b7a3	                jmp ed_next_command
.b8fd					ed_cmd_f:
.b8fd	fa		plx		                plx
.b8fe	24 32		bit $32		                bit ed_flags
.b900	30 17		bmi $b919	                bmi _cmd_f_have_para
.b902	20 80 89	jsr $8980	                jsr xt_cr
.b905	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b908	20 61 9b	jsr $9b61	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b90b	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b90e	20 09 a5	jsr $a509	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b911	20 78 96	jsr $9678	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b914	20 9c 9a	jsr $9a9c	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b917	80 11		bra $b92a	                bra _cmd_f_done
.b919					_cmd_f_have_para:
.b919	20 9d 98	jsr $989d	                jsr xt_over
.b91c	20 80 89	jsr $8980	                jsr xt_cr
.b91f	20 09 a5	jsr $a509	                jsr xt_u_dot
.b922	b5 02		lda $02,x	                lda 2,x
.b924	95 06		sta $06,x	                sta 6,x
.b926	b5 03		lda $03,x	                lda 3,x
.b928	95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b92a					_cmd_f_done:
.b92a	20 80 89	jsr $8980	                jsr xt_cr
.b92d	4c a3 b7	jmp $b7a3	                jmp ed_next_command
.b930					ed_cmd_i:
.b930	fa		plx		                plx
.b931	e8		inx		                inx
.b932	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b933	24 32		bit $32		                bit ed_flags
.b935	30 08		bmi $b93f	                bmi _cmd_i_have_para
.b937	a5 30		lda $30		                lda ed_cur
.b939	95 00		sta $00,x	                sta 0,x
.b93b	a5 31		lda $31		                lda ed_cur+1
.b93d	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b93f					_cmd_i_have_para:
.b93f	b5 00		lda $00,x	                lda 0,x
.b941	15 01		ora $01,x	                ora 1,x
.b943	f0 09		beq $b94e	                beq _cmd_i_done
.b945	20 1b 98	jsr $981b	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b948	20 83 a7	jsr $a783	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b94b	20 22 95	jsr $9522	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b94e					_cmd_i_done:
.b94e	4c b9 b7	jmp $b7b9	                jmp ed_entry_cmd_i
.b951					ed_cmd_n:
.b951	fa		plx		                plx
.b952	a9 01		lda #$01	                lda #%00000001
.b954	04 32		tsb $32		                tsb ed_flags
.b956	80 05		bra $b95d	                bra ed_cmd_p_entry_for_cmd_n
.b958					ed_cmd_p:
.b958	fa		plx		                plx
.b959					ed_cmd_p_from_external:
.b959	a9 01		lda #$01	                lda #%00000001
.b95b	14 32		trb $32		                trb ed_flags
.b95d					ed_cmd_p_entry_for_cmd_n:
.b95d	20 a1 ba	jsr $baa1	                jsr ed_have_text
.b960	20 f6 ba	jsr $baf6	                jsr ed_no_line_zero
.b963	20 80 89	jsr $8980	                jsr xt_cr
.b966	b5 00		lda $00,x	                lda 0,x
.b968	15 01		ora $01,x	                ora 1,x
.b96a	d0 10		bne $b97c	                bne _cmd_p_loop
.b96c	b5 02		lda $02,x	                lda 2,x
.b96e	85 30		sta $30		                sta ed_cur
.b970	b5 03		lda $03,x	                lda 3,x
.b972	85 31		sta $31		                sta ed_cur+1
.b974	20 9d 98	jsr $989d	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b977	20 a5 b9	jsr $b9a5	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b97a	80 26		bra $b9a2	                bra _cmd_p_all_done
.b97c					_cmd_p_loop:
.b97c	20 93 a3	jsr $a393	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b97f	20 66 91	jsr $9166	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b982	b5 00		lda $00,x	                lda 0,x
.b984	15 01		ora $01,x	                ora 1,x
.b986	d0 10		bne $b998	                bne _cmd_p_done
.b988	e8		inx		                inx
.b989	e8		inx		                inx                     ; Get rid of the flag from >
.b98a	20 9d 98	jsr $989d	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b98d	20 a5 b9	jsr $b9a5	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b990	f6 02		inc $02,x	                inc 2,x
.b992	d0 02		bne $b996	                bne +
.b994	f6 03		inc $03,x	                inc 3,x
.b996					+
.b996	80 e4		bra $b97c	                bra _cmd_p_loop
.b998					_cmd_p_done:
.b998	e8		inx		                inx
.b999	e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b99a	b5 00		lda $00,x	                lda 0,x
.b99c	85 30		sta $30		                sta ed_cur
.b99e	b5 01		lda $01,x	                lda 1,x
.b9a0	85 31		sta $31		                sta ed_cur+1
.b9a2					_cmd_p_all_done:
.b9a2	4c a3 b7	jmp $b7a3	                jmp ed_next_command
.b9a5					_cmd_p_common:
.b9a5	a5 32		lda $32		                lda ed_flags
.b9a7	4a		lsr a		                lsr                     ; bit 0 now in carry
.b9a8	90 0b		bcc $b9b5	                bcc _cmd_p_common_no_num
.b9aa	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b9ad	20 09 a5	jsr $a509	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b9b0	a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b9b2	20 ff 8d	jsr $8dff	                jsr emit_a
.b9b5					_cmd_p_common_no_num:
.b9b5	20 04 bb	jsr $bb04	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9b8	20 44 bb	jsr $bb44	                jsr ed_print_addr
.b9bb	60		rts		                rts
.b9bc					ed_cmd_q:
.b9bc	fa		plx		                plx
.b9bd	24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b9bf	50 03		bvc $b9c4	                bvc +
.b9c1	4c 7e ba	jmp $ba7e	                jmp ed_error_2drop
.b9c4					+
.b9c4	4c aa b7	jmp $b7aa	                jmp ed_all_done            ; can't fall thru because of PLX
.b9c7					ed_cmd_qq:
.b9c7	fa		plx		                plx
.b9c8	4c aa b7	jmp $b7aa	                jmp ed_all_done
.b9cb					ed_cmd_w:
.b9cb	fa		plx		                plx
.b9cc	20 a1 ba	jsr $baa1	                jsr ed_have_text
.b9cf	24 32		bit $32		                bit ed_flags
.b9d1	30 13		bmi $b9e6	                bmi _cmd_w_have_para
.b9d3	b5 06		lda $06,x	                lda 6,x
.b9d5	15 07		ora $07,x	                ora 7,x
.b9d7	d0 03		bne $b9dc	                bne +
.b9d9	4c 7e ba	jmp $ba7e	                jmp ed_error_2drop
.b9dc					+
.b9dc	b5 06		lda $06,x	                lda 6,x
.b9de	95 02		sta $02,x	                sta 2,x
.b9e0	b5 07		lda $07,x	                lda 7,x
.b9e2	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b9e4	80 08		bra $b9ee	                bra _cmd_w_para_ready
.b9e6					_cmd_w_have_para:
.b9e6	b5 02		lda $02,x	                lda 2,x
.b9e8	95 06		sta $06,x	                sta 6,x
.b9ea	b5 03		lda $03,x	                lda 3,x
.b9ec	95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b9ee					_cmd_w_para_ready:
.b9ee	a9 2e		lda #$2e	                lda #<ed_head
.b9f0	95 00		sta $00,x	                sta 0,x
.b9f2	a9 00		lda #$00	                lda #>ed_head
.b9f4	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.b9f6	20 9d 98	jsr $989d	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.b9f9	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.b9fc					_cmd_w_loop:
.b9fc	20 89 8f	jsr $8f89	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.b9ff	b5 00		lda $00,x	                lda 0,x
.ba01	15 01		ora $01,x	                ora 1,x
.ba03	f0 55		beq $ba5a	                beq _cmd_w_eol
.ba05	20 93 a3	jsr $a393	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ba08	20 7d a4	jsr $a47d	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ba0b	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ba0e	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ba11	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba14	20 89 8f	jsr $8f89	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba17	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba1a	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba1d	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba20	20 89 8f	jsr $8f89	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba23	20 78 96	jsr $9678	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba26	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba29	20 61 9b	jsr $9b61	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba2c	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba2f	20 4b a3	jsr $a34b	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba32	20 cc 95	jsr $95cc	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba35	20 9c 9a	jsr $9a9c	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba38	20 03 a4	jsr $a403	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba3b	20 78 96	jsr $9678	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba3e	20 ed 99	jsr $99ed	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba41	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba44	ca		dex		                dex
.ba45	ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba46	a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba48	95 00		sta $00,x	                sta 0,x
.ba4a	74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba4c	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba4f	20 68 a1	jsr $a168	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba52	20 27 98	jsr $9827	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba55	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba58	80 a2		bra $b9fc	                bra _cmd_w_loop
.ba5a					_cmd_w_eol:
.ba5a	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba5d	20 9c 9a	jsr $9a9c	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba60	20 5a 95	jsr $955a	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba63	b5 00		lda $00,x	                lda 0,x
.ba65	95 04		sta $04,x	                sta 4,x
.ba67	b5 01		lda $01,x	                lda 1,x
.ba69	95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba6b	20 80 89	jsr $8980	                jsr xt_cr
.ba6e	20 b8 8d	jsr $8db8	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba71	20 09 a5	jsr $a509	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba74	20 80 89	jsr $8980	                jsr xt_cr
.ba77	a9 40		lda #$40	                lda #%01000000
.ba79	14 32		trb $32		                trb ed_flags
.ba7b	4c a3 b7	jmp $b7a3	                jmp ed_next_command
.ba7e					ed_error_2drop:
.ba7e	e8		inx		                inx
.ba7f	e8		inx		                inx                     ; drop through to _error_1drop
.ba80					ed_error_1drop:
.ba80	e8		inx		                inx
.ba81	e8		inx		                inx                     ; drop through to _error
.ba82					ed_error:
.ba82	20 80 89	jsr $8980	                jsr xt_cr
.ba85	a9 3f		lda #$3f	                lda #'?'
.ba87	20 ff 8d	jsr $8dff	                jsr emit_a
.ba8a	20 80 89	jsr $8980	                jsr xt_cr
.ba8d	4c b1 b5	jmp $b5b1	                jmp ed_input_loop
.ba90					ed_get_input:
.ba90	20 02 9b	jsr $9b02	                jsr xt_refill           ;  ( addr-t u-t f )
.ba93	b5 00		lda $00,x	                lda 0,x
.ba95	15 01		ora $01,x	                ora 1,x
.ba97	d0 05		bne $ba9e	                bne +
.ba99	7a		ply		                ply
.ba9a	7a		ply		                ply
.ba9b	4c 80 ba	jmp $ba80	                jmp ed_error_1drop
.ba9e					+
.ba9e	e8		inx		                inx
.ba9f	e8		inx		                inx
.baa0	60		rts		                rts
.baa1					ed_have_text:
.baa1	a5 2e		lda $2e		                lda ed_head
.baa3	05 2f		ora $2f		                ora ed_head+1
.baa5	d0 04		bne $baab	                bne +
.baa7	7a		ply		                ply
.baa8	7a		ply		                ply
.baa9	80 d7		bra $ba82	                bra ed_error
.baab					+
.baab	60		rts		                rts
.baac					ed_is_valid_line:
.baac	38		sec		                sec                             ; default is legal line number
.baad	b5 00		lda $00,x	                lda 0,x
.baaf	15 01		ora $01,x	                ora 1,x
.bab1	f0 19		beq $bacc	                beq _is_valid_line_nope_zero    ; ( n )
.bab3	20 b8 8d	jsr $8db8	                jsr xt_dup                      ; DUP ( n n )
.bab6	20 ce ba	jsr $bace	                jsr ed_last_line                  ; ( n n last )
.bab9	20 89 a1	jsr $a189	                jsr xt_swap                     ; SWAP ( n last n )
.babc	20 6f 93	jsr $936f	                jsr xt_less_than                ; < ( n f )
.babf	b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.bac1	15 01		ora $01,x	                ora 1,x
.bac3	d0 05		bne $baca	                bne _is_valid_line_too_small
.bac5	e8		inx		                inx
.bac6	e8		inx		                inx                     ; DROP flag ( n )
.bac7	38		sec		                sec                     ; Who knows what's happened to C by now
.bac8	80 03		bra $bacd	                bra _is_valid_line_done ; only one exit from this routine
.baca					_is_valid_line_too_small:
.baca	e8		inx		                inx
.bacb	e8		inx		                inx                     ; drop through to _is_valid_line_zero
.bacc					_is_valid_line_nope_zero:
.bacc	18		clc		                clc                     ; drop through to _is_valid_line_done
.bacd					_is_valid_line_done:
.bacd	60		rts		                rts
.bace					ed_last_line:
.bace	64 24		stz $24		                stz tmp1
.bad0	64 25		stz $25		                stz tmp1+1
.bad2	ca		dex		                dex
.bad3	ca		dex		                dex                     ; ( ? )
.bad4	a9 2e		lda #$2e	                lda #<ed_head
.bad6	95 00		sta $00,x	                sta 0,x
.bad8	a9 00		lda #$00	                lda #>ed_head
.bada	95 01		sta $01,x	                sta 1,x                 ; ( addr )
.badc					_last_line_loop:
.badc	20 89 8f	jsr $8f89	                jsr xt_fetch            ; ( addr | 0 )
.badf	b5 00		lda $00,x	                lda 0,x
.bae1	15 01		ora $01,x	                ora 1,x
.bae3	f0 08		beq $baed	                beq _last_line_done
.bae5	e6 24		inc $24		                inc tmp1
.bae7	d0 02		bne $baeb	                bne +
.bae9	e6 25		inc $25		                inc tmp1+1
.baeb					+
.baeb	80 ef		bra $badc	                bra _last_line_loop
.baed					_last_line_done:
.baed	a5 24		lda $24		                lda tmp1
.baef	95 00		sta $00,x	                sta 0,x
.baf1	a5 25		lda $25		                lda tmp1+1
.baf3	95 01		sta $01,x	                sta 1,x                 ; ( u )
.baf5	60		rts		                rts
.baf6					ed_no_line_zero:
.baf6	b5 02		lda $02,x	                lda 2,x
.baf8	15 03		ora $03,x	                ora 3,x
.bafa	d0 07		bne $bb03	                bne _no_line_zero_done
.bafc	24 32		bit $32		                bit ed_flags
.bafe	10 03		bpl $bb03	                bpl _no_line_zero_done
.bb00	4c 7e ba	jmp $ba7e	                jmp ed_error_2drop
.bb03					_no_line_zero_done:
.bb03	60		rts		                rts
.bb04					ed_num_to_addr:
.bb04	ca		dex		                dex
.bb05	ca		dex		                dex                     ; ( u ? )
.bb06	a9 2e		lda #$2e	                lda #<ed_head
.bb08	95 00		sta $00,x	                sta 0,x
.bb0a	a9 00		lda #$00	                lda #>ed_head
.bb0c	95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bb0e	b5 02		lda $02,x	                lda 2,x
.bb10	15 03		ora $03,x	                ora 3,x
.bb12	d0 05		bne $bb19	                bne _num_to_addr_loop
.bb14	20 4c 96	jsr $964c	                jsr xt_nip              ; ( addr-h )
.bb17	80 21		bra $bb3a	                bra _num_to_addr_done
.bb19					_num_to_addr_loop:
.bb19	20 89 8f	jsr $8f89	                jsr xt_fetch            ; @ ( u addr1 )
.bb1c	b5 00		lda $00,x	                lda 0,x
.bb1e	15 01		ora $01,x	                ora 1,x
.bb20	d0 05		bne $bb27	                bne +
.bb22	20 4c 96	jsr $964c	                jsr xt_nip              ; NIP ( addr1 )
.bb25	80 13		bra $bb3a	                bra _num_to_addr_done
.bb27					+
.bb27	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( addr1 u )
.bb2a	20 1b 98	jsr $981b	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb2d	b5 00		lda $00,x	                lda 0,x
.bb2f	15 01		ora $01,x	                ora 1,x
.bb31	f0 05		beq $bb38	                beq _num_to_addr_finished
.bb33	20 89 a1	jsr $a189	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb36	80 e1		bra $bb19	                bra _num_to_addr_loop
.bb38					_num_to_addr_finished:
.bb38	e8		inx		                inx
.bb39	e8		inx		                inx                     ; ( addr )
.bb3a					_num_to_addr_done:
.bb3a	60		rts		                rts
.bb3b					ed_para1_to_cur:
.bb3b	b5 02		lda $02,x	                lda 2,x
.bb3d	85 30		sta $30		                sta ed_cur
.bb3f	b5 03		lda $03,x	                lda 3,x
.bb41	85 31		sta $31		                sta ed_cur+1
.bb43	60		rts		                rts
.bb44					ed_print_addr:
.bb44	20 27 98	jsr $9827	                jsr xt_one_plus
.bb47	20 27 98	jsr $9827	                jsr xt_one_plus         ; ( addr+2 )
.bb4a	20 b8 8d	jsr $8db8	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb4d	20 27 98	jsr $9827	                jsr xt_one_plus
.bb50	20 27 98	jsr $9827	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb53	20 89 8f	jsr $8f89	                jsr xt_fetch            ; ( addr+2 u-s )
.bb56	20 89 a1	jsr $a189	                jsr xt_swap             ; ( u-s addr+2 )
.bb59	20 89 8f	jsr $8f89	                jsr xt_fetch            ; ( u-s addr-s )
.bb5c	20 89 a1	jsr $a189	                jsr xt_swap             ; ( addr-s u-s )
.bb5f	20 de a4	jsr $a4de	                jsr xt_type
.bb62	20 80 89	jsr $8980	                jsr xt_cr
.bb65	60		rts		                rts
>bb66	61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb6e	71 51 00
.bb71					ed_cmd_table:
>bb71	b6 b7 fd b8 30 b9 59 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bb79	58 b9 51 b9
>bb7d	c1 b8 cb b9 bc b9 c7 b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bb85					ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bb85					forth_words_start:
>bb85	20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb8d	61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb9d	74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bbad	20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bbbd	20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bbcd	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bbdd	2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bbed	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bbfd	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bc0d	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bc1d	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc2d	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc3d	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc4d	65 78 69 74 29 20 63 72 20
.bc56					forth_words_end:
.bc56					user_words_start:
>bc56	20 20				.binary "user_words.asc"
.bc58					user_words_end:

;******  Processing file: platform/../headers.asm

.bc58					dictionary_start:
.bc58					nt_drop:
>bc58	04 10				        .byte 4, UF
>bc5a	64 bc 37 8d 3c 8d		        .word nt_dup, xt_drop, z_drop
>bc60	64 72 6f 70			        .text "drop"
.bc64					nt_dup:
>bc64	03 10				        .byte 3, UF
>bc66	6f bc b8 8d c5 8d		        .word nt_swap, xt_dup, z_dup
>bc6c	64 75 70			        .text "dup"
.bc6f					nt_swap:
>bc6f	04 10				        .byte 4, UF
>bc71	7b bc 89 a1 9c a1		        .word nt_store, xt_swap, z_swap
>bc77	73 77 61 70			        .text "swap"
.bc7b					nt_store:
>bc7b	01 10				        .byte 1, UF
>bc7d	84 bc 68 a1 7d a1		        .word nt_fetch, xt_store, z_store
>bc83	21				        .text "!"
.bc84					nt_fetch:
>bc84	01 10				        .byte 1, UF
>bc86	8d bc 89 8f 9b 8f		        .word nt_over, xt_fetch, z_fetch
>bc8c	40				        .text "@"
.bc8d					nt_over:
>bc8d	04 10				        .byte 4, UF
>bc8f	99 bc 9d 98 aa 98		        .word nt_to_r, xt_over, z_over
>bc95	6f 76 65 72			        .text "over"
.bc99					nt_to_r:
>bc99	02 11				        .byte 2, CO+UF ; native is special case
>bc9b	a3 bc 4b a3 5e a3		        .word nt_r_from, xt_to_r, z_to_r
>bca1	3e 72				        .text ">r"
.bca3					nt_r_from:
>bca3	02 01				        .byte 2, CO    ; native is special case
>bca5	ad bc 9c 9a ac 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bcab	72 3e				        .text "r>"
.bcad					nt_r_fetch:
>bcad	02 01				        .byte 2, CO    ; native is special case
>bcaf	b7 bc 87 9a 9b 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bcb5	72 40				        .text "r@"
.bcb7					nt_nip:
>bcb7	03 10				        .byte 3, UF
>bcb9	c2 bc 4c 96 59 96		        .word nt_rot, xt_nip, z_nip
>bcbf	6e 69 70			        .text "nip"
.bcc2					nt_rot:
>bcc2	03 10				        .byte 3, UF
>bcc4	cd bc 61 9b 7c 9b		        .word nt_not_rote, xt_rot, z_rot
>bcca	72 6f 74			        .text "rot"
.bccd					nt_not_rote:
>bccd	04 10				        .byte 4, UF
>bccf	d9 bc 78 96 93 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bcd5	2d 72 6f 74			        .text "-rot"
.bcd9					nt_tuck:
>bcd9	04 10				        .byte 4, UF
>bcdb	e5 bc 68 a3 81 a3		        .word nt_comma, xt_tuck, z_tuck
>bce1	74 75 63 6b			        .text "tuck"
.bce5					nt_comma:
>bce5	01 10				        .byte 1, UF
>bce7	ee bc 7a 87 93 87		        .word nt_c_fetch, xt_comma, z_comma
>bced	2c				        .text ","
.bcee					nt_c_fetch:
>bcee	02 10				        .byte 2, UF
>bcf0	f8 bc 17 86 20 86		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bcf6	63 40				        .text "c@"
.bcf8					nt_c_store:
>bcf8	02 10				        .byte 2, UF
>bcfa	02 bd 21 86 2c 86		        .word nt_plus_store, xt_c_store, z_c_store
>bd00	63 21				        .text "c!"
.bd02					nt_plus_store:
>bd02	02 10				        .byte 2, UF
>bd04	0c bd 00 9a 1f 9a		        .word nt_execute, xt_plus_store, z_plus_store
>bd0a	2b 21				        .text "+!"
.bd0c					nt_execute:
>bd0c	07 10				        .byte 7, UF
>bd0e	1b bd 46 8f 4c 8f		        .word nt_emit, xt_execute, z_execute
>bd14	65 78 65 63 75 74 65		        .text "execute"
.bd1b					nt_emit:
>bd1b	04 18				        .byte 4, NN+UF
>bd1d	27 bd f8 8d 02 8e		        .word nt_type, xt_emit, z_emit
>bd23	65 6d 69 74			        .text "emit"
.bd27					nt_type:
>bd27	04 10				        .byte 4, UF
>bd29	33 bd de a4 08 a5		        .word nt_dot, xt_type, z_type
>bd2f	74 79 70 65			        .text "type"
.bd33					nt_dot:
>bd33	01 10				        .byte 1, UF
>bd35	3c bd 3f 8c 60 8c		        .word nt_u_dot, xt_dot, z_dot
>bd3b	2e				        .text "."
.bd3c					nt_u_dot:
>bd3c	02 10				        .byte 2, UF
>bd3e	46 bd 09 a5 14 a5		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd44	75 2e				        .text "u."
.bd46					nt_u_dot_r:
>bd46	03 10				        .byte 3, UF
>bd48	51 bd 15 a5 36 a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd4e	75 2e 72			        .text "u.r"
.bd51					nt_dot_r:
>bd51	02 10				        .byte 2, UF
>bd53	5b bd 7b 8c a8 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd59	2e 72				        .text ".r"
.bd5b					nt_d_dot:
>bd5b	02 10				        .byte 2, UF
>bd5d	65 bd ed 8c 0b 8d		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd63	64 2e				        .text "d."
.bd65					nt_d_dot_r:
>bd65	03 10				        .byte 3, UF
>bd67	70 bd 0c 8d 36 8d		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd6d	64 2e 72			        .text "d.r"
.bd70					nt_ud_dot:
>bd70	03 10				        .byte 3, UF
>bd72	7b bd 63 a5 75 a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd78	75 64 2e			        .text "ud."
.bd7b					nt_ud_dot_r:
>bd7b	04 10				        .byte 4, UF
>bd7d	87 bd 76 a5 94 a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd83	75 64 2e 72			        .text "ud.r"
.bd87					nt_question:
>bd87	01 00				        .byte 1, 0
>bd89	90 bd 6c 9a 72 9a		        .word nt_false, xt_question, z_question
>bd8f	3f				        .text "?"
.bd90					nt_false:
>bd90	05 00				        .byte 5, 0
>bd92	9d bd 82 8f 88 8f		        .word nt_true, xt_false, z_false
>bd98	66 61 6c 73 65			        .text "false"
.bd9d					nt_true:
>bd9d	04 00				        .byte 4, 0
>bd9f	a9 bd 5f a3 67 a3		        .word nt_space, xt_true, z_true
>bda5	74 72 75 65			        .text "true"
.bda9					nt_space:
>bda9	05 00				        .byte 5, 0
>bdab	b6 bd f9 a0 fe a0		        .word nt_zero, xt_space, z_space
>bdb1	73 70 61 63 65			        .text "space"
.bdb6					nt_zero:
>bdb6	01 00				        .byte 1, 0
>bdb8	bf bd 83 a7 89 a7		        .word nt_one, xt_zero, z_zero
>bdbe	30				        .text "0"
.bdbf					nt_one:
>bdbf	01 00				        .byte 1, 0
>bdc1	c8 bd 12 98 1a 98		        .word nt_two, xt_one, z_one
>bdc7	31				        .text "1"
.bdc8					nt_two:
>bdc8	01 00				        .byte 1, 0
>bdca	d1 bd 82 a3 8a a3		        .word nt_two_dup, xt_two, z_two
>bdd0	32				        .text "2"
.bdd1					nt_two_dup:
>bdd1	04 10				        .byte 4, UF
>bdd3	dd bd 93 a3 aa a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bdd9	32 64 75 70			        .text "2dup"
.bddd					nt_question_dup:
>bddd	04 10				        .byte 4, UF
>bddf	e9 bd 73 9a 86 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bde5	3f 64 75 70			        .text "?dup"
.bde9					nt_plus:
>bde9	01 10				        .byte 1, UF
>bdeb	f2 bd ed 99 ff 99		        .word nt_minus, xt_plus, z_plus
>bdf1	2b				        .text "+"
.bdf2					nt_minus:
>bdf2	01 10				        .byte 1, UF
>bdf4	fb bd 5a 95 6c 95		        .word nt_one_minus, xt_minus, z_minus
>bdfa	2d				        .text "-"
.bdfb					nt_one_minus:
>bdfb	02 10				        .byte 2, UF
>bdfd	05 be 1b 98 26 98		        .word nt_one_plus, xt_one_minus, z_one_minus
>be03	31 2d				        .text "1-"
.be05					nt_one_plus:
>be05	02 10				        .byte 2, UF
>be07	0f be 27 98 30 98		        .word nt_two_star, xt_one_plus, z_one_plus
>be0d	31 2b				        .text "1+"
.be0f					nt_two_star:
>be0f	02 10				        .byte 2, UF
>be11	19 be 2b a4 32 a4		        .word nt_two_slash, xt_two_star, z_two_star
>be17	32 2a				        .text "2*"
.be19					nt_two_slash:
>be19	02 10				        .byte 2, UF
>be1b	23 be 20 a4 2a a4		        .word nt_abs, xt_two_slash, z_two_slash
>be21	32 2f				        .text "2/"
.be23					nt_abs:
>be23	03 10				        .byte 3, UF
>be25	2e be 23 81 37 81		        .word nt_dabs, xt_abs, z_abs
>be2b	61 62 73			        .text "abs"
.be2e					nt_dabs:
>be2e	04 10				        .byte 4, UF
>be30	3a be a3 8a c1 8a		        .word nt_and, xt_dabs, z_dabs
>be36	64 61 62 73			        .text "dabs"
.be3a					nt_and:
>be3a	03 10				        .byte 3, UF
>be3c	45 be 28 83 39 83		        .word nt_or, xt_and, z_and
>be42	61 6e 64			        .text "and"
.be45					nt_or:
>be45	02 10				        .byte 2, UF
>be47	4f be 3d 98 4e 98		        .word nt_xor, xt_or, z_or
>be4d	6f 72				        .text "or"
.be4f					nt_xor:
>be4f	03 10				        .byte 3, UF
>be51	5a be 71 a7 82 a7		        .word nt_rshift, xt_xor, z_xor
>be57	78 6f 72			        .text "xor"
.be5a					nt_rshift:
>be5a	06 10				        .byte 6, UF
>be5c	68 be 7d 9b 90 9b		        .word nt_lshift, xt_rshift, z_rshift
>be62	72 73 68 69 66 74		        .text "rshift"
.be68					nt_lshift:
>be68	06 10				        .byte 6, UF
>be6a	76 be 84 94 97 94		        .word nt_pick, xt_lshift, z_lshift
>be70	6c 73 68 69 66 74		        .text "lshift"
.be76					nt_pick:
>be76	04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be78	82 be dc 99 ec 99		        .word nt_char, xt_pick, z_pick
>be7e	70 69 63 6b			        .text "pick"
.be82					nt_char:
>be82	04 00				        .byte 4, 0
>be84	8e be 3d 86 53 86		        .word nt_bracket_char, xt_char, z_char
>be8a	63 68 61 72			        .text "char"
.be8e					nt_bracket_char:
>be8e	06 05				        .byte 6, CO+IM
>be90	9c be a3 85 a9 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>be96	5b 63 68 61 72 5d		        .text "[char]"
.be9c					nt_char_plus:
>be9c	05 00				        .byte 5, 0
>be9e	a9 be 27 98 30 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bea4	63 68 61 72 2b			        .text "char+"
.bea9					nt_chars:
>bea9	05 12				        .byte 5, AN+UF   ; deleted during compile
>beab	b6 be 54 86 57 86		        .word nt_cells, xt_chars, z_chars
>beb1	63 68 61 72 73			        .text "chars"
.beb6					nt_cells:
>beb6	05 00				        .byte 5, 0
>beb8	c3 be 2b a4 32 a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bebe	63 65 6c 6c 73			        .text "cells"
.bec3					nt_cell_plus:
>bec3	05 10				        .byte 5, UF
>bec5	d0 be 2d 86 3c 86		        .word nt_here, xt_cell_plus, z_cell_plus
>becb	63 65 6c 6c 2b			        .text "cell+"
.bed0					nt_here:
>bed0	04 00				        .byte 4, 0
>bed2	dc be 7b 91 85 91		        .word nt_equal, xt_here, z_here
>bed8	68 65 72 65			        .text "here"
.bedc					nt_equal:
>bedc	01 10				        .byte 1, UF
>bede	e5 be d7 8e f2 8e		        .word nt_not_equals, xt_equal, z_equal
>bee4	3d				        .text "="
.bee5					nt_not_equals:
>bee5	02 10				        .byte 2, UF
>bee7	ef be 5a 96 77 96		        .word nt_less_than, xt_not_equals, z_not_equals
>beed	3c 3e				        .text "<>"
.beef					nt_less_than:
>beef	01 10				        .byte 1, UF
>bef1	f8 be 6f 93 83 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bef7	3c				        .text "<"
.bef8					nt_u_less_than:
>bef8	02 10				        .byte 2, UF
>befa	02 bf 4d a5 62 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bf00	75 3c				        .text "u<"
.bf02					nt_u_greater_than:
>bf02	02 10				        .byte 2, UF
>bf04	0c bf 37 a5 4c a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bf0a	75 3e				        .text "u>"
.bf0c					nt_greater_than:
>bf0c	01 10				        .byte 1, UF
>bf0e	15 bf 66 91 7a 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bf14	3e				        .text ">"
.bf15					nt_zero_equal:
>bf15	02 10				        .byte 2, UF
>bf17	1f bf 8a a7 9b a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bf1d	30 3d				        .text "0="
.bf1f					nt_zero_unequal:
>bf1f	03 10				        .byte 3, UF
>bf21	2a bf c0 a7 cf a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bf27	30 3c 3e			        .text "0<>"
.bf2a					nt_zero_greater:
>bf2a	02 10				        .byte 2, UF
>bf2c	34 bf 9c a7 af a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bf32	30 3e				        .text "0>"
.bf34					nt_zero_less:
>bf34	02 10				        .byte 2, UF
>bf36	3e bf b0 a7 bf a7		        .word nt_min, xt_zero_less, z_zero_less
>bf3c	30 3c				        .text "0<"
.bf3e					nt_min:
>bf3e	03 10				        .byte 3, UF
>bf40	49 bf 3e 95 59 95		        .word nt_max, xt_min, z_min
>bf46	6d 69 6e			        .text "min"
.bf49					nt_max:
>bf49	03 10				        .byte 3, UF
>bf4b	54 bf 22 95 3d 95		        .word nt_two_drop, xt_max, z_max
>bf51	6d 61 78			        .text "max"
.bf54					nt_two_drop:
>bf54	05 10				        .byte 5, UF
>bf56	61 bf 8b a3 92 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf5c	32 64 72 6f 70			        .text "2drop"
.bf61					nt_two_swap:
>bf61	05 10				        .byte 5, UF
>bf63	6e bf 59 a4 7c a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf69	32 73 77 61 70			        .text "2swap"
.bf6e					nt_two_over:
>bf6e	05 10				        .byte 5, UF
>bf70	7b bf cd a3 e4 a3		        .word nt_two_store, xt_two_over, z_two_over
>bf76	32 6f 76 65 72			        .text "2over"
.bf7b					nt_two_store:
>bf7b	02 10				        .byte 2, UF
>bf7d	85 bf 33 a4 58 a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bf83	32 21				        .text "2!"
.bf85					nt_two_fetch:
>bf85	02 10				        .byte 2, UF
>bf87	8f bf ab a3 cc a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bf8d	32 40				        .text "2@"
.bf8f					nt_two_variable:
>bf8f	09 00				        .byte 9, 0
>bf91	a0 bf cf a4 dd a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>bf97	32 76 61 72 69 61 62 6c		        .text "2variable"
>bf9f	65
.bfa0					nt_two_constant:
>bfa0	09 10				        .byte 9, UF
>bfa2	b1 bf 9d a4 c1 a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bfa8	32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bfb0	74
.bfb1					nt_two_literal:
>bfb1	08 14				        .byte 8, UF+IM
>bfb3	c1 bf c2 a4 ce a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bfb9	32 6c 69 74 65 72 61 6c		        .text "2literal"
.bfc1					nt_two_r_fetch:
>bfc1	03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bfc3	cc bf e5 a3 02 a4		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bfc9	32 72 40			        .text "2r@"
.bfcc					nt_two_r_from:
>bfcc	03 01				        .byte 3, CO             ; native is special case
>bfce	d7 bf 03 a4 1f a4		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bfd4	32 72 3e			        .text "2r>"
.bfd7					nt_two_to_r:
>bfd7	03 11				        .byte 3, CO+UF          ; native is special case
>bfd9	e2 bf 7d a4 9c a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>bfdf	32 3e 72			        .text "2>r"
.bfe2					nt_invert:
>bfe2	06 10				        .byte 6, UF
>bfe4	f0 bf f2 92 01 93		        .word nt_negate, xt_invert, z_invert
>bfea	69 6e 76 65 72 74		        .text "invert"
.bff0					nt_negate:
>bff0	06 10				        .byte 6, UF
>bff2	fe bf 2d 96 3d 96		        .word nt_dnegate, xt_negate, z_negate
>bff8	6e 65 67 61 74 65		        .text "negate"
.bffe					nt_dnegate:
>bffe	07 10				        .byte 7, UF
>c000	0d c0 5e 8b 78 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>c006	64 6e 65 67 61 74 65		        .text "dnegate"
.c00d					nt_c_comma:
>c00d	02 10				        .byte 2, UF
>c00f	17 c0 0c 86 16 86		        .word nt_bounds, xt_c_comma, z_c_comma
>c015	63 2c				        .text "c,"
.c017					nt_bounds:
>c017	06 10				        .byte 6, UF
>c019	25 c0 8a 85 a2 85		        .word nt_spaces, xt_bounds, z_bounds
>c01f	62 6f 75 6e 64 73		        .text "bounds"
.c025					nt_spaces:
>c025	06 10				        .byte 6, UF
>c027	33 c0 ff a0 3a a1		        .word nt_bl, xt_spaces, z_spaces
>c02d	73 70 61 63 65 73		        .text "spaces"
.c033					nt_bl:
>c033	02 00				        .byte 2, 0
>c035	3d c0 a6 83 ae 83		        .word nt_minus_trailing, xt_bl, z_bl
>c03b	62 6c				        .text "bl"
.c03d					nt_minus_trailing:
>c03d	09 10				        .byte 9, UF
>c03f	4e c0 86 95 c2 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c045	2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c04d	67
.c04e					nt_minus_leading:
>c04e	08 10				        .byte 8, UF
>c050	5e c0 6d 95 85 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c056	2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c05e					nt_slash_string:
>c05e	07 10				        .byte 7, UF
>c060	6d c0 f4 9f 13 a0		        .word nt_refill, xt_slash_string, z_slash_string
>c066	2f 73 74 72 69 6e 67		        .text "/string"
.c06d					nt_refill:
>c06d	06 00				        .byte 6, 0
>c06f	7b c0 02 9b 43 9b		        .word nt_accept, xt_refill, z_refill
>c075	72 65 66 69 6c 6c		        .text "refill"
.c07b					nt_accept:
>c07b	06 18				        .byte 6, UF+NN
>c07d	89 c0 38 81 30 82		        .word nt_input_to_r, xt_accept, z_accept
>c083	61 63 63 65 70 74		        .text "accept"
.c089					nt_input_to_r:
>c089	07 08				        .byte 7, NN
>c08b	98 c0 69 92 7e 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c091	69 6e 70 75 74 3e 72		        .text "input>r"
.c098					nt_r_to_input:
>c098	07 08				        .byte 7, NN
>c09a	a7 c0 ad 9a c4 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c0a0	72 3e 69 6e 70 75 74		        .text "r>input"
.c0a7					nt_unused:
>c0a7	06 00				        .byte 6, 0
>c0a9	b5 c0 2f a6 3e a6		        .word nt_depth, xt_unused, z_unused
>c0af	75 6e 75 73 65 64		        .text "unused"
.c0b5					nt_depth:
>c0b5	05 00				        .byte 5, 0
>c0b7	c2 c0 13 8b 21 8b		        .word nt_key, xt_depth, z_depth
>c0bd	64 65 70 74 68			        .text "depth"
.c0c2					nt_key:
>c0c2	03 00				        .byte 3, 0
>c0c4	cd c0 35 93 3e 93		        .word nt_allot, xt_key, z_key
>c0ca	6b 65 79			        .text "key"
.c0cd					nt_allot:
>c0cd	05 10				        .byte 5, UF
>c0cf	da c0 95 82 fd 82		        .word nt_create, xt_allot, z_allot
>c0d5	61 6c 6c 6f 74			        .text "allot"
.c0da					nt_create:
>c0da	06 00				        .byte 6, 0
>c0dc	e8 c0 86 89 5a 8a		        .word nt_does, xt_create, z_create
>c0e2	63 72 65 61 74 65		        .text "create"
.c0e8					nt_does:
>c0e8	05 05				        .byte 5, CO+IM
>c0ea	f5 c0 fe 8b 0c 8c		        .word nt_variable, xt_does, z_does
>c0f0	64 6f 65 73 3e			        .text "does>"
.c0f5					nt_variable:
>c0f5	08 00				        .byte 8, 0
>c0f7	05 c1 53 a6 6b a6		        .word nt_constant, xt_variable, z_variable
>c0fd	76 61 72 69 61 62 6c 65		        .text "variable"
.c105					nt_constant:
>c105	08 10				        .byte 8, UF
>c107	15 c1 2e 89 6b 89		        .word nt_value, xt_constant, z_constant
>c10d	63 6f 6e 73 74 61 6e 74		        .text "constant"
.c115					nt_value:
>c115	05 10				        .byte 5, UF
>c117	22 c1 2e 89 6b 89		        .word nt_to, xt_constant, z_constant
>c11d	76 61 6c 75 65			        .text "value"
.c122					nt_to:
>c122	02 0c				        .byte 2, NN+IM
>c124	2c c1 0c a2 67 a2		        .word nt_s_to_d, xt_to, z_to
>c12a	74 6f				        .text "to"
.c12c					nt_s_to_d:
>c12c	03 10				        .byte 3, UF
>c12e	37 c1 87 9e 98 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c134	73 3e 64			        .text "s>d"
.c137					nt_d_to_s:
>c137	03 10				        .byte 3, UF
>c139	42 c1 9d 8a a2 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c13f	64 3e 73			        .text "d>s"
.c142					nt_d_minus:
>c142	02 10				        .byte 2, UF
>c144	4c c1 5b 8a 7b 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c14a	64 2d				        .text "d-"
.c14c					nt_d_plus:
>c14c	02 10				        .byte 2, UF
>c14e	56 c1 7c 8a 9c 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c154	64 2b				        .text "d+"
.c156					nt_erase:
>c156	05 00				        .byte 5, 0      ; underflow checked by FILL
>c158	63 c1 fd 8e 45 8f		        .word nt_blank, xt_erase, z_erase
>c15e	65 72 61 73 65			        .text "erase"
.c163					nt_blank:
>c163	05 00				        .byte 5, 0     ; underflow checked by FILL
>c165	70 c1 f3 8e 45 8f		        .word nt_fill, xt_blank, z_blank
>c16b	62 6c 61 6e 6b			        .text "blank"
.c170					nt_fill:
>c170	04 10				        .byte 4, UF
>c172	7c c1 03 8f 45 8f		        .word nt_find_name, xt_fill, z_fill
>c178	66 69 6c 6c			        .text "fill"
.c17c					nt_find_name:
>c17c	09 10				        .byte 9, UF
>c17e	8d c1 e4 8f 8f 90		        .word nt_tick, xt_find_name, z_find_name
>c184	66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c18c	65
.c18d					nt_tick:
>c18d	01 00				        .byte 1, 0
>c18f	96 c1 ec a1 0b a2		        .word nt_bracket_tick, xt_tick, z_tick
>c195	27				        .text "'"
.c196					nt_bracket_tick:
>c196	03 05				        .byte 3, CO+IM
>c198	a1 c1 aa 85 b0 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c19e	5b 27 5d			        .text "[']"
.c1a1					nt_name_to_int:
>c1a1	08 10				        .byte 8, UF
>c1a3	b1 c1 eb 95 07 96		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c1a9	6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c1b1					nt_int_to_name:
>c1b1	08 10				        .byte 8, UF
>c1b3	c1 c1 7f 92 f1 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c1b9	69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c1c1					nt_name_to_string:
>c1c1	0b 10				        .byte 11, UF
>c1c3	d4 c1 08 96 21 96		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c1c9	6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1d1	69 6e 67
.c1d4					nt_to_body:
>c1d4	05 10				        .byte 5, UF
>c1d6	e1 c1 68 a2 8c a2		        .word nt_defer, xt_to_body, z_to_body
>c1dc	3e 62 6f 64 79			        .text ">body"
.c1e1					nt_defer:
>c1e1	05 00				        .byte 5, 0
>c1e3	ee c1 c9 8a fb 8a		        .word nt_latestxt, xt_defer, z_defer
>c1e9	64 65 66 65 72			        .text "defer"
.c1ee					nt_latestxt:
>c1ee	08 00				        .byte 8, 0
>c1f0	fe c1 50 93 56 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c1f6	6c 61 74 65 73 74 78 74		        .text "latestxt"
.c1fe					nt_latestnt:
>c1fe	08 00				        .byte 8, 0
>c200	0e c2 42 93 4f 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c206	6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c20e					nt_parse_name:
>c20e	0a 08				        .byte 10, NN
>c210	20 c2 e9 98 db 99		        .word nt_parse, xt_parse_name, z_parse_name
>c216	70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c21e	6d 65
.c220					nt_parse:
>c220	05 10				        .byte 5, UF
>c222	2d c2 44 99 db 99		        .word nt_execute_parsing, xt_parse, z_parse
>c228	70 61 72 73 65			        .text "parse"
.c22d					nt_execute_parsing:
>c22d	0f 10				        .byte 15, UF
>c22f	44 c2 5a 8f 80 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c235	65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c23d	70 61 72 73 69 6e 67
.c244					nt_source:
>c244	06 00				        .byte 6, 0
>c246	52 c2 d9 a0 ed a0		        .word nt_source_id, xt_source, z_source
>c24c	73 6f 75 72 63 65		        .text "source"
.c252					nt_source_id:
>c252	09 00				        .byte 9, 0
>c254	63 c2 ee a0 f8 a0		        .word nt_colon, xt_source_id, z_source_id
>c25a	73 6f 75 72 63 65 2d 69		        .text "source-id"
>c262	64
.c263					nt_colon:
>c263	01 00				        .byte 1, 0
>c265	6c c2 1b 87 5d 87		        .word nt_semicolon, xt_colon, z_colon
>c26b	3a				        .text ":"
.c26c					nt_semicolon:
>c26c	01 05				        .byte 1, CO+IM
>c26e	75 c2 63 9f c1 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c274	3b				        .text ";"
.c275					nt_colon_noname:
>c275	07 00				        .byte 7, 0
>c277	84 c2 5e 87 79 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c27d	3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c284					nt_compile_comma:
>c284	08 18				        .byte 8, UF+NN
>c286	94 c2 f9 87 21 89		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c28c	63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c294					nt_left_bracket:
>c294	01 05				        .byte 1, IM+CO
>c296	9d c2 5c 93 60 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c29c	5b				        .text "["
.c29d					nt_right_bracket:
>c29d	01 04				        .byte 1, IM
>c29f	a6 c2 51 9b 57 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c2a5	5d				        .text "]"
.c2a6					nt_literal:
>c2a6	07 15				        .byte 7, IM+CO+UF
>c2a8	b5 c2 91 93 9e 93		        .word nt_sliteral, xt_literal, z_literal
>c2ae	6c 69 74 65 72 61 6c		        .text "literal"
.c2b5					nt_sliteral:
>c2b5	08 15				        .byte 8, CO+IM+UF
>c2b7	c5 c2 14 a0 83 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c2bd	73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c2c5					nt_dot_quote:
>c2c5	02 05				        .byte 2, CO+IM
>c2c7	cf c2 70 8c 7a 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c2cd	2e 22				        .text ".", $22
.c2cf					nt_s_quote:
>c2cf	02 0c				        .byte 2, IM+NN
>c2d1	d9 c2 59 9d 86 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c2d7	73 22				        .text "s", $22
.c2d9					nt_s_backslash_quote:
>c2d9	03 04				        .byte 3, IM
>c2db	e4 c2 91 9b 9a 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c2e1	73 5c 22			        .text "s", $5C, $22
.c2e4					nt_postpone:
>c2e4	08 05				        .byte 8, IM+CO
>c2e6	f4 c2 20 9a 5e 9a		        .word nt_immediate, xt_postpone, z_postpone
>c2ec	70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c2f4					nt_immediate:
>c2f4	09 00				        .byte 9, 0
>c2f6	05 c3 52 92 5d 92		        .word nt_compile_only, xt_immediate, z_immediate
>c2fc	69 6d 6d 65 64 69 61 74		        .text "immediate"
>c304	65
.c305					nt_compile_only:
>c305	0c 00				        .byte 12, 0
>c307	19 c3 22 89 2d 89		        .word nt_never_native, xt_compile_only, z_compile_only
>c30d	63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c315	6f 6e 6c 79
.c319					nt_never_native:
>c319	0c 00				        .byte 12, 0
>c31b	2d c3 3e 96 4b 96		        .word nt_always_native, xt_never_native, z_never_native
>c321	6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c329	74 69 76 65
.c32d					nt_always_native:
>c32d	0d 00				        .byte 13, 0
>c32f	42 c3 1a 83 27 83		        .word nt_allow_native, xt_always_native, z_always_native
>c335	61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c33d	61 74 69 76 65
.c342					nt_allow_native:
>c342	0c 00				        .byte 12, 0
>c344	56 c3 fe 82 09 83		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c34a	61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c352	74 69 76 65
.c356					nt_nc_limit:
>c356	08 00				        .byte 8, 0
>c358	66 c3 22 96 2c 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c35e	6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c366					nt_strip_underflow:
>c366	0f 00				        .byte 15, 0
>c368	7d c3 7e a1 88 a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c36e	73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c376	64 65 72 66 6c 6f 77
.c37d					nt_abort:
>c37d	05 00				        .byte 5, 0
>c37f	8a c3 60 80 ad 80		        .word nt_abort_quote, xt_abort, z_abort
>c385	61 62 6f 72 74			        .text "abort"
.c38a					nt_abort_quote:
>c38a	06 0d				        .byte 6, CO+IM+NN
>c38c	98 c3 03 81 0d 81		        .word nt_do, xt_abort_quote, z_abort_quote
>c392	61 62 6f 72 74 22		        .text "abort", $22
.c398					nt_do:
>c398	02 0d				        .byte 2, CO+IM+NN
>c39a	a2 c3 7f 8b b8 8b		        .word nt_question_do, xt_do, z_do
>c3a0	64 6f				        .text "do"
.c3a2					nt_question_do:
>c3a2	03 0d				        .byte 3, CO+IM+NN
>c3a4	ad c3 79 8b b8 8b		        .word nt_i, xt_question_do, z_question_do
>c3aa	3f 64 6f			        .text "?do"
.c3ad					nt_i:
>c3ad	01 03				        .byte 1, AN+CO
>c3af	b6 c3 f2 91 09 92		        .word nt_j, xt_i, z_i
>c3b5	69				        .text "i"
.c3b6					nt_j:
>c3b6	01 03				        .byte 1, AN+CO
>c3b8	bf c3 1b 93 34 93		        .word nt_loop, xt_j, z_j
>c3be	6a				        .text "j"
.c3bf					nt_loop:
>c3bf	04 05				        .byte 4, CO+IM
>c3c1	cb c3 02 94 5f 94		        .word nt_plus_loop, xt_loop, z_loop
>c3c7	6c 6f 6f 70			        .text "loop"
.c3cb					nt_plus_loop:
>c3cb	05 05				        .byte 5, CO+IM
>c3cd	d8 c3 13 94 5f 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3d3	2b 6c 6f 6f 70			        .text "+loop"
.c3d8					nt_exit:
>c3d8	04 03				        .byte 4, AN+CO
>c3da	e4 c3 81 8f 82 8f		        .word nt_unloop, xt_exit, z_exit
>c3e0	65 78 69 74			        .text "exit"
.c3e4					nt_unloop:
>c3e4	06 03				        .byte 6, AN+CO
>c3e6	f2 c3 1d a6 23 a6		        .word nt_leave, xt_unloop, z_unloop
>c3ec	75 6e 6c 6f 6f 70		        .text "unloop"
.c3f2					nt_leave:
>c3f2	05 03				        .byte 5, AN+CO
>c3f4	ff c3 57 93 5c 93		        .word nt_recurse, xt_leave, z_leave
>c3fa	6c 65 61 76 65			        .text "leave"
.c3ff					nt_recurse:
>c3ff	07 0d				        .byte 7, CO+IM+NN
>c401	0e c4 c5 9a 01 9b		        .word nt_quit, xt_recurse, z_recurse
>c407	72 65 63 75 72 73 65		        .text "recurse"
.c40e					nt_quit:
>c40e	04 00				        .byte 4, 0
>c410	1a c4 62 80 ad 80		        .word nt_begin, xt_quit, z_quit
>c416	71 75 69 74			        .text "quit"
.c41a					nt_begin:
>c41a	05 07				        .byte 5, AN+CO+IM
>c41c	27 c4 9c 83 9f 83		        .word nt_again, xt_begin, z_begin
>c422	62 65 67 69 6e			        .text "begin"
.c427					nt_again:
>c427	05 17				        .byte 5, AN+CO+IM+UF
>c429	34 c4 73 82 93 82		        .word nt_state, xt_again, z_again
>c42f	61 67 61 69 6e			        .text "again"
.c434					nt_state:
>c434	05 00				        .byte 5, 0
>c436	41 c4 5d a1 67 a1		        .word nt_evaluate, xt_state, z_state
>c43c	73 74 61 74 65			        .text "state"
.c441					nt_evaluate:
>c441	08 10				        .byte 8, UF
>c443	51 c4 de 90 31 91		        .word nt_base, xt_evaluate, z_evaluate
>c449	65 76 61 6c 75 61 74 65		        .text "evaluate"
.c451					nt_base:
>c451	04 00				        .byte 4, 0
>c453	5d c4 93 83 9b 83		        .word nt_digit_question, xt_base, z_base
>c459	62 61 73 65			        .text "base"
.c45d					nt_digit_question:
>c45d	06 10				        .byte 6, UF
>c45f	6b c4 22 8b 56 8b		        .word nt_number, xt_digit_question, z_digit_question
>c465	64 69 67 69 74 3f		        .text "digit?"
.c46b					nt_number:
>c46b	06 10				        .byte 6, UF
>c46d	79 c4 94 96 90 97		        .word nt_to_number, xt_number, z_number
>c473	6e 75 6d 62 65 72		        .text "number"
.c479					nt_to_number:
>c479	07 10				        .byte 7, UF
>c47b	88 c4 98 a2 37 a3		        .word nt_hex, xt_to_number, z_to_number
>c481	3e 6e 75 6d 62 65 72		        .text ">number"
.c488					nt_hex:
>c488	03 00				        .byte 3, 0
>c48a	93 c4 86 91 8c 91		        .word nt_decimal, xt_hex, z_hex
>c490	68 65 78			        .text "hex"
.c493					nt_decimal:
>c493	07 00				        .byte 7, 0
>c495	a2 c4 c2 8a c8 8a		        .word nt_count, xt_decimal, z_decimal
>c49b	64 65 63 69 6d 61 6c		        .text "decimal"
.c4a2					nt_count:
>c4a2	05 10				        .byte 5, UF
>c4a4	af c4 6c 89 7f 89		        .word nt_m_star, xt_count, z_count
>c4aa	63 6f 75 6e 74			        .text "count"
.c4af					nt_m_star:
>c4af	02 10				        .byte 2, UF
>c4b1	b9 c4 98 94 b2 94		        .word nt_um_star, xt_m_star, z_m_star
>c4b7	6d 2a				        .text "m*"
.c4b9					nt_um_star:
>c4b9	03 10				        .byte 3, UF
>c4bb	c4 c4 d7 a5 1c a6		        .word nt_star, xt_um_star, z_um_star
>c4c1	75 6d 2a			        .text "um*"
.c4c4					nt_star:
>c4c4	01 10				        .byte 1, UF
>c4c6	cd c4 3b a1 43 a1		        .word nt_um_slash_mod, xt_star, z_star
>c4cc	2a				        .text "*"
.c4cd					nt_um_slash_mod:
>c4cd	06 10				        .byte 6, UF
>c4cf	db c4 95 a5 d6 a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c4d5	75 6d 2f 6d 6f 64		        .text "um/mod"
.c4db					nt_sm_slash_rem:
>c4db	06 10				        .byte 6, UF
>c4dd	e9 c4 b0 a0 d8 a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c4e3	73 6d 2f 72 65 6d		        .text "sm/rem"
.c4e9					nt_fm_slash_mod:
>c4e9	06 10				        .byte 6, UF
>c4eb	f7 c4 9a 90 d0 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c4f1	66 6d 2f 6d 6f 64		        .text "fm/mod"
.c4f7					nt_slash:
>c4f7	01 10				        .byte 1, UF
>c4f9	00 c5 d7 9f f3 9f		        .word nt_slash_mod, xt_slash, z_slash
>c4ff	2f				        .text "/"
.c500					nt_slash_mod:
>c500	04 10				        .byte 4, UF
>c502	0c c5 dc 9f f3 9f		        .word nt_mod, xt_slash_mod, z_slash_mod
>c508	2f 6d 6f 64			        .text "/mod"
.c50c					nt_mod:
>c50c	03 10				        .byte 3, UF
>c50e	17 c5 c3 95 cb 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c514	6d 6f 64			        .text "mod"
.c517					nt_star_slash_mod:
>c517	05 10				        .byte 5, UF
>c519	24 c5 4d a1 5c a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c51f	2a 2f 6d 6f 64			        .text "*/mod"
.c524					nt_star_slash:
>c524	02 10				        .byte 2, UF
>c526	2e c5 44 a1 4c a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c52c	2a 2f				        .text "*/"
.c52e					nt_backslash:
>c52e	01 04				        .byte 1, IM
>c530	37 c5 68 83 92 83		        .word nt_move, xt_backslash, z_backslash
>c536	5c				        .byte $5c
.c537					nt_move:
>c537	04 18				        .byte 4, NN+UF
>c539	43 c5 cc 95 ea 95		        .word nt_cmove_up, xt_move, z_move
>c53f	6d 6f 76 65			        .text "move"
.c543					nt_cmove_up:
>c543	06 10				        .byte 6, UF
>c545	51 c5 e0 86 1a 87		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c54b	63 6d 6f 76 65 3e		        .text "cmove>"
.c551					nt_cmove:
>c551	05 10				        .byte 5, UF
>c553	5e c5 a5 86 df 86		        .word nt_pad, xt_cmove, z_cmove
>c559	63 6d 6f 76 65			        .text "cmove"
.c55e					nt_pad:
>c55e	03 00				        .byte 3, 0
>c560	69 c5 ab 98 ba 98		        .word nt_cleave, xt_pad, z_pad
>c566	70 61 64			        .text "pad"
.c569					nt_cleave:
>c569	06 10				        .byte 6, UF
>c56b	77 c5 58 86 a4 86		        .word nt_hexstore, xt_cleave, z_cleave
>c571	63 6c 65 61 76 65		        .text "cleave"
.c577					nt_hexstore:
>c577	08 10				        .byte 8, UF
>c579	87 c5 8d 91 df 91		        .word nt_within, xt_hexstore, z_hexstore
>c57f	68 65 78 73 74 6f 72 65		        .text "hexstore"
.c587					nt_within:
>c587	06 10				        .byte 6, UF
>c589	95 c5 80 a6 95 a6		        .word nt_to_in, xt_within, z_within
>c58f	77 69 74 68 69 6e		        .text "within"
.c595					nt_to_in:
>c595	03 00				        .byte 3, 0
>c597	a0 c5 8d a2 97 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c59d	3e 69 6e			        .text ">in"
.c5a0					nt_less_number_sign:
>c5a0	02 00				        .byte 2, 0
>c5a2	aa c5 61 93 6e 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c5a8	3c 23				        .text "<#"
.c5aa					nt_number_sign:
>c5aa	01 10				        .byte 1, UF
>c5ac	b3 c5 91 97 c5 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c5b2	23				        .text "#"
.c5b3					nt_number_sign_s:
>c5b3	02 10				        .byte 2, UF
>c5b5	bd c5 e8 97 f8 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c5bb	23 73				        .text "#s"
.c5bd					nt_number_sign_greater:
>c5bd	02 10				        .byte 2, UF
>c5bf	c7 c5 c6 97 e7 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c5c5	23 3e				        .text "#>"
.c5c7					nt_hold:
>c5c7	04 10				        .byte 4, UF
>c5c9	d3 c5 e0 91 f1 91		        .word nt_sign, xt_hold, z_hold
>c5cf	68 6f 6c 64			        .text "hold"
.c5d3					nt_sign:
>c5d3	04 10				        .byte 4, UF
>c5d5	df c5 c2 9f d6 9f		        .word nt_output, xt_sign, z_sign
>c5db	73 69 67 6e			        .text "sign"
.c5df					nt_output:
>c5df	06 00				        .byte 6, 0
>c5e1	ed c5 92 98 9c 98		        .word nt_input, xt_output, z_output
>c5e7	6f 75 74 70 75 74		        .text "output"
.c5ed					nt_input:
>c5ed	05 00				        .byte 5, 0
>c5ef	fa c5 5e 92 68 92		        .word nt_cr, xt_input, z_input
>c5f5	69 6e 70 75 74			        .text "input"
.c5fa					nt_cr:
>c5fa	02 00				        .byte 2, 0
>c5fc	04 c6 80 89 85 89		        .word nt_page, xt_cr, z_cr
>c602	63 72				        .text "cr"
.c604					nt_page:
>c604	04 00				        .byte 4, 0
>c606	10 c6 bb 98 d8 98		        .word nt_at_xy, xt_page, z_page
>c60c	70 61 67 65			        .text "page"
.c610					nt_at_xy:
>c610	05 10				        .byte 5, UF
>c612	1d c6 3a 83 67 83		        .word nt_marker, xt_at_xy, z_at_xy
>c618	61 74 2d 78 79			        .text "at-xy"
.c61d					nt_marker:
>c61d	06 04				        .byte 6, IM
>c61f	2b c6 b3 94 f0 94		        .word nt_words, xt_marker, z_marker
>c625	6d 61 72 6b 65 72		        .text "marker"
.c62b					nt_words:
>c62b	05 00				        .byte 5, 0
>c62d	38 c6 f3 a6 4f a7		        .word nt_wordsize, xt_words, z_words
>c633	77 6f 72 64 73			        .text "words"
.c638					nt_wordsize:
>c638	08 10				        .byte 8, UF
>c63a	48 c6 50 a7 70 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c640	77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c648					nt_aligned:
>c648	07 00				        .byte 7, 0
>c64a	57 c6 94 82 94 82		        .word nt_align, xt_align, z_align
>c650	61 6c 69 67 6e 65 64		        .text "aligned"
.c657					nt_align:
>c657	05 00				        .byte 5, 0
>c659	64 c6 94 82 94 82		        .word nt_bell, xt_align, z_align
>c65f	61 6c 69 67 6e			        .text "align"
.c664					nt_bell:
>c664	04 00				        .byte 4, 0
>c666	70 c6 a0 83 a5 83		        .word nt_dump, xt_bell, z_bell
>c66c	62 65 6c 6c			        .text "bell"
.c670					nt_dump:
>c670	04 10				        .byte 4, UF
>c672	7c c6 3d 8d a3 8d		        .word nt_dot_s, xt_dump, z_dump
>c678	64 75 6d 70			        .text "dump"
.c67c					nt_dot_s:
>c67c	02 00				        .byte 2, 0
>c67e	86 c6 a9 8c ec 8c		        .word +, xt_dot_s, z_dot_s
>c684	2e 73				        .text ".s"
.c686					+
.c686					nt_disasm:
>c686	06 10				        .byte 6, UF
>c688	94 c6 57 8b 5d 8b		        .word +, xt_disasm, z_disasm
>c68e	64 69 73 61 73 6d		        .text "disasm"
.c694					+
.c694					nt_compare:
>c694	07 10				        .byte 7, UF
>c696	a3 c6 94 87 f8 87		        .word nt_search, xt_compare, z_compare
>c69c	63 6f 6d 70 61 72 65		        .text "compare"
.c6a3					nt_search:
>c6a3	06 18				        .byte 6, UF+NN
>c6a5	b1 c6 c4 9e 62 9f		        .word +, xt_search, z_search
>c6ab	73 65 61 72 63 68		        .text "search"
.c6b1					+
.c6b1					nt_environment_q:
>c6b1	0c 10				        .byte 12, UF
>c6b3	c5 c6 1e 8e 9a 8e		        .word +, xt_environment_q, z_environment_q
>c6b9	65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c6c1	65 6e 74 3f
.c6c5					+
.c6c5					nt_find:
>c6c5	04 10				        .byte 4, UF
>c6c7	d1 c6 9c 8f e3 8f		        .word nt_word, xt_find, z_find
>c6cd	66 69 6e 64			        .text "find"
.c6d1					nt_word:
>c6d1	04 10				        .byte 4, UF
>c6d3	dd c6 96 a6 db a6		        .word nt_paren, xt_word, z_word
>c6d9	77 6f 72 64			        .text "word"
.c6dd					nt_paren:
>c6dd	01 04				        .byte 1, IM
>c6df	e6 c6 d9 98 e8 98		        .word nt_dot_paren, xt_paren, z_paren
>c6e5	28				        .text "("
.c6e6					nt_dot_paren:
>c6e6	02 04				        .byte 2, IM
>c6e8	f0 c6 61 8c 6f 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c6ee	2e 28				        .text ".("
.c6f0					nt_if:
>c6f0	02 0d				        .byte 2, IM+CO+NN
>c6f2	fa c6 0a 92 1a 92		        .word nt_then, xt_if, z_if
>c6f8	69 66				        .text "if"
.c6fa					nt_then:
>c6fa	04 0d				        .byte 4, IM+CO+NN
>c6fc	06 c7 9d a1 a6 a1		        .word nt_else, xt_then, z_then
>c702	74 68 65 6e			        .text "then"
.c706					nt_else:
>c706	04 0d				        .byte 4, IM+CO+NN
>c708	12 c7 ca 8d e3 8d		        .word nt_repeat, xt_else, z_else
>c70e	65 6c 73 65			        .text "else"
.c712					nt_repeat:
>c712	06 0d				        .byte 6, IM+CO+NN
>c714	20 c7 44 9b 50 9b		        .word nt_until, xt_repeat, z_repeat
>c71a	72 65 70 65 61 74		        .text "repeat"
.c720					nt_until:
>c720	05 0d				        .byte 5, IM+CO+NN
>c722	2d c7 24 a6 2e a6		        .word nt_while, xt_until, z_until
>c728	75 6e 74 69 6c			        .text "until"
.c72d					nt_while:
>c72d	05 0d				        .byte 5, IM+CO+NN
>c72f	3a c7 6c a6 7f a6		        .word nt_case, xt_while, z_while
>c735	77 68 69 6c 65			        .text "while"
.c73a					nt_case:
>c73a	04 0d				        .byte 4, IM+CO+NN
>c73c	46 c7 83 a7 89 a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c742	63 61 73 65			        .text "case"
.c746					nt_of:
>c746	02 0d				        .byte 2, IM+CO+NN
>c748	50 c7 f9 97 11 98		        .word nt_endof, xt_of, z_of
>c74e	6f 66				        .text "of"
.c750					nt_endof:
>c750	05 0d				        .byte 5, IM+CO+NN
>c752	5d c7 ca 8d e3 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c758	65 6e 64 6f 66			        .text "endof"
.c75d					nt_endcase:
>c75d	07 0d				        .byte 7, IM+CO+NN
>c75f	6c c7 09 8e 1d 8e		        .word nt_defer_fetch, xt_endcase, z_endcase
>c765	65 6e 64 63 61 73 65		        .text "endcase"
.c76c					nt_defer_fetch:
>c76c	06 00				        .byte 6, 0
>c76e	7a c7 fc 8a 02 8b		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c774	64 65 66 65 72 40		        .text "defer@"
.c77a					nt_defer_store:
>c77a	06 00				        .byte 6, 0
>c77c	88 c7 03 8b 09 8b		        .word nt_is, xt_defer_store, z_defer_store
>c782	64 65 66 65 72 21		        .text "defer!"
.c788					nt_is:
>c788	02 04				        .byte 2, IM
>c78a	92 c7 02 93 1a 93		        .word nt_action_of, xt_is, z_is
>c790	69 73				        .text "is"
.c792					nt_action_of:
>c792	09 04				        .byte 9, IM
>c794	a3 c7 5a 82 72 82		        .word nt_useraddr, xt_action_of, z_action_of
>c79a	61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c7a2	66
.c7a3					nt_useraddr:
>c7a3	08 00				        .byte 8, 0
>c7a5	b3 c7 48 a6 52 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c7ab	75 73 65 72 61 64 64 72		        .text "useraddr"
.c7b3					nt_buffer_colon:
>c7b3	07 00				        .byte 7, 0
>c7b5	c2 c7 f2 85 f8 85		        .word +, xt_buffer_colon, z_buffer_colon
>c7bb	62 75 66 66 65 72 3a		        .text "buffer:"
.c7c2					+
.c7c2					nt_buffstatus:
>c7c2	0a 00				        .byte 10, 0
>c7c4	d4 c7 f9 85 08 86		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7ca	62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7d2	75 73
.c7d4					nt_buffblocknum:
>c7d4	0c 00				        .byte 12, 0
>c7d6	e8 c7 b1 85 c0 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c7dc	62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c7e4	6b 6e 75 6d
.c7e8					nt_blkbuffer:
>c7e8	09 00				        .byte 9, 0
>c7ea	f9 c7 bf 83 cc 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c7f0	62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c7f8	72
.c7f9					nt_scr:
>c7f9	03 00				        .byte 3, 0
>c7fb	04 c8 b4 9e c3 9e		        .word nt_blk, xt_scr, z_scr
>c801	73 63 72			        .text "scr"
.c804					nt_blk:
>c804	03 00				        .byte 3, 0
>c806	0f c8 af 83 be 83		        .word nt_block_write, xt_blk, z_blk
>c80c	62 6c 6b			        .text "blk"
.c80f					nt_block_write:
>c80f	0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c811	22 c8 6c 85 7a 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c817	62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c81f	69 74 65
.c822					nt_block_write_vector:
>c822	12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c824	3c c8 7a 85 89 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c82a	62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c832	69 74 65 2d 76 65 63 74 6f 72
.c83c					nt_block_read:
>c83c	0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c83e	4e c8 49 85 57 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c844	62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c84c	61 64
.c84e					nt_block_read_vector:
>c84e	11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c850	67 c8 57 85 66 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c856	62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c85e	61 64 2d 76 65 63 74 6f 72
.c867					nt_save_buffers:
>c867	0c 00				        .byte 12, 0
>c869	7b c8 99 9e b3 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c86f	73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c877	66 65 72 73
.c87b					nt_block:
>c87b	05 00				        .byte 5, 0
>c87d	88 c8 cd 83 1f 84		        .word nt_update, xt_block, z_block
>c883	62 6c 6f 63 6b			        .text "block"
.c888					nt_update:
>c888	06 00				        .byte 6, 0
>c88a	96 c8 3f a6 47 a6		        .word nt_buffer, xt_update, z_update
>c890	75 70 64 61 74 65		        .text "update"
.c896					nt_buffer:
>c896	06 00				        .byte 6, 0
>c898	a4 c8 c1 85 f1 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c89e	62 75 66 66 65 72		        .text "buffer"
.c8a4					nt_empty_buffers:
>c8a4	0d 00				        .byte 13, 0
>c8a6	b9 c8 02 8e 08 8e		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c8ac	65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c8b4	66 66 65 72 73
.c8b9					nt_flush:
>c8b9	05 00				        .byte 5, 0
>c8bb	c6 c8 90 90 99 90		        .word nt_load, xt_flush, z_flush
>c8c1	66 6c 75 73 68			        .text "flush"
.c8c6					nt_load:
>c8c6	04 10				        .byte 4, UF
>c8c8	d2 c8 be 93 01 94		        .word nt_thru, xt_load, z_load
>c8ce	6c 6f 61 64			        .text "load"
.c8d2					nt_thru:
>c8d2	04 10				        .byte 4, UF
>c8d4	de c8 a7 a1 eb a1		        .word nt_list, xt_thru, z_thru
>c8da	74 68 72 75			        .text "thru"
.c8de					nt_list:
>c8de	04 10				        .byte 4, UF
>c8e0	ea c8 84 93 90 93		        .word +, xt_list, z_list
>c8e6	6c 69 73 74			        .text "list"
.c8ea					+
.c8ea					nt_block_ramdrive_init:
>c8ea	13 10				        .byte 19, UF
>c8ec	05 c9 20 84 48 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c8f2	62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c8fa	6d 64 72 69 76 65 2d 69 6e 69 74
.c905					+
.c905					nt_definitions:
>c905	0b 00				        .byte 11, 0
>c907	18 c9 0a 8b 12 8b		        .word nt_wordlist, xt_definitions, z_definitions
>c90d	64 65 66 69 6e 69 74 69		        .text "definitions"
>c915	6f 6e 73
.c918					nt_wordlist:
>c918	08 00				        .byte 8, 0
>c91a	28 c9 dc a6 f2 a6		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c920	77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c928					nt_search_wordlist:
>c928	0f 10				        .byte 15, UF
>c92a	3f c9 aa 9b 8a 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c930	73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c938	6f 72 64 6c 69 73 74
.c93f					nt_set_current:
>c93f	0b 10				        .byte 11, UF
>c941	52 c9 19 9d 24 9d		        .word nt_get_current, xt_set_current, z_set_current
>c947	73 65 74 2d 63 75 72 72		        .text "set-current"
>c94f	65 6e 74
.c952					nt_get_current:
>c952	0b 00				        .byte 11, 0
>c954	65 c9 32 91 3c 91		        .word nt_set_order, xt_get_current, z_get_current
>c95a	67 65 74 2d 63 75 72 72		        .text "get-current"
>c962	65 6e 74
.c965					nt_set_order:
>c965	09 00				        .byte 9, 0
>c967	76 c9 25 9d 58 9d		        .word nt_get_order, xt_set_order, z_set_order
>c96d	73 65 74 2d 6f 72 64 65		        .text "set-order"
>c975	72
.c976					nt_get_order:
>c976	09 00				        .byte 9, 0
>c978	87 c9 3d 91 65 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c97e	67 65 74 2d 6f 72 64 65		        .text "get-order"
>c986	72
.c987					nt_root_wordlist:
>c987	0d 00				        .byte 13, 0
>c989	9c c9 58 9b 60 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c98f	72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c997	64 6c 69 73 74
.c99c					+
.c99c					nt_assembler_wordlist:
>c99c	12 00				        .byte 18, 0
>c99e	b6 c9 82 a3 8a a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c9a4	61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c9ac	72 2d 77 6f 72 64 6c 69 73 74
.c9b6					+
.c9b6					nt_editor_wordlist:
>c9b6	0f 00				        .byte 15, 0
>c9b8	cd c9 12 98 1a 98		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9be	65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9c6	6f 72 64 6c 69 73 74
.c9cd					+
.c9cd					nt_forth_wordlist:
>c9cd	0e 00				        .byte 14, 0
>c9cf	e3 c9 83 a7 89 a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c9d5	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9dd	72 64 6c 69 73 74
.c9e3					nt_only:
>c9e3	04 00				        .byte 4, 0
>c9e5	ef c9 31 98 3c 98		        .word nt_also, xt_only, z_only
>c9eb	6f 6e 6c 79			        .text "only"
.c9ef					nt_also:
>c9ef	04 00				        .byte 4, 0
>c9f1	fb c9 0a 83 19 83		        .word nt_previous, xt_also, z_also
>c9f7	61 6c 73 6f			        .text "also"
.c9fb					nt_previous:
>c9fb	08 00				        .byte 8, 0
>c9fd	0b ca 5f 9a 6b 9a		        .word nt_to_order, xt_previous, z_previous
>ca03	70 72 65 76 69 6f 75 73		        .text "previous"
.ca0b					nt_to_order:
>ca0b	06 00				        .byte 6, 0
>ca0d	19 ca 38 a3 4a a3		        .word nt_order, xt_to_order, z_to_order
>ca13	3e 6f 72 64 65 72		        .text ">order"
.ca19					nt_order:
>ca19	05 00				        .byte 5, 0
>ca1b	26 ca 4f 98 79 98		        .word nt_forth, xt_order, z_order
>ca21	6f 72 64 65 72			        .text "order"
.ca26					nt_forth:
>ca26	05 00				        .byte 5, 0
>ca28	33 ca d1 90 d7 90		        .word +, xt_forth, z_forth
>ca2e	66 6f 72 74 68			        .text "forth"
.ca33					+
>ca33	03 08				nt_see: .byte 3, NN
>ca35	3e ca 8b 9c 18 9d		        .word +, xt_see, z_see
>ca3b	73 65 65			        .text "see"
.ca3e					+
.ca3e					nt_ed:
>ca3e	02 08				        .byte 2, NN
>ca40	48 ca c6 8d c9 8d		        .word +, xt_ed, z_ed
>ca46	65 64				        .text "ed"
.ca48					+
.ca48					nt_cold:
>ca48	04 00				        .byte 4, 0
>ca4a	54 ca 00 80 ad 80		        .word nt_bye, xt_cold, z_cold
>ca50	63 6f 6c 64			        .text "cold"
.ca54					nt_bye:
>ca54	03				        .byte 3         ; length of word strings
>ca55	00				        .byte 0         ; status byte
>ca56	00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca58	09 86				        .word xt_bye    ; start of code block (xt of this word)
>ca5a	0c 86				        .word z_bye     ; end of code (RTS)
>ca5c	62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca5f					root_dictionary_start:
.ca5f					nt_root_set_order:
>ca5f	09 00				        .byte 9, 0
>ca61	70 ca 25 9d 58 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca67	73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca6f	72
.ca70					nt_root_forth:
>ca70	05 00				        .byte 5, 0
>ca72	7d ca d1 90 d7 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca78	66 6f 72 74 68			        .text "forth"
.ca7d					nt_root_forth_wordlist:
>ca7d	0e 00				        .byte 14, 0
>ca7f	93 ca 83 a7 89 a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca85	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca8d	72 64 6c 69 73 74
.ca93					nt_root_words:
>ca93	05 00				        .byte 5, 0
>ca95	00 00 f3 a6 4f a7		        .word 0000, xt_words, z_words
>ca9b	77 6f 72 64 73			        .text "words"
.caa0					editor_dictionary_start:
.caa0					nt_editor_o:
>caa0	01 00				        .byte 1, 0
>caa2	a9 ca b2 a8 f7 a8		        .word nt_editor_line, xt_editor_o, z_editor_o
>caa8	6f				        .text "o"
.caa9					nt_editor_line:
>caa9	04 10				        .byte 4, UF
>caab	b5 ca 99 a8 b1 a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>cab1	6c 69 6e 65			        .text "line"
.cab5					nt_editor_l:
>cab5	01 00				        .byte 1, 0
>cab7	be ca 1d a8 98 a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>cabd	6c				        .text "l"
.cabe					nt_editor_el:
>cabe	02 00				        .byte 2, 0
>cac0	c8 ca 0b a8 1c a8		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cac6	65 6c				        .text "el"
.cac8					nt_editor_erase_screen:
>cac8	0c 00				        .byte 12, 0
>caca	dc ca f9 a7 0a a8		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cad0	65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cad8	72 65 65 6e
.cadc					nt_editor_enter_screen:
>cadc	0c 00				        .byte 12, 0
>cade	00 00 dd a7 f8 a7		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cae4	65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>caec	72 65 65 6e
.caf0					assembler_dictionary_start:
.caf0					nt_asm_adc_h:
>caf0	05 0c						.byte 5, IM+NN
>caf2	fd ca				                .word nt_asm_adc_x
>caf4	f8 a8 fd a8					.word xt_asm_adc_h, z_asm_adc_h
>caf8	61 64 63 2e 23					.text "adc.#"
.cafd					nt_asm_adc_x:
>cafd	05 0c						.byte 5, IM+NN
>caff	0a cb				                .word nt_asm_adc_y
>cb01	fd a8 02 a9					.word xt_asm_adc_x, z_asm_adc_x
>cb05	61 64 63 2e 78					.text "adc.x"
.cb0a					nt_asm_adc_y:
>cb0a	05 0c						.byte 5, IM+NN
>cb0c	17 cb				                .word nt_asm_adc_z
>cb0e	02 a9 07 a9					.word xt_asm_adc_y, z_asm_adc_y
>cb12	61 64 63 2e 79					.text "adc.y"
.cb17					nt_asm_adc_z:
>cb17	05 0c						.byte 5, IM+NN
>cb19	24 cb				                .word nt_asm_adc_zi
>cb1b	07 a9 0c a9					.word xt_asm_adc_z, z_asm_adc_z
>cb1f	61 64 63 2e 7a					.text "adc.z"
.cb24					nt_asm_adc_zi:
>cb24	06 0c						.byte 6, IM+NN
>cb26	32 cb				                .word nt_asm_adc_ziy
>cb28	0c a9 11 a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cb2c	61 64 63 2e 7a 69				.text "adc.zi"
.cb32					nt_asm_adc_ziy:
>cb32	07 0c						.byte 7, IM+NN
>cb34	41 cb				                .word nt_asm_adc_zx
>cb36	11 a9 16 a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb3a	61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb41					nt_asm_adc_zx:
>cb41	06 0c						.byte 6, IM+NN
>cb43	4f cb				                .word nt_asm_adc_zxi
>cb45	16 a9 1b a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cb49	61 64 63 2e 7a 78				.text "adc.zx"
.cb4f					nt_asm_adc_zxi:
>cb4f	07 0c						.byte 7, IM+NN
>cb51	5e cb				                .word nt_asm_and
>cb53	1b a9 20 a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb57	61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb5e					nt_asm_and:
>cb5e	04 0c						.byte 4, IM+NN
>cb60	6a cb				                .word nt_asm_and_h
>cb62	20 a9 25 a9					.word xt_asm_and, z_asm_and
>cb66	61 6e 64 2e					.text "and."
.cb6a					nt_asm_and_h:
>cb6a	05 0c						.byte 5, IM+NN
>cb6c	77 cb				                .word nt_asm_and_x
>cb6e	25 a9 2a a9					.word xt_asm_and_h, z_asm_and_h
>cb72	61 6e 64 2e 23					.text "and.#"
.cb77					nt_asm_and_x:
>cb77	05 0c						.byte 5, IM+NN
>cb79	84 cb				                .word nt_asm_and_y
>cb7b	2a a9 2f a9					.word xt_asm_and_x, z_asm_and_x
>cb7f	61 6e 64 2e 78					.text "and.x"
.cb84					nt_asm_and_y:
>cb84	05 0c						.byte 5, IM+NN
>cb86	91 cb				                .word nt_asm_and_z
>cb88	2f a9 34 a9					.word xt_asm_and_y, z_asm_and_y
>cb8c	61 6e 64 2e 79					.text "and.y"
.cb91					nt_asm_and_z:
>cb91	05 0c						.byte 5, IM+NN
>cb93	9e cb				                .word nt_asm_and_zi
>cb95	34 a9 39 a9					.word xt_asm_and_z, z_asm_and_z
>cb99	61 6e 64 2e 7a					.text "and.z"
.cb9e					nt_asm_and_zi:
>cb9e	06 0c						.byte 6, IM+NN
>cba0	ac cb				                .word nt_asm_and_ziy
>cba2	39 a9 3e a9					.word xt_asm_and_zi, z_asm_and_zi
>cba6	61 6e 64 2e 7a 69				.text "and.zi"
.cbac					nt_asm_and_ziy:
>cbac	07 0c						.byte 7, IM+NN
>cbae	bb cb				                .word nt_asm_and_zx
>cbb0	3e a9 43 a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cbb4	61 6e 64 2e 7a 69 79				.text "and.ziy"
.cbbb					nt_asm_and_zx:
>cbbb	06 0c						.byte 6, IM+NN
>cbbd	c9 cb				                .word nt_asm_and_zxi
>cbbf	43 a9 48 a9					.word xt_asm_and_zx, z_asm_and_zx
>cbc3	61 6e 64 2e 7a 78				.text "and.zx"
.cbc9					nt_asm_and_zxi:
>cbc9	07 0c						.byte 7, IM+NN
>cbcb	d8 cb				                .word nt_asm_asl
>cbcd	48 a9 4d a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cbd1	61 6e 64 2e 7a 78 69				.text "and.zxi"
.cbd8					nt_asm_asl:
>cbd8	03 0c						.byte 3, IM+NN
>cbda	e3 cb				                .word nt_asm_asl_a
>cbdc	4d a9 52 a9					.word xt_asm_asl, z_asm_asl
>cbe0	61 73 6c					.text "asl"
.cbe3					nt_asm_asl_a:
>cbe3	05 0c						.byte 5, IM+NN
>cbe5	f0 cb				                .word nt_asm_asl_x
>cbe7	52 a9 57 a9					.word xt_asm_asl_a, z_asm_asl_a
>cbeb	61 73 6c 2e 61					.text "asl.a"
.cbf0					nt_asm_asl_x:
>cbf0	05 0c						.byte 5, IM+NN
>cbf2	fd cb				                .word nt_asm_asl_z
>cbf4	57 a9 5c a9					.word xt_asm_asl_x, z_asm_asl_x
>cbf8	61 73 6c 2e 78					.text "asl.x"
.cbfd					nt_asm_asl_z:
>cbfd	05 0c						.byte 5, IM+NN
>cbff	0a cc				                .word nt_asm_asl_zx
>cc01	5c a9 61 a9					.word xt_asm_asl_z, z_asm_asl_z
>cc05	61 73 6c 2e 7a					.text "asl.z"
.cc0a					nt_asm_asl_zx:
>cc0a	06 0c						.byte 6, IM+NN
>cc0c	18 cc				                .word nt_asm_bcc
>cc0e	61 a9 66 a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cc12	61 73 6c 2e 7a 78				.text "asl.zx"
.cc18					nt_asm_bcc:
>cc18	03 0c						.byte 3, IM+NN
>cc1a	23 cc				                .word nt_asm_bcs
>cc1c	66 a9 6b a9					.word xt_asm_bcc, z_asm_bcc
>cc20	62 63 63					.text "bcc"
.cc23					nt_asm_bcs:
>cc23	03 0c						.byte 3, IM+NN
>cc25	2e cc				                .word nt_asm_beq
>cc27	6b a9 72 a9					.word xt_asm_bcs, z_asm_bcs
>cc2b	62 63 73					.text "bcs"
.cc2e					nt_asm_beq:
>cc2e	03 0c						.byte 3, IM+NN
>cc30	39 cc				                .word nt_asm_bit
>cc32	72 a9 77 a9					.word xt_asm_beq, z_asm_beq
>cc36	62 65 71					.text "beq"
.cc39					nt_asm_bit:
>cc39	03 0c						.byte 3, IM+NN
>cc3b	44 cc				                .word nt_asm_bit_h
>cc3d	77 a9 7c a9					.word xt_asm_bit, z_asm_bit
>cc41	62 69 74					.text "bit"
.cc44					nt_asm_bit_h:
>cc44	05 0c						.byte 5, IM+NN
>cc46	51 cc				                .word nt_asm_bit_x
>cc48	7c a9 81 a9					.word xt_asm_bit_h, z_asm_bit_h
>cc4c	62 69 74 2e 23					.text "bit.#"
.cc51					nt_asm_bit_x:
>cc51	05 0c						.byte 5, IM+NN
>cc53	5e cc				                .word nt_asm_bit_z
>cc55	81 a9 86 a9					.word xt_asm_bit_x, z_asm_bit_x
>cc59	62 69 74 2e 78					.text "bit.x"
.cc5e					nt_asm_bit_z:
>cc5e	05 0c						.byte 5, IM+NN
>cc60	6b cc				                .word nt_asm_bit_zx
>cc62	86 a9 8b a9					.word xt_asm_bit_z, z_asm_bit_z
>cc66	62 69 74 2e 7a					.text "bit.z"
.cc6b					nt_asm_bit_zx:
>cc6b	06 0c						.byte 6, IM+NN
>cc6d	79 cc				                .word nt_asm_bmi
>cc6f	8b a9 90 a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cc73	62 69 74 2e 7a 78				.text "bit.zx"
.cc79					nt_asm_bmi:
>cc79	03 0c						.byte 3, IM+NN
>cc7b	84 cc				                .word nt_asm_bne
>cc7d	90 a9 95 a9					.word xt_asm_bmi, z_asm_bmi
>cc81	62 6d 69					.text "bmi"
.cc84					nt_asm_bne:
>cc84	03 0c						.byte 3, IM+NN
>cc86	8f cc				                .word nt_asm_bpl
>cc88	95 a9 9a a9					.word xt_asm_bne, z_asm_bne
>cc8c	62 6e 65					.text "bne"
.cc8f					nt_asm_bpl:
>cc8f	03 0c						.byte 3, IM+NN
>cc91	9a cc				                .word nt_asm_bra
>cc93	9a a9 9f a9					.word xt_asm_bpl, z_asm_bpl
>cc97	62 70 6c					.text "bpl"
.cc9a					nt_asm_bra:
>cc9a	03 0c						.byte 3, IM+NN
>cc9c	a5 cc				                .word nt_asm_brk
>cc9e	9f a9 a4 a9					.word xt_asm_bra, z_asm_bra
>cca2	62 72 61					.text "bra"
.cca5					nt_asm_brk:
>cca5	03 0c						.byte 3, IM+NN
>cca7	b0 cc				                .word nt_asm_bvc
>cca9	a4 a9 a9 a9					.word xt_asm_brk, z_asm_brk
>ccad	62 72 6b					.text "brk"
.ccb0					nt_asm_bvc:
>ccb0	03 0c						.byte 3, IM+NN
>ccb2	bb cc				                .word nt_asm_bvs
>ccb4	a9 a9 ae a9					.word xt_asm_bvc, z_asm_bvc
>ccb8	62 76 63					.text "bvc"
.ccbb					nt_asm_bvs:
>ccbb	03 0c						.byte 3, IM+NN
>ccbd	c6 cc				                .word nt_asm_clc
>ccbf	ae a9 b3 a9					.word xt_asm_bvs, z_asm_bvs
>ccc3	62 76 73					.text "bvs"
.ccc6					nt_asm_clc:
>ccc6	03 0c						.byte 3, IM+NN
>ccc8	d1 cc				                .word nt_asm_cld
>ccca	b3 a9 b8 a9					.word xt_asm_clc, z_asm_clc
>ccce	63 6c 63					.text "clc"
.ccd1					nt_asm_cld:
>ccd1	03 0c						.byte 3, IM+NN
>ccd3	dc cc				                .word nt_asm_cli
>ccd5	b8 a9 bd a9					.word xt_asm_cld, z_asm_cld
>ccd9	63 6c 64					.text "cld"
.ccdc					nt_asm_cli:
>ccdc	03 0c						.byte 3, IM+NN
>ccde	e7 cc				                .word nt_asm_clv
>cce0	bd a9 c2 a9					.word xt_asm_cli, z_asm_cli
>cce4	63 6c 69					.text "cli"
.cce7					nt_asm_clv:
>cce7	03 0c						.byte 3, IM+NN
>cce9	f2 cc				                .word nt_asm_cmp
>cceb	c2 a9 c7 a9					.word xt_asm_clv, z_asm_clv
>ccef	63 6c 76					.text "clv"
.ccf2					nt_asm_cmp:
>ccf2	03 0c						.byte 3, IM+NN
>ccf4	fd cc				                .word nt_asm_cmp_h
>ccf6	c7 a9 cc a9					.word xt_asm_cmp, z_asm_cmp
>ccfa	63 6d 70					.text "cmp"
.ccfd					nt_asm_cmp_h:
>ccfd	05 0c						.byte 5, IM+NN
>ccff	0a cd				                .word nt_asm_cmp_x
>cd01	cc a9 d1 a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cd05	63 6d 70 2e 23					.text "cmp.#"
.cd0a					nt_asm_cmp_x:
>cd0a	05 0c						.byte 5, IM+NN
>cd0c	17 cd				                .word nt_asm_cmp_y
>cd0e	d1 a9 d6 a9					.word xt_asm_cmp_x, z_asm_cmp_x
>cd12	63 6d 70 2e 78					.text "cmp.x"
.cd17					nt_asm_cmp_y:
>cd17	05 0c						.byte 5, IM+NN
>cd19	24 cd				                .word nt_asm_cmp_z
>cd1b	d6 a9 db a9					.word xt_asm_cmp_y, z_asm_cmp_y
>cd1f	63 6d 70 2e 79					.text "cmp.y"
.cd24					nt_asm_cmp_z:
>cd24	05 0c						.byte 5, IM+NN
>cd26	31 cd				                .word nt_asm_cmp_zi
>cd28	db a9 e0 a9					.word xt_asm_cmp_z, z_asm_cmp_z
>cd2c	63 6d 70 2e 7a					.text "cmp.z"
.cd31					nt_asm_cmp_zi:
>cd31	06 0c						.byte 6, IM+NN
>cd33	3f cd				                .word nt_asm_cmp_ziy
>cd35	e0 a9 e5 a9					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd39	63 6d 70 2e 7a 69				.text "cmp.zi"
.cd3f					nt_asm_cmp_ziy:
>cd3f	07 0c						.byte 7, IM+NN
>cd41	4e cd				                .word nt_asm_cmp_zx
>cd43	e5 a9 ea a9					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd47	63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd4e					nt_asm_cmp_zx:
>cd4e	06 0c						.byte 6, IM+NN
>cd50	5c cd				                .word nt_asm_cmp_zxi
>cd52	ea a9 ef a9					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd56	63 6d 70 2e 7a 78				.text "cmp.zx"
.cd5c					nt_asm_cmp_zxi:
>cd5c	07 0c						.byte 7, IM+NN
>cd5e	6b cd				                .word nt_asm_cpx
>cd60	ef a9 f4 a9					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd64	63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd6b					nt_asm_cpx:
>cd6b	03 0c						.byte 3, IM+NN
>cd6d	76 cd				                .word nt_asm_cpx_h
>cd6f	f4 a9 f9 a9					.word xt_asm_cpx, z_asm_cpx
>cd73	63 70 78					.text "cpx"
.cd76					nt_asm_cpx_h:
>cd76	05 0c						.byte 5, IM+NN
>cd78	83 cd				                .word nt_asm_cpx_z
>cd7a	f9 a9 fe a9					.word xt_asm_cpx_h, z_asm_cpx_h
>cd7e	63 70 78 2e 23					.text "cpx.#"
.cd83					nt_asm_cpx_z:
>cd83	05 0c						.byte 5, IM+NN
>cd85	90 cd				                .word nt_asm_cpy
>cd87	fe a9 03 aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cd8b	63 70 78 2e 7a					.text "cpx.z"
.cd90					nt_asm_cpy:
>cd90	03 0c						.byte 3, IM+NN
>cd92	9b cd				                .word nt_asm_cpy_h
>cd94	03 aa 0a aa					.word xt_asm_cpy, z_asm_cpy
>cd98	63 70 79					.text "cpy"
.cd9b					nt_asm_cpy_h:
>cd9b	05 0c						.byte 5, IM+NN
>cd9d	a8 cd				                .word nt_asm_cpy_z
>cd9f	0a aa 0f aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cda3	63 70 79 2e 23					.text "cpy.#"
.cda8					nt_asm_cpy_z:
>cda8	05 0c						.byte 5, IM+NN
>cdaa	b5 cd				                .word nt_asm_dec
>cdac	0f aa 14 aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cdb0	63 70 79 2e 7a					.text "cpy.z"
.cdb5					nt_asm_dec:
>cdb5	03 0c						.byte 3, IM+NN
>cdb7	c0 cd				                .word nt_asm_dec_a
>cdb9	14 aa 19 aa					.word xt_asm_dec, z_asm_dec
>cdbd	64 65 63					.text "dec"
.cdc0					nt_asm_dec_a:
>cdc0	05 0c						.byte 5, IM+NN
>cdc2	cd cd				                .word nt_asm_dec_x
>cdc4	19 aa 1e aa					.word xt_asm_dec_a, z_asm_dec_a
>cdc8	64 65 63 2e 61					.text "dec.a"
.cdcd					nt_asm_dec_x:
>cdcd	05 0c						.byte 5, IM+NN
>cdcf	da cd				                .word nt_asm_dec_z
>cdd1	1e aa 23 aa					.word xt_asm_dec_x, z_asm_dec_x
>cdd5	64 65 63 2e 78					.text "dec.x"
.cdda					nt_asm_dec_z:
>cdda	05 0c						.byte 5, IM+NN
>cddc	e7 cd				                .word nt_asm_dec_zx
>cdde	23 aa 28 aa					.word xt_asm_dec_z, z_asm_dec_z
>cde2	64 65 63 2e 7a					.text "dec.z"
.cde7					nt_asm_dec_zx:
>cde7	06 0c						.byte 6, IM+NN
>cde9	f5 cd				                .word nt_asm_dex
>cdeb	28 aa 2d aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cdef	64 65 63 2e 7a 78				.text "dec.zx"
.cdf5					nt_asm_dex:
>cdf5	03 0c						.byte 3, IM+NN
>cdf7	00 ce				                .word nt_asm_dey
>cdf9	2d aa 32 aa					.word xt_asm_dex, z_asm_dex
>cdfd	64 65 78					.text "dex"
.ce00					nt_asm_dey:
>ce00	03 0c						.byte 3, IM+NN
>ce02	0b ce				                .word nt_asm_eor
>ce04	32 aa 37 aa					.word xt_asm_dey, z_asm_dey
>ce08	64 65 79					.text "dey"
.ce0b					nt_asm_eor:
>ce0b	03 0c						.byte 3, IM+NN
>ce0d	16 ce				                .word nt_asm_eor_h
>ce0f	37 aa 3c aa					.word xt_asm_eor, z_asm_eor
>ce13	65 6f 72					.text "eor"
.ce16					nt_asm_eor_h:
>ce16	05 0c						.byte 5, IM+NN
>ce18	23 ce				                .word nt_asm_eor_x
>ce1a	3c aa 41 aa					.word xt_asm_eor_h, z_asm_eor_h
>ce1e	65 6f 72 2e 23					.text "eor.#"
.ce23					nt_asm_eor_x:
>ce23	05 0c						.byte 5, IM+NN
>ce25	30 ce				                .word nt_asm_eor_y
>ce27	41 aa 46 aa					.word xt_asm_eor_x, z_asm_eor_x
>ce2b	65 6f 72 2e 78					.text "eor.x"
.ce30					nt_asm_eor_y:
>ce30	05 0c						.byte 5, IM+NN
>ce32	3d ce				                .word nt_asm_eor_z
>ce34	46 aa 4b aa					.word xt_asm_eor_y, z_asm_eor_y
>ce38	65 6f 72 2e 79					.text "eor.y"
.ce3d					nt_asm_eor_z:
>ce3d	05 0c						.byte 5, IM+NN
>ce3f	4a ce				                .word nt_asm_eor_zi
>ce41	4b aa 50 aa					.word xt_asm_eor_z, z_asm_eor_z
>ce45	65 6f 72 2e 7a					.text "eor.z"
.ce4a					nt_asm_eor_zi:
>ce4a	06 0c						.byte 6, IM+NN
>ce4c	58 ce				                .word nt_asm_eor_ziy
>ce4e	50 aa 55 aa					.word xt_asm_eor_zi, z_asm_eor_zi
>ce52	65 6f 72 2e 7a 69				.text "eor.zi"
.ce58					nt_asm_eor_ziy:
>ce58	07 0c						.byte 7, IM+NN
>ce5a	67 ce				                .word nt_asm_eor_zx
>ce5c	55 aa 5a aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce60	65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce67					nt_asm_eor_zx:
>ce67	06 0c						.byte 6, IM+NN
>ce69	75 ce				                .word nt_asm_eor_zxi
>ce6b	5a aa 5f aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce6f	65 6f 72 2e 7a 78				.text "eor.zx"
.ce75					nt_asm_eor_zxi:
>ce75	07 0c						.byte 7, IM+NN
>ce77	84 ce				                .word nt_asm_inc
>ce79	5f aa 64 aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce7d	65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce84					nt_asm_inc:
>ce84	03 0c						.byte 3, IM+NN
>ce86	8f ce				                .word nt_asm_inc_a
>ce88	64 aa 69 aa					.word xt_asm_inc, z_asm_inc
>ce8c	69 6e 63					.text "inc"
.ce8f					nt_asm_inc_a:
>ce8f	05 0c						.byte 5, IM+NN
>ce91	9c ce				                .word nt_asm_inc_x
>ce93	69 aa 6e aa					.word xt_asm_inc_a, z_asm_inc_a
>ce97	69 6e 63 2e 61					.text "inc.a"
.ce9c					nt_asm_inc_x:
>ce9c	05 0c						.byte 5, IM+NN
>ce9e	a9 ce				                .word nt_asm_inc_z
>cea0	6e aa 73 aa					.word xt_asm_inc_x, z_asm_inc_x
>cea4	69 6e 63 2e 78					.text "inc.x"
.cea9					nt_asm_inc_z:
>cea9	05 0c						.byte 5, IM+NN
>ceab	b6 ce				                .word nt_asm_inc_zx
>cead	73 aa 78 aa					.word xt_asm_inc_z, z_asm_inc_z
>ceb1	69 6e 63 2e 7a					.text "inc.z"
.ceb6					nt_asm_inc_zx:
>ceb6	06 0c						.byte 6, IM+NN
>ceb8	c4 ce				                .word nt_asm_inx
>ceba	78 aa 7d aa					.word xt_asm_inc_zx, z_asm_inc_zx
>cebe	69 6e 63 2e 7a 78				.text "inc.zx"
.cec4					nt_asm_inx:
>cec4	03 0c						.byte 3, IM+NN
>cec6	cf ce				                .word nt_asm_iny
>cec8	7d aa 82 aa					.word xt_asm_inx, z_asm_inx
>cecc	69 6e 78					.text "inx"
.cecf					nt_asm_iny:
>cecf	03 0c						.byte 3, IM+NN
>ced1	da ce				                .word nt_asm_jmp
>ced3	82 aa 87 aa					.word xt_asm_iny, z_asm_iny
>ced7	69 6e 79					.text "iny"
.ceda					nt_asm_jmp:
>ceda	03 0c						.byte 3, IM+NN
>cedc	e5 ce				                .word nt_asm_jmp_i
>cede	87 aa 8c aa					.word xt_asm_jmp, z_asm_jmp
>cee2	6a 6d 70					.text "jmp"
.cee5					nt_asm_jmp_i:
>cee5	05 0c						.byte 5, IM+NN
>cee7	f2 ce				                .word nt_asm_jmp_xi
>cee9	8c aa 91 aa					.word xt_asm_jmp_i, z_asm_jmp_i
>ceed	6a 6d 70 2e 69					.text "jmp.i"
.cef2					nt_asm_jmp_xi:
>cef2	06 0c						.byte 6, IM+NN
>cef4	00 cf				                .word nt_asm_jsr
>cef6	91 aa 96 aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cefa	6a 6d 70 2e 78 69				.text "jmp.xi"
.cf00					nt_asm_jsr:
>cf00	03 0c						.byte 3, IM+NN
>cf02	0b cf				                .word nt_asm_lda
>cf04	96 aa 9b aa					.word xt_asm_jsr, z_asm_jsr
>cf08	6a 73 72					.text "jsr"
.cf0b					nt_asm_lda:
>cf0b	03 0c						.byte 3, IM+NN
>cf0d	16 cf				                .word nt_asm_lda_h
>cf0f	9b aa a0 aa					.word xt_asm_lda, z_asm_lda
>cf13	6c 64 61					.text "lda"
.cf16					nt_asm_lda_h:
>cf16	05 0c						.byte 5, IM+NN
>cf18	23 cf				                .word nt_asm_lda_x
>cf1a	a0 aa a5 aa					.word xt_asm_lda_h, z_asm_lda_h
>cf1e	6c 64 61 2e 23					.text "lda.#"
.cf23					nt_asm_lda_x:
>cf23	05 0c						.byte 5, IM+NN
>cf25	30 cf				                .word nt_asm_lda_y
>cf27	a5 aa aa aa					.word xt_asm_lda_x, z_asm_lda_x
>cf2b	6c 64 61 2e 78					.text "lda.x"
.cf30					nt_asm_lda_y:
>cf30	05 0c						.byte 5, IM+NN
>cf32	3d cf				                .word nt_asm_lda_z
>cf34	aa aa af aa					.word xt_asm_lda_y, z_asm_lda_y
>cf38	6c 64 61 2e 79					.text "lda.y"
.cf3d					nt_asm_lda_z:
>cf3d	05 0c						.byte 5, IM+NN
>cf3f	4a cf				                .word nt_asm_lda_zi
>cf41	af aa b4 aa					.word xt_asm_lda_z, z_asm_lda_z
>cf45	6c 64 61 2e 7a					.text "lda.z"
.cf4a					nt_asm_lda_zi:
>cf4a	06 0c						.byte 6, IM+NN
>cf4c	58 cf				                .word nt_asm_lda_ziy
>cf4e	b4 aa b9 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cf52	6c 64 61 2e 7a 69				.text "lda.zi"
.cf58					nt_asm_lda_ziy:
>cf58	07 0c						.byte 7, IM+NN
>cf5a	67 cf				                .word nt_asm_lda_zx
>cf5c	b9 aa be aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf60	6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf67					nt_asm_lda_zx:
>cf67	06 0c						.byte 6, IM+NN
>cf69	75 cf				                .word nt_asm_lda_zxi
>cf6b	be aa c3 aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cf6f	6c 64 61 2e 7a 78				.text "lda.zx"
.cf75					nt_asm_lda_zxi:
>cf75	07 0c						.byte 7, IM+NN
>cf77	84 cf				                .word nt_asm_ldx
>cf79	c3 aa c8 aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf7d	6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf84					nt_asm_ldx:
>cf84	03 0c						.byte 3, IM+NN
>cf86	8f cf				                .word nt_asm_ldx_h
>cf88	c8 aa cd aa					.word xt_asm_ldx, z_asm_ldx
>cf8c	6c 64 78					.text "ldx"
.cf8f					nt_asm_ldx_h:
>cf8f	05 0c						.byte 5, IM+NN
>cf91	9c cf				                .word nt_asm_ldx_y
>cf93	cd aa d2 aa					.word xt_asm_ldx_h, z_asm_ldx_h
>cf97	6c 64 78 2e 23					.text "ldx.#"
.cf9c					nt_asm_ldx_y:
>cf9c	05 0c						.byte 5, IM+NN
>cf9e	a9 cf				                .word nt_asm_ldx_z
>cfa0	d2 aa d7 aa					.word xt_asm_ldx_y, z_asm_ldx_y
>cfa4	6c 64 78 2e 79					.text "ldx.y"
.cfa9					nt_asm_ldx_z:
>cfa9	05 0c						.byte 5, IM+NN
>cfab	b6 cf				                .word nt_asm_ldx_zy
>cfad	d7 aa dc aa					.word xt_asm_ldx_z, z_asm_ldx_z
>cfb1	6c 64 78 2e 7a					.text "ldx.z"
.cfb6					nt_asm_ldx_zy:
>cfb6	06 0c						.byte 6, IM+NN
>cfb8	c4 cf				                .word nt_asm_ldy
>cfba	dc aa e1 aa					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfbe	6c 64 78 2e 7a 79				.text "ldx.zy"
.cfc4					nt_asm_ldy:
>cfc4	03 0c						.byte 3, IM+NN
>cfc6	cf cf				                .word nt_asm_ldy_h
>cfc8	e1 aa e6 aa					.word xt_asm_ldy, z_asm_ldy
>cfcc	6c 64 79					.text "ldy"
.cfcf					nt_asm_ldy_h:
>cfcf	05 0c						.byte 5, IM+NN
>cfd1	dc cf				                .word nt_asm_ldy_x
>cfd3	e6 aa eb aa					.word xt_asm_ldy_h, z_asm_ldy_h
>cfd7	6c 64 79 2e 23					.text "ldy.#"
.cfdc					nt_asm_ldy_x:
>cfdc	05 0c						.byte 5, IM+NN
>cfde	e9 cf				                .word nt_asm_ldy_z
>cfe0	eb aa f0 aa					.word xt_asm_ldy_x, z_asm_ldy_x
>cfe4	6c 64 79 2e 78					.text "ldy.x"
.cfe9					nt_asm_ldy_z:
>cfe9	05 0c						.byte 5, IM+NN
>cfeb	f6 cf				                .word nt_asm_ldy_zx
>cfed	f0 aa f5 aa					.word xt_asm_ldy_z, z_asm_ldy_z
>cff1	6c 64 79 2e 7a					.text "ldy.z"
.cff6					nt_asm_ldy_zx:
>cff6	06 0c						.byte 6, IM+NN
>cff8	04 d0				                .word nt_asm_lsr
>cffa	f5 aa fa aa					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cffe	6c 64 79 2e 7a 78				.text "ldy.zx"
.d004					nt_asm_lsr:
>d004	03 0c						.byte 3, IM+NN
>d006	0f d0				                .word nt_asm_lsr_a
>d008	fa aa ff aa					.word xt_asm_lsr, z_asm_lsr
>d00c	6c 73 72					.text "lsr"
.d00f					nt_asm_lsr_a:
>d00f	05 0c						.byte 5, IM+NN
>d011	1c d0				                .word nt_asm_lsr_x
>d013	ff aa 04 ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d017	6c 73 72 2e 61					.text "lsr.a"
.d01c					nt_asm_lsr_x:
>d01c	05 0c						.byte 5, IM+NN
>d01e	29 d0				                .word nt_asm_lsr_z
>d020	04 ab 09 ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d024	6c 73 72 2e 78					.text "lsr.x"
.d029					nt_asm_lsr_z:
>d029	05 0c						.byte 5, IM+NN
>d02b	36 d0				                .word nt_asm_lsr_zx
>d02d	09 ab 0e ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d031	6c 73 72 2e 7a					.text "lsr.z"
.d036					nt_asm_lsr_zx:
>d036	06 0c						.byte 6, IM+NN
>d038	44 d0				                .word nt_asm_nop
>d03a	0e ab 13 ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d03e	6c 73 72 2e 7a 78				.text "lsr.zx"
.d044					nt_asm_nop:
>d044	03 0c						.byte 3, IM+NN
>d046	4f d0				                .word nt_asm_ora
>d048	13 ab 18 ab					.word xt_asm_nop, z_asm_nop
>d04c	6e 6f 70					.text "nop"
.d04f					nt_asm_ora:
>d04f	03 0c						.byte 3, IM+NN
>d051	5a d0				                .word nt_asm_ora_h
>d053	18 ab 1d ab					.word xt_asm_ora, z_asm_ora
>d057	6f 72 61					.text "ora"
.d05a					nt_asm_ora_h:
>d05a	05 0c						.byte 5, IM+NN
>d05c	67 d0				                .word nt_asm_ora_x
>d05e	1d ab 22 ab					.word xt_asm_ora_h, z_asm_ora_h
>d062	6f 72 61 2e 23					.text "ora.#"
.d067					nt_asm_ora_x:
>d067	05 0c						.byte 5, IM+NN
>d069	74 d0				                .word nt_asm_ora_y
>d06b	22 ab 27 ab					.word xt_asm_ora_x, z_asm_ora_x
>d06f	6f 72 61 2e 78					.text "ora.x"
.d074					nt_asm_ora_y:
>d074	05 0c						.byte 5, IM+NN
>d076	81 d0				                .word nt_asm_ora_z
>d078	27 ab 2c ab					.word xt_asm_ora_y, z_asm_ora_y
>d07c	6f 72 61 2e 79					.text "ora.y"
.d081					nt_asm_ora_z:
>d081	05 0c						.byte 5, IM+NN
>d083	8e d0				                .word nt_asm_ora_zi
>d085	2c ab 31 ab					.word xt_asm_ora_z, z_asm_ora_z
>d089	6f 72 61 2e 7a					.text "ora.z"
.d08e					nt_asm_ora_zi:
>d08e	06 0c						.byte 6, IM+NN
>d090	9c d0				                .word nt_asm_ora_ziy
>d092	31 ab 38 ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d096	6f 72 61 2e 7a 69				.text "ora.zi"
.d09c					nt_asm_ora_ziy:
>d09c	07 0c						.byte 7, IM+NN
>d09e	ab d0				                .word nt_asm_ora_zx
>d0a0	38 ab 3d ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d0a4	6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d0ab					nt_asm_ora_zx:
>d0ab	06 0c						.byte 6, IM+NN
>d0ad	b9 d0				                .word nt_asm_ora_zxi
>d0af	3d ab 42 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d0b3	6f 72 61 2e 7a 78				.text "ora.zx"
.d0b9					nt_asm_ora_zxi:
>d0b9	07 0c						.byte 7, IM+NN
>d0bb	c8 d0				                .word nt_asm_pha
>d0bd	42 ab 47 ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0c1	6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0c8					nt_asm_pha:
>d0c8	03 0c						.byte 3, IM+NN
>d0ca	d3 d0				                .word nt_asm_php
>d0cc	47 ab 4c ab					.word xt_asm_pha, z_asm_pha
>d0d0	70 68 61					.text "pha"
.d0d3					nt_asm_php:
>d0d3	03 0c						.byte 3, IM+NN
>d0d5	de d0				                .word nt_asm_phx
>d0d7	4c ab 51 ab					.word xt_asm_php, z_asm_php
>d0db	70 68 70					.text "php"
.d0de					nt_asm_phx:
>d0de	03 0c						.byte 3, IM+NN
>d0e0	e9 d0				                .word nt_asm_phy
>d0e2	51 ab 56 ab					.word xt_asm_phx, z_asm_phx
>d0e6	70 68 78					.text "phx"
.d0e9					nt_asm_phy:
>d0e9	03 0c						.byte 3, IM+NN
>d0eb	f4 d0				                .word nt_asm_pla
>d0ed	56 ab 5b ab					.word xt_asm_phy, z_asm_phy
>d0f1	70 68 79					.text "phy"
.d0f4					nt_asm_pla:
>d0f4	03 0c						.byte 3, IM+NN
>d0f6	ff d0				                .word nt_asm_plp
>d0f8	5b ab 60 ab					.word xt_asm_pla, z_asm_pla
>d0fc	70 6c 61					.text "pla"
.d0ff					nt_asm_plp:
>d0ff	03 0c						.byte 3, IM+NN
>d101	0a d1				                .word nt_asm_plx
>d103	60 ab 65 ab					.word xt_asm_plp, z_asm_plp
>d107	70 6c 70					.text "plp"
.d10a					nt_asm_plx:
>d10a	03 0c						.byte 3, IM+NN
>d10c	15 d1				                .word nt_asm_ply
>d10e	65 ab 6a ab					.word xt_asm_plx, z_asm_plx
>d112	70 6c 78					.text "plx"
.d115					nt_asm_ply:
>d115	03 0c						.byte 3, IM+NN
>d117	20 d1				                .word nt_asm_rol
>d119	6a ab 6f ab					.word xt_asm_ply, z_asm_ply
>d11d	70 6c 79					.text "ply"
.d120					nt_asm_rol:
>d120	03 0c						.byte 3, IM+NN
>d122	2b d1				                .word nt_asm_rol_a
>d124	6f ab 74 ab					.word xt_asm_rol, z_asm_rol
>d128	72 6f 6c					.text "rol"
.d12b					nt_asm_rol_a:
>d12b	05 0c						.byte 5, IM+NN
>d12d	38 d1				                .word nt_asm_rol_x
>d12f	74 ab 79 ab					.word xt_asm_rol_a, z_asm_rol_a
>d133	72 6f 6c 2e 61					.text "rol.a"
.d138					nt_asm_rol_x:
>d138	05 0c						.byte 5, IM+NN
>d13a	45 d1				                .word nt_asm_rol_z
>d13c	79 ab 7e ab					.word xt_asm_rol_x, z_asm_rol_x
>d140	72 6f 6c 2e 78					.text "rol.x"
.d145					nt_asm_rol_z:
>d145	05 0c						.byte 5, IM+NN
>d147	52 d1				                .word nt_asm_rol_zx
>d149	7e ab 83 ab					.word xt_asm_rol_z, z_asm_rol_z
>d14d	72 6f 6c 2e 7a					.text "rol.z"
.d152					nt_asm_rol_zx:
>d152	06 0c						.byte 6, IM+NN
>d154	60 d1				                .word nt_asm_ror
>d156	83 ab 88 ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d15a	72 6f 6c 2e 7a 78				.text "rol.zx"
.d160					nt_asm_ror:
>d160	03 0c						.byte 3, IM+NN
>d162	6b d1				                .word nt_asm_ror_a
>d164	88 ab 8d ab					.word xt_asm_ror, z_asm_ror
>d168	72 6f 72					.text "ror"
.d16b					nt_asm_ror_a:
>d16b	05 0c						.byte 5, IM+NN
>d16d	78 d1				                .word nt_asm_ror_x
>d16f	8d ab 92 ab					.word xt_asm_ror_a, z_asm_ror_a
>d173	72 6f 72 2e 61					.text "ror.a"
.d178					nt_asm_ror_x:
>d178	05 0c						.byte 5, IM+NN
>d17a	85 d1				                .word nt_asm_ror_z
>d17c	92 ab 97 ab					.word xt_asm_ror_x, z_asm_ror_x
>d180	72 6f 72 2e 78					.text "ror.x"
.d185					nt_asm_ror_z:
>d185	05 0c						.byte 5, IM+NN
>d187	92 d1				                .word nt_asm_ror_zx
>d189	97 ab 9c ab					.word xt_asm_ror_z, z_asm_ror_z
>d18d	72 6f 72 2e 7a					.text "ror.z"
.d192					nt_asm_ror_zx:
>d192	06 0c						.byte 6, IM+NN
>d194	a0 d1				                .word nt_asm_rti
>d196	9c ab a1 ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d19a	72 6f 72 2e 7a 78				.text "ror.zx"
.d1a0					nt_asm_rti:
>d1a0	03 0c						.byte 3, IM+NN
>d1a2	ab d1				                .word nt_asm_rts
>d1a4	a1 ab a6 ab					.word xt_asm_rti, z_asm_rti
>d1a8	72 74 69					.text "rti"
.d1ab					nt_asm_rts:
>d1ab	03 0c						.byte 3, IM+NN
>d1ad	b6 d1				                .word nt_asm_sbc
>d1af	a6 ab ab ab					.word xt_asm_rts, z_asm_rts
>d1b3	72 74 73					.text "rts"
.d1b6					nt_asm_sbc:
>d1b6	03 0c						.byte 3, IM+NN
>d1b8	c1 d1				                .word nt_asm_sbc_h
>d1ba	ab ab b0 ab					.word xt_asm_sbc, z_asm_sbc
>d1be	73 62 63					.text "sbc"
.d1c1					nt_asm_sbc_h:
>d1c1	05 0c						.byte 5, IM+NN
>d1c3	ce d1				                .word nt_asm_sbc_x
>d1c5	b0 ab b5 ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d1c9	73 62 63 2e 23					.text "sbc.#"
.d1ce					nt_asm_sbc_x:
>d1ce	05 0c						.byte 5, IM+NN
>d1d0	db d1				                .word nt_asm_sbc_y
>d1d2	b5 ab ba ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d1d6	73 62 63 2e 78					.text "sbc.x"
.d1db					nt_asm_sbc_y:
>d1db	05 0c						.byte 5, IM+NN
>d1dd	e8 d1				                .word nt_asm_sbc_z
>d1df	ba ab bf ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d1e3	73 62 63 2e 79					.text "sbc.y"
.d1e8					nt_asm_sbc_z:
>d1e8	05 0c						.byte 5, IM+NN
>d1ea	f5 d1				                .word nt_asm_sbc_zi
>d1ec	bf ab c4 ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d1f0	73 62 63 2e 7a					.text "sbc.z"
.d1f5					nt_asm_sbc_zi:
>d1f5	06 0c						.byte 6, IM+NN
>d1f7	03 d2				                .word nt_asm_sbc_ziy
>d1f9	c4 ab c9 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d1fd	73 62 63 2e 7a 69				.text "sbc.zi"
.d203					nt_asm_sbc_ziy:
>d203	07 0c						.byte 7, IM+NN
>d205	12 d2				                .word nt_asm_sbc_zx
>d207	c9 ab ce ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d20b	73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d212					nt_asm_sbc_zx:
>d212	06 0c						.byte 6, IM+NN
>d214	20 d2				                .word nt_asm_sbc_zxi
>d216	ce ab d3 ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d21a	73 62 63 2e 7a 78				.text "sbc.zx"
.d220					nt_asm_sbc_zxi:
>d220	07 0c						.byte 7, IM+NN
>d222	2f d2				                .word nt_asm_sec
>d224	d3 ab d7 ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d228	73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d22f					nt_asm_sec:
>d22f	03 0c						.byte 3, IM+NN
>d231	3a d2				                .word nt_asm_sed
>d233	d7 ab db ab					.word xt_asm_sec, z_asm_sec
>d237	73 65 63					.text "sec"
.d23a					nt_asm_sed:
>d23a	03 0c						.byte 3, IM+NN
>d23c	45 d2				                .word nt_asm_sei
>d23e	db ab df ab					.word xt_asm_sed, z_asm_sed
>d242	73 65 64					.text "sed"
.d245					nt_asm_sei:
>d245	03 0c						.byte 3, IM+NN
>d247	50 d2				                .word nt_asm_sta
>d249	df ab e3 ab					.word xt_asm_sei, z_asm_sei
>d24d	73 65 69					.text "sei"
.d250					nt_asm_sta:
>d250	03 0c						.byte 3, IM+NN
>d252	5b d2				                .word nt_asm_sta_x
>d254	e3 ab e7 ab					.word xt_asm_sta, z_asm_sta
>d258	73 74 61					.text "sta"
.d25b					nt_asm_sta_x:
>d25b	05 0c						.byte 5, IM+NN
>d25d	68 d2				                .word nt_asm_sta_y
>d25f	e7 ab eb ab					.word xt_asm_sta_x, z_asm_sta_x
>d263	73 74 61 2e 78					.text "sta.x"
.d268					nt_asm_sta_y:
>d268	05 0c						.byte 5, IM+NN
>d26a	75 d2				                .word nt_asm_sta_z
>d26c	eb ab ef ab					.word xt_asm_sta_y, z_asm_sta_y
>d270	73 74 61 2e 79					.text "sta.y"
.d275					nt_asm_sta_z:
>d275	05 0c						.byte 5, IM+NN
>d277	82 d2				                .word nt_asm_sta_zi
>d279	ef ab f3 ab					.word xt_asm_sta_z, z_asm_sta_z
>d27d	73 74 61 2e 7a					.text "sta.z"
.d282					nt_asm_sta_zi:
>d282	06 0c						.byte 6, IM+NN
>d284	90 d2				                .word nt_asm_sta_ziy
>d286	f3 ab f7 ab					.word xt_asm_sta_zi, z_asm_sta_zi
>d28a	73 74 61 2e 7a 69				.text "sta.zi"
.d290					nt_asm_sta_ziy:
>d290	07 0c						.byte 7, IM+NN
>d292	9f d2				                .word nt_asm_sta_zx
>d294	f7 ab fb ab					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d298	73 74 61 2e 7a 69 79				.text "sta.ziy"
.d29f					nt_asm_sta_zx:
>d29f	06 0c						.byte 6, IM+NN
>d2a1	ad d2				                .word nt_asm_sta_zxi
>d2a3	fb ab ff ab					.word xt_asm_sta_zx, z_asm_sta_zx
>d2a7	73 74 61 2e 7a 78				.text "sta.zx"
.d2ad					nt_asm_sta_zxi:
>d2ad	07 0c						.byte 7, IM+NN
>d2af	bc d2				                .word nt_asm_stx
>d2b1	ff ab 03 ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2b5	73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2bc					nt_asm_stx:
>d2bc	03 0c						.byte 3, IM+NN
>d2be	c7 d2				                .word nt_asm_stx_z
>d2c0	03 ac 07 ac					.word xt_asm_stx, z_asm_stx
>d2c4	73 74 78					.text "stx"
.d2c7					nt_asm_stx_z:
>d2c7	05 0c						.byte 5, IM+NN
>d2c9	d4 d2				                .word nt_asm_stx_zy
>d2cb	07 ac 0b ac					.word xt_asm_stx_z, z_asm_stx_z
>d2cf	73 74 78 2e 7a					.text "stx.z"
.d2d4					nt_asm_stx_zy:
>d2d4	06 0c						.byte 6, IM+NN
>d2d6	e2 d2				                .word nt_asm_sty
>d2d8	0b ac 0f ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d2dc	73 74 78 2e 7a 79				.text "stx.zy"
.d2e2					nt_asm_sty:
>d2e2	03 0c						.byte 3, IM+NN
>d2e4	ed d2				                .word nt_asm_sty_z
>d2e6	0f ac 13 ac					.word xt_asm_sty, z_asm_sty
>d2ea	73 74 79					.text "sty"
.d2ed					nt_asm_sty_z:
>d2ed	05 0c						.byte 5, IM+NN
>d2ef	fa d2				                .word nt_asm_sty_zx
>d2f1	13 ac 17 ac					.word xt_asm_sty_z, z_asm_sty_z
>d2f5	73 74 79 2e 7a					.text "sty.z"
.d2fa					nt_asm_sty_zx:
>d2fa	06 0c						.byte 6, IM+NN
>d2fc	08 d3				                .word nt_asm_stz
>d2fe	17 ac 1b ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d302	73 74 79 2e 7a 78				.text "sty.zx"
.d308					nt_asm_stz:
>d308	03 0c						.byte 3, IM+NN
>d30a	13 d3				                .word nt_asm_stz_x
>d30c	1b ac 1f ac					.word xt_asm_stz, z_asm_stz
>d310	73 74 7a					.text "stz"
.d313					nt_asm_stz_x:
>d313	05 0c						.byte 5, IM+NN
>d315	20 d3				                .word nt_asm_stz_z
>d317	1f ac 23 ac					.word xt_asm_stz_x, z_asm_stz_x
>d31b	73 74 7a 2e 78					.text "stz.x"
.d320					nt_asm_stz_z:
>d320	05 0c						.byte 5, IM+NN
>d322	2d d3				                .word nt_asm_stz_zx
>d324	23 ac 27 ac					.word xt_asm_stz_z, z_asm_stz_z
>d328	73 74 7a 2e 7a					.text "stz.z"
.d32d					nt_asm_stz_zx:
>d32d	06 0c						.byte 6, IM+NN
>d32f	3b d3				                .word nt_asm_tax
>d331	27 ac 2b ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d335	73 74 7a 2e 7a 78				.text "stz.zx"
.d33b					nt_asm_tax:
>d33b	03 0c						.byte 3, IM+NN
>d33d	46 d3				                .word nt_asm_tay
>d33f	2b ac 2f ac					.word xt_asm_tax, z_asm_tax
>d343	74 61 78					.text "tax"
.d346					nt_asm_tay:
>d346	03 0c						.byte 3, IM+NN
>d348	51 d3				                .word nt_asm_trb
>d34a	2f ac 33 ac					.word xt_asm_tay, z_asm_tay
>d34e	74 61 79					.text "tay"
.d351					nt_asm_trb:
>d351	03 0c						.byte 3, IM+NN
>d353	5c d3				                .word nt_asm_trb_z
>d355	33 ac 37 ac					.word xt_asm_trb, z_asm_trb
>d359	74 72 62					.text "trb"
.d35c					nt_asm_trb_z:
>d35c	05 0c						.byte 5, IM+NN
>d35e	69 d3				                .word nt_asm_tsb
>d360	37 ac 3b ac					.word xt_asm_trb_z, z_asm_trb_z
>d364	74 72 62 2e 7a					.text "trb.z"
.d369					nt_asm_tsb:
>d369	03 0c						.byte 3, IM+NN
>d36b	74 d3				                .word nt_asm_tsb_z
>d36d	3b ac 3f ac					.word xt_asm_tsb, z_asm_tsb
>d371	74 73 62					.text "tsb"
.d374					nt_asm_tsb_z:
>d374	05 0c						.byte 5, IM+NN
>d376	81 d3				                .word nt_asm_tsx
>d378	3f ac 43 ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d37c	74 73 62 2e 7a					.text "tsb.z"
.d381					nt_asm_tsx:
>d381	03 0c						.byte 3, IM+NN
>d383	8c d3				                .word nt_asm_txa
>d385	43 ac 47 ac					.word xt_asm_tsx, z_asm_tsx
>d389	74 73 78					.text "tsx"
.d38c					nt_asm_txa:
>d38c	03 0c						.byte 3, IM+NN
>d38e	97 d3				                .word nt_asm_txs
>d390	47 ac 4b ac					.word xt_asm_txa, z_asm_txa
>d394	74 78 61					.text "txa"
.d397					nt_asm_txs:
>d397	03 0c						.byte 3, IM+NN
>d399	a2 d3				                .word nt_asm_tya
>d39b	4b ac 4f ac					.word xt_asm_txs, z_asm_txs
>d39f	74 78 73					.text "txs"
.d3a2					nt_asm_tya:
>d3a2	03 0c						.byte 3, IM+NN
>d3a4	ad d3				                .word nt_asm_arrow
>d3a6	4f ac 53 ac					.word xt_asm_tya, z_asm_tya
>d3aa	74 79 61					.text "tya"
.d3ad					nt_asm_arrow:
>d3ad	03 04				                .byte 3, IM
>d3af	b8 d3				                .word nt_asm_back_jump
>d3b1	7b 91 85 91			                .word xt_asm_arrow, z_asm_arrow
>d3b5	2d 2d 3e			                .text "-->"
.d3b8					nt_asm_back_jump:
>d3b8	02 04				                .byte 2, IM
>d3ba	c2 d3				                .word nt_asm_back_branch
>d3bc	a4 ac a4 ac			                .word xt_asm_back_jump, z_asm_back_jump
>d3c0	3c 6a				                .text "<j"
.d3c2					nt_asm_back_branch:
>d3c2	02 04				                .byte 2, IM
>d3c4	cc d3				                .word nt_asm_push_a
>d3c6	a5 ac ad ac			                .word xt_asm_back_branch, z_asm_back_branch
>d3ca	3c 62				                .text "<b"
.d3cc					nt_asm_push_a:
>d3cc	06 0c				                .byte 6, IM+NN
>d3ce	00 00				                .word 0000
>d3d0	8d ac 9c ac			                .word xt_asm_push_a, z_asm_push_a
>d3d4	70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0					ix := 0
=0					str_ok             = ix
=1					ix += 1
=1					str_compile        = ix
=2					ix += 1
=2					str_redefined      = ix
=3					ix += 1
=3					str_abc_upper      = ix
=4					ix += 1
=4					str_wid_forth      = ix
=5					ix += 1
=5					str_wid_editor     = ix
=6					ix += 1
=6					str_wid_assembler  = ix
=7					ix += 1
=7					str_wid_root       = ix
=8					ix += 1
=8					str_see_flags      = ix
=9					ix += 1
=9					str_see_nt         = ix
=10					ix += 1
=10					str_see_xt         = ix
=11					ix += 1
=11					str_see_size       = ix
=12					ix += 1
=12					str_disasm_lit     = ix
=13					ix += 1
=13					str_disasm_sdc     = ix
=14					ix += 1
=14					str_disasm_bra     = ix
=15					ix += 1
.d3da					string_table:
>d3da	f8 d3 fc d3 06 d4 11 d4		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d3e2	48 d4 40 d4 35 d4 4f d4		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d3ea	55 d4 71 d4 76 d4 7b d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d3f2	8c d4 95 d4 a7 d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 12-14
>d3f8	20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d3fc	20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d404	64 00
>d406	72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d40e	64 20 00
>d411	30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d419	38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d429	4f 50 51 52 53 54 55 56 57 58 59 5a
>d435	41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d43d	72 20 00
>d440	45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d448	46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d44f	52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d455	66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d45d	4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d46d	29 3a 20 00
>d471	6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d476	78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d47b	73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d483	63 69 6d 61 6c 29 3a 20 00
>d48c	4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d494	00
>d495	53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d49d	50 54 48 20 43 48 45 43 4b 00
>d4a7	42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0					err_allot        = 0
=1					err_badsource    = 1
=2					err_compileonly  = 2
=3					err_defer        = 3
=4					err_divzero      = 4
=5					err_noname       = 5
=6					err_refill       = 6
=7					err_state        = 7
=8					err_syntax       = 8
=9					err_underflow    = 9
=10					err_negallot     = 10
=11					err_wordlist     = 11
=12					err_blockwords   = 12
=13					err_returnstack  = 13
.d4af					error_table:
>d4af	cb d4 ec d4 0c d5 2d d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4b7	4a d5 5b d5 6b d5 99 d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4bf	b1 d5 d2 d5 e7 d5 03 d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4c7	1a d6 59 d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d4cb	41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d4d3	69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d4e3	65 20 6d 65 6d 6f 72 79 00
>d4ec	49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d4f4	53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d504	20 52 45 46 49 4c 4c 00
>d50c	49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d514	74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d524	6e 6c 79 20 77 6f 72 64 00
>d52d	44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d535	77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d545	20 79 65 74 00
>d54a	44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d552	20 62 79 20 7a 65 72 6f 00
>d55b	50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d563	66 61 69 6c 75 72 65 00
>d56b	51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d573	6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d583	20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d593	64 20 2d 31 29 00
>d599	41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d5a1	69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5b1	55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d5b9	64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d5c9	64 20 6e 75 6d 62 65 72 00
>d5d2	44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d5da	63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d5e7	4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d5ef	72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d5ff	4c 4f 54 00
>d603	4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d60b	69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d61a	50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d622	73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d632	4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d642	61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d652	56 45 43 54 4f 52 00
>d659	52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d661	74 61 63 6b 3a 00
>d667	0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d66f	44 2d 53 54 52 49 4e 47
>d677	05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d67d	04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d682	11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d68a	2d 55 4e 49 54 2d 42 49 54 53
>d694	07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d69c	08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6a4	52
>d6a5	05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6ab	05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6b1	12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6b9	53 54 41 43 4b 2d 43 45 4c 4c 53
>d6c4	0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d6cc	45 4c 4c 53
>d6d0	09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d6d8	54 53
>d6da	05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d6e0	06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d6e7					cmpl_subroutine:
.d6e7	48		pha		                pha             ; save LSB of address
.d6e8	a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d6ea	80 03		bra $d6ef	                bra cmpl_common
.d6ec					cmpl_jump:
.d6ec	48		pha		                pha             ; save LSB of address
.d6ed	a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d6ef					cmpl_common:
.d6ef	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; compile opcode
.d6f2	68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d6f3					cmpl_word:
.d6f3	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; compile LSB of address
.d6f6	98		tya		                tya             ; fall thru for MSB
.d6f7					cmpl_a:
.d6f7	92 00		sta ($00)	                sta (cp)
.d6f9	e6 00		inc $00		                inc cp
.d6fb	d0 02		bne $d6ff	                bne _done
.d6fd	e6 01		inc $01		                inc cp+1
.d6ff					_done:
.d6ff	60		rts		                rts
.d700					doconst:
.d700	ca		dex		                dex             ; make room for constant
.d701	ca		dex		                dex
.d702	68		pla		                pla             ; LSB of return address
.d703	85 24		sta $24		                sta tmp1
.d705	68		pla		                pla             ; MSB of return address
.d706	85 25		sta $25		                sta tmp1+1
.d708	a0 01		ldy #$01	                ldy #1
.d70a	b1 24		lda ($24),y	                lda (tmp1),y
.d70c	95 00		sta $00,x	                sta 0,x
.d70e	c8		iny		                iny
.d70f	b1 24		lda ($24),y	                lda (tmp1),y
.d711	95 01		sta $01,x	                sta 1,x
.d713	60		rts		                rts
.d714					dodefer:
.d714	68		pla		                pla             ; LSB
.d715	85 24		sta $24		                sta tmp1
.d717	68		pla		                pla             ; MSB
.d718	85 25		sta $25		                sta tmp1+1
.d71a	a0 01		ldy #$01	                ldy #1
.d71c	b1 24		lda ($24),y	                lda (tmp1),y
.d71e	85 26		sta $26		                sta tmp2
.d720	c8		iny		                iny
.d721	b1 24		lda ($24),y	                lda (tmp1),y
.d723	85 27		sta $27		                sta tmp2+1
.d725	6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d728					defer_error:
.d728	a9 03		lda #$03	                lda #err_defer
.d72a	4c 5a d8	jmp $d85a	                jmp error
.d72d					dodoes:
.d72d	7a		ply		                ply             ; LSB
.d72e	68		pla		                pla             ; MSB
.d72f	c8		iny		                iny
.d730	d0 01		bne $d733	                bne +
.d732	1a		inc a		                ina
.d733					+
.d733	84 26		sty $26		                sty tmp2
.d735	85 27		sta $27		                sta tmp2+1
.d737	ca		dex		                dex
.d738	ca		dex		                dex
.d739	7a		ply		                ply
.d73a	68		pla		                pla
.d73b	c8		iny		                iny
.d73c	d0 01		bne $d73f	                bne +
.d73e	1a		inc a		                ina
.d73f					+
.d73f	94 00		sty $00,x	                sty 0,x         ; LSB
.d741	95 01		sta $01,x	                sta 1,x         ; MSB
.d743	6c 26 00	jmp ($0026)	                jmp (tmp2)
.d746					dovar:
.d746	7a		ply		                ply             ; LSB
.d747	68		pla		                pla             ; MSB
.d748	c8		iny		                iny
.d749	d0 01		bne $d74c	                bne +
.d74b	1a		inc a		                ina
.d74c					+
.d74c	ca		dex		                dex
.d74d	ca		dex		                dex
.d74e	95 01		sta $01,x	                sta 1,x
.d750	98		tya		                tya
.d751	95 00		sta $00,x	                sta 0,x
.d753	60		rts		                rts
.d754					byte_to_ascii:
.d754	48		pha		                pha
.d755	4a		lsr a		                lsr             ; convert high nibble first
.d756	4a		lsr a		                lsr
.d757	4a		lsr a		                lsr
.d758	4a		lsr a		                lsr
.d759	20 5d d7	jsr $d75d	                jsr _nibble_to_ascii
.d75c	68		pla		                pla
.d75d					_nibble_to_ascii:
.d75d	29 0f		and #$0f	                and #$0F
.d75f	09 30		ora #$30	                ora #'0'
.d761	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d763	90 02		bcc $d767	                bcc +
.d765	69 06		adc #$06	                adc #$06
.d767	4c ff 8d	jmp $8dff	+               jmp emit_a
.d76a	60		rts		                rts
.d76b					compare_16bit:
.d76b	b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d76d	d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d76f	f0 0a		beq $d77b	                beq _equal
.d771	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d773	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d775	09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d777	70 08		bvs $d781	                bvs _overflow
.d779	80 08		bra $d783	                bra _not_equal
.d77b					_equal:
.d77b	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d77d	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d77f	50 04		bvc $d785	                bvc _done
.d781					_overflow:
.d781	49 80		eor #$80	                eor #$80                ; complement negative flag
.d783					_not_equal:
.d783	09 01		ora #$01	                ora #1                  ; if overflow, we can't be equal
.d785					_done:
.d785	60		rts		                rts
.d786					current_to_dp:
.d786	a0 04		ldy #$04	                ldy #current_offset
.d788	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d78a	0a		asl a		                asl             ; turn it into an offset (in cells)
.d78b	18		clc		                clc
.d78c	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d78e	a8		tay		                tay
.d78f	b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d791	85 02		sta $02		                sta dp
.d793	c8		iny		                iny
.d794	b1 1e		lda ($1e),y	                lda (up),y
.d796	85 03		sta $03		                sta dp+1
.d798	60		rts		                rts
.d799					dp_to_current:
.d799	a0 04		ldy #$04	                ldy #current_offset
.d79b	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d79d	0a		asl a		                asl             ; turn it into an offset (in cells)
.d79e	18		clc		                clc
.d79f	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d7a1	a8		tay		                tay
.d7a2	a5 02		lda $02		                lda dp
.d7a4	91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d7a6	c8		iny		                iny
.d7a7	a5 03		lda $03		                lda dp+1
.d7a9	91 1e		sta ($1e),y	                sta (up),y
.d7ab	60		rts		                rts
.d7ac					interpret:
.d7ac					_loop:
.d7ac	20 e9 98	jsr $98e9	                jsr xt_parse_name       ; ( "string" -- addr u )
.d7af	b5 00		lda $00,x	                lda 0,x
.d7b1	15 01		ora $01,x	                ora 1,x
.d7b3	f0 70		beq $d825	                beq _line_done
.d7b5	20 93 a3	jsr $a393	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d7b8	20 e4 8f	jsr $8fe4	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d7bb	b5 00		lda $00,x	                lda 0,x
.d7bd	15 01		ora $01,x	                ora 1,x
.d7bf	d0 28		bne $d7e9	                bne _got_name_token
.d7c1	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d7c2	e8		inx		                inx
.d7c3	20 94 96	jsr $9694	                jsr xt_number           ; ( addr u -- u|d )
.d7c6	a5 16		lda $16		                lda state
.d7c8	f0 e2		beq $d7ac	                beq _loop
.d7ca	a9 20		lda #$20	                lda #$20
.d7cc	24 20		bit $20		                bit status
.d7ce	f0 0d		beq $d7dd	                beq _single_number
.d7d0	20 89 a1	jsr $a189	                jsr xt_swap
.d7d3	a0 93		ldy #$93	                ldy #>literal_runtime
.d7d5	a9 9f		lda #$9f	                lda #<literal_runtime
.d7d7	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.d7da	20 7a 87	jsr $877a	                jsr xt_comma
.d7dd					_single_number:
.d7dd	a0 93		ldy #$93	                ldy #>literal_runtime
.d7df	a9 9f		lda #$9f	                lda #<literal_runtime
.d7e1	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.d7e4	20 7a 87	jsr $877a	                jsr xt_comma
.d7e7	80 c3		bra $d7ac	                bra _loop
.d7e9					_got_name_token:
.d7e9	b5 00		lda $00,x	                lda 0,x
.d7eb	95 04		sta $04,x	                sta 4,x
.d7ed	b5 01		lda $01,x	                lda 1,x
.d7ef	95 05		sta $05,x	                sta 5,x
.d7f1	e8		inx		                inx
.d7f2	e8		inx		                inx
.d7f3	e8		inx		                inx
.d7f4	e8		inx		                inx                     ; ( nt )
.d7f5	b5 00		lda $00,x	                lda 0,x
.d7f7	85 22		sta $22		                sta tmpbranch
.d7f9	b5 01		lda $01,x	                lda 1,x
.d7fb	85 23		sta $23		                sta tmpbranch+1
.d7fd	20 eb 95	jsr $95eb	                jsr xt_name_to_int      ; ( nt - xt )
.d800	a5 16		lda $16		                lda state
.d802	d0 13		bne $d817	                bne _compile
.d804	a0 01		ldy #$01	                ldy #1
.d806	b1 22		lda ($22),y	                lda (tmpbranch),y
.d808	29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d80a	f0 05		beq $d811	                beq _interpret
.d80c	a9 02		lda #$02	                lda #err_compileonly
.d80e	4c 5a d8	jmp $d85a	                jmp error
.d811					_interpret:
.d811	20 46 8f	jsr $8f46	                jsr xt_execute
.d814	4c ac d7	jmp $d7ac	                jmp _loop
.d817					_compile:
.d817	a0 01		ldy #$01	                ldy #1
.d819	b1 22		lda ($22),y	                lda (tmpbranch),y
.d81b	29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d81d	d0 f2		bne $d811	                bne _interpret          ; IMMEDIATE word, execute right now
.d81f	20 f9 87	jsr $87f9	                jsr xt_compile_comma
.d822	4c ac d7	jmp $d7ac	                jmp _loop
.d825					_line_done:
.d825	e8		inx		                inx
.d826	e8		inx		                inx
.d827	e8		inx		                inx
.d828	e8		inx		                inx
.d829	60		rts		                rts
.d82a					is_printable:
.d82a	c9 20		cmp #$20	                cmp #AscSP              ; $20
.d82c	90 08		bcc $d836	                bcc _done
.d82e	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d830	b0 03		bcs $d835	                bcs _failed
.d832	38		sec		                sec
.d833	80 01		bra $d836	                bra _done
.d835					_failed:
.d835	18		clc		                clc
.d836					_done:
.d836	60		rts		                rts
.d837					is_whitespace:
.d837	c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d839	90 08		bcc $d843	                bcc _done
.d83b	c9 21		cmp #$21	                cmp #AscSP+1
.d83d	b0 03		bcs $d842	                bcs _failed
.d83f	38		sec		                sec
.d840	80 01		bra $d843	                bra _done
.d842					_failed:
.d842	18		clc		                clc
.d843					_done:
.d843	60		rts		                rts
.d844					underflow_1:
.d844	e0 77		cpx #$77	                cpx #dsp0-1
.d846	10 10		bpl $d858	                bpl underflow_error
.d848	60		rts		                rts
.d849					underflow_2:
.d849	e0 75		cpx #$75	                cpx #dsp0-3
.d84b	10 0b		bpl $d858	                bpl underflow_error
.d84d	60		rts		                rts
.d84e					underflow_3:
.d84e	e0 73		cpx #$73	                cpx #dsp0-5
.d850	10 06		bpl $d858	                bpl underflow_error
.d852	60		rts		                rts
.d853					underflow_4:
.d853	e0 71		cpx #$71	                cpx #dsp0-7
.d855	10 01		bpl $d858	                bpl underflow_error
.d857	60		rts		                rts
.d858					underflow_error:
.d858	a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d85a					error:
.d85a	48		pha		                pha                     ; save error
.d85b	20 9a d8	jsr $d89a	                jsr print_error
.d85e	20 80 89	jsr $8980	                jsr xt_cr
.d861	68		pla		                pla
.d862	c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d864	d0 17		bne $d87d	                bne _no_underflow
.d866	a9 0d		lda #$0d	                lda #err_returnstack
.d868	20 9a d8	jsr $d89a	                jsr print_error
.d86b	ba		tsx		                tsx
.d86c					-
.d86c	e8		inx		                inx
.d86d	f0 0b		beq $d87a	                beq +
.d86f	20 f9 a0	jsr $a0f9	                jsr xt_space
.d872	bd 00 01	lda $0100,x	                lda $100,x
.d875	20 54 d7	jsr $d754	                jsr byte_to_ascii
.d878	80 f2		bra $d86c	                bra -
.d87a					+
.d87a	20 80 89	jsr $8980	                jsr xt_cr
.d87d					_no_underflow:
.d87d	4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d880					print_string_no_lf:
.d880	0a		asl a		                asl
.d881	a8		tay		                tay
.d882	b9 da d3	lda $d3da,y	                lda string_table,y
.d885	85 28		sta $28		                sta tmp3                ; LSB
.d887	c8		iny		                iny
.d888	b9 da d3	lda $d3da,y	                lda string_table,y
.d88b	85 29		sta $29		                sta tmp3+1              ; MSB
.d88d					print_common:
.d88d	a0 00		ldy #$00	                ldy #0
.d88f					_loop:
.d88f	b1 28		lda ($28),y	                lda (tmp3),y
.d891	f0 06		beq $d899	                beq _done               ; strings are zero-terminated
.d893	20 ff 8d	jsr $8dff	                jsr emit_a              ; allows vectoring via output
.d896	c8		iny		                iny
.d897	80 f6		bra $d88f	                bra _loop
.d899					_done:
.d899	60		rts		                rts
.d89a					print_error:
.d89a	0a		asl a		                asl
.d89b	a8		tay		                tay
.d89c	b9 af d4	lda $d4af,y	                lda error_table,y
.d89f	85 28		sta $28		                sta tmp3                ; LSB
.d8a1	c8		iny		                iny
.d8a2	b9 af d4	lda $d4af,y	                lda error_table,y
.d8a5	85 29		sta $29		                sta tmp3+1              ; MSB
.d8a7	20 8d d8	jsr $d88d	                jsr print_common
.d8aa	60		rts		                rts
.d8ab					print_string:
.d8ab	20 80 d8	jsr $d880	                jsr print_string_no_lf
.d8ae	4c 80 89	jmp $8980	                jmp xt_cr               ; JSR/RTS because never compiled
.d8b1					print_u:
.d8b1	20 83 a7	jsr $a783	                jsr xt_zero                     ; 0
.d8b4	20 61 93	jsr $9361	                jsr xt_less_number_sign         ; <#
.d8b7	20 e8 97	jsr $97e8	                jsr xt_number_sign_s            ; #S
.d8ba	20 c6 97	jsr $97c6	                jsr xt_number_sign_greater      ; #>
.d8bd	4c de a4	jmp $a4de	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp forth
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034	74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044	6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054	28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
