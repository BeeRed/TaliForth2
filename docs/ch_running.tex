% Chapter Running Tali Forth
% Scot W. Stevenson

\begin{quote}
	One doesn't write programs in Forth. Forth is the program.
\end{quote}
\begin{flushright}
        -- Charles Moore,\index{Moore, Charles} \textit{Masterminds of Programming}\cite{biancuzzi09}
\end{flushright}

\section{Available words}

Tali Forth comes with the following Forth words\index{Forth words} out of the
box:

\begin{lstlisting}[frame=lines]
        see within to d.r d. ud.r ud. .r u.r */mod */ mod /mod /
        action-of is defer@ defer! while until repeat else then
        if .( ( drop dup swap ! @ over >r r> r@ nip rot -rot tuck
        , c@ c! +! execute emit type . u. ? false true space 0 1
        2 2dup ?dup + - abs dabs and or xor rshift lshift pick char
        [char] char+ chars cells cell+ here 1- 1+ 2* = <> < > 0=
        0<> 0> 0< min max 2drop 2swap 2over 2variable 2r@ 2r> 2>r
        invert negate dnegate c, bounds spaces bl -trailing /string
        refill accept unused depth key allot create does> variable
        constant value s>d d>s d- d+ erase blank fill find-name '
        ['] name>int int>name name>string >body defer latestxt
        latestnt parse-name parse source source-id : ; compile, [ ]
        0branch branch literal sliteral ." s" postpone immediate
        compile-only never-native always-native nc-limit abort
        abort" do ?do i j loop +loop exit unloop leave recurse quit
        begin again state evaluate base digit? number >number hex
        decimal count m* um* * um/mod ud/mod sm/rem fm/mod \ move
        cmove> cmove pad >in <# # #s #> hold sign output input cr
        page at-xy marker words wordsize aligned align bell dump .s
        find word cold bye
\end{lstlisting}

(Call \texttt{words}\index{words@\texttt{words}} in Tali Forth for the current
list.)

Though the list might look unsorted, it actually reflects the priority in the
dictionary\index{dictionary}, that is, which words are found first. For
instance, the native words\index{native words} -- those coded in assembler --
start with \texttt{drop}\index{drop@\texttt{drop}}
\texttt{bye}\index{bye@\texttt{bye}}, which is the last word that Tali Forth
will find.\footnote{If you're going to quit, speed can't be that important} The
words before \texttt{drop} are those that are defined in high-level Forth. For
more information on the words, use the \texttt{see}\index{see@\texttt{see}}
command.

\section{Native compiling}\index{compiling, native|textbf}

In a pure subroutine threaded code, higher-level words are merely a series of
subroutine jumps. For instance, the Forth word
\texttt{[char]}\index{[char]@\texttt{[char]}}, formally defined in high-level
Forth as

\begin{lstlisting}[frame=lines]
        : [char] char postpone literal ; immediate
\end{lstlisting}

\noindent in assembler is simply

\begin{lstlisting}[frame=lines]
                jsr xt_char
                jsr xt_literal
\end{lstlisting}

\noindent as an immediate, compile-only word. Theare are two obvious problems
with this method: First, it is slow, because each \texttt{jsr/rts} pair consumes
four bytes and 12 cycles overhead. Second, for smaller words, the jumps use far
more bytes than the actual code. Take for instance
\texttt{drop}\index{drop@\texttt{drop}}, which in its naive form is simply

\begin{lstlisting}[frame=lines]
                inx
                inx
\end{lstlisting}

\noindent for two bytes and four cycles. If we jump to this word as is assumed
with pure subroutine threaded Forth, we add four bytes and 12 cycles -- double
the space and three times the time required by the actual working code. (In
practice, it's even worse, because \texttt{drop} checks for
underflow\index{underflow}. The actual assembler code is

\begin{lstlisting}[frame=lines]
                cpx #dsp0-1
                bmi +
                lda #11         ; error code for underflow
                jmp error
*
                inx
                inx
\end{lstlisting}

\noindent for eleven bytes. We'll discuss the underflow checks further below.)

To get rid of this problem, Tali Forth supports \textbf{native
compiling}\index{compiling, native}. The system variable
\texttt{nc-limit}\index{nc-limit@\texttt{nc-limit}} sets
the threshhold up to which a word will be included not as a subroutine jump, but
machine language. Let's start with an example where \texttt{nc-limit} is set to
zero, that is, all words are compiled as subroutine jumps. Take a simple word
such as

\begin{lstlisting}[frame=lines]
        : aaa 0 drop ;
\end{lstlisting}

\noindent and check the actual code with \texttt{see}\index{see@\texttt{see}}

\begin{lstlisting}[frame=lines]
        see aaa
          nt: 7CD  xt: 7D8
         size (decimal): 6

        07D8  20 52 99 20 6B 88  ok
\end{lstlisting}

\noindent (The actual addresses might be different, this is from the ALPHA release).  Our
word \texttt{aaa} consists of two subroutine jumps, one to zero and one to
\texttt{drop}. Now, if we increase the threshhold to 20, we get different code,
as this console session shows:

\begin{lstlisting}[frame=lines]
        20 nc-limit !  ok
        : bbb 0 drop ;  ok
        see bbb
          nt: 7DF  xt: 7EA
         size (decimal): 17

        07EA  CA CA 74 00 74 01 E0 77  30 05 A9 0B 4C C7 AC E8
        07FA  E8  ok
\end{lstlisting}

\noindent Even though the definition of \texttt{bbb} is the same as \texttt{aaa}, we have
totally different code: The number 0001 is pushed to the Data Stack (the first
six bytes), then we check for underflow\index{underflow} (the next nine bytes),
and finally we \texttt{drop} by moving X\index{X register}, the Data Stack
Pointer. Our word is definitely longer, but have just saved 12 cycles.

To experiment with various parameters for native compiling, the Forth word
\texttt{words\&sizes} is included in \texttt{user\_words.fs} (but commented out 
by default). The Forth is:

\begin{lstlisting}[frame=lines]
: words&sizes ( --)
        latestnt
        begin
                dup
        0<> while
                dup name>string type space
                dup wordsize u. cr      
                2 + @
        repeat
        drop ;
\end{lstlisting}

\noindent Changing \texttt{nc-limit} should show differences in the Forth words.



\section{Underflow stripping}\index{underflow!detection}

Checking for underflow helps during the design and debug phases of writing Forth
code, but once it ready to ship, those nine bytes per check hurt, as we see in
the case above. To allow those checks to be stripped, we can set the system
variable \texttt{uf-strip} to \texttt{true}.




% -------------------------------------

\section{Gotchas}

Tali has a 16-bit cell size (use \texttt{1 cells 8 \* .} to get the cells size in
bits with any Forth), which can trip up calculations when compared to the
\textit{de facto} standard Gforth\index{Gforth} with 64 bits. Take this example:

\begin{lstlisting}[frame=lines]
( Gforth )      decimal 1000 100 um* hex swap u. u.  186a0 0  ok
( Tali Forth)   decimal 1000 100 um* hex swap u. u.  86a0 1  ok
\end{lstlisting}

\noindent Tali has to use the upper cell of a double-celled\index{double cell}
number to correctly report the result, while Gforth doesn't. If the conversion
from double to single is only via a \texttt{drop} instruction, this will produce
different results.


% -------------------------------------

\section{Reporting a problem}\index{feedback|textbf}\index{bugs}

The best way to point out a bug or make any other form of a comment is on Tali
Forth's page on GitHub\index{GitHub} at
\href{https://github.com/scotws/TaliForth2}{https://github.com/scotws/TaliForth2}.
There, you can `open an issue', which allows other people who might have the
same problem to help even when the author is not available.



