% Chapter Running Tali Forth
% Scot W. Stevenson

\section{Native compiling}\index{compiling, native|textbf}

In a pure subroutine threaded code, higher-level words are merely a series of
subroutine jumps. For instance, the Forth word
\texttt{[char]}\index{[char]@\texttt{[char]}}, formally defined in high-level
Forth as

\begin{lstlisting}[frame=single]
        : [char] char postpone literal ; immediate
\end{lstlisting}

\noindent in assembler is simply

\begin{lstlisting}[frame=single]
                jsr xt_char
                jsr xt_literal
\end{lstlisting}

\noindent as an immediate, compile-only word. Theare are two obvious problems
with this method: First, it is slow, because each \texttt{jsr/rts} pair consumes
four bytes and 12 cycles overhead. Second, for smaller words, the jumps use far
more bytes than the actual code. Take for instance
\texttt{drop}\index{drop@\texttt{drop}}, which in its naive form is simply

\begin{lstlisting}[frame=single]
                inx
                inx
\end{lstlisting}

\noindent for two bytes and four cycles. If we jump to this word as is assumed
with pure subroutine threaded Forth, we add four bytes and 12 cycles -- double
the space and three times the time required by the actual working code. (In
practice, it's even worse, because \texttt{drop} checks for
underflow\index{underflow}. The actual assembler code is

\begin{lstlisting}[frame=single]
                cpx #dsp0-1
                bmi +
                lda #11         ; error code for underflow
                jmp error
*
                inx
                inx
\end{lstlisting}

\noindent for eleven bytes. We'll discuss the underflow checks further below.)

To get rid of this problem, Tali Forth supports \textbf{native
compiling}\index{compiling, native}. The system variable
\texttt{nc-limit}\index{nc-limit@\texttt{nc-limit}} sets
the threshhold up to which a word will be included not as a subroutine jump, but
machine language. Let's start with an example where \texttt{nc-limit} is set to
zero, that is, all words are compiled as subroutine jumps. Take a simple word
such as

\begin{lstlisting}[frame=single]
        : aaa 0 drop ;
\end{lstlisting}

\noindent and check the actual code with \texttt{see}\index{see@\texttt{see}}

\begin{lstlisting}[frame=single]
        see aaa
          nt: 7CD  xt: 7D8
         size (decimal): 6

        07D8  20 52 99 20 6B 88  ok
\end{lstlisting}

\noindent (The actual addresses might be different, this is from the ALPHA release).  Our
word \texttt{aaa} consists of two subroutine jumps, one to zero and one to
\texttt{drop}. Now, if we increase the threshhold to 20, we get different code,
as this console session shows:

\begin{lstlisting}[frame=single]
        20 nc-limit !  ok
        : bbb 0 drop ;  ok
        see bbb
          nt: 7DF  xt: 7EA
         size (decimal): 17

        07EA  CA CA 74 00 74 01 E0 77  30 05 A9 0B 4C C7 AC E8
        07FA  E8  ok
\end{lstlisting}

\noindent Even though the definition of \texttt{bbb} is the same as \texttt{aaa}, we have
totally different code: The number 0001 is pushed to the Data Stack (the first
six bytes), then we check for underflow\index{underflow} (the next nine bytes),
and finally we \texttt{drop} by moving X\index{X register}, the Data Stack
Pointer. Our word is definitely longer, but have just saved 12 cycles.

To experiment with various parameters for native compiling, the Forth word
\texttt{words\&sizes} is included in \texttt{user\_words.fs} (but commented out 
by default). The Forth is:

\begin{lstlisting}[frame=single]
: words&sizes ( --)
        latestnt
        begin
                dup
        0<> while
                dup name>string type space
                dup wordsize u. cr      
                2 + @
        repeat
        drop ;
\end{lstlisting}

\noindent Changing \texttt{nc-limit} should show differences in the Forth words.



\section{Underflow stripping}\index{underflow!detection}

Checking for underflow helps during the design and debug phases of writing Forth
code, but once it ready to ship, those nine bytes per check hurt, as we see in
the case above. To allow those checks to be stripped, we can set the system
variable \texttt{uf-strip} to \texttt{true}.




% -------------------------------------

\section{Gotchas}

Tali has a 16-bit cell size (use \texttt{1 cells 8 \* .} to get the cells size in
bits with any Forth), which can trip up calculations when compared to the
\textit{de facto} standard Gforth\index{Gforth} with 64 bits. Take this example:

\begin{lstlisting}[frame=single]
( Gforth )      decimal 1000 100 um* hex swap u. u.  186a0 0  ok
( Tali Forth)   decimal 1000 100 um* hex swap u. u.  86a0 1  ok
\end{lstlisting}

\noindent Tali has to use the upper cell of a double-celled\index{double cell}
number to correctly report the result, while Gforth doesn't. If the conversion
from double to single is only via a \texttt{drop} instruction, this will produce
different results.


% -------------------------------------

\section{Reporting a problem}\index{feedback|textbf}\index{bugs}




