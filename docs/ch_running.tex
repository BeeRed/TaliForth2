% Chapter Running Tali Forth
% Scot W. Stevenson

\begin{quote}
	One doesn't write programs in Forth. Forth is the program.
\end{quote}
\begin{flushright}
        -- Charles Moore,\index{Moore, Charles} \textit{Masterminds of Programming}\cite{biancuzzi09}
\end{flushright}


% -------------------------------------------------
\section{Booting}\texttt{booting}

Out of the box, Tali Forth boots a minimal kernel\texttt{kernel}\index{kernel}
to connect to the py65mon\index{py65mon} simulator. By default, this stage ends
with a line such as

\begin{lstlisting}[frame=lines]
        Tali Forth 2 default kernel for py65mon (18. Feb 2018)
\end{lstlisting}

\noindent Tali Forth itself boots next, and after setting up various internal
things, compiles the high level words. This causes a slight delay, depending on
the number and length of these words. As the last step, Forth should spit out a
boot string, something to the effect of

\begin{lstlisting}[frame=lines]
        Tali Forth 2 for the 65c02
        Version ALPHA 07. Mar 2018 
        Copyright 2014-2018 Scot W. Stevenson
        Tali Forth 2 comes with absolutely NO WARRANTY
        Type 'bye' to exit
\end{lstlisting}

\noindent This functions as a primitive self-test. If you have modified the high
level Forth words\index{Forth words} in either \texttt{forth\_words.fs} or
\texttt{user\_words.fs}, the boot process might fail with a variant of the error
message `unknown word'. The built-in, native words should still work.


% -------------------------------------------------
\section{Available words}

Tali Forth comes with the following Forth words\index{Forth words} out of the
box:

\begin{lstlisting}[frame=lines]
        see within to d.r d. ud.r ud. .r u.r */mod */ mod /mod /
        action-of is defer@ defer! while until repeat else then
        if .( ( drop dup swap ! @ over >r r> r@ nip rot -rot tuck
        , c@ c! +! execute emit type . u. ? false true space 0 1
        2 2dup ?dup + - abs dabs and or xor rshift lshift pick char
        [char] char+ chars cells cell+ here 1- 1+ 2* = <> < > 0=
        0<> 0> 0< min max 2drop 2swap 2over 2variable 2r@ 2r> 2>r
        invert negate dnegate c, bounds spaces bl -trailing /string
        refill accept unused depth key allot create does> variable
        constant value s>d d>s d- d+ erase blank fill find-name '
        ['] name>int int>name name>string >body defer latestxt
        latestnt parse-name parse source source-id : ; compile, [ ]
        0branch branch literal sliteral ." s" postpone immediate
        compile-only never-native always-native nc-limit abort
        abort" do ?do i j loop +loop exit unloop leave recurse quit
        begin again state evaluate base digit? number >number hex
        decimal count m* um* * um/mod ud/mod sm/rem fm/mod \ move
        cmove> cmove pad >in <# # #s #> hold sign output input cr
        page at-xy marker words wordsize aligned align bell dump .s
        find word cold bye
\end{lstlisting}

\noindent (Call \texttt{words}\index{words@\texttt{words}} in Tali Forth for the
current list.)

Though the list might look unsorted, it actually reflects the priority in the
dictionary\index{dictionary}, that is, which words are found first. For
instance, the native words\index{native words} -- those coded in assembler --
start with \texttt{drop}\index{drop@\texttt{drop}}
\texttt{bye}\index{bye@\texttt{bye}}, which is the last word that Tali Forth
will find.\footnote{If you're going to quit, speed can't be that important} The
words before \texttt{drop} are those that are defined in high-level Forth. For
more information on the words, use the \texttt{see}\index{see@\texttt{see}}
command.

Note that the built-in words are lower case\index{case!lower}. Newly defined
words can be in any case and will be distinct -- `KASUMI' is a different word
than `Kasumi'.\index{Goto, Kasumi}


\subsection{Standards}

Tali Forth is orientated on ANSI Forth, but (currently) doesn't contain the
complete set of even the core words. Tali also adopted some words from
Gforth\index{Gforth} such as \texttt{bounds}\index{bounds@\texttt{bounds}}. In
practical terms, Tali aims to be a subset of Gforth: If a program runs on Tali,
it should run on Gforth the same way or have a very good reason not to. 

In addition, there are a few words that are specific to Gforth such as 
\texttt{nc-limit}\index{nc-limit@\texttt{nc-limit}}. 

% -------------------------------------------------
\section{Native compiling}\index{compiling!native}

As the name says, subroutine threaded code\index{threading} encodes the words as
a series of subroutine jumps. Because of the overhead caused by these jumps,
this can make the code slow. Therefore, Tali Forth enables `native compiling',
where the machine code from the word itself is included instead of a subroutine
jump. 

The parameter \texttt{nc-limit}\index{nc-limit@\texttt{nc-limit}} sets the limit
of how small words have to be to be natively compiled. To get the current value
(usually 20), check the value of the system variable: 

\begin{lstlisting}[frame=lines]
        nc-limit ?
\end{lstlisting}

\noindent To set a new limit, save the maximal allowed number of bytes in the
machine code like any other Forth variable:

\begin{lstlisting}[frame=lines]
        40 nc-limit !
\end{lstlisting}

To complete turn off native compiling, set this value to zero.


% -------------------------------------------------
\section{Underflow detection}\index{underflow!detection}

When a word tries to access more words on the stack than it is holding, an
`underflow' error occurs. Whereas Tali Forth 1\index{Tali Forth 1} didn't check
for these errors, this version does. 

However, this slows the program down. Because of this, the user can turn off
underflow detection for words that are natively compiled into new words. To do
this, set the system variable
\texttt{uf-strip}\index{uf-strip@\texttt{uf-strip}} to
\texttt{true}\index{true@\texttt{true}}. Note this does not turn off underflow
detection in the built-in words. Also, words with underflow detection which are
not included in new words through native compiling will also retain their tests.


% -------------------------------------
\section{Restarting}

Tali Forth has a non-standard word \texttt{cold}\index{cold@\texttt{cold}} that
resets the system. Note that this doesn't erase any data in memory, but just
moves the pointers back. When in doubt, you might be better off quitting and
restarting completely.


% -------------------------------------
\section{Gotchas}

Tali has a 16-bit cell size (use \texttt{1 cells 8 \* .} to get the cells size in
bits with any Forth), which can trip up calculations when compared to the
\textit{de facto} standard Gforth\index{Gforth} with 64 bits. Take this example:

\begin{lstlisting}[frame=lines]
( Gforth )      decimal 1000 100 um* hex swap u. u.  186a0 0  ok
( Tali Forth)   decimal 1000 100 um* hex swap u. u.  86a0 1  ok
\end{lstlisting}

\noindent Tali has to use the upper cell of a double-celled\index{double cell}
number to correctly report the result, while Gforth doesn't. If the conversion
from double to single is only via a \texttt{drop} instruction, this will produce
different results.


% -------------------------------------

\section{Reporting a problem}\index{feedback|textbf}\index{bugs}

The best way to point out a bug or make any other form of a comment is on Tali
Forth's page on GitHub\index{GitHub} at
\href{https://github.com/scotws/TaliForth2}{https://github.com/scotws/TaliForth2}.
There, you can `open an issue', which allows other people who might have the
same problem to help even when the author is not available.



