% Tests for Forth
% Scot W. Stevenson
% TODO rename examples so letters coincide with themes

Tali Forth 2 operates in a hardware environment that makes built-in
tests\index{testing|textbf} pretty much impossible. The following collection of
Forth snippets provides a basic way of testing at least some party by hand.

For stress testing, the \texttt{user\_words.fs} routines contain routines such as
a Mandelbrot\index{Mandelbrot} program that can be uncommented and run.

% ----------------------------------------
\section{The interpreter}\index{interpreter}

\subsection{\texttt{>in} tests}

From
https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Text-Interpreter.html

\begin{lstlisting}
        : lat ." <foo>" ;
        : flat ." <bar>" >in dup @ 3 - swap ! ; 
\end{lstlisting}

\noindent A simple \texttt{flat} should print \texttt{<bar><foo>}. A bit more complicated:

\begin{lstlisting}
        char & parse jack& type
\end{lstlisting}

\noindent This should print \texttt{jack}.


% ----------------------------------------
\section{Defining words}

\subsection{\texttt{create} and \texttt{does>}}
The simplest test is to redefine \texttt{constant}:

\begin{lstlisting}
        : aaa create , does> @ ; 
\end{lstlisting}


\subsection{\texttt{literal}}

\begin{lstlisting}
        : aaa [ 1 ] literal ;
\end{lstlisting}

\noindent This should put 1 on the Data Stack at run time.


\subsection{\texttt{bracket-tick}}

\begin{lstlisting}
        : aaa ['] words execute ;
\end{lstlisting}

\noindent This should print all words in the dictionary.


\subsection{\texttt{postpone}}

\texttt{postpone} is aord that is complicated to code, but very useful. The
following simple test is from
\href{https://www.forth.com/starting-forth/11-forth-compiler-defining-words/}{\textif{Starting
Forth}}:

\begin{lstlisting}
        : say-hello ." Hello" ; immediate
        : greet postpone say-hello ." I speak Forth" ;
\end{lstlisting}

\noindent Here, \texttt{greet} won't print \texttt{Hello} right away.


\subsection{\texttt{find-name}}

This word walks through the dictionary until it finds the word presented. 

\begin{lstlisting}
        s" words" find-name name>string type
\end{lstlisting}

\noindent should print \texttt{words}


\subsection{\texttt{word} vs \texttt{parse}}

\texttt{word}\index{word@\texttt{word}} was used in ancient Forths and should be
considered obsolete today. The following piece of code shows the differences:

Taken from Conklin \& Rather p. 160

\begin{lstlisting}
        : test1 ( "name" -- )  32 word count type ; 
        : test2 ( "name" -- )  32 parse type ; 
\end{lstlisting}

\noindent Results of calls with `abc' should give identical result if there are no
leading spaces. However, with leading spaces, \texttt{test2} will find an empty string
and abort, then throw an error because ABC will not be found in the dictionary.

% ----------------------------------------
\section{Looping}

The looping constructs are the most complicated parts of Tali Forth. Currently,
we use the Return Stack instead of the more traditional Data Stack as the
mythical Forth `Control Stack'.

\subsection{Basic looping}

Test normal loop:
\begin{lstlisting}
        : aaa 11 1 do i . loop ;        
\end{lstlisting}

\noindent This should simply produce the numbers 1 to 10. Then, break up the
loop over multiple lines because it turns out this can be tricky:

\begin{lstlisting}
        : bbb 11 1 do 
          i . loop ; 
\end{lstlisting}

\noindent Following Gforth\index{Gforth}, we then should test other variants:

\begin{lstlisting}
        : bbb1 -1 0 ?do i . -1 +loop ;
\end{lstlisting}

\noindent This should produce `0 -1', while

\begin{lstlisting}
        : bbb2 0 0 ?do i . -1 +loop ;
\end{lstlisting}

\noindent should print nothing.


\subsection{Looping with \texttt{if}}

Including \texttt{if} in a loop is the ultimate test if everything is correct
with our stack machanics. First, a simple version will do:

\begin{lstlisting}
        : ccc 11 1 do i dup 5 > if . then loop ; 
\end{lstlisting}

\noindent This should produce \texttt{6 7 8 9 10}. The next step is to continue
with some instructions after the \texttt{then} -- this actually revealed a
stupid bug in the ALPHA version of Tali Forth 2.

\begin{lstlisting}
        : ccc 11 1 do i dup 2 = if ." two! " then . loop ;
\end{lstlisting}

\noindent This should print the string right before the number two.

\subsection{Nested loops}

\noindent A simple test of nested loops is found in
\href{https://www.forth.com/starting-forth/6-forth-do-loops/}{\textit{Starting
Forth}}:

\begin{lstlisting}
        : ddd cr 11 1 do
            11 1 do 
                i j * 5 u.r 
            loop cr loop ;
\end{lstlisting}

\noindent This should print a multiplication table from 1x1 to 10x10.

\subsection{\texttt{exit}}

\begin{lstlisting}
        : eee1 true if exit then ." true" ; 
        : eee2 false if exit then ."false" ; 
\end{lstlisting}

\noindent First word should just return with \texttt{ok}, second word prints \texttt{false}.


\subsection{\texttt{unloop}}

\begin{lstlisting}
        : fff 11 1 do i dup 8 = if drop unloop exit then . loop ." Done" ; 
\end{lstlisting}

\noindent should produce \texttt{1 2 3 4 5 6 7} (with no \texttt{Done})


\subsection{\texttt{leave}}

\begin{lstlisting}
        : ggg 11 1 do i dup 8 = if leave then . loop ." Done" drop ; 
\end{lstlisting}

\noindent should produce \texttt{1 2 3 4 5 6 7 Done} (note \texttt{Done} printed)

The Data Stack should be empty after all of these words, check with \texttt{.s}


\subsection{\texttt{recurse}}
\index{recursion}
\index{recurse@\texttt{recurse}}

\begin{lstlisting}
        : hhh ( a b -- gcd ) ?dup if tuck mod recurse then ;
\end{lstlisting}

\noindent Which should produce 16 for 784 48 hhh. 

% Source: 
% [http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm]
% (http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm)

Also, the classic (here from the ANSI Forth documentation):

\begin{lstlisting}
        : factorial ( u -- u ) 
           dup 2 < if drop 1 exit then 
           dup 1- recurse * ;
\end{lstlisting}

\noindent For 5, the result should be 120.


% ----------------------------------------

\section{Math routines}\index{math}

% TODO For examples of interger divsion, see
% [http://www.forth200x.org/documents/html/usage.html#usage:div]


\subsection{\texttt{fm/mod}}
\index{fm/mod@\texttt{fm/mod}|textbf}

\begin{lstlisting}
        : fm swap s>d rot fm/mod swap . . ; 
\end{lstlisting}

\noindent Should give you: 
% TODO convert to table
\begin{lstlisting}
        10 7 --> 3 1
        -10 7 --> 4 -2 
        10 -7 --> -4 -2
        -10 -7 --> -3 1
\end{lstlisting}


\subsection{\texttt{sm/rem}}
\index{sm/rem@\texttt{sm/rem}|textbf}

\begin{lstlisting}
        : sm swap s>d rot sm/rem swap . . ; 
\end{lstlisting}

\noindent Should give you: 
% TODO convert to table
\begin{lstlisting}
        10 7 --> 3 1
        -10 7 --> -3 -1 
        10 -7 --> 3 -1
        -10 -7 --> -3 1
\end{lstlisting}
