; Assembler for Tali Forth 2 
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 07. Nov 2014 (as tasm65c02)
; This version: 13. Dez 2018

; This is the built-in assembler for Tali Forth 2. Once the assembler wordlist
; is established, the opcodes are available as normal Forth words. The format
; is Simpler Assembler Notation (SAN) which separates the opcode completely
; from the operand. In this case, the operand is entered before the opcode in
; the normal postfix Forth notation (for example, "2000 lda.#"). See the
; assembler documenation in the manual for more detail. SAN itself is discussed
; at https://github.com/scotws/SAN.
;
; The code here was originally used in A Typist's Assembler for the 65c02
; (tasm65c02), see https://github.com/scotws/tasm65c02 for the standalone
; version.

; ==========================================================
; MNEMONICS

; The assembler instructions are realized as individual Forth words with
; entries in the assembler wordlist (see header.asm). We pass the opcode in
; A and the total length of the instruction in bytes (1 to 3) in Y. Note an
; alterantive method would be along the lines of
;
;               jsr asm_common
;               .byte $EA, 01
;
; where the asm_common then uses the address on the Return Stack to pick up the
; opcode and the length. Though this uses one byte and one cycle less per
; assembler instruction in these routines, the current version makes up for
; this by simplifying the code of asm_common.

; The routines are organized alphabetically by SAN mnemonic, not by opcode. The
; SAN and traditional mnemonics are listed after the opcode load instruction.
; This list was generated by a Python script in the tools folder, see there
; for more detail

; TODO make sure lower words are BRA not JMP to asm_common

xt_asm_nop:      
                lda #$EA        ; nop / NOP
                ldy #1
                jmp asm_common
z_asm_nop:

xt_asm_lda_h:
                lda #$A9        ; lda.# / LDA #nn
                ldy #2
                jmp asm_common
z_asm_lda_h:

xt_asm_ldx_h:
                lda #$A2        ; ldx.# / LDX #nn
                ldy #2
                jmp asm_common
z_asm_ldx_h:

xt_asm_rts:
                lda #$60        ; rts / RTS
                ldy #1
                jmp asm_common
z_asm_rts:


; ==========================================================
; PSEUDO-INSTRUCTIONS

xt_asm_push_a:
        ; """push-a puts the content of the 65c02 Accumulator on the Forth
        ; data stack as the TOS. This is a convience routine that encodes the
        ; instructions  DEX DEX  STA 0,X  STZ 1,X
        ; """
        ; TODO if we have more than one pseudo-instruction like this, consider
        ; using a common loop for different byte sequences
.scope
                ldy #0
_loop:
                lda _data,y
                cmp #$FF
                beq _done

                jsr cmpl_a      ; does not change Y
                iny
                bra _loop
_done:
z_asm_push_a:
                rts
_data:
        ; We can't use 00 as a terminator because of STA 0,X
        .byte $CA, $CA, $95, 00, $74, $01 
        .byte $FF               ; terminator 
.scend


; ==========================================================
; DIRECTIVES


; ==========================================================
; ASSEMBLER HELPER FUNCTIONS

asm_common:
.scope
        ; """Common routine for all opcodes. We arrive here with the opcode in
        ; A and the total length in bytes of the instruction in Y (1 to 3). We
        ; do not need to check for the correct values because we are coming
        ; from the assembler Dictionary and trust our external test suite.
        ; """
                ; Compile opcode. Note cmpl_a does not use Y
                jsr cmpl_a

                cpy #1          ; One byte means no operand, we're done
                beq _done

                ; We have an operand which must be TOS
                cpx #dsp0-1
                bmi +
                jmp underflow
*
                ; We compile the LSB of TOS as the operand we definitely have
                ; before we even test if this is a two- or three-byte
                ; instruction. Little endian CPU means we store this byte first
                lda 0,x
                jsr cmpl_a

                ; If this is a two-byte instruction, we're done
                cpy #2
                beq _done_drop

                ; This must be a three-byte instruction, get the MSB. 
                lda 1,x
                jsr cmpl_a      ; Fall through to _done_drop

_done_drop:
                inx
                inx             ; Fall through to _done
_done:
                rts             ; Returns to original caller
.scend        

; END
