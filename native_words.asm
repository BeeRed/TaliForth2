; Low-level Forth word routines
; Tali Forth 2 for the 65c02
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 19. Jan 2014
; This version: 18. Feb 2018

; The skeleton for this file was generated by a script, 
; see the tools folder for more information

; This list is ordered alphabetically by the names of the 
; words, not their strings (so "!" is sorted as "store"). However,
; we start off with COLD, ABORT and QUIT as the natural start 
; sequence. Each word two special status line that begins with 
; "; ## " and allows auto-generation of the WORDLIST.md file in the
; docs folder. Status entries are 
;
;       TBA --> fragment --> coded --> tested


; ## COLD ( -- ) "Reset the Forth system"
; ## "cold"  src: Tali Forth  b: TBA  c: TBA  status: fragment
;       """Reset the Forth system. Does not restart the kernel,
;       use the 65c02 reset for that. Flows into ABORT.
;       """
xt_cold:        
                ; Since the default case for Tali is the py65mon emulator, we
                ; have no use for interrupts. If you are going to include
                ; them in your system in any way, you're going to have to
                ; do it from scratch. Sorry.
                sei
                cld
 
                ; Set the OUTPUT vector to the default kernel_putc
                ; We do this really early so we can print error messages
                ; during debugging
                lda #<kernel_putc
                sta output
                lda #>kernel_putc
                sta output+1

                ; set the INPUT vector to the default kernel_getc
                lda #<kernel_getc
                sta input
                lda #>kernel_getc
                sta input+1
     
                ; set the HAVE_KEY vector to the default kernel_getc
                ; TODO see how this works with py65mon
                lda #<kernel_getc
                sta havekey
                lda #>kernel_getc
                sta havekey+1

                ; initialize 65c02 stack (Return Stack)
                ldx #rsp0
                txs

                ; Clear Data Stack. This is repeated in ABORT, but this way we
                ; can load high-level words with EVALUATE
                ldx #dsp0

                ; Start out with radix 10
                lda #10
                sta base
                stz base+1

                ; We start out with smaller words with less than 20 bytes being
                ; natively compiled
                ; TODO TESTING
                lda #00
                sta nc_limit
                stz nc_limit+1
     
                ; The compiler pointer (CP) points to the first free byte
                ; in the Dictionary
                lda #<cp0
                sta cp
                lda #>cp0
                sta cp+1

                lda #<buffer0   ; input buffer
                sta cib
                lda #>buffer0
                sta cib+1 

                stz ciblen      ; input buffer starts empty
                stz ciblen+1

                stz insrc       ; SOURCE-ID is zero (keyboard)
                stz insrc+1

                stz state       ; STATE is zero (interpret mode)
                stz state+1
     
                ; The name token (nt) of DROP is always the first one in the
                ; new Dictionary, so we start off the Dictionary Pointer (DP)
                ; there. Anything that comes after that (with WORDS, before
                ; that) is high-level from Forth
                lda #<dictionary_start
                sta dp
                lda #>dictionary_start
                sta dp+1

                jsr xt_cr

                ; Define high-level words in forth_words.asm via EVALUATE
                dex
                dex
                dex
                dex

                ; start address goes NOS
                lda #<high_level_start
                sta 2,x
                lda #>high_level_start  
                sta 3,x
                
                ; length goes TOS
                lda #<high_level_end
                sec
                sbc #<high_level_start
                sta 0,x

                lda #>high_level_end
                sbc #>high_level_start
                sta 1,x

                jsr xt_evaluate

                ; Define any user words via EVALUATE
                dex
                dex
                dex
                dex
                       
                ; start address goes NOS
                lda #<user_words_start
                sta 2,x
                lda #>user_words_start  
                sta 3,x
                
                ; length goes TOS
                lda #<user_words_end
                sec
                sbc #<user_words_start
                sta 0,x

                lda #>user_words_end
                sbc #>user_words_start
                sta 1,x
 
                jsr xt_evaluate
                
                ; fall through to ABORT


; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
; ## "abort"  src: ANSI core  b: TBA  c: TBA  status: fragment
        ; """Clear Data Stack and continue into QUIT. We can jump here via
        ; subroutine if we want to because we are going to reset the 65c02's
        ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
        ; actually delete the stuff on the Data Stack
        ; """
xt_abort:       ldx #dsp0


; ## QUIT ( -- ) "Reset the input and get new input"
; ## "quit"  src: ANSI core  b: TBA  c: TBA  status: fragment
        ; """Rest the input and start command loop.
        ; """
.scope
xt_quit:        
                ; Clear the Return Stack. This is a little screwed up
                ; because the 65c02 can only set the Return Stack via X,
                ; which is our Data Stack pointer. The ANSI specification
                ; demands, however, that ABORT reset the Data Stack pointer
                txa             ; Save the DSP that we just defined
                ldx #rsp0
                txs
                tax             ; Restore the DSP. Dude, seriously.

                ; make sure instruction pointer is empty
                stz ip
                stz ip+1

                ; SOURCE-ID is zero (keyboard input)
                stz insrc
                stz insrc+1

                ; STATE is zero (interpret, not compile)
                stz state
                stz state+1

_get_line:
                lda #<buffer0   ; input buffer, this is paranoid
                sta cib
                lda #>buffer0
                sta cib+1 

                ; Size of current input buffer (CIB) is zero
                stz ciblen
                stz ciblen+1

                ; accept a line from the current import source
                jsr xt_refill           ; ( -- f ) 

                ; test flag: LSB of TOS
                lda 0,x
                bne _success

                ; If REFILL returned a FALSE flag, something went wrong and we
                ; need to print an error message and reset the machine. We don't
                ; need to save TOS because we're going to clobber it anyway when we
                ; go back to ABORT.
                lda #8                  ; code for error string refill 1
                jmp error 

_success:
                ; Assume we have successfully accepted a string of input from
                ; a source, with address cib and length of input in ciblen. We
                ; arrive here still with the TRUE flag from REFILL as TOS
                inx                     ; drop
                inx
     
                ; make >IN point to begining of buffer
                stz toin 
                stz toin+1 
 
                ; Main compile/execute routine
                jsr interpret

                ; Test for Data Stack underflow. We don't check for
                ; overflow because it is so rare
                cpx #dsp0
                beq _stack_ok
                bcc _stack_ok           ; DSP must always be smaller (!) than DSP0

                lda #11                 ; code for underflow es_underflow
                jmp error

_stack_ok:
                ; Display system prompt if all went well. If we're interpreting,
                ; this is " ok", if we're compiling, it's " compiled"
                lda state
                bne _compiled

                lda #0                  ; number for "ok" string
                bra _print
_compiled:
                lda #1                  ; number for "compiled" string
_print:
                jsr print_string

                ; Awesome line, everybody! Now get the next one
                bra _get_line

z_cold:         
z_abort:        
z_quit:         ; no RTS required
.scend


; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, MESSAGE with message"
; ## "abort""  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_abort_quote:
                ; save the string
                jsr xt_s_quote 

                ; compile run-time part
                lda #>abort_quote_runtime       ; MSB
                pha
                lda #<abort_quote_runtime       ; LSB
                pha
                jsr cmpl_subroutine

                rts

z_abort_quote:  
.scend

abort_quote_runtime:
        ; """Runtime aspect of ABORT_QUOTE
        ; """
.scope
                ; We arrive here with ( f addr u )                
                lda 4,x
                ora 5,x
                beq _done       ; if FALSE, we're done

                ; We're true, so print string and ABORT
                jsr xt_type
                jmp xt_abort    ; not JSR, so never come back
_done:
                ; Drop three entries from the Data Stack
                txa
                clc
                adc #6
                tax

                rts
.scend



; ## ABS ( n -- u ) "Return absolute value of a number"
; ## "abs"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_abs:         
                cpx #dsp0-1
                bmi +
                lda #11
                jmp error
*
                lda 1,x 
                bpl _done       ; positive number, easy money!

                ; negative: calculate 0 - n
                sec
                lda #0
                sbc 0,x         ; LSB
                sta 0,x

                lda #0          ; MSB
                sbc 1,x
                sta 1,x

_done:
z_abs:          rts
.scend


; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
; ## "accept"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """ Receive a string of at most n1 characters, placing them at
        ; addr. Return the actual number of characters as n2. Characters
        ; are echoed as they are received. ACCEPT is called by REFILL in
        ; modern Forths. This version accepts 255 chars max in the 
        ; current implementation
        ; """
.scope
xt_accept:
                cpx #dsp0-3
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; Abort if we were asked to receive 0 chars 
                lda 0,x
                ora 1,x
                bne _not_zero
     
                ; yes, we were, so return 0
                inx
                inx
                stz 0,x
                stz 1,x

                bra _done       ; no RTS so we can native compile

_not_zero:
                lda 0,x         ; number of chars to get in tmp2 ...
                sta tmp2
                stz tmp2+1      ; ... but we only accept max 255 chars

                lda 2,x         ; address of buffer is NOS, to tmp1
                sta tmp1 
                lda 3,x
                sta tmp1+1

                inx
                inx

                ldy #0

_loop:
                ; Out of the box, py65mon catches some CTRL sequences such as
                ; CTRL-c. We also don't need to check for CTRL-l because a
                ; vt100 terminal clears the screen automatically. Long-term,
                ; we would like CTRL-p for "previous command"

                ; This is the internal version of KEY without all the mucking
                ; about with the Data Stack while still using the input vector
                jsr key_a

                ; we quit on both line feed and carriage return
                cmp #AscLF     
                beq _eol
                cmp #AscCR
                beq _eol

                ; BS and DEL do the same thing for the moment
                cmp #AscBS     
                beq _bs
                cmp #AscDEL     ; (CTRL-h)
                beq _bs

                ; That's enough for now, echo character. EMIT_A sidesteps
                ; all the fooling around with the Data Stack
                jsr emit_a

                sta (tmp1),y
                iny
                cpy tmp2        ; reached character limit?
                bne _loop       ; fall thru if buffer limit reached

_eol:
                ; REFILL updatess ciblen, we don't need to do it here
                sty 0,x         ; Y contains number of chars accepted already
                stz 1,x         ; we only accept 256 chars

                jsr xt_space    ; print final space
                bra _done

_bs:
                cpy #0          ; buffer empty?
                bne +

                lda #AscBELL    ; complain and don't delete beyond the start of line
                jsr emit_a
                iny
*
                dey
                lda #AscBS      ; move back one
                jsr emit_a
                lda #AscSP      ; print a space (rubout) 
                jsr emit_a
                lda #AscBS      ; move back over space
                jsr emit_a

                bra _loop
_done:
z_accept:       rts
.scend


; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
; ## "again"  src: ANSI core ext  b: TBA  c: TBA  status: coded
.scope
xt_again:
                cpx #dsp0-1
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; Add the opcode for a JMP. We use JMP instead of BRA
                ; so we have the range and don't have to calculate the
                ; offset.
                ldy #0
                lda #$4c        ; JMP
                sta (cp),y
                iny

                lda 0,x         ; LSB of address
                sta (cp),y
                iny

                lda 1,x         ; MSB of address
                sta (cp),y
                iny

                ; Allot the space we just used
                tya
                clc
                adc cp
                sta cp
                bcc _done
                inc cp+1
_done:
                inx
                inx

z_again:        rts
.scend


; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
; ## "align"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """On a 8-bit machine, this does nothing. ALIGNED uses
        ; this routine as well"""
.scope
xt_align:
z_align:        rts             ; stripped out during native compile
.scend


; ## ALLOT ( n -- ) "Reserve or release memory"
; ## "allot"  src: ANSI core  b: TBA  c: TBA  status: tested
        ; """Reserve a certain number of bytes (not cells) or release them.
        ; If n = 0, do nothing. If n is negative, release n bytes, but only
        ; to the beginning of the Dictionary. If n is positive (the most
        ; common case), reserve n bytes, but not past the end of the 
        ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
        ; """
        ; TODO see what to do with the Dictionary Pointer (dp) memory is
        ; released to the beginning of the Dictionary
.scope
xt_allot:       
                cpx #dsp0-1
                bmi +
                lda #11                 ; underflow
                jmp error
*
                ; if we were given a zero, forget the whole thing
                lda 0,x
                ora 1,x
                beq _done

                ; if we have a positive value, reserve space
                lda 1,x
                bmi _negative

                ; add positiv value
                clc
                lda 0,x
                adc cp
                sta cp

                lda 1,x
                adc cp+1
                sta cp+1

                ; make sure we haven't granted more than we have
                sec
                lda #<cp_end            
                sbc cp                  ; only need the carry
                lda #>cp_end
                sbc cp+1
                bpl _done               ; we're good

                ; we're not good, so we fail hard. This is going to be rare,
                ; and so it's not worth keeping the old values around to
                ; restore them. Instead, we reserve max memory
                lda #<cp_end
                sta cp
                lda #>cp_end
                sta cp+1

                lda #1                  ; error code for ALLOT
                jmp error
_negative:
                ; we were given a negative value, release space
                clc
                lda cp
                adc 0,x
                sta cp

                lda cp+1
                adc 1,x
                sta cp+1

                ; Free at most to the beginning of the Dictionary space. Note
                ; this completely destroys the user's Dictionary. Currently,
                ; this leaves the Dictionary Pointer dangling, so this is probably
                ; not the best solution
                ; TODO find the best solution
                sec
                lda #<cp0
                sbc cp                  ; only need carry
                lda #>cp0
                sbc cp+1
                bmi _done               ; CP still > than CP0, we're good

                ; we're totally not good, set CP to CP0
                lda #<cp0
                sta cp
                lda #>cp0
                sta cp+1                ; drop through to _done

_done:          inx
                inx

z_allot:        rts
.scend


; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
; ## "never-compile"  src: Tali Forth  b: TBA  c: TBA  status: coded
xt_always_native:
                ldy #1          ; offset for status byte
                lda (dp),y
                ora #AN         ; make sure flag is set
                sta (dp),y
z_always_native:
                rts


; ## AND ( n n -- n ) "Logically AND TOS and NOS"
; ## "and"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_and:         
                cpx #dsp0-3
                bmi +
                lda #11                 ; underflow
                jmp error
*
                lda 0,x
                and 2,x
                sta 2,x

                lda 1,x
                and 3,x
                sta 3,x

                inx
                inx

z_and:          rts


; ## AT_XY ( n m -- ) "Move cursor to position given"
; ## "at-xy"  src: ANSI facility  b: TBA  c: TBA  status: TBA
        ; """On an ANSI compatible terminal, place cursor at row n colum m. 
        ; Code is ESC[<n>;<m>H Do not use U. to print the numbers because the 
        ; trailing space will not work with xterm 
        ; """
xt_at_xy:       
                cpx #dsp0-3
                bmi +
                lda #11                 ; underflow
                jmp error
*
                lda #AscESC
                jsr emit_a
                lda #$5B        ; ASCII for "["
                jsr emit_a
                lda 3,x         ; n (x) is in MSB
                jsr byte_to_ascii
                lda #$3B        ; ASCII for ";"
                jsr emit_a
                lda 1,x         ; m (y) is in LSB
                jsr byte_to_ascii
                lda #'H         ; for Mac OS X 
                jsr emit_a

                inx             ; 2DROP
                inx
                inx
                inx
        
z_at_xy:        rts


; ## BACKSLASH ( -- ) "Ignore rest of line"
; ## "\"  src: ANSI core ext  b: 8  c: TBA  status: coded
xt_backslash:   
                lda ciblen
                sta toin
                lda ciblen+1
                sta toin+1

z_backslash:    rts


; ## BASE ( -- addr ) "Push address of radix base to stack"
; ## "base"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_base:        
                dex
                dex
                lda #<base
                sta 0,x
                lda #>base      ; paranoid, should always be zero
                sta 1,x

z_base:         rts


; ## BEGIN ( -- addr ) "Mark entry point for loop"
; ## "begin"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """This is just an immediate version of here which
        ; could just as welle be coded as
        ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
        ; but we code it in assembler for speed
        ; """
.scope
xt_begin:
                dex
                dex
                lda cp
                sta 0,x
                lda cp+1
                sta 1,x

z_begin:        rts
.scend


; ## BELL ( -- ) "Emit ASCII BELL"
; ## "bell"  src: Tali Forth  b: TBA  c: TBA  status: tested
xt_bell:        
                lda #7          ; ASCII value for BELl
                jsr emit_a

z_bell:         rts


; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
; ## "bl"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_bl:          
                dex
                dex
                lda #AscSP
                sta 0,x
                stz 1,x

z_bl:           rts
.scend


; ## BOUNDS ( addr u -- addr+u addr ) "<TBA>"
; ## "bounds"  src: Gforth  b: TBA  c: TBA  status: coded
        ; """Given a string, return the correct Data Stack parameters for
        ; a DO/LOOP loop; over its characters. This is realized as
        ; OVER + SWAP in Forth, but we do it a lot faster in assembler
        ; """
xt_bounds:
                cpx #dsp0-3
                bmi +
                lda #11                 ; underflow
                jmp error
*
                ; save the string length
                lda 0,x
                sta tmp1
                lda 1,x
                sta tmp1+1

                ; copy address to TOS. Start with MSB so we save a few
                ; bytes in the last step
                lda 3,x         ; MSB
                sta 1,x
                lda 2,x         ; LSB
                sta 0,x

                ; add string length to address. LSB of address already
                ; in A
                clc
                adc tmp1        ; LSB
                sta 2,x

                lda 3,x         ; MSB
                adc tmp1+1
                sta 3,x
                
z_bounds:       rts


; ## BRACKET_CHAR ( "c" -- ) "Compile character"
; ## "[char]"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Compile the ASCII value of a character as a literal. This is an
        ; immediate, compile-only word. A definition given in 
        ; http://forth-standard.org/standard/implement is 
        ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
        ; """
xt_bracket_char:
                jsr xt_char
                jsr xt_literal
z_bracket_char: rts


; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
; ## "[']"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_bracket_tick:
                jsr xt_tick
                jsr xt_literal
z_bracket_tick: rts


; ## BRANCH ( -- ) "Always branch"
; ## "branch"  src: Tali Forth  b: TBA  c: TBA  status: closed
        ; """Expects offset in next two bytes. This cannot be natively
        ; compiled because we need the return address provided on the
        ; 65c02 stack by JSR. 
        ; """
.scope
xt_branch:
                ; encode subroutine branch to runtime component
                lda #>branch_runtime    ; MSB first
                pha
                lda #<branch_runtime
                pha
                jsr cmpl_subroutine
                
z_branch:       rts
.scend

branch_runtime:
.scope
                ; The value on the Return Stack determines where to go
                ; to
                pla
                sta tmpbranch
                pla
                sta tmpbranch+1

                ; Note that the address on the 65c02 stack points to the 
                ; last byte of the JSR instruction, not the next byte 
                ; afterwards
                ldy #1
                lda (tmpbranch),y  ; LSB
                sta tmp1
                iny
                lda (tmpbranch),y  ; MSB
                sta tmp1+1

                ; We have to subtract one byte from the address 
                ; given because of the effect of RTS
                lda tmp1
                bne +
                dec tmp1+1
*               dec tmp1

                ; now we can finally push the address to the stack
                lda tmp1+1      ; MSB first
                pha
                lda tmp1        ; LSB on top 
                pha

                rts
.scend


; ## BYE ( -- ) "Break"
; ## "bye"  src: ANSI tools ext  b: TBA  c: TBA  status: coded
.scope
xt_bye:         
                brk
z_bye:          rts             ; never reached
.scend


; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
; ## "c,"  src: ANSI core  b: TBA  c: TBA  status: coded
; TODO make sure we haven't allocated more than we have
.scope
xt_c_comma:     
                lda 0,x
                sta (cp)

                ; increase CP to the next byte
                inc cp
                bne _done
                inc cp+1
_done:
                inx
                inx

z_c_comma:      rts
.scend


; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
; ## "c@"  src: ANSI core  b: 6  c: TBA  status: coded
xt_c_fetch:     
                lda (0,x)
                sta 0,x
                stz 1,x

z_c_fetch:      rts


; ## C_STORE ( c addr -- ) "Store character at address given"
; ## "c!"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_c_store:     
                lda 2,x
                sta (0,x)

                inx
                inx
                inx
                inx

z_c_store:      rts


; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
; ## "cell+"  src: ANSI core  b: TBA  c: TBA  status: TBA
        ; """Add the number of bytes ("address units") that one cell needs.
        ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
        ; """
.scope
xt_cell_plus:
                lda 0,x
                clc
                adc #2
                sta 0,x

                lda 1,x
                adc #0          ; we only need carry
                sta 1,x
                
z_cell_plus:    rts
.scend


; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
; ## "char"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_char:        
                ; get character from string, returns ( addr u )
                jsr xt_parse_name

                ; if we got back a zero, we have a problem 
                lda 0,x
                ora 1,x
                bne _not_empty

                lda #6          ; Code for parsing falue
                jmp error 

_not_empty:
                inx             ; drop number of characters, leave addr 
                inx

                lda (0,x)       ; get character (equivalent to C@) 

                sta 0,x
                stz 1,x         ; MSB is always zero 

z_char:         rts
.scend


; ## CHARS ( n -- n ) "Number of bytes that n chars need"
; ## "chars"  src: ANSI core  b: 0  c: TBA  status: tested
        ; """Return how many address units n chars are. Since this is an 8 bit
        ; machine, this does absolutely nothing and is included for
        ; compatibility with other Forth versions
        ; """
.scope
xt_chars:
                ; Even if this does nothing, we catch underflows for
                ; stability
                cpx #dsp0-1
                bmi +
                lda #11         ; underflow
                jmp error
*
z_chars:        rts
.scend


; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
; ## "cmove"  src: ANSI string  b: TBA  c: TBA  status: coded
        ; """Copy u bytes from addr1 to addr2, going low to high (addr2 is
        ; larger than addr1). Based on code in Leventhal, Lance A. 
        ; "6502 Assembly Language Routines", p. 201
        ; """
.scope
xt_cmove:
                cpx #dsp0-5
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; abort if number of bytes to move is zero 
                lda 0,x
                ora 1,x
                beq _abort

                ; move addresses to where we can work with them 
                lda 0,x
                sta tmptos
                lda 1,x
                sta tmptos+1

                lda 2,x
                sta tmp2        ; use tmp2 because easier to remember
                lda 3,x
                sta tmp2+1

                lda 4,x
                sta tmp1        ; use tmp1 because easier to remember 
                lda 5,x
                sta tmp1+1

                phx             ; we'll need all the registers we have 

                ldy #0
                ldx tmptos+1    ; number of pages to move 
                beq _dopartial
_page:          
                lda (tmp1),y
                sta (tmp2),y
                iny
                bne _page

                inc tmp1+1
                inc tmp2+1
                dex
                bne _page
_dopartial:     
                ldx tmptos      ; length of last page
                beq _done
_partial:       
                lda (tmp1),y
                sta (tmp2),y
                iny
    
                dex
                bne _partial

_done:          plx             ; drops through to _abort

_abort:         ; clear the stack  
                txa
                clc
                adc #6
                tax

z_cmove:        rts
.scend


; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
; ## "cmove>"  src: ANSI string  b: TBA  c: TBA  status: coded
        ; """Note addr1 is larger than ; ; addr2). Based on code in
        ; Leventhal, Lance A. "6502 Assembly Language Routines", p. 201.
        ; """
.scope
xt_cmove_up:
                cpx #dsp0-5
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; abort if number of bytes to move is zero 
                lda 0,x
                ora 1,x
                beq _abort

                ; move addresses to where we can work with them 
                lda 0,x
                sta tmptos
                lda 1,x
                sta tmptos+1

                lda 2,x
                sta tmp2        ; use tmp2 because easier to remember
                lda 3,x
                sta tmp2+1

                lda 4,x
                sta tmp1        ; use tmp1 because easier to remember 
                lda 5,x
                sta tmp1+1

                phx             ; we'll need all the registers we have 

                ; move partial page first 
                lda tmptos+1
                clc
                adc tmp1+1
                sta tmp1+1      ; point to last page of source 

                lda tmptos+1
                clc
                adc tmp2+1
                sta tmp2+1      ; point to last page of destination 

                ; move the last partial page first
                ldy tmptos      ; length of last page
                beq _fullpage
_partial:       
                dey
                lda (tmp1),y
                sta (tmp2),y
                cpy #0
                bne _partial
_fullpage:      
                ; use the MSB of counter as our page counter 
                ldx tmptos+1    ; X is safe on the stack 
                beq _done
_outerloop:     
                dec tmp1+1   ; back up to previous pages 
                dec tmp2+1
_innerloop:     
                dey
                lda (tmp1),y
                sta (tmp2),y
                cpy #$00
                bne _innerloop

                dex
                bne _outerloop
_done:          
                plx             ; drops through to _abort 
_abort:         
                ; clear up the stack and leave 
                txa
                clc
                adc #6
                tax
               
z_cmove_up:     rts
.scend


; ## COLON ( "name" -- ) "Start compilation of a new word""
; ## ":"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Use the CREATE routine and fill in the rest by hand.
        ; """
.scope
xt_colon:       
                ; if we're already in the compile state, complain
                ; and quit
                lda state
                ora state+1
                beq +

                lda #10         ; "already in compile mode"
                jmp error
*
                ; switch to compile state
                dec state
                dec state+1

                ; CREATE is going to change DP to point to the new word's
                ; header. While this is fine for (say) variables, it would mean
                ; that FIND-NAME etc would find a half-finished word when
                ; looking in the Dictionary. To prevent this, we save the old
                ; version of DP and restore it later. The new DP is placed in
                ; the variable WORKWORD until we're finished with a SEMICOLON.
                lda dp+1        ; CREATE uses lots of tmp variables
                pha
                lda dp
                pha

                jsr xt_create

                ; Get the nt (not the xt!) of the new word as described above.
                ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
                lda dp
                sta workword
                lda dp+1
                sta workword+1

                pla
                sta dp
                pla
                sta dp+1

                ; CREATE includes a subroutine jump to DOVAR by default. We
                ; back up three bytes and overwrite that.
                lda cp
                sec
                sbc #3
                sta cp
                bcs _done
                dec cp+1
_done:
z_colon:        rts
.scend


; ## COMMA ( n -- ) "Allot and store one cell in memory"
; ## ","  src: ANSI core  b: 22  c: TBA  status: coded
        ; """Store TOS at current place in memory. Since this an eight-bit
        ; machine, we can ignore all alignment issures
        ; """
.scope
xt_comma:
                cpx #dsp0-1
                bne +
                lda #11         ; underflow
                jmp error
*
                lda 0,x
                sta (cp)

                inc cp
                bne +
                inc cp+1
*
                lda 1,x
                sta (cp)

                inc cp
                bne _done
                inc cp+1
_done:
                inx
                inx
       
z_comma:        rts
.scend


; ## COMPILE_COMMA ( xt -- ) "Compile xt"
; ## "compile,"  src: ANSI core ext  b: TBA  c: TBA  status: coded
        ; """Compile the given xt in the current word definition. It is an
        ; error if we are not in the compile state. Because we are using
        ; subroutine threading, we can't use , (COMMA) to compile new words
        ; the traditional way. By default, native compiled is allowed, unless
        ; there is a NN (Never Native) flag associated. If not, we use the
        ; value NC_LIMIT (from definitions.tasm) to decide if the code 
        ; is too large to be natively coded: If the size is larger than
        ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
        ; Native) flag is set, the word is always natively compiled
        ; """
.scope
xt_compile_comma:
                ; See if this is an Always Native (AN) word by checking the
                ; AN flag. We need nt for this.

                ; Save a copy of xt to the Return Stack
                lda 1,x                 ; MSB
                pha
                lda 0,x
                pha                     ; LSB

                jsr xt_int_to_name      ; ( xt -- nt )

                ; put nt away for safe keeping
                lda 0,x
                sta tmptos
                lda 1,x
                sta tmptos+1

                ; status byte is one further down
                inc 0,x
                bne +
                inc 1,x                 ; ( nt -- nt+1 )
*
                lda (0,x)
                sta tmp1                ; keep copy of status byte for NN
                and #AN                 ; mask all but Always Native (AN bit
                beq _compile_check

                ; We're natively compiling no matter what. Get length and
                ; compile in code. Get the original nt back
                lda tmptos
                sta 0,x
                lda tmptos+1
                sta 1,x

                jsr xt_wordsize         ; ( nt -- u )

                bra _compile_as_code

_compile_check:
                ; See if Native Compile is even alowed by checking the NN
                ; flag
                lda tmp1
                and #NN
                bne _compile_as_jump

                ; Native compile is a legal option, but we need to see what
                ; limit the user set for size
                lda tmptos
                sta 0,x
                lda tmptos+1
                sta 1,x

                jsr xt_wordsize         ; ( nt -- u )

                ; We implicitly assume that we don't want to compile anything
                ; greater than 255 bytes, so we only deal with LSB
                clc
                cmp nc_limit            ; user-defined limit
                bcs _compile_as_jump    ; if too large, we jump

_compile_as_code:
                ; We arrive here with the length of the word's code TOS and
                ; xt on top of the Return Stack. MOVE will need ( xt cp u )
                ; on the data stack
                dex
                dex                     ; ( -- u ? )
                dex
                dex                     ; ( -- u ? ? ) 

                lda 4,x
                sta 0,x                 ; LSB of u 
                lda 5,x
                sta 1,x                 ; ( -- u ? u )

                pla
                sta 4,x                 ; LSB of xt
                pla
                sta 5,x                 ; ( -- xt ? u )

                lda cp                  ; LSB of cp
                sta 2,x
                lda cp+1
                sta 3,x                 ; ( -- xt cp u )

                ; Store size of area copied for calculation of new CP
                lda 1,x                 ; MSB
                pha
                lda 0,x                 ; LSB
                pha

                ; TODO add special cases:
                ; - strip single NOP
                ; - cut R>, >R, R@
                ; - later: if UF flag set, remove underflow testing

                ; Enough of this, move the bytes already
                jsr xt_move

                ; Update CP
                clc
                pla                     ; LSB
                adc cp
                sta cp

                pla                     ; MSB
                adc cp+1
                sta cp+1

                bra _done
                
_compile_as_jump:
                ; Compile xt as a subroutine jump
                lda #$20
                sta (cp)
                
                ldy #1
                pla             ; LSB
                sta (cp),y
                iny
                pla             ; MSB
                sta (cp),y

                ; allot space we just used
                lda #3
                clc
                adc cp
                sta cp
                bcc +
                inc cp+1
*
                inx             ; drop xt
                inx
_done:                
z_compile_comma:
                rts
.scend


; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
; ## "compile-only"  src: Tali Forth  b: 8  c: TBA  status: coded
        ; """Set the Compile Only flag (CO) of the most recently defined
        ; word. The alternative way to do this is to define a word 
        ; ?COMPILE that makes sure  we're in compile mode
        ; """
.scope
xt_compile_only:
                ldy #1          ; offset for status byte
                lda (dp),y
                ora #CO        ; make sure bit 7 is set
                sta (dp),y
                
z_compile_only: rts
.scend


; ## CONSTANT ( n "name" -- ) "Define a constant"
; ## "constant"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Forth equivalent is  CREATE , DOES> @  but we do
        ; more in assembler and let CREATE do the heavy lifting.
        ; See http://www.bradrodriguez.com/papers/moving3.htm for
        ; a primer on how this works in various Forths.
        ; """
xt_constant:    
                jsr xt_create

                ; CREATE by default installs a subroutine jump to DOVAR,
                ; but we want DOCONST for constants. Go back two bytes and
                ; replace the subroutine jump target
                lda cp
                sbc #2
                sta tmp1
                lda cp+1
                sbc #0
                sta tmp1+1

                lda #<doconst   ; LSB of DOCONST
                sta (tmp1)
                inc tmp1
                bne +
                inc tmp1+1
*
                lda #>doconst   ; MSB of DOCONST
                sta (tmp1)

                ; Now we save the constant number itself in the next cell
                jsr xt_comma            ; drop through to adjust_z

adjust_z:
                ; Now the length of the complete word (z_word) has increased by
                ; two. We need to update that number or else words such as SEE
                ; will ignore the PFA. We use this same routine for VARIABLE,
                ; VALUE and DEFER
                jsr xt_latestnt         ; gives us ( -- nt )

                ; z_word is six bytes further down
                lda 0,x
                clc
                adc #6
                sta tmp1
                lda 1,x
                adc #0          ; only need carry
                sta tmp1+1

                lda (tmp1)
                clc
                adc #2
                sta tmp2
                ldy #1
                lda (tmp1),y
                adc #0          ; only need carry

                tay             ; hold on to MSB while we update target
                inc tmp1
                bne +
                inc tmp1
*               
                tya
                sta (tmp1)
              
                inx
                inx

z_constant:     rts


; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
; ## "count"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """; Convert old-style character string to address-length pair. Note
        ; that the length of the string c-addr ist stored in character length
        ; (8 bit), not cell length (16 bit). This is rarely used these days,
        ; though COUNT can also be used to step through a string character by
        ; character. 
        ; """
xt_count:
                lda (0,x)       ; Get number of characters (255 max)
                tay

                ; move start address up by one 
                inc 0,x         ; LSB
                bne +
                inc 1,x         ; MSB

                ; save number of characters to stack 
*               tya
                dex
                dex
                sta 0,x         ; LSB
                stz 1,x         ; MSB, always zero

z_count:        rts


; ## CR ( -- ) "Print a line feed"
; ## "cr"  src: ANSI core  b: 5  c: TBA  status: tested
xt_cr:         
                lda #AscLF
                jsr emit_a
z_cr:           rts


; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
; ## "create"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """See the drawing in headers.asm for details on the header
        ; """
.scope
xt_create:      
                ; get string
                jsr xt_parse_name       ; ( addr u )

                ; if we were given an empty string, we complain and quit
                lda 0,x
                ora 1,x
                bne _got_name

                lda #6
                jmp error

_got_name:
                ; Enforce maximal length of string by overwriting the MSB of 
                ; the length. There is a possible error here: If the string
                ; is exactly 255 chars long, then a lot of the following
                ; additions will fail because of wrapping
                ; TODO fix this
                stz 1,x

                lda 0,x
                sta tmp2                ; store length of string in tmp2
                
                ; remember the first free byte of memory as the start of
                ; the new word
                lda cp
                sta tmp1
                lda cp+1
                sta tmp1+1

                ; we need 8 bytes plus the length of the string for our new header.
                ; This is also the offset for the start of the code field (the
                ; xt_ label) so we need to remember it. Otherwise, we could 
                ; just allot the space afterwards
                lda 0,x
                clc
                adc #8
                sta tmp3                ; total header length

                ; We need three more bytes for for the hardcoded code field
                ; area (CFA), the "payload" of the word which by default will
                ; be a subroutine jump to DOVAR
                clc
                adc #3
                
                ; We overwrite the length of the string returned by PARSE-NAME
                ; and then call ALLOT
                sta 0,x
                stz 1,x         ; max header size is 255 chars
                jsr xt_allot    ; ( addr ) 
                
                ; Now we walk through the header with Y as the index, adding
                ; information byte-by-byte
                ldy #0

                ; HEADER BYTE 0: Length of string
                lda tmp2
                sta (tmp1),y

                ; HEADER BYTE 1: Status byte
                tya                     ; STZ doesn't have "STZ (TMP1),Y"
                iny 
                sta (tmp1),y
                iny

                ; HEADER BYTE 2,3: Next header. This is the current last word
                ; in the Dictionary
                lda dp
                sta (tmp1),y
                iny
                lda dp+1
                sta (tmp1),y
                iny
                
                ; Interlude: Make old CP new DP (new start of Dictionary)
                lda tmp1+1
                sta dp+1
                lda tmp1
                sta dp

                ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
                ; This begins after the header so we take the length of the
                ; header, which we cleverly saved in tmp3, and use it as an
                ; offset to the address of the start of the word. We come here
                ; with tmp1 in A
                clc
                adc tmp3        ; add total header length
                sta (tmp1),y
                pha             ; we need this in the next step
                iny

                lda tmp1+1
                adc #0          ; only need the carry
                sta (tmp1),y
                iny

                ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
                ; we execute a jump to the DOVAR routine, so we need to move three
                ; bytes down, and then one more byte so that the z_ label points
                ; to the (still fictional) RTS instruction for correct compilation
                pla             ; LSB of "z_" address
                clc
                adc #3
                sta (tmp1),y
                
                dey             ; get the MSB of xt back
                lda (tmp1),y
                adc #0          ; only need the carry
                iny
                iny
                sta (tmp1),y
                iny
                
                ; HEADER BYTE 8: Start of name string. The address is TOS, the
                ; length in tmp2. We subtract 8 from the address so we can
                ; use the same loop index, which is already 8 byte ahead at
                ; this point
                lda 0,x
                sec
                sbc #8
                sta tmptos

                lda 1,x
                sbc #0          ; only need carry
                sta tmptos+1

_name_loop:
                lda (tmptos),y
                sta (tmp1),y
                iny
                dec tmp2
                bne _name_loop

                ; After thename string comes the code field, starting at the
                ; current xt of this word, which is initially a jump to the
                ; subroutine to DOVAR. We code this jump by hand
                lda #$20        ; opcode of JSR
                sta (tmp1),y
                iny
                lda #<dovar
                sta (tmp1),y
                iny
                lda #>dovar
                sta (tmp1),y

                ; And we're done. Restore stack
                inx
                inx

z_create:       rts
.scend


; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
; ## "d-"  src: ANSI double  b: TBA  c: TBA  status: coded
.scope
xt_d_minus:
                cpx #dsp0-7
                bmi +
                lda #11         ; underflow
                jmp error
*
                sec

                lda 6,x         ; LSB of lower word
                sbc 2,x
                sta 6,x

                lda 7,x         ; MSB of lower word
                sbc 3,x
                sta 7,x

                lda 4,x         ; LSB of upper word
                sbc 0,x
                sta 4,x

                lda 5,x         ; MSB of upper word
                sbc 1,x
                sta 5,x

                inx
                inx
                inx
                inx

z_d_minus:      rts
.scend


; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
; ## "d+"  src: ANSI double  b: TBA  c: TBA  status: coded
.scope
xt_d_plus:
                cpx #dsp0-7
                bmi +
                lda #11         ; underflow
                jmp error
*
                clc
                lda 2,x         ; LSB of lower word
                adc 6,x
                sta 6,x

                lda 3,x         ; MSB of lower word
                adc 7,x
                sta 7,x

                lda 0,x         ; LSB of upper word
                adc 4,x
                sta 4,x

                lda 1,x         ; MSB of upper word
                adc 5,x
                sta 5,x
                
                inx
                inx
                inx
                inx

z_d_plus:       rts
.scend


; ## D_TO_S ( d -- n ) "Convert a double number to single"
; ## "d>s"  src: ANSI double  b: TBA  c: TBA  status: coded
        ; """Though this is basically just DROP, we keep it
        ; separate so we can test for underflow
        ; """
.scope
xt_d_to_s:      
                cpx #dsp0-3
                bmi +
                lda #11         ; underflow
                jmp error
*
                inx
                inx

z_d_to_s:       rts
.scend


; ## DABS ( d -- d ) "Return the absolute value of a double"
; ## "dabs"  src: ANSI double  b: TBA  c: TBA  status: coded
.scope
xt_dabs:
                lda 1,x         ; MSB of high cell
                bpl _done       ; positive, we get off light

                ; negative, calculate 0 - d
                ldy #0
                sec

                tya
                sbc 2,x         ; LSB of low cell
                sta 2,x

                tya
                sbc 3,x         ; MSB of low cell
                sta 3,x

                tya
                sbc 0,x         ; LSB of high cell
                sta 0,x

                tya
                sbc 1,x         ; MSB of high cell
                sta 1,x
_done:
z_dabs:         rts
.scend


; ## DECIMAL ( -- ) "Change radix base to decimal"
; ## "decimal"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_decimal:     
                lda #10
                sta base
                stz base+1              ; paranoid

z_decimal:      rts


; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
; ## "defer"  src: ANSI core ext  b: TBA  c: TBA  status: coded
        ; """Reserve an name that can be linked to various xt by IS. The
        ; ANSI reference implementation is 
        ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
        ; But we use this routine as a low-level word so things go faster
.scope
xt_defer:
                jsr xt_create

                ; CREATE by default installs a subroutine jump to DOVAR,
                ; but we actually want DODEFER this time. Go back two
                ; bytes and repace the subroutine jump target
                lda cp          ; LSB 
                sec
                sbc #2
                sta tmp1

                lda cp+1        ; MSB
                sbc #0          ; we only care about the borrow
                sta tmp1+1

                ; Save the target address
                ldy #0
                lda #<dodefer   ; LSB
                sta (tmp1),y
                iny
                lda #>dodefer   ; MSB
                sta (tmp1),y


                ; DODEFER executes the next address it finds after
                ; its call. As default, we include the error
                ; "Defer not defined"
                lda #<defer_error
                sta (cp)
                inc cp
                bne +
                inc cp+1
*
                lda #>defer_error
                sta (cp)
                inc cp
                bne +
                inc cp+1
*
                jsr adjust_z    ; adjust header to correct length

z_defer:        rts
.scend


; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
; ## "depth"  src: ANSI core  b: 14  c: TBA  status: coded
xt_depth:       
                lda #dsp0
                stx tmpdsp
                sec
                sbc tmpdsp

                ; divide by two because each cell is two bytes
                lsr

                dex
                dex
                sta 0,x
                stz 1,x

z_depth:        rts


; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
; ## "digit?"  src: Tali Forth  b: TBA  c: TBA  status: coded
        ; """Inspired by the pForth instruction DIGIT, see
        ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
        ; pForth, we get the base (radix) ourselves instead of having the
        ; user provide it. There is no standard name for this routine, which
        ; itself is not ANSI; we use DIGIT? following pForth and Gforth. 
        ; """
.scope
xt_digit_question:
                ; one way or another, we're going to need room for the
                ; flag on the stack
                dex
                dex
                stz 0,x                 ; default flag is failure
                stz 1,x
                stz 3,x                 ; paranoid

                ; Check the character, now in the LSB of NOS. First, make
                ; sure we're not below the ASCII code for "0"
                lda 2,x
                cmp #'0
                bcc _done               ; failure flag already set

                ; Next, see if we are below "9", because that would make
                ; this a normal number
                cmp #'9+1               ; this is actually ":"
                bcc _checkbase

                ; Well, then let's if this is the gap between "9" and "A"
                ; so we can treat the whole range as a number
                cmp #'A-1               ; this is actually "@"
                bcc _done               ; failure flag is already set

                ; probably a letter, so we make sure it is uppercase
                cmp #'a
                bcc _case_done          ; not lower case, too low
                cmp #'z+1
                bcs _case_done          ; not lower case, too high

                clc                     ; just right
                adc #$e0                ; offset to upper case (wraps)

_case_done:
                ; get rid of the gap between "9" and "A" so we can treat
                ; the whole range as one number
                sec
                sbc #7                  ; fall through to _checkbase

_checkbase:
                ; we have a number, now see if it falls inside the range
                ; provided by BASE
                sec
                sbc #'0                 ; this is also the conversion step
                cmp base
                bcs _done               ; already have false flag

                ; Found a legal number
                sta 2,x                 ; put number in NOS
                dec 0,x                 ; set success flag
                dec 1,x

_done:
z_digit_question:
                rts
.scend


; ## DNEGATE ( d -- d ) "Negate double cell number"
; ## "dnegate"  src: ANSI double  b: 33  c: TBA  status: coded
xt_dnegate:     
                lda 2,x         ; LSB of low cell
                eor #$ff
                clc
                adc #1
                sta 2,x

                lda 3,x         ; MSB of low cell
                eor #$ff
                adc #0          ; just need carry
                sta 3,x

                lda 0,x         ; LSB of high cell
                eor #$ff
                adc #0          ; again, just need carry
                sta 0,x

                lda 1,x         ; MSB of high cell
                eor #$ff
                adc #0          ; again, just need carry
                sta 1,x

z_dnegate:      rts


; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
; ## "?do"  src: ANSI core ext  b: TBA  c: TBA  status: coded
xt_question_do:
                ; ?DO shares most of its code with DO. We use the tmp1 flag
                ; to mark which is which
                lda #$ff                ; -1 is ?DO, jump to common code
                sta tmp1
                bra do_common

; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
; ## "do"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Compile-time part of DO. Could be realized in Forth as
        ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
        ; but we do it in assembler for speed. To work with LEAVE, we compile
        ; a routine that pushes the end address to the Return Stack at run
        ; time. This is based on a suggestion by Garth Wilson, see
        ; docs/loops.txt for details. This may not be native compile. Don't
        ; check for a stack underflow
        ; """
.scope
xt_do:
                ; DO and ?DO share most of their code, use tmp1 as a flag.
                stz tmp1                ; 0 is DO, drop through to DO_COMMON
do_common:
                ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
                ; compile the address we need to LDA at runtime
                dex
                dex
                lda cp
                sta 0,x                 ; LSB
                lda cp+1
                sta 1,x                 ; MSB   ( limit start here ) 
                
                ; now we compile six dummy bytes that LOOP/+LOOP will
                ; replace by the actual LDA/PHA instructions
                lda #5                  ; we don't really care about the value 
                tay                     ; so we use 5 to be tricky
_loop:
                sta (CP),y
                dey
                bpl _loop

                ; update CP
                inc             ; we used 5 as a dummy value, this is why 
                clc
                adc CP
                sta CP
                bcc +
                inc CP+1
*
                ; compile the (?DO) portion of ?DO if appropriate
                lda tmp1
                beq _compile_do

                ; We came from ?DO, so compile its runtime first. We do
                ; this with a quick loop because we know it has to be
                ; Always Native anyway
                ldy #question_do_runtime_end-question_do_runtime
                phy             ; save counter to calculate new CP
*
                lda question_do_runtime,y
                sta (cp),y
                dey
                bpl -

                ; adjust CP
                pla             ; retrieve counter
                clc
                adc cp
                sta cp
                lda cp+1
                adc #0          ; only care about carry
                sta cp+1        ; fall through to _compile_do
_compile_do:
                ; compile runtime part of DO. 
                ldy #do_runtime_end-do_runtime  ; counter
                phy             ; save counter to calculate new CP
*
                lda do_runtime,y
                sta (cp),y
                dey
                bpl -

                ; adjust CP
                pla             ; retrieve counter
                clc
                adc cp
                sta cp
                lda cp+1
                adc #0          ; only care about carry
                sta cp+1   

                ; HERE, hardcoded for speed. We put it on the Data Stack
                ; where LOOP/+LOOP takes it from. Note this has nothing to
                ; do with the HERE we're saving for LEAVE
                dex
                dex
                lda CP          ; LSB
                sta 0,x
                lda CP+1        ; MSB
                sta 1,x
z_question_do:                          
z_do:           rts
.scend

do_runtime:
        ; """Runtime routine for DO loop. Note that ANSI loops quit when the
        ; boundry of limit-1 and limit is reached, a different mechanism than
        ; the FIG Forth loop (you can see which version you have by running
        ; a loop with start and limit as the same value, for instance
        ; 0 0 DO -- these will walk through the number space). We use a 
        ; "fudge factor" for the limit that makes the Overflow Flag trip when
        ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026 
        ; for further discussion of this. The source given there for 
        ; this idea is Laxen & Perry F83. -- This routine is called (DO) 
        ; in some Forths. Usually, we would define this as a separate word
        ; and compile it with COMPILE, and the Always Native (AN) flag.
        ; However, we can do it faster if we just copy the bytes
        ; of this routine with a simple loop in DO.
        ; """
                ; First step: create fudge factor (FUFA) by subtracting the
                ; limit from $8000, the number that will trip the overflow
                ; flag
                sec
                lda #0
                sbc 2,x         ; LSB of limit
                sta 2,x         ; save FUFA for later use

                lda #$80
                sbc 3,x         ; MSB of limit
                sta 3,x         ; save FUFA for later use
                pha             ; FUFA replaces limit on R stack
                lda 2,x         ; LSB of limit
                pha

                ; Second step: index is FUFA plus original index
                clc
                lda 0,x         ; LSB of original index
                adc 2,x         ; add LSB of FUFA
                sta 0,x
                lda 1,x         ; MSB of orginal index
                adc 3,x         ; add MSB of FUFA
                pha
                lda 0,x         ; LSB of index
                pha

                ; we've saved the FUFA on the NOS of the R stack, so we can
                ; use it later. Clean the Data Stack
                inx
                inx
                inx
                inx
do_runtime_end:


question_do_runtime:
.scope
        ; """This is called (?DO) in some Forths. See the explanation at
        ; do_runtime for the background on this design
        ; """
                ; see if TOS and NOS are equal. Change this to assembler
                ; for speed
                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
                jsr xt_equal            ; ( -- n1 n2 f ) 

                lda 0,x
                ora 1,x
                beq _do_do

                ; We're equal, so dump everything and jump beyond the loop.
                ; But first, dump six entries off of the Data Stack
                txa
                clc
                adc #6        
                tax

                ; Second, abort the whole loop. We don't have the 
                ; limit/start parameters on the Return Stack yet, just the 
                ; address that points to the end of the loop. Dump the 
                ; RTS of ?DO and then just RTS ourselves
                pla
                pla
                rts
_do_do:         
                inx             ; clear flag from EQUAL off stack
                inx
question_do_runtime_end:
.scend


; ## DOES ( -- ) "Add payload when defining new words"
; ## "does>"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Create the payload for defining new defining words. See
        ; http://www.bradrodriguez.com/papers/moving3.htm and 
        ; docs/create-does.txt for a discussion of
        ; DOES>'s internal workings. This uses tmp1 and tmp2
        ; """
.scope
xt_does:
                ; compile a subroutine jump to runtime of DOES>
                lda #>does_runtime     ; MSB first
                pha
                lda #<does_runtime     ; LSB on top
                pha

                jsr cmpl_subroutine

                ; compile a subroutine jump to DODOES. In traditional
                ; terms, this is the Code Field Area (CFA) of the new
                ; word
                lda #>dodoes            ; MSB first
                pha
                lda #<dodoes            ; LSB on top
                pha
                
                jsr cmpl_subroutine

z_does:         rts
.scend

does_runtime:
        ; """Runtime portion of DOES>. This replaces the subroutine jump
        ; to DOVAR that CREATE automatically encodes by a jump to the
        ; address that contains a subroutine jump to DODOES. We don't
        ; jump to DODOES directly because we need to work our magic with
        ; the return addresses. This routine is also known as "(DOES)" in
        ; other Forths
        ; """
.scope
                ply             ; LSB
                pla             ; MSB

                iny
                bne +
                inc
*
                sty tmp1
                sta tmp1+1

                ; CREATE has also already modified the DP to point to the new
                ; word. We have no idea which instructions followed the CREATE
                ; command if there is a DOES> so the CP could point anywhere
                ; by now. The address of the word's xt is four bytes down.
                lda dp
                clc
                adc #4
                sta tmp2
                lda dp+1
                adc #0          ; we only care about the carry
                sta tmp2+1

                ; Now we get that address and add one byte to skip over the JSR
                ; opcode
                lda (tmp2)
                clc
                adc #1
                sta tmp3
                ldy #1
                lda (tmp2),y
                adc #0          ; we only care about the carry
                sta tmp3+1

                ; Replace the DOVAR address with our own
                lda tmp1        ; LSB
                sta (tmp3)
                lda tmp1+1
                sta (tmp3),y    ; Y is still 1
                
                ; Since we removed the return address that brought us here, we
                ; go back to whatever the main routine was. Otherwise, we we
                ; smash into the subroutine jump to DODOES.
                rts
.scend


; ## DOT ( u -- ) "Print TOS"
; ## "."  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_dot:         
                cpx #dsp0-1
                bmi +

                lda #11         ; underflow
                jmp error
*
                jsr xt_dup                      ; ( n n )
                jsr xt_abs                      ; ( n u )
                jsr xt_zero                     ; ( n u 0 )
                jsr xt_less_number_sign         ; ( n u 0 )
                jsr xt_number_sign_s            ; ( n ud )
                jsr xt_rot                      ; ( ud n )
                jsr xt_sign                     ; ( ud )
                jsr xt_number_sign_greater      ; ( addr u )
                jsr xt_type
                jsr xt_space

z_dot:          rts
.scend

; ## DOT_BYTE ( -- ) "<TBA>"
; ## ".byte"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_dot_byte:    nop
z_dot_byte:     rts
.scend


; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
; ## ".""  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Compile string that is printed during run time. ANSI Forth wants
        ; this to be compile-only, even though everybody and their friend
        ; uses it for everything. We follow the book here, and recommend
        ; .( for general printing
        ; """
.scope
xt_dot_quote:
                ; we let S" do the heavy lifting. Since we're in
                ; compile mode, it will save the string and reproduce it
                ; during runtime
                jsr xt_s_quote

                ; We then let TYPE do the actual printing
                lda #>xt_type           ; MSB
                pha
                lda #<xt_type           ; LSB
                pha
                jsr cmpl_subroutine

z_dot_quote:    rts
.scend


; ## DOT_S ( -- ) "Print content of Data Stack"
; ## ".s"  src: ANSI tools  b: TBA  c: TBA  status: coded
        ; """Print content of Data Stack non-distructively. Since this is for
        ; humans, we don't have to worry about speed. We follow the format
        ; of Gforth and print the number of elements first in brackets,
        ; followed by the Data Stack content (if any).
        ; """
.scope
xt_dot_s:
                jsr xt_depth    ; ( -- u ) 

                ; Print stack depth in brackets
                lda #$3c        ; ASCII for "<"
                jsr emit_a

                ; We keep a copy of the number of the things on the stack
                ; to use as a counter later down. This assumes that there
                ; are less than 255 elements on the stack
                lda 0,x
                tay

                ; print unsigned number without the trailing space
                ; TODO replace this by a real routine
                jsr byte_to_ascii
 
                lda #$3e        ; ASCII for ">"
                jsr emit_a

                lda #AscSP      ; ASCII for SPACE
                jsr emit_a

                inx
                inx

                ; There will be lots of cases where the stack is empty. If that
                ; is so, get out of here quickly
                cpx #dsp0
                beq _done

                ; We have at least one element on the stack. The depth of the
                ; stack is in Y and A, where we can use it as a counter. We go
                ; from bottom to top
                sty tmp1        ; counter

                lda #dsp0-1     ; go up one to avoid garbage
                sta tmp2
                stz tmp2+1      ; must be zero page on the 65c02
_loop:
                lda (tmp2)
                jsr byte_to_ascii       ; TODO replace by real routine
                dec tmp2
                lda (tmp2)
                jsr byte_to_ascii       ; TODO replace by real routine
                dec tmp2

                jsr xt_space

                dec tmp1
                bne _loop
_done:
z_dot_s:        rts
.scend


; ## DROP ( u -- ) "Pop top entry on Data Stack"
; ## "drop"  src: ANSI core  b: 11  c: TBA  status: tested
xt_drop:        
                cpx #dsp0-1
                bmi +
                lda #11         ; underflow
                jmp error
*
                inx
                inx
z_drop:         rts


; ## DUMP ( addr u -- ) "Display a memory region"
; ## "dump"  src: ANSI tools  b: TBA  c: TBA  status: coded
; TODO This is a primitive low-level version for testing, replace
; by high-level version
.scope
xt_dump:        
_row:
                ; start counter for 16 numbers per row
                ldy #16

                jsr xt_cr

                ; print address number
                lda 3,x
                jsr byte_to_ascii
                lda 2,x
                jsr byte_to_ascii

                jsr xt_space
                jsr xt_space
_loop:
                ; if there are zero bytes left to display, we're done
                lda 0,x
                ora 1,x
                beq _done

                ; dump the contents
                lda (2,x)
                jsr byte_to_ascii
                jsr xt_space
                
                ; extra space after eight bytes
                cpy #9
                bne _next_char
                jsr xt_space

_next_char:
                inc 2,x
                bne _counter
                inc 3,x

_counter:
                ; loop counter
                lda 0,x
                bne +
                dec 1,x
*
                dec 0,x
                
                dey
                bne _loop               ; next byte

                bra _row                ; new row
_done:
                inx
                inx
                inx
                inx

z_dump:         rts
.scend


; ## DUP ( u -- u u ) "Duplicate TOS"
; ## "dup"  src: ANSI core  b: 19  c: TBA  status: coded
xt_dup:         
                cpx #dsp0-1
                bmi +

                lda #11         ; underflow
                jmp error
*
                dex
                dex

                lda 2,x         ; LSB
                sta 0,x
                lda 3,x         ; MSB
                sta 1,x

z_dup:          rts


; ## EMIT ( char -- ) "Print character to current output"
; ## "emit"  src: ANSI core  b: TBA  c: TBA  status: tested
.scope
xt_emit:
        ; """Run-time default for EMIT. The user can revector this by changing
        ; the value of the OUTPUT variable. We ignore the MSB completely, and 
        ; do not check to see if we have been given a valid ASCII character. 
        ; Don't make this native compile
        ; """
                cpx #dsp0-1
                bmi +

                lda #11                 ; underflow
                jmp error
*
                lda 0,x
                inx
                inx

emit_a:
        ; We frequently want to print the character in A without fooling
        ; around with the Data Stack. This is emit_a's job, which still
        ; allows the output to be vectored. Call it with JSR as you 
        ; would XT_EMIT
                jmp (output)            ; JSR/RTS

z_emit:         ; never reached 
.scend


; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
; ## "="  src: ANSI core  b: TBA c: TBA  status: coded
.scope
xt_equal:       
                cpx #dsp0-3
                bmi +
                lda #11                 ; underflow
                jmp error
*               
                lda 0,x                 ; LSB
                cmp 2,x
                bne _false

                lda 1,x                 ; MSB
                cmp 3,x
                bne _false

                lda #$ff
                bra _done

_false:         lda #0                  ; drop thru to done

_done:          sta 2,x
                sta 3,x

                inx
                inx

z_equal:        rts
.scend


; ## ERASE ( addr u -- ) "Fill memory region with zeros"
; ## "erase"  src: ANSI core ext  b: TBA  c: TBA  status: coded
.scope
xt_erase:
                ; We don't check for underflow here because
                ; we deal with that in FILL
                dex
                dex
                stz 0,x
                stz 1,x

                ; fall through to FILL

; ## FILL ( addr u char -- ) "Fill a memory region with a character"
; ## "fill"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Fill u bytes of memory with char starting at addr. Note that
        ; this works on bytes, not on cells. On an 8-bit machine such as the
        ; 65c02, this is a serious pain in the rear. It is not defined what
        ; happens when we reach the end of the address space
        ; """
xt_fill:        
                cpx #dsp0-5
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; We use tmp1 to hold the address
                lda 4,x         ; LSB
                sta tmp1
                lda 5,x
                sta tmp1+1

                ; We use tmp2 to hold the counter
                lda 2,x
                sta tmp2
                lda 3,x
                sta tmp2+1
                
                ; We use Y to hold the character
                lda 0,x
                tay
_loop:
                ; Unfortunately, we also need to make sure that we don't
                ; write further than the end of the RAM. So RAM_END must
                ; be larger or equal to the current address
                lda #>ram_end           ; MSB
                cmp tmp1+1
                bcc _done               ; RAM_END < TMP1, so leave
                bne _check_counter      ; RAM_END is not smaller and not equal

                lda #<ram_end           ; LSB, because MSBs were equal
                cmp tmp1
                bcc _done               ; RAM_END < TMP1, so leave

_check_counter:                
                ; See if our counter has reached zero
                lda tmp2
                ora tmp2+1
                beq _done

                ; We're not in ROM and we still have stuff on the counter, so
                ; let's actually do what we came here to do
                tya
                sta (tmp1)

                ; Adjust the counter
                lda tmp2
                bne +
                dec tmp2+1
*               dec tmp2

                ; Next address
                inc tmp1
                bne _loop
                inc tmp1+1

                bra _loop

_done:
                ; Drop three cells off the Data Stack. This uses one byte
                ; less than six times INX
                txa
                clc
                adc #6
                tax
z_erase:
z_fill:         rts
.scend


; ## EVALUATE ( addr u -- ) "Execute a string"
; ## "evaluate"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
        ; After processing the line, revert to old input source. We use this
        ; to compile high-level Forth words and user-defined words during
        ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
        ; accept more than 255 characters here, even though it's a pain in
        ; 8-bit.
        ; """
.scope
xt_evaluate:
                cpx #dsp0-3
                bmi +

                lda #11         ; underflow
                jmp error
*
                ; If u is zero (which can happen a lot for the user-defined
                ; words), just leave again
                lda 0,x
                ora 1,x
                beq _done

                ; We follow pforth's example of pushing SOURCE, SOURCE-ID,
                ; and >IN to the Return Stack. All go MSB first
                lda toin+1      ; >IN
                pha
                lda toin
                pha

                lda insrc+1     ; input source (SOURCE-ID)
                pha
                lda insrc
                pha

                lda cib+1       ; Current Input Buffer
                pha
                lda cib
                pha

                lda ciblen+1    ; Length of CIB
                pha
                lda ciblen
                pha

                ; set SOURCE-ID to -1
                lda #$ff
                sta insrc
                sta insrc+1

                ; set >IN to zero
                stz toin
                stz toin+1

                ; move TOS and NOS to input buffers
                lda 0,x
                sta ciblen
                lda 1,x
                sta ciblen+1

                lda 2,x
                sta cib
                lda 3,x
                sta cib+1

                ; We could clean up the Data Stack here but we might as well
                ; just handle that later before we leave and avoid the
                ; code duplication

                jsr interpret

                ; restore variables
                pla
                sta ciblen
                pla
                sta ciblen+1

                pla
                sta cib
                pla
                sta cib+1

                pla
                sta insrc
                pla
                sta insrc+1

                pla
                sta toin
                pla
                sta toin+1
_done:
                inx
                inx
                inx
                inx

z_evaluate:     rts
.scend


; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
; ## "execute"  src: ANSI core  b: 19  c: TBA  status: tested
.scope
xt_execute:     
                lda 0,x
                sta ip
                lda 1,x
                sta ip+1
                
                inx
                inx

                ; Only JMP has the addressing mode we need, but all our
                ; Forth words end with a RTS instruction. We fake the 
                ; return address by pushing the correct address to the stack
                ; We'll land on a NOP so we don't have to DEC the return
                ; address
                lda #>_done     ; push MSB first
                pha
                lda #<_done
                pha

                jmp (ip)

_done:          ; Keep the NOP here as the landing site for the indirect 
                ; subroutine jump (easier and quicker than adjusting the
                ; return address on the stack)
                nop             ; never actually reached

z_execute:      rts
.scend


; ## EXIT ( -- ) "Return control to the calling word immediately"
; ## "exit"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """ If we're in a loop, we need to UNLOOP first and get everything
        ; we we might have put on the Return Stack off as well. This should
        ; be natively compiled
        ; """
.scope
xt_exit:        
                rts             ; keep before z_exit
z_exit:                         ; never reached
.scend

;
; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
; ## "false"  src: ANSI core ext  b: 6  c: TBA  status: tested
xt_false:       
                dex
                dex
                stz 0,x
                stz 1,x

z_false:        rts


; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
; ## "@"  src: ANSI core  b: 16  c: TBA  status: coded
xt_fetch:       
                lda (0,x)       ; LSB
                tay
                inc 0,x
                bne +
                inc 1,x
*
                lda (0,x)       ; MSB
                sta 1,x
                tya
                sta 0,x

z_fetch:        rts


; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
; ## "find"  src: ANSI core  b: TBA  c: TBA  status: coded
	; """Included for backwards compatibility only, because it still
        ; can be found in so may examples. It should, however, be replaced
        ; by FIND-NAME. Counted string either returns address with a FALSE
        ; flag if not found in the Dictionary, or the xt with a flag to
        ; indicate if this is immediate or not. FIND is a wrapper around
        ; FIND-NAME, we get this all over with as quickly as possible. See
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
        ; """
.scope
xt_find:
                cpx #dsp0-1
                bmi +
                lda #11                 ; underflow
                jmp error
*
                ; Convert ancient-type counted string address to 
                ; modern format
                jsr xt_count            ; ( caddr -- addr u )

                ; Save address in case conversion fails. We use the
                ; Return Stack instead of temporary variables like TMP1
                ; because this is shorter and anybody still using FIND
                ; can't be worried about speed anyway
                lda 3,x                 ; MSB
                pha
                lda 2,x                 ; LSB
                pha

                jsr xt_find_name        ; ( addr u -- nt | 0 )

                lda 0,x
                ora 1,x
                bne _found_word

                ; No word found. Return address of the string and a false
                ; flag
                jsr xt_false            ; ( 0 0 ) 

                pla                     ; LSB of address
                sta 2,x
                pla
                sta 3,x                 ; MSB of address

                bra _done               ; ( addr 0 ) 
_found_word:
                ; We don't need the address after all, dump
                pla
                pla

                ; We arrive here with ( nt ) on the TOS. Now we have to
                ; convert the return values to FIND's format
                jsr xt_dup              ; ( nt nt ) 
                jsr xt_name_to_int      ; ( nt xt )
                jsr xt_swap             ; ( xt nt ) 

                ldy #0                  ; Prepare flag

                ; The flags are in the second byte of the header
                inc 0,x
                bne +
                inc 1,x                 ; ( xt nt+1 )
*
                lda (0,x)               ; ( xt char )
                and #IM
                bne _immediate          ; bit set, we're immediate

                lda #$ff                ; We're not immediate, return -1
                sta 0,x
                sta 1,x
                bra _done
_immediate:
                lda #1                  ; We're immediate, return 1
                sta 0,x
                stz 1,x
_done:
z_find:         rts
.scend


; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
; ## "find-name"  src: Gforth  b: TBA  c: TBA  status: coded
.scope
xt_find_name:
        ; """Given a string, find the Name Token (nt) of a word or return
        ; zero if the word is not in the dictionary. We use this instead of
        ; ancient FIND to look up words in the Dictionary passed by
        ; PARSE-NAME. Note this returns the nt, not the xt of a word like
        ; FIND. To convert, use NAME>INT. This is a Gforth word. See
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html 
        ; FIND calls this word
        ; """
        
                ; check for special case of an empty string (length zero)
                lda 0,x
                ora 1,x
                beq _fail_done          ; this might have to be JMP

_have_string:
                ; set up first loop iteration
                lda dp                  ; nt of first word in Dictionary
                sta tmp1
                lda dp+1
                sta tmp1+1

                lda 2,x                 ; Address of mystery string
                sta tmp2
                lda 3,x
                sta tmp2+1

_loop:
                ; first quick test: Are strings the same length?
                lda (tmp1)
                cmp 0,x
                bne _next_entry

_compare_string:
                ; are the same length, so we now have to compare each
                ; character

                ; second quick test: Is the first character the same?
                ldy #8
                lda (tmp1),y
                cmp (tmp2)              ; first character of mystery string
                bne _next_entry

                ; string length are the same and the first character is the
                ; same. If the length of the string is 1, we're already done
                lda 0,x
                dec
                beq _success

                ; No such luck: The strings are the same length and the first
                ; char is the same, but the word is more than one char long.
                ; So we suck it up and compare every single character. We go
                ; from back to front, because words like CELLS and CELL+ would
                ; take longer otherwise. We can also shorten the loop by one
                ; because we've already compared the first char. 

                ; The string of the word we're testing against is 8 bytes down
                lda tmp1
                clc
                adc #8
                sta tmp3        ; we preserve tmp1
                lda tmp1+1
                adc #0          ; we only need the carry
                sta tmp3+1

                ldy 0,x         ; index is length of string minus 1
                dey

_string_loop:
                lda (tmp2),y    ; last char of mystery string
                cmp (tmp3),y    ; last char of word we're testing against
                bne _next_entry

                dey
                bne _string_loop

_success:
                ; The strings match. Put correct nt NOS, because we'll drop
                ; TOS before we leave
                lda tmp1
                sta 2,x
                lda tmp1+1
                sta 3,x

                bra _done

_next_entry:
                ; Not the same, so we get the next word. Next header
                ; address is two bytes down
                ldy #2
                lda (tmp1),y
                pha
                iny
                lda (tmp1),y
                sta tmp1+1
                pla
                sta tmp1

                ; If we got a zero, we've walked the whole Dictionary and
                ; return as a failure, otherwise try again
                ora tmp1+1
                bne _loop       ; fall through to _fail_done

_fail_done:
                stz 2,x         ; failure flag
                stz 3,x
_done: 
                inx
                inx

z_find_name:    rts
.scend


; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
; ## "fm/mod"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """There are various ways to realize this. We follow EForth with
        ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
        ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN 
        ; See (http://www.forth.org/eforth.html). However you can also
        ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
        ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN 
        ; Note that by default, Tali Forth uses SM/REM for most things.
        ; """
.scope
xt_fm_slash_mod:
                cpx #dsp0-5
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; if sign of n1 is negative, negate both n1 and d
                stz tmp2        ; default: n is positive
                lda 1,x         ; MSB of n1
                bpl _check_d    

                inc tmp2        ; set flag to negative for n1
                jsr xt_negate   ; NEGATE
                jsr xt_to_r     ; >R
                jsr xt_dnegate  ; DNEGATE
                jsr xt_r_from   ; R>

_check_d:       ; if d is negative, add n1 to high cell of d
                lda 3,x         ; MSB of high word of d
                bpl _multiply

                clc
                lda 0,x         ; LSB of n1
                adc 2,x         ; LSB of dh
                sta 2,x

                lda 1,x         ; MSB of n1
                adc 3,x         ; MSB of dh
                sta 3,x
_multiply:
                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )

                ; if n was negative, negate the result
                lda tmp2
                beq _done

                inx             ; pretend that we SWAP
                inx
                jsr xt_negate
                dex
                dex
_done:
z_fm_slash_mod: rts
.scend

; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
; ## ">"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_greater_than:
                cpx #dsp0-3
                bmi +
                lda #11         ; underflow
                jmp error
*               
                ldy #0          ; default false
                jsr compare_16bit

                ; for signed numbers, NOS>TOS gives us Z=0 and N=1
                beq _false
                bpl _false

                ; true
                dey
_false:
                tya

                inx
                inx
                sta 0,x
                sta 1,x
                
z_greater_than: rts
.scend


; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
; ## "here"  src: ANSI core  b: 10  c: TBA  status: coded
xt_here:        
                dex
                dex
                lda cp
                sta 0,x
                lda cp+1
                sta 1,x

z_here:         rts


; ## HEX ( -- ) "Change base radix to hexadecimal"
; ## "hex"  src: ANSI core ext  b: 6  c: TBA  status: coded
xt_hex:         
                lda #16
                sta base
                stz base+1              ; paranoid

z_hex:          rts



; ## HOLD ( char -- ) "Insert character at current output"
; ## "hold"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Insert a character at the current position of a pictured numeric
        ; output string on 
        ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
        ; variable tohold instead of HLD.
        ; """
xt_hold:        
                lda tohold
                bne +
                dec tohold+1
*               dec tohold

                lda 0,x
                sta (tohold)

                inx
                inx

z_hold:         rts


; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
; ## "i"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Note that this is not the same as R@ because we use a fudge
        ; factor for loop control; see docs/loop.txt for details. We
        ; should make this native compile for speed. 
        ; """
.scope
xt_i:           
                dex
                dex

                ; Get the fudged index off of the top of the stack. It's
                ; easier to do math on the stack directly than to pop and
                ; push stuff around
                stx tmpdsp
                tsx

                sec
                lda $0101,x     ; LSB
                sbc $0103,x
                sta tmp1

                lda $0102,x     ; MSB
                sbc $0104,x

                ldx tmpdsp

                sta 1,x         ; MSB of de-fudged index
                lda tmp1
                sta 0,x         ; LSB of de-fudged index

z_i:            rts
.scend


; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
; ## "immediate"  src: ANSI core  b: 8  c: TBA  status: coded
        ; """Make sure the most recently defined word is immediate. Will only
        ; affect the last word in the dictionary. Note that if the word is
        ; defined in ROM, this will have no affect, but will not produce an
        ; error message.
        ; """
xt_immediate:
                ldy #1          ; offset for status byte
                lda (dp),y
                ora #IM        ; make sure bit 7 is set
                sta (dp),y

z_immediate:    rts


; ## INPUT ( -- addr ) "Return address of input vector"
; ## "input"  src: Tali Forth  b: TBA  c: TBA  status: coded
.scope
xt_input:       
                dex
                dex
                lda #<input
                sta 0,x
                lda #>input
                sta 1,x

z_input:        rts
.scend


; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
; ## "int>name"  src: Tali Forth  b: TBA  c: TBA  status: coded
        ; """This is called >NAME in Gforth, but we change it to 
        ; INT>NAME to match NAME>INT
        ; """
.scope
xt_int_to_name: 
                ; Unfortunately, to find the header, we have to walk through
                ; the whole Dictonary
                lda dp
                sta tmp2        ; Save latest word nt in tmp2
                lda dp+1
                sta tmp2+1

                lda 0,x
                sta tmp3        ; Save target xt in tmp3
                lda 1,x
                sta tmp3+1
_loop:
                ldy #4          ; xt is four bytes down
                lda (tmp2),y    ; LSB of xt of current nt
                cmp tmp3
                bne _no_match

                ; LSB is the same, now check MSB
                iny
                lda (tmp2),y    ; MSB of xt of current nt
                cmp tmp3+1
                beq _match
_no_match: 
                ; no match, so we need to get the next word. Next nt is two
                ; bytes down
                clc
                lda tmp2
                adc #2
                sta tmp2
                lda tmp2+1
                adc #0          ; only care about carry
                sta tmp2+1

                ldy #0
                lda (tmp2),y
                pha
                iny
                ora (tmp2),y
                beq _zero

                ; Not zero continue
                lda (tmp2),y
                sta tmp2+1
                pla
                sta tmp2
                bra _loop
_zero:
                ; if next word is zero, something is wrong and we
                ; return with an error
                lda #13         ; xt not found
                jmp error 
_match:
                ; It's a match! Replace TOS with nt
                lda tmp2
                sta 0,x
                lda tmp2+1
                sta 1,x
                
z_int_to_name:  rts
.scend


; ## INVERT ( u -- u ) "Complement of TOS"
; ## "invert"  src: ANSI core  b: 10  c: TBA  status: coded
; TODO see if TAY really faster than second LDA #$FF
xt_invert:
                lda #$FF
                tay

                eor 0,x         ; LSB
                sta 0,x

                tya
                eor 1,x         ; MSB
                sta 1,x

z_invert:       rts


; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
; ## "j"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Copy second loop counter from Return Stack to stack. Note we use
        ; a fudge factor for loop control; see docs/loop.txt for more details.
        ; At this point, we have the "I" counter/limit and the LEAVE address
        ; on the stack above this (three entries), whereas the ideal Forth
        ; implementation would just have two. Make this native compiled for
        ; speed
        ; """
.scope
xt_j:
                dex
                dex

                ; Get the fudged index off from the stack. It's easier to
                ; do math on the stack directly than to pop and push stuff 
                ; around
                stx tmpdsp
                tsx

                sec
                lda $0106,x     ; LSB
                sbc $0108,x
                sta tmp1

                lda $0107,x     ; MSB
                sbc $0109,x

                ldx tmpdsp

                sta 1,x         ; MSB of de-fudged index
                lda tmp1
                sta 0,x         ; LSB of de-fudged index

z_j:            rts
.scend


; ## KEY ( -- char ) "Get one character from the input"
; ## "key"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_key:         
        ; """Get a single character of input from the vectored
        ; input without echoing.
        ; """
                jsr key_a               ; returns char in A
                
                dex
                dex
                sta 0,x
                stz 1,x

                rts

key_a:
        ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
        ; 65816, so we have to fake the indirect jump to vector it.
        ; This is depressingly slow. We use this routine internally
        ; to avoid manipulating the Data Stack when we just want a
        ; character
                jmp (input)             ; JSR/RTS

z_key:          ; never reached
.scend


; ## KEY_QUESTION ( -- ) "<TBA>"
; ## "key?"  src: ANSI facility  b: TBA  c: TBA  status: TBA
.scope
xt_key_question:
                nop
z_key_question: rts
.scend


; ## LATESTNT ( -- nt ) "Push most recent nt to stack"
; ## "latestnt"  src: Tali Forth  b: 10  c: TBA  status: coded
        ; """The Gforth version of this word is called LATEST
        ; """
xt_latestnt:
                dex
                dex

                lda dp
                sta 0,x
                lda dp+1
                sta 1,x 

z_latestnt:     rts


; ## LATESTXT ( -- xt ) "<TBA>"
; ## "latestxt"  src: Gforth  b: TBA  c: TBA  status: coded
xt_latestxt:    
                jsr xt_latestnt         ; ( nt )
                jsr xt_name_to_int      ; ( xt ) 
z_latestxt:     rts


; ## LEAVE ( -- ) "Leave DO/LOOP construct"
; ## "leave"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Note that this does not work with  anything but a DO/LOOP in
        ; contrast to other versions such as discussed at
        ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
        ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
        ; See docs/loops.txt on details of how this works. This must be native
        ; compile and not IMMEDIATE
        ; """
.scope
xt_leave:
                ; We dump the limit/start entries off the Return Stack
                ; (four bytes)
                pla
                pla
                pla
                pla

                rts             ; this must be compiled, so keep before z_leave
z_leave:                        ; not reached, not compiled
.scend


; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
; ## "["  src: ANSI core  b: 4  c: TBA  status: coded
        ; """This is an immediate and compile-only word
        ; """
xt_left_bracket:
                stz state
                stz state+1

z_left_bracket: rts


; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
; ## "<#"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Start the process to create pictured numeric output. The new
        ; string is constructed from back to front, saving the new character
        ; at the beginning of the output string. Since we use PAD as a 
        ; starting address and work backward (!), the string is constructed
        ; in the space between the end of the Dictionary (as defined by CP)
        ; and the PAD. This allows us to satisfy the ANS Forth condition that
        ; programs don't fool around with the PAD but still use its address.
        ; Based on pForth
        ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
        ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
        ; internal variable tohold instead of HLD.
        ; """
xt_less_number_sign:
                jsr xt_pad      ; ( addr )

                lda 0,x
                sta tohold
                lda 1,x
                sta tohold+1

                inx
                inx
z_less_number_sign:
                rts

; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
; ## "<"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_less_than:
                cpx #dsp0-3
                bmi +
                lda #11         ; underflow
                jmp error
*
                ldy #0          ; default false
                jsr compare_16bit

                ; for signed numbers, NOS < TOS if Z=0 and N=0
                beq _false
                bmi _false

                ; true
                dey
_false:
                tya

                inx
                inx
                sta 0,x
                sta 1,x
                
z_less_than:    rts
.scend


; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
; ## "literal"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """ Compile-only word to store TOS so that it is pushed on stack
        ; during runtime. This is a immediate, compile-only word. At runtime,
        ; it works by calling literal_runtime by compling JSR LITERAL_RT.
        ; Note the cmpl_ routines use TMPTOS
        ; """
xt_literal:     
                lda #>literal_runtime
                pha                     ; MSB first
                lda #<literal_runtime
                pha                     ; LSB

                jsr cmpl_subroutine

                ; Compile the value that is to be pushed on the Stack during
                ; runtime
                jsr xt_comma
                
z_literal:      rts

literal_runtime:
.scope
                ; During runtime, we push the value following this word back
                ; on the Data Stack. The subroutine jump that brought us
                ; here put the address to return to on the Return Stack -
                ; this points to the data we need to get. This routine is
                ; also called (LITERAL) in some Forths
                dex
                dex

                ; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
                ; so we have to manipulate the address. First, we get the
                ; value after the command
                ply             ; LSB
                pla             ; MSB
                iny
                bne +
                inc
*
                sty tmp1        ; LSB
                sta tmp1+1      ; MSB

                ; Then we get the bytes after the the JSR address
                lda (tmp1)      ; LSB
                sta 0,x
                inc tmp1
                bne +
                inc tmp1+1
*
                lda (tmp1)      ; MSB
                sta 1,x

                ; Replace return address on the Return Stack
                lda tmp1+1
                pha             ; MSB
                lda tmp1
                pha             ; LSB

                rts
.scend


; ## LOOP ( -- ) "Finish loop construct"
; ## "loop"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Compile-time part of LOOP. This does nothing more but push 1 on
        ; the stack and then call +LOOP. In Forth, this is 
        ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
        ;       IMMEDIATE ; COMPILE-ONLY
        ; This drops through to +LOOP
        ; """
xt_loop:
                ; Have the finished word push 1 on the stack
                lda #>xt_one
                pha
                lda #<xt_one
                pha
                jsr cmpl_subroutine     ; drop through to +LOOP

; ## PLUS_LOOP ( -- ) "Finish loop construct"
; ## "+loop"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Compile-time part of +LOOP, also used for LOOP. Is usually
        ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
        ;       COMPILE-ONLY 
        ; in Forth. LOOP uses this routine as well. We jump here with the
        ; address for looping as TOS and the address for aborting the loop
        ; (LEAVE) as the second double-byte entry on the Return Stack (see
        ; DO and docs/loops.txt for details).
        ; """
.scope
xt_plus_loop:
                ; Compile the run-time part. We do this with a short loop
                ; and not a call to COMPILE, because it has to be natively
                ; coded anyway. 
                ldy #plus_loop_runtime_end-plus_loop_runtime
                phy             ; save counter to adjust CP
*
                lda plus_loop_runtime,y
                sta (cp),y
                dey
                bpl -

                ; Adjust CP
                pla
                clc
                adc cp
                sta cp
                lda cp+1
                adc #0          ; only need carry
                sta cp+1

                ; The address we need to loop back to is TOS. Store it so
                ; the runtime part of +LOOP jumps back up there
                jsr xt_comma

                ; Compile an UNLOOP for when we're all done. This is a series
                ; of six PLA, so we just do it here instead jumping around
                ; all over the place
                lda #$68                ; opcode for PLA
                ldy #6
*
                sta (cp),y
                dey
                bpl -

                ; Adjust CP
                lda #6
                clc
                adc cp
                sta cp
                lda cp+1
                adc #0                  ; only need carry
                sta cp+1

                ; Complete compile of DO/?DO by replacing the six
                ; dummy bytes by PHA instructions. The address where 
                ; they are located is on the Data Stack
                lda 0,x
                sta tmp1
                lda 1,x
                sta tmp1+1
                inx
                inx

                ; now compile this in the DO/?DO routine
                ldy #0

                lda #$a9        ; opcode for LDA immediate
                sta (tmp1),y
                iny
                lda tmp1+1   ; MSB
                sta (tmp1),y
                iny
                lda #$48        ; Opcode for PHA
                sta (tmp1),y
                iny

                lda #$a9        ; opcode for LDA immediate
                sta (tmp1),y
                iny
                lda tmp1        ; LSB
                sta (tmp1),y
                iny
                lda #$48        ; Opcode for PHA
                sta (tmp1),y
z_loop:
z_plus_loop:    rts
.scend

plus_loop_runtime:
        ; """Runtime compile for loop control. This is used for both +LOOP and
        ; LOOP which are defined at high level. Note we use a fudge factor for
        ; loop  control so we can test with the Overflow Flag. See 
        ; docs/loop.txt for details. The step value is TOS in the loop. This
        ; musst always be native compiled. In some Forths, this is a separate
        ; word called (+LOOP) or (LOOP)
        ; """
.scope
                clc
                pla             ; LSB of index
                adc 0,x         ; LSB of step
                tay             ; temporary storage of LSB

                clv
                pla             ; MSB of index
                adc 1,x         ; MSB of step
                pha             ; put MSB of index back on stack

                tya             ; put LSB of index back on stack
                pha

                inx             ; dump step from TOS 
                inx

                ; if V flag is set, we're done looping and continue
                ; after the +LOOP instruction
                bvs _hack+3     ; skip over JMP instruction

_hack:          ; This is why this routine must be natively compiled: We 
                ; compile the opcode for JMP here without an address to 
                ; go to, which is added by the next next instruction of
                ; LOOP/+LOOP during compile time
                .byte $4c
.scend
plus_loop_runtime_end:


; ## LSHIFT ( x u -- u ) "Shift TOS left"
; ## "lshift"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_lshift:
                ; max shift 16 times
                lda 0,x
                and #%00001111
                beq _done

                tay
_loop:
                asl 2,x
                rol 3,x
                dey
                bne _loop
_done:
                inx
                inx

z_lshift:       rts
.scend


; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
; ## "m*"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Multiply two 16 bit numbers, producing a 32 bit result. All
        ; values are signed. Adapted from FIG Forth for Tali Forth. The
        ; original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
        ; with  : D+- O< IF DNEGATE THEN ;
        ; """
.scope
xt_m_star:
                ; figure out the sign
                lda 1,x         ; MSB of n1
                eor 3,x         ; MSB of n2

                ; UM* uses all kinds of temporary variables so we don't
                ; risk a conflict but just take the cycle hit and push
                ; this to the stack
                pha

                ; get the absolute value of both numbers so we can feed
                ; them to UM*, which does the real work
                ; TODO convert this to assembler for speed
                jsr xt_abs
                jsr xt_swap
                jsr xt_abs

                jsr xt_um_star          ; ( d ) 

                ; handle the sign
                pla
                bpl _done

                jsr xt_dnegate
_done:
z_m_star:       rts
.scend


; ## MARKER ( -- ) "<TBA>"
; ## "marker"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_marker:      nop
z_marker:       rts
.scend


; ## MAX ( n n -- n ) "Keep larger of two numbers"
; ## "max"  src: ANSI core  b: 24  c: TBA  status: coded
        ; """Compare TOS and NOS and keep which one is larger. Adapted from
        ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
        ; Flag indicates which number is larger. See also 
        ; http://6502.org/tutorials/compare_instructions.html and
        ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html 
        ; """
.scope
xt_max:         
                ; Compare LSB. We do this first to set the carry flag
                lda 0,x         ; LSB of TOS
                cmp 2,x         ; LSB of NOS, this sets the carry

                lda 1,x         ; MSB of TOS
                sbc 3,x         ; MSB of NOS
                bvc _no_overflow

                ; handle overflow, because we use signed numbers
                eor #$80        ; complement negative flag
_no_overflow:
                ; if negative, NOS is larger and needs to be kept
                bmi _keep_nos

                ; move TOS to NOS
                lda 0,x
                sta 2,x
                lda 1,x
                sta 3,x
_keep_nos:
                inx
                inx

z_max:          rts
.scend


; ## MIN ( n n -- n ) "Keep smaller of two numbers"
; ## "min"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Adapted from Lance A. Leventhal "6502 Assembly Language
        ; Subroutines." Negative Flag indicateds which number is larger. See
        ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html 
        ; """
.scope
xt_min:         ; compare LSB. We do this first to set the carry flag
                lda 0,x         ; LSB of TOS
                cmp 2,x         ; LSB of NOS, this sets carry

                lda 1,x         ; MSB of TOS
                sbc 3,x         ; MSB of NOS
                bvc _no_overflow

                ; handle overflow because we use signed numbers
                eor #$80
_no_overflow:
                ; if negative, NOS is larger and needs to be dumped
                bpl _keep_nos
                
                ; move TOS to NOS
                lda 0,x
                sta 2,x
                lda 1,x
                sta 3,x
_keep_nos:
                inx
                inx

z_min:          rts
.scend


; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
; ## "-"  src: ANSI core  b: 15  c: TBA  status: coded
xt_minus:       
                sec
                lda 2,x         ; LSB
                sbc 0,x
                sta 2,x

                lda 3,x         ; MSB
                sbc 1,x
                sta 3,x
                
                inx
                inx

z_minus:        rts


; ## MINUS_TRAILING ( -- ) "<TBA>"
; ## "-trailing"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_minus_trailing:
                nop
z_minus_trailing:
                rts
.scend

; ## MOD ( -- ) "<TBA>"
; ## "mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_mod:         nop
z_mod:          rts
.scend


; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
; ## "move"  src: ANSI core  b: TBA  c: TBA  status: TBA
        ; """Copy u "address units" from addr1 to addr2. Since our address
        ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
        ; is actually the only one of these three words that is in the CORE
        ; set. This word must not be natively compiled
        ; """
.scope
xt_move:
                ; We let CMOVE and CMOVE> check if there is underflow or
                ; we've been told to copy zero bytes

                ; compare MSB first
                lda 3,x                 ; MSB of addr2
                cmp 5,x                 ; MSB of addr1
                beq _lsb                ; wasn't not helpful, move to LSB

                bcc _to_move_up         ; we want CMOVE>

                jmp xt_cmove            ; JSR/RTS
_lsb:        
                ; MSB were equal, so do the whole thing over with LSB
                lda 2,x                 ; LSB of addr2
                cmp 4,x                 ; LSB of addr1
                beq _equal              ; LSB is equal as well 

                bcc _to_move_up         ; we want CMOVE>
                jmp xt_cmove            ; JSR/RTS
_to_move_up:
                jmp xt_cmove_up         ; JSR/RTS
_equal:         
                ; drop three entries from Data Stack
                txa
                clc
                adc #6
                tax

z_move:         rts
.scend


; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
; ## "name>int"  src: Gforth  b: 11  c: TBA  status: coded
; TODO deal with compile-only words
        ; """See
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
        ; """ 
.scope
xt_name_to_int: 
                ; The xt starts four bytes down from the nt
                lda 0,x
                clc
                adc #4
                sta tmp3

                lda 1,x
                bcc _done
                inc
_done:
                sta tmp3+1

                ldy #0
                lda (tmp3),y
                sta 0,x
                iny
                lda (tmp3),y
                sta 1,x

z_name_to_int:  rts
.scend


; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
; ## "name>string"  src: Gforth  b: TBA  c: TBA  status: coded
.scope
xt_name_to_string:
                dex
                dex

                ; the length of the string is the first byte of the
                ; header pointed to by nt
                lda (2,x)
                sta 0,x
                stz 1,x

                ; the string itself always starts eight bytes down
                lda 2,x         ; LSB
                clc
                adc #8
                tay
                lda 3,x         ; MSB
                adc #0          ; just need carry
                sta 3,x
                sty 2,x
                 
z_name_to_string:
                rts
.scend

; ## NC_LIMIT ( -- ) "<TBA>"
; ## "nc-limit"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_nc_limit:    nop
z_nc_limit:     rts
.scend


; ## NEGATE ( n -- n ) "Two's complement"
; ## "negate"  src: ANSI core  b: 17  c: TBA  status: coded
xt_negate:      
                lda 0,x         ; LSB
                eor #$ff
                clc
                adc #1
                sta 0,x

                lda 1,x         ; MSB
                eor #$ff
                adc #0          ; only need the carry
                sta 1,x

z_negate:       rts


; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
; ## "never-compile"  src: Tali Forth  b: TBA  c: TBA  status: coded
xt_never_native:
                ldy #1          ; offset for status byte
                lda (dp),y
                ora #NN         ; make sure flag is set
                sta (dp),y
z_never_native:
                rts


; ## NIP ( b a -- a ) "Delete NOS"
; ## "nip"  src: ANSI core ext  b: 10  c: TBA  status: coded
xt_nip:         
                lda 0,x         ; LSB
                sta 2,x
                lda 1,x         ; MSB
                sta 3,x
                inx
                inx

z_nip:          rts


; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
; ## "<>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
        ; """This is just a variant of EQUAL, we code it separately
        ; for speed.
        ; """
.scope
xt_not_equals:
                cpx #dsp0-3
                bmi +
                lda #11                 ; underflow
                jmp error
*               
                ldy #0                  ; default is true

                lda 0,x                 ; LSB
                cmp 2,x
                bne _not_equal

                ; LSB is equal
                lda 1,x                 ; MSB
                cmp 3,x
                bne _not_equal

                lda #$ff
                bra _done
_not_equal:     
                dey                     ; drop thru to done
_done:          
                tya

                inx
                inx
                sta 0,x
                sta 1,x

z_not_equals:   rts
.scend


; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
; ## "-rot"  src: Gforth  b: TBA  c: TBA  status: coded
.scope
xt_not_rote:    
                lda 1,x         ; MSB first
                tay
                lda 3,x
                sta 1,x

                lda 5,x
                sta 3,x
                tya
                sta 5,x

                lda 0,x         ; LSB second
                tay
                lda 2,x
                sta 0,x

                lda 4,x
                sta 2,x
                tya
                sta 4,x

z_not_rote:     rts
.scend


; ## NUMBER ( addr u -- u | d ) "Convert a number string"
; ## "number"  src: Tali Forth  b: TBA  c: TBA  status: TBA
        ; """Convert a number string to a double or single cell number. This
        ; is a wrapper for >NUMBER and follows the convention set out in the 
        ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
        ; Based in part on the "Starting Forth" code 
        ; https://www.forth.com/starting-forth/10-input-output-operators/
        ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
        ; Another difference to Gforth is that we follow ANSI Forth that the
        ; dot to signal a double cell number is required to be the last
        ; character of the string. Number calls >NUMBER which in turn calls UM*,
        ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
        ; a pain. 
        ;"""
.scope
xt_number:      
                ; we keep the flags for sign and double in tmpdsp because
                ; we've run out of temporary variables
                stz tmpdsp      ; flag for double
                stz tmpdsp+1    ; flag for minus

                ; If the first character is a minus, strip it off and set
                ; the flag
                lda (2,x)
                cmp #$2d        ; ASCII for "-"
                bne _check_dot

                ; It's a minus
                dec tmpdsp+1
                inc 2,x         ; start one character later
                bne +
                inc 3,x
*
                dec 0,x         ; decrease string length by one
                
                ; TODO check to see what happens if we are given a single
                ; minus as the string

_check_dot:
                ; If the last character is a dot, strip it off and set a
                ; flag. We can use tmptos as a temporary variable
                lda 2,x         ; LSB of address
                clc
                adc 0,x         ; length of string
                sta tmptos
                lda 3,x
                adc #0          ; only need carry
                sta tmptos+1

                ; tmptos now points to the first character after the string,
                ; but we need the last character
                lda tmptos
                bne +
                dec tmptos+1
*               dec tmptos

                lda (tmptos)
                cmp #'.
                bne _main

                ; We have a dot, which means this is a double number. Flag
                ; the fact and reduce string length by one
                dec tmpdsp
                dec 0,x
_main:                
                ; set up stack for subroutine jump to >NUMBER, which means
                ; we have to go ( addr u --> ud addr u )
                dex
                dex
                dex
                dex

                lda 4,x         ; LSB of length
                sta 0,x
                stz 1,x         ; MSB, max length 255 chars

                lda 6,x         ; LSB of address
                sta 2,x
                lda 7,x         ; MSB of address
                sta 3,x

                stz 4,x         ; clear space for ud
                stz 5,x
                stz 6,x
                stz 7,x

                jsr xt_to_number        ; (ud addr u -- ud addr u )

                ; test length of returned string, which should be zero
                lda 0,x
                beq _all_converted

                ; Something went wrong, we still have characters left over,
                ; so we print an error and abort. If the NUMBER was called
                ; by INTERPRET, we've already checked for Forth words, so
                ; we're in deep trouble one way or another
                lda #$3e        ; ASCII for ">"
                jsr emit_a
                jsr xt_type
                lda #$3c        ; ASCII for "<"
                jsr emit_a
                jsr xt_space

                lda #12         ; code for Syntax error
                jmp error
                
_all_converted:
                ; We can drop the string info
                inx
                inx
                inx
                inx

                ; We have a double-cell number on the Data Stack that might
                ; actually have a minus and might actually be single-cell
                lda tmpdsp      ; flag for double
                beq _single

                ; This is a double cell number. If it had a minus, we'll have
                ; to negate it
                lda tmpdsp+1
                beq _done       ; no minus, all done

                jsr xt_dnegate

                bra _done
_single:
                ; This is a single number, so we just drop the top cell
                inx
                inx

                ; If we had a minus, we'll have to negate it
                lda tmpdsp+1
                beq _done       ; no minus, all done

                jsr xt_negate
_done:                
z_number:       rts
.scend


; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
; ## "#"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Add one char to the beginning of the pictured output string. Based
        ; on https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
        ; """
        ; TODO convert more parts to assembler
        
xt_number_sign:        
                jsr xt_base
                jsr xt_fetch            ; ( ud1 base )
                jsr xt_ud_slash_mod     ; ( rem ud )
                jsr xt_rot              ; ( ud rem ) 

                ; Convert the number that is left over to an ASCII character. We
                ; use a string lookup for speed. Use either abc_str_lower for
                ; lower case or abc_str_upper for upper case (prefered)
                lda 0,x
                tay
                lda s_abc_upper,y
                sta 0,x
                stz 1,x                 ; paranoid; now ( ud char ) 

                jsr xt_hold

z_number_sign:
                rts


; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
; ## "#>"  src: ANSI core  b: 26  c: TBA  status: coded
        ; """Finish conversion of pictured number string, putting address and
        ; length on the Data Stack. Original Fort is  2DROP HLD @ PAD OVER -
        ; Based on
        ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; """
xt_number_sign_greater:
                
                ; The start address lives in tohold
                lda tohold
                sta 0,x         ; LSB of tohold
                sta 2,x
                lda tohold+1
                sta 1,x         ; MSB of addr
                sta 3,x         ; ( addr addr ) 

                ; The length of the string is pad - addr
                jsr xt_pad      ; ( addr addr pad ) 

                sec
                lda 0,x         ; LSB of pad address
                sbc 2,x
                sta 2,x

                lda 1,x         ; MSB, which should always be zero
                sbc 3,x
                sta 3,x         ; ( addr u pad )

                inx
                inx

z_number_sign_greater:
                rts


; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
; ## "#s"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Completely convert number for pictured numerical output. Based on
        ; https://github.com/philburk/pforth/blob/master/fth/system.fth
        ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
        ; """
.scope
xt_number_sign_s:
_loop:
                ; convert a single number ("#")
                jsr xt_number_sign

                ; stop when double-celled number in TOS is zero:
                lda 0,x
                ora 1,x
                ora 2,x
                ora 3,x
                bne _loop

z_number_sign_s:
                rts
.scend


; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
; ## "1"  src: Tali Forth  b: 8  c: TBA  status: tested
xt_one:         
                dex
                dex
                lda #1
                sta 0,x
                stz 1,x

z_one:          rts



; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
; ## "1-"  src: ANSI core  b: 8  c: TBA  status: coded
.scope
xt_one_minus:   
                lda 0,x
                bne +
                dec 1,x
*               dec 0,x

z_one_minus:    rts
.scend


; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
; ## "1+"  src: ANSI core  b: 6  c: 14-15  status: coded
.scope
xt_one_plus:    
                inc 0,x
                bne _done
                inc 1,x
_done:
z_one_plus:     rts
.scend


; ## OR ( m n -- n ) "Logically OR TOS and NOS"
; ## "or"  src: ANSI core  b: 14  c: TBA  status: coded
xt_or:          
                cpx #dsp0-3
                bmi +
                lda #11         ; underflow
                jmp error
*
                lda 0,x
                ora 2,x
                sta 2,x

                lda 1,x
                ora 3,x
                sta 3,x

                inx
                inx

z_or:           rts


; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
; ## "output"  src: Tali Forth  b: TBA  c: TBA  status: coded
xt_output:      
        ; """Return the address where the jump target for EMIT is stored (but
        ; not the vector itself). By default, this will hold the value of 
        ; kernel_putc routine, but this can be changed by the user, hence this
        ; routine.
        ; """
                dex
                dex
                lda #<output
                sta 0,x
                lda #>output
                sta 1,x
                
z_output:       rts


; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
; ## "over"  src: ANSI core  b: 10  c: TBA  status: coded
xt_over:        
                dex
                dex

                lda 4,x         ; LSB
                sta 0,x
                lda 5,x         ; MSB
                sta 1,x 

z_over:         rts


; ## PAD ( -- addr ) "Return address of user scratchpad"
; ## "pad"  src: ANSI core ext  b: TBA  c: TBA  status: coded
        ; """Return address to a temporary area in free memory for user. Must
        ; be at least 84 bytes in size (says ANSI). It is located relative to
        ; the compile area pointer (CP) and therefore varies in position.
        ; This area is reserved for the user and not used by the system
        ; """
xt_pad:         
                dex
                dex

                lda cp
                clc
                adc #padoffset  ; assumes padoffset one byte in size
                sta 0,x

                lda cp+1
                adc #0          ; only need carry
                sta 1,x

z_pad:          rts


; ## PAGE ( -- ) "Clear the screen"
; ## "page"  src: ANSI facility  b: TBA  c: TBA  status: coded
        ; """Clears a page if supported by ANSI terminal codes. This is 
        ; Clear Screen ("ESC[2J") plus moving the cursor to the top
        ; left of the screen
        ; """
xt_page:        
                lda #AscESC
                jsr emit_a
                lda #$5B        ; ASCII for "["
                jsr emit_a
                lda #'2
                jsr emit_a
                lda #'J
                jsr emit_a

                ; move cursor to top left of screen 
                jsr xt_zero 
                jsr xt_zero
                jsr xt_at_xy

z_page:         rts


; ## PAREN_DO ( -- ) "<TBA>"
; ## "(do)"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_paren_do:    nop
z_paren_do:     rts
.scend

; ## PAREN_PLUS_LOOP ( -- ) "<TBA>"
; ## "(+loop)"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_paren_plus_loop:
                nop
z_paren_plus_loop:
                rts
.scend

; ## PAREN_Q_DO ( -- ) "<TBA>"
; ## "(?do)"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_paren_q_do:  nop
z_paren_q_do:   rts
.scend

; ## PARSE-NAME ( "name" -- addr u ) "Parse the input"
; ## "parse-name"  src: ANSI core ext  b: TBA  c: TBA  status: coded
        ; """Find next word in input string, skipping leading spaces. This is 
        ; a special form of PARSE and drops through to that word. See PARSE 
        ; for more detail. We use this word internally for the interpreter
        ; because it is a lot easier to use. Reference implementations at
        ; http://forth-standard.org/standard/core/PARSE-NAME and
        ; http://www.forth200x.org/reference-implementations/parse-name.fs
        ; Roughly, the word is comparable to BL WORD COUNT
        ; """
.scope
xt_parse_name:
                ; To enable the compilation of the high-level Forth words
                ; in forth-words.asm and user-words.asm at boot time,
                ; PARSE-NAME and PARSE must be able to deal with 16-bit string
                ; lengths. This is a pain on an 8-bit machine. The pointer
                ; to the current location is in toin (>IN). We need to check, 
                ; worst case, the characters from cib+toin to cib+ciblen, and
                ; we can't just use Y as an index. 

                ; The counter is CIBLEN-TOIN and stored in tmp1
                lda ciblen              ; LSB of counter
                sec
                sbc toin
                sta tmp1
                lda ciblen+1            ; MSB
                sbc toin+1
                sta tmp1+1

                ; However, TOIN is an index and CIBLEN is a length, so we
                ; have to subtract one
                lda tmp1
                beq +
                dec tmp1+1
*               dec tmp1

                ; We walk through the characters starting at CIB+TOIN, so we
                ; save a temp version of that in tmp2
                lda cib
                clc
                adc toin
                sta tmp2                ; LSB of first character
                lda cib+1
                adc toin+1
                sta tmp2+1              ; MSB

_skip_loop:
                lda (tmp2)              ; work copy of cib
                cmp #AscSP
                bne _char_found
                
                ; Char is still a space, continue
                inc tmp2
                bne +
                inc tmp2+1
*
                ; Adjust counter
                lda tmp1
                bne +
                dec tmp1+1
*               dec tmp1

                lda tmp1
                ora tmp1+1
                bne _skip_loop          ; fall through if empty line

_empty_line:
                ; Neither the ANSI Forth nor the Gforth documentation say
                ; what to return as an address if a string with only 
                ; spaces is given. For speed reasons, we just return junk
                ; NOS, with the TOS zero as per standard
                dex
                dex
                dex
                dex

                stz 0,x                 ; TOS is zero
                stz 1,x

                jmp z_parse_name        ; skip over PARSE

_char_found:
                ; We arrive here with tmp2 pointing to the first non-space
                ; character. This is where the word really starts, so 
                ; we use it to calculate the new >IN by subtracting
                lda tmp2
                sec
                sbc cib
                sta toin
                lda tmp2+1
                sbc cib+1
                sta toin+1

                ; prepare Data Stack for PARSE by adding space
                ; as the delimiter
                dex
                dex

                lda #AscSP
                sta 0,x
                stz 1,x                 ; paranoid, now ( "name" c ) 
.scend

; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
; ## "parse"  src: ANSI core ext  b: TBA  c: TBA  status: coded
        ; """Find word in input string delimited by character given. Do not
        ; skip leading delimiters -- this is the main difference to PARSE-NAME.
        ; PARSE and PARSE-NAME replace WORD in modern systems. ANSI discussion
        ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE 
        ;
        ;     cib  cib+toin   cib+ciblen
        ;      v      v            v
        ;     |###################|  
        ;                           
        ;     |------>|  toin (>IN)
        ;     |------------------->|  ciblen
        ;
        ; The input string is stored starting at the address in the Current
        ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
        ; for the delimiter, TOIN (>IN) points to the where we currently are.
        ; Since PARSE does not skip leading delimiters, we assume we are on a
        ; useful string if there are any characters at all. As with
        ; PARSE-NAME, we must be able to handle strings with a length of
        ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
        ; """
.scope
xt_parse:
                cpx #dsp0-1
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; If the input buffer is empty, we just return
                lda ciblen
                ora ciblen+1
                beq _abort_parse
                
                ; If the pointer >IN is larger or equal to the length of
                ; the input buffer (CIBLEN), the line is done. Put
                ; differently, we only continue if >IN is smaller than
                ; CIBLEN
                lda toin+1              ; MSB
                cmp ciblen+1
                bcc _go_parse           ; unsigned comparison

                lda toin                ; LSB
                cmp ciblen
                bcc _go_parse

_abort_parse:
                ; Sorry, this line is over
                dex
                dex
                stz 0,x
                stz 1,x

                bra _done
_go_parse:
                ; We actually have work to do. Save the delimiter
                lda 0,x
                sta tmptos

               ; We can now prepare the Data Stack for the return value
                dex
                dex
 
                ; tmp1 is CIB+TOIN, the beginning of the current string
                ; tmp2 is initially the same as tmp1, then the work index
                ; tmp3 is CIB+CIBLEN, one char past the end of the string
                
                ; Calculate the beginning of the string, which is also the
                ; address to return
                lda cib
                clc
                adc toin        ; LSB
                sta tmp1
                sta tmp2
                sta 2,x
                
                lda cib+1
                adc toin+1      ; MSB
                sta tmp1+1
                sta tmp2+1
                sta 3,x

                ; Calculate the address where the input buffer ends plus 1, so
                ; we can compare it with TOIN, which is an index
                lda cib
                clc
                adc ciblen
                sta tmp3
                lda cib+1
                adc ciblen+1
                sta tmp3+1

                ; Initialize the offset we use to adjust EOL or found delimiter
                stz tmptos+1
_loop:
                ; If we are at the end of the string, quit
                lda tmp2
                cmp tmp3
                bne _not_empty

                lda tmp2+1
                cmp tmp3+1
                beq _eol
_not_empty:
                ; We have to do this the hard way
                lda (tmp2)
                cmp tmptos
                beq _found_delimiter

                ; Not a delimiter, next character
                inc tmp2
                bne _loop
                inc tmp2+1
                bra _loop

_found_delimiter:
                ; Increase the offset: If we've found a delimiter, we want
                ; TOIN to point to the character after it, not the delimiter
                ; itself
                inc tmptos+1
_eol:
                ; The length of the new string is tmp2-tmp1
                lda tmp2
                sec
                sbc tmp1
                sta 0,x

                lda tmp2+1
                sbc tmp1+1
                sta 1,x

                ; The new offset is tmp2-cib
                lda tmp2
                sec
                sbc cib
                sta toin
                lda tmp2+1
                sbc cib+1
                sta toin+1

                ; Add in the delimiter
                lda toin
                clc
                adc tmptos+1
                sta toin
                lda toin+1
                adc #0          ; we only need the carry
                sta toin+1
_done:
z_parse_name:
z_parse:        rts
.scend


; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
; ## "pick"  src: ANSI core ext  b: TBA  c: TBA  status: coded
        ; """Take the u-th element out of the stack and put it on TOS,
        ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
        ; OVER. Note that using PICK is considered poor coding form. Also note
        ; that FIG Forth has a different behavior for PICK than ANS Forth. 
        ; """
.scope
xt_pick:
                ; Checking for underflow is difficult because it depends on
                ; which element we want to grab

                lda 0,x         ; we only use LSB (stack is small)
                asl
                clc
                adc #2
                tay

                stx tmp1
                stz tmp1+1

                lda (tmp1),y    ; MSB
                sta 0,x
                iny
                lda (tmp1),y    ; LSB
                sta 1,x
               
z_pick:         rts
.scend


; ## PLUS ( n n -- n ) "Add TOS and NOS"
; ## "+"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_plus:        
                cpx #dsp0-3
                bmi +
                lda #11         ; underflow
                jmp error
*
                clc
                lda 0,x         ; LSB
                adc 2,x
                sta 2,x

                lda 1,x         ; MSB. No CLC, conserve carry bit
                adc 3,x
                sta 3,x

                inx
                inx

z_plus:         rts



; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
; ## "+!"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_plus_store:
                cpx #dsp0-3
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; move address to tmp1 so we can work with it
                lda 0,x
                sta tmp1
                lda 1,x
                sta tmp1+1

                ldy #0          ; LSB
                lda (tmp1),y
                clc
                adc 2,x
                sta (tmp1),y

                iny             ; MSB
                lda (tmp1),y
                adc 3,x
                sta (tmp1),y

                inx
                inx
                inx
                inx
                
z_plus_store:   rts


; ## POSTPONE ( -- ) "<TBA>"
; ## "postpone"  src: ANSI core  b: TBA  c: TBA  status: TBA
        ; """Add the compilation behavior of a word to a new word at
        ; compile time. If the word that follows it is immediate, include
        ; it so that it will be compiled when the word being defined is
        ; itself used for a new word. Tricky, but very useful. Because
        ; POSTPONE expects a word (not an xt) in the input stream (not
        ; on the Data Stack). This means we cannot build words with
        ; "jsr xt_postpone, jsr <word>" directly.
        ; """
.scope
xt_postpone:
                jsr xt_parse_name               ; ( -- addr n )

                ; if there was no word provided, complain and quit
                lda 0,x
                ora 1,x
                bne +

                lda #6          ; no name
                jmp error
*
                jsr xt_find_name                ; ( -- nt | 0 )

                ; if word not in Dictionary, complain and quit
                bne +
                lda #12         ; no name
                jmp error
*
                ; keep a copy of nt for later
                lda 0,x
                sta tmp1
                lda 1,x
                sta tmp1+1

                ; We need the xt instead of the nt
                jsr xt_name_to_int              ; ( nt -- xt ) 

                ; See if this is an immediate word. This is easier
                ; with nt than with xt. The status byte of the word
                ; is nt+1
                inc tmp1
                bne +
                inc tmp1+1
*
                lda (tmp1)
                and #IM         ; mask all but Intermediate flag
                beq _not_immediate

                ; we're immediate, so instead of executing it right now, we
                ; compile it. xt is TOS, so this is easy. The RTS at the end
                ; takes us back to the original caller
                jsr xt_compile_comma
                bra _done

_not_immediate:
                ; This is not an immediate word, so we enact "deferred
                ; compilation" by including ' <NAME> COMPILE, which we do by
                ; compiling the run-time routine of LITERAL, the xt itself, and
                ; a subroutine jump to COMPILE,
                lda #>literal_runtime   ; MSB first
                pha
                lda #<literal_runtime
                pha
                jsr cmpl_subroutine

                ; The xt is TOS. We can't use COMPILE, here because it might
                ; decided to do something silly like compile it as a native word
                ; and ruin everything
                jsr xt_comma

                ; Last, compile COMPILE, 
                lda #>xt_compile_comma  ; MSB first
                pha
                lda #<xt_compile_comma 
                pha
                jsr cmpl_subroutine
_done:
z_postpone:     rts
.scend


; ## QUESTION ( addr -- ) "Print content of a variable"
; ## "?"  src: ANSI tools  b: 6  c: TBA  status: coded
        ; """Only used interactively. Since humans are so slow, we
        ; save size and just go for the subroutine jumps
        ; """
xt_question:    
                jsr xt_fetch
                jsr xt_dot

z_question:     rts


; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
; ## "?dup"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_question_dup:
                cpx #dsp0-1
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; Check if TOS is zero
                lda 0,x
                ora 1,x
                beq _done

                ; not zero, duplicate
                dex
                dex
                lda 2,x
                sta 0,x
                lda 3,x
                sta 1,x
_done:
z_question_dup: rts
.scend


; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
; ## "r@"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """We follow Gforth in that this word is not compiled only, because
        ; it can be interesting to know what the top of R is in an interactive
        ; setting. However, this causes all kinds of problems if we try
        ; to natively compile the word, so it is flagged NN even though it is
        ; actually short enough to make that reasonable.
        ; """
        ; TODO consider special case in COMPILE,
xt_r_fetch:     
                ; get the return address
                ply             ; LSB
                sty tmp1
                ply             ; MSB

                ; get the actual top of Return Stack
                dex
                dex

                pla             ; LSB
                sta 0,x
                pla             ; MSB
                sta 1,x

                ; now we have to put that value back
                pha
                lda 0,x
                pha

                ; restore return value
                phy             ; MSB
                ldy tmp1
                phy             ; LSB

z_r_fetch:      rts


; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
; ## "r>"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Move Top of Return Stack to Top of Data Stack. We have to move
        ; the RTS address out of the way first. This word is handled
        ; differently for native and and subroutine compilation, see COMPILE,
        ; This is a compile-only word
        ; """

xt_r_from:
                dex
                dex

                ; Rescue the address of the return jump that is currently
                ; on top of the Return Stack. If this word is natively 
                ; compiled, this is a total waste of time
                pla             ; LSB
                sta tmptos
                ply             ; MSB

                ; --- cut for native coding ---

                ; now we can access the actual data
                pla             ; LSB
                sta 0,x
                pla             ; MSB
                sta 1,x

                ; --- cut for native coding ---
                
                ; restore the return address
                phy             ; MSB
                lda tmptos
                pha             ; LSB

z_r_from:       rts



; ## RECURSE ( -- ) "<TBA>"
; ## "recurse"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_recurse:     nop
z_recurse:      rts
.scend


; ## REFILL ( -- f ) "Refill the input buffer"
; ## "refill"  src: ANSI core ext  b: TBA  c: TBA  status: coded
        ; """Attempt to fill the input buffer from the input source, returning
        ; a true flag if successful. When the input source is the user input
        ; device, attempt to receive input into the terminal input buffer. If
        ; successful, make the result the input buffer, set >IN to zero, and
        ; return true. Receipt of a line containing no characters is considered
        ; successful. If there is no input available from the current input
        ; source, return false. When the input source is a string from EVALUATE,
        ; return false and perform no other action." See
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
        ; and Conklin & Rather p. 156
        ; """"
.scope
xt_refill:      
                ; Get input source from SOURCE-ID. We don't have blocks in this
                ; version, or else we would have to check BLK first. This is an
                ; optimized version of a subroutine jump to SOURCE-ID
                lda insrc               ; cheat: We only check LSB
                bne _src_not_kbd

                ; SOURCE-ID of zero means we're getting stuff from the keyboard
                ; with ACCEPT, which wants the address of the current input
                ; buffer NOS and the max number of characters to accept TOS
                dex
                dex
                dex
                dex

                lda cib                 ; address of CIB is NOS
                sta 2,x
                lda cib+1
                sta 3,x

                stz ciblen              ; go in with empty buffer
                stz ciblen+1
                
                lda #bsize              ; max number of chars is TOS
                sta 0,x
                stz 1,x                 ; cheat: We only accept max 255

                jsr xt_accept           ; ( addr n1 -- n2)

                ; ACCEPT returns the number of characters accepted, which
                ; belong in CIBLEN
                lda 0,x
                sta ciblen
                lda 1,x
                sta ciblen+1            ; though we only accept 255 chars
                
                lda #$ff                ; overwrite with TRUE flag
                sta 0,x
                sta 1,x

                bra _done

_src_not_kbd:
                ; If SOURCE-ID doesn't return a zero, it must be a string in
                ; memory or a file (remember, no blocks in this version).
                ; If source is a string, we were given the flag -1 ($ffff)
                inc
                bne _src_not_string

                ; Simply return FALSE flag as per specification
                dex
                dex
                stz 0,x
                stz 1,x

                bra z_refill

_src_not_string:
                ; Since we don't have blocks, this must mean that we are trying
                ; to read from a file. However, we don't have files yet, so we 
                ; report an error and jump to ABORT.
                lda #9                  ; error code for illegal source id
                jmp error

_done:
z_refill:       rts
.scend


; ## REPEAT ( -- ) "<TBA>"
; ## "repeat"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_repeat:      nop
z_repeat:       rts
.scend


; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
; ## "]"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """This is an immediate word."""
xt_right_bracket:
                lda #$ff
                sta state
                sta state+1
z_right_bracket:
                rts


; ## RIGHT_PAREN ( -- ) "<TBA>"
; ## ")"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_right_paren: nop
z_right_paren:  rts
.scend


; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
; ## "rot"  src: ANSI core  b: 28  c: TBA  status: coded
        ; """Remember "R for 'Revolution' - the bottom entry comes out
        ; on top!
        ; """
.scope
xt_rot:         
                cpx #dsp0-5
                bmi +
                lda #11         ; underflow
                jmp error 
*
                lda 5,x         ; MSB first
                tay
                lda 3,x
                sta 5,x
                lda 1,x
                sta 3,x
                tya
                sta 1,x

                lda 4,x         ; LSB next 
                tay
                lda 2,x
                sta 4,x
                lda 0,x
                sta 2,x
                tya
                sta 0,x

z_rot:          rts
.scend


; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
; ## "rshift"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_rshift:      
                ; We shift maximal by 16 bits, mask everything else
                lda 0,x
                and #%00001111
                beq _done               ; if 0 shifts, quit

                tay
_loop:
                lsr 3,x
                ror 2,x
                dey
                bne _loop
_done:
                inx
                inx

z_rshift:       rts


; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
; ## "s""  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Store address and length of string given, returning ( addr u ).
        ; ANSI core claims this is compile-only, but the file set expands it
        ; to be interpreted, so it is a state-sensitive word, which in theory
        ; are evil. We follow general usage. Can also be realized as 
        ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
        ; but it is used so much we want it in code. Note we limit strings
        ; to a length of 255 chars for this routine
        ; """
.scope
xt_s_quote:
                dex
                dex

                ; First, find the end of the string and save it
                lda #$22                ; ASCII for "
                sta 0,x
                stz 1,x                 ; paranoid

                jsr xt_parse            ; ( "string" -- addr u )

                ; if we were given an empty string, just leave
                lda 0,x
                ora 1,x
                bne +

                ; Zero length string, dump stack and run
                inx
                inx
                inx
                inx
                bra _done
*
                ; What happens next depends on the state (which is bad, but
                ; that's the way it works at the moment). If we are
                ; interpretating, we save the string to a transient buffer
                ; and return that address (used for file calls, see
                ; https://forth-standard.org/standard/file/Sq . If we're
                ; compiling, we just need SLITERAL
                lda state
                ora state+1             ; paranoid
                beq _interpreted

                jsr xt_sliteral         ; ( addr u -- )
                bra _done
_interpreted:
                ; We should move this string to a safe place. This is a pain
                ; on an 8-bit machine, even though we're going to limit this
                ; to 255 characters
                lda 2,x                 ; current address of string
                sta tmp1
                lda 3,x
                sta tmp1+1

                lda cp                  ; HERE in quicker
                sta tmp2
                lda cp+1
                sta tmp2+1

                ldy 0,x                ; length of string
_loop:
                dey
                lda (tmp1),y
                sta (tmp2),y
                bne _loop

                ; We can keep the length of the string in TOS, but
                ; need to replace the address in NOS by the new one
                lda cp
                sta 2,x
                lda cp+1
                sta 3,x

                ; Adjust CP to point past the string
                lda 0,x
                clc
                adc cp
                sta cp
                lda cp+1
                adc #0                  ; only care about the carry
                sta cp+1
_done:
z_s_quote:      rts
.scend

; ## S_TO_D ( d -- n ) "Convert single cell number to double cell"
; ## "s>d"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_s_to_d:
                dex
                dex
                stz 0,x
                stz 1,x

                lda 2,x
                bpl _done

                ; negative, extend sign
                dec 0,x
                dec 1,x
_done:                
z_s_to_d:       rts
.scend


; ## SEMICOLON ( -- ) "End compilation of new word"
; ## ";"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """End the compilation of a new word into the Dictionary. When we
        ; enter this, WORKWORD is pointing to the nt_ of this word in the
        ; Dictionary, DP to the previous word, and CP to the next free byte.
        ; A Forth definition would be (see "Starting Forth"):
        ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE
        ; """
.scope
xt_semicolon:
                ; CP is the byte that will be the address we use in the
                ; header as the end-of-compile address (z_word). This is
                ; six bytes down from the header
                ldy #6
                lda cp
                sta (workword),y
                iny
                lda cp+1
                sta (workword),y

                ; Allocate one further byte and save the RTS instruction
                ; there
                lda #$60                ; opcode for RTS
                sta (cp)
                inc cp
                bne +
                inc cp+1
*
                ; Save beginning of our word as new last word in the
                ; Dictionary
                lda workword
                sta dp
                lda workword+1
                sta dp+1

                ; Word definition complete. Return compile flag to zero
                ; to return to interpret mode
                stz state
                stz state+1

z_semicolon:    rts
.scend


; ## SIGN ( n -- ) "Add minus to pictured output"
; ## "sign"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Code based on 
        ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
        ; Original Forth code is   0< IF ASCII - HOLD THEN 
        ; """
.scope
xt_sign:        
                lda 1,x         ; check MSB of TOS
                bmi _minus

                inx
                inx

                bra _done
_minus:
                lda #$2d        ; ASCII for "-"
                sta 0,x         ; overwrite TOS
                stz 1,x         ; paranoid

                jsr xt_hold
_done:
z_sign:         rts
.scend


; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
; ## "sliteral"  src: ANSI string  b: TBA  c: TBA  status: TBA
        ; """Currently, we only copy strings of up to 255 characters
        ; """
.scope
xt_sliteral:
                cpx #dsp0-3
                bmi +
                lda #11
                jmp error
*
                ; We can't assume that ( addr u ) of the current string is in
                ; a stable area, so we first have to move them to safety. Since
                ; CP points to where the interpreter expects to be able to
                ; continue in the code, we have to jump over the string. We use
                ; JMP instead of BRA so we can use longer strings
                
                ; Store length of source string in tmptos
                lda 0,x
                sta tmptos
                lda 1,x
                sta tmptos+1

                ; Store address of source string in tmp1
                lda 2,x
                sta tmp1
                lda 3,x
                sta tmp1+1

                ; Store opcode for JMP
                lda #$4c
                sta (cp)
                inc cp
                bne +
                inc cp+1
*
                ; Our jump target is CP + 2 (for the length of the jump
                ; instruction itself ) + the length of the string
                lda tmptos
                clc
                adc cp
                adc #2
                sta (cp)        ; LSB
                lda tmptos+1
                adc cp+1
                ldy #1
                sta (cp),y      ; MSB

                ; Move past the jump instruction to where the string will
                ; start
                clc
                lda cp
                adc #2
                sta cp
                lda cp+1
                adc #0          ; only for the carry
                sta cp+1

                ; Now we can savely copy the string. Note currently we
                ; can only copy strings of up to 255 chars length
                ldy tmptos
                dey             ; offset is one less than length
_loop:
                lda (tmp1),y
                sta (cp),y
                dey
                bpl _loop

                ; Keep old CP as new address of string
                lda cp
                sta tmp3
                lda cp+1
                sta tmp3+1

                ; Update CP
                clc
                lda cp
                adc tmptos
                sta cp
                lda cp+1
                adc tmptos+1
                sta cp+1

                ; Compile a subroutine jump to the runtime of SLITERAL that
                ; pushes the new ( addr u ) pair to the Data Stack.
                ; When we're done, the code will look like this:
 
                ; xt -->    jmp a
                ;           <string data bytes>
                ;  a -->    jsr sliteral_runtime
                ;           <string address>
                ;           <string length>
                ; rts -->

                ; This means we'll have to adjust the return address for two
                ; cells, not just one
                lda #>sliteral_runtime  ; MSB
                pha
                lda #<sliteral_runtime  ; LSB
                pha

                jsr cmpl_subroutine

                ; We want to have the address end up as NOS and the length
                ; as TOS, so we store the address first
                lda tmp3+1              ; address MSB
                pha
                lda tmp3                ; address LSB
                pha
                jsr cmpl_word

                lda tmptos+1            ; length MSB
                pha
                lda tmptos              ; length LSB
                pha
                jsr cmpl_word

                ; clean up and leave
                inx
                inx
                inx
                inx
                
z_sliteral:     rts
.scend

sliteral_runtime:
.scope
        ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
        ; the Data Stack. We arrive here with the return address as the
        ; top of Return Stack, which points to the address of the string
        ; """
                dex
                dex
                dex
                dex

                ; Get the address of the string address off the stack and
                ; increase by one because of the RTS mechanics
                pla
                sta tmp1        ; LSB of address
                pla
                sta tmp1+1      ; MSB of address

                ; Walk through both and save them
                ldy #1          ; adjust for JSR/RTS mechanics on 65c02

                lda (tmp1),y
                sta 2,x         ; LSB of address
                iny

                lda (tmp1),y
                sta 3,x         ; MSB of address
                iny

                lda (tmp1),y
                sta 0,x         ; LSB of length
                iny

                lda (tmp1),y
                sta 1,x         ; MSB of length
                
                ; restore return address
                clc
                lda tmp1
                adc #4
                tay             ; LSB
                lda tmp1+1
                adc #0          ; we only need carry
                pha             ; MSB
                phy             

                rts
.scend


; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
; ## "sm/rem"  src: ANSI core  b: TBA  c: TBA  status: tested
        ; """; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
        ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq Forth:
        ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
        ; R> ?NEGATE SWAP
        ; """
.scope
xt_sm_slash_rem:
                ; push MSB of high cell of d to Data Stack so we can check
                ; its sign later
                lda 3,x
                pha

                ; XOR the MSB of the high cell of d and n1 so we figure out
                ; its sign later as well
                lda 1,x
                eor 3,x
                pha

                ; Prepare division by getting absolute of n1 and d
                jsr xt_abs
                inx             ; pretend we pushed n1 to R
                inx

                jsr xt_dabs
                dex
                dex

                jsr xt_um_slash_mod     ; UM/MOD

                ; if the XOR compiled above is negative, negate the
                ; quotient (n3)
                pla
                bpl +
                jsr xt_negate
*
                ; if d was negative, negate the remainder (n2)
                pla
                bpl _done

                inx             ; pretend we pushed quotient to R
                inx
                jsr xt_negate
                dex
                dex

_done:
z_sm_slash_rem: rts
.scend


; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
; ## "source"  src: ANSI core  b: 20  c: TBA  status: coded
xt_source:      
                ; add address
                dex
                dex
                lda cib
                sta 0,x
                lda cib+1
                sta 1,x

                ; add size
                dex
                dex
                lda ciblen
                sta 0,x
                lda ciblen+1    ; paranoid, should be zero
                sta 1,x

z_source:       rts


; ## SOURCE_ID ( -- n ) "Return source identifier"
; ## "source-id"  src: ANSI core ext  b: 10  c: TBA  status: coded
        ; """Identify the input source unless it is a block (s. Conklin &
        ; Rather p. 156). Since we don't have blocks (yet), this will give
        ; the input source: 0 is keyboard, -1 (0ffff) is character string,
        ; and a text file gives the fileid.
        ; """
xt_source_id:   
                dex
                dex
                lda insrc
                sta 0,x
                lda insrc+1
                sta 1,x

z_source_id:    rts


; ## SPACE ( -- ) "Print a single space"
; ## "space"  src: ANSI core  b: 5  c: TBA  status: coded
xt_space:      
                lda #AscSP
                jsr emit_a

z_space:        rts


; ## SPACES ( u -- ) "Print a number of spaces"
; ## "spaces"  src: ANSI core  b: TBA  c: TBA  status: coded
; TODO test with TOS > 256
.scope
xt_spaces:      
                ; catch any zero in TOS fast
                lda 0,x
                ora 1,x
                beq _done

                ; usually we're only going to print far less than 256 spaces,
                ; so we create a quick loop for that. Short loop could be realized
                ; as a separate subroutine, but unless we're really pressed for
                ; memory at some point, this is faster
                lda #AscSP
                ldy 1,x
                bne _lots_of_spaces

                ldy 0,x
_quick_loop:
                ; we reach here knowing that there must be a number that is not
                ; zero in the TOS
                jsr emit_a
                dey
                beq _done
                bra _quick_loop

_lots_of_spaces:
                ; we go through the first loop once to get rid of the lower
                ; counter byte. This could be zero
                ldy 0,x

_first_slow_loop:
                beq _slow_outer_loop
                jsr emit_a
                dey
                bra _first_slow_loop
                
_slow_outer_loop:
                ; we arrive here knowing that the MSB of TOS cannot be a zero
                ldy #00                

_slow_inner_loop:
                jsr emit_a 
                dey
                bne _slow_inner_loop

                dec 1,x
                bne _slow_outer_loop

_done:
                inx             ; drop
                inx

z_spaces:       rts 
.scend


; ## STAR ( n n -- n ) "16*16 --> 16 "
; ## "*"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Multiply two signed 16 bit numbers, returning a 16 bit result.
        ; This is nothing  more than UM* DROP
        ; """
.scope
xt_star:
                cpx #dsp0-3
                bmi +
                lda #11                 ; underflow
                jmp error
*
                jsr xt_um_star
                inx
                inx

z_star:         rts
.scend


; ## STATE ( -- addr ) "Return the address of compilation state flag"
; ## "state"  src: ANSI core  b: 10  c: TBA  status: coded
        ; """STATE is true when in compilation state, false otherwise. Note
        ; we do not return the state itself, but only the address where
        ; it lives. The state should not be changed directly by the user; see
        ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
        ; """
xt_state:       
                dex
                dex
                lda #<state
                sta 0,x
                lda #>state
                sta 1,x

z_state:        rts


; ## STORE ( n addr -- ) "Store TOS in memory"
; ## "!"  src: ANSI core  b: 18  c: TBA  status: tested
.scope
xt_store:
                cpx #dsp0-3
                bmi +
                lda #11         ; underflow
                jmp error
*
                lda 2,x         ; LSB
                sta (0,x)

                inc 0,x
                bne +
                inc 1,x
*
                lda 3,x         ; MSB
                sta (0,x)

                inx             ; 2DROP
                inx
                inx
                inx

z_store:        rts
.scend


; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
; ## "swap"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_swap:        
.scope
                cpx #dsp0-3
                bmi +

                lda #11         ; underflow
                jsr error 
*
                lda 0,x         ; LSB
                ldy 2,x
                sta 2,x
                sty 0,x

                lda 1,x         ; MSB
                ldy 3,x
                sta 3,x
                sty 1,x

z_swap:         rts
.scend


; ## THEN ( -- ) "<TBA>"
; ## "then"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_then:        nop
z_then:         rts
.scend


; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
; ## "'"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_tick:        
                jsr xt_parse_name       ; ( -- addr u )

                ; if we got a zero, there was a problem getting the
                ; name of the word
                lda 0,x
                ora 1,x
                bne +

                lda #6                  ; parsing failure
                jmp error
*
                jsr xt_find_name        ; ( addr u -- nt )

                ; If we didn't find the word in the Dictionary, abort
                lda 0,x
                ora 1,x
                bne +

                lda #12                 ; word not defined
                jmp error
*
                jsr xt_name_to_int      ; ( nt -- xt ) 

z_tick:         rts
.scend


; ## TO ( -- ) "<TBA>"
; ## "to"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_to:          nop
z_to:           rts
.scend


; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
; ## ">body"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Given a word's execution token (xt), return the address of the
        ; start of that word's parameter field (PFA). This is the address that
        ; HERE would return right after CREATE. This is a difficult word for
        ; STC Forths, because most words don't actually have a Code Field Area
        ; (CFA) to skip. We solve this by testing if the first three bytes of
        ; the body (that starts at xt) are subroutine jumps to DOVAR, DOCONST
        ; or DODOES
        ; """
.scope
xt_to_body:
                cpx #dsp0-1
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; In the header, xt already points to the CFA, which
                ; CREATE fills with a JSR to DOVAR
                lda (0,x)
                cmp #$20                ; opcode for JSR
                bne _no_jsr

                ; Okay, so we found a JSR instruction. But is it one
                ; of the right ones?
                lda 0,x
                sta tmp1
                lda 1,x
                sta tmp1+1

                ldy# 1

                lda (tmp1),y            ; get LSB of address after JSR
                cmp #<dovar             ; LSB of DOVAR?
                bne _check_doconst
                iny
                lda (tmp1),y            ; LSB was good, what about MSB?
                cmp #>dovar
                beq _got_cfa

                dey                     ; go back to first address byte
_check_doconst:
                ; Wasn't DOVAR, how about DOCONST
                lda (tmp1),y
                cmp #<doconst
                bne _check_dodefer
                iny
                lda (tmp1),y
                cmp #>doconst
                beq _got_cfa

                dey
_check_dodefer:
                ; Wasn't DOCONST, how about DODEFER
                lda (tmp1),y
                cmp #<dodefer
                bne _check_dodoes
                iny
                lda (tmp1),y
                cmp #>dodefer
                beq _got_cfa

                dey
_check_dodoes:
                ; Wasn't DODEFER either, how about DODOES
                lda (tmp1),y
                cmp #<dodoes
                bne _no_jsr
                iny
                lda (tmp1),y
                cmp #>dodoes
                bne _no_jsr
_got_cfa:
                ; We've got a DOVAR, DOCONST, DODEFER or DODOES, so we add three
                ; to the xt 
                clc
                lda 0,x         ; LSB
                adc #3
                sta 0,x
                lda 1,x         ; MSB
                adc #0          ; we conly care about the carry
                sta 1,x
_no_jsr:
                ; If we don't have a subroutine jump to one of the right
                ; addresses, the xt already points to the parameter field
                ; (PFA) because there is no CFA - and we're already done

z_to_body:      rts
.scend


; ## TO_IN ( -- addr ) "Return address of the input pointer"
; ## ">in"  src: ANSI core  b: 10  c: TBA  status: coded
xt_to_in:       
                dex
                dex

                lda #<toin
                sta 0,x
                lda #>toin      ; paranoid, should be zero
                sta 1,x

z_to_in:        rts


; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
; ## ">number"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Convert a string to a double number. Logic here is based on the
        ; routine by Phil Burk of the same name in pForth, see
        ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; for the original Forth code. We arrive here from NUMBER which has
        ; made sure that we don't have to deal with a sign and we don't have
        ; to deal with a dot as a last character that signalizes double -
        ; this should be a pure number string. This routine calles UM*, which
        ; uses tmp1, tmp2 and tmp3, so we cannot access any of those.
        
        ; For the math routine, we move the inputs to the scratchpad to
        ; avoid having to fool around with the Data Stack. 
        ;
        ;     +-----+-----+-----+-----+-----+-----+-----+-----+
        ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
        ;     |           |           |           |           |
        ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
        ;     +-----+-----+-----+-----+-----+-----+-----+-----+

        ; The math routine works by converting one character to its
        ; numerical value (N) via DIGIT? and storing it in S+4 for
        ; the moment. We then multiply the UD-HI value with the radix
        ; (from BASE) using UM*, which returns a double-cell result. We
        ; discard the high cell of that result (UD-HI-HI) and store the
        ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
        ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
        ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
        ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
        ; storing the result back in S and S+2, before we start another
        ; round with it as the new UD-LO and UD-HI.
        ; """

.scope
xt_to_number:
                ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
                ; After this step, the original ud-lo and ud-hi will still be on
                ; the Data Stack, but will be ignored and later overwritten
                ; If >NUMBER is called by NUMBER, these should be all zeros
                lda 6,x         ; ud-lo LSB
                sta scratch
                lda 7,x         ; ud-lo MSB
                sta scratch+1

                lda 4,x         ; ud-hi LSB
                sta scratch+2
                lda 5,x         ; ud-hi MSB
                sta scratch+3

                ; Push down one on the Data Stack to use TOS for character
                ; conversion ( ud-lo ud-hi addr u x )
                dex
                dex

_loop:
                ; Get one character based on address
                lda (4,x)
                sta 0,x         ; ( ud-lo ud-hi addr u char )
                stz 1,x         ; paranoid

                jsr xt_digit_question   ; ( char -- n -1 | char 0 )

                ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
                ; check the flag. If it is zero, we return what we have and
                ; let the caller (usually NUMBER) complain
                lda 0,x
                bne _digit_ok

                inx
                inx
                bra _done       ; ( ud-lo ud-hi addr u char ) 

_digit_ok:
                ; Conversion was successful. We arrive here with
                ; ( ud-lo ud-hi addr u n -1 ) and can start the
                ; math routine

                ; Save n so we don't have to fool around with the
                ; Data Stack
                lda 2,x
                sta scratch+4
                lda 3,x
                sta scratch+5

                ; Now multiply ud-hi (the one in the scratchpad, not the
                ; original one on the Data Stack) with the radix from BASE.
                ; We can clobber TOS and NOS because we saved n
                lda scratch+2
                sta 2,x         ; NOS
                lda scratch+3
                sta 3,x

                lda base
                sta 0,x         ; TOS
                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)

                ; UM* returns a double-celled number
                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )

                ; Move ud-hi-lo to safety
                lda 2,x         ; ud-hi-lo
                sta scratch+6
                lda 3,x
                sta scratch+7

                ; Now we multiply ud-lo, overwriting the stack entries
                lda scratch
                sta 2,x
                lda scratch+1
                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )

                lda base
                sta 0,x         
                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )

                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )

                lda 0,x
                sta scratch+2
                lda 1,x
                sta scratch+3

                lda 2,x
                sta scratch
                lda 3,x
                sta scratch+1

                ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
                ; both in the scratch pad
                clc
                lda scratch     ; ud-lo LSB
                adc scratch+4   ; n LSB
                sta scratch     ; this is the new ud-lo
                lda scratch+1   ; ud-lo MSB
                adc scratch+5   ; n MSB
                sta scratch+1

                lda scratch+2   ; LSB
                adc scratch+6
                sta scratch+2   ; this is the new ud-hi
                lda scratch+3   ; MSB
                adc scratch+7
                sta scratch+3

                ; Clean up: Get rid of one of the two top elements on 
                ; the Data Stack. We don't really care which one
                inx
                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )

                ; One character down. Move address up
                inc 4,x
                bne +
                inc 5,x
*
                ; Decrease counter
                dec 2,x
                bne _loop

_done:               
                ; Counter has reached zero or we have an error. In both
                ; cases, we clean up the Data Stack and return. Error gives
                ; us ( ud-lo ud-hi addr u char ), regular end is
                ; ( ud-lo ud-hi addr u ud-lo )
                inx
                inx             ; ( ud-lo ud-hi addr u )

                ; The new ud-lo and ud-hi are still on the scratch pad
                lda scratch     ; new ud-lo
                sta 6,x
                lda scratch+1
                sta 7,x

                lda scratch+2
                sta 4,x
                lda scratch+3
                sta 5,x

z_to_number:    rts
.scend


; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
; ## ">r"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """This word is handled differently for native and for 
        ; subroutine coding, see COMPILE, . This is a complile-only
        ; word
        ; """
xt_to_r:
                ; Save the return address. If this word is natively
                ; coded, this is a complete waste of cycles, but
                ; required for subroutine coding
                pla             ; LSB
                sta tmptos
                ply             ; MSB

                ; --- cut line for native coding ---
 
                ; now we can do the actual work
                lda 1,x         ; MSB
                pha
                lda 0,x         ; LSB
                pha

                ; --- cut line for native coding ---

                ; restore return address
                phy             ; MSB
                lda tmptos
                pha             ; LSB

                inx
                inx

z_to_r:         rts


; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
; ## "true"  src: ANSI core ext  b: 8  c: TBA  status: coded
xt_true:        dex
                dex
                lda #$ff
                sta 0,x
                sta 1,x

z_true:         rts


; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
; ## "tuck"  src: ANSI core ext  b: 24  c: TBA  status: coded
xt_tuck:        dex
                dex             ; ba- 

                lda 2,x
                sta 0,x         
                lda 3,x
                sta 1,x         ; baa

                ldy 4,x         ; using Y saves one instruction
                sty 2,x         ; because TOS MSB stays in A
                ldy 5,x
                sty 3,x         ; bba

                sta 5,x         
                lda 0,x
                sta 4,x         ; aba

z_tuck:         rts


; ## TWO ( -- u ) "Push the number 2 to stack"
; ## "2"  src: Tali Forth  b: TBA  c: TBA  status: coded
xt_two:
                dex
                dex
                lda #2
                sta 0,x
                stz 1,x

z_two:          rts


; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
; ## "2drop"  src: ANSI core  b: 4  c: TBA  status: coded
.scope
xt_two_drop:    
                inx
                inx
                inx
                inx

z_two_drop:     rts
.scend


; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
; ## "2dup"  src: ANSI core  b: 20  c: TBA  status: coded
.scope
xt_two_dup:
                cpx #dsp0-3
                bmi +

                lda #11
                jmp error

*               dex
                dex
                dex
                dex

                lda 4,x         ; TOS
                sta 0,x
                lda 5,x
                sta 1,x

                lda 6,x         ; NOS
                sta 2,x
                lda 7,x
                sta 3,x

z_two_dup:      rts
.scend


; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
; ## "2over"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_two_over:
                cpx #dsp0-7
                bmi +
                lda #11
                jmp error
*
                dex
                dex
                dex
                dex

                lda 8,x
                sta 0,x

                lda 9,x
                sta 1,x

                lda 10,x
                sta 2,x

                lda 11,x
                sta 3,x

z_two_over:     rts
.scend


; ## TWO_R_FETCH ( -- ) "<TBA>"
; ## "2r@"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_two_r_fetch: nop
z_two_r_fetch:  rts
.scend

; ## TWO_R_FROM ( -- ) "<TBA>"
; ## "2r>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_two_r_from:  nop
z_two_r_from:   rts
.scend


; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
; ## "2*"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Also used for CELLS
        ; """
xt_two_star:
                cpx #dsp0-1
                bmi +
                lda #11         ; underflow
                jmp error
*
                asl 0,x
                rol 1,x
z_two_star:     rts


; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
; ## "2swap"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_two_swap:
                cpx #dsp0-7
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; 0 <-> 4
                lda 0,x
                ldy 4,x
                sta 4,x
                sty 0,x

                ; 1 <-> 5
                lda 1,x
                ldy 5,x
                sta 5,x
                sty 1,x

                ; 2 <-> 6
                lda 2,x
                ldy 6,x
                sta 6,x
                sty 2,x

                ; 3 <-> 7
                lda 3,x
                ldy 7,x
                sta 7,x
                sty 3,x
                
z_two_swap:     rts
.scend


; ## TWO_TO_R ( -- ) "<TBA>"
; ## "2>r"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_two_to_r:    nop
z_two_to_r:     rts
.scend

; ## TWO_VARIABLE ( -- ) "<TBA>"
; ## "2variable"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_two_variable:
                nop
z_two_variable: rts
.scend


; ## TYPE ( addr u -- ) "Print string"
; ## "type"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Works through EMIT to allow OUTPUT revectoring. Currently, only
        ; strings of up to 255 characters are printed
        ; """
.scope
xt_type:        
                cpx #dsp0-3
                bmi +
                lda #11         ; underflow
                jmp error
*
                ; skip if length is zero
                lda 0,x
                ora 1,x
                beq _done

                lda 2,x
                sta tmp1
                lda 3,x
                sta tmp1+1
                
                ; CPY doesn't have a mode to compare with 0,x so we have to do the
                ; loop the hard way
                ldy #0
                lda 0,x
                sta tmp2

_loop:
                lda (tmp1),y
                jsr emit_a              ; avoids stack foolery
                iny
                cpy tmp2
                bne _loop               ; fall through to _done

_done:
                inx
                inx
                inx
                inx

z_type:         rts
.scend


; ## UD_SLASH_MOD ( ud u -- rem ud ) "32/16 --> 32 Division"
; ## "ud/mod"  src: Gforth  b: TBA  c: TBA  status: coded
        ; """Divide double cell number by a single-cell number and return
        ; the quotient ud as TOS in double-cell form and remainder rem
        ; Based on code from pForth, which is in the public domain. Original
        ; Forth is  >R 0 R@ UM/MOD  ROT ROT R> UM/MOD ROT
        ; """
        ; TODO analyze and convert parts to assembler 
        ; TODO test this, some results seem fishy
.scope
xt_ud_slash_mod:
                jsr xt_to_r             ; >r
                jsr xt_zero             ; 0
                jsr xt_r_fetch          ; r@
                jsr xt_um_slash_mod     ; um/mod
                jsr xt_rot              ; rot
                jsr xt_rot              ; rot
                jsr xt_r_from           ; r>
                jsr xt_um_slash_mod     ; um/mod
                jsr xt_rot              ; rot

z_ud_slash_mod: rts
.scend


; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
; ## "um/mod"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Divide double cell number by single cell number, returning the
        ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
        ; This is the basic division operation all others use. Based on FIG
        ; Forth code, modified by Garth Wilson, see
        ; http://6502.org/source/integers/ummodfix/ummodfix.htm 
        ; This uses tmp1, tmp1+1, and tmptos
        ; """
.scope
xt_um_slash_mod:
                ; catch division by zero
                lda 0,x
                ora 1,x
                bne _not_zero

                lda #3          ; "Division by zero" error string
                jmp error

_not_zero: 
                ; We loop 17 times
                lda #17
                sta tmptos

_loop:
                ; rotate low cell of dividend one bit left (LSB)
                rol 4,x
                rol 5,x

                ; loop control
                dec tmptos
                beq _done

                ; rotate high cell of dividend one bit left (MSB)
                rol 2,x
                rol 3,x

                stz tmp1        ; store the bit we got from hi cell (MSB)
                rol tmp1

                ; subtract dividend hi cell minus divisor
                sec
                lda 2,x
                sbc 0,x
                sta tmp1+1
                lda 3,x
                sbc 1,x

                tay
                lda tmp1
                sbc #0
                bcc _loop

                ; make result new dividend high cell
                lda tmp1+1
                sta 2,x
                sty 3,x         ; used as temp storage

                bra _loop
_done:
                inx
                inx

                jsr xt_swap

z_um_slash_mod: rts
.scend


; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
; ## "um*"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Multiply two unsigned 16 bit numbers, producing a 32 bit result.
        ; This is based on modified FIG Forth code by Dr. Jefyll, see
        ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
        ; discussion. We don't use the system scratch pad (SYSPAD) for temp
        ; storage because >NUMBER uses it as well, but instead tmp1 to
        ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
        ; Old Forth versions such as FIG Forth call this U* 
        ;
        ; Consider switching to a table-supported version based on
        ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
        ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
        ; http://forum.6502.org/viewtopic.php?p=205#p205
        ; http://forum.6502.org/viewtopic.php?f=9&t=689
        ; """
.scope
xt_um_star:     
                ; to eliminate clc inside the loop, the value at 
                ; tmp1 is reduced by 1 in advance
                clc     
                lda 0,x         ; copy TOS to tmp2
                sbc #0
                sta tmp2

                lda 1,x
                sbc #0
                bcc _zero       ; is TOS zero?
                sta tmp2+1

                lda #0
                sta tmp1
                stx tmp3        ; tested for exit from outer loop
                dex
                dex
_outer_loop:
                ldy #8          ; counter inner loop
                lsr 4,x         ; think "2,x" then later "3,x"
_inner_loop:
                bcc _no_add
                sta tmp1+1      ; save time, don't CLC
                lda tmp1
                adc tmp2
                sta tmp1
                lda tmp1+1
                adc tmp2+1
_no_add:
                ror
                ror tmp1
                ror 4,x         ; think "2,x" then later "3,x"

                dey
                bne _inner_loop ; go back for one more shift?

                inx
                cpx tmp3
                bne _outer_loop ; go back for eight more shifts?

                ; all done, store high word of result
                sta 1,x
                lda tmp1
                sta 0,x
                bra _done
_zero:
                stz 2,x
                stz 3,x
_done:
z_um_star:      rts
.scend


; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
; ## "unloop"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Note that 6xPLA uses just as many bytes as a loop would
        ; """
.scope
xt_unloop: 
                ; Drop fudge number (limit/start from DO/?DO off the
                ; return stack
                pla
                pla
                pla

                ; Now drop the LEAVE address that was below them off
                ; the Return Stack as well
                pla
                pla

z_unloop:       rts
.scend


; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
; ## "unused"  src: ANSI core ext  b: 15  c: TBA  status: TBA
xt_unused:      
                dex
                dex

                lda #<cp_end
                sec
                sbc cp
                sta 0,x

                lda #>cp_end
                sbc cp+1
                sta 1,x
                
z_unused:       rts

; ## VALUE ( -- ) "<TBA>"
; ## "value"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_value:       nop
z_value:        rts
.scend


; ## VARIABLE ( "name" -- ) "Define a variable"
; ## "variable"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """There are various Forth definitions for this word, such as
        ; CREATE 1 CELLS ALLOT  or CREATE 0 ,  We use a variant of the
        ; second one so the variable is initialized to zero
        ; """
xt_variable:    
                ; we let CREATE do the heavy lifting
                jsr xt_create

                ; there is no "STZ (CP)" so we have to do this the hard
                ; way
                lda #0
                sta (cp)
                inc cp
                bne +
                inc cp+1
*
                sta (cp)
                inc cp
                bne +
*
                inc cp+1

                ; Now we need to adjust the length of the complete word by two
                jsr adjust_z
                
z_variable:     rts


; ## WORD ( char "name " -- caddr ) "Parse input stream"
; ## "word"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Obsolete parsing word included for backwards compatibility only.
        ; Do not use this, use PARSE or PARSE-NAME. Skips leading delimiters
        ; and copies word to storage area for a maximum size of 255 bytes.
        ; Returns the result as a counted string (requires COUNT to convert
        ; to modern format), and inserts a space after the string. See "Forth
        ; Programmer's Handbook" 3rd edition p. 159 and
        ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE 
        ; for discussions of why you shouldn't be using WORD anymore. Forth
        ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
        ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
        ; """
.scope
xt_word:
                cpx #dsp0-1
                bmi +
                lda #11                 ; underflow
                jmp error
*
                ; Skip over leading delimiters - this is like PARSE-NAME,
                ; but unlike PARSE
                ldy toin                ; >IN
_loop:
                cpy ciblen              ; quit if end of input
                beq _found_char
                lda (cib),y
                cmp 0,x                 ; ASCII of delimiter
                bne _found_char

                iny
                bra _loop
_found_char:
                ; Save index of where word starts
                sty toin

                ; The real work is done by parse
                jsr xt_parse            ; Returns ( addr u ) 

                ; Convert the modern ( addr u ) string format to obsolete
                ; ( caddr ) format. We just do this in the Dictionary
                lda 0,x
                sta (cp)                ; Save length of string
                pha                     ; Keep copy of length for later

                jsr xt_dup              ; ( addr u u )
                lda cp
                clc
                adc #1
                sta 2,x                 ; LSB of CP
                lda cp+1
                adc #0
                sta 3,x                 ; ( addr cp+1 u )
                
                jsr xt_move 

                ; Return caddr
                dex
                dex
                lda cp
                sta 0,x
                lda cp+1
                sta 1,x

                ; Adjust CP
                pla                     ; length of string
                clc
                adc cp
                sta cp
                lda cp+1
                adc #0                  ; we only need the carry
                sta cp+1
z_word:         
.scend


; ## WORDS ( -- ) "Print known words from Dictionary"
; ## "words"  src: ANSI tools  b: TBA  c: TBA  status: tested
        ; """This is pretty much only used at the command line so we can
        ; be slow and try to save space. DROP must always be the first word in a
        ; clean system (without Forth words), BYE the last. There is no reason
        ; why we couldn't define this as a high level word except that it is
        ; really useful for testing
        ; """
        ; TODO make output respect line length on screen
.scope
xt_words:       
                ; we follow Gforth by starting on the next
                ; line
                jsr xt_cr

                ; start with last word in Dictionary
                jsr xt_latestnt         ; ( nt ) 
_loop:
                jsr xt_dup              ; ( nt nt ) 
                jsr xt_name_to_string   ; ( nt addr u )
                jsr xt_type             ; ( nt )

                lda #AscSP
                jsr emit_a

                ; get next word, which begins two down
                jsr xt_one_plus         ; 1+
                jsr xt_one_plus         ; 1+
                jsr xt_fetch            ; @ ( nt+1 )

                ; if next address is zero, we're done
                lda 0,x
                ora 1,x
                bne _loop

                inx
                inx
                
z_words:        rts
.scend


; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
; ## "wordsize"  src: Tali Forth  b: 29  c: TBA  status: coded
        ; """Given an word's name token (nt), return the size of the word's
        ; payload size in bytes (CFA plus PFA) in bytes. Does not count the
        ; final RTS.
        ; """
.scope
xt_wordsize:    
                ; We get the start address of the word from its header entry
                ; for the start of the actual code (execution token, xt)
                ; which is four bytes down, and the pointer to the end of the
                ; code (z_word, six bytes down)
                lda 0,x
                sta tmp1
                lda 1,x
                sta tmp1+1

                ldy #6
                lda (tmp1),y    ; LSB of z
                dey
                dey

                sec
                sbc (tmp1),y    ; LSB of xt
                sta 0,x

                ldy #7
                lda (tmp1),y    ; MSB of z
                dey
                dey

                sbc (tmp1),y    ; MSB of xt
                sta 1,x

z_wordsize:     rts
.scend


; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
; ## "xor"  src: ANSI core  b: 14  c: TBA  status: coded
.scope
xt_xor:         
                lda 0,x
                eor 2,x
                sta 2,x

                lda 1,x
                eor 3,x
                sta 3,x

                inx
                inx

z_xor:          rts
.scend


; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
; ## "0"  src: Tali Forth  b: 6  c: TBA  status: coded
xt_zero:        
                dex             ; push
                dex
                stz 0,x
                stz 1,x

z_zero:         rts


; ## ZERO_BRANCH ( f -- ) "Branch if TOS is zero"
; ## "0branch"  src: Tali Forth  b: TBA  c: TBA  status: coded 
        ; """This exects the next two bytes to be the address of where to
        ; branch to if the test fails. The code may not be natively compiled
        ; because we need the return address provided by JSR's push to the
        ; Return Stack This routine uses tmpbranch
        ; """
.scope
xt_zero_branch:
                ; The actual word is short: Just compile the runtime
                ; behavior
                lda #>zero_branch_runtime       ; MSB first
                pha
                lda #<zero_branch_runtime       ; MSB first
                pha
                jsr cmpl_subroutine
                
z_zero_branch:  rts
.scend

zero_branch_runtime:
        ; """In some Forths, this is called (0BRANCH)"""
.scope
                ; See if the flag is zero, which is the whole purpose of
                ; this all
                lda 0,x
                ora 1,x
                beq _zero

                ; Flag is TRUE, so we skip over the next two bytes. This is
                ; the part between IF and THEN
                pla             ; LSB
                clc
                adc #2
                sta tmp1
                pla             ; MSB
                adc #0          ; only need carry
                sta tmp1+1
                bra _done
_zero:
                ; Flag is FALSE, so we take the jump to the address given
                ; in the next two bytes
                pla
                sta tmpbranch
                pla
                sta tmpbranch+1

                ; However, the address points to the last byte of the
                ; JSR instruction, not to the next byte afterwards
                ldy #1
                lda (tmpbranch),y
                sta tmp1
                iny
                lda (tmpbranch),y
                sta tmp1+1
                
                ; Now we have to subtract one byte from the address
                ; given because of the way the 6502 calculates RTS
                lda tmp1
                bne +
                dec tmp1+1
*               dec tmp1
_done:
                ; However we got here, tmp1 has the value we push to jump
                ; to
                lda tmp1+1
                pha             ; MSB first
                lda tmp1
                pha

                ; clean up the stack and jump
                inx
                inx

                rts
.scend


; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
; ## "0="  src: ANSI core  b: TBA  c: TBA  status: coded
; TODO Rewrite to the form of 0<>
.scope
xt_zero_equal:  
                cpx #dsp0-1
                bmi +
                lda #11         ; underflow
                jmp error
*
                lda 0,x
                ora 1,x
                beq _zero

                ; not a zero, so we need a FALSE flag (0)
                lda #0
                bra _store
_zero:
                ; We have a zero, so we need a TRUE flag (-1)
                lda #$ff
_store:
                sta 0,x
                sta 1,x

z_zero_equal:   rts
.scend


; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
; ## "0>"  src: ANSI core ext  b: TBA  c: TBA  status: coded
.scope
xt_zero_greater:
                cpx #dsp0-1
                bmi +
                lda #11
                jmp error
*
                ldy #0          ; Default is FALSE (TOS is negative)

                lda 1,x         ; MSB
                bmi _done       ; TOS is negative, keep FLASE
                ora 0,x
                beq _done       ; TOS is zero, keep FALSE

                dey             ; TOS is postive, make true
_done:          
                tya
                sta 0,x
                sta 1,x

z_zero_greater: rts
.scend


; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
; ## "0<"  src: ANSI core  b: TBA  c: TBA  status: tested
.scope
xt_zero_less:
                cpx #dsp0-1
                bmi +
                lda #11
                jmp error
*
                ldy #0          ; Default is FALSE (TOS positive)

                lda 1,x         ; MSB
                bpl _done       ; TOS is positive, so keep FALSE

                dey             ; TOS is negative, make TRUE
_done:          
                tya
                sta 0,x
                sta 1,x

z_zero_less:    rts
.scend


; ## ZERO_UNEQUAL ( m -- f ) "<TBA>"
; ## "0<>"  src: ANSI core ext  b: TBA  c: TBA  status: coded
.scope
xt_zero_unequal:
                cpx #dsp0-1
                bmi +
                lda #11         ; underflow
                jmp error
*
                ldy #0          ; default false

                lda 0,x
                ora 1,x
                beq _got_zero

                dey
_got_zero:      
                tya
                sta 0,x
                sta 1,x
               
z_zero_unequal: rts
.scend

