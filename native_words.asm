; Low-level Forth word routines
; Tali Forth 2 for the 65c02
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 19. Jan 2014
; This version: 10. Dec 2017

; The skeleton for this file was generated by a script, 
; see the tools folder for more information

; This list is ordered alphabetically by the names of the 
; words, not their strings (so "!" is sorted as "store"). However,
; we start off with COLD, ABORT and QUIT as the natural start 
; sequence. Each word two special status line that begins with 
; "; ## " and allows auto-generation of the WORDLIST.md file in the
; docs folder. Status entries are 
;
;       TBA --> fragment --> coded --> tested


; ## COLD ( -- ) "Reset the Forth system"
; ## "cold"  src: Tali Forth  b: TBA  c: TBA  status: fragment
;       """Reset the Forth system. Does not restart the kernel,
;       use the 65c02 reset for that. Flows into ABORT.
;       """
xt_cold:        
                ; Since the default case for Tali is the py65mon
                ; emulator, we have no use for interrupts. If you
                ; are going to include them in your system in any
                ; way, you're going to have to do it from scratch
                sei

                ; initialize 65c02 stack (Return Stack)
                ldx #rsp0
                txs

                ; Clear Data Stack. This is repeated in ABORT,
                ; but this way we can load high-level words such
                ; as EVALUATE
                ldx #dsp0

                ; Start out with radix 10
                lda #$0a
                sta base
                stz base+1

                ; We start out with smaller words with less than 20 bytes being
                ; natively compiled, because this includes words like LSHIFT and MAX. 
                lda #20
                sta nc_limit
                stz nc_limit+1

     
                ; set the OUTPUT vector to the default kernel_putc
                ; but may have synonyms
                lda #<kernel_putc
                sta output
                lda #>kernel_putc
                sta output+1

                ; set the INPUT vector to the default kernel_getc
                lda #<kernel_getc
                sta input
                lda #>kernel_getc
                sta input+1
     
                ; set the HAVE_KEY vector to the default kernel_getc
                ; TODO see how this works with py65mon and if we need it
                lda #<kernel_getc
                sta havekey
                lda #>kernel_getc
                sta havekey+1

                ; The compiler pointer (CP) points to the first free byte
                ; in the Dictionary
                lda #<cp0
                sta cp
                lda #>cp0
                sta cp+1

                lda #<buffer0   ; input buffer
                sta cib
                lda #>buffer0
                sta cib+1 

                stz ciblen      ; input buffer starts empty
                stz ciblen+1

                stz insrc       ; SOURCE-ID is zero
                stz ciblen+1

                stz state       ; STATE is zero (interpret mode)
                stz ciblen+1
     
                ; The name token (nt) of DROP is always the first one in the
                ; new Dictionary, so we start off the Dictionary Pointer (DP)
                ; there. Anything that comes after that (with WORDS, before
                ; that) is high-level
                lda #<nt_drop
                sta dp
                lda #>nt_drop
                sta dp+1
 
                ; Clear the screen, assumes vt100 terminal
                ; jsr xt_page
     
                ; Define high-level words via EVALUATE. At this point, whatever
                ; is in Y (TOS) is garbage, so we don't have to push it to the 
                ; stack first
                ; dex
                ; dex
                ; dex
                ; dex
               
                ; lda #<high_level_start        ; start address goes TOS
                ; sta 0,x
                ; lda #>high_level_start  
                ; sta 0,1
                ;
                ; lda #<(high_level_end-high_level_start)
                ; sta 0,x
                ; lda #>(high_level_end-high_level_start)
                ; sta 1,x

                ; jsr xt_evaluate
                
                ; Define any user words via EVALUATE
                ; dex
                ; dex
                ; dex
                ; dex
               
                ; lda #<user_words_start        ; start address goes TOS
                ; sta 0,x
                ; lda #>user_words_start  
                ; sta 0,1
                ;
                ; lda #<(user_words_end-user_words_start)
                ; sta 0,x
                ; lda #>(user_words_end-user_words_start)
                ; sta 1,x
 
                ; jsr xt_evaluate
                
                ; fall through to ABORT


; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
; ## "abort"  src: ANSI core  b: TBA  c: TBA  status: fragment
        ; """Clear Data Stack and continue into QUIT. We can jump here via
        ; subroutine if we want to because we are going to reset the 65c02's
        ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
        ; actually delete the stuff on the Data Stack
        ; """
xt_abort:       ldx #dsp0


; ## QUIT ( -- ) "Reset the input and get new input"
; ## "quit"  src: ANSI core  b: TBA  c: TBA  status: fragment
        ; """Rest the input and start command loop.
        ; """
.scope
xt_quit:        
                ; clear Return Stack
                ldx #rsp0
                txs

                ; make sure instruction pointer is empty
                stz ip
                stz ip+1

                ; SOURCE-ID is keyboard import
                stz insrc
                stz insrc+1

                ; STATE is zero (interpret, not compile)
                stz state
                stz state+1

_get_line:
                ; empty current input buffer
                stz ciblen
                stz ciblen+1

                ; accept a line from the current import source
                jsr xt_refill           ; ( -- f ) 

                ; test flag: LSB of TOS
                lda 0,x
                bne _success

                ; If REFILL returned a FALSE flag, something went wrong and we
                ; need to print an error message and reset the machine. We don't
                ; need to save TOS because we're going to clobber it anyway when we
                ; go back to ABORT.
                lda #8                  ; code for error string refill 1
                jmp error 

_success:
                ; Assume we have successfully accepted a string of input from
                ; a source, with address cib and length of input in ciblen. We
                ; arrive here still with the TRUE flag from REFILL as TOS
                inx                     ; DROP
                inx
     
                ; make >IN point to begining of buffer
                stz toin 
                stz toin+1 
 
                ; Main compile/execute routine
                jsr interpret

                ; Test for Data Stack underflow. We don't check for
                ; overflow
                ; TODO enable
                ; cpx #dsp0
                ; bcc _stack_ok           ; DSP must always be smaller (!) than DSP0

                ; lda #11                 ; code for underflow es_underflow
                ; jmp error

_stack_ok:
                ; Display system prompt if all went well. If we're interpreting,
                ; this is " ok", if we're compiling, it's " compiled"
                lda state
                bne _compiled

                lda #0                  ; number for "ok" string
                bra _print
_compiled:
                lda #1                  ; number for "compiled" string
_print:
                jsr print_string

                ; Awesome line, everybody! Now get the next one
                bra _get_line

z_cold:         
z_abort:        
z_quit:         ; no RTS required
.scend


; ## ABORT_QUOTE ( -- ) "<TBA>"
; ## "abort""  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_abort_quote: nop
z_abort_quote:  rts
.scend

; ## ABS ( -- ) "<TBA>"
; ## "abs"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_abs:         nop
z_abs:          rts
.scend


; ## ACCEPT ( addr n -- n ) "Receive a string of characters"
; ## "accept"  src: ANSI core  b: TBA  c: TBA  status: fragment
	; """ Receive a string of at most n1 characters, placing them at
        ; addr. Return the actual number of characters as n2. Characters
        ; are echoed as they are received. ACCEPT is called by REFILL in
        ; modern Forths. This version accepts 256 chars max in the 
        ; current implementation
        ; """
.scope
xt_accept:
                ; Abort if we were asked to receive 0 chars 
                lda 0,x
                ora 1,x
                bne _not_zero
     
                ; return 0
                inx
                inx
                stz 0,x
                stz 1,x

                bra z_accept    ; no RTS so we can native compile

_not_zero:
                lda 0,x         ; number of chars to get in tmp2 ...
                sta tmp2
                stz tmp2+1      ; ... but we only accept max 256 chars

                lda 2,x         ; address of buffer is NOS, to tmp1
                sta tmp1 
                lda 3,x
                sta tmp1+1

                inx
                inx

                ldy #0

_loop:
                ; This is the internal version of KEY without all the mucking
                ; about with the Data Stack while still using the input vector
                jsr key_a

                ; we quit on both line feed and carriage return
                cmp #AscLF     
                beq _eol
                cmp #AscCR
                beq _eol

                ; BS and DEL do the same thing for the moment
                cmp #AscBS     
                beq _bs
                cmp #AscDEL     ; (CTRL-h)
                beq _bs

                ; CTRL-c aborts. At some point, consider moving this to the
                ; KEY routine
                cmp #AscCC     
                bne + 
                jmp xt_abort
*
                ; That's quite enough, echo character. EMIT_A sidesteps all the
                ; fooling around with the Data Stack
                jsr emit_a

                sta (tmp1),y
                iny
                cpy tmp2        ; reached character limit?
                bne _loop       ; fall thru if buffer limit reached

_eol:
                jsr xt_space    ; print final space

                sty 0,x         ; Y contains number of chars accepted already
                stz 1,x         ; we only accept 256 chars

                bra z_accept
_bs:
                cpy #0          ; buffer empty?
                bne +

                lda #AscBELL    ; complain and don't delete beyond the start of line
                jsr emit_a
                iny
*
                dey
                lda #AscBS      ; move back one
                jsr emit_a
                lda #AscSP      ; print a space (rubout) 
                jsr emit_a
                lda #AscBS      ; move back over space
                jsr emit_a

                bra _loop

z_accept:       rts
.scend


; ## AGAIN ( -- ) "<TBA>"
; ## "again"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_again:       nop
z_again:        rts
.scend

; ## ALIGN ( -- ) "<TBA>"
; ## "align"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_align:       nop
z_align:        rts
.scend

; ## ALIGNED ( -- ) "<TBA>"
; ## "aligned"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_aligned:     nop
z_aligned:      rts
.scend

; ## ALLOT ( -- ) "<TBA>"
; ## "allot"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_allot:       nop
z_allot:        rts
.scend

; ## AND ( -- ) "<TBA>"
; ## "and"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_and:         nop
z_and:          rts
.scend

; ## AT_XY ( -- ) "<TBA>"
; ## "at-xy"  src: ANSI facility  b: TBA  c: TBA  status: TBA
.scope
xt_at_xy:       nop
z_at_xy:        rts
.scend

; ## BACKSLASH ( -- ) "<TBA>"
; ## "\"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_backslash:   nop
z_backslash:    rts
.scend

; ## BASE ( -- ) "<TBA>"
; ## "base"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_base:        nop
z_base:         rts
.scend

; ## BEGIN ( -- ) "<TBA>"
; ## "begin"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_begin:       nop
z_begin:        rts
.scend

; ## BELL ( -- ) "<TBA>"
; ## "bell"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_bell:        nop
z_bell:         rts
.scend

; ## BL ( -- ) "<TBA>"
; ## "bl"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_bl:          nop
z_bl:           rts
.scend

; ## BOUNDS ( -- ) "<TBA>"
; ## "bounds"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_bounds:      nop
z_bounds:       rts
.scend

; ## BRACKET_CHAR ( -- ) "<TBA>"
; ## "[char]"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_bracket_char:
                nop
z_bracket_char: rts
.scend

; ## BRACKET_TICK ( -- ) "<TBA>"
; ## "[']"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_bracket_tick:
                nop
z_bracket_tick: rts
.scend

; ## BRANCH ( -- ) "<TBA>"
; ## "branch"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_branch:      nop
z_branch:       rts
.scend

; ## BYE ( -- ) "<TBA>"
; ## "bye"  src: ANSI tools ext  b: TBA  c: TBA  status: TBA
.scope
xt_bye:         nop
z_bye:          rts
.scend

; ## C_COMMA ( -- ) "<TBA>"
; ## "c,"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_c_comma:     nop
z_c_comma:      rts
.scend

; ## C_FETCH ( -- ) "<TBA>"
; ## "c@"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_c_fetch:     nop
z_c_fetch:      rts
.scend

; ## C_STORE ( -- ) "<TBA>"
; ## "c!"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_c_store:     nop
z_c_store:      rts
.scend

; ## CELL_PLUS ( -- ) "<TBA>"
; ## "cell+"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_cell_plus:   nop
z_cell_plus:    rts
.scend

; ## CELLS ( -- ) "<TBA>"
; ## "cells"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_cells:       nop
z_cells:        rts
.scend

; ## CHAR ( -- ) "<TBA>"
; ## "char"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_char:        nop
z_char:         rts
.scend

; ## CHAR_PLUS ( -- ) "<TBA>"
; ## "char+"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_char_plus:   nop
z_char_plus:    rts
.scend

; ## CHARS ( -- ) "<TBA>"
; ## "chars"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_chars:       nop
z_chars:        rts
.scend

; ## CMOVE ( -- ) "<TBA>"
; ## "cmove"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_cmove:       nop
z_cmove:        rts
.scend

; ## CMOVE_UP ( -- ) "<TBA>"
; ## "cmove>"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_cmove_up:    nop
z_cmove_up:     rts
.scend

; ## COLON ( -- ) "<TBA>"
; ## ":"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_colon:       nop
z_colon:        rts
.scend

; ## COMMA ( -- ) "<TBA>"
; ## ","  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_comma:       nop
z_comma:        rts
.scend

; ## COMPILE_COMMA ( -- ) "<TBA>"
; ## "compile,"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_compile_comma:
                nop
z_compile_comma:
                rts
.scend

; ## COMPILE_ONLY ( -- ) "<TBA>"
; ## "compile-only"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_compile_only:
                nop
z_compile_only: rts
.scend

; ## CONSTANT ( -- ) "<TBA>"
; ## "constant"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_constant:    nop
z_constant:     rts
.scend

; ## COUNT ( -- ) "<TBA>"
; ## "count"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_count:       nop
z_count:        rts
.scend

; ## CR ( -- ) "<TBA>"
; ## "cr"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_cr:          nop
z_cr:           rts
.scend

; ## CREATE ( -- ) "<TBA>"
; ## "create"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_create:      nop
z_create:       rts
.scend

; ## D_DOT ( -- ) "<TBA>"
; ## "d."  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_dot:       nop
z_d_dot:        rts
.scend

; ## D_MINUS ( -- ) "<TBA>"
; ## "d-"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_minus:     nop
z_d_minus:      rts
.scend

; ## D_PLUS ( -- ) "<TBA>"
; ## "d+"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_plus:      nop
z_d_plus:       rts
.scend

; ## D_R ( -- ) "<TBA>"
; ## "d.r"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_r:         nop
z_d_r:          rts
.scend

; ## D_TO_S ( -- ) "<TBA>"
; ## "d>s"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_to_s:      nop
z_d_to_s:       rts
.scend

; ## DABS ( -- ) "<TBA>"
; ## "dabs"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_dabs:        nop
z_dabs:         rts
.scend

; ## DECIMAL ( -- ) "<TBA>"
; ## "decimal"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_decimal:     nop
z_decimal:      rts
.scend

; ## DEFER ( -- ) "<TBA>"
; ## "defer"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_defer:       nop
z_defer:        rts
.scend

; ## DEPTH ( -- ) "<TBA>"
; ## "depth"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_depth:       nop
z_depth:        rts
.scend

; ## DIGIT_QUESTION ( -- ) "<TBA>"
; ## "digit?"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_digit_question:
                nop
z_digit_question:
                rts
.scend

; ## DNEGATE ( -- ) "<TBA>"
; ## "dnegate"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_dnegate:     nop
z_dnegate:      rts
.scend

; ## DO ( -- ) "<TBA>"
; ## "do"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_do:          nop
z_do:           rts
.scend

; ## DOES ( -- ) "<TBA>"
; ## "does>"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_does:        nop
z_does:         rts
.scend

; ## DOT ( -- ) "<TBA>"
; ## "."  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_dot:         nop
z_dot:          rts
.scend

; ## DOT_BYTE ( -- ) "<TBA>"
; ## ".byte"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_dot_byte:    nop
z_dot_byte:     rts
.scend

; ## DOT_PAREN ( -- ) "<TBA>"
; ## ".("  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_dot_paren:   nop
z_dot_paren:    rts
.scend

; ## DOT_QUOTE ( -- ) "<TBA>"
; ## ".""  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_dot_quote:   nop
z_dot_quote:    rts
.scend

; ## DOT_R ( -- ) "<TBA>"
; ## ".r"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_dot_r:       nop
z_dot_r:        rts
.scend

; ## DOT_S ( -- ) "<TBA>"
; ## ".s"  src: ANSI tools  b: TBA  c: TBA  status: TBA
.scope
xt_dot_s:       nop
z_dot_s:        rts
.scend


; ## DROP ( u -- ) "Pop top entry on Data Stack"
; ## "drop"  src: ANSI core  b: 2  c: 4  status: coded
xt_drop:        
                inx             ; drop
                inx
z_drop:         rts


; ## DUMP ( -- ) "<TBA>"
; ## "dump"  src: ANSI tools  b: TBA  c: TBA  status: TBA
.scope
xt_dump:        nop
z_dump:         rts
.scend


; ## DUP ( u -- u u ) "Duplicate TOS"
; ## "dup"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_dup:         dex
                dex
                lda 2,x         ; LSB
                sta 0,x
                lda 3,x         ; MSB
                sta 1,x

z_dup:          rts


; ## ELSE ( -- ) "<TBA>"
; ## "else"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_else:        nop
z_else:         rts
.scend


; ## EMIT ( char -- ) "Print character to current output"
; ## "emit"  src: ANSI core  b: TBA  c: TBA  status: fragment
xt_emit:
        ; """Run-time default for EMIT. The user can revector this by changing
        ; the value of the OUTPUT variable. We ignore the MSB completely, and 
        ; do not check to see if we have been given a valid ASCII character. 
        ; Don't make this native compile. 
        ; """
                ; TODO
                ; load LSB of TOS A
                ; DROP
                ; falls through to emit_a

emit_a:
        ; We frequently want to print the character in A without fooling
        ; around with the Data Stack. This is emit_a's job, which still
        ; allows the output to be vectored. Call it with JSR as you 
        ; would XT_EMIT
                jmp (output)            ; JSR/RTS

z_emit:         ; never reached 


; ## EQUALS ( -- ) "<TBA>"
; ## "="  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_equals:      nop
z_equals:       rts
.scend

; ## ERASE ( -- ) "<TBA>"
; ## "erase"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_erase:       nop
z_erase:        rts
.scend

; ## EVALUATE ( -- ) "<TBA>"
; ## "evaluate"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_evaluate:    nop
z_evaluate:     rts
.scend

; ## EXECUTE ( -- ) "<TBA>"
; ## "execute"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_execute:     nop
z_execute:      rts
.scend

; ## EXIT ( -- ) "<TBA>"
; ## "exit"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_exit:        nop
z_exit:         rts
.scend

;
; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
; ## "false"  src: ANSI core ext  b: TBA  c: TBA  status: coded
xt_false:       dex
                dex
                stz 0,x
                stz 1,x

z_false:        rts


; ## FETCH ( -- ) "<TBA>"
; ## "@"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_fetch:       nop
z_fetch:        rts
.scend

; ## FILL ( -- ) "<TBA>"
; ## "fill"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_fill:        nop
z_fill:         rts
.scend

; ## FIND ( -- ) "<TBA>"
; ## "find"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_find:        nop
z_find:         rts
.scend

; ## FIND_NAME ( -- ) "<TBA>"
; ## "find-name"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_find_name:   nop
z_find_name:    rts
.scend

; ## FM_SLASH_MOD ( -- ) "<TBA>"
; ## "fm/mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_fm_slash_mod:
                nop
z_fm_slash_mod: rts
.scend

; ## GREATER_THAN ( -- ) "<TBA>"
; ## ">"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_greater_than:
                nop
z_greater_than: rts
.scend

; ## HERE ( -- ) "<TBA>"
; ## "here"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_here:        nop
z_here:         rts
.scend

; ## HEX ( -- ) "<TBA>"
; ## "hex"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_hex:         nop
z_hex:          rts
.scend

; ## HOLD ( -- ) "<TBA>"
; ## "hold"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_hold:        nop
z_hold:         rts
.scend

; ## I ( -- ) "<TBA>"
; ## "i"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_i:           nop
z_i:            rts
.scend

; ## IF ( -- ) "<TBA>"
; ## "if"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_if:          nop
z_if:           rts
.scend

; ## IMMEDIATE ( -- ) "<TBA>"
; ## "immediate"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_immediate:   nop
z_immediate:    rts
.scend

; ## INPUT ( -- ) "<TBA>"
; ## "input"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_input:       nop
z_input:        rts
.scend

; ## INT_TO_NAME ( -- ) "<TBA>"
; ## "int>name"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_int_to_name: nop
z_int_to_name:  rts
.scend

; ## INVERT ( -- ) "<TBA>"
; ## "invert"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_invert:      nop
z_invert:       rts
.scend

; ## J ( -- ) "<TBA>"
; ## "j"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_j:           nop
z_j:            rts
.scend


; ## KEY ( -- char ) "Get one character from the input"
; ## "key"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Get a single character of input from the vectored
        ; input without echoing.
        ; """
.scope
xt_key:         
                jsr key_a               ; returns char in A
                
                dex
                dex
                sta 0,x
                stz 1,x

                rts

key_a:
        ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
        ; 65816, so we have to fake the indirect jump to vector it.
        ; This is depressingly slow. We use this routine internally
        ; to avoid manipulating the Data Stack when we just want a
        ; character
                jmp (input)             ; JSR/RTS

z_key:          ; never reached
.scend


; ## KEY_QUESTION ( -- ) "<TBA>"
; ## "key?"  src: ANSI facility  b: TBA  c: TBA  status: TBA
.scope
xt_key_question:
                nop
z_key_question: rts
.scend

; ## LATESTNT ( -- ) "<TBA>"
; ## "latestnt"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_latestnt:    nop
z_latestnt:     rts
.scend

; ## LATESTXT ( -- ) "<TBA>"
; ## "latestxt"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_latestxt:    nop
z_latestxt:     rts
.scend

; ## LEAVE ( -- ) "<TBA>"
; ## "leave"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_leave:       nop
z_leave:        rts
.scend

; ## LEFT_BRACKET ( -- ) "<TBA>"
; ## "["  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_left_bracket:
                nop
z_left_bracket: rts
.scend

; ## LESS_NUMBER_SIGN ( -- ) "<TBA>"
; ## "<#"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_less_number_sign:
                nop
z_less_number_sign:
                rts
.scend

; ## LESS_THAN ( -- ) "<TBA>"
; ## "<"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_less_than:   nop
z_less_than:    rts
.scend

; ## LITERAL ( -- ) "<TBA>"
; ## "literal"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_literal:     nop
z_literal:      rts
literal_rt:
.scend

; ## LOOP ( -- ) "<TBA>"
; ## "loop"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_loop:        nop
z_loop:         rts
.scend

; ## LSHIFT ( -- ) "<TBA>"
; ## "lshift"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_lshift:      nop
z_lshift:       rts
.scend

; ## M_STAR ( -- ) "<TBA>"
; ## "m*"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_m_star:      nop
z_m_star:       rts
.scend

; ## MARKER ( -- ) "<TBA>"
; ## "marker"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_marker:      nop
z_marker:       rts
.scend

; ## MAX ( -- ) "<TBA>"
; ## "max"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_max:         nop
z_max:          rts
.scend

; ## MIN ( -- ) "<TBA>"
; ## "min"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_min:         nop
z_min:          rts
.scend

; ## MINUS ( -- ) "<TBA>"
; ## "-"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_minus:       nop
z_minus:        rts
.scend

; ## MINUS_TRAILING ( -- ) "<TBA>"
; ## "-trailing"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_minus_trailing:
                nop
z_minus_trailing:
                rts
.scend

; ## MOD ( -- ) "<TBA>"
; ## "mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_mod:         nop
z_mod:          rts
.scend

; ## MOVE ( -- ) "<TBA>"
; ## "move"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_move:        nop
z_move:         rts
.scend

; ## NAME_TO_INT ( -- ) "<TBA>"
; ## "name>int"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_name_to_int: nop
z_name_to_int:  rts
.scend

; ## NAME_TO_STRING ( -- ) "<TBA>"
; ## "name>string"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_name_to_string:
                nop
z_name_to_string:
                rts
.scend

; ## NC_LIMIT ( -- ) "<TBA>"
; ## "nc-limit"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_nc_limit:    nop
z_nc_limit:     rts
.scend

; ## NEGATE ( -- ) "<TBA>"
; ## "negate"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_negate:      nop
z_negate:       rts
.scend

; ## NEVER_COMPILE ( -- ) "<TBA>"
; ## "never-compile"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_never_compile:
                nop
z_never_compile:
                rts
.scend


; ## NIP ( b a -- a ) "Delete NOS"
; ## "nip"  src: ANSI core ext  b: 10  c: TBA  status: coded
xt_nip:         lda 0,x         ; LSB
                sta 2,x
                lda 1,x         ; MSB
                sta 3,x
                inx
                inx

z_nip:          rts


; ## NOT_EQUALS ( -- ) "<TBA>"
; ## "<>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_not_equals:  nop
z_not_equals:   rts
.scend

; ## NOT_ROTE ( -- ) "<TBA>"
; ## "-rot"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_not_rote:    nop
z_not_rote:     rts
.scend

; ## NUMBER ( -- ) "<TBA>"
; ## "number"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_number:      nop
z_number:       rts
.scend


; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
; ## "1"  src: Tali Forth  b: 8  c: TBA  status: coded
xt_one:         dex
                dex
                lda #01
                sta 0,x
                stz 1,x

z_one:          rts



; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
; ## "1-"  src: ANSI core  b: 8  c: TBA  status: coded
.scope
xt_one_minus:   lda 0,x
                bne +
                dec 1,x
*               dec 0,x

z_one_minus:    rts
.scend


; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
; ## "1+"  src: ANSI core  b: 6  c: 14-15  status: coded
.scope
xt_one_plus:    inc 0,x
                bne _done
                inc 1,x
_done:
z_one_plus:     rts
.scend


; ## OR ( -- ) "<TBA>"
; ## "or"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_or:          nop
z_or:           rts
.scend


; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
; ## "output"  src: Tali Forth  b: TBA  c: TBA  status: fragment
xt_output:      
        ; """Return the address where the jump target for EMIT is stored (but
        ; not the vector itself). By default, this will hold the value of 
        ; kernel_putc routine, but this can be changed by the user, hence this
        ; routine.
        ; """
                ; TODO
                ; push value of output to TOS
z_output:       rts


; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
; ## "over"  src: ANSI core  b: 10  c: TBA  status: coded
xt_over:        dex
                dex
                lda 4,x         ; LSB
                sta 0,x
                lda 5,x         ; MSB
                sta 1,x 

z_over:         rts


; ## PAD ( -- ) "<TBA>"
; ## "pad"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_pad:         nop
z_pad:          rts
.scend

; ## PAGE ( -- ) "<TBA>"
; ## "page"  src: ANSI facility  b: TBA  c: TBA  status: TBA
.scope
xt_page:        nop
z_page:         rts
.scend

; ## PAREN ( -- ) "<TBA>"
; ## "("  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_paren:       nop
z_paren:        rts
.scend

; ## PAREN_DO ( -- ) "<TBA>"
; ## "(do)"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_paren_do:    nop
z_paren_do:     rts
.scend

; ## PAREN_PLUS_LOOP ( -- ) "<TBA>"
; ## "(+loop)"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_paren_plus_loop:
                nop
z_paren_plus_loop:
                rts
.scend

; ## PAREN_Q_DO ( -- ) "<TBA>"
; ## "(?do)"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_paren_q_do:  nop
z_paren_q_do:   rts
.scend

; ## PARSE ( -- ) "<TBA>"
; ## "parse"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_parse:       nop
z_parse:        rts
.scend

; ## PARSE_NAME ( -- ) "<TBA>"
; ## "parse-name"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_parse_name:  nop
z_parse_name:   rts
.scend

; ## PICK ( -- ) "<TBA>"
; ## "pick"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_pick:        nop
z_pick:         rts
.scend


; ## PLUS ( b a -- a+b ) "Add TOS and NOS"
; ## "+"  src: ANSI core  b: 15  c: TBA  status: coded
xt_plus:        clc
                lda 0,x         ; LSB
                adc 2,x
                sta 0,x

                lda 1,x         ; MSB. No CLC, conserve carry bit
                adc 3,x
                sta 1,x

                inx
                inx

z_plus:         rts


; ## PLUS_LOOP ( -- ) "<TBA>"
; ## "+loop"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_plus_loop:   nop
z_plus_loop:    rts
.scend

; ## PLUS_STORE ( -- ) "<TBA>"
; ## "+!"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_plus_store:  nop
z_plus_store:   rts
.scend

; ## POSTPONE ( -- ) "<TBA>"
; ## "postpone"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_postpone:    nop
z_postpone:     rts
.scend

; ## QUESTION ( -- ) "<TBA>"
; ## "?"  src: ANSI tools  b: TBA  c: TBA  status: TBA
.scope
xt_question:    nop
z_question:     rts
.scend

; ## QUESTION_DO ( -- ) "<TBA>"
; ## "?do"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_question_do: nop
z_question_do:  rts
.scend

; ## QUESTION_DUP ( -- ) "<TBA>"
; ## "?dup"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_question_dup:
                nop
z_question_dup: rts
.scend

; ## R_FETCH ( -- ) "<TBA>"
; ## "r@"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_r_fetch:     nop
z_r_fetch:      rts
.scend

; ## R_FROM ( -- ) "<TBA>"
; ## "r>"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_r_from:      nop
z_r_from:       rts
.scend

; ## RECURSE ( -- ) "<TBA>"
; ## "recurse"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_recurse:     nop
z_recurse:      rts
.scend


; ## REFILL ( -- f ) "Refill the input buffer"
; ## "refill"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
;       """Attempt to fill the input buffer from the input source, returning
;       a true flag if successful. When the input source is the user input
;       device, attempt to receive input into the terminal input buffer. If
;       successful, make the result the input buffer, set >IN to zero, and
;       return true. Receipt of a line containing no characters is considered
;       successful. If there is no input available from the current input
;       source, return false. When the input source is a string from EVALUATE,
;       return false and perform no other action." See
;       https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
;       and Conklin & Rather p. 156
;       """"
.scope
xt_refill:      
                ; Get input source from SOURCE-ID. We don't have blocks in this
                ; version, or else we would have to check BLK first. This is an
                ; optimized version of a subroutine jump to SOURCE-ID
                lda insrc               ; cheat: We only check LSB
                bne _src_not_kbd

                ; SOURCE-ID of zero means we're getting stuff from the keyboard
                ; with ACCEPT, which wants the address of the current input
                ; buffer NOS and the max number of characters to accept TOS
                dex
                dex
                dex
                dex

                lda cib                 ; address of CIB is NOS
                sta 2,x
                lda cib+1
                sta 3,x
                
                lda #bsize              ; max number of chars is TOS
                sta 0,x
                stz 1,x                 ; cheat: We only accept max 256

                jsr xt_accept           ; ( addr n1 -- n2)

                ; ACCEPT returns the number of characters accepted, which
                ; belong in CIBLEN
                lda 0,x
                sta ciblen
                stz ciblen+1            ; we only accept 256 chars
                
                lda #$ff                ; overwrite with TRUE flag
                sta 0,x
                sta 1,x

                bra z_refill

_src_not_kbd:
                ; If SOURCE-ID doesn't return a zero, it must be a string in
                ; memory or a file (remember, no blocks in this version).
                ; If source is a string, we were given the flag -1 ($ffff)
                inc
                bne _source_is_not_string

                ; Simply return FALSE flag as per specification
                dex
                dex
                stz 0,x
                stz 1,x

                bra z_refill

_source_is_not_string:
                ; Since we don't have blocks, this must mean that we are trying
                ; to read from a file. However, we don't have files yet, so we 
                ; report an error and jump to ABORT.
                lda #9                  ; error code for illegal source id
                jmp error

z_refill:       rts
.scend


; ## REPEAT ( -- ) "<TBA>"
; ## "repeat"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_repeat:      nop
z_repeat:       rts
.scend

; ## RIGHT_BRACKET ( -- ) "<TBA>"
; ## "]"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_right_bracket:
                nop
z_right_bracket:
                rts
.scend

; ## RIGHT_PAREN ( -- ) "<TBA>"
; ## ")"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_right_paren: nop
z_right_paren:  rts
.scend

; ## ROTE ( -- ) "<TBA>"
; ## "rot"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_rote:        nop
z_rote:         rts
.scend

; ## RSHIFT ( -- ) "<TBA>"
; ## "rshift"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_rshift:      nop
z_rshift:       rts
.scend

; ## S_QUOTE ( -- ) "<TBA>"
; ## "s""  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_s_quote:     nop
z_s_quote:      rts
.scend

; ## S_TO_D ( -- ) "<TBA>"
; ## "s>d"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_s_to_d:      nop
z_s_to_d:       rts
.scend

; ## SEMICOLON ( -- ) "<TBA>"
; ## ";"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_semicolon:   nop
z_semicolon:    rts
.scend

; ## SIGN ( -- ) "<TBA>"
; ## "sign"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_sign:        nop
z_sign:         rts
.scend

; ## SLASH ( -- ) "<TBA>"
; ## "/"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_slash:       nop
z_slash:        rts
.scend

; ## SLASH_MOD ( -- ) "<TBA>"
; ## "/mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_slash_mod:   nop
z_slash_mod:    rts
.scend

; ## SLASH_STRING ( -- ) "<TBA>"
; ## "/string"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_slash_string:
                nop
z_slash_string: rts
.scend

; ## SLITERAL ( -- ) "<TBA>"
; ## "sliteral"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_sliteral:    nop
z_sliteral:     rts
.scend

; ## SM_SLASH_REM ( -- ) "<TBA>"
; ## "sm/rem"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_sm_slash_rem:
                nop
z_sm_slash_rem: rts
.scend

; ## SOURCE ( -- ) "<TBA>"
; ## "source"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_source:      nop
z_source:       rts
.scend

; ## SOURCE_ID ( -- ) "<TBA>"
; ## "source-id"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_source_id:   nop
z_source_id:    rts
.scend

; ## SPACE ( -- ) "<TBA>"
; ## "space"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_space:       nop
z_space:        rts
.scend

; ## SPACES ( -- ) "<TBA>"
; ## "spaces"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_spaces:      nop
z_spaces:       rts
.scend

; ## STAR ( -- ) "<TBA>"
; ## "*"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_star:        nop
z_star:         rts
.scend

; ## STAR_SLASH ( -- ) "<TBA>"
; ## "*/"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_star_slash:  nop
z_star_slash:   rts
.scend

; ## STAR_SLASH_MOD ( -- ) "<TBA>"
; ## "*/mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_star_slash_mod:
                nop
z_star_slash_mod:
                rts
.scend

; ## STATE ( -- ) "<TBA>"
; ## "state"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_state:       nop
z_state:        rts
.scend

; ## STORE ( -- ) "<TBA>"
; ## "!"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_store:       nop
z_store:        rts
.scend


; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
; ## "swap"  src: ANSI core  b: 16  c: TBA  status: coded
xt_swap:        lda 0,x         ; LSB
                ldy 2,x
                sta 2,x
                sty 0,x

                lda 1,x         ; MSB
                ldy 3,x
                sta 3,x
                sty 1,x

z_swap:         rts


; ## THEN ( -- ) "<TBA>"
; ## "then"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_then:        nop
z_then:         rts
.scend

; ## TICK ( -- ) "<TBA>"
; ## "'"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_tick:        nop
z_tick:         rts
.scend

; ## TO ( -- ) "<TBA>"
; ## "to"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_to:          nop
z_to:           rts
.scend

; ## TO_BODY ( -- ) "<TBA>"
; ## ">body"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_to_body:     nop
z_to_body:      rts
.scend

; ## TO_IN ( -- ) "<TBA>"
; ## ">in"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_to_in:       nop
z_to_in:        rts
.scend

; ## TO_NUMBER ( -- ) "<TBA>"
; ## ">number"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_to_number:   nop
z_to_number:    rts
.scend

; ## TO_R ( -- ) "<TBA>"
; ## ">r"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_to_r:        nop
z_to_r:         rts
.scend

;
; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
; ## "true"  src: ANSI core ext  b: 8  c: TBA  status: coded
xt_true:        dex
                dex
                lda #$ff
                sta 0,x
                sta 1,x

z_true:         rts


; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
; ## "tuck"  src: ANSI core ext  b: 24  c: TBA  status: coded
xt_tuck:        dex
                dex             ; ba- 

                lda 2,x
                sta 0,x         
                lda 3,x
                sta 1,x         ; baa

                ldy 4,x         ; using Y saves one instruction
                sty 2,x         ; because TOS MSB stays in A
                ldy 5,x
                sty 3,x         ; bba

                sta 5,x         
                lda 0,x
                sta 4,x         ; aba

z_tuck:         rts


; ## TWO ( -- ) "<TBA>"
; ## "2"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_two:         nop
z_two:          rts
.scend

; ## TWO_DROP ( -- ) "<TBA>"
; ## "2drop"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_two_drop:    nop
z_two_drop:     rts
.scend

; ## TWO_DUP ( -- ) "<TBA>"
; ## "2dup"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_two_dup:     nop
z_two_dup:      rts
.scend

; ## TWO_OVER ( -- ) "<TBA>"
; ## "2over"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_two_over:    nop
z_two_over:     rts
.scend

; ## TWO_R_FETCH ( -- ) "<TBA>"
; ## "2r@"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_two_r_fetch: nop
z_two_r_fetch:  rts
.scend

; ## TWO_R_FROM ( -- ) "<TBA>"
; ## "2r>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_two_r_from:  nop
z_two_r_from:   rts
.scend

; ## TWO_STAR ( -- ) "<TBA>"
; ## "2*"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_two_star:    nop
z_two_star:     rts
.scend

; ## TWO_SWAP ( -- ) "<TBA>"
; ## "2swap"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_two_swap:    nop
z_two_swap:     rts
.scend

; ## TWO_TO_R ( -- ) "<TBA>"
; ## "2>r"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_two_to_r:    nop
z_two_to_r:     rts
.scend

; ## TWO_VARIABLE ( -- ) "<TBA>"
; ## "2variable"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_two_variable:
                nop
z_two_variable: rts
.scend

; ## TYPE ( -- ) "<TBA>"
; ## "type"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_type:        nop
z_type:         rts
.scend

; ## U_DOT ( -- ) "<TBA>"
; ## "u."  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_u_dot:       nop
z_u_dot:        rts
.scend

; ## U_DOT_R ( -- ) "<TBA>"
; ## "u.r"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_u_dot_r:     nop
z_u_dot_r:      rts
.scend

; ## UD_DOT ( -- ) "<TBA>"
; ## "ud."  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_ud_dot:      nop
z_ud_dot:       rts
.scend

; ## UD_DOT_R ( -- ) "<TBA>"
; ## "ud.r"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_ud_dot_r:    nop
z_ud_dot_r:     rts
.scend

; ## UD_SLASH_MOD ( -- ) "<TBA>"
; ## "ud/mod"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_ud_slash_mod:
                nop
z_ud_slash_mod: rts
.scend

; ## UM_SLASH_MOD ( -- ) "<TBA>"
; ## "um/mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_um_slash_mod:
                nop
z_um_slash_mod: rts
.scend

; ## UM_STAR ( -- ) "<TBA>"
; ## "um*"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_um_star:     nop
z_um_star:      rts
.scend

; ## UNLOOP ( -- ) "<TBA>"
; ## "unloop"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_unloop:      nop
z_unloop:       rts
.scend

; ## UNUSED ( -- ) "<TBA>"
; ## "unused"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_unused:      nop
z_unused:       rts
.scend

; ## VALUE ( -- ) "<TBA>"
; ## "value"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_value:       nop
z_value:        rts
.scend

; ## VARIABLE ( -- ) "<TBA>"
; ## "variable"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_variable:    nop
z_variable:     rts
.scend

; ## WITHIN ( -- ) "<TBA>"
; ## "within"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_within:      nop
z_within:       rts
.scend

; ## WORD ( -- ) "<TBA>"
; ## "word"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_word:        nop
z_word:         rts
.scend

; ## WORDS ( -- ) "<TBA>"
; ## "words"  src: ANSI tools  b: TBA  c: TBA  status: TBA
.scope
xt_words:       nop
z_words:        rts
.scend

; ## WORDS_AND_SIZES ( -- ) "<TBA>"
; ## "words&sizes"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_words_and_sizes:
                nop
z_words_and_sizes:
                rts
.scend

; ## WORDSIZE ( -- ) "<TBA>"
; ## "wordsize"  src: ANSI searc  b: TBA  c: TBA  status: TBA
.scope
xt_wordsize:    nop
z_wordsize:     rts
.scend

; ## XOR ( -- ) "<TBA>"
; ## "xor"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_xor:         nop
z_xor:          rts
.scend

; ## ZERO ( -- ) "<TBA>"
; ## "0"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_zero:        nop
z_zero:         rts
.scend

; ## ZERO_BRANCH ( -- ) "<TBA>"
; ## "0branch"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_zero_branch: nop
z_zero_branch:  rts
.scend

; ## ZERO_EQUAL ( -- ) "<TBA>"
; ## "0="  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_zero_equal:  nop
z_zero_equal:   rts
.scend

; ## ZERO_GREATER ( -- ) "<TBA>"
; ## "0>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_zero_greater:
                nop
z_zero_greater: rts
.scend

; ## ZERO_LESS ( -- ) "<TBA>"
; ## "0<"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_zero_less:   nop
z_zero_less:    rts
.scend

; ## ZERO_UNEQUAL ( -- ) "<TBA>"
; ## "0<>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_zero_unequal:
                nop
z_zero_unequal: rts
.scend

