; Low-level Forth word routines
; Tali Forth 2 for the 65c02
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 19. Jan 2014
; This version: 04. Feb 2018

; The skeleton for this file was generated by a script, 
; see the tools folder for more information

; This list is ordered alphabetically by the names of the 
; words, not their strings (so "!" is sorted as "store"). However,
; we start off with COLD, ABORT and QUIT as the natural start 
; sequence. Each word two special status line that begins with 
; "; ## " and allows auto-generation of the WORDLIST.md file in the
; docs folder. Status entries are 
;
;       TBA --> fragment --> coded --> tested


; ## COLD ( -- ) "Reset the Forth system"
; ## "cold"  src: Tali Forth  b: TBA  c: TBA  status: fragment
;       """Reset the Forth system. Does not restart the kernel,
;       use the 65c02 reset for that. Flows into ABORT.
;       """
xt_cold:        
                ; Since the default case for Tali is the py65mon
                ; emulator, we have no use for interrupts. If you
                ; are going to include them in your system in any
                ; way, you're going to have to do it from scratch
                sei

                ; initialize 65c02 stack (Return Stack)
                ldx #rsp0
                txs

                ; Clear Data Stack. This is repeated in ABORT,
                ; but this way we can load high-level words such
                ; as EVALUATE
                ldx #dsp0

                ; Start out with radix 10
                lda #$0a
                sta base
                stz base+1

                ; We start out with smaller words with less than 20 bytes being
                ; natively compiled, because this includes words like LSHIFT and MAX. 
                lda #20
                sta nc_limit
                stz nc_limit+1

     
                ; set the OUTPUT vector to the default kernel_putc
                ; but may have synonyms
                lda #<kernel_putc
                sta output
                lda #>kernel_putc
                sta output+1

                ; set the INPUT vector to the default kernel_getc
                lda #<kernel_getc
                sta input
                lda #>kernel_getc
                sta input+1
     
                ; set the HAVE_KEY vector to the default kernel_getc
                ; TODO see how this works with py65mon and if we need it
                lda #<kernel_getc
                sta havekey
                lda #>kernel_getc
                sta havekey+1

                ; The compiler pointer (CP) points to the first free byte
                ; in the Dictionary
                lda #<cp0
                sta cp
                lda #>cp0
                sta cp+1

                lda #<buffer0   ; input buffer
                sta cib
                lda #>buffer0
                sta cib+1 

                stz ciblen      ; input buffer starts empty
                stz ciblen+1

                stz insrc       ; SOURCE-ID is zero
                stz insrc+1

                stz state       ; STATE is zero (interpret mode)
                stz state+1
     
                ; The name token (nt) of DROP is always the first one in the
                ; new Dictionary, so we start off the Dictionary Pointer (DP)
                ; there. Anything that comes after that (with WORDS, before
                ; that) is high-level
                lda #<dictionary_start
                sta dp
                lda #>dictionary_start
                sta dp+1
 
                ; Clear the screen, assumes vt100 terminal
                jsr xt_page
     
                ; Define high-level words via EVALUATE. At this point, whatever
                ; is in Y (TOS) is garbage, so we don't have to push it to the 
                ; stack first
                ; dex
                ; dex
                ; dex
                ; dex
               
                ; lda #<high_level_start        ; start address goes TOS
                ; sta 0,x
                ; lda #>high_level_start  
                ; sta 0,1
                ;
                ; lda #<(high_level_end-high_level_start)
                ; sta 0,x
                ; lda #>(high_level_end-high_level_start)
                ; sta 1,x

                ; jsr xt_evaluate
                
                ; Define any user words via EVALUATE
                ; dex
                ; dex
                ; dex
                ; dex
               
                ; lda #<user_words_start        ; start address goes TOS
                ; sta 0,x
                ; lda #>user_words_start  
                ; sta 0,1
                ;
                ; lda #<(user_words_end-user_words_start)
                ; sta 0,x
                ; lda #>(user_words_end-user_words_start)
                ; sta 1,x
 
                ; jsr xt_evaluate
                
                ; fall through to ABORT


; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
; ## "abort"  src: ANSI core  b: TBA  c: TBA  status: fragment
        ; """Clear Data Stack and continue into QUIT. We can jump here via
        ; subroutine if we want to because we are going to reset the 65c02's
        ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
        ; actually delete the stuff on the Data Stack
        ; """
xt_abort:       ldx #dsp0


; ## QUIT ( _- ) "Reset the input and get new input"
; ## "quit"  src: ANSI core  b: TBA  c: TBA  status: fragment
        ; """Rest the input and start command loop.
        ; """
.scope
xt_quit:        
                ; clear Return Stack
                ldx #rsp0
                txs

                ; make sure instruction pointer is empty
                stz ip
                stz ip+1

                ; SOURCE-ID is keyboard import
                stz insrc
                stz insrc+1

                ; STATE is zero (interpret, not compile)
                stz state
                stz state+1

_get_line:
                ; empty current input buffer
                stz ciblen
                stz ciblen+1

                ; accept a line from the current import source
                jsr xt_refill           ; ( -- f ) 

                ; test flag: LSB of TOS
                lda 0,x
                bne _success

                ; If REFILL returned a FALSE flag, something went wrong and we
                ; need to print an error message and reset the machine. We don't
                ; need to save TOS because we're going to clobber it anyway when we
                ; go back to ABORT.
                lda #8                  ; code for error string refill 1
                jmp error 

_success:
                ; Assume we have successfully accepted a string of input from
                ; a source, with address cib and length of input in ciblen. We
                ; arrive here still with the TRUE flag from REFILL as TOS
                inx                     ; DROP
                inx
     
                ; make >IN point to begining of buffer
                stz toin 
                stz toin+1 
 
                ; Main compile/execute routine
                jsr interpret

                ; Test for Data Stack underflow. We don't check for
                ; overflow
                ; TODO enable
                ; cpx #dsp0
                ; bcc _stack_ok           ; DSP must always be smaller (!) than DSP0

                ; lda #11                 ; code for underflow es_underflow
                ; jmp error

_stack_ok:
                ; Display system prompt if all went well. If we're interpreting,
                ; this is " ok", if we're compiling, it's " compiled"
                lda state
                bne _compiled

                lda #0                  ; number for "ok" string
                bra _print
_compiled:
                lda #1                  ; number for "compiled" string
_print:
                jsr print_string

                ; Awesome line, everybody! Now get the next one
                bra _get_line

z_cold:         
z_abort:        
z_quit:         ; no RTS required
.scend


; ## ABORT_QUOTE ( -- ) "<TBA>"
; ## "abort""  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_abort_quote: nop
z_abort_quote:  rts
.scend


; ## ABS ( n -- u ) "Return absolute value of a number"
; ## "abs"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_abs:         
                lda 1,x 
                bpl _done       ; positive number, easy money!

                ; negative: calculate 0 - n
                sec
                lda #0
                sbc 0,x         ; LSB
                sta 0,x

                lda #0          ; MSB
                sbc 1,x
                sta 1,x

_done:
z_abs:          rts
.scend


; ## ACCEPT ( addr n -- n ) "Receive a string of characters"
; ## "accept"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """ Receive a string of at most n1 characters, placing them at
        ; addr. Return the actual number of characters as n2. Characters
        ; are echoed as they are received. ACCEPT is called by REFILL in
        ; modern Forths. This version accepts 256 chars max in the 
        ; current implementation
        ; """
.scope
xt_accept:
                ; Abort if we were asked to receive 0 chars 
                lda 0,x
                ora 1,x
                bne _not_zero
     
                ; return 0
                inx
                inx
                stz 0,x
                stz 1,x

                bra z_accept    ; no RTS so we can native compile

_not_zero:
                lda 0,x         ; number of chars to get in tmp2 ...
                sta tmp2
                stz tmp2+1      ; ... but we only accept max 256 chars

                lda 2,x         ; address of buffer is NOS, to tmp1
                sta tmp1 
                lda 3,x
                sta tmp1+1

                inx
                inx

                ldy #0

_loop:
                ; This is the internal version of KEY without all the mucking
                ; about with the Data Stack while still using the input vector
                jsr key_a

                ; we quit on both line feed and carriage return
                cmp #AscLF     
                beq _eol
                cmp #AscCR
                beq _eol

                ; BS and DEL do the same thing for the moment
                cmp #AscBS     
                beq _bs
                cmp #AscDEL     ; (CTRL-h)
                beq _bs

                ; CTRL-c aborts. At some point, consider moving this to the
                ; KEY routine
                cmp #AscCC     
                bne + 
                jmp xt_abort
*
                ; That's quite enough, echo character. EMIT_A sidesteps all the
                ; fooling around with the Data Stack
                jsr emit_a

                sta (tmp1),y
                iny
                cpy tmp2        ; reached character limit?
                bne _loop       ; fall thru if buffer limit reached

_eol:
                sty 0,x         ; Y contains number of chars accepted already
                stz 1,x         ; we only accept 256 chars

                jsr xt_space    ; print final space
                bra z_accept

_bs:
                cpy #0          ; buffer empty?
                bne +

                lda #AscBELL    ; complain and don't delete beyond the start of line
                jsr emit_a
                iny
*
                dey
                lda #AscBS      ; move back one
                jsr emit_a
                lda #AscSP      ; print a space (rubout) 
                jsr emit_a
                lda #AscBS      ; move back over space
                jsr emit_a

                bra _loop

z_accept:       rts
.scend


; ## AGAIN ( -- ) "<TBA>"
; ## "again"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_again:       nop
z_again:        rts
.scend

; ## ALIGN ( -- ) "<TBA>"
; ## "align"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_align:       nop
z_align:        rts
.scend

; ## ALIGNED ( -- ) "<TBA>"
; ## "aligned"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_aligned:     nop
z_aligned:      rts
.scend


; ## ALLOT ( n -- ) "Reserve or release memory"
; ## "allot"  src: ANSI core  b: TBA  c: TBA  status: tested
        ; """Reserve a certain number of bytes (not cells) or release them.
        ; If n = 0, do nothing. If n is negative, release n bytes, but only
        ; to the beginning of the Dictionary. If n is positive (the most
        ; common case), reserve n bytes, but not past the end of the 
        ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
        ; """
        ; TODO see what to do with the Dictionary Pointer (dp) memory is
        ; released to the beginning of the Dictionary
.scope
xt_allot:       
                ; if we were given a zero, forget the whole thing
                lda 0,x
                ora 1,x
                beq _done

                ; if we have a positive value, reserve space
                lda 1,x
                bmi _negative

                ; add positiv value
                clc
                lda 0,x
                adc cp
                sta cp

                lda 1,x
                adc cp+1
                sta cp+1

                ; make sure we haven't granted more than we have
                sec
                lda #<cp_end            
                sbc cp                  ; only need the carry
                lda #>cp_end
                sbc cp+1
                bpl _done               ; we're good

                ; we're not good, so we fail hard. This is going to be rare,
                ; and so it's not worth keeping the old values around to
                ; restore them. Instead, we reserve max memory
                lda #<cp_end
                sta cp
                lda #>cp_end
                sta cp+1

                lda #1                  ; error code for ALLOT
                jmp error

_negative:
                ; we were given a negative value, release space
                clc
                lda cp
                adc 0,x
                sta cp

                lda cp+1
                adc 1,x
                sta cp+1

                ; free at most to the beginning of the Dictionary space. Note
                ; this completely destroys the user's Dictionary. Currently,
                ; this leaves the Dictionary Pointer dangling, so this is probably
                ; not the best solution
                sec
                lda #<cp0
                sbc cp                  ; only need carry
                lda #>cp0
                sbc cp+1
                bmi _done               ; CP still > than CP0, we're good

                ; we're totally not good, set CP to CP0
                lda #<cp0
                sta cp
                lda #>cp0
                sta cp+1                ; drop through to _done

_done:          inx
                inx

z_allot:        rts
.scend


; ## AND ( n n -- n ) "Logically AND TOS and NOS"
; ## "and"  src: ANSI core  b: 14  c: TBA  status: coded
xt_and:         
                lda 0,x
                and 2,x
                sta 2,x

                lda 1,x
                and 3,x
                sta 3,x

                inx
                inx

z_and:          rts


; ## AT_XY ( n m -- ) "Move cursor to position given"
; ## "at-xy"  src: ANSI facility  b: TBA  c: TBA  status: TBA
        ; """On an ANSI compatible terminal, place cursor at row n colum m. 
        ; Code is ESC[<n>;<m>H Do not use U. to print the numbers because the 
        ; trailing space will not work with xterm 
        ; """
xt_at_xy:       
                lda #AscESC
                jsr emit_a
                lda #$5B        ; ASCII for "["
                jsr emit_a
                lda 3,x         ; n (x) is in MSB
                jsr byte_to_ascii
                lda #$3B        ; ASCII for ";"
                jsr emit_a
                lda 1,x         ; m (y) is in LSB
                jsr byte_to_ascii
                lda #'H         ; for Mac OS X 
                jsr emit_a

                inx             ; 2DROP
                inx
                inx
                inx
        
z_at_xy:        rts


; ## BACKSLASH ( -- ) "Ignore rest of line"
; ## "\"  src: ANSI core ext  b: 8  c: TBA  status: coded
xt_backslash:   
                lda ciblen
                sta toin
                lda ciblen+1
                sta toin+1

z_backslash:    rts


; ## BASE ( -- addr ) "Push address of radix base to stack"
; ## "base"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_base:        
                dex
                dex
                lda #<base
                sta 0,x
                lda #>base      ; paranoid, should always be zero
                sta 1,x

z_base:         rts


; ## BEGIN ( -- ) "<TBA>"
; ## "begin"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_begin:       nop
z_begin:        rts
.scend


; ## BELL ( -- ) "Emit ASCII BELL"
; ## "bell"  src: Tali Forth  b: TBA  c: TBA  status: tested
xt_bell:        
                lda #7          ; ASCII value for BELl
                jsr emit_a

z_bell:         rts


; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
; ## "bl"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_bl:          
                dex
                dex
                lda #AscSP
                sta 0,x
                stz 1,x

z_bl:           rts
.scend


; ## BOUNDS ( -- ) "<TBA>"
; ## "bounds"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_bounds:      nop
z_bounds:       rts
.scend

; ## BRACKET_CHAR ( -- ) "<TBA>"
; ## "[char]"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_bracket_char:
                nop
z_bracket_char: rts
.scend

; ## BRACKET_TICK ( -- ) "<TBA>"
; ## "[']"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_bracket_tick:
                nop
z_bracket_tick: rts
.scend

; ## BRANCH ( -- ) "<TBA>"
; ## "branch"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_branch:      nop
z_branch:       rts
.scend


; ## BYE ( -- ) "Break"
; ## "bye"  src: ANSI tools ext  b: TBA  c: TBA  status: coded
.scope
xt_bye:         
                brk
z_bye:          rts             ; never reached
.scend


; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
; ## "c,"  src: ANSI core  b: TBA  c: TBA  status: coded
; TODO make sure we haven't allocated more than we have
.scope
xt_c_comma:     
                lda 0,x
                sta (cp)

                ; increase CP to the next byte
                inc cp
                bne _done
                inc cp+1
_done:
                inx
                inx

z_c_comma:      rts
.scend


; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
; ## "c@"  src: ANSI core  b: 6  c: TBA  status: coded
xt_c_fetch:     
                lda (0,x)
                sta 0,x
                stz 1,x

z_c_fetch:      rts


; ## C_STORE ( c addr -- ) "Store character at address given"
; ## "c!"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_c_store:     
                lda 2,x
                sta (0,x)

                inx
                inx
                inx
                inx

z_c_store:      rts


; ## CELL_PLUS ( -- ) "<TBA>"
; ## "cell+"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_cell_plus:   nop
z_cell_plus:    rts
.scend


; ## CHAR ( -- ) "<TBA>"
; ## "char"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_char:        nop
z_char:         rts
.scend


; ## CHARS ( n -- n ) "Number of bytes that n chars need"
; ## "chars"  src: ANSI core  b: 0  c: TBA  status: tested
.scope
xt_chars:       nop             ; removed during native compile
z_chars:        rts
.scend


; ## CMOVE ( -- ) "<TBA>"
; ## "cmove"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_cmove:       nop
z_cmove:        rts
.scend

; ## CMOVE_UP ( -- ) "<TBA>"
; ## "cmove>"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_cmove_up:    nop
z_cmove_up:     rts
.scend

; ## COLON ( -- ) "<TBA>"
; ## ":"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_colon:       nop
z_colon:        rts
.scend


; ## COMMA ( n -- ) "Allot and store one cell in memory"
; ## ","  src: ANSI core  b: 22  c: TBA  status: coded
        ; """Store TOS at current place in memory. Since this an eight-bit
        ; machine, we can ignore all alignment issures
        ; """
        ; TODO make sure we don't allot more than we have
.scope
xt_comma:
                lda 0,x
                sta (cp)

                inc cp
                bne _msb
                inc cp+1
_msb:
                lda 1,x
                sta (cp)

                inc cp
                bne _done
                inc cp+1
_done:
                inx
                inx
       
z_comma:        rts
.scend


; ## COMPILE_COMMA ( -- ) "<TBA>"
; ## "compile,"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_compile_comma:
                nop
z_compile_comma:
                rts
.scend


; ## COMPILE_ONLY ( -- ) "<TBA>"
; ## "compile-only"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_compile_only:
                nop
z_compile_only: rts
.scend


; ## CONSTANT ( n "name" -- ) "Define a constant"
; ## "constant"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Forth equivalent is  CREATE , DOES> @  but we do
        ; more in assembler and let CREATE do the heavy lifting.
        ; See http://www.bradrodriguez.com/papers/moving3.htm for
        ; a primer on how this works in various Forths.
        ; """
xt_constant:    
                jsr xt_create

                ; CREATE by default installs a subroutine jump to DOVAR,
                ; but we want DOCONST for constants. Go back two bytes and
                ; replace the subroutine jump target
                lda cp
                sbc #2
                sta tmp1
                lda cp+1
                sbc #0
                sta tmp1+1

                lda #<doconst   ; LSB of DOCONST
                sta (tmp1)
                inc tmp1
                bne +
                inc tmp1+1
*
                lda #>doconst   ; MSB of DOCONST
                sta (tmp1)

                ; Now we save the constant number itself in the next cell
                jsr xt_comma            ; drop through to adjust_z

adjust_z:
    		; Now the length of the complete word (z_word) has increased by
                ; two. We need to update that number or else words such as SEE
                ; will ignore the PFA. We use this same routine for VARIABLE,
                ; VALUE and DEFER
                jsr xt_latestnt         ; gives us ( nt )

                ; z_word is six bytes further down
                lda 0,x
                clc
                adc #6
                sta tmp1
                lda 1,x
                adc #0          ; only need carry
                sta tmp1+1

                lda (tmp1)
                clc
                adc #2
                sta tmp2
                ldy #1
                lda (tmp1),y
                adc #0          ; only need carry

                tay             ; hold on to MSB while we update target
                inc tmp1
                bne +
                inc tmp1
*               
                tya
                sta (tmp1)
              
                inx
                inx

z_constant:     rts

; ## COUNT ( -- ) "<TBA>"
; ## "count"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_count:       nop
z_count:        rts
.scend


; ## CR ( -- ) "Print a line feed"
; ## "cr"  src: ANSI core  b: 5  c: TBA  status: tested
xt_cr:         
                lda #AscLF
                jsr emit_a
z_cr:           rts


; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
; ## "create"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """See the drawing in headers.asm for details on the header
        ; """
.scope
xt_create:      
                ; get string
                jsr xt_parse_name       ; ( addr u )

                ; if we were given an empty string, we complain and quit
                lda 0,x
                ora 1,x
                bne _got_name

                lda #6
                jmp error

_got_name:
                ; Enforce maximal length of string by overwriting the MSB of 
                ; the length. There is a possible error here: If the string
                ; is exactly 255 chars long, then a lot of the following
                ; additions will fail because of wrapping
                ; TODO fix this
                stz 1,x

                lda 0,x
                sta tmp2                ; store length of string in tmp2
                
                ; remember the first free byte of memory as the start of
                ; the new word
                lda cp
                sta tmp1
                lda cp+1
                sta tmp1+1

                ; we need 8 bytes plus the length of the string for our new header.
                ; This is also the offset for the start of the code field (the
                ; xt_ label) so we need to remember it. Otherwise, we could 
                ; just allot the space afterwards
                lda 0,x
                clc
                adc #8
                sta tmp3                ; total header length

                ; We need three more bytes for for the hardcoded code field
                ; area (CFA), the "payload" of the word which by default will
                ; be a subroutine jump to DOVAR
                clc
                adc #3
                
                ; We overwrite the length of the string returned by PARSE-NAME
                ; and then call ALLOT
                sta 0,x
                stz 1,x         ; max header size is 255 chars
                jsr xt_allot    ; ( addr ) 
                
                ; Now we walk through the header with Y as the index, adding
                ; information byte-by-byte
                ldy #0

                ; HEADER BYTE 0: Length of string
                lda tmp2
                sta (tmp1),y

                ; HEADER BYTE 1: Status byte
                tya                     ; STZ doesn't have "STZ (TMP1),Y"
                iny 
                sta (tmp1),y
                iny

                ; HEADER BYTE 2,3: Next header. This is the current last word
                ; in the Dictionary
                lda dp
                sta (tmp1),y
                iny
                lda dp+1
                sta (tmp1),y
                iny
                
                ; Interlude: Make old CP new DP (new start of Dictionary)
                lda tmp1+1
                sta dp+1
                lda tmp1
                sta dp

                ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
                ; This begins after the header so we take the length of the
                ; header, which we cleverly saved in tmp3, and use it as an
                ; offset to the address of the start of the word. We come here
                ; with tmp1 in A
                clc
                adc tmp3        ; add total header length
                sta (tmp1),y
                pha             ; we need this in the next step
                iny

                lda tmp1+1
                adc #0          ; only need the carry
                sta (tmp1),y
                iny

                ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
                ; we execute a jump to the DOVAR routine, so we need to move three
                ; bytes down, and then one more byte so that the z_ label points
                ; to the (still fictional) RTS instruction for correct compilation
                pla             ; LSB of "z_" address
                clc
                adc #3
                sta (tmp1),y
                
                dey             ; get the MSB of xt back
                lda (tmp1),y
                adc #0          ; only need the carry
                iny
                iny
                sta (tmp1),y
                iny
                
                ; HEADER BYTE 8: Start of name string. The address is TOS, the
                ; length in tmp2. We subtract 8 from the address so we can
                ; use the same loop index, which is already 8 byte ahead at
                ; this point
                lda 0,x
                sec
                sbc #8
                sta tmptos

                lda 1,x
                sbc #0          ; only need carry
                sta tmptos+1

_name_loop:
                lda (tmptos),y
                sta (tmp1),y
                iny
                dec tmp2
                bne _name_loop

                ; After thename string comes the code field, starting at the
                ; current xt of this word, which is initially a jump to the
                ; subroutine to DOVAR. We code this jump by hand
                lda #$20        ; opcode of JSR
                sta (tmp1),y
                iny
                lda #<dovar
                sta (tmp1),y
                iny
                lda #>dovar
                sta (tmp1),y

                ; And we're done. Restore stack
                inx
                inx

z_create:       rts
.scend


; ## D_DOT ( -- ) "<TBA>"
; ## "d."  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_dot:       nop
z_d_dot:        rts
.scend

; ## D_MINUS ( -- ) "<TBA>"
; ## "d-"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_minus:     nop
z_d_minus:      rts
.scend

; ## D_PLUS ( -- ) "<TBA>"
; ## "d+"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_plus:      nop
z_d_plus:       rts
.scend

; ## D_R ( -- ) "<TBA>"
; ## "d.r"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_r:         nop
z_d_r:          rts
.scend

; ## D_TO_S ( -- ) "<TBA>"
; ## "d>s"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_d_to_s:      nop
z_d_to_s:       rts
.scend

; ## DABS ( -- ) "<TBA>"
; ## "dabs"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_dabs:        nop
z_dabs:         rts
.scend


; ## DECIMAL ( -- ) "Change radix base to decimal"
; ## "decimal"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_decimal:     
                lda #10
                sta base
                stz base+1              ; paranoid

z_decimal:      rts


; ## DEFER ( -- ) "<TBA>"
; ## "defer"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_defer:       nop
z_defer:        rts
.scend


; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
; ## "depth"  src: ANSI core  b: 14  c: TBA  status: coded
xt_depth:       
                stx tmpdsp
                lda dsp0
                sec
                sbc tmpdsp

                ; divide by two because each cell is two bytes
                lsr

                dex
                dex
                sta 0,x
                stz 1,x

z_depth:        rts


; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
; ## "digit?"  src: Tali Forth  b: TBA  c: TBA  status: coded
        ; """Inspired by the pForth instruction DIGIT, see
        ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
        ; pForth, we get the base (radix) ourselves instead of having the
        ; user provide it. There is no standard name for this routine, which
        ; itself is not ANSI; we use DIGIT? following pForth and Gforth. 
        ; """
.scope
xt_digit_question:
                ; one way or another, we're going to need room for the
                ; flag on the stack
                dex
                dex
                stz 0,x                 ; default flag is failure
                stz 1,x
                stz 3,x                 ; paranoid

                ; Check the character, now in the LSB of NOS. First, make
                ; sure we're not below the ASCII code for "0"
                lda 2,x
                cmp #'0
                bcc _done               ; failure flag already set

                ; Next, see if we are below "9", because that would make
                ; this a normal number
                cmp #'9+1               ; this is actually ":"
                bcc _checkbase

                ; Well, then let's if this is the gap between "9" and "A"
                ; so we can treat the whole range as a number
                cmp #'A-1               ; this is actually "@"
                bcc _done               ; failure flag is already set

                ; probably a letter, so we make sure it is uppercase
                cmp #'a
                bcc _case_done          ; not lower case, too low
                cmp #'z+1
                bcs _case_done          ; not lower case, too high

                clc                     ; just right
                adc #$e0                ; offset to upper case (wraps)

_case_done:
                ; get rid of the gap between "9" and "A" so we can treat
                ; the whole range as one number
                sec
                sbc #7                  ; fall through to _checkbase

_checkbase:
                ; we have a number, now see if it falls inside the range
                ; provided by BASE
                sec
                sbc #'0                 ; this is also the conversion step
                cmp base
                bcs _done               ; already have false flag

                ; Found a legal number
                sta 2,x                 ; put number in NOS
                dec 0,x                 ; set success flag
                dec 1,x

_done:
z_digit_question:
                rts
.scend


; ## DNEGATE ( d -- d ) "Negate double cell number"
; ## "dnegate"  src: ANSI double  b: 33  c: TBA  status: coded
xt_dnegate:     
                lda 2,x         ; LSB of low cell
                eor #$ff
                clc
                adc #1
                sta 2,x

                lda 3,x         ; MSB of low cell
                eor #$ff
                adc #0          ; just need carry
                sta 3,x

                lda 0,x         ; LSB of high cell
                eor #$ff
                adc #0          ; again, just need carry
                sta 0,x

                lda 1,x         ; MSB of high cell
                eor #$ff
                adc #0          ; again, just need carry
                sta 1,x

z_dnegate:      rts


; ## DO ( -- ) "<TBA>"
; ## "do"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_do:          nop
z_do:           rts
.scend

; ## DOES ( -- ) "<TBA>"
; ## "does>"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_does:        nop
z_does:         rts
.scend

; ## DOT ( u -- ) "Print TOS"
; ## "."  src: ANSI core  b: TBA  c: TBA  status: TBA
; TODO This is a temporary version
.scope
xt_dot:         lda 1,x
                jsr byte_to_ascii
                lda 0,x
                jsr byte_to_ascii
                inx
                inx

z_dot:          rts
.scend

; ## DOT_BYTE ( -- ) "<TBA>"
; ## ".byte"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_dot_byte:    nop
z_dot_byte:     rts
.scend

; ## DOT_PAREN ( -- ) "<TBA>"
; ## ".("  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_dot_paren:   nop
z_dot_paren:    rts
.scend

; ## DOT_QUOTE ( -- ) "<TBA>"
; ## ".""  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_dot_quote:   nop
z_dot_quote:    rts
.scend

; ## DOT_R ( -- ) "<TBA>"
; ## ".r"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_dot_r:       nop
z_dot_r:        rts
.scend

; ## DOT_S ( -- ) "<TBA>"
; ## ".s"  src: ANSI tools  b: TBA  c: TBA  status: TBA
.scope
xt_dot_s:       nop
z_dot_s:        rts
.scend


; ## DROP ( u -- ) "Pop top entry on Data Stack"
; ## "drop"  src: ANSI core  b: 2  c: 4  status: tested
xt_drop:        
                inx             ; drop
                inx
z_drop:         rts


; ## DUMP ( addr u -- ) "Display a memory region"
; ## "dump"  src: ANSI tools  b: TBA  c: TBA  status: TBA
.scope
xt_dump:        nop
z_dump:         rts
.scend


; ## DUP ( u -- u u ) "Duplicate TOS"
; ## "dup"  src: ANSI core  b: TBA  c: TBA  status: coded
xt_dup:         
                dex
                dex

                lda 2,x         ; LSB
                sta 0,x
                lda 3,x         ; MSB
                sta 1,x

z_dup:          rts


; ## ELSE ( -- ) "<TBA>"
; ## "else"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_else:        nop
z_else:         rts
.scend


; ## EMIT ( char -- ) "Print character to current output"
; ## "emit"  src: ANSI core  b: TBA  c: TBA  status: tested
xt_emit:
        ; """Run-time default for EMIT. The user can revector this by changing
        ; the value of the OUTPUT variable. We ignore the MSB completely, and 
        ; do not check to see if we have been given a valid ASCII character. 
        ; Don't make this native compile
        ; """
                lda 0,x
                inx
                inx

emit_a:
        ; We frequently want to print the character in A without fooling
        ; around with the Data Stack. This is emit_a's job, which still
        ; allows the output to be vectored. Call it with JSR as you 
        ; would XT_EMIT
                jmp (output)            ; JSR/RTS

z_emit:         ; never reached 


; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
; ## "="  src: ANSI core  b: 24  c: TBA  status: coded
.scope
xt_equal:       
                lda 0,x                 ; LSB
                cmp 2,x
                bne _false

                lda 1,x                 ; MSB
                cmp 3,x
                bne _false

                lda #$ff
                bra _done

_false:         lda #0                  ; drop thru to done

_done:          sta 2,x
                sta 3,x

                inx
                inx

z_equal:        rts
.scend


; ## ERASE ( addr u -- ) "<TBA>"
; ## "erase"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_erase:       nop
z_erase:        rts
.scend

; ## EVALUATE ( -- ) "<TBA>"
; ## "evaluate"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_evaluate:    nop
z_evaluate:     rts
.scend


; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
; ## "execute"  src: ANSI core  b: 19  c: TBA  status: tested
.scope
xt_execute:     
                lda 0,x
                sta ip
                lda 1,x
                sta ip+1
                
                inx
                inx

                ; Only JMP has the addressing mode we need, but all our
                ; Forth words end with a RTS instruction. We fake the 
                ; return address by pushing the correct address to the stack
                ; We'll land on a NOP so we don't have to DEC the return
                ; address
                lda #>_done     ; push MSB first
                pha
                lda #<_done
                pha

                jmp (ip)

_done:          ; keep the NOP here as the landing site for the indirect 
                ; subroutine jump (easier and quicker than adjusting the
                ; return address on the stack)
                nop             ; never reached

z_execute:      rts
.scend


; ## EXIT ( -- ) "<TBA>"
; ## "exit"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_exit:        nop
z_exit:         rts
.scend

;
; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
; ## "false"  src: ANSI core ext  b: TBA  c: TBA  status: coded
xt_false:       
                dex
                dex
                stz 0,x
                stz 1,x

z_false:        rts


; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
; ## "@"  src: ANSI core  b: 16  c: TBA  status: coded
xt_fetch:       
                lda (0,x)       ; LSB
                tay
                inc 0,x
                bne +
                inc 1,x
*
                lda (0,x)       ; MSB
                sta 1,x
                tya
                sta 0,x

z_fetch:        rts


; ## FILL ( -- ) "<TBA>"
; ## "fill"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_fill:        nop
z_fill:         rts
.scend

; ## FIND ( -- ) "<TBA>"
; ## "find"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_find:        nop
z_find:         rts
.scend


; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
; ## "find-name"  src: Gforth  b: TBA  c: TBA  status: coded
.scope
xt_find_name:
        ; """Given a string, find the Name Token (nt) of a word or return
        ; zero if the word is not in the dictionary. We use this instead of
        ; ancient FIND to look up words in the Dictionary passed by
        ; PARSE-NAME. Note this returns the nt, not the xt of a word like
        ; FIND. To convert, use NAME>INT. This is a Gforth word. See
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html 
        ; FIND calls this word
        ; """
        
                ; check for special case of an empty string (length zero)
                lda 0,x
                ora 1,x
                beq _fail_done          ; this might have to be JMP

_have_string:
                ; set up first loop iteration
                lda dp                  ; nt of first word in Dictionary
                sta tmp1
                lda dp+1
                sta tmp1+1

                lda 2,x                 ; Address of mystery string
                sta tmp2
                lda 3,x
                sta tmp2+1

_loop:
                ; first quick test: Are strings the same length?
                lda (tmp1)
                cmp 0,x
                bne _next_entry

_compare_string:
                ; are the same length, so we now have to compare each
                ; character

                ; second quick test: Is the first character the same?
                ldy #8
                lda (tmp1),y
                cmp (tmp2)              ; first character of mystery string
                bne _next_entry

                ; string length are the same and the first character is the
                ; same. If the length of the string is 1, we're already done
                lda 0,x
                dec
                beq _success

                ; No such luck: The strings are the same length and the first
                ; char is the same, but the word is more than one char long.
                ; So we suck it up and compare every single character. We go
                ; from back to front, because words like CELLS and CELL+ would
                ; take longer otherwise. We can also shorten the loop by one
                ; because we've already compared the first char. 

                ; The string of the word we're testing against is 8 bytes down
                lda tmp1
                clc
                adc #8
                sta tmp3        ; we preserve tmp1
                lda tmp1+1
                adc #0          ; we only need the carry
                sta tmp3+1

                ldy 0,x         ; index is length of string minus 1
                dey

_string_loop:
                lda (tmp2),y    ; last char of mystery string
                cmp (tmp3),y    ; last char of word we're testing against
                bne _next_entry

                dey
                bne _string_loop

_success:
                ; the strings match. Put correct nt NOS, because we'll drop
                ; TOS before we leave
                lda tmp1
                sta 2,x
                lda tmp1+1
                sta 3,x

                bra _done

_next_entry:
                ; not the same, so we get the next word. Next header
                ; address is two bytes down
                ldy #2
                lda (tmp1),y
                pha
                iny
                lda (tmp1),y
                sta tmp1+1
                pla
                sta tmp1

                ; if we got a zero, we've walked the whole Dictionary and
                ; return as a failure, otherwise try again
                ora tmp1+1
                bne _loop       ; fall through to _fail_done

_fail_done:
                stz 2,x         ; failure flag
                stz 3,x
_done: 
                inx
                inx

z_find_name:    rts
.scend


; ## FM_SLASH_MOD ( -- ) "<TBA>"
; ## "fm/mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_fm_slash_mod:
                nop
z_fm_slash_mod: rts
.scend

; ## GREATER_THAN ( -- ) "<TBA>"
; ## ">"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_greater_than:
                nop
z_greater_than: rts
.scend


; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
; ## "here"  src: ANSI core  b: 10  c: TBA  status: coded
xt_here:        
                dex
                dex
                lda cp
                sta 0,x
                lda cp+1
                sta 1,x

z_here:         rts


; ## HEX ( -- ) "Change base radix to hexadecimal"
; ## "hex"  src: ANSI core ext  b: 6  c: TBA  status: coded
xt_hex:         
                lda #$10
                sta base
                stz base+1              ; paranoid
z_hex:          rts



; ## HOLD ( char -- ) "Insert character at current output"
; ## "hold"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Insert a character at the current position of a pictured numeric
        ; output string on 
        ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
        ; variable tohold instead of HLD.
        ; """
xt_hold:        
                dec tohold
                bne +
                dec tohold+1
*
                sta (tohold)
                inx
                inx

z_hold:         rts


; ## I ( -- ) "<TBA>"
; ## "i"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_i:           nop
z_i:            rts
.scend

; ## IF ( -- ) "<TBA>"
; ## "if"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_if:          nop
z_if:           rts
.scend

; ## IMMEDIATE ( -- ) "<TBA>"
; ## "immediate"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_immediate:   nop
z_immediate:    rts
.scend

; ## INPUT ( -- ) "<TBA>"
; ## "input"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_input:       nop
z_input:        rts
.scend

; ## INT_TO_NAME ( -- ) "<TBA>"
; ## "int>name"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_int_to_name: nop
z_int_to_name:  rts
.scend

; ## INVERT ( -- ) "<TBA>"
; ## "invert"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_invert:      nop
z_invert:       rts
.scend

; ## J ( -- ) "<TBA>"
; ## "j"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_j:           nop
z_j:            rts
.scend


; ## KEY ( -- char ) "Get one character from the input"
; ## "key"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_key:         
        ; """Get a single character of input from the vectored
        ; input without echoing.
        ; """
                jsr key_a               ; returns char in A
                
                dex
                dex
                sta 0,x
                stz 1,x

                rts

key_a:
        ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
        ; 65816, so we have to fake the indirect jump to vector it.
        ; This is depressingly slow. We use this routine internally
        ; to avoid manipulating the Data Stack when we just want a
        ; character
                jmp (input)             ; JSR/RTS

z_key:          ; never reached
.scend


; ## KEY_QUESTION ( -- ) "<TBA>"
; ## "key?"  src: ANSI facility  b: TBA  c: TBA  status: TBA
.scope
xt_key_question:
                nop
z_key_question: rts
.scend


; ## LATESTNT ( -- nt ) "Push most recent nt to stack"
; ## "latestnt"  src: Tali Forth  b: 10  c: TBA  status: coded
        ; """The Gforth version of this word is called LATEST
        ; """
xt_latestnt:
                dex
                dex

                lda dp
                sta 0,x
                lda dp+1
                sta 1,x 

z_latestnt:     rts


; ## LATESTXT ( -- xt ) "<TBA>"
; ## "latestxt"  src: Gforth  b: TBA  c: TBA  status: coded
xt_latestxt:    
                jsr xt_latestnt         ; ( nt )
                jsr xt_name_to_int      ; ( xt ) 
z_latestxt:     rts


; ## LEAVE ( -- ) "<TBA>"
; ## "leave"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_leave:       nop
z_leave:        rts
.scend

; ## LEFT_BRACKET ( -- ) "<TBA>"
; ## "["  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_left_bracket:
                nop
z_left_bracket: rts
.scend

; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
; ## "<#"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Start the process to create pictured numeric output. The new
        ; string is constructed from back to front, saving the new character
        ; at the beginning of the output string. Since we use PAD as a 
        ; starting address and work backward (!), the string is constructed
        ; in the space between the end of the Dictionary (as defined by CP)
        ; and the PAD. This allows us to satisfy the ANS Forth condition that
        ; programs don't fool around with the PAD but still use its address.
        ; Code based on pForth, see
        ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
        ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
        ; internal variable tohold instead of HLD.
        ; """
xt_less_number_sign:
                jsr xt_pad

                lda 0,x
                sta tohold
                lda 1,x
                sta tohold+1

                inx
                inx
z_less_number_sign:
                rts

; ## LESS_THAN ( -- ) "<TBA>"
; ## "<"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_less_than:   nop
z_less_than:    rts
.scend

; ## LITERAL ( -- ) "<TBA>"
; ## "literal"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_literal:     nop
z_literal:      rts
literal_rt:
.scend

; ## LOOP ( -- ) "<TBA>"
; ## "loop"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_loop:        nop
z_loop:         rts
.scend

; ## LSHIFT ( -- ) "<TBA>"
; ## "lshift"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_lshift:      nop
z_lshift:       rts
.scend


; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
; ## "m*"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Multiply two 16 bit numbers, producing a 32 bit result. All
        ; values are signed. Adapted from FIG Forth for Tali Forth. The
        ; original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
        ; with  : D+- O< IF DNEGATE THEN ;  FIG Forth is in the public domain
        ; """
        
.scope
xt_m_star:
                ; figure out the sign
                lda 1,x         ; MSB of n1
                eor 3,x         ; MSB of n2

                ; UM* uses all kinds of temporary variables so we don't
                ; risk a conflict but just take the cycle hit and push
                ; this to the stack
                pha

                ; get the absolute value of both numbers so we can feed
                ; them to UM*, which does the real work
                ; TODO convert this to assembler for speed
                jsr xt_abs
                jsr xt_swap
                jsr xt_abs

                jsr xt_um_star          ; ( d ) 

                ; handle the sign
                pla
                bpl _done

                jsr xt_dnegate
_done:
z_m_star:       rts
.scend


; ## MARKER ( -- ) "<TBA>"
; ## "marker"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_marker:      nop
z_marker:       rts
.scend


; ## MAX ( n n -- n ) "Keep larger of two numbers"
; ## "max"  src: ANSI core  b: 24  c: TBA  status: coded
        ; """Compare TOS and NOS and keep which one is larger. Adapted from
        ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
        ; Flag indicates which number is larger. See also 
        ; http://6502.org/tutorials/compare_instructions.html and
        ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html 
        ; """
.scope
xt_max:         
                ; Compare LSB. We do this first to set the carry flag
                lda 0,x         ; LSB of TOS
                cmp 2,x         ; LSB of NOS, this sets the carry

                lda 1,x         ; MSB of TOS
                sbc 3,x         ; MSB of NOS
                bvc _no_overflow

                ; handle overflow, because we use signed numbers
                eor #$80        ; complement negative flag

_no_overflow:
                ; if negative, NOS is larger and needs to be kept
                bmi _keep_nos

                ; move TOS to NOS
                lda 0,x
                sta 2,x
                lda 1,x
                sta 3,x

_keep_nos:
                inx
                inx

z_max:          rts
.scend


; ## MIN ( n n -- n ) "Keep smaller of two numbers"
; ## "min"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Adapted from Lance A. Leventhal "6502 Assembly Language
        ; Subroutines." Negative Flag indicateds which number is larger. See
        ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html 
        ; """
.scope
xt_min:         ; compare LSB. We do this first to set the carry flag
                lda 0,x         ; LSB of TOS
                cmp 2,x         ; LSB of NOS, this sets carry

                lda 1,x         ; MSB of TOS
                sbc 3,x         ; MSB of NOS
                bvc _no_overflow

                ; handle overflow because we use signed numbers
                eor #$80

_no_overflow:
                ; if negative, NOS is larger and needs to be dumped
                bpl _keep_nos
                
                ; move TOS to NOS
                lda 0,x
                sta 2,x
                lda 1,x
                sta 3,x

_keep_nos:
                inx
                inx

z_min:          rts
.scend


; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
; ## "-"  src: ANSI core  b: 15  c: TBA  status: coded
xt_minus:       
                sec
                lda 2,x         ; LSB
                sbc 0,x
                sta 2,x

                lda 3,x         ; MSB
                sbc 1,x
                sta 3,x
                
                inx
                inx

z_minus:        rts


; ## MINUS_TRAILING ( -- ) "<TBA>"
; ## "-trailing"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_minus_trailing:
                nop
z_minus_trailing:
                rts
.scend

; ## MOD ( -- ) "<TBA>"
; ## "mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_mod:         nop
z_mod:          rts
.scend


; ## MOVE ( -- ) "<TBA>"
; ## "move"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_move:        nop
z_move:         rts
.scend


; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
; ## "name>int"  src: Gforth  b: 11  c: TBA  status: coded
; TODO deal with compile-only words
.scope
xt_name_to_int: 
        ; """See
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
        ; """ 
                ; The xt starts four bytes down from the nt
                lda 0,x
                clc
                adc #4
                sta tmp3

                lda 1,x
                bcc _done
                inc
_done:
                sta tmp3+1

                ldy #0
                lda (tmp3),y
                sta 0,x
                iny
                lda (tmp3),y
                sta 1,x

z_name_to_int:  rts
.scend


; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
; ## "name>string"  src: Gforth  b: TBA  c: TBA  status: coded
.scope
xt_name_to_string:

                dex
                dex

                ; the length of the string is the first byte of the
                ; header pointed to by nt
                lda (2,x)
                sta 0,x
                stz 1,x

                ; the string itself always starts eight bytes down
                lda 2,x         ; LSB
                clc
                adc #8
                tay
                lda 3,x         ; MSB
                adc #0          ; just need carry
                sta 3,x
                sty 2,x
                 
z_name_to_string:
                rts
.scend

; ## NC_LIMIT ( -- ) "<TBA>"
; ## "nc-limit"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_nc_limit:    nop
z_nc_limit:     rts
.scend


; ## NEGATE ( n -- n ) "Two's complement"
; ## "negate"  src: ANSI core  b: 17  c: TBA  status: coded
xt_negate:      
                lda 0,x         ; LSB
                eor #$ff
                clc
                adc #1
                sta 0,x

                lda 1,x         ; MSB
                eor #$ff
                adc #0          ; only need the carry
                sta 1,x

z_negate:       rts


; ## NEVER_COMPILE ( -- ) "<TBA>"
; ## "never-compile"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_never_compile:
                nop
z_never_compile:
                rts
.scend


; ## NIP ( b a -- a ) "Delete NOS"
; ## "nip"  src: ANSI core ext  b: 10  c: TBA  status: coded
xt_nip:         
                lda 0,x         ; LSB
                sta 2,x
                lda 1,x         ; MSB
                sta 3,x
                inx
                inx

z_nip:          rts


; ## NOT_EQUALS ( -- ) "<TBA>"
; ## "<>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_not_equals:  nop
z_not_equals:   rts
.scend

; ## NOT_ROTE ( -- ) "<TBA>"
; ## "-rot"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_not_rote:    nop
z_not_rote:     rts
.scend


; ## NUMBER ( addr u -- u | d ) "Convert a number string"
; ## "number"  src: Tali Forth  b: TBA  c: TBA  status: TBA
        ; """Convert a number string to a double or single cell number. This
        ; is a wrapper for >NUMBER and follows the convention set out in the 
        ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
        ; Based in part on the "Starting Forth" code 
        ; https://www.forth.com/starting-forth/10-input-output-operators/
        ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
        ; Another difference to Gforth is that we follow ANSI Forth that the
        ; dot to signal a double cell number is required to be the last
        ; character of the string. Number calls >NUMBER which in turn calls UM*,
        ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
        ; a pain. 
        ;"""
.scope
xt_number:      
                ; we keep the flags for sign and double in tmpdsp because
                ; we've run out of temporary variables
                stz tmpdsp      ; flag for double
                stz tmpdsp+1    ; flag for minus

                ; If the first character is a minus, strip it off and set
                ; the flag
                lda (2,x)
                cmp #$2d        ; ASCII for "-"
                bne _check_dot

                ; It's a minus
                dec tmpdsp+1
                inc 2,x         ; start one character later
                bne +
                inc 3,x
*
                dec 0,x         ; decrease string length by one
                
                ; TODO check to see what happens if we are given a single
                ; minus as the string

_check_dot:
                ; If the last character is a dot, strip it off and set a
                ; flag. We can use tmptos as a temporary variable
                lda 2,x         ; LSB of address
                clc
                adc 0,x         ; length of string
                sta tmptos
                lda 3,x
                adc #0          ; only need carry
                sta tmptos+1

                ; tmptos now points to the first character after the string,
                ; but we need the last character
                lda tmptos
                bne +
                dec tmptos+1
*               dec tmptos

                lda (tmptos)
                cmp #'.
                bne _main

                ; We have a dot, which means this is a double number. Flag
                ; the fact and reduce string length by one
                dec tmpdsp
                dec 0,x
_main:                
                ; set up stack for subroutine jump to >NUMBER, which means
                ; we have to go ( addr u --> ud addr u )
                dex
                dex
                dex
                dex

                lda 4,x         ; LSB of length
                sta 0,x
                stz 1,x         ; max length 255 chars

                lda 6,x         ; LSB of address
                sta 2,x
                lda 7,x
                sta 3,x

                stz 4,x         ; clear space for ud
                stz 5,x
                stz 6,x
                stz 7,x

                jsr xt_to_number        ; (ud addr u -- ud addr u )

                ; test length of returned string, which should be zero
                lda 0,x
                beq _all_converted

                ; Something went wrong, we still have characters left over,
                ; so we print an error and abort. If the NUMBER was called
                ; by INTERPRET, we've already checked for Forth words, so
                ; we're in deep trouble one way or another
                lda #12         ; code for Syntax error
                jmp error
                
_all_converted:
                ; We can drop the string info
                inx
                inx
                inx
                inx

                ; We have a double-cell number on the Data Stack that might
                ; actually have a minus and might actually be single-cell
                lda tmpdsp      ; flag for double
                beq _single

                ; This is a double cell number. If it had a minus, we'll have
                ; to negate it
                lda tmpdsp+1
                beq _done       ; no minus, all done

                jsr xt_dnegate

                bra _done
_single:
                ; This is a single number, so we just drop the top cell
                inx
                inx

                ; If we had a minus, we'll have to negate it
                lda tmpdsp+1
                beq _done       ; no minus, all done

                jsr xt_negate
_done:                
z_number:       rts
.scend


; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
; ## "#"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Add one char to the beginning of the pictured output string. Based
        ; on https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
        ; """
        ; TODO convert more parts to assembler
        
xt_number_sign:        
                jsr xt_base
                jsr xt_fetch            ; ( ud1 base )
                jsr xt_ud_slash_mod     ; ( rem ud )
                jsr xt_rot              ; ( ud rem ) 

                ; Convert the number that is left over to an ASCII character. We
                ; use a string lookup for speed. Use either abc_str_lower for
                ; lower case or abc_str_upper for upper case (prefered)
                lda 0,x
                tay
                lda s_abc_upper,y
                sta 0,x
                stz 1,x                 ; paranoid; now (ud char) 

                jsr xt_hold

z_number_sign:
		rts


; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
; ## "#>"  src: ANSI core  b: 26  c: TBA  status: coded
        ; """Finish conversion of pictured number string, putting address and
        ; length on the Data Stack. Original Fort is  2DROP HLD @ PAD OVER -
        ; Based on
        ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; """
xt_number_sign_greater:
                
                ; The start address lives in tohold
                lda tohold
                sta 2,x
                lda tohold+1
                sta 3,x         ; ( addr ud )

                ; The length of the string is pad - addr
                jsr xt_pad      ; ( addr ud pad ) 

                lda 0,x         ; LSB
                sec
                sbc 4,x
                sta 2,x

                lda 1,x         ; MSB, which should always be zero
                sbc 4,x
                sta 3,x

                inx
                inx

z_number_sign_greater:
                rts


; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
; ## "#s"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Completely convert number for pictured numerical output. Based on
        ; https://github.com/philburk/pforth/blob/master/fth/system.fth
        ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
        ; """
.scope
xt_number_sign_s:
_loop:
                ; convert a single number ("#")
                jsr xt_number_sign

                ; stop when double-celled number in TOS is zero:
                lda 0,x
                ora 1,x
                ora 2,x
                ora 3,x
                bne _loop

z_number_sign_s:
                rts
.scend


; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
; ## "1"  src: Tali Forth  b: 8  c: TBA  status: coded
xt_one:         
                dex
                dex
                lda #1
                sta 0,x
                stz 1,x

z_one:          rts



; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
; ## "1-"  src: ANSI core  b: 8  c: TBA  status: coded
.scope
xt_one_minus:   
                lda 0,x
                bne +
                dec 1,x
*               dec 0,x

z_one_minus:    rts
.scend


; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
; ## "1+"  src: ANSI core  b: 6  c: 14-15  status: coded
.scope
xt_one_plus:    
                inc 0,x
                bne _done
                inc 1,x
_done:
z_one_plus:     rts
.scend


; ## OR ( m n -- n ) "Logically OR TOS and NOS"
; ## "or"  src: ANSI core  b: 14  c: TBA  status: coded
xt_or:          
                lda 0,x
                ora 2,x
                sta 2,x

                lda 1,x
                ora 3,x
                sta 3,x

                inx
                inx

z_or:           rts


; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
; ## "output"  src: Tali Forth  b: TBA  c: TBA  status: fragment
xt_output:      
        ; """Return the address where the jump target for EMIT is stored (but
        ; not the vector itself). By default, this will hold the value of 
        ; kernel_putc routine, but this can be changed by the user, hence this
        ; routine.
        ; """
                ; TODO
                ; push value of output to TOS
z_output:       rts


; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
; ## "over"  src: ANSI core  b: 10  c: TBA  status: coded
xt_over:        dex
                dex
                lda 4,x         ; LSB
                sta 0,x
                lda 5,x         ; MSB
                sta 1,x 

z_over:         rts


; ## PAD ( -- addr ) "Return address of user scratchpad"
; ## "pad"  src: ANSI core ext  b: TBA  c: TBA  status: coded
        ; """Return address to a temporary area in free memory for user. Must
        ; be at least 84 bytes in size (says ANSI). It is located relative to
        ; the compile area pointer (CP) and therefore varies in position.
        ; This area is reserved for the user and not used by the system
        ; """
xt_pad:         
                dex
                dex

                lda cp
                clc
                adc #padoffset  ; assumes padoffset one byte in size
                sta 0,x

                lda cp+1
                adc #0          ; only need carry
                sta 1,x

z_pad:          rts


; ## PAGE ( -- ) "Clear the screen"
; ## "page"  src: ANSI facility  b: TBA  c: TBA  status: coded
        ; """Clears a page if supported by ANSI terminal codes. This is 
        ; Clear Screen ("ESC[2J") plus moving the cursor to the top
        ; left of the screen
        ; """
xt_page:        
                lda #AscESC
                jsr emit_a
                lda #$5B        ; ASCII for "["
                jsr emit_a
                lda #'2
                jsr emit_a
                lda #'J
                jsr emit_a

                ; move cursor to top left of screen 
                jsr xt_zero 
                jsr xt_zero
                jsr xt_at_xy

z_page:         rts


; ## PAREN ( -- ) "<TBA>"
; ## "("  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_paren:       nop
z_paren:        rts
.scend

; ## PAREN_DO ( -- ) "<TBA>"
; ## "(do)"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_paren_do:    nop
z_paren_do:     rts
.scend

; ## PAREN_PLUS_LOOP ( -- ) "<TBA>"
; ## "(+loop)"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_paren_plus_loop:
                nop
z_paren_plus_loop:
                rts
.scend

; ## PAREN_Q_DO ( -- ) "<TBA>"
; ## "(?do)"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_paren_q_do:  nop
z_paren_q_do:   rts
.scend

; ## PARSE-NAME ( "name" -- addr u ) "Parse the input"
; ## "parse-name"  src: ANSI core ext  b: TBA  c: TBA  status: coded
.scope
xt_parse_name:
        ; """Find next word in input string, skipping leading spaces. This is 
        ; a special form of PARSE and drops through to that word. See PARSE 
        ; for more detail. We use this word internally for the interpreter
        ; because it is a lot easier to use. Reference implementations at
        ; http://forth-standard.org/standard/core/PARSE-NAME and
        ; http://www.forth200x.org/reference-implementations/parse-name.fs
        ; Roughly, the word is comparable to BL WORD COUNT
        ; """

                ; skip leading spaces. We only use the LSB of toin, so the
                ; maximal input size again is 256 chars
                ldy toin
        
_skip_loop:
                cpy ciblen              ; end of line?
                beq _empty_line
                lda (cib),y
                cmp #AscSP
                bne _found
                iny
                bra _skip_loop

_empty_line:
                ; Neither the ANSI Forth nor the Gforth documentation seem to
                ; say what to return as an address if a string with only 
                ; spaces is given. For speed reasons, we just return junk
                dex
                dex
                dex
                dex

                stz 0,x                 ; TOS is zero
                stz 1,x

                jmp z_parse_name        ; skip over PARSE

_found:
                ; save index of where words starts
                sty toin

                ; prepare Data Stack for PARSE by adding space
                ; as the delimiter
                dex
                dex
                lda #AscSP

                sta 0,x
                stz 1,x         ; paranoid

                ; fall through to PARSE
.scend


; ## PARSE ( c "name" -- addr u ) "Parse input with delimiter character"
; ## "parse"  src: ANSI core ext  b: TBA  c: TBA  status: coded
.scope
xt_parse:
        ; """Find word in input string delimited by character given. Do not skip 
        ; leading delimiters, this is the main difference to PARSE-NAME. PARSE
        ; and PARSE-NAME replace WORD in modern systems. See the ANSI
        ; documentation at
        ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE 
        ; PARSE-NAME drops through to here
        ;
        ;    cib   cib+toin    cib+ciblen
        ;     v       v             v
        ;     |#####################|
        ;                           
        ;     |------>|  toin (>IN)
        ;     |-------------------->|  ciblen
        ;
        ; The input string is stored starting at the address in the Current
        ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
        ; for the delimiter, TOIN (>IN) points to the where we currently are.
        ; Since PARSE does not skip leading delimiters, we assume we are on a
        ; useful string.
        ; """

                lda 0,x         ; save delimiter
                sta tmp1

                lda toin        ; save original >IN for length calculation
                sta tmp2        

                ; save beginning of word (cib+toin) to NOS as the return value
                dex
                dex

                clc
                adc cib
                sta 2,x
                lda cib+1
                adc #0          ; we only need the carry
                sta 3,x

                stz tmp3        ; offset for EOL/char found adjustment of >IN

                ldy toin

_parse_loop:
                cpy ciblen
                beq _eol

                lda (cib),y
                cmp tmp1        ; found delimiter?
                beq _found_delimiter
                iny
                bra _parse_loop
                
_found_delimiter:
                ; If we haven't reached the end of the line, but found
                ; a delimiter, we want >IN to point to the next character after
                ; the delimiter, not the delimiter itself. This is what the
                ; offset is for
                inc tmp3

_eol:
                ; calculate length of string found
                tya
                sec
                sbc tmp2        ; original value for >IN, index of first char

                sta 0,x         ; length goes TOS
                stz 1,x

                ; calculate new >IN
                tya
                clc
                adc tmp3        ; offset for EOL vs delimiter found
                sta toin
                stz toin+1      ; paranoid

z_parse_name:
z_parse:        rts
.scend


; ## PICK ( -- ) "<TBA>"
; ## "pick"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_pick:        nop
z_pick:         rts
.scend


; ## PLUS ( b a -- a+b ) "Add TOS and NOS"
; ## "+"  src: ANSI core  b: 15  c: TBA  status: tested
xt_plus:        
                clc
                lda 0,x         ; LSB
                adc 2,x
                sta 2,x

                lda 1,x         ; MSB. No CLC, conserve carry bit
                adc 3,x
                sta 3,x

                inx
                inx

z_plus:         rts


; ## PLUS_LOOP ( -- ) "<TBA>"
; ## "+loop"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_plus_loop:   nop
z_plus_loop:    rts
.scend

; ## PLUS_STORE ( -- ) "<TBA>"
; ## "+!"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_plus_store:  nop
z_plus_store:   rts
.scend

; ## POSTPONE ( -- ) "<TBA>"
; ## "postpone"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_postpone:    nop
z_postpone:     rts
.scend


; ## QUESTION ( addr -- ) "Print content of a variable"
; ## "?"  src: ANSI tools  b: 6  c: TBA  status: coded
        ; """Only used interactively. Since humans are so slow, we
        ; save size and just go for the subroutine jumps
        ; """
xt_question:    
                jsr xt_fetch
                jsr xt_dot

z_question:     rts


; ## QUESTION_DO ( -- ) "<TBA>"
; ## "?do"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_question_do: nop
z_question_do:  rts
.scend

; ## QUESTION_DUP ( -- ) "<TBA>"
; ## "?dup"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_question_dup:
                nop
z_question_dup: rts
.scend


; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
; ## "r@"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """We follow Gforth in that this word is not compiled only, because
        ; it can be interesting to know what the top of R is in an interactive
        ; setting. However, this causes all kinds of problems if we try
        ; to natively compile the word, so it is flagged NN even though it is
        ; actually short enough to make that reasonable.
        ; """
        ; TODO consider special case in COMPILE,
xt_r_fetch:     
                dex
                dex

                ; get the return address
                ply             ; LSB
                sty tmp1
                ply             ; MSB

                ; get the actual top of Return Stack
                pla             ; LSB
                sta 0,x
                pla             ; MSB
                sta 1,x

                ; restore return value
                phy             ; MSB
                ldy tmp1
                phy             ; LSB

z_r_fetch:      rts


; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
; ## "r>"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Move Top of Return Stack to Top of Data Stack. We have to move
        ; the RTS address out of the way first. This word is handled
        ; differently for native and and subroutine compilation, see COMPILE,
        ; This is a compile-only word
        ; """

xt_r_from:
                dex
                dex

                ; Rescue the address of the return jump that is currently
                ; on top of the Return Stack. If this word is natively 
                ; compiled, this is a total waste of time
                pla             ; LSB
                sta tmptos
                ply             ; MSB

                ; --- cut for native coding ---

                ; now we can access the actual data
                pla             ; LSB
                sta 0,x
                pla             ; MSB
                sta 1,x

                ; --- cut for native coding ---
                
                ; restore the return address
                phy             ; MSB
                lda tmptos
                pha             ; LSB

z_r_from:       rts



; ## RECURSE ( -- ) "<TBA>"
; ## "recurse"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_recurse:     nop
z_recurse:      rts
.scend


; ## REFILL ( -- f ) "Refill the input buffer"
; ## "refill"  src: ANSI core ext  b: TBA  c: TBA  status: coded
.scope
xt_refill:      
        ; """Attempt to fill the input buffer from the input source, returning
        ; a true flag if successful. When the input source is the user input
        ; device, attempt to receive input into the terminal input buffer. If
        ; successful, make the result the input buffer, set >IN to zero, and
        ; return true. Receipt of a line containing no characters is considered
        ; successful. If there is no input available from the current input
        ; source, return false. When the input source is a string from EVALUATE,
        ; return false and perform no other action." See
        ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
        ; and Conklin & Rather p. 156
        ; """"
                ; Get input source from SOURCE-ID. We don't have blocks in this
                ; version, or else we would have to check BLK first. This is an
                ; optimized version of a subroutine jump to SOURCE-ID
                lda insrc               ; cheat: We only check LSB
                bne _src_not_kbd

                ; SOURCE-ID of zero means we're getting stuff from the keyboard
                ; with ACCEPT, which wants the address of the current input
                ; buffer NOS and the max number of characters to accept TOS
                dex
                dex
                dex
                dex

                lda cib                 ; address of CIB is NOS
                sta 2,x
                lda cib+1
                sta 3,x
                
                lda #bsize              ; max number of chars is TOS
                sta 0,x
                stz 1,x                 ; cheat: We only accept max 256

                jsr xt_accept           ; ( addr n1 -- n2)

                ; ACCEPT returns the number of characters accepted, which
                ; belong in CIBLEN
                lda 0,x
                sta ciblen
                stz ciblen+1            ; we only accept 256 chars
                
                lda #$ff                ; overwrite with TRUE flag
                sta 0,x
                sta 1,x

                bra z_refill

_src_not_kbd:
                ; If SOURCE-ID doesn't return a zero, it must be a string in
                ; memory or a file (remember, no blocks in this version).
                ; If source is a string, we were given the flag -1 ($ffff)
                inc
                bne _source_is_not_string

                ; Simply return FALSE flag as per specification
                dex
                dex
                stz 0,x
                stz 1,x

                bra z_refill

_source_is_not_string:
                ; Since we don't have blocks, this must mean that we are trying
                ; to read from a file. However, we don't have files yet, so we 
                ; report an error and jump to ABORT.
                lda #9                  ; error code for illegal source id
                jmp error

z_refill:       rts
.scend


; ## REPEAT ( -- ) "<TBA>"
; ## "repeat"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_repeat:      nop
z_repeat:       rts
.scend

; ## RIGHT_BRACKET ( -- ) "<TBA>"
; ## "]"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_right_bracket:
                nop
z_right_bracket:
                rts
.scend

; ## RIGHT_PAREN ( -- ) "<TBA>"
; ## ")"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_right_paren: nop
z_right_paren:  rts
.scend


; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
; ## "rot"  src: ANSI core  b: 28  c: TBA  status: coded
        ; """Remember "R for 'Revolution' - the bottom entry comes out
        ; on top!
        ; """
xt_rot:         
                lda 5,x         ; MSB first
                tay
                lda 3,x
                sta 5,x
                lda 1,x
                sta 3,x
                tya
                sta 1,x

                lda 4,x         ; LSB next 
                tay
                lda 2,x
                sta 4,x
                lda 0,x
                sta 2,x
                tya
                sta 0,x

z_rot:          rts


; ## RSHIFT ( -- ) "<TBA>"
; ## "rshift"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_rshift:      nop
z_rshift:       rts
.scend

; ## S_QUOTE ( -- ) "<TBA>"
; ## "s""  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_s_quote:     nop
z_s_quote:      rts
.scend

; ## S_TO_D ( -- ) "<TBA>"
; ## "s>d"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_s_to_d:      nop
z_s_to_d:       rts
.scend

; ## SEMICOLON ( -- ) "<TBA>"
; ## ";"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_semicolon:   nop
z_semicolon:    rts
.scend


; ## SIGN ( n -- ) "Add minus to pictured output"
; ## "sign"  src: ANSI core  b: TBA  c: TBA  status: coded
.scope
xt_sign:        
                lda 1,x         ; check MSB of TOS
                bmi _minus

                inx
                inx
                bra _done
_minus:
                lda #$2d        ; ASCII for "-"
                sta 0,x         ; overwrite TOS
                stz 1,x         ; paranoid

                jsr xt_hold
_done:
z_sign:         rts
.scend


; ## SLASH ( -- ) "<TBA>"
; ## "/"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_slash:       nop
z_slash:        rts
.scend

; ## SLASH_MOD ( -- ) "<TBA>"
; ## "/mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_slash_mod:   nop
z_slash_mod:    rts
.scend

; ## SLASH_STRING ( -- ) "<TBA>"
; ## "/string"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_slash_string:
                nop
z_slash_string: rts
.scend

; ## SLITERAL ( -- ) "<TBA>"
; ## "sliteral"  src: ANSI string  b: TBA  c: TBA  status: TBA
.scope
xt_sliteral:    nop
z_sliteral:     rts
.scend

; ## SM_SLASH_REM ( -- ) "<TBA>"
; ## "sm/rem"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_sm_slash_rem:
                nop
z_sm_slash_rem: rts
.scend


; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
; ## "source"  src: ANSI core  b: 20  c: TBA  status: coded
xt_source:      
                ; add address
                dex
                dex
                lda cib
                sta 0,x
                lda cib+1
                sta 1,x

                ; add size
                dex
                dex
                lda ciblen
                sta 0,x
                lda ciblen+1    ; paranoid, should be zero
                sta 1,x

z_source:       rts


; ## SOURCE_ID ( -- n ) "Return source identifier"
; ## "source-id"  src: ANSI core ext  b: 10  c: TBA  status: coded
        ; """Identify the input source unless it is a block (s. Conklin &
        ; Rather p. 156). Since we don't have blocks (yet), this will give
        ; the input source: 0 is keyboard, -1 (0ffff) is character string,
        ; and a text file gives the fileid.
        ; """
xt_source_id:   
                dex
                dex
                lda insrc
                sta 0,x
                lda insrc+1
                sta 1,x

z_source_id:    rts


; ## SPACE ( -- ) "Print a single space"
; ## "space"  src: ANSI core  b: 5  c: TBA  status: coded
xt_space:      
                lda #AscSP
                jsr emit_a

z_space:        rts


; ## SPACES ( u -- ) "Print a number of spaces"
; ## "spaces"  src: ANSI core  b: TBA  c: TBA  status: coded
; TODO test with TOS > 256
.scope
xt_spaces:      
                ; catch any zero in TOS fast
                lda 0,x
                ora 1,x
                beq _done

                ; usually we're only going to print far less than 256 spaces,
                ; so we create a quick loop for that. Short loop could be realized
                ; as a separate subroutine, but unless we're really pressed for
                ; memory at some point, this is faster
                lda #AscSP
                ldy 1,x
                bne _lots_of_spaces

                ldy 0,x
_quick_loop:
                ; we reach here knowing that there must be a number that is not
                ; zero in the TOS
                jsr emit_a
                dey
                beq _done
                bra _quick_loop

_lots_of_spaces:
                ; we go through the first loop once to get rid of the lower
                ; counter byte. This could be zero
                ldy 0,x

_first_slow_loop:
                beq _slow_outer_loop
                jsr emit_a
                dey
                bra _first_slow_loop
                
_slow_outer_loop:
                ; we arrive here knowing that the MSB of TOS cannot be a zero
                ldy #00                

_slow_inner_loop:
                jsr emit_a 
                dey
                bne _slow_inner_loop

                dec 1,x
                bne _slow_outer_loop

_done:
                inx             ; drop
                inx

z_spaces:       rts 
.scend

; ## STAR ( -- ) "<TBA>"
; ## "*"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_star:        nop
z_star:         rts
.scend

; ## STAR_SLASH ( -- ) "<TBA>"
; ## "*/"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_star_slash:  nop
z_star_slash:   rts
.scend

; ## STAR_SLASH_MOD ( -- ) "<TBA>"
; ## "*/mod"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_star_slash_mod:
                nop
z_star_slash_mod:
                rts
.scend


; ## STATE ( -- addr ) "Return the address of compilation state flag"
; ## "state"  src: ANSI core  b: 10  c: TBA  status: coded
        ; """STATE is true when in compilation state, false otherwise. Note
        ; we do not return the state itself, but only the address where
        ; it lives. The state should not be changed directly by the user; see
        ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
        ; """
xt_state:       dex
                dex
                lda #<state
                sta 0,x
                lda #>state     ; paranoid, should always be zero
                sta 1,x

z_state:        rts


; ## STORE ( n addr -- ) "Store TOS in memory"
; ## "!"  src: ANSI core  b: 18  c: TBA  status: tested
.scope
xt_store:
                lda 2,x         ; LSB
                sta (0,x)

                inc 0,x
                bne +
                inc 1,x
*
                lda 3,x         ; MSB
                sta (0,x)

                inx             ; 2DROP
                inx
                inx
                inx

z_store:        rts
.scend


; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
; ## "swap"  src: ANSI core  b: 16  c: TBA  status: coded
xt_swap:        lda 0,x         ; LSB
                ldy 2,x
                sta 2,x
                sty 0,x

                lda 1,x         ; MSB
                ldy 3,x
                sta 3,x
                sty 1,x

z_swap:         rts


; ## THEN ( -- ) "<TBA>"
; ## "then"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_then:        nop
z_then:         rts
.scend

; ## TICK ( -- ) "<TBA>"
; ## "'"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_tick:        nop
z_tick:         rts
.scend

; ## TO ( -- ) "<TBA>"
; ## "to"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_to:          nop
z_to:           rts
.scend

; ## TO_BODY ( -- ) "<TBA>"
; ## ">body"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_to_body:     nop
z_to_body:      rts
.scend


; ## TO_IN ( -- addr ) "Return address of the input pointer"
; ## ">in"  src: ANSI core  b: 10  c: TBA  status: coded
xt_to_in:       
                dex
                dex

                lda #<toin
                sta 0,x
                lda #>toin      ; paranoid, should be zero
                sta 1,x

z_to_in:        rts


; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
; ## ">number"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Convert a string to a double number. Logic here is based on the
        ; routine by Phil Burk of the same name in pForth, see
        ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
        ; for the original Forth code. We arrive here from NUMBER which has
        ; made sure that we don't have to deal with a sign and we don't have
        ; to deal with a dot as a last character that signalizes double -
        ; this should be a pure number string. This routine calles UM*, which
        ; uses tmp1, tmp2 and tmp3, so we cannot access any of those.
        
        ; For the math routine, we move the inputs to the scratchpad to
        ; avoid having to fool around with the Data Stack. 
        ;
        ;     +-----+-----+-----+-----+-----+-----+-----+-----+
        ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
        ;     |           |           |           |           |
        ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
        ;     +-----+-----+-----+-----+-----+-----+-----+-----+

        ; The math routine works by converting one character to its
        ; numerical value (N) via DIGIT? and storing it in S+4 for
        ; the moment. We then multiply the UD-HI value with the radix
        ; (from BASE) using UM*, which returns a double-cell result. We
        ; discard the high cell of that result (UD-HI-HI) and store the
        ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
        ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
        ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
        ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
        ; storing the result back in S and S+2, before we start another
        ; round with it as the new UD-LO and UD-HI.
        ; """

.scope
xt_to_number:
                ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
                ; After this step, the original ud-lo and ud-hi will still be on
                ; the Data Stack, but will be ignored and later overwritten
                lda 6,x         ; ud-lo LSB
                sta scratch
                lda 7,x         ; ud-lo MSB
                sta scratch+1

                lda 4,x         ; ud-hi LSB
                sta scratch+2
                lda 5,x         ; ud-hi MSB
                sta scratch+3

                ; Push down one on the Data Stack to use TOS for character
                ; conversion ( ud-lo ud-hi addr u u )
                dex
                dex

_loop:
                ; Get one character based on address
                lda (4,x)
                sta 0,x         ; ( ud-lo ud-hi addr u char )

                jsr xt_digit_question   ; ( char -- n -1 | char 0 )

                ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
                ; check the flag. If it is zero, we return what we have and
                ; let the caller (usually NUMBER) complain
                lda 0,x
                bne _digit_ok

                inx
                inx
                bra _done       ; ( ud-lo ud-hi addr u char ) 

_digit_ok:
                ; Conversion was successful. We arrive here with
                ; ( ud-lo ud-hi addr u n -1 ) and can start the
                ; math routine

                ; Save n so we don't have to fool around with the
                ; Data Stack
                lda 2,x
                sta scratch+4
                stz scratch+5   ; paranoid

                ; Now multiply ud-hi (the one in the scratchpad, not the
                ; original one on the Data Stack) with the radix from BASE.
                ; We can clobber TOS and NOS
                lda scratch+2
                sta 2,x         ; NOS
                lda scratch+3
                sta 3,x

                lda base
                sta 0,x
                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)

                ; UM* returns a double-celled number
                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )

                ; Move ud-hi-lo to safety
                lda 2,x         ; ud-hi-lo
                sta scratch+6
                lda 3,x
                sta scratch+7

                ; Now we multiply ud-lo, overwriting the stack entries
                lda scratch
                sta 2,x
                lda scratch+1
                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
                lda base
                sta 0,x         
                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )

                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
                lda 0,x
                sta scratch+2
                lda 1,x
                sta scratch+3

                lda 2,x
                sta scratch
                lda 3,x
                sta scratch+1

                ; We now do D+, but in the scratch pad
                lda scratch
                clc
                adc scratch+4
                sta scratch     ; this is the new ud-lo
                lda scratch+1
                adc scratch+5
                sta scratch+1

                lda scratch+2
                adc scratch+6
                sta scratch+2   ; this is the new ud-hi
                lda scratch+3
                adc scratch+7
                sta scratch+3

                ; Clean up: Get rid of one of the two top elements on 
                ; the Data Stack. We don't really care which one
                inx
                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )

                ; One character down. Move address up
                inc 4,x
                bne +
                inc 5,x
*
                ; Decrease counter
                dec 2,x
                bne _loop

_done:               
                ; Counter has reached zero or we have an error. In both
                ; cases, we clean up the Data Stack and return. Error gives
                ; us ( ud-lo ud-hi addr u char ), regular end is
                ; ( ud-lo ud-hi addr u ud-lo )
                inx
                inx             ; ( ud-lo ud-hi addr u )

                ; The new ud-lo and ud-hi are still on the scratch pad
                lda scratch     ; new ud-lo
                sta 6,x
                lda scratch+1
                sta 7,x

                lda scratch+2
                sta 4,x
                lda scratch+3
                sta 5,x

z_to_number:    rts
.scend


; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
; ## ">r"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """This word is handled differently for native and for 
        ; subroutine coding, see COMPILE, . This is a complile-only
        ; word
        ; """
xt_to_r:
                ; Save the return address. If this word is natively
                ; coded, this is a complete waste of cycles, but
                ; required for subroutine coding
                pla             ; LSB
                sta tmptos
                ply             ; MSB

                ; --- cut line for native coding ---
 
                ; now we can do the actual work
                lda 1,x         ; MSB
                pha
                lda 0,x         ; LSB
                pha

                ; --- cut line for native coding ---

                ; restore return address
                phy             ; MSB
                lda tmptos
                pha             ; LSB

                inx
                inx

z_to_r:         rts


; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
; ## "true"  src: ANSI core ext  b: 8  c: TBA  status: coded
xt_true:        dex
                dex
                lda #$ff
                sta 0,x
                sta 1,x

z_true:         rts


; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
; ## "tuck"  src: ANSI core ext  b: 24  c: TBA  status: coded
xt_tuck:        dex
                dex             ; ba- 

                lda 2,x
                sta 0,x         
                lda 3,x
                sta 1,x         ; baa

                ldy 4,x         ; using Y saves one instruction
                sty 2,x         ; because TOS MSB stays in A
                ldy 5,x
                sty 3,x         ; bba

                sta 5,x         
                lda 0,x
                sta 4,x         ; aba

z_tuck:         rts


; ## TWO ( -- u ) "Push the number 2 to stack"
; ## "2"  src: Tali Forth  b: TBA  c: TBA  status: coded
xt_two:
                dex
                dex
                lda #2
                sta 0,x
                stz 1,x

z_two:          rts


; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
; ## "2drop"  src: ANSI core  b: 4  c: TBA  status: coded
.scope
xt_two_drop:    
                inx
                inx
                inx
                inx

z_two_drop:     rts
.scend


; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
; ## "2dup"  src: ANSI core  b: 20  c: TBA  status: coded
xt_two_dup:
                dex
                dex
                dex
                dex

                lda 4,x         ; TOS
                sta 0,x
                lda 5,x
                sta 1,x

                lda 6,x         ; NOS
                sta 2,x
                lda 7,x
                sta 3,x

z_two_dup:      rts


; ## TWO_OVER ( -- ) "<TBA>"
; ## "2over"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_two_over:    nop
z_two_over:     rts
.scend

; ## TWO_R_FETCH ( -- ) "<TBA>"
; ## "2r@"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_two_r_fetch: nop
z_two_r_fetch:  rts
.scend

; ## TWO_R_FROM ( -- ) "<TBA>"
; ## "2r>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_two_r_from:  nop
z_two_r_from:   rts
.scend


; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
; ## "2*"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Also used for CELLS
        ; """
xt_two_star:
                asl 0,x
                rol 1,x
z_two_star:     rts


; ## TWO_SWAP ( -- ) "<TBA>"
; ## "2swap"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_two_swap:    nop
z_two_swap:     rts
.scend

; ## TWO_TO_R ( -- ) "<TBA>"
; ## "2>r"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_two_to_r:    nop
z_two_to_r:     rts
.scend

; ## TWO_VARIABLE ( -- ) "<TBA>"
; ## "2variable"  src: ANSI double  b: TBA  c: TBA  status: TBA
.scope
xt_two_variable:
                nop
z_two_variable: rts
.scend


; ## TYPE ( addr u -- ) "Print string"
; ## "type"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Works through EMIT to allow OUTPUT revectoring. Currently, only
        ; strings of up to 255 characters are printed
        ; """
.scope
xt_type:        
                ; skip if length is zero
                lda 0,x
                ora 1,x
                beq _done

                lda 2,x
                sta tmp1
                lda 3,x
                sta tmp1+1
                
                ; CPY doesn't have a mode to compare with 0,x so we have to do the
                ; loop the hard way
                ldy #0
                lda 0,x
                sta tmp2

_loop:
                lda (tmp1),y
                jsr emit_a              ; avoids stack foolery
                iny
                cpy tmp2
                bne _loop               ; fall through to _done

_done:
                inx
                inx
                inx
                inx

z_type:         rts
.scend


; ## U_DOT ( -- ) "<TBA>"
; ## "u."  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_u_dot:       nop
z_u_dot:        rts
.scend

; ## U_DOT_R ( -- ) "<TBA>"
; ## "u.r"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_u_dot_r:     nop
z_u_dot_r:      rts
.scend

; ## UD_DOT ( -- ) "<TBA>"
; ## "ud."  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_ud_dot:      nop
z_ud_dot:       rts
.scend

; ## UD_DOT_R ( -- ) "<TBA>"
; ## "ud.r"  src: Gforth  b: TBA  c: TBA  status: TBA
.scope
xt_ud_dot_r:    nop
z_ud_dot_r:     rts
.scend


; ## UD_SLASH_MOD ( ud u1 -- u2 ud2 ) "32/16 --> 32 Division"
; ## "ud/mod"  src: Gforth  b: TBA  c: TBA  status: coded
        ; """Divide double cell number by a single-cell number and return
        ; the quotient ud2 as TOS in double-cell form and remainder u2
        ; Based on code from pForth, which is in the public domain. Original
        ; Forth is  >R 0 R@ UM/MOD  ROT ROT R> UM/MOD ROT
        ; """
        ; TODO analyze and convert parts to assembler 
        ; TODO test this, some results seem fishy
xt_ud_slash_mod:
                
                jsr xt_to_r
                jsr xt_zero
                jsr xt_r_fetch
                jsr xt_um_slash_mod
                jsr xt_rot
                jsr xt_rot
                jsr xt_r_from
                jsr xt_um_slash_mod
                jsr xt_rot

z_ud_slash_mod: rts


; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
; ## "um/mod"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Divide double cell number by single cell number, returning the
        ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
        ; This is the basic division operation all others use. Based on FIG
        ; Forth code, modified by Garth Wilson, see
        ; http://6502.org/source/integers/ummodfix/ummodfix.htm 
        ; """
.scope
xt_um_slash_mod:
                ; TODO make sure we have enough stuff on the stack
                
                ; prevent division by zero
                lda 0,x
                ora 1,x
                bne _not_zero

                lda #3          ; "Division by zero" error string
                jmp error

_not_zero: 
                ; We loop 17 times
                lda #17
                sta tmptos

_loop:
                ; rotate low cell of dividend one bit left (LSB)
                rol 4,x
                rol 5,x

                ; loop control
                dec tmptos
                beq _done

                ; rotate high cell of dividend one bit left (MSB)
                rol 2,x
                rol 3,x

                stz tmp1        ; store the bit we got from hi cell (MSB)
                rol tmp1

                ; subtract dividend hi cell minus divisor
                sec
                lda 2,x
                sbc 0,x
                sta tmp1+1
                lda 3,x
                sbc 1,x

                tay
                lda tmp1
                sbc #0
                bcc _loop

                ; make result new dividend high cell
                lda tmp1+1
                sta 2,x
                sty 3,x         ; used as temp storage

                bra _loop
_done:
                inx
                inx

                jsr xt_swap

z_um_slash_mod: rts
.scend


; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
; ## "um*"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """Multiply two unsigned 16 bit numbers, producing a 32 bit result.
        ; This is based on modified FIG Forth code by Dr. Jefyll, see
        ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
        ; discussion. We use the system scratch pad (SYSPAD) for temp storage
        ; (N in the original code). FIG Forth is in the public domain. We use
        ; tmp1, tmp2, tmp3 for this, with the assumption that tmp3 immediately
        ; follows tmp2. Old Forth versions such as FIG Forth call this U* 
        ;
        ; This is currently a brute-force loop based on the 8-bit variant
        ; in "6502 Assembly Language Programming" by Leventhal. Once everything
        ; is working, consider switching to a table-supported version based on
        ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
        ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
        ; http://forum.6502.org/viewtopic.php?p=205#p205
        ; http://forum.6502.org/viewtopic.php?f=9&t=689
        ; """
.scope
xt_um_star:     
                ; SPECIAL CASE 1: Multiplication by zero
                lda 0,x         ; TOS
                ora 1,x
                beq _zero

                lda 2,x         ; NOS
                ora 3,x
                beq _zero

                ; SPECIAL CASE 2: Multiplication by one
                lda 0,x         ; TOS is one
                cmp #1
                bne _test_nos
                lda 1,x
                beq _one_tos

_test_nos:
                lda 2,x         ; NOS is one
                cmp #1
                bne _not_one
                lda 3,x
                beq _one_nos

_not_one:       ; NO SPECIAL CASE ("THE HARD WAY")
                ; Copy TOS to scratch+2, scratch+3. To eliminate CLC inside
                ; the loop, this value is reduced by one in advance
                lda 0,x         ; LSB
                clc             ; not sec!
                sbc #0
                sta scratch+2
                lda 1,x         ; MSB
                sbc #0
                sta scratch+3

                ; put 0 in both A and scratch
                ; First eight shifts are A --> SCRATCH --> 2,x
                ; Final eight shifts are A --> SCRATCH --> 3,x
                lda #0
                sta scratch
                
                stx scratch+4    ; tested later for exit from outer loop
                dex
                dex

_outer_loop:    ldy #8
                lsr 4,x          ; think "2,x" and later "3,x"

_inner_loop:    bcc _noadd
                sta scratch+1    ; save time by not clc
                lda scratch
                adc scratch+2
                sta scratch
                lda scratch+1
                adc scratch+3

_noadd:         ror
                ror scratch
                ror 4,x         ; think "2,x" and later "3,x"
                dey
                bne _inner_loop         ; go back for one more shift?

                inx
                cpx scratch+4
                bne _outer_loop         ; go back for eight more shifts?

                ; all done
                sta 1,x         ; MSB of high word of result
                lda scratch
                sta 0,x         ; LSB of high word of result
                bra _done

_zero:          ; one or both number are zero, so we got off light
                stz 0,x
                stz 1,x
                stz 2,x
                stz 3,x
                bra _done

_one_tos:       ; TOS is one. NOS is the LSW, TOS becomes zero
                dec 0,x
                bra _done

_one_nos:       ; NOS is one: Move TOS to LSW, TOS becomes zero
                lda 0,x
                sta 2,x
                lda 1,x
                sta 3,x
                stz 0,x
                stz 1,x         ; fall through to _done

_done:
z_um_star:      rts
.scend


; ## UNLOOP ( -- ) "<TBA>"
; ## "unloop"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_unloop:      nop
z_unloop:       rts
.scend

; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
; ## "unused"  src: ANSI core ext  b: 15  c: TBA  status: TBA
xt_unused:      
                dex
                dex

                lda #<cp_end
                sec
                sbc cp
                sta 0,x

                lda #>cp_end
                sbc cp+1
                sta 1,x
                
z_unused:       rts

; ## VALUE ( -- ) "<TBA>"
; ## "value"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_value:       nop
z_value:        rts
.scend


; ## VARIABLE ( "name" -- ) "Define a variable"
; ## "variable"  src: ANSI core  b: TBA  c: TBA  status: coded
        ; """There are various Forth definitions for this word, such as
        ; CREATE 1 CELLS ALLOT  or CREATE 0 ,  We use a variant of the
        ; second one so the variable is initialized to zero
        ; """
xt_variable:    
                ; we let CREATE do the heavy lifting
                jsr xt_create

                ; there is no "STZ (CP)" so we have to do this the hard
                ; way
                lda #0
                sta (cp)
                inc cp
                bne +
                inc cp+1
*
                sta (cp)
                inc cp
                bne +
*
                inc cp+1

                ; Now we need to adjust the length of the complete word by two
                jsr adjust_z
                
z_variable:     rts


; ## WITHIN ( -- ) "<TBA>"
; ## "within"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_within:      nop
z_within:       rts
.scend

; ## WORD ( -- ) "<TBA>"
; ## "word"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_word:        nop
z_word:         rts
.scend


; ## WORDS ( -- ) "Print known words from Dictionary"
; ## "words"  src: ANSI tools  b: TBA  c: TBA  status: tested
        ; """This is pretty much only used at the command line so we can
        ; be slow and try to save space. DROP must always be the first word in a
        ; clean system (without Forth words), BYE the last. There is no reason
        ; why we couldn't define this as a high level word except that it is
        ; really useful for testing
        ; """
        ; TODO make output respect line length on screen
.scope
xt_words:       
                ; we follow Gforth by starting on the next
                ; line
                jsr xt_cr

                ; start with last word in Dictionary
                jsr xt_latestnt         ; ( nt ) 
_loop:
                jsr xt_dup              ; ( nt nt ) 
                jsr xt_name_to_string   ; ( nt addr u )
                jsr xt_type             ; ( nt )

                lda #AscSP
                jsr emit_a

                ; get next word, which begins two down
                jsr xt_one_plus         ; 1+
                jsr xt_one_plus         ; 1+
                jsr xt_fetch            ; @ ( nt+1 )

                ; if next address is zero, we're done
                lda 0,x
                ora 1,x
                bne _loop

                inx
                inx
                
z_words:        rts
.scend


; ## WORDS_AND_SIZES ( -- ) "<TBA>"
; ## "words&sizes"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_words_and_sizes:
                nop
z_words_and_sizes:
                rts
.scend

; ## WORDSIZE ( -- ) "<TBA>"
; ## "wordsize"  src: ANSI search  b: TBA  c: TBA  status: TBA
.scope
xt_wordsize:    nop
z_wordsize:     rts
.scend


; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
; ## "xor"  src: ANSI core  b: 14  c: TBA  status: coded
.scope
xt_xor:         
                lda 0,x
                eor 2,x
                sta 2,x

                lda 1,x
                eor 3,x
                sta 3,x

                inx
                inx

z_xor:          rts
.scend


; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
; ## "0"  src: Tali Forth  b: 6  c: TBA  status: coded
xt_zero:        
                dex             ; push
                dex
                stz 0,x
                stz 1,x

z_zero:         rts


; ## ZERO_BRANCH ( -- ) "<TBA>"
; ## "0branch"  src: Tali Forth  b: TBA  c: TBA  status: TBA
.scope
xt_zero_branch: nop
z_zero_branch:  rts
.scend


; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
; ## "0="  src: ANSI core  b: 16  c: TBA  status: coded
.scope
xt_zero_equal:  
                lda 0,x
                ora 1,x
                beq _zero

                ; not a zero, so we need a FALSE flag (0)
                lda #0
                bra _store
_zero:
                ; We have a zero, so we need a TRUE flag (-1)
                lda #$ff
_store:
                sta 0,x
                sta 1,x

z_zero_equal:   rts
.scend


; ## ZERO_GREATER ( -- ) "<TBA>"
; ## "0>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_zero_greater:
                nop
z_zero_greater: rts
.scend

; ## ZERO_LESS ( -- ) "<TBA>"
; ## "0<"  src: ANSI core  b: TBA  c: TBA  status: TBA
.scope
xt_zero_less:   nop
z_zero_less:    rts
.scend

; ## ZERO_UNEQUAL ( -- ) "<TBA>"
; ## "0<>"  src: ANSI core ext  b: TBA  c: TBA  status: TBA
.scope
xt_zero_unequal:
                nop
z_zero_unequal: rts
.scend

