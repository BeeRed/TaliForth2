\ From: John Hayes S1I  ok
\ Subject: tester.fr  ok
\ Date: Mon, 27 Nov 95 13:10:09 PST    ok
  ok
\ Modified by SamCo 2018-05 for testing Tali Forth 2.  ok
\ The main change is lowercasing all of the words as Tali  ok
\ is case sensitive, as well as replacing tabs with spaces.  ok
\ A word to display the actual (erroneous) results was also added.  ok
  ok
\ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS LABORATORY  ok
\ MAY BE DISTRIBUTED FREELY AS LONG AS THIS COPYRIGHT NOTICE REMAINS.  ok
hex  ok
  ok
\ Set the following flag to true for more verbose output; this may allow you to  ok
\ tell which test caused your system to hang. With Tali Forth, this is useless  ok
\ because the Python script echoes all the output anyway.  ok
variable verbose  false verbose !  ok
  ok
variable actual-depth   \ stack record  ok
create actual-results  20 cells allot  ok
  ok
\ Empty stack: handles underflowed stack too  ok
: empty-stack ( ... -- )   compiled
   depth ?dup if   compiled
      dup 0< if   compiled
         negate 0 do 0 loop   compiled
      else   compiled
         0 do drop loop   compiled
      then   compiled
   then ;  ok
  ok
\ Print the previous test's actual results. Added by SamCo 2018-05   ok
: show-results ( -- )   compiled
   s"  ACTUAL RESULT: { " type  compiled
   actual-depth @ 0 ?do  compiled
      actual-results   compiled
      actual-depth @ i - 1- \ Print them in reverse order to match test.  compiled
      cells + @ .  compiled
   loop  compiled
   s" }" type ;  ok
  ok
\ Display an error message followed by the line that had the error  ok
: error  \ ( C-ADDR U -- )   compiled
   type source type \ display line corresponding to error  compiled
   empty-stack      \ throw away every thing else  compiled
   show-results ;   \ added by SamCo to show what actually happened  ok
  ok
\ Syntactic sugar  ok
: {  ( -- ) ;  ok
  ok
\ Record depth and content of stack  ok
: ->  ( ... -- )   compiled
   depth dup actual-depth !  \ record depth  compiled
   ?dup if                   \ if there is something on stack ...  compiled
      0 do   compiled
         actual-results i cells + !   compiled
      loop                   \ ... save it  compiled
   then ;  ok
  ok
\ Compare stack (expected) contents with saved (actual) contents  ok
: }  ( ... -- )   compiled
   depth actual-depth @ = if     \ if depths match  compiled
      depth ?dup if              \ if there is something on the stack  compiled
         0 do                    \ for each stack item  compiled
            actual-results i cells + @  \ compare actual with expected  compiled
            <> if   compiled
               s" INCORRECT RESULT: " error leave   compiled
            then  compiled
         loop  compiled
      then  compiled
   else                          \ depth mismatch  compiled
      s" WRONG NUMBER OF RESULTS: " error  compiled
   then ;  ok
  ok
\ Talking comment  ok
: testing ( -- )   compiled
   source verbose @ if   compiled
      dup >r type cr r> >in !  compiled
   else >in ! drop  compiled
   then ;  ok
\ From: John Hayes S1I  ok
\ Subject: core.fr  ok
\ Date: Mon, 27 Nov 95 13:10  ok
  ok
\ Modified by SamCo 2018-05 for testing Tali Forth 2.  ok
\ The main change is lowercasing all of the words as Tali  ok
\ is case sensitive.  ok
  ok
\ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS LABORATORY  ok
\ MAY BE DISTRIBUTED FREELY AS LONG AS THIS COPYRIGHT NOTICE REMAINS.  ok
\ VERSION 1.2  ok
\ THIS PROGRAM TESTS THE CORE WORDS OF AN ANS FORTH SYSTEM.  ok
\ THE PROGRAM ASSUMES A TWO'S COMPLEMENT IMPLEMENTATION WHERE  ok
\ THE RANGE OF SIGNED NUMBERS IS -2^(N-1) ... 2^(N-1)-1 AND  ok
\ THE RANGE OF UNSIGNED NUMBERS IS 0 ... 2^(N)-1.  ok
\ II HAVEN'T FIGURED OUT HOW TO TEST KEY, QUIT, ABORT, OR ABORT"...  ok
\ I ALSO HAVEN'T THOUGHT OF A WAY TO TEST ENVIRONMENT?...  ok
  ok
testing core words  ok
hex  ok
  ok
\ ------------------------------------------------------------------------  ok
testing basic assumptions  ok
  ok
{ -> }     \ Start with clean slate  ok
( test if any bits are set; answer in base 1 )  ok
{ : bitsset? if 0 0 else 0 then ; -> }  ok
{  0 bitsset? -> 0 }   \ zero is all bits clear  ok
{  1 bitsset? -> 0 0 } \ other number have at least one bit  ok
{ -1 bitsset? -> 0 0 }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing booleans: and invert or xor  ok
  ok
{ 0 0 and -> 0 }  ok
{ 0 1 and -> 0 }  ok
{ 1 0 and -> 0 }  ok
{ 1 1 and -> 1 }  ok
  ok
{ 0 invert 1 and -> 1 }  ok
{ 1 invert 1 and -> 0 }  ok
  ok
0 constant 0s  ok
0 invert constant 1s  ok
  ok
{ 0s invert -> 1s }  ok
{ 1s invert -> 0s }  ok
  ok
{ 0s 0s and -> 0s }  ok
{ 0s 1s and -> 0s }  ok
{ 1s 0s and -> 0s }  ok
{ 1s 1s and -> 1s }  ok
  ok
{ 0s 0s or -> 0s }  ok
{ 0s 1s or -> 1s }  ok
{ 1s 0s or -> 1s }  ok
{ 1s 1s or -> 1s }  ok
  ok
{ 0s 0s xor -> 0s }  ok
{ 0s 1s xor -> 1s }  ok
{ 1s 0s xor -> 1s }  ok
{ 1s 1s xor -> 0s }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing 2* 2/ lshift rshift  ok
  ok
( we trust 1s, invert, and bitsset?; we will confirm rshift later )  ok
1s 1 rshift invert constant msb  ok
{ msb bitsset? -> 0 0 }  ok
  ok
{ 0s 2* -> 0s }  ok
{ 1 2* -> 2 }  ok
{ 4000 2* -> 8000 }  ok
{ 1s 2* 1 xor -> 1s }  ok
{ msb 2* -> 0s }  ok
  ok
{ 0s 2/ -> 0s }  ok
{ 1 2/ -> 0 }  ok
{ 4000 2/ -> 2000 }  ok
{ 1s 2/ -> 1s } \ msb propogated  ok
{ 1s 1 xor 2/ -> 1s }  ok
{ msb 2/ msb and -> msb }  ok
  ok
{ 1 0 lshift -> 1 }  ok
{ 1 1 lshift -> 2 }  ok
{ 1 2 lshift -> 4 }  ok
{ 1 f lshift -> 8000 } \ biggest guaranteed shift  ok
{ 1s 1 lshift 1 xor -> 1s }  ok
{ msb 1 lshift -> 0 }  ok
  ok
{ 1 0 rshift -> 1 }  ok
{ 1 1 rshift -> 0 }  ok
{ 2 1 rshift -> 1 }  ok
{ 4 2 rshift -> 1 }  ok
{ 8000 f rshift -> 1 } \ biggest  ok
{ msb 1 rshift msb and -> 0 }  \ rshift zero fills msbs  ok
{ msb 1 rshift 2* -> msb }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing comparisons: 0= = <> 0< < > u< min max within  ok
( TODO we need to add max-2int and min-2int for further tests)  ok
0 invert  constant max-uint  ok
0 invert 1 rshift  constant max-int  ok
0 invert 1 rshift invert  constant min-int  ok
0 invert 1 rshift  constant mid-uint  ok
0 invert 1 rshift invert  constant mid-uint+1  ok
  ok
0s constant <false>  ok
1s constant <true>  ok
  ok
{ 0 0= -> <true> }  ok
{ 1 0= -> <false> }  ok
{ 2 0= -> <false> }  ok
{ -1 0= -> <false> }  ok
{ max-uint 0= -> <false> }  ok
{ min-int 0= -> <false> }  ok
{ max-int 0= -> <false> }  ok
  ok
{ 0 0 = -> <true> }  ok
{ 1 1 = -> <true> }  ok
{ -1 -1 = -> <true> }  ok
{ 1 0 = -> <false> }  ok
{ -1 0 = -> <false> }  ok
{ 0 1 = -> <false> }  ok
{ 0 -1 = -> <false> }  ok
  ok
{ 0 0 <> -> <false> }  ok
{ 1 1 <> -> <false> }  ok
{ -1 -1 <> -> <false> }  ok
{ 1 0 <> -> <true> }  ok
{ -1 0 <> -> <true> }  ok
{ 0 1 <> -> <true> }  ok
{ 0 -1 <> -> <true> }  ok
  ok
{ 0 0< -> <false> }  ok
{ -1 0< -> <true> }  ok
{ min-int 0< -> <true> }  ok
{ 1 0< -> <false> }  ok
{ max-int 0< -> <false> }  ok
  ok
{ 0 1 < -> <true> }  ok
{ 1 2 < -> <true> }  ok
{ -1 0 < -> <true> }  ok
{ -1 1 < -> <true> }  ok
{ min-int 0 < -> <true> }  ok
{ min-int max-int < -> <true> }  ok
{ 0 max-int < -> <true> }  ok
{ 0 0 < -> <false> }  ok
{ 1 1 < -> <false> }  ok
{ 1 0 < -> <false> }  ok
{ 2 1 < -> <false> }  ok
{ 0 -1 < -> <false> }  ok
{ 1 -1 < -> <false> }  ok
{ 0 min-int < -> <false> }  ok
{ max-int min-int < -> <false> }  ok
{ max-int 0 < -> <false> }  ok
  ok
{ 0 1 > -> <false> }  ok
{ 1 2 > -> <false> }  ok
{ -1 0 > -> <false> }  ok
{ -1 1 > -> <false> }  ok
{ min-int 0 > -> <false> }  ok
{ min-int max-int > -> <false> }  ok
{ 0 max-int > -> <false> }  ok
{ 0 0 > -> <false> }  ok
{ 1 1 > -> <false> }  ok
{ 1 0 > -> <true> }  ok
{ 2 1 > -> <true> }  ok
{ 0 -1 > -> <true> }  ok
{ 1 -1 > -> <true> }  ok
{ 0 min-int > -> <true> }  ok
{ max-int min-int > -> <true> }  ok
{ max-int 0 > -> <true> }  ok
  ok
{ 0 1 u< -> <true> }  ok
{ 1 2 u< -> <true> }  ok
{ 0 mid-uint u< -> <true> }  ok
{ 0 max-uint u< -> <true> }  ok
{ mid-uint max-uint u< -> <true> }  ok
{ 0 0 u< -> <false> }  ok
{ 1 1 u< -> <false> }  ok
{ 1 0 u< -> <false> }  ok
{ 2 1 u< -> <false> }  ok
{ mid-uint 0 u< -> <false> }  ok
{ max-uint 0 u< -> <false> }  ok
{ max-uint mid-uint u< -> <false> }  ok
  ok
{ 0 1 min -> 0 }  ok
{ 1 2 min -> 1 }  ok
{ -1 0 min -> -1 }  ok
{ -1 1 min -> -1 }  ok
{ min-int 0 min -> min-int }  ok
{ min-int max-int min -> min-int }  ok
{ 0 max-int min -> 0 }  ok
{ 0 0 min -> 0 }  ok
{ 1 1 min -> 1 }  ok
{ 1 0 min -> 0 }  ok
{ 2 1 min -> 1 }  ok
{ 0 -1 min -> -1 }  ok
{ 1 -1 min -> -1 }  ok
{ 0 min-int min -> min-int }  ok
{ max-int min-int min -> min-int }  ok
{ max-int 0 min -> 0 }  ok
  ok
{ 0 1 max -> 1 }  ok
{ 1 2 max -> 2 }  ok
{ -1 0 max -> 0 }  ok
{ -1 1 max -> 1 }  ok
{ min-int 0 max -> 0 }  ok
{ min-int max-int max -> max-int }  ok
{ 0 max-int max -> max-int }  ok
{ 0 0 max -> 0 }  ok
{ 1 1 max -> 1 }  ok
{ 1 0 max -> 1 }  ok
{ 2 1 max -> 2 }  ok
{ 0 -1 max -> 0 }  ok
{ 1 -1 max -> 1 }  ok
{ 0 min-int max -> 0 }  ok
{ max-int min-int max -> max-int }  ok
{ max-int 0 max -> max-int }  ok
  ok
{ 1 2 4 within -> <false> }  ok
{ 2 2 4 within -> <true> }  ok
{ 3 2 4 within -> <true> }  ok
{ 4 2 4 within -> <false> }  ok
{ 5 2 4 within -> <false> }  ok
  ok
{ 0 2 4 within -> <false> }  ok
{ 1 0 4 within -> <true> }  ok
{ 0 0 4 within -> <true> }  ok
{ 4 0 4 within -> <false> }  ok
{ 5 0 4 within -> <false> }  ok
  ok
{ -1 -3 -1 within -> <false> }  ok
{ -2 -3 -1 within -> <true> }  ok
{ -3 -3 -1 within -> <true> }  ok
{ -4 -3 -1 within -> <false> }  ok
  ok
{ -2 -2 0 within -> <true> }  ok
{ -1 -2 0 within -> <true> }  ok
{ 0 -2 0 within -> <false> }  ok
{ 1 -2 0 within -> <false> }  ok
  ok
{ 0 min-int max-int within -> <true> }  ok
{ 1 min-int max-int within -> <true> }  ok
{ -1 min-int max-int within -> <true> }  ok
{ min-int min-int max-int within -> <true> }  ok
{ max-int min-int max-int within -> <false> }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing stack ops: 2drop 2dup 2over 2swap ?dup depth drop dup nip over rot -rot swap   ok
  ok
{ 1 2 2drop -> }  ok
{ 1 2 2dup -> 1 2 1 2 }  ok
{ 1 2 3 4 2over -> 1 2 3 4 1 2 }  ok
{ 1 2 3 4 2swap -> 3 4 1 2 }  ok
{ 0 ?dup -> 0 }  ok
{ 1 ?dup -> 1 1 }  ok
{ -1 ?dup -> -1 -1 }  ok
{ depth -> 0 }  ok
{ 0 depth -> 0 1 }  ok
{ 0 1 depth -> 0 1 2 }  ok
{ 0 drop -> }  ok
{ 1 2 drop -> 1 }  ok
{ 1 dup -> 1 1 }  ok
{ 1 2 nip -> 2 }  ok
{ 1 2 over -> 1 2 1 }  ok
{ 1 2 3 rot -> 2 3 1 }  ok
{ 1 2 3 -rot -> 3 1 2 }  ok
{ 1 2 swap -> 2 1 }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing >r r> r@  ok
  ok
{ : gr1 >r r> ; -> }  ok
{ : gr2 >r r@ r> drop ; -> }  ok
{ 123 gr1 -> 123 }  ok
{ 123 gr2 -> 123 }  ok
{ 1s gr1 -> 1s } \ return stack holds cells  ok
  ok
\ ------------------------------------------------------------------------  ok
teting add/subtract: + - 1+ 1- abs negate dnegate >teting< Undefined word
  ok
{ 0 5 + -> 5 }  ok
{ 5 0 + -> 5 }  ok
{ 0 -5 + -> -5 }  ok
{ -5 0 + -> -5 }  ok
{  2 + -> 3 } Stack underflow
{  -2 + -> -1 } Stack underflow
{ -1 2 + -> 1 }  ok
{ -1 -2 + -> -3 }  ok
{ -1 1 + -> 0 }  ok
{ mid-uint 1 + -> mid-uint+1 }  ok
  ok
{ 0 5 - -> -5 }  ok
{ 5 0 - -> 5 }  ok
{ 0 -5 - -> 5 }  ok
{ -5 0 - -> -5 }  ok
{ 1 2 - -> -1 }  ok
{ 1 -2 - -> 3 }  ok
{ -1 2 - -> -3 }  ok
{ -1 -2 - -> 1 }  ok
{ 0 1 - -> -1 }  ok
{ mid-uint+1 1 - -> mid-uint }  ok
  ok
{ 0 1+ -> 1 }  ok
{ -1 1+ -> 0 }  ok
{ 1 1+ -> 2 }  ok
{ mid-uint 1+ -> mid-uint+1 }  ok
  ok
{ 2 1- -> 1 }  ok
{ 1 1- -> 0 }  ok
{ 0 1- -> -1 }  ok
{ mid-uint+1 1- -> mid-uint }  ok
  ok
{ 0 negate -> 0 }  ok
{ 1 negate -> -1 }  ok
{ -1 negate -> 1 }  ok
{ 2 negate -> -2 }  ok
{ -2 negate -> 2 }  ok
  ok
{ 0. dnegate -> 0. }  ok
{ 1. dnegate -> -1. }  ok
{ -1. dnegate -> 1. }  ok
\ { max-2int dnegate -> min-2int swap 1+ swap } \ TODO Not working yet  ok
\ { min-2int swap 1+ swap dnegate -> max-2int } \ TODO Not working yet   ok
  ok
{ 0 abs -> 0 }  ok
{ 1 abs -> 1 }  ok
{ -1 abs -> 1 }  ok
{ min-int abs -> mid-uint+1 }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing multiply: s>d * m* um*  ok
  ok
{ 0 s>d -> 0 0 }  ok
{ 1 s>d -> 1 0 }  ok
{ 2 s>d -> 2 0 }  ok
{ -1 s>d -> -1 -1 }  ok
{ -2 s>d -> -2 -1 }  ok
{ min-int s>d -> min-int -1 }  ok
{ max-int s>d -> max-int 0 }  ok
  ok
{ 0 0 m* -> 0 s>d }  ok
{ 0 1 m* -> 0 s>d }  ok
{ 1 0 m* -> 0 s>d }  ok
{ 1 2 m* -> 2 s>d }  ok
{ 2 1 m* -> 2 s>d }  ok
{ 3 3 m* -> 9 s>d }  ok
{ -3 3 m* -> -9 s>d }  ok
{ 3 -3 m* -> -9 s>d }  ok
{ -3 -3 m* -> 9 s>d }  ok
{ 0 min-int m* -> 0 s>d }  ok
{ 1 min-int m* -> min-int s>d }  ok
{ 2 min-int m* -> 0 1s }  ok
{ 0 max-int m* -> 0 s>d }  ok
{ 1 max-int m* -> max-int s>d }  ok
{ 2 max-int m* -> max-int 1 lshift 0 }  ok
{ min-int min-int m* -> 0 msb 1 rshift }  ok
{ max-int min-int m* -> msb msb 2/ }  ok
{ max-int max-int m* -> 1 msb 2/ invert }  ok
  ok
{ 0 0 * -> 0 } \ test identities  ok
{ 0 1 * -> 0 }  ok
{ 1 0 * -> 0 }  ok
{ 1 2 * -> 2 }  ok
{ 2 1 * -> 2 }  ok
{ 3 3 * -> 9 }  ok
{ -3 3 * -> -9 }  ok
{ 3 -3 * -> -9 }  ok
{ -3 -3 * -> 9 }  ok
  ok
{ mid-uint+1 1 rshift 2 * -> mid-uint+1 }  ok
{ mid-uint+1 2 rshift 4 * -> mid-uint+1 }  ok
{ mid-uint+1 1 rshift mid-uint+1 or 2 * -> mid-uint+1 }  ok
  ok
{ 0 0 um* -> 0 0 }  ok
{ 0 1 um* -> 0 0 }  ok
{ 1 0 um* -> 0 0 }  ok
{ 1 2 um* -> 2 0 }  ok
{ 2 1 um* -> 2 0 }  ok
{ 3 3 um* -> 9 0 }  ok
  ok
{ mid-uint+1 1 rshift 2 um* -> mid-uint+1 0 }  ok
{ mid-uint+1 2 um* -> 0 1 }  ok
{ mid-uint+1 4 um* -> 0 2 }  ok
{ 1s 2 um* -> 1s 1 lshift 1 }  ok
{ max-uint max-uint um* -> 1 1 invert }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing divide: fm/mod sm/rem um/mod */ */mod / /mod mod  ok
  ok
{ 0 s>d 1 fm/mod -> 0 0 }  ok
{ 1 s>d 1 fm/mod -> 0 1 }  ok
{ 2 s>d 1 fm/mod -> 0 2 }  ok
{ -1 s>d 1 fm/mod -> 0 -1 }  ok
{ -2 s>d 1 fm/mod -> 0 -2 }  ok
{ 0 s>d -1 fm/mod -> 0 0 }  ok
{ 1 s>d -1 fm/mod -> 0 -1 }  ok
{ 2 s>d -1 fm/mod -> 0 -2 }  ok
{ -1 s>d -1 fm/mod -> 0 1 }  ok
{ -2 s>d -1 fm/mod -> 0 2 }  ok
{ 2 s>d 2 fm/mod -> 0 1 }  ok
{ -1 s>d -1 fm/mod -> 0 1 }  ok
{ -2 s>d -2 fm/mod -> 0 1 }  ok
{  7 s>d  3 fm/mod -> 1 2 }  ok
{  7 s>d -3 fm/mod -> -2 -3 }  ok
{ -7 s>d  3 fm/mod -> 2 -3 }  ok
{ -7 s>d -3 fm/mod -> -1 2 }  ok
{ max-int s>d 1 fm/mod -> 0 max-int }  ok
{ min-int s>d 1 fm/mod -> 0 min-int }  ok
{ max-int s>d max-int fm/mod -> 0 1 }  ok
{ min-int s>d min-int fm/mod -> 0 1 }  ok
{ 1s 1 4 fm/mod -> 3 max-int }  ok
{ 1 min-int m* 1 fm/mod -> 0 min-int }  ok
{ 1 min-int m* min-int fm/mod -> 0 1 }  ok
{ 2 min-int m* 2 fm/mod -> 0 min-int }  ok
{ 2 min-int m* min-int fm/mod -> 0 2 }  ok
{ 1 max-int m* 1 fm/mod -> 0 max-int }  ok
{ 1 max-int m* max-int fm/mod -> 0 1 }  ok
{ 2 max-int m* 2 fm/mod -> 0 max-int }  ok
{ 2 max-int m* max-int fm/mod -> 0 2 }  ok
{ min-int min-int m* min-int fm/mod -> 0 min-int }  ok
{ min-int max-int m* min-int fm/mod -> 0 max-int }  ok
{ min-int max-int m* max-int fm/mod -> 0 min-int }  ok
{ max-int max-int m* max-int fm/mod -> 0 max-int }  ok
  ok
{ 0 s>d 1 sm/rem -> 0 0 }  ok
{ 1 s>d 1 sm/rem -> 0 1 }  ok
{ 2 s>d 1 sm/rem -> 0 2 }  ok
{ -1 s>d 1 sm/rem -> 0 -1 }  ok
{ -2 s>d 1 sm/rem -> 0 -2 }  ok
{ 0 s>d -1 sm/rem -> 0 0 }  ok
{ 1 s>d -1 sm/rem -> 0 -1 }  ok
{ 2 s>d -1 sm/rem -> 0 -2 }  ok
{ -1 s>d -1 sm/rem -> 0 1 }  ok
{ -2 s>d -1 sm/rem -> 0 2 }  ok
{ 2 s>d 2 sm/rem -> 0 1 }  ok
{ -1 s>d -1 sm/rem -> 0 1 }  ok
{ -2 s>d -2 sm/rem -> 0 1 }  ok
{  7 s>d  3 sm/rem -> 1 2 }  ok
{  7 s>d -3 sm/rem -> 1 -2 }  ok
{ -7 s>d  3 sm/rem -> -1 -2 }  ok
{ -7 s>d -3 sm/rem -> -1 2 }  ok
{ max-int s>d 1 sm/rem -> 0 max-int }  ok
{ min-int s>d 1 sm/rem -> 0 min-int }  ok
{ max-int s>d max-int sm/rem -> 0 1 }  ok
{ min-int s>d min-int sm/rem -> 0 1 }  ok
{ 1s 1 4 sm/rem -> 3 max-int }  ok
{ 2 min-int m* 2 sm/rem -> 0 min-int }  ok
{ 2 min-int m* min-int sm/rem -> 0 2 }  ok
{ 2 max-int m* 2 sm/rem -> 0 max-int }  ok
{ 2 max-int m* max-int sm/rem -> 0 2 }  ok
{ min-int min-int m* min-int sm/rem -> 0 min-int }  ok
{ min-int max-int m* min-int sm/rem -> 0 max-int }  ok
{ min-int max-int m* max-int sm/rem -> 0 min-int }  ok
{ max-int max-int m* max-int sm/rem -> 0 max-int }  ok
  ok
{ 0 0 1 um/mod -> 0 0 }  ok
{ 1 0 1 um/mod -> 0 1 }  ok
{ 1 0 2 um/mod -> 1 0 }  ok
{ 3 0 2 um/mod -> 1 1 }  ok
{ max-uint 2 um* 2 um/mod -> 0 max-uint }  ok
{ max-uint 2 um* max-uint um/mod -> 0 2 }  ok
{ max-uint max-uint um* max-uint um/mod -> 0 max-uint }  ok
  ok
: iffloored  compiled
   [ -3 2 / -2 = invert ] literal if postpone \ then ;  ok
: ifsym  compiled
   [ -3 2 / -1 = invert ] literal if postpone \ then ;  ok
  ok
\ the system might do either floored or symmetric division.  ok
\ since we have already tested m*, fm/mod, and sm/rem we can use them in test.  ok
iffloored : t/mod  >r s>d r> fm/mod ;  ok
iffloored : t/     t/mod swap drop ;  ok
iffloored : tmod   t/mod drop ;  ok
iffloored : t*/mod >r m* r> fm/mod ;  ok
iffloored : t*/    t*/mod swap drop ;  ok
ifsym     : t/mod  >r s>d r> sm/rem ;  ok
ifsym     : t/     t/mod swap drop ;  ok
ifsym     : tmod   t/mod drop ;  ok
ifsym     : t*/mod >r m* r> sm/rem ;  ok
ifsym     : t*/    t*/mod swap drop ;  ok
  ok
{ 0 1 /mod -> 0 1 t/mod }  ok
{ 1 1 /mod -> 1 1 t/mod }  ok
{ 2 1 /mod -> 2 1 t/mod }  ok
{ -1 1 /mod -> -1 1 t/mod }  ok
{ -2 1 /mod -> -2 1 t/mod }  ok
{ 0 -1 /mod -> 0 -1 t/mod }  ok
{ 1 -1 /mod -> 1 -1 t/mod }  ok
{ 2 -1 /mod -> 2 -1 t/mod }  ok
{ -1 -1 /mod -> -1 -1 t/mod }  ok
{ -2 -1 /mod -> -2 -1 t/mod }  ok
{ 2 2 /mod -> 2 2 t/mod }  ok
{ -1 -1 /mod -> -1 -1 t/mod }  ok
{ -2 -2 /mod -> -2 -2 t/mod }  ok
{ 7 3 /mod -> 7 3 t/mod }  ok
{ 7 -3 /mod -> 7 -3 t/mod }  ok
{ -7 3 /mod -> -7 3 t/mod }  ok
{ -7 -3 /mod -> -7 -3 t/mod }  ok
{ max-int 1 /mod -> max-int 1 t/mod }  ok
{ min-int 1 /mod -> min-int 1 t/mod }  ok
{ max-int max-int /mod -> max-int max-int t/mod }  ok
{ min-int min-int /mod -> min-int min-int t/mod }  ok
  ok
{ 0 1 / -> 0 1 t/ }  ok
{ 1 1 / -> 1 1 t/ }  ok
{ 2 1 / -> 2 1 t/ }  ok
{ -1 1 / -> -1 1 t/ }  ok
{ -2 1 / -> -2 1 t/ }  ok
{ 0 -1 / -> 0 -1 t/ }  ok
{ 1 -1 / -> 1 -1 t/ }  ok
{ 2 -1 / -> 2 -1 t/ }  ok
{ -1 -1 / -> -1 -1 t/ }  ok
{ -2 -1 / -> -2 -1 t/ }  ok
{ 2 2 / -> 2 2 t/ }  ok
{ -1 -1 / -> -1 -1 t/ }  ok
{ -2 -2 / -> -2 -2 t/ }  ok
{ 7 3 / -> 7 3 t/ }  ok
{ 7 -3 / -> 7 -3 t/ }  ok
{ -7 3 / -> -7 3 t/ }  ok
{ -7 -3 / -> -7 -3 t/ }  ok
{ max-int 1 / -> max-int 1 t/ }  ok
{ min-int 1 / -> min-int 1 t/ }  ok
{ max-int max-int / -> max-int max-int t/ }  ok
{ min-int min-int / -> min-int min-int t/ }  ok
  ok
{ 0 1 mod -> 0 1 tmod }  ok
{ 1 1 mod -> 1 1 tmod }  ok
{ 2 1 mod -> 2 1 tmod }  ok
{ -1 1 mod -> -1 1 tmod }  ok
{ -2 1 mod -> -2 1 tmod }  ok
{ 0 -1 mod -> 0 -1 tmod }  ok
{ 1 -1 mod -> 1 -1 tmod }  ok
{ 2 -1 mod -> 2 -1 tmod }  ok
{ -1 -1 mod -> -1 -1 tmod }  ok
{ -2 -1 mod -> -2 -1 tmod }  ok
{ 2 2 mod -> 2 2 tmod }  ok
{ -1 -1 mod -> -1 -1 tmod }  ok
{ -2 -2 mod -> -2 -2 tmod }  ok
{ 7 3 mod -> 7 3 tmod }  ok
{ 7 -3 mod -> 7 -3 tmod }  ok
{ -7 3 mod -> -7 3 tmod }  ok
{ -7 -3 mod -> -7 -3 tmod }  ok
{ max-int 1 mod -> max-int 1 tmod }  ok
{ min-int 1 mod -> min-int 1 tmod }  ok
{ max-int max-int mod -> max-int max-int tmod }  ok
{ min-int min-int mod -> min-int min-int tmod }  ok
  ok
{ 0 2 1 */ -> 0 2 1 t*/ }  ok
{ 1 2 1 */ -> 1 2 1 t*/ }  ok
{ 2 2 1 */ -> 2 2 1 t*/ }  ok
{ -1 2 1 */ -> -1 2 1 t*/ }  ok
{ -2 2 1 */ -> -2 2 1 t*/ }  ok
{ 0 2 -1 */ -> 0 2 -1 t*/ }  ok
{ 1 2 -1 */ -> 1 2 -1 t*/ }  ok
{ 2 2 -1 */ -> 2 2 -1 t*/ }  ok
{ -1 2 -1 */ -> -1 2 -1 t*/ }  ok
{ -2 2 -1 */ -> -2 2 -1 t*/ }  ok
{ 2 2 2 */ -> 2 2 2 t*/ }  ok
{ -1 2 -1 */ -> -1 2 -1 t*/ }  ok
{ -2 2 -2 */ -> -2 2 -2 t*/ }  ok
{ 7 2 3 */ -> 7 2 3 t*/ }  ok
{ 7 2 -3 */ -> 7 2 -3 t*/ }  ok
{ -7 2 3 */ -> -7 2 3 t*/ }  ok
{ -7 2 -3 */ -> -7 2 -3 t*/ }  ok
{ max-int 2 max-int */ -> max-int 2 max-int t*/ }  ok
{ min-int 2 min-int */ -> min-int 2 min-int t*/ }  ok
  ok
{ 0 2 1 */mod -> 0 2 1 t*/mod }  ok
{ 1 2 1 */mod -> 1 2 1 t*/mod }  ok
{ 2 2 1 */mod -> 2 2 1 t*/mod }  ok
{ -1 2 1 */mod -> -1 2 1 t*/mod }  ok
{ -2 2 1 */mod -> -2 2 1 t*/mod }  ok
{ 0 2 -1 */mod -> 0 2 -1 t*/mod }  ok
{ 1 2 -1 */mod -> 1 2 -1 t*/mod }  ok
{ 2 2 -1 */mod -> 2 2 -1 t*/mod }  ok
{ -1 2 -1 */mod -> -1 2 -1 t*/mod }  ok
{ -2 2 -1 */mod -> -2 2 -1 t*/mod }  ok
{ 2 2 2 */mod -> 2 2 2 t*/mod }  ok
{ -1 2 -1 */mod -> -1 2 -1 t*/mod }  ok
{ -2 2 -2 */mod -> -2 2 -2 t*/mod }  ok
{ 7 2 3 */mod -> 7 2 3 t*/mod }  ok
{ 7 2 -3 */mod -> 7 2 -3 t*/mod }  ok
{ -7 2 3 */mod -> -7 2 3 t*/mod }  ok
{ -7 2 -3 */mod -> -7 2 -3 t*/mod }  ok
{ max-int 2 max-int */mod -> max-int 2 max-int t*/mod }  ok
{ min-int 2 min-int */mod -> min-int 2 min-int t*/mod }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing here , @ ! cell+ cells c, c@ c! chars 2@ 2! align aligned +! allot pad unused  ok
  ok
here 1 allot  ok
here  ok
constant 2nda  ok
constant 1sta  ok
{ 1sta 2nda u< -> <true> }  \ here must grow with allot ...  ok
{ 1sta 1+ -> 2nda }         \ ... by one address unit  ok
( TODO missing test: negative allot )  ok
  ok
here 1 ,  ok
here 2 ,  ok
constant 2nd  ok
constant 1st  ok
{ 1st 2nd u< -> <true> } \ here must grow with allot ...  ok
{ 1st cell+ -> 2nd }     \ ... by one cell  ok
{ 1st 1 cells + -> 2nd }  ok
{ 1st @ 2nd @ -> 1 2 }  ok
{ 5 1st ! -> }  ok
{ 1st @ 2nd @ -> 5 2 }  ok
{ 6 2nd ! -> }  ok
{ 1st @ 2nd @ -> 5 6 }  ok
{ 1st 2@ -> 6 5 }  ok
{ 2 1 1st 2! -> }  ok
{ 1st 2@ -> 2 1 }  ok
{ 1s 1st !  1st @ -> 1s }  \ can store cell-wide value  ok
  ok
here 1 c,  ok
here 2 c,  ok
constant 2ndc  ok
constant 1stc  ok
{ 1stc 2ndc u< -> <true> } \ here must grow with allot  ok
{ 1stc char+ -> 2ndc }     \ ... by one char  ok
{ 1stc 1 chars + -> 2ndc }  ok
{ 1stc c@ 2ndc c@ -> 1 2 }  ok
{ 3 1stc c! -> }  ok
{ 1stc c@ 2ndc c@ -> 3 2 }  ok
{ 4 2ndc c! -> }  ok
{ 1stc c@ 2ndc c@ -> 3 4 }  ok
  ok
align 1 allot here align here 3 cells allot  ok
constant a-addr  constant ua-addr  ok
{ ua-addr aligned -> a-addr }  ok
{ 1 a-addr c!  a-addr c@ -> 1 }  ok
{ 1234 a-addr  !  a-addr  @ -> 1234 }  ok
{ 123 456 a-addr 2!  a-addr 2@ -> 123 456 }  ok
{ 2 a-addr char+ c!  a-addr char+ c@ -> 2 }  ok
{ 3 a-addr cell+ c!  a-addr cell+ c@ -> 3 }  ok
{ 1234 a-addr cell+ !  a-addr cell+ @ -> 1234 }  ok
{ 123 456 a-addr cell+ 2!  a-addr cell+ 2@ -> 123 456 }  ok
  ok
: bits ( x -- u )  compiled
   0 swap begin  compiled
   dup while   compiled
      dup msb and if  compiled
         >r 1+ r>   compiled
     then 2*   compiled
   repeat   compiled
   drop ;  ok
  ok
( characters >= 1 au, <= size of cell, >= 8 bits )  ok
{ 1 chars 1 < -> <false> }  ok
{ 1 chars 1 cells > -> <false> }  ok
( TODO how to find number of bits? )  ok
  ok
( cells >= 1 au, integral multiple of char size, >= 16 bits )  ok
{ 1 cells 1 < -> <false> }  ok
{ 1 cells 1 chars mod -> 0 }  ok
{ 1s bits 10 < -> <false> }  ok
  ok
{ 0 1st ! -> }  ok
{ 1 1st +! -> }  ok
{ 1st @ -> 1 }  ok
{ -1 1st +! 1st @ -> 0 }  ok
  ok
( here + unused + buffer size must be total RAM, that is, $7FFF )  ok
{ pad here - -> FF } \ PAD must have offset of $FF  ok
{ here unused + 400 + -> 7FFF }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing char [char] [ ] bl s"  ok
  ok
{ bl -> 20 }  ok
{ char X -> 58 }  ok
{ char HELLO -> 48 }  ok
{ : gc1 [char] X ; -> }  ok
{ : gc2 [char] HELLO ; -> }  ok
{ gc1 -> 58 }  ok
{ gc2 -> 48 }  ok
{ : gc3 [ gc1 ] literal ; -> }  ok
{ gc3 -> 58 }  ok
{ : gc4 s" XY" ; -> }  ok
{ gc4 swap drop -> 2 }  ok
{ gc4 drop dup c@ swap char+ c@ -> 58 59 }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing ' ['] find execute immediate count literal postpone state  ok
  ok
{ : gt1 123 ; -> }  ok
{ ' gt1 execute -> 123 }  ok
{ : gt2 ['] gt1 ; immediate -> }  ok
{ gt2 execute -> 123 }  ok
here 3 c, char g c, char t c, char 1 c, constant gt1string  ok
here 3 c, char g c, char t c, char 2 c, constant gt2string  ok
{ gt1string find -> ' gt1 -1 }  ok
{ gt2string find -> ' gt2 1 }  ok
( TODO how to search for non-existent word? )  ok
{ : gt3 gt2 literal ; -> }  ok
{ gt3 -> ' gt1 }  ok
{ gt1string count -> gt1string char+ 3 }  ok
  ok
{ : gt4 postpone gt1 ; immediate -> }  ok
{ : gt5 gt4 ; -> }  ok
{ gt5 -> 123 }  ok
{ : gt6 345 ; immediate -> }  ok
{ : gt7 postpone gt6 ; -> }  ok
{ gt7 -> 345 }  ok
  ok
{ : gt8 state @ ; immediate -> }  ok
{ gt8 -> 0 }  ok
{ : gt9 gt8 literal ; -> }  ok
{ gt9 0= -> <false> }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing if else then begin while repeat until recurse  ok
  ok
{ : gi1 if 123 then ; -> }  ok
{ : gi2 if 123 else 234 then ; -> }  ok
{  gi1 -> } Stack underflow
{ 1 gi1 -> 123 }  ok
{ -1 gi1 -> 123 }  ok
{ 0 gi2 -> 234 }  ok
{ 1 gi2 -> 123 }  ok
{ -1 gi1 -> 123 }  ok
  ok
{ : gi3 begin dup 5 < while dup 1+ repeat ; -> }  ok
{ 0 gi3 -> 0 1 2 3 4 5 }  ok
{ 4 gi3 -> 4 5 }  ok
{ 5 gi3 -> 5 }  ok
{ 6 gi3 -> 6 }  ok
  ok
{ : gi4 begin dup 1+ dup 5 > until ; -> }  ok
{ 3 gi4 -> 3 4 5 6 }  ok
{ 5 gi4 -> 5 6 }  ok
{ 6 gi4 -> 6 7 }  ok
  ok
{ : gi5 begin dup 2 > while dup 5 < while dup 1+ repeat 123 else 345 then ; -> }  ok
{ 1 gi5 -> 1 345 }  ok
{ 2 gi5 -> 2 345 }  ok
{ 3 gi5 -> 3 4 5 123 }  ok
{ 4 gi5 -> 4 5 123 }  ok
{ 5 gi5 -> 5 123 }  ok
  ok
{ : gi6 ( n -- 0,1,..n ) dup if dup >r 1- recurse r> then ; -> }  ok
{ 0 gi6 -> 0 }  ok
{ 1 gi6 -> 0 1 }  ok
{ 2 gi6 -> 0 1 2 }  ok
{ 3 gi6 -> 0 1 2 3 }  ok
{ 4 gi6 -> 0 1 2 3 4 }  ok
  ok
\ ------------------------------------------------------------------------  ok
testing do loop +loop i j unloop leave exit ?do  ok
  ok
{ : gd1 do i loop ; -> }  ok
{ 4 1 gd1 -> 1 2 3 }  ok
{ 2 -1 gd1 -> -1 0 1 }  ok
{ mid-uint+1 mid-uint gd1 -> mid-uint }  ok
  ok
{ : gd2 do i -1 +loop ; -> }  ok
{ 1 4 gd2 -> 4 3 2 1 }  ok
{ -1 2 gd2 -> 2 1 0 -1 }  ok
{ mid-uint mid-uint+1 gd2 -> mid-uint+1 mid-uint }  ok
  ok
{ : gd3 do 1 0 do j loop loop ; -> }  ok
{ 4 1 gd3 -> 1 2 3 }  ok
{ 2 -1 gd3 -> -1 0 1 }  ok
{ mid-uint+1 mid-uint gd3 -> mid-uint }  ok
  ok
{ : gd4 do 1 0 do j loop -1 +loop ; -> }  ok
{ 1 4 gd4 -> 4 3 2 1 }  ok
{ -1 2 gd4 -> 2 1 0 -1 }  ok
{ mid-uint mid-uint+1 gd4 -> mid-uint+1 mid-uint }  ok
  ok
{ : gd5 123 swap 0 do i 4 > if drop 234 leave then loop ; -> }  ok
{ 1 gd5 -> 123 }  ok
{ 5 gd5 -> 123 }  ok
{ 6 gd5 -> 234 }  ok
  ok
{ : gd6  ( pat: {0 0},{0 0}{1 0}{1 1},{0 0}{1 0}{1 1}{2 0}{2 1}{2 2} )  compiled
   0 swap 0 do  compiled
      i 1+ 0 do i j + 3 = if i unloop i unloop exit then 1+ loop  compiled
    loop ; -> }  ok
{ 1 gd6 -> 1 }  ok
{ 2 gd6 -> 3 }  ok
{ 3 gd6 -> 4 1 2 }  ok
  ok
: qd ?do i loop ;   ok
{   789   789 qd -> }   ok
{ 9876 -9876 qd -> }  
{ 9876 -9876 qd -> }  {     5     0 qd -> 0 1 2 3 4 }

