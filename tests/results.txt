Tali Forth 2 default kernel for py65mon (18. Feb 2018)


Tali Forth 2 for the 65c02
Version BETA 24. Dec 2018 
Copyright 2014-2018 Scot W. Stevenson
Tali Forth 2 comes with absolutely NO WARRANTY
Type 'bye' to exit
\ From: John Hayes S1I  ok
\ Subject: tester.fr  ok
\ Date: Mon, 27 Nov 95 13:10:09 PST    ok
  ok
\ Modified by SamCo 2018-05 for testing Tali Forth 2.  ok
\ The main change is lowercasing all of the words as Tali  ok
\ is case sensitive, as well as replacing tabs with spaces.  ok
\ A word to display the actual (erroneous) results was also added.  ok
\ Modified by SamCo 2018-10 to facilitate using standard ANS tests.  ok
\ The testing words were changed from { and } to T{ and }T to  ok
\ match the testing words currently being used by ANS standard tests.  ok
  ok
\ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS LABORATORY  ok
\ MAY BE DISTRIBUTED FREELY AS LONG AS THIS COPYRIGHT NOTICE REMAINS.  ok
hex  ok
  ok
\ Set the following flag to true for more verbose output; this may allow you to  ok
\ tell which test caused your system to hang. With Tali Forth, this is useless  ok
\ because the Python script echoes all the output anyway.  ok
variable verbose  false verbose !  ok
  ok
variable actual-depth   \ stack record  ok
create actual-results  20 cells allot  ok
  ok
  ok
\ Empty stack: handles underflowed stack too  ok
: empty-stack ( ... -- )   compiled
   depth ?dup if   compiled
      dup 0< if   compiled
         negate 0 do 0 loop   compiled
      else   compiled
         0 do drop loop   compiled
      then   compiled
   then ;  ok
  ok
\ Print the previous test's actual results. Added by SamCo 2018-05   ok
: show-results ( -- )   compiled
   s"  ACTUAL RESULT: { " type  compiled
   actual-depth @ 0 ?do  compiled
      actual-results   compiled
      actual-depth @ i - 1- \ Print them in reverse order to match test.  compiled
      cells + @ .  compiled
   loop  compiled
   s" }" type ;  ok
  ok
\ Display an error message followed by the line that had the error  ok
: error  \ ( C-ADDR U -- )   compiled
   type source type \ display line corresponding to error  compiled
   empty-stack      \ throw away every thing else  compiled
   show-results ;   \ added by SamCo to show what actually happened  ok
  ok
\ Syntactic sugar  ok
: T{  ( -- ) ;  ok
  ok
\ Record depth and content of stack  ok
: ->  ( ... -- )   compiled
   depth dup actual-depth !  \ record depth  compiled
   ?dup if                   \ if there is something on stack ...  compiled
      0 do   compiled
         actual-results i cells + !   compiled
      loop                   \ ... save it  compiled
   then ;  ok
  ok
\ Compare stack (expected) contents with saved (actual) contents  ok
: }T  ( ... -- )   compiled
   depth actual-depth @ = if     \ if depths match  compiled
      depth ?dup if              \ if there is something on the stack  compiled
         0 do                    \ for each stack item  compiled
            actual-results i cells + @  \ compare actual with expected  compiled
            <> if   compiled
               s" INCORRECT RESULT: " error leave   compiled
            then  compiled
         loop  compiled
      then  compiled
   else                          \ depth mismatch  compiled
      s" WRONG NUMBER OF RESULTS: " error  compiled
   then ;  ok
  ok
\ Talking comment  ok
: testing ( -- )   compiled
   source verbose @ if   compiled
      dup >r type cr r> >in !  compiled
   else >in ! drop  compiled
   then ;  ok
  ok
 ( Running test 'tali' from file 'tali.fs' )  ok
\ ------------------------------------------------------------------------  ok
hex  ok
  ok
marker tali_tests  ok
  ok
  ok
\ Repeat definitions for standalone testing  ok
0 constant 0s  ok
0 invert constant 1s  ok
0s constant <false>  ok
1s constant <true>  ok
  ok
\ ------------------------------------------------------------------------  ok
testing gforth words: bounds find-name latestxt name>int name>string  ok
\ Test for COLD not implemented  ok
  ok
( TODO NAME>INT test missing)  ok
( TODO NAME>STRING test missing)  ok
  ok
\ Test for FIND-NAME assumes that PARSE-NAME has been tested in core.fs  ok
T{ parse-name drop     find-name  0<> -> <true> }T \ need to find any nt  ok
T{ parse-name Chatika  find-name  0=  -> <true> }T \ shouldn't find Tali's drone  ok
  ok
T{ hex -> }T  ok
T{ 1000 10 bounds -> 1010 1000 }T  ok
T{ ffff 2 bounds -> 0001 ffff }T  \ BOUNDS wraps on Tali with 16 bit address space  ok
T{ decimal -> }T  ok
  ok
\ ------------------------------------------------------------------------  ok
\ testing tali-only words: -leading cleave hexstore  ok
  ok
\ -leading: Trip leading whitespace  ok
T{ s" aaa" -leading  s" aaa" compare -> 0 }T   \ No leading spaces  ok
T{ s"  bbb" -leading  s" bbb" compare -> 0 }T  \ one leading space  ok
T{ s"   ccc" -leading  s" ccc" compare -> 0 }T   \ two leading spaces  ok
  ok
T{ s\" \tddd" -leading  s" ddd" compare -> 0 }T   \ one leading tab  ok
T{ s\" \t\teee" -leading  s" eee" compare -> 0 }T   \ two leading tabs  ok
  ok
T{ s\" \nddd" -leading  s" ddd" compare -> 0 }T   \ one leading LF  ok
T{ s\" \n\neee" -leading  s" eee" compare -> 0 }T   \ two leading LF  ok
  ok
\ Cleave: Normal cases. KNOWN issue: CLEAVE fails if we have multiple  ok
\ delimiters, for example "aaa  bbb" with two strings. This is also true if we  ok
\ start the string with a delimiter  ok
  ok
T{ : s1 s" " ; -> }T \ case 1: empty string  ok
T{ s1 cleave  s" " compare  -rot  s" " compare -> 0 0 }T  ok
  ok
T{ : s1 s" aaa" ; -> }T  \ case 2: one word redefined s1  ok
T{ s1 cleave  s" aaa" compare  -rot  s" " compare -> 0 0 }T  ok
  ok
T{ : s1 s" aaa bbb ccc" ; -> }T  \ case 3: lots of words, single space delimiter redefined s1  ok
T{ s1 cleave  s" aaa" compare  -rot  s" bbb ccc" compare -> 0 0 }T  ok
  ok
T{ : s1 s" bbb  ccc  ddd" ; -> }T  \ case 3a: lots of words, multiple space delimiter redefined s1  ok
T{ s1 cleave  s" bbb" compare  -rot  s" ccc  ddd" compare -> 0 0 }T  ok
  ok
T{ : s1 s\" eee\tfff\tggg" ; -> }T  \ case 3b: lots of words, tab delimter redefined s1  ok
T{ s1 cleave  s" eee" compare  -rot  s\" fff\tggg" compare -> 0 0 }T  ok
  ok
T{ : s1 s\" aaa\nAAA\nqqq" ; -> }T  \ case 3c: lots of words, EOL delimiter redefined s1  ok
T{ s1 cleave  s" aaa" compare  -rot  s\" AAA\nqqq" compare -> 0 0 }T  ok
  ok
T{ : s1 s"  xxx yyy zzz" ; -> }T  \ case 3d: lots of words, start with space delimiter redefined s1  ok
T{ s1 cleave  s" xxx" compare  -rot  s" yyy zzz" compare -> 0 0 }T INCORRECT RESULT: T{ s1 cleave  s" xxx" compare  -rot  s" yyy zzz" compare -> 0 0 }T ACTUAL RESULT: { 0 -1 } ok
  ok
  ok
\ Cleave: Pathological cases  ok
  ok
T{ : s1 s"  aaa bbb ccc" ; -> }T \ case 4: Leading space is cleaved redefined s1  ok
T{ s1 cleave  s" " compare  -rot  s" aaa bbb ccc" compare -> 0 0 }T INCORRECT RESULT: T{ s1 cleave  s" " compare  -rot  s" aaa bbb ccc" compare -> 0 0 }T ACTUAL RESULT: { 1 -1 } ok
  ok
T{ : s1 s" aaa bbb ccc " ; -> }T \ case 5: Trailing space is left redefined s1  ok
T{ s1 cleave  s" aaa" compare  -rot  s" bbb ccc " compare -> 0 0 }T  ok
  ok
T{ : s1 s" aaa " ; -> }T  \ case 6: Trailing space on single word is empty redefined s1  ok
T{ s1 cleave  s" aaa" compare  -rot  s" " compare -> 0 0 }T  ok
  ok
T{ : s1 s"  " ; -> }T  \ case 7: Single space as word is two empty words redefined s1  ok
T{ s1 cleave  s" " compare  -rot  s" " compare -> 0 0 }T INCORRECT RESULT: T{ s1 cleave  s" " compare  -rot  s" " compare -> 0 0 }T ACTUAL RESULT: { 0 1 } ok
  ok
  ok
\ Hexstore: Normal cases  ok
  ok
create hs-test 5 allot  ok
  ok
decimal  ok
create hs-want-dec  1 c, 2 c, 3 c, 4 c, 5 c,   ok
T{ s" 1 2 3 4 5" hs-test hexstore  hs-test swap  hs-want-dec 5  compare -> 0 }T  ok
T{ s" 1" hs-test hexstore  hs-test swap  hs-want-dec 1  compare -> 0 }T  ok
  ok
hex  ok
create hs-want-hex  0A c, 0B c, 0C c, 0D c, 0E c,   ok
T{ s" 0A 0B 0C 0D 0E" hs-test hexstore  hs-test swap  hs-want-hex 5  compare -> 0 }T  ok
T{ s" 0A" hs-test hexstore  hs-test swap  hs-want-hex 1  compare -> 0 }T  ok
  ok
\ Hexstore: Pathological cases  ok
  ok
decimal  ok
T{ s" " hs-test hexstore  hs-test swap  s" " compare -> 0 }T  ok
T{ s" emergency" hs-test hexstore  hs-test swap  s" " compare -> 0 }T  ok
T{ s" emergency induction port" hs-test hexstore  hs-test swap  s" " compare -> 0 }T  ok
  ok
create hs-want-dec-path  01 c, 02 c,  ok
T{ s" 01 HONK! 02" hs-test hexstore  hs-test swap  hs-want-dec-path 2 compare -> 0 }T  ok
T{ s" HONK! 01 02" hs-test hexstore  hs-test swap  hs-want-dec-path 2 compare -> 0 }T  ok
T{ s" 01 02 HONK!" hs-test hexstore  hs-test swap  hs-want-dec-path 2 compare -> 0 }T  ok
  ok
\ ------------------------------------------------------------------------  ok
testing tali-only words: always-native bell compile-only digit? int>name  ok
testing tali-only words: latestnt latestxt number 0 1 2  ok
testing tali-only words: allow-native never-native wordsize nc-limit  ok
decimal  ok
  ok
\ Test for 0BRANCH not implemented  ok
\ Test for BRANCH not implemented  ok
\ Test for DISASM not implemented  ok
\ Test for INPUT not implemented  ok
\ Test for OUTPUT not implemented  ok
\ Test for UF-STRIP not implemented  ok
  ok
( TODO BELL test missing)  ok
( TODO COMPILE-ONLY test missing)  ok
  ok
\ Test int>name, latestnt, latestxt, and wordsize  ok
: one 1 ;  ok
T{ ' one int>name wordsize    -> 8 }T  ok
T{ latestxt int>name wordsize -> 8 }T  ok
T{ latestnt wordsize          -> 8 }T  ok
  ok
\ One should have been c