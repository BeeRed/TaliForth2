Tali Forth 2 default kernel for py65mon (18. Feb 2018)


Tali Forth 2 for the 65c02
Version BETA 11. Dec 2018 
Copyright 2014-2018 Scot W. Stevenson
Tali Forth 2 comes with absolutely NO WARRANTY
Type 'bye' to exit
\ From: John Hayes S1I  ok
\ Subject: tester.fr  ok
\ Date: Mon, 27 Nov 95 13:10:09 PST    ok
  ok
\ Modified by SamCo 2018-05 for testing Tali Forth 2.  ok
\ The main change is lowercasing all of the words as Tali  ok
\ is case sensitive, as well as replacing tabs with spaces.  ok
\ A word to display the actual (erroneous) results was also added.  ok
\ Modified by SamCo 2018-10 to facilitate using standard ANS tests.  ok
\ The testing words were changed from { and } to T{ and }T to  ok
\ match the testing words currently being used by ANS standard tests.  ok
  ok
\ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS LABORATORY  ok
\ MAY BE DISTRIBUTED FREELY AS LONG AS THIS COPYRIGHT NOTICE REMAINS.  ok
hex  ok
  ok
\ Set the following flag to true for more verbose output; this may allow you to  ok
\ tell which test caused your system to hang. With Tali Forth, this is useless  ok
\ because the Python script echoes all the output anyway.  ok
variable verbose  false verbose !  ok
  ok
variable actual-depth   \ stack record  ok
create actual-results  20 cells allot  ok
  ok
\ Empty stack: handles underflowed stack too  ok
: empty-stack ( ... -- )   compiled
   depth ?dup if   compiled
      dup 0< if   compiled
         negate 0 do 0 loop   compiled
      else   compiled
         0 do drop loop   compiled
      then   compiled
   then ;  ok
  ok
\ Print the previous test's actual results. Added by SamCo 2018-05   ok
: show-results ( -- )   compiled
   s"  ACTUAL RESULT: { " type  compiled
   actual-depth @ 0 ?do  compiled
      actual-results   compiled
      actual-depth @ i - 1- \ Print them in reverse order to match test.  compiled
      cells + @ .  compiled
   loop  compiled
   s" }" type ;  ok
  ok
\ Display an error message followed by the line that had the error  ok
: error  \ ( C-ADDR U -- )   compiled
   type source type \ display line corresponding to error  compiled
   empty-stack      \ throw away every thing else  compiled
   show-results ;   \ added by SamCo to show what actually happened  ok
  ok
\ Syntactic sugar  ok
: T{  ( -- ) ;  ok
  ok
\ Record depth and content of stack  ok
: ->  ( ... -- )   compiled
   depth dup actual-depth !  \ record depth  compiled
   ?dup if                   \ if there is something on stack ...  compiled
      0 do   compiled
         actual-results i cells + !   compiled
      loop                   \ ... save it  compiled
   then ;  ok
  ok
\ Compare stack (expected) contents with saved (actual) contents  ok
: }T  ( ... -- )   compiled
   depth actual-depth @ = if     \ if depths match  compiled
      depth ?dup if              \ if there is something on the stack  compiled
         0 do                    \ for each stack item  compiled
            actual-results i cells + @  \ compare actual with expected  compiled
            <> if   compiled
               s" INCORRECT RESULT: " error leave   compiled
            then  compiled
         loop  compiled
      then  compiled
   else                          \ depth mismatch  compiled
      s" WRONG NUMBER OF RESULTS: " error  compiled
   then ;  ok
  ok
\ Talking comment  ok
: testing ( -- )   compiled
   source verbose @ if   compiled
      dup >r type cr r> >in !  compiled
   else >in ! drop  compiled
   then ;  ok
  ok
 ( Running test 'asm' from file 'asm.fs' )  ok
\ ------------------------------------------------------------------------  ok
testing assembler words  ok
  ok
marker asm-tests   ok
  ok
\ Add assembler wordlist. This currently kills <true>  ok
forth-wordlist assembler-wordlist 2 set-order  ok
  ok
  ok
: opcode-test ( opc len addr u -- f )  compiled
   here        ( opc len addr u here0 )  compiled
   dup >r      ( opc len addr u here0 ) ( R: here0 )  compiled
   -rot        ( opc len here0 addr u ) ( R: here0 )  compiled
   evaluate    ( opc len here0 ) ( R: here0 )  compiled
  compiled
   \ See if length is correct  compiled
   here swap -    ( opc len n ) ( R: here0 )  compiled
   =              ( opc f ) ( R: here0 )  compiled
   swap           ( f opc ) ( R: here0 )  compiled
  compiled
   \ See if opcode is correct. We can't use AND for the last step because that  compiled
   \ is replaced by the assembler instruction of the same name  compiled
   r> c@          ( f opc c )  compiled
   =              ( f f )   compiled
;  ok
  ok
\ Test for little endian behavior with three-byte instructions  ok
\ For instance, 'sta 1122' must become 8D 22 11. Note that Tali stores the cell  ok
\ values little-endian as well, which makes this test confusing at first glance.  ok
\ Insert  CR DUP 3 DUMP CR  after EVALUTE to convince yourself that this is okay  ok
: little-endian? ( u-want addr u -- f )  compiled
   here -rot      ( u-want here0 addr u )  compiled
   evaluate       ( u-want here0 )  compiled
   \ cr dup 3 dump cr   \ Manual check for paranoia  compiled
   1+             ( u-want here0+1 ) \ Skip opcode  compiled
   @              ( u-want u-have )  compiled
   =              ( f )   compiled
;  ok
  ok
\ Testing all assembler instructions: Opcode and length  ok
T{ 0ea 1 s" nop" opcode-test -> -1 -1 }T  ok
T{ 0a9 2 s" 0ff lda.#" opcode-test -> -1 -1 }T  ok
  ok
\ Testing all three-byte instructions: Little endian  ok
T{ 1122 s" 1122 sta" little-endian? -> -1 }T  ok
  ok
  ok
\ Testing pseudo-instructions  ok
T{ here  0a lda.# push-a  execute -> 0a }T 