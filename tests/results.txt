Tali Forth 2 default kernel for py65mon (18. Feb 2018)


Tali Forth 2 for the 65c02
Version BETA 21. Dec 2018 
Copyright 2014-2018 Scot W. Stevenson
Tali Forth 2 comes with absolutely NO WARRANTY
Type 'bye' to exit
\ From: John Hayes S1I  ok
\ Subject: tester.fr  ok
\ Date: Mon, 27 Nov 95 13:10:09 PST    ok
  ok
\ Modified by SamCo 2018-05 for testing Tali Forth 2.  ok
\ The main change is lowercasing all of the words as Tali  ok
\ is case sensitive, as well as replacing tabs with spaces.  ok
\ A word to display the actual (erroneous) results was also added.  ok
\ Modified by SamCo 2018-10 to facilitate using standard ANS tests.  ok
\ The testing words were changed from { and } to T{ and }T to  ok
\ match the testing words currently being used by ANS standard tests.  ok
  ok
\ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS LABORATORY  ok
\ MAY BE DISTRIBUTED FREELY AS LONG AS THIS COPYRIGHT NOTICE REMAINS.  ok
hex  ok
  ok
\ Set the following flag to true for more verbose output; this may allow you to  ok
\ tell which test caused your system to hang. With Tali Forth, this is useless  ok
\ because the Python script echoes all the output anyway.  ok
variable verbose  false verbose !  ok
  ok
variable actual-depth   \ stack record  ok
create actual-results  20 cells allot  ok
  ok
\ Empty stack: handles underflowed stack too  ok
: empty-stack ( ... -- )   compiled
   depth ?dup if   compiled
      dup 0< if   compiled
         negate 0 do 0 loop   compiled
      else   compiled
         0 do drop loop   compiled
      then   compiled
   then ;  ok
  ok
\ Print the previous test's actual results. Added by SamCo 2018-05   ok
: show-results ( -- )   compiled
   s"  ACTUAL RESULT: { " type  compiled
   actual-depth @ 0 ?do  compiled
      actual-results   compiled
      actual-depth @ i - 1- \ Print them in reverse order to match test.  compiled
      cells + @ .  compiled
   loop  compiled
   s" }" type ;  ok
  ok
\ Display an error message followed by the line that had the error  ok
: error  \ ( C-ADDR U -- )   compiled
   type source type \ display line corresponding to error  compiled
   empty-stack      \ throw away every thing else  compiled
   show-results ;   \ added by SamCo to show what actually happened  ok
  ok
\ Syntactic sugar  ok
: T{  ( -- ) ;  ok
  ok
\ Record depth and content of stack  ok
: ->  ( ... -- )   compiled
   depth dup actual-depth !  \ record depth  compiled
   ?dup if                   \ if there is something on stack ...  compiled
      0 do   compiled
         actual-results i cells + !   compiled
      loop                   \ ... save it  compiled
   then ;  ok
  ok
\ Compare stack (expected) contents with saved (actual) contents  ok
: }T  ( ... -- )   compiled
   depth actual-depth @ = if     \ if depths match  compiled
      depth ?dup if              \ if there is something on the stack  compiled
         0 do                    \ for each stack item  compiled
            actual-results i cells + @  \ compare actual with expected  compiled
            <> if   compiled
               s" INCORRECT RESULT: " error leave   compiled
            then  compiled
         loop  compiled
      then  compiled
   else                          \ depth mismatch  compiled
      s" WRONG NUMBER OF RESULTS: " error  compiled
   then ;  ok
  ok
\ Talking comment  ok
: testing ( -- )   compiled
   source verbose @ if   compiled
      dup >r type cr r> >in !  compiled
   else >in ! drop  compiled
   then ;  ok
  ok
 ( Running test 'core' from file 'core.fs' )  ok
\ From: John Hayes S1I  ok
\ Subject: core.fr  ok
\ Date: Mon, 27 Nov 95 13:10  ok
  ok
\ Modified by SamCo 2018-05 for testing Tali Forth 2.  ok
\ The main change is lowercasing all of the words as Tali  ok
\ is case sensitive.  ok
  ok
\ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS LABORATORY  ok
\ MAY BE DISTRIBUTED FREELY AS LONG AS THIS COPYRIGHT NOTICE REMAINS.  ok
\ VERSION 1.2  ok
\ THIS PROGRAM TESTS THE CORE WORDS OF AN ANS FORTH SYSTEM.  ok
\ THE PROGRAM ASSUMES A TWO'S COMPLEMENT IMPLEMENTATION WHERE  ok
\ THE RANGE OF SIGNED NUMBERS IS -2^(N-1) ... 2^(N-1)-1 AND  ok
\ THE RANGE OF UNSIGNED NUMBERS IS 0 ... 2^(N)-1.  ok
\ I HAVEN'T FIGURED OUT HOW TO TEST KEY, QUIT, ABORT, OR ABORT"...  ok
  ok
testing core words  ok
hex  ok
  ok
marker core_tests  ok
  ok
\ ------------------------------------------------------------------------  ok
testing basic assumptions  ok
  ok
T{ -> }T     \ Start with clean slate WRONG NUMBER OF RESULTS: T{ -> }T     \ Start with clean slate ACTUAL RESULT: { 20 } ok
( test if any bits are set; answer in base 1 )  ok
T{ : bitsset? if 0 0 else 0 then ; -> }T  ok
T{  0 bitsset? -> 0 }T   \ zero is all bits clear  ok
T{  1 bitsset? -> 0 0 }T \ other number have at least one bit WRONG NUMBER OF RESULTS: T{  1 bitsset? -> 0 0 }T \ other number have at least one bit ACTUAL RESULT: { 0 0 }>\< Undefined word
T{ -1 bitsset? -> 0 0 }T WRONG NUMBER OF RESULTS: T{ -1 bitsset? -> 0 0 }T ACTUAL RESULT: { -1 0 0 } ok
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing booleans: and invert or xor  ok
  ok
T{ 0 0 and -> 0 }T >nd< Undefined word
T{ 0 1 and -> 0 }T >nd< Undefined word
T{ 1 0 and -> 0 }T >nd< Undefined word
T{ 1 1 and -> 1 }T >nd< Undefined word
  ok
T{ 0 invert 1 and -> 1 }T >invert< Undefined word
T{ 1 invert 1 and -> 0 }T >invert< Undefined word
  ok
0 constant 0s >onstant< Undefined word
0 invert constant 1s >invert< Undefined word
  ok
T{ 0s invert -> 1s }T >s< Undefined word
T{ 1s invert -> 0s }T >s< Undefined word
  ok
T{ 0s 0s and -> 0s }T >s< Undefined word
T{ 0s 1s and -> 0s }T >s< Undefined word
T{ 1s 0s and -> 0s }T >s< Undefined word
T{ 1s 1s and -> 1s }T >s< Undefined word
  ok
T{ 0s 0s or -> 0s }T >s< Undefined word
T{ 0s 1s or -> 1s }T >s< Undefined word
T{ 1s 0s or -> 1s }T >s< Undefined word
T{ 1s 1s or -> 1s }T >s< Undefined word
  ok
T{ 0s 0s xor -> 0s }T >s< Undefined word
T{ 0s 1s xor -> 1s }T >s< Undefined word
T{ 1s 0s xor -> 1s }T >s< Undefined word
T{ 1s 1s xor -> 0s }T >s< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing 2* 2/ lshift rshift  ok
  ok
( we trust 1s, invert, and bitsset?; we will confirm rshift later ) >(< Undefined word
1s 1 rshift invert constant msb >s< Undefined word
T{ msb bitsset? -> 0 0 }T >msb< Undefined word
  ok
T{ 0s 2* -> 0s }T >s< Undefined word
T{ 1 2* -> 2 }T >*< Undefined word
T{ 4000 2* -> 8000 }T >*< Undefined word
T{ 1s 2* 1 xor -> 1s }T >s< Undefined word
T{ msb 2* -> 0s }T >msb< Undefined word
  ok
T{ 0s 2/ -> 0s }T >s< Undefined word
T{ 1 2/ -> 0 }T >/< Undefined word
T{ 4000 2/ -> 2000 }T >/< Undefined word
T{ 1s 2/ -> 1s }T \ msb propogated >s< Undefined word
T{ 1s 1 xor 2/ -> 1s }T >s< Undefined word
T{ msb 2/ msb and -> msb }T >msb< Undefined word
  ok
T{ 1 0 lshift -> 1 }T >lshift< Undefined word
T{ 1 1 lshift -> 2 }T >lshift< Undefined word
T{ 1 2 lshift -> 4 }T >lshift< Undefined word
T{ 1 f lshift -> 8000 }T \ biggest guaranteed shift >lshift< Undefined word
T{ 1s 1 lshift 1 xor -> 1s }T >s< Undefined word
T{ msb 1 lshift -> 0 }T >msb< Undefined word
  ok
T{ 1 0 rshift -> 1 }T >rshift< Undefined word
T{ 1 1 rshift -> 0 }T >rshift< Undefined word
T{ 2 1 rshift -> 1 }T >rshift< Undefined word
T{ 4 2 rshift -> 1 }T >rshift< Undefined word
T{ 8000 f rshift -> 1 }T \ biggest >rshift< Undefined word
T{ msb 1 rshift msb and -> 0 }T  \ rshift zero fills msbs >msb< Undefined word
T{ msb 1 rshift 2* -> msb }T >msb< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing comparisons: true false 0= 0<> = <> 0< 0> < > u< min max within  ok
0 invert  constant max-uint >invert< Undefined word
0 invert 1 rshift  constant max-int >invert< Undefined word
0 invert 1 rshift invert  constant min-int >invert< Undefined word
0 invert 1 rshift  constant mid-uint >invert< Undefined word
0 invert 1 rshift invert  constant mid-uint+1 >invert< Undefined word
  ok
0s constant <false> >s< Undefined word
1s constant <true> >s< Undefined word
  ok
T{ false -> 0 }T >lse< Undefined word
T{ false -> <false> }T >lse< Undefined word
  ok
T{ true -> <true> }T >true< Undefined word
T{ true -> 0 invert }T >true< Undefined word
  ok
T{ 0 0= -> <true> }T >=< Undefined word
T{ 1 0= -> <false> }T >=< Undefined word
T{ 2 0= -> <false> }T >=< Undefined word
T{ -1 0= -> <false> }T >=< Undefined word
T{ max-uint 0= -> <false> }T >max-uint< Undefined word
T{ min-int 0= -> <false> }T >min-int< Undefined word
T{ max-int 0= -> <false> }T >max-int< Undefined word
  ok
T{ 0 0<> -> <false> }T ><>< Undefined word
T{ 1 0<> -> <true> }T ><>< Undefined word
T{ 2 0<> -> <true> }T ><>< Undefined word
T{ -1 0<> -> <true> }T ><>< Undefined word
T{ max-uint 0<> -> <true> }T >max-uint< Undefined word
T{ min-int 0<> -> <true> }T >min-int< Undefined word
T{ max-int 0<> -> <true> }T >max-int< Undefined word
  ok
T{ 0 0 = -> <true> }T >=< Undefined word
T{ 1 1 = -> <true> }T >=< Undefined word
T{ -1 -1 = -> <true> }T >=< Undefined word
T{ 1 0 = -> <false> }T >=< Undefined word
T{ -1 0 = -> <false> }T >=< Undefined word
T{ 0 1 = -> <false> }T >=< Undefined word
T{ 0 -1 = -> <false> }T >=< Undefined word
  ok
T{ 0 0 <> -> <false> }T ><>< Undefined word
T{ 1 1 <> -> <false> }T ><>< Undefined word
T{ -1 -1 <> -> <false> }T ><>< Undefined word
T{ 1 0 <> -> <true> }T ><>< Undefined word
T{ -1 0 <> -> <true> }T ><>< Undefined word
T{ 0 1 <> -> <true> }T ><>< Undefined word
T{ 0 -1 <> -> <true> }T ><>< Undefined word
  ok
T{ 0 0< -> <false> }T ><< Undefined word
T{ -1 0< -> <true> }T ><< Undefined word
T{ min-int 0< -> <true> }T >min-int< Undefined word
T{ 1 0< -> <false> }T ><< Undefined word
T{ max-int 0< -> <false> }T >max-int< Undefined word
  ok
T{ 0 0> -> <false> }T >>< Undefined word
T{ -1 0> -> <false> }T >>< Undefined word
T{ min-int 0> -> <false> }T >min-int< Undefined word
T{ 1 0> -> <true> }T >>< Undefined word
T{ max-int 0> -> <true> }T >max-int< Undefined word
  ok
T{ 0 1 < -> <true> }T ><< Undefined word
T{ 1 2 < -> <true> }T ><< Undefined word
T{ -1 0 < -> <true> }T ><< Undefined word
T{ -1 1 < -> <true> }T ><< Undefined word
T{ min-int 0 < -> <true> }T >min-int< Undefined word
T{ min-int max-int < -> <true> }T >min-int< Undefined word
T{ 0 max-int < -> <true> }T >max-int< Undefined word
T{ 0 0 < -> <false> }T ><< Undefined word
T{ 1 1 < -> <false> }T ><< Undefined word
T{ 1 0 < -> <false> }T ><< Undefined word
T{ 2 1 < -> <false> }T ><< Undefined word
T{ 0 -1 < -> <false> }T ><< Undefined word
T{ 1 -1 < -> <false> }T ><< Undefined word
T{ 0 min-int < -> <false> }T >min-int< Undefined word
T{ max-int min-int < -> <false> }T >max-int< Undefined word
T{ max-int 0 < -> <false> }T >max-int< Undefined word
  ok
T{ 0 1 > -> <false> }T >>< Undefined word
T{ 1 2 > -> <false> }T >>< Undefined word
T{ -1 0 > -> <false> }T >>< Undefined word
T{ -1 1 > -> <false> }T >>< Undefined word
T{ min-int 0 > -> <false> }T >min-int< Undefined word
T{ min-int max-int > -> <false> }T >min-int< Undefined word
T{ 0 max-int > -> <false> }T >max-int< Undefined word
T{ 0 0 > -> <false> }T >>< Undefined word
T{ 1 1 > -> <false> }T >>< Undefined word
T{ 1 0 > -> <true> }T >>< Undefined word
T{ 2 1 > -> <true> }T >>< Undefined word
T{ 0 -1 > -> <true> }T >>< Undefined word
T{ 1 -1 > -> <true> }T >>< Undefined word
T{ 0 min-int > -> <true> }T >min-int< Undefined word
T{ max-int min-int > -> <true> }T >max-int< Undefined word
T{ max-int 0 > -> <true> }T >max-int< Undefined word
  ok
T{ 0 1 u< -> <true> }T >u<< Undefined word
T{ 1 2 u< -> <true> }T >u<< Undefined word
T{ 0 mid-uint u< -> <true> }T >mid-uint< Undefined word
T{ 0 max-uint u< -> <true> }T >max-uint< Undefined word
T{ mid-uint max-uint u< -> <true> }T >mid-uint< Undefined word
T{ 0 0 u< -> <false> }T >u<< Undefined word
T{ 1 1 u< -> <false> }T >u<< Undefined word
T{ 1 0 u< -> <false> }T >u<< Undefined word
T{ 2 1 u< -> <false> }T >u<< Undefined word
T{ mid-uint 0 u< -> <false> }T >mid-uint< Undefined word
T{ max-uint 0 u< -> <false> }T >max-uint< Undefined word
T{ max-uint mid-uint u< -> <false> }T >max-uint< Undefined word
  ok
T{ 1 0 u> -> <true> }T >u>< Undefined word
T{ 2 1 u> -> <true> }T >u>< Undefined word
T{ mid-uint 0 u> -> <true> }T >mid-uint< Undefined word
T{ max-uint 0 u> -> <true> }T >max-uint< Undefined word
T{ max-uint mid-uint u> -> <true> }T >max-uint< Undefined word
T{ 0 0 u> -> <false> }T >u>< Undefined word
T{ 1 1 u> -> <false> }T >u>< Undefined word
T{ 0 1 u> -> <false> }T >u>< Undefined word
T{ 1 2 u> -> <false> }T >u>< Undefined word
T{ 0 mid-uint u> -> <false> }T >mid-uint< Undefined word
T{ 0 max-uint u> -> <false> }T >max-uint< Undefined word
T{ mid-uint max-uint u> -> <false> }T >mid-uint< Undefined word
  ok
T{ 0 1 min -> 0 }T >min< Undefined word
T{ 1 2 min -> 1 }T >min< Undefined word
T{ -1 0 min -> -1 }T >min< Undefined word
T{ -1 1 min -> -1 }T >min< Undefined word
T{ min-int 0 min -> min-int }T >min-int< Undefined word
T{ min-int max-int min -> min-int }T >min-int< Undefined word
T{ 0 max-int min -> 0 }T >max-int< Undefined word
T{ 0 0 min -> 0 }T >min< Undefined word
T{ 1 1 min -> 1 }T >min< Undefined word
T{ 1 0 min -> 0 }T >min< Undefined word
T{ 2 1 min -> 1 }T >min< Undefined word
T{ 0 -1 min -> -1 }T >min< Undefined word
T{ 1 -1 min -> -1 }T >min< Undefined word
T{ 0 min-int min -> min-int }T >min-int< Undefined word
T{ max-int min-int min -> min-int }T >max-int< Undefined word
T{ max-int 0 min -> 0 }T >max-int< Undefined word
  ok
T{ 0 1 max -> 1 }T >max< Undefined word
T{ 1 2 max -> 2 }T >max< Undefined word
T{ -1 0 max -> 0 }T >max< Undefined word
T{ -1 1 max -> 1 }T >max< Undefined word
T{ min-int 0 max -> 0 }T >min-int< Undefined word
T{ min-int max-int max -> max-int }T >min-int< Undefined word
T{ 0 max-int max -> max-int }T >max-int< Undefined word
T{ 0 0 max -> 0 }T >max< Undefined word
T{ 1 1 max -> 1 }T >max< Undefined word
T{ 1 0 max -> 1 }T >max< Undefined word
T{ 2 1 max -> 2 }T >max< Undefined word
T{ 0 -1 max -> 0 }T >max< Undefined word
T{ 1 -1 max -> 1 }T >max< Undefined word
T{ 0 min-int max -> 0 }T >min-int< Undefined word
T{ max-int min-int max -> max-int }T >max-int< Undefined word
T{ max-int 0 max -> max-int }T >max-int< Undefined word
  ok
T{ 1 2 4 within -> <false> }T >within< Undefined word
T{ 2 2 4 within -> <true> }T >within< Undefined word
T{ 3 2 4 within -> <true> }T >within< Undefined word
T{ 4 2 4 within -> <false> }T >within< Undefined word
T{ 5 2 4 within -> <false> }T >within< Undefined word
  ok
T{ 0 2 4 within -> <false> }T >within< Undefined word
T{ 1 0 4 within -> <true> }T >within< Undefined word
T{ 0 0 4 within -> <true> }T >within< Undefined word
T{ 4 0 4 within -> <false> }T >within< Undefined word
T{ 5 0 4 within -> <false> }T >within< Undefined word
  ok
T{ -1 -3 -1 within -> <false> }T >within< Undefined word
T{ -2 -3 -1 within -> <true> }T >within< Undefined word
T{ -3 -3 -1 within -> <true> }T >within< Undefined word
T{ -4 -3 -1 within -> <false> }T >within< Undefined word
  ok
T{ -2 -2 0 within -> <true> }T >within< Undefined word
T{ -1 -2 0 within -> <true> }T >within< Undefined word
T{ 0 -2 0 within -> <false> }T >within< Undefined word
T{ 1 -2 0 within -> <false> }T >within< Undefined word
  ok
T{ 0 min-int max-int within -> <true> }T >min-int< Undefined word
T{ 1 min-int max-int within -> <true> }T >min-int< Undefined word
T{ -1 min-int max-int within -> <true> }T >min-int< Undefined word
T{ min-int min-int max-int within -> <true> }T >min-int< Undefined word
T{ max-int min-int max-int within -> <false> }T >max-int< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing stack ops: 2drop 2dup 2over 2swap ?dup depth drop dup nip over rot -rot   ok
testing stack ops: swap tuck pick  ok
  ok
T{ 1 2 2drop -> }T >rop< Undefined word
T{ 1 2 2dup -> 1 2 1 2 }T >up< Undefined word
T{ 1 2 3 4 2over -> 1 2 3 4 1 2 }T >over< Undefined word
T{ 1 2 3 4 2swap -> 3 4 1 2 }T >swap< Undefined word
T{ 0 ?dup -> 0 }T >?dup< Undefined word
T{ 1 ?dup -> 1 1 }T >?dup< Undefined word
T{ -1 ?dup -> -1 -1 }T >?dup< Undefined word
T{ depth -> 0 }T >pth< Undefined word
T{ 0 depth -> 0 1 }T >pth< Undefined word
T{ 0 1 depth -> 0 1 2 }T >pth< Undefined word
T{ 0 drop -> }T >rop< Undefined word
T{ 1 2 drop -> 1 }T >rop< Undefined word
T{ 1 dup -> 1 1 }T >up< Undefined word
T{ 1 2 nip -> 2 }T >nip< Undefined word
T{ 1 2 over -> 1 2 1 }T >over< Undefined word
T{ 1 2 3 rot -> 2 3 1 }T >rot< Undefined word
T{ 1 2 3 -rot -> 3 1 2 }T >rot< Undefined word
T{ 1 2 swap -> 2 1 }T >swap< Undefined word
  ok
\ There is no formal ANS test for TUCK, this added 01. July 2018 >\< Undefined word
T{ 2 1 tuck -> 1 2 1 }T >tuck< Undefined word
  ok
\ There is no formal ANS test for PICK, this added 01. July 2018 >\< Undefined word
\ Note that ANS's PICK is different from FIG Forth PICK >\< Undefined word
T{ 1      0 pick -> 1 1 }T    \ Defined by standard: 0 PICK is same as DUP >pick< Undefined word
T{ 1 2    1 pick -> 1 2 1 }T  \ Defined by standard: 1 PICK is same as OVER >pick< Undefined word
T{ 1 2 3  2 pick -> 1 2 3 1 }T >pick< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing >r r> r@ 2>r 2r> 2r@  ok
  ok
T{ : gr1 >r r> ; -> }T >:< Undefined word
T{ : gr2 >r r@ r> drop ; -> }T >:< Undefined word
T{ 123 gr1 -> 123 }T >gr1< Undefined word
T{ 123 gr2 -> 123 }T >gr2< Undefined word
T{ 1s gr1 -> 1s }T \ return stack holds cells >s< Undefined word
  ok
\ There are no official ANS tests for 2>R, 2R>, or 2R@, added 22. June 2018 >\< Undefined word
T{ : gr3 2>r 2r> ; -> }T >:< Undefined word
T{ : gr4 2>r 2r@ 2r> 2drop ; -> }T >:< Undefined word
T{ : gr5 2>r r> r> ; }T \ must reverse sequence, as 2r> is not r> r>  >:< Undefined word
T{ 123. gr3 -> 123. }T >gr3< Undefined word
T{ 123. gr4 -> 123. }T >gr4< Undefined word
T{ 123. gr5 -> 0 123 }T >gr5< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing add/subtract: + - 1+ 1- abs negate   ok
  ok
T{ 0 5 + -> 5 }T >+< Undefined word
T{ 5 0 + -> 5 }T >+< Undefined word
T{ 0 -5 + -> -5 }T >+< Undefined word
T{ -5 0 + -> -5 }T >+< Undefined word
T{ 1 2 + -> 3 }T >+< Undefined word
T{ 1 -2 + -> -1 }T >+< Undefined word
T{ -1 2 + -> 1 }T >+< Undefined word
T{ -1 -2 + -> -3 }T >+< Undefined word
T{ -1 1 + -> 0 }T >+< Undefined word
T{ mid-uint 1 + -> mid-uint+1 }T >mid-uint< Undefined word
  ok
T{ 0 5 - -> -5 }T WRONG NUMBER OF RESULTS: T{ 0 5 - -> -5 }T ACTUAL RESULT: { 0 0 5 0 0 0 } ok
T{ 5 0 - -> 5 }T WRONG NUMBER OF RESULTS: T{ 5 0 - -> 5 }T ACTUAL RESULT: { 5 0 0 0 0 0 } ok
T{ 0 -5 - -> 5 }T WRONG NUMBER OF RESULTS: T{ 0 -5 - -> 5 }T ACTUAL RESULT: { 0 0 -5 -1 0 0 } ok
T{ -5 0 - -> -5 }T WRONG NUMBER OF RESULTS: T{ -5 0 - -> -5 }T ACTUAL RESULT: { -5 -1 0 0 0 0 } ok
T{ 1 2 - -> -1 }T WRONG NUMBER OF RESULTS: T{ 1 2 - -> -1 }T ACTUAL RESULT: { 1 0 2 0 0 0 } ok
T{ 1 -2 - -> 3 }T WRONG NUMBER OF RESULTS: T{ 1 -2 - -> 3 }T ACTUAL RESULT: { 1 0 -2 -1 0 0 } ok
T{ -1 2 - -> -3 }T WRONG NUMBER OF RESULTS: T{ -1 2 - -> -3 }T ACTUAL RESULT: { -1 -1 2 0 0 0 } ok
T{ -1 -2 - -> 1 }T WRONG NUMBER OF RESULTS: T{ -1 -2 - -> 1 }T ACTUAL RESULT: { -1 -1 -2 -1 0 0 } ok
T{ 0 1 - -> -1 }T WRONG NUMBER OF RESULTS: T{ 0 1 - -> -1 }T ACTUAL RESULT: { 0 0 1 0 0 0 } ok
T{ mid-uint+1 1 - -> mid-uint }T >mid-uint+1< Undefined word
  ok
T{ 0 1+ -> 1 }T >+< Undefined word
T{ -1 1+ -> 0 }T >+< Undefined word
T{ 1 1+ -> 2 }T >+< Undefined word
T{ mid-uint 1+ -> mid-uint+1 }T >mid-uint< Undefined word
  ok
T{ 2 1- -> 1 }T >-< Undefined word
T{ 1 1- -> 0 }T >-< Undefined word
T{ 0 1- -> -1 }T >-< Undefined word
T{ mid-uint+1 1- -> mid-uint }T >mid-uint+1< Undefined word
  ok
T{ 0 negate -> 0 }T >negate< Undefined word
T{ 1 negate -> -1 }T >negate< Undefined word
T{ -1 negate -> 1 }T >negate< Undefined word
T{ 2 negate -> -2 }T >negate< Undefined word
T{ -2 negate -> 2 }T >negate< Undefined word
  ok
T{ 0 abs -> 0 }T >s< Undefined word
T{ 1 abs -> 1 }T >s< Undefined word
T{ -1 abs -> 1 }T >s< Undefined word
T{ min-int abs -> mid-uint+1 }T >min-int< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing multiply: s>d * m* um*  ok
  ok
T{ 0 s>d -> 0 0 }T >s>d< Undefined word
T{ 1 s>d -> 1 0 }T >s>d< Undefined word
T{ 2 s>d -> 2 0 }T >s>d< Undefined word
T{ -1 s>d -> -1 -1 }T >s>d< Undefined word
T{ -2 s>d -> -2 -1 }T >s>d< Undefined word
T{ min-int s>d -> min-int -1 }T >min-int< Undefined word
T{ max-int s>d -> max-int 0 }T >max-int< Undefined word
  ok
T{ 0 0 m* -> 0 s>d }T >m*< Undefined word
T{ 0 1 m* -> 0 s>d }T >m*< Undefined word
T{ 1 0 m* -> 0 s>d }T >m*< Undefined word
T{ 1 2 m* -> 2 s>d }T >m*< Undefined word
T{ 2 1 m* -> 2 s>d }T >m*< Undefined word
T{ 3 3 m* -> 9 s>d }T >m*< Undefined word
T{ -3 3 m* -> -9 s>d }T >m*< Undefined word
T{ 3 -3 m* -> -9 s>d }T >m*< Undefined word
T{ -3 -3 m* -> 9 s>d }T >m*< Undefined word
T{ 0 min-int m* -> 0 s>d }T >min-int< Undefined word
T{ 1 min-int m* -> min-int s>d }T >min-int< Undefined word
T{ 2 min-int m* -> 0 1s }T >min-int< Undefined word
T{ 0 max-int m* -> 0 s>d }T >max-int< Undefined word
T{ 1 max-int m* -> max-int s>d }T >max-int< Undefined word
T{ 2 max-int m* -> max-int 1 lshift 0 }T >max-int< Undefined word
T{ min-int min-int m* -> 0 msb 1 rshift }T >min-int< Undefined word
T{ max-int min-int m* -> msb msb 2/ }T >max-int< Undefined word
T{ max-int max-int m* -> 1 msb 2/ invert }T >max-int< Undefined word
  ok
T{ 0 0 * -> 0 }T \ test identities >*< Undefined word
T{ 0 1 * -> 0 }T >*< Undefined word
T{ 1 0 * -> 0 }T >*< Undefined word
T{ 1 2 * -> 2 }T >*< Undefined word
T{ 2 1 * -> 2 }T >*< Undefined word
T{ 3 3 * -> 9 }T >*< Undefined word
T{ -3 3 * -> -9 }T >*< Undefined word
T{ 3 -3 * -> -9 }T >*< Undefined word
T{ -3 -3 * -> 9 }T >*< Undefined word
  ok
T{ mid-uint+1 1 rshift 2 * -> mid-uint+1 }T >mid-uint+1< Undefined word
T{ mid-uint+1 2 rshift 4 * -> mid-uint+1 }T >mid-uint+1< Undefined word
T{ mid-uint+1 1 rshift mid-uint+1 or 2 * -> mid-uint+1 }T >mid-uint+1< Undefined word
  ok
T{ 0 0 um* -> 0 0 }T >um*< Undefined word
T{ 0 1 um* -> 0 0 }T >um*< Undefined word
T{ 1 0 um* -> 0 0 }T >um*< Undefined word
T{ 1 2 um* -> 2 0 }T >um*< Undefined word
T{ 2 1 um* -> 2 0 }T >um*< Undefined word
T{ 3 3 um* -> 9 0 }T >um*< Undefined word
  ok
T{ mid-uint+1 1 rshift 2 um* -> mid-uint+1 0 }T >mid-uint+1< Undefined word
T{ mid-uint+1 2 um* -> 0 1 }T >mid-uint+1< Undefined word
T{ mid-uint+1 4 um* -> 0 2 }T >mid-uint+1< Undefined word
T{ 1s 2 um* -> 1s 1 lshift 1 }T >s< Undefined word
T{ max-uint max-uint um* -> 1 1 invert }T >max-uint< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing divide: fm/mod sm/rem um/mod */ */mod / /mod mod  ok
  ok
T{ 0 s>d 1 fm/mod -> 0 0 }T >s>d< Undefined word
T{ 1 s>d 1 fm/mod -> 0 1 }T >s>d< Undefined word
T{ 2 s>d 1 fm/mod -> 0 2 }T >s>d< Undefined word
T{ -1 s>d 1 fm/mod -> 0 -1 }T >s>d< Undefined word
T{ -2 s>d 1 fm/mod -> 0 -2 }T >s>d< Undefined word
T{ 0 s>d -1 fm/mod -> 0 0 }T >s>d< Undefined word
T{ 1 s>d -1 fm/mod -> 0 -1 }T >s>d< Undefined word
T{ 2 s>d -1 fm/mod -> 0 -2 }T >s>d< Undefined word
T{ -1 s>d -1 fm/mod -> 0 1 }T >s>d< Undefined word
T{ -2 s>d -1 fm/mod -> 0 2 }T >s>d< Undefined word
T{ 2 s>d 2 fm/mod -> 0 1 }T >s>d< Undefined word
T{ -1 s>d -1 fm/mod -> 0 1 }T >s>d< Undefined word
T{ -2 s>d -2 fm/mod -> 0 1 }T >s>d< Undefined word
T{  7 s>d  3 fm/mod -> 1 2 }T >s>d< Undefined word
T{  7 s>d -3 fm/mod -> -2 -3 }T >s>d< Undefined word
T{ -7 s>d  3 fm/mod -> 2 -3 }T >s>d< Undefined word
T{ -7 s>d -3 fm/mod -> -1 2 }T >s>d< Undefined word
T{ max-int s>d 1 fm/mod -> 0 max-int }T >max-int< Undefined word
T{ min-int s>d 1 fm/mod -> 0 min-int }T >min-int< Undefined word
T{ max-int s>d max-int fm/mod -> 0 1 }T >max-int< Undefined word
T{ min-int s>d min-int fm/mod -> 0 1 }T >min-int< Undefined word
T{ 1s 1 4 fm/mod -> 3 max-int }T >s< Undefined word
T{ 1 min-int m* 1 fm/mod -> 0 min-int }T >min-int< Undefined word
T{ 1 min-int m* min-int fm/mod -> 0 1 }T >min-int< Undefined word
T{ 2 min-int m* 2 fm/mod -> 0 min-int }T >min-int< Undefined word
T{ 2 min-int m* min-int fm/mod -> 0 2 }T >min-int< Undefined word
T{ 1 max-int m* 1 fm/mod -> 0 max-int }T >max-int< Undefined word
T{ 1 max-int m* max-int fm/mod -> 0 1 }T >max-int< Undefined word
T{ 2 max-int m* 2 fm/mod -> 0 max-int }T >max-int< Undefined word
T{ 2 max-int m* max-int fm/mod -> 0 2 }T >max-int< Undefined word
T{ min-int min-int m* min-int fm/mod -> 0 min-int }T >min-int< Undefined word
T{ min-int max-int m* min-int fm/mod -> 0 max-int }T >min-int< Undefined word
T{ min-int max-int m* max-int fm/mod -> 0 min-int }T >min-int< Undefined word
T{ max-int max-int m* max-int fm/mod -> 0 max-int }T >max-int< Undefined word
  ok
T{ 0 s>d 1 sm/rem -> 0 0 }T >s>d< Undefined word
T{ 1 s>d 1 sm/rem -> 0 1 }T >s>d< Undefined word
T{ 2 s>d 1 sm/rem -> 0 2 }T >s>d< Undefined word
T{ -1 s>d 1 sm/rem -> 0 -1 }T >s>d< Undefined word
T{ -2 s>d 1 sm/rem -> 0 -2 }T >s>d< Undefined word
T{ 0 s>d -1 sm/rem -> 0 0 }T >s>d< Undefined word
T{ 1 s>d -1 sm/rem -> 0 -1 }T >s>d< Undefined word
T{ 2 s>d -1 sm/rem -> 0 -2 }T >s>d< Undefined word
T{ -1 s>d -1 sm/rem -> 0 1 }T >s>d< Undefined word
T{ -2 s>d -1 sm/rem -> 0 2 }T >s>d< Undefined word
T{ 2 s>d 2 sm/rem -> 0 1 }T >s>d< Undefined word
T{ -1 s>d -1 sm/rem -> 0 1 }T >s>d< Undefined word
T{ -2 s>d -2 sm/rem -> 0 1 }T >s>d< Undefined word
T{  7 s>d  3 sm/rem -> 1 2 }T >s>d< Undefined word
T{  7 s>d -3 sm/rem -> 1 -2 }T >s>d< Undefined word
T{ -7 s>d  3 sm/rem -> -1 -2 }T >s>d< Undefined word
T{ -7 s>d -3 sm/rem -> -1 2 }T >s>d< Undefined word
T{ max-int s>d 1 sm/rem -> 0 max-int }T >max-int< Undefined word
T{ min-int s>d 1 sm/rem -> 0 min-int }T >min-int< Undefined word
T{ max-int s>d max-int sm/rem -> 0 1 }T >max-int< Undefined word
T{ min-int s>d min-int sm/rem -> 0 1 }T >min-int< Undefined word
T{ 1s 1 4 sm/rem -> 3 max-int }T >s< Undefined word
T{ 2 min-int m* 2 sm/rem -> 0 min-int }T >min-int< Undefined word
T{ 2 min-int m* min-int sm/rem -> 0 2 }T >min-int< Undefined word
T{ 2 max-int m* 2 sm/rem -> 0 max-int }T >max-int< Undefined word
T{ 2 max-int m* max-int sm/rem -> 0 2 }T >max-int< Undefined word
T{ min-int min-int m* min-int sm/rem -> 0 min-int }T >min-int< Undefined word
T{ min-int max-int m* min-int sm/rem -> 0 max-int }T >min-int< Undefined word
T{ min-int max-int m* max-int sm/rem -> 0 min-int }T >min-int< Undefined word
T{ max-int max-int m* max-int sm/rem -> 0 max-int }T >max-int< Undefined word
  ok
T{ 0 0 1 um/mod -> 0 0 }T >um/mod< Undefined word
T{ 1 0 1 um/mod -> 0 1 }T >um/mod< Undefined word
T{ 1 0 2 um/mod -> 1 0 }T >um/mod< Undefined word
T{ 3 0 2 um/mod -> 1 1 }T >um/mod< Undefined word
T{ max-uint 2 um* 2 um/mod -> 0 max-uint }T >max-uint< Undefined word
T{ max-uint 2 um* max-uint um/mod -> 0 2 }T >max-uint< Undefined word
T{ max-uint max-uint um* max-uint um/mod -> 0 max-uint }T >max-uint< Undefined word
  ok
: iffloored >:< Undefined word
   [ -3 2 / -2 = invert ] literal if postpone \ then ; >[< Undefined word
: ifsym >:< Undefined word
   [ -3 2 / -1 = invert ] literal if postpone \ then ; >[< Undefined word
  ok
\ the system might do either floored or symmetric division. >\< Undefined word
\ since we have already tested m*, fm/mod, and sm/rem we can use them in test. >\< Undefined word
iffloored : t/mod  >r s>d r> fm/mod ; >iffloored< Undefined word
iffloored : t/     t/mod swap drop ; >iffloored< Undefined word
iffloored : tmod   t/mod drop ; >iffloored< Undefined word
iffloored : t*/mod >r m* r> fm/mod ; >iffloored< Undefined word
iffloored : t*/    t*/mod swap drop ; >iffloored< Undefined word
ifsym     : t/mod  >r s>d r> sm/rem ; >ifsym< Undefined word
ifsym     : t/     t/mod swap drop ; >ifsym< Undefined word
ifsym     : tmod   t/mod drop ; >ifsym< Undefined word
ifsym     : t*/mod >r m* r> sm/rem ; >ifsym< Undefined word
ifsym     : t*/    t*/mod swap drop ; >ifsym< Undefined word
  ok
T{ 0 1 /mod -> 0 1 t/mod }T >/mod< Undefined word
T{ 1 1 /mod -> 1 1 t/mod }T >/mod< Undefined word
T{ 2 1 /mod -> 2 1 t/mod }T >/mod< Undefined word
T{ -1 1 /mod -> -1 1 t/mod }T >/mod< Undefined word
T{ -2 1 /mod -> -2 1 t/mod }T >/mod< Undefined word
T{ 0 -1 /mod -> 0 -1 t/mod }T >/mod< Undefined word
T{ 1 -1 /mod -> 1 -1 t/mod }T >/mod< Undefined word
T{ 2 -1 /mod -> 2 -1 t/mod }T >/mod< Undefined word
T{ -1 -1 /mod -> -1 -1 t/mod }T >/mod< Undefined word
T{ -2 -1 /mod -> -2 -1 t/mod }T >/mod< Undefined word
T{ 2 2 /mod -> 2 2 t/mod }T >/mod< Undefined word
T{ -1 -1 /mod -> -1 -1 t/mod }T >/mod< Undefined word
T{ -2 -2 /mod -> -2 -2 t/mod }T >/mod< Undefined word
T{ 7 3 /mod -> 7 3 t/mod }T >/mod< Undefined word
T{ 7 -3 /mod -> 7 -3 t/mod }T >/mod< Undefined word
T{ -7 3 /mod -> -7 3 t/mod }T >/mod< Undefined word
T{ -7 -3 /mod -> -7 -3 t/mod }T >/mod< Undefined word
T{ max-int 1 /mod -> max-int 1 t/mod }T >max-int< Undefined word
T{ min-int 1 /mod -> min-int 1 t/mod }T >min-int< Undefined word
T{ max-int max-int /mod -> max-int max-int t/mod }T >max-int< Undefined word
T{ min-int min-int /mod -> min-int min-int t/mod }T >min-int< Undefined word
  ok
T{ 0 1 / -> 0 1 t/ }T >/< Undefined word
T{ 1 1 / -> 1 1 t/ }T >/< Undefined word
T{ 2 1 / -> 2 1 t/ }T >/< Undefined word
T{ -1 1 / -> -1 1 t/ }T >/< Undefined word
T{ -2 1 / -> -2 1 t/ }T >/< Undefined word
T{ 0 -1 / -> 0 -1 t/ }T >/< Undefined word
T{ 1 -1 / -> 1 -1 t/ }T >/< Undefined word
T{ 2 -1 / -> 2 -1 t/ }T >/< Undefined word
T{ -1 -1 / -> -1 -1 t/ }T >/< Undefined word
T{ -2 -1 / -> -2 -1 t/ }T >/< Undefined word
T{ 2 2 / -> 2 2 t/ }T >/< Undefined word
T{ -1 -1 / -> -1 -1 t/ }T >/< Undefined word
T{ -2 -2 / -> -2 -2 t/ }T >/< Undefined word
T{ 7 3 / -> 7 3 t/ }T >/< Undefined word
T{ 7 -3 / -> 7 -3 t/ }T >/< Undefined word
T{ -7 3 / -> -7 3 t/ }T >/< Undefined word
T{ -7 -3 / -> -7 -3 t/ }T >/< Undefined word
T{ max-int 1 / -> max-int 1 t/ }T >max-int< Undefined word
T{ min-int 1 / -> min-int 1 t/ }T >min-int< Undefined word
T{ max-int max-int / -> max-int max-int t/ }T >max-int< Undefined word
T{ min-int min-int / -> min-int min-int t/ }T >min-int< Undefined word
  ok
T{ 0 1 mod -> 0 1 tmod }T >mod< Undefined word
T{ 1 1 mod -> 1 1 tmod }T >mod< Undefined word
T{ 2 1 mod -> 2 1 tmod }T >mod< Undefined word
T{ -1 1 mod -> -1 1 tmod }T >mod< Undefined word
T{ -2 1 mod -> -2 1 tmod }T >mod< Undefined word
T{ 0 -1 mod -> 0 -1 tmod }T >mod< Undefined word
T{ 1 -1 mod -> 1 -1 tmod }T >mod< Undefined word
T{ 2 -1 mod -> 2 -1 tmod }T >mod< Undefined word
T{ -1 -1 mod -> -1 -1 tmod }T >mod< Undefined word
T{ -2 -1 mod -> -2 -1 tmod }T >mod< Undefined word
T{ 2 2 mod -> 2 2 tmod }T >mod< Undefined word
T{ -1 -1 mod -> -1 -1 tmod }T >mod< Undefined word
T{ -2 -2 mod -> -2 -2 tmod }T >mod< Undefined word
T{ 7 3 mod -> 7 3 tmod }T >mod< Undefined word
T{ 7 -3 mod -> 7 -3 tmod }T >mod< Undefined word
T{ -7 3 mod -> -7 3 tmod }T >mod< Undefined word
T{ -7 -3 mod -> -7 -3 tmod }T >mod< Undefined word
T{ max-int 1 mod -> max-int 1 tmod }T >max-int< Undefined word
T{ min-int 1 mod -> min-int 1 tmod }T >min-int< Undefined word
T{ max-int max-int mod -> max-int max-int tmod }T >max-int< Undefined word
T{ min-int min-int mod -> min-int min-int tmod }T >min-int< Undefined word
  ok
T{ 0 2 1 */ -> 0 2 1 t*/ }T >*/< Undefined word
T{ 1 2 1 */ -> 1 2 1 t*/ }T >*/< Undefined word
T{ 2 2 1 */ -> 2 2 1 t*/ }T >*/< Undefined word
T{ -1 2 1 */ -> -1 2 1 t*/ }T >*/< Undefined word
T{ -2 2 1 */ -> -2 2 1 t*/ }T >*/< Undefined word
T{ 0 2 -1 */ -> 0 2 -1 t*/ }T >*/< Undefined word
T{ 1 2 -1 */ -> 1 2 -1 t*/ }T >*/< Undefined word
T{ 2 2 -1 */ -> 2 2 -1 t*/ }T >*/< Undefined word
T{ -1 2 -1 */ -> -1 2 -1 t*/ }T >*/< Undefined word
T{ -2 2 -1 */ -> -2 2 -1 t*/ }T >*/< Undefined word
T{ 2 2 2 */ -> 2 2 2 t*/ }T >*/< Undefined word
T{ -1 2 -1 */ -> -1 2 -1 t*/ }T >*/< Undefined word
T{ -2 2 -2 */ -> -2 2 -2 t*/ }T >*/< Undefined word
T{ 7 2 3 */ -> 7 2 3 t*/ }T >*/< Undefined word
T{ 7 2 -3 */ -> 7 2 -3 t*/ }T >*/< Undefined word
T{ -7 2 3 */ -> -7 2 3 t*/ }T >*/< Undefined word
T{ -7 2 -3 */ -> -7 2 -3 t*/ }T >*/< Undefined word
T{ max-int 2 max-int */ -> max-int 2 max-int t*/ }T >max-int< Undefined word
T{ min-int 2 min-int */ -> min-int 2 min-int t*/ }T >min-int< Undefined word
  ok
T{ 0 2 1 */mod -> 0 2 1 t*/mod }T >*/mod< Undefined word
T{ 1 2 1 */mod -> 1 2 1 t*/mod }T >*/mod< Undefined word
T{ 2 2 1 */mod -> 2 2 1 t*/mod }T >*/mod< Undefined word
T{ -1 2 1 */mod -> -1 2 1 t*/mod }T >*/mod< Undefined word
T{ -2 2 1 */mod -> -2 2 1 t*/mod }T >*/mod< Undefined word
T{ 0 2 -1 */mod -> 0 2 -1 t*/mod }T >*/mod< Undefined word
T{ 1 2 -1 */mod -> 1 2 -1 t*/mod }T >*/mod< Undefined word
T{ 2 2 -1 */mod -> 2 2 -1 t*/mod }T >*/mod< Undefined word
T{ -1 2 -1 */mod -> -1 2 -1 t*/mod }T >*/mod< Undefined word
T{ -2 2 -1 */mod -> -2 2 -1 t*/mod }T >*/mod< Undefined word
T{ 2 2 2 */mod -> 2 2 2 t*/mod }T >*/mod< Undefined word
T{ -1 2 -1 */mod -> -1 2 -1 t*/mod }T >*/mod< Undefined word
T{ -2 2 -2 */mod -> -2 2 -2 t*/mod }T >*/mod< Undefined word
T{ 7 2 3 */mod -> 7 2 3 t*/mod }T >*/mod< Undefined word
T{ 7 2 -3 */mod -> 7 2 -3 t*/mod }T >*/mod< Undefined word
T{ -7 2 3 */mod -> -7 2 3 t*/mod }T >*/mod< Undefined word
T{ -7 2 -3 */mod -> -7 2 -3 t*/mod }T >*/mod< Undefined word
T{ max-int 2 max-int */mod -> max-int 2 max-int t*/mod }T >max-int< Undefined word
T{ min-int 2 min-int */mod -> min-int 2 min-int t*/mod }T >min-int< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing here , @ ! cell+ cells c, c@ c! char+ chars 2@ 2! align aligned +! allot pad unused compile,  ok
  ok
decimal >imal< Undefined word
here 1 allot >here< Undefined word
here >here< Undefined word
9 allot                     \ Growing by 9 and shrinking >llot< Undefined word
-10 allot                    \ by 10 should bring us back >llot< Undefined word
here                        \ to where we started. >here< Undefined word
constant 3rda >onstant< Undefined word
constant 2nda >onstant< Undefined word
constant 1sta >onstant< Undefined word
T{ 1sta 2nda u< -> <true> }T  \ here must grow with allot ... >sta< Undefined word
T{ 1sta 1+ -> 2nda }T         \ ... by one address unit >sta< Undefined word
T{ 3rda -> 1sta }T            \ and shrink back to the beginning. >rda< Undefined word
hex >hex< Undefined word
  ok
here 1 , >here< Undefined word
here 2 , >here< Undefined word
constant 2nd >onstant< Undefined word
constant 1st >onstant< Undefined word
T{ 1st 2nd u< -> <true> }T \ here must grow with allot ... >st< Undefined word
T{ 1st cell+ -> 2nd }T     \ ... by one cell (test for char+) >st< Undefined word
T{ 1st 1 cells + -> 2nd }T >st< Undefined word
T{ 1st @ 2nd @ -> 1 2 }T >st< Undefined word
T{ 5 1st ! -> }T >st< Undefined word
T{ 1st @ 2nd @ -> 5 2 }T >st< Undefined word
T{ 6 2nd ! -> }T >nd< Undefined word
T{ 1st @ 2nd @ -> 5 6 }T >st< Undefined word
T{ 1st 2@ -> 6 5 }T >st< Undefined word
T{ 2 1 1st 2! -> }T >st< Undefined word
T{ 1st 2@ -> 2 1 }T >st< Undefined word
T{ 1s 1st !  1st @ -> 1s }T  \ can store cell-wide value >s< Undefined word
  ok
here 1 c, >here< Undefined word
here 2 c, >here< Undefined word
constant 2ndc >onstant< Undefined word
constant 1stc >onstant< Undefined word
T{ 1stc 2ndc u< -> <true> }T \ here must grow with allot >stc< Undefined word
T{ 1stc char+ -> 2ndc }T     \ ... by one char >stc< Undefined word
T{ 1stc 1 chars + -> 2ndc }T >stc< Undefined word
T{ 1stc c@ 2ndc c@ -> 1 2 }T >stc< Undefined word
T{ 3 1stc c! -> }T >stc< Undefined word
T{ 1stc c@ 2ndc c@ -> 3 2 }T >stc< Undefined word
T{ 4 2ndc c! -> }T >ndc< Undefined word
T{ 1stc c@ 2ndc c@ -> 3 4 }T >stc< Undefined word
  ok
align 1 allot here align here 3 cells allot >lign< Undefined word
constant a-addr  constant ua-addr >onstant< Undefined word
T{ ua-addr aligned -> a-addr }T >ua-addr< Undefined word
T{ 1 a-addr c!  a-addr c@ -> 1 }T >-addr< Undefined word
T{ 1234 a-addr  !  a-addr  @ -> 1234 }T >-addr< Undefined word
T{ 123 456 a-addr 2!  a-addr 2@ -> 123 456 }T >-addr< Undefined word
T{ 2 a-addr char+ c!  a-addr char+ c@ -> 2 }T >-addr< Undefined word
T{ 3 a-addr cell+ c!  a-addr cell+ c@ -> 3 }T >-addr< Undefined word
T{ 1234 a-addr cell+ !  a-addr cell+ @ -> 1234 }T >-addr< Undefined word
T{ 123 456 a-addr cell+ 2!  a-addr cell+ 2@ -> 123 456 }T >-addr< Undefined word
  ok
: bits ( x -- u ) >:< Undefined word
   0 swap begin >swap< Undefined word
   dup while  >up< Undefined word
      dup msb and if >up< Undefined word
         >r 1+ r>  >>r< Undefined word
      then 2*  >then< Undefined word
   repeat  >repeat< Undefined word
   drop ; >rop< Undefined word
  ok
( characters >= 1 au, <= size of cell, >= 8 bits ) >(< Undefined word
T{ 1 chars 1 < -> <false> }T >hars< Undefined word
T{ 1 chars 1 cells > -> <false> }T >hars< Undefined word
( TODO how to find number of bits? ) >(< Undefined word
  ok
( cells >= 1 au, integral multiple of char size, >= 16 bits ) >(< Undefined word
T{ 1 cells 1 < -> <false> }T >lls< Undefined word
T{ 1 cells 1 chars mod -> 0 }T >lls< Undefined word
T{ 1s bits 10 < -> <false> }T >s< Undefined word
  ok
T{ 0 1st ! -> }T >st< Undefined word
T{ 1 1st +! -> }T >st< Undefined word
T{ 1st @ -> 1 }T >st< Undefined word
T{ -1 1st +! 1st @ -> 0 }T >st< Undefined word
  ok
( here + unused + buffer size must be total RAM, that is, $7FFF ) >(< Undefined word
T{ pad here - -> FF }T \ PAD must have offset of $FF >pad< Undefined word
T{ here unused + 3FF + -> 7FFF }T >here< Undefined word
  ok
:noname dup + ; constant dup+  >:noname< Undefined word
T{ : q dup+ compile, ; -> }T  >:< Undefined word
T{ : as [ q ] ; -> }T  >:< Undefined word
T{ 123 as -> 246 }T >s< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing char [char] [ ] bl s" s\"  ok
  ok
T{ bl -> 20 }T >l< Undefined word
T{ char X -> 58 }T >har< Undefined word
T{ char HELLO -> 48 }T >har< Undefined word
T{ : gc1 [char] X ; -> }T >:< Undefined word
T{ : gc2 [char] HELLO ; -> }T >:< Undefined word
T{ gc1 -> 58 }T >gc1< Undefined word
T{ gc2 -> 48 }T >gc2< Undefined word
T{ : gc3 [ gc1 ] literal ; -> }T >:< Undefined word
T{ gc3 -> 58 }T >gc3< Undefined word
T{ : gc4 s" XY" ; -> }T >:< Undefined word
T{ gc4 swap drop -> 2 }T >gc4< Undefined word
T{ gc4 drop dup c@ swap char+ c@ -> 58 59 }T >gc4< Undefined word
  ok
\ Test s\" >\< Undefined word
decimal >imal< Undefined word
create result >reate< Undefined word
 7 c, ( \a ) >,< Undefined word
 8 c, ( \b ) >,< Undefined word
27 c, ( \e ) >,< Undefined word
12 c, ( \f ) >,< Undefined word
10 c, ( \l ) >,< Undefined word
13 c, 10 c, ( \m ) >,< Undefined word
10 c, ( \n - Tali does just a linefeed for \n ) >,< Undefined word
34 c, ( \q ) >,< Undefined word
13 c, ( \r ) >,< Undefined word
 9 c, ( \t ) >,< Undefined word
11 c, ( \v ) >,< Undefined word
 0 c, ( \z ) >,< Undefined word
34 c, ( \" ) >,< Undefined word
65 c, ( \x41 ) >,< Undefined word
92 c, ( \\ ) >,< Undefined word
  ok
T{ result here result - 2dup dump ( Make a string out of result ) >result< Undefined word
   s\" \a\b\e\f\l\m\n\q\r\t\v\z\"\x41\\" 2dup dump compare -> 0 }T >s\"< Undefined word
hex >hex< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing ' ['] find execute immediate count literal postpone state  ok
  ok
T{ : gt1 123 ; -> }T >:< Undefined word
T{ ' gt1 execute -> 123 }T >'< Undefined word
T{ : gt2 ['] gt1 ; immediate -> }T >:< Undefined word
T{ gt2 execute -> 123 }T >gt2< Undefined word
here 3 c, char g c, char t c, char 1 c, constant gt1string >here< Undefined word
here 3 c, char g c, char t c, char 2 c, constant gt2string >here< Undefined word
T{ gt1string find -> ' gt1 -1 }T >gt1string< Undefined word
T{ gt2string find -> ' gt2 1 }T >gt2string< Undefined word
( TODO how to search for non-existent word? ) >(< Undefined word
T{ : gt3 gt2 literal ; -> }T >:< Undefined word
T{ gt3 -> ' gt1 }T >gt3< Undefined word
T{ gt1string count -> gt1string char+ 3 }T >gt1string< Undefined word
  ok
T{ : gt4 postpone gt1 ; immediate -> }T >:< Undefined word
T{ : gt5 gt4 ; -> }T >:< Undefined word
T{ gt5 -> 123 }T >gt5< Undefined word
T{ : gt6 345 ; immediate -> }T >:< Undefined word
T{ : gt7 postpone gt6 ; -> }T >:< Undefined word
T{ gt7 -> 345 }T >gt7< Undefined word
  ok
T{ : gt8 state @ ; immediate -> }T >:< Undefined word
T{ gt8 -> 0 }T >gt8< Undefined word
T{ : gt9 gt8 literal ; -> }T >:< Undefined word
T{ gt9 0= -> <false> }T >gt9< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing if else then begin while repeat until recurse  ok
  ok
T{ : gi1 if 123 then ; -> }T >:< Undefined word
T{ : gi2 if 123 else 234 then ; -> }T >:< Undefined word
T{ 0 gi1 -> }T >gi1< Undefined word
T{ 1 gi1 -> 123 }T >gi1< Undefined word
T{ -1 gi1 -> 123 }T >gi1< Undefined word
T{ 0 gi2 -> 234 }T >gi2< Undefined word
T{ 1 gi2 -> 123 }T >gi2< Undefined word
T{ -1 gi1 -> 123 }T >gi1< Undefined word
  ok
T{ : gi3 begin dup 5 < while dup 1+ repeat ; -> }T >:< Undefined word
T{ 0 gi3 -> 0 1 2 3 4 5 }T >gi3< Undefined word
T{ 4 gi3 -> 4 5 }T >gi3< Undefined word
T{ 5 gi3 -> 5 }T >gi3< Undefined word
T{ 6 gi3 -> 6 }T >gi3< Undefined word
  ok
T{ : gi4 begin dup 1+ dup 5 > until ; -> }T >:< Undefined word
T{ 3 gi4 -> 3 4 5 6 }T >gi4< Undefined word
T{ 5 gi4 -> 5 6 }T >gi4< Undefined word
T{ 6 gi4 -> 6 7 }T >gi4< Undefined word
  ok
T{ : gi5 begin dup 2 > while dup 5 < while dup 1+ repeat 123 else 345 then ; -> }T >:< Undefined word
T{ 1 gi5 -> 1 345 }T >gi5< Undefined word
T{ 2 gi5 -> 2 345 }T >gi5< Undefined word
T{ 3 gi5 -> 3 4 5 123 }T >gi5< Undefined word
T{ 4 gi5 -> 4 5 123 }T >gi5< Undefined word
T{ 5 gi5 -> 5 123 }T >gi5< Undefined word
  ok
T{ : gi6 ( n -- 0,1,..n ) dup if dup >r 1- recurse r> then ; -> }T >:< Undefined word
T{ 0 gi6 -> 0 }T >gi6< Undefined word
T{ 1 gi6 -> 0 1 }T >gi6< Undefined word
T{ 2 gi6 -> 0 1 2 }T >gi6< Undefined word
T{ 3 gi6 -> 0 1 2 3 }T >gi6< Undefined word
T{ 4 gi6 -> 0 1 2 3 4 }T >gi6< Undefined word
  ok
decimal >imal< Undefined word
T{ :noname ( n -- 0, 1, .., n )  >:noname< Undefined word
     dup if dup >r 1- recurse r> then  >up< Undefined word
   ;  >;< Undefined word
   constant rn1 -> }T >onstant< Undefined word
T{ 0 rn1 execute -> 0 }T >rn1< Undefined word
T{ 4 rn1 execute -> 0 1 2 3 4 }T >rn1< Undefined word
  ok
:noname ( n -- n1 ) >:noname< Undefined word
   1- dup >-< Undefined word
   case 0 of exit endof >se< Undefined word
     1 of 11 swap recurse endof >of< Undefined word
     2 of 22 swap recurse endof >of< Undefined word
     3 of 33 swap recurse endof >of< Undefined word
     drop abs recurse exit >rop< Undefined word
   endcase >ndcase< Undefined word
; constant rn2 >;< Undefined word
  ok
T{  1 rn2 execute -> 0 }T >rn2< Undefined word
T{  2 rn2 execute -> 11 0 }T >rn2< Undefined word
T{  4 rn2 execute -> 33 22 11 0 }T >rn2< Undefined word
T{ 25 rn2 execute -> 33 22 11 0 }T >rn2< Undefined word
hex >hex< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing case of endof endcase  ok
  ok
: cs1 case  >:< Undefined word
   1 of 111 endof >of< Undefined word
   2 of 222 endof >of< Undefined word
   3 of 333 endof >of< Undefined word
   4 of 444 endof >of< Undefined word
   5 of 555 endof >of< Undefined word
   6 of 666 endof >of< Undefined word
   7 of 777 endof >of< Undefined word
   >r 999 r> >>r< Undefined word
   endcase >ndcase< Undefined word
; >;< Undefined word
  ok
T{ 1 cs1 -> 111 }T >s1< Undefined word
T{ 2 cs1 -> 222 }T >s1< Undefined word
T{ 3 cs1 -> 333 }T >s1< Undefined word
T{ 4 cs1 -> 444 }T >s1< Undefined word
T{ 5 cs1 -> 555 }T >s1< Undefined word
T{ 6 cs1 -> 666 }T >s1< Undefined word
T{ 7 cs1 -> 777 }T >s1< Undefined word
T{ 8 cs1 -> 999 }T \ default >s1< Undefined word
  ok
: cs2 >r case >:< Undefined word
  ok
   -1 of case r@ 1 of 100 endof >of< Undefined word
                2 of 200 endof >of< Undefined word
                >r -300 r> >>r< Undefined word
        endcase >ndcase< Undefined word
     endof >ndof< Undefined word
   -2 of case r@ 1 of -99 endof >of< Undefined word
                >r -199 r> >>r< Undefined word
        endcase >ndcase< Undefined word
     endof >ndof< Undefined word
     >r 299 r> >>r< Undefined word
   endcase r> drop ; >ndcase< Undefined word
  ok
T{ -1 1 cs2 ->  100 }T >s2< Undefined word
T{ -1 2 cs2 ->  200 }T >s2< Undefined word
T{ -1 3 cs2 -> -300 }T >s2< Undefined word
T{ -2 1 cs2 ->  -99 }T >s2< Undefined word
T{ -2 2 cs2 -> -199 }T >s2< Undefined word
T{  0 2 cs2 ->  299 }T >s2< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing do loop +loop i j unloop leave exit ?do  ok
  ok
T{ : gd1 do i loop ; -> }T >:< Undefined word
T{ 4 1 gd1 -> 1 2 3 }T >gd1< Undefined word
T{ 2 -1 gd1 -> -1 0 1 }T >gd1< Undefined word
T{ mid-uint+1 mid-uint gd1 -> mid-uint }T >mid-uint+1< Undefined word
  ok
T{ : gd2 do i -1 +loop ; -> }T >:< Undefined word
T{ 1 4 gd2 -> 4 3 2 1 }T >gd2< Undefined word
T{ -1 2 gd2 -> 2 1 0 -1 }T >gd2< Undefined word
T{ mid-uint mid-uint+1 gd2 -> mid-uint+1 mid-uint }T >mid-uint< Undefined word
  ok
T{ : gd3 do 1 0 do j loop loop ; -> }T >:< Undefined word
T{ 4 1 gd3 -> 1 2 3 }T >gd3< Undefined word
T{ 2 -1 gd3 -> -1 0 1 }T >gd3< Undefined word
T{ mid-uint+1 mid-uint gd3 -> mid-uint }T >mid-uint+1< Undefined word
  ok
T{ : gd4 do 1 0 do j loop -1 +loop ; -> }T >:< Undefined word
T{ 1 4 gd4 -> 4 3 2 1 }T >gd4< Undefined word
T{ -1 2 gd4 -> 2 1 0 -1 }T >gd4< Undefined word
T{ mid-uint mid-uint+1 gd4 -> mid-uint+1 mid-uint }T >mid-uint< Undefined word
  ok
T{ : gd5 123 swap 0 do i 4 > if drop 234 leave then loop ; -> }T >:< Undefined word
T{ 1 gd5 -> 123 }T >gd5< Undefined word
T{ 5 gd5 -> 123 }T >gd5< Undefined word
T{ 6 gd5 -> 234 }T >gd5< Undefined word
  ok
T{ : gd6  ( pat: T{0 0}T,T{0 0}TT{1 0}TT{1 1}T,T{0 0}TT{1 0}TT{1 1}TT{2 0}TT{2 1}TT{2 2}T ) >:< Undefined word
   0 swap 0 do >swap< Undefined word
      i 1+ 0 do i j + 3 = if i unloop i unloop exit then 1+ loop >i< Undefined word
    loop ; -> }T >loop< Undefined word
T{ 1 gd6 -> 1 }T >gd6< Undefined word
T{ 2 gd6 -> 3 }T >gd6< Undefined word
T{ 3 gd6 -> 4 1 2 }T >gd6< Undefined word
  ok
: qd ?do i loop ;  >:< Undefined word
T{   789   789 qd -> }T  >qd< Undefined word
T{ -9876 -9876 qd -> }T  >qd< Undefined word
T{     5     0 qd -> 0 1 2 3 4 }T >qd< Undefined word
  ok
: qd1 ?do i 10 +loop ;  >:< Undefined word
T{ 50 1 qd1 -> 1 11 21 31 41 }T  >qd1< Undefined word
T{ 50 0 qd1 -> 0 10 20 30 40 }T >qd1< Undefined word
  ok
: qd2 ?do i 3 > if leave else i then loop ;  >:< Undefined word
T{ 5 -1 qd2 -> -1 0 1 2 3 }T >qd2< Undefined word
  ok
: qd3 ?do i 1 +loop ;  >:< Undefined word
T{ 4  4 qd3 -> }T  >qd3< Undefined word
T{ 4  1 qd3 ->  1 2 3 }T >qd3< Undefined word
T{ 2 -1 qd3 -> -1 0 1 }T >qd3< Undefined word
  ok
: qd4 ?do i -1 +loop ;  >:< Undefined word
T{  4 4 qd4 -> }T >qd4< Undefined word
T{  1 4 qd4 -> 4 3 2  1 }T  >qd4< Undefined word
T{ -1 2 qd4 -> 2 1 0 -1 }T >qd4< Undefined word
  ok
: qd5 ?do i -10 +loop ;  >:< Undefined word
T{   1 50 qd5 -> 50 40 30 20 10   }T  >qd5< Undefined word
T{   0 50 qd5 -> 50 40 30 20 10 0 }T  >qd5< Undefined word
T{ -25 10 qd5 -> 10 0 -10 -20     }T >qd5< Undefined word
  ok
variable qditerations  >variable< Undefined word
variable qdincrement >variable< Undefined word
  ok
: qd6 ( limit start increment -- )    qdincrement !  >:< Undefined word
   0 qditerations !  >qditerations< Undefined word
   ?do  >?do< Undefined word
     1 qditerations +!  >qditerations< Undefined word
     i  >i< Undefined word
     qditerations @ 6 = if leave then  >qditerations< Undefined word
     qdincrement @  >qdincrement< Undefined word
   +loop qditerations @  >+loop< Undefined word
; >;< Undefined word
  ok
T{  4  4 -1 qd6 ->                   0  }T  >qd6< Undefined word
T{  1  4 -1 qd6 ->  4  3  2  1       4  }T  >qd6< Undefined word
T{  4  1 -1 qd6 ->  1  0 -1 -2 -3 -4 6  }T  >qd6< Undefined word
T{  4  1  0 qd6 ->  1  1  1  1  1  1 6  }T  >qd6< Undefined word
T{  0  0  0 qd6 ->                   0  }T  >qd6< Undefined word
T{  1  4  0 qd6 ->  4  4  4  4  4  4 6  }T  >qd6< Undefined word
T{  1  4  1 qd6 ->  4  5  6  7  8  9 6  }T  >qd6< Undefined word
T{  4  1  1 qd6 ->  1  2  3          3  }T  >qd6< Undefined word
T{  4  4  1 qd6 ->                   0  }T  >qd6< Undefined word
T{  2 -1 -1 qd6 -> -1 -2 -3 -4 -5 -6 6  }T  >qd6< Undefined word
T{ -1  2 -1 qd6 ->  2  1  0 -1       4  }T  >qd6< Undefined word
T{  2 -1  0 qd6 -> -1 -1 -1 -1 -1 -1 6  }T  >qd6< Undefined word
T{ -1  2  0 qd6 ->  2  2  2  2  2  2 6  }T  >qd6< Undefined word
T{ -1  2  1 qd6 ->  2  3  4  5  6  7 6  }T  >qd6< Undefined word
T{  2 -1  1 qd6 -> -1  0  1          3  }T >qd6< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing defining words: : ; constant variable create does> >body value to  ok
  ok
T{ 123 constant x123 -> }T >onstant< Undefined word
T{ x123 -> 123 }T >x123< Undefined word
T{ : equ constant ; -> }T >:< Undefined word
T{ x123 equ y123 -> }T >x123< Undefined word
T{ y123 -> 123 }T >y123< Undefined word
  ok
T{ variable v1 -> }T >variable< Undefined word
T{ 123 v1 ! -> }T >v1< Undefined word
T{ v1 @ -> 123 }T >v1< Undefined word
  ok
T{ : nop : postpone ; ; -> }T >:< Undefined word
T{ nop nop1 nop nop2 -> }T >nop< Undefined word
T{ nop1 -> }T >nop1< Undefined word
T{ nop2 -> }T >nop2< Undefined word
  ok
T{ : does1 does> @ 1 + ; -> }T >:< Undefined word
T{ : does2 does> @ 2 + ; -> }T >:< Undefined word
T{ create cr1 -> }T >reate< Undefined word
T{ cr1 -> here }T >r1< Undefined word
T{ ' cr1 >body -> here }T >'< Undefined word
T{ 1 , -> }T >,< Undefined word
T{ cr1 @ -> 1 }T >r1< Undefined word
T{ does1 -> }T >oes1< Undefined word
T{ cr1 -> 2 }T >r1< Undefined word
T{ does2 -> }T >oes2< Undefined word
T{ cr1 -> 3 }T >r1< Undefined word
  ok
\ The following test is not part of the original suite, but belongs >\< Undefined word
\ to the "weird:" test following it. See discussion at >\< Undefined word
\ https://github.com/scotws/TaliForth2/issues/61 >\< Undefined word
T{ : odd: create does> 1 + ; -> }T >:< Undefined word
T{ odd: o1 -> }T >odd:< Undefined word
T{ ' o1 >body -> here }T >'< Undefined word
T{ o1 -> here 1 + }T >o1< Undefined word
  ok
T{ : weird: create does> 1 + does> 2 + ; -> }T >:< Undefined word
T{ weird: w1 -> }T >weird:< Undefined word
T{ ' w1 >body -> here }T >'< Undefined word
T{ w1 -> here 1 + }T >w1< Undefined word
T{ w1 -> here 2 + }T >w1< Undefined word
  ok
T{  111 value v1 -> }T >value< Undefined word
T{ -999 value v2 -> }T >value< Undefined word
T{ v1 ->  111 }T >v1< Undefined word
T{ v2 -> -999 }T  >v2< Undefined word
T{ 222 to v1 -> }T  >to< Undefined word
T{ v1 -> 222 }T >v1< Undefined word
T{ : vd1 v1 ; -> }T >:< Undefined word
T{ vd1 -> 222 }T >vd1< Undefined word
  ok
T{ : vd2 to v2 ; -> }T >:< Undefined word
T{ v2 -> -999 }T >v2< Undefined word
T{ -333 vd2 -> }T >vd2< Undefined word
T{ v2 -> -333 }T >v2< Undefined word
T{ v1 ->  222 }T >v1< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing evaluate  ok
  ok
: ge1 s" 123" ; immediate >:< Undefined word
: ge2 s" 123 1+" ; immediate >:< Undefined word
: ge3 s" : ge4 345 ;" ; >:< Undefined word
: ge5 evaluate ; immediate >:< Undefined word
  ok
T{ ge1 evaluate -> 123 }T \ test evaluate in interp. state >ge1< Undefined word
T{ ge2 evaluate -> 124 }T >ge2< Undefined word
T{ ge3 evaluate -> }T >ge3< Undefined word
T{ ge4 -> 345 }T >ge4< Undefined word
  ok
T{ : ge6 ge1 ge5 ; -> }T  \ test evaluate in compile state >:< Undefined word
T{ ge6 -> 123 }T >ge6< Undefined word
T{ : ge7 ge2 ge5 ; -> }T >:< Undefined word
T{ ge7 -> 124 }T >ge7< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing source >in word  ok
  ok
: gs1 s" source" 2dup evaluate  >:< Undefined word
       >r swap >r = r> r> = ; >>r< Undefined word
T{ gs1 -> <true> <true> }T >gs1< Undefined word
  ok
variable scans >variable< Undefined word
: rescan?  -1 scans +! >:< Undefined word
   scans @ if >scans< Undefined word
      0 >in ! >>in< Undefined word
   then ; >then< Undefined word
  ok
T{ 2 scans !   >scans< Undefined word
345 rescan?   >rescan?< Undefined word
-> 345 345 }T WRONG NUMBER OF RESULTS: -> 345 345 }T ACTUAL RESULT: { } ok
  ok
: gs2  5 scans ! s" 123 rescan?" evaluate ; >:< Undefined word
T{ gs2 -> 123 123 123 123 123 }T >gs2< Undefined word
  ok
: gs3 word count swap c@ ; >:< Undefined word
T{ bl gs3 hello -> 5 char h }T >l< Undefined word
T{ char " gs3 goodbye" -> 7 char g }T >har< Undefined word
T{ bl gs3  >l< Undefined word
drop -> 0 }T \ blank line return zero-length string >rop< Undefined word
  ok
: gs4 source >in ! drop ; >:< Undefined word
T{ gs4 123 456  >gs4< Undefined word
-> }T  ok
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing <# # #s #> hold sign base >number hex decimal  ok
hex >hex< Undefined word
  ok
\ compare two strings. >\< Undefined word
: s=  ( addr1 c1 addr2 c2 -- t/f )  >:< Undefined word
   >r swap r@ = if \ make sure strings have same length >>r< Undefined word
      r> ?dup if   \ if non-empty strings >r>< Undefined word
         0 do >o< Undefined word
            over c@ over c@ - if >over< Undefined word
               2drop <false> unloop exit >rop< Undefined word
            then >then< Undefined word
            swap char+ swap char+ >swap< Undefined word
         loop >loop< Undefined word
      then >then< Undefined word
      2drop <true> \ if we get here, strings match >rop< Undefined word
   else >lse< Undefined word
      r> drop 2drop <false>  \ lengths mismatch >r>< Undefined word
   then ; >then< Undefined word
  ok
: gp1  <# 41 hold 42 hold 0 0 #> s" BA" s= ; >:< Undefined word
T{ gp1 -> <true> }T >gp1< Undefined word
  ok
: gp2  <# -1 sign 0 sign -1 sign 0 0 #> s" --" s= ; >:< Undefined word
T{ gp2 -> <true> }T >gp2< Undefined word
  ok
: gp3  <# 1 0 # # #> s" 01" s= ; >:< Undefined word
T{ gp3 -> <true> }T >gp3< Undefined word
  ok
: gp4  <# 1 0 #s #> s" 1" s= ; >:< Undefined word
T{ gp4 -> <true> }T >gp4< Undefined word
  ok
24 constant max-base   \ base 2 .. 36 >onstant< Undefined word
max-base .( max-base post def: ) . cr  ( TODO TEST ) >max-base< Undefined word
: count-bits >:< Undefined word
   0 0 invert  >invert< Undefined word
   begin  >gin< Undefined word
      dup while >up< Undefined word
      >r 1+ r> 2*  >>r< Undefined word
   repeat  >repeat< Undefined word
   drop ; >rop< Undefined word
  ok
count-bits 2* constant #bits-ud  \ number of bits in ud >ount-bits< Undefined word
  ok
: gp5 >:< Undefined word
   base @ <true> >se< Undefined word
   max-base 1+ 2 do   \ for each possible base >max-base< Undefined word
      i base !    \ tbd: assumes base works >i< Undefined word
      i 0 <# #s #> s" 10" s= and >i< Undefined word
   loop >loop< Undefined word
   swap base ! ; >swap< Undefined word
T{ gp5 -> <true> }T >gp5< Undefined word
  ok
: gp6 >:< Undefined word
   base @ >r  2 base ! >se< Undefined word
   max-uint max-uint <# #s #>  \ maximum ud to binary >max-uint< Undefined word
   r> base !    \ s: c-addr u >r>< Undefined word
   dup #bits-ud = swap >up< Undefined word
   0 do     \ s: c-addr flag >o< Undefined word
      over c@ [char] 1 = and  \ all ones >over< Undefined word
      >r char+ r> >>r< Undefined word
   loop swap drop ; >loop< Undefined word
T{ gp6 -> <true> }T >gp6< Undefined word
  ok
  ok
\ Split up long testing word from ANS Forth in two parts >\< Undefined word
\ to figure out what is wrong >\< Undefined word
  ok
\ Test the numbers 0 to 15 in max-base >\< Undefined word
: gp7-1 >:< Undefined word
   base @ >r   >se< Undefined word
   max-base base ! >max-base< Undefined word
   <true> ><true>< Undefined word
  ok
   a 0 do >o< Undefined word
      i 0 <# #s #> >i< Undefined word
      1 = swap c@ i 30 + = and and >=< Undefined word
   loop >loop< Undefined word
     ok
   r> base ! ; >r>< Undefined word
  ok
T{ gp7-1 -> <true> }T >gp7-1< Undefined word
  ok
\ Test the numbers 16 to max-base in max-base >\< Undefined word
: gp7-2 >:< Undefined word
   base @ >r   >se< Undefined word
   max-base base ! >max-base< Undefined word
   <true> ><true>< Undefined word
  ok
   max-base a do >max-base< Undefined word
      i 0 <# #s #> >i< Undefined word
      2dup type cr ( TODO TEST ) >up< Undefined word
      1 = swap c@ 41 i a - + = and and >=< Undefined word
      .s cr ( TODO TEST ) >.s< Undefined word
   loop >loop< Undefined word
  ok
   r> base ! ; >r>< Undefined word
  ok
T{ gp7-2 -> <true> }T >gp7-2< Undefined word
  ok
\ >number tests >\< Undefined word
create gn-buf 0 c, >reate< Undefined word
: gn-string gn-buf 1 ; >:< Undefined word
: gn-consumed gn-buf char+ 0 ; >:< Undefined word
: gn'  [char] ' word char+ c@ gn-buf c!  gn-string ; >:< Undefined word
  ok
T{ 0 0 gn' 0' >number -> 0 0 gn-consumed }T >gn'< Undefined word
T{ 0 0 gn' 1' >number -> 1 0 gn-consumed }T >gn'< Undefined word
T{ 1 0 gn' 1' >number -> base @ 1+ 0 gn-consumed }T >gn'< Undefined word
T{ 0 0 gn' -' >number -> 0 0 gn-string }T \ should fail to convert these >gn'< Undefined word
T{ 0 0 gn' +' >number -> 0 0 gn-string }T >gn'< Undefined word
T{ 0 0 gn' .' >number -> 0 0 gn-string }T >gn'< Undefined word
  ok
: >number-based  base @ >r base ! >number r> base ! ; >:< Undefined word
  ok
T{ 0 0 gn' 2' 10 >number-based -> 2 0 gn-consumed }T >gn'< Undefined word
T{ 0 0 gn' 2'  2 >number-based -> 0 0 gn-string }T >gn'< Undefined word
T{ 0 0 gn' f' 10 >number-based -> f 0 gn-consumed }T >gn'< Undefined word
T{ 0 0 gn' g' 10 >number-based -> 0 0 gn-string }T >gn'< Undefined word
T{ 0 0 gn' g' max-base >number-based -> 10 0 gn-consumed }T >gn'< Undefined word
T{ 0 0 gn' z' max-base >number-based -> 23 0 gn-consumed }T >gn'< Undefined word
  ok
\ ud should equal ud' and len should be zero. >\< Undefined word
: gn1  ( ud base -- ud' len )  >:< Undefined word
   base @ >r base ! >se< Undefined word
   <# #s #> ><#< Undefined word
   0 0 2swap >number swap drop  \ return length only >swap< Undefined word
   r> base ! ; >r>< Undefined word
  ok
T{ 0 0 2 gn1 -> 0 0 0 }T >gn1< Undefined word
T{ max-uint 0 2 gn1 -> max-uint 0 0 }T >max-uint< Undefined word
T{ max-uint dup 2 gn1 -> max-uint dup 0 }T >max-uint< Undefined word
  ok
T{ 0 0 max-base gn1 -> 0 0 0 }T >max-base< Undefined word
T{ max-uint 0 max-base gn1 -> max-uint 0 0 }T >max-uint< Undefined word
T{ max-uint dup max-base gn1 -> max-uint dup 0 }T >max-uint< Undefined word
  ok
: gn2 ( -- 16 10 ) >:< Undefined word
   base @ >r  hex base @  decimal base @  r> base ! ; >se< Undefined word
  ok
T{ gn2 -> 10 a }T >gn2< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing action-of defer defer! defer@ is  ok
  ok
T{ defer defer1 -> }T >r< Undefined word
T{ : action-defer1 action-of defer1 ; -> }T >:< Undefined word
T{ ' * ' defer1 defer! ->   }T >'< Undefined word
T{          2 3 defer1 -> 6 }T >r1< Undefined word
T{ action-of defer1 -> ' * }T  >tion-of< Undefined word
T{    action-defer1 -> ' * }T >tion-defer1< Undefined word
  ok
T{ ' + is defer1 ->   }T >'< Undefined word
T{    1 2 defer1 -> 3 }T  >r1< Undefined word
T{ action-of defer1 -> ' + }T >tion-of< Undefined word
T{    action-defer1 -> ' + }T >tion-defer1< Undefined word
  ok
T{ defer defer2 ->   }T  >r< Undefined word
T{ ' * ' defer2 defer! -> }T >'< Undefined word
T{   2 3 defer2 -> 6 }T >r2< Undefined word
T{ ' + is defer2 ->   }T >'< Undefined word
T{    1 2 defer2 -> 3 }T >r2< Undefined word
  ok
T{ defer defer3 -> }T >r< Undefined word
T{ ' * ' defer3 defer! -> }T >'< Undefined word
T{ 2 3 defer3 -> 6 }T >r3< Undefined word
T{ ' + ' defer3 defer! -> }T >'< Undefined word
T{ 1 2 defer3 -> 3 }T >r3< Undefined word
  ok
T{ defer defer4 -> }T >r< Undefined word
T{ ' * ' defer4 defer! -> }T >'< Undefined word
T{ 2 3 defer4 -> 6 }T >r4< Undefined word
T{ ' defer4 defer@ -> ' * }T >'< Undefined word
  ok
T{ ' + is defer4 -> }T  >'< Undefined word
T{ 1 2 defer4 -> 3 }T  >r4< Undefined word
T{ ' defer4 defer@ -> ' + }T >'< Undefined word
  ok
T{ defer defer5 -> }T >r< Undefined word
T{ : is-defer5 is defer5 ; -> }T >:< Undefined word
T{ ' * is defer5 -> }T >'< Undefined word
T{ 2 3 defer5 -> 6 }T >r5< Undefined word
T{ ' + is-defer5 -> }T  >'< Undefined word
T{ 1 2 defer5 -> 3 }T >r5< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing fill move  ok
  ok
create fbuf 00 c, 00 c, 00 c, >reate< Undefined word
create sbuf 12 c, 34 c, 56 c, >reate< Undefined word
: seebuf fbuf c@  fbuf char+ c@  fbuf char+ char+ c@ ; >:< Undefined word
  ok
T{ fbuf 0 20 fill -> }T >uf< Undefined word
T{ seebuf -> 00 00 00 }T >seebuf< Undefined word
  ok
T{ fbuf 1 20 fill -> }T >uf< Undefined word
T{ seebuf -> 20 00 00 }T >seebuf< Undefined word
  ok
T{ fbuf 3 20 fill -> }T >uf< Undefined word
T{ seebuf -> 20 20 20 }T >seebuf< Undefined word
  ok
T{ fbuf fbuf 3 chars move -> }T  \ bizarre special case >uf< Undefined word
T{ seebuf -> 20 20 20 }T >seebuf< Undefined word
  ok
T{ sbuf fbuf 0 chars move -> }T >sbuf< Undefined word
T{ seebuf -> 20 20 20 }T >seebuf< Undefined word
  ok
T{ sbuf fbuf 1 chars move -> }T >sbuf< Undefined word
T{ seebuf -> 12 20 20 }T >seebuf< Undefined word
  ok
T{ sbuf fbuf 3 chars move -> }T >sbuf< Undefined word
T{ seebuf -> 12 34 56 }T >seebuf< Undefined word
  ok
T{ fbuf fbuf char+ 2 chars move -> }T >uf< Undefined word
T{ seebuf -> 12 12 34 }T >seebuf< Undefined word
  ok
T{ fbuf char+ fbuf 2 chars move -> }T >uf< Undefined word
T{ seebuf -> 12 34 34 }T >seebuf< Undefined word
  ok
\ CMOVE and CMOVE> propogation tests taken from  >\< Undefined word
\ https://forth-standard.org/standard/string/CMOVE and .../CMOVEtop >\< Undefined word
decimal >imal< Undefined word
create cmbuf  97 c, 98 c, 99 c, 100 c, \ "abcd" >reate< Undefined word
: seecmbuf  cmbuf c@  cmbuf char+ c@  cmbuf char+ char+ c@  cmbuf char+ char+ char+ c@ ; >:< Undefined word
T{ cmbuf dup char+ 3 cmove -> }T >mbuf< Undefined word
T{ seecmbuf -> 97 97 97 97 }T \ "aaaa" >seecmbuf< Undefined word
  ok
create cmubuf  97 c, 98 c, 99 c, 100 c, \ "abcd" >reate< Undefined word
: seecmubuf  cmubuf c@  cmubuf char+ c@  cmubuf char+ char+ c@  cmubuf char+ char+ char+ c@ ; >:< Undefined word
T{ cmubuf dup char+ swap 3 cmove> -> }T >mubuf< Undefined word
T{ seecmubuf -> 100 100 100 100 }T \ "dddd" >seecmubuf< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing output: . ." cr emit space spaces type u.  ok
hex >hex< Undefined word
  ok
: output-test >:< Undefined word
   ." you should see the standard graphic characters:" cr >."< Undefined word
   41 bl do i emit loop cr >l< Undefined word
   61 41 do i emit loop cr >o< Undefined word
   7f 61 do i emit loop cr >o< Undefined word
   ." you should see 0-9 separated by a space:" cr >."< Undefined word
   9 1+ 0 do i . loop cr >+< Undefined word
   ." you should see 0-9 (with no spaces):" cr >."< Undefined word
   [char] 9 1+ [char] 0 do i 0 spaces emit loop cr >[char]< Undefined word
   ." you should see a-g separated by a space:" cr >."< Undefined word
   [char] g 1+ [char] a do i emit space loop cr >[char]< Undefined word
   ." you should see 0-5 separated by two spaces:" cr >."< Undefined word
   5 1+ 0 do i [char] 0 + emit 2 spaces loop cr >+< Undefined word
   ." you should see two separate lines:" cr >."< Undefined word
   s" line 1" type cr s" line 2" type cr >s"< Undefined word
   ." you should see the number ranges of signed and unsigned numbers:" cr >."< Undefined word
   ."   signed: " min-int . max-int . cr >."< Undefined word
   ." unsigned: " 0 u. max-uint u. cr >."< Undefined word
; >;< Undefined word
  ok
T{ output-test -> }T >output-test< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing parse-name marker erase  ok
  ok
\ Careful editing these, whitespace is significant >\< Undefined word
T{ parse-name abcd s" abcd" s= -> <true> }T  >parse-name< Undefined word
T{ parse-name   abcde   s" abcde" s= -> <true> }T \ test empty parse area  >parse-name< Undefined word
T{ parse-name  abcde s" abcde" s= -> <true> }T \ test TABS instead of spaces >parse-name< Undefined word
T{ parse-name  >parse-name< Undefined word
   nip -> 0 }T    \ empty line  >nip< Undefined word
T{ parse-name     >parse-name< Undefined word
   nip -> 0 }T    \ line with white space >nip< Undefined word
T{ : parse-name-test ( "name1" "name2" -- n )  >:< Undefined word
   parse-name parse-name s= ; -> }T >parse-name< Undefined word
T{ parse-name-test abcd abcd -> <true> }T  >parse-name-test< Undefined word
T{ parse-name-test  abcd   abcd   -> <true> }T  >parse-name-test< Undefined word
T{ parse-name-test abcde abcdf -> <false> }T  >parse-name-test< Undefined word
T{ parse-name-test abcdf abcde -> <false> }T  >parse-name-test< Undefined word
T{ parse-name-test abcde abcde  >parse-name-test< Undefined word
    -> <true> }T  ><true>< Undefined word
T{ parse-name-test abcde abcde   >parse-name-test< Undefined word
    -> <true> }T    \ line with white space ><true>< Undefined word
  ok
\ There is no official ANS test for MARKER, added 22. June 2018 >\< Undefined word
\ TODO There is currently no test for FIND-NAME, taking it on faith here >\< Undefined word
T{ variable marker_size -> }T >variable< Undefined word
T{ unused marker_size ! -> }T >unused< Undefined word
T{ marker quarian -> }T >marker< Undefined word
: marker_test ." Bosh'tet!" ; >:< Undefined word
T{ marker_test -> }T \ should print "Bosh'tet!" >marker_test< Undefined word
T{ quarian -> }T  >quarian< Undefined word
T{ parse-name marker_test find-name -> 0 }T  >parse-name< Undefined word
T{ marker_size @ unused = -> <true> }T >marker_size< Undefined word
  ok
\ There is no official ANS test of ERASE, added 01. July 2018 >\< Undefined word
T{ create erase_test -> }T >reate< Undefined word
T{ 9 c, 1 c, 2 c, 3 c, 9 c, -> }T >,< Undefined word
T{ erase_test 1+ 3 erase -> }T  \ Erase bytes between 9  >rase_test< Undefined word
T{ erase_test            c@ 9 = -> <true> }T >rase_test< Undefined word
T{ erase_test 1 chars +  c@ 0 = -> <true> }T >rase_test< Undefined word
T{ erase_test 2 chars +  c@ 0 = -> <true> }T >rase_test< Undefined word
T{ erase_test 3 chars +  c@ 0 = -> <true> }T >rase_test< Undefined word
T{ erase_test 4 chars +  c@ 9 = -> <true> }T >rase_test< Undefined word
  ok
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing environment  ok
  ok
\ This is from the ANS Forth specification at  >\< Undefined word
\ https://forth-standard.org/standard/core/ENVIRONMENTq but the first >\< Undefined word
\ test is commented out because it doesn't seem to make sense >\< Undefined word
\ T{ s" x:deferred" environment? dup 0= xor invert -> <true>  }T ( Huh? Why true? ) >\< Undefined word
T{ s" x:notfound" environment? dup 0= xor invert -> <false> }T >s"< Undefined word
  ok
\ These were added for Tali Forth 10. Aug 2018 >\< Undefined word
hex >hex< Undefined word
T{ s" /COUNTED-STRING"    environment? ->    7FFF <true> }T >s"< Undefined word
T{ s" /HOLD"              environment? ->      FF <true> }T >s"< Undefined word
T{ s" /PAD"               environment? ->      54 <true> }T >s"< Undefined word
T{ s" ADDRESS-UNIT-BITS"  environment? ->       8 <true> }T >s"< Undefined word
T{ s" FLOORED"            environment? -> <false> <true> }T >s"< Undefined word
T{ s" MAX-CHAR"           environment? ->      FF <true> }T >s"< Undefined word
T{ s" MAX-N"              environment? ->    7FFF <true> }T >s"< Undefined word
T{ s" MAX-U"              environment? ->    FFFF <true> }T >s"< Undefined word
T{ s" RETURN-STACK-CELLS" environment? ->      80 <true> }T >s"< Undefined word
T{ s" STACK-CELLS"        environment? ->      20 <true> }T >s"< Undefined word
T{ s" WORDLISTS"          environment? ->       9 <true> }T >s"< Undefined word
  ok
T{ s" MAX-D"  environment? -> 7FFFFFFF. <true> }T  >s"< Undefined word
T{ s" MAX-UD" environment? -> FFFFFFFF. <true> }T >s"< Undefined word
decimal >imal< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing input: accept  ok
  ok
create abuf 80 chars allot >reate< Undefined word
  ok
: accept-test >:< Undefined word
   cr ." please type up to 80 characters:" cr >r< Undefined word
   abuf 80 accept >uf< Undefined word
   dup  >up< Undefined word
   cr ." received: " [char] " emit >r< Undefined word
   abuf swap type [char] " emit cr >uf< Undefined word
; >;< Undefined word
  ok
\ The text for accept (below the test) is 29 characters long. >\< Undefined word
T{ accept-test -> 29 }T >pt-test< Undefined word
Here is some text for accept. >Here< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing dictionary search rules  ok
  ok
T{ : gdx   123 ; : gdx   gdx 234 ; -> }T >:< Undefined word
T{ gdx -> 123 234 }T >gdx< Undefined word
  ok
hex >hex< Undefined word
\ Free memory used for these tests >\< Undefined word
core_tests  ok
  ok
  ok
 ( Running test 'string' from file 'string.fs' ) >(< Undefined word
\ ------------------------------------------------------------------------ >\< Undefined word
testing string words: /string -trailing blank sliteral  ok
decimal >imal< Undefined word
  ok
marker string_tests >marker< Undefined word
  ok
  ok
\ Note the sequence of tests is fixed by https://forth-standard.org/standard/testsuite >\< Undefined word
  ok
T{ : s1 s" abcdefghijklmnopqrstuvwxyz" ; -> }T >:< Undefined word
   ok
T{ s1  5 /string -> s1 swap 5 + swap 5 - }T >s1< Undefined word
T{ s1 10 /string -4 /string -> s1 6 /string }T >s1< Undefined word
T{ s1  0 /string -> s1 }T >s1< Undefined word
  ok
T{ : s2 s" abc"   ; -> }T >:< Undefined word
T{ : s3 s" jklmn" ; -> }T >:< Undefined word
T{ : s4 s" z"     ; -> }T >:< Undefined word
T{ : s5 s" mnoq"  ; -> }T >:< Undefined word
T{ : s6 s" 12345" ; -> }T >:< Undefined word
T{ : s7 s" "      ; -> }T >:< Undefined word
  ok
T{ s1 s2 search -> s1 -1 ( <true> )  }T   >s1< Undefined word
T{ s1 s3 search -> s1  9 /string -1 ( <true> )  }T >s1< Undefined word
T{ s1 s4 search -> s1 25 /string -1 ( <true> ) }T >s1< Undefined word
T{ s1 s5 search -> s1 0 ( <false> ) }T >s1< Undefined word
T{ s1 s6 search -> s1 0 ( <false> ) }T >s1< Undefined word
T{ s1 s7 search -> s1 -1 ( <true> ) }T  >s1< Undefined word
  ok
T{ :  s8 s" abc  " ; -> }T >:< Undefined word
T{ :  s9 s"      " ; -> }T >:< Undefined word
T{ : s10 s"    a " ; -> }T >:< Undefined word
  ok
T{  s1 -trailing -> s1 }T        \ "abcdefghijklmnopqrstuvwxyz" >s1< Undefined word
T{  s8 -trailing -> s8 2 - }T    \ "abc " >s8< Undefined word
T{  s7 -trailing -> s7 }T        \ " " >s7< Undefined word
T{  s9 -trailing -> s9 drop 0 }T \ " " >s9< Undefined word
T{ s10 -trailing -> s10 1- }T    \ " a " >s10< Undefined word
  ok
T{ s1        s1 compare ->  0  }T >s1< Undefined word
T{ s1  pad swap cmove   ->     }T    \ copy s1 to PAD >s1< Undefined word
T{ s1  pad over compare ->  0  }T >s1< Undefined word
T{ s1     pad 6 compare ->  1  }T >s1< Undefined word
T{ pad 10    s1 compare -> -1  }T >pad< Undefined word
T{ s1     pad 0 compare ->  1  }T >s1< Undefined word
T{ pad  0    s1 compare -> -1  }T >pad< Undefined word
T{ s1        s6 compare ->  1  }T >s1< Undefined word
T{ s6        s1 compare -> -1  }T >s6< Undefined word
  ok
: "abdde" s" abdde" ; >:< Undefined word
: "abbde" s" abbde" ; >:< Undefined word
: "abcdf" s" abcdf" ; >:< Undefined word
: "abcdee" s" abcdee" ; >:< Undefined word
  ok
T{ s1 "abdde"  compare -> -1 }T >s1< Undefined word
T{ s1 "abbde"  compare ->  1 }T >s1< Undefined word
T{ s1 "abcdf"  compare -> -1 }T >s1< Undefined word
T{ s1 "abcdee" compare ->  1 }T >s1< Undefined word
  ok
: s11 s" 0abc" ; >:< Undefined word
: s12 s" 0aBc" ; >:< Undefined word
  ok
T{ s11 s12 compare ->  1 }T >s11< Undefined word
T{ s12 s11 compare -> -1 }T >s12< Undefined word
  ok
: s13 s" aaaaa      a" ;       \ six spaces >:< Undefined word
  ok
T{ pad 25 char a fill -> }T      \ fill PAD with 25 'a's >pad< Undefined word
T{ pad 5 chars + 6 blank -> }T   \ put 6 spaced from character 5 >pad< Undefined word
T{ pad 12 s13 compare -> 0 }T    \ PAD should now be same as s13 TODO >pad< Undefined word
  ok
( CMOVE and CMOVE> are kept together with MOVE ) >(< Undefined word
  ok
T{ : s14 [ s1 ] sliteral ; -> }T  >:< Undefined word
T{ s1 s14 compare -> 0 }T >s1< Undefined word
T{ s1 s14 rot = rot rot = -> -1 ( <true> ) 0 ( <false> ) }T >s1< Undefined word
  ok
( TODO REPLACES not implemented yet ) >(< Undefined word
( TODO SUBSTITUTE not implemented yet ) >(< Undefined word
( TODO UNESCAPE not implemented yet ) >(< Undefined word
  ok
\ Tests for long strings are currently in their own file >\< Undefined word
\ Free memory used for these tests >\< Undefined word
string_tests >string_tests< Undefined word
  ok
  ok
 ( Running test 'double' from file 'double.fs' ) >(< Undefined word
\ ------------------------------------------------------------------------ >\< Undefined word
testing double words: 2constant 2variable d+ d- d. d.r d>s dabs dnegate  ok
  ok
marker double_tests >marker< Undefined word
  ok
decimal >imal< Undefined word
  ok
T{ 2variable 2v1 -> }T >variable< Undefined word
T{ 0. 2v1 2! -> }T >v1< Undefined word
T{ 2v1 2@ -> 0. }T >v1< Undefined word
T{ -1 -2 2v1 2! -> }T >v1< Undefined word
T{ 2v1 2@ -> -1 -2 }T >v1< Undefined word
T{ : cd2 2variable ; -> }T >:< Undefined word
T{ cd2 2v2 -> }T >v2< Undefined word
T{ : cd3 2v2 2! ; -> }T >:< Undefined word
T{ -2 -1 cd3 -> }T WRONG NUMBER OF RESULTS: T{ -2 -1 cd3 -> }T ACTUAL RESULT: { -2 -1 -1 -1 CD3 0 } ok
T{ 2v2 2@ -> -2 -1 }T >v2< Undefined word
T{ 2variable 2v3 immediate 5 6 2v3 2! -> }T >variable< Undefined word
T{ 2v3 2@ -> 5 6 }T >v3< Undefined word
  ok
\ Repeats in case we call this test alone >\< Undefined word
0 constant 0s >onstant< Undefined word
0 invert constant 1s >invert< Undefined word
0 invert 1 rshift  constant max-int >invert< Undefined word
0 invert 1 rshift invert  constant min-int >invert< Undefined word
  ok
T{  0.  5. d+ ->  5. }T                         \ small integers  >+< Undefined word
T{ -5.  0. d+ -> -5. }T  >+< Undefined word
T{  1.  2. d+ ->  3. }T  >+< Undefined word
T{  1. -2. d+ -> -1. }T  >+< Undefined word
T{ -1.  2. d+ ->  1. }T  >+< Undefined word
T{ -1. -2. d+ -> -3. }T  >+< Undefined word
T{ -1.  1. d+ ->  0. }T >+< Undefined word
T{  0  0  0  5 d+ ->  0  5 }T                  \ mid range integers  >+< Undefined word
T{ -1  5  0  0 d+ -> -1  5 }T  >+< Undefined word
T{  0  0  0 -5 d+ ->  0 -5 }T  >+< Undefined word
T{  0 -5 -1  0 d+ -> -1 -5 }T  >+< Undefined word
T{  0  1  0  2 d+ ->  0  3 }T  >+< Undefined word
T{ -1  1  0 -2 d+ -> -1 -1 }T  >+< Undefined word
T{  0 -1  0  2 d+ ->  0  1 }T  >+< Undefined word
T{  0 -1 -1 -2 d+ -> -1 -3 }T  >+< Undefined word
T{ -1 -1  0  1 d+ -> -1  0 }T >+< Undefined word
  ok
T{ min-int 0 2dup d+ -> 0 1 }T >min-int< Undefined word
T{ min-int s>d min-int 0 d+ -> 0 0 }T >min-int< Undefined word
  ok
T{ 1 2 2constant 2c1 -> }T >onstant< Undefined word
T{ 2c1 -> 1 2 }T WRONG NUMBER OF RESULTS: T{ 2c1 -> 1 2 }T ACTUAL RESULT: { 2C1 0 } ok
T{ : cd1 2c1 ; -> }T >:< Undefined word
T{ cd1 -> 1 2 }T INCORRECT RESULT: T{ cd1 -> 1 2 }T ACTUAL RESULT: { CD1 0 } ok
T{ : cd2 2constant ; -> }T  ok
T{ -1 -2 cd2 2c2 -> }T WRONG NUMBER OF RESULTS: T{ -1 -2 cd2 2c2 -> }T ACTUAL RESULT: { -1 -1 } ok
T{ 2c2 -> -1 -2 }T WRONG NUMBER OF RESULTS: T{ 2c2 -> -1 -2 }T ACTUAL RESULT: { -2 -1 } ok
T{ 4 5 2constant 2c3 immediate 2c3 -> 4 5 }T >onstant< Undefined word
T{ : cd6 2c3 2literal ; cd6 -> 4 5 }T >:< Undefined word
  ok
max-int 2/ constant hi-int \ 001...1  >max-int< Undefined word
min-int 2/ constant lo-int \ 110...1 >min-int< Undefined word
  ok
1s max-int  2constant max-2int \ 01...1  >s< Undefined word
0 min-int   2constant min-2int \ 10...0  >min-int< Undefined word
max-2int 2/ 2constant hi-2int  \ 001...1  >max-2int< Undefined word
min-2int 2/ 2constant lo-2int  \ 110...0 >min-2int< Undefined word
  ok
T{ : cd1 [ max-2int ] 2literal ; -> }T >:< Undefined word
T{ cd1 -> max-2int }T >max-2int< Undefined word
T{ 2variable 2v4 immediate 5 6 2v4 2! -> }T WRONG NUMBER OF RESULTS: T{ 2variable 2v4 immediate 5 6 2v4 2! -> }T ACTUAL RESULT: { 5 0 } ok
T{ : cd7 2v4 [ 2@ ] 2literal ; cd7 -> 5 6 }T >:< Undefined word
T{ : cd8 [ 6 7 ] 2v4 [ 2! ] ; 2v4 2@ -> 6 7 }T >:< Undefined word
  ok
T{  hi-2int       1. d+ -> 0 hi-int 1+ }T     \ large double integers  >hi-2int< Undefined word
T{  hi-2int     2dup d+ -> 1s 1- max-int }T >hi-2int< Undefined word
T{ max-2int min-2int d+ -> -1. }T >max-2int< Undefined word
T{ max-2int  lo-2int d+ -> hi-2int }T >max-2int< Undefined word
T{  lo-2int     2dup d+ -> min-2int }T >lo-2int< Undefined word
T{  hi-2int min-2int d+ 1. d+ -> lo-2int }T >hi-2int< Undefined word
  ok
T{  0.  5. d- -> -5. }T              \ small integers  >-< Undefined word
T{  5.  0. d- ->  5. }T  >-< Undefined word
T{  0. -5. d- ->  5. }T  >-< Undefined word
T{  1.  2. d- -> -1. }T  >-< Undefined word
T{  1. -2. d- ->  3. }T  >-< Undefined word
T{ -1.  2. d- -> -3. }T  >-< Undefined word
T{ -1. -2. d- ->  1. }T  >-< Undefined word
T{ -1. -1. d- ->  0. }T  >-< Undefined word
T{  0  0  0  5 d- ->  0 -5 }T        \ mid-range integers  >-< Undefined word
T{ -1  5  0  0 d- -> -1  5 }T  >-< Undefined word
T{  0  0 -1 -5 d- ->  1  4 }T  >-< Undefined word
T{  0 -5  0  0 d- ->  0 -5 }T  >-< Undefined word
T{ -1  1  0  2 d- -> -1 -1 }T  >-< Undefined word
T{  0  1 -1 -2 d- ->  1  2 }T  >-< Undefined word
T{  0 -1  0  2 d- ->  0 -3 }T  >-< Undefined word
T{  0 -1  0 -2 d- ->  0  1 }T  >-< Undefined word
T{  0  0  0  1 d- ->  0 -1 }T >-< Undefined word
T{ min-int 0 2dup d- -> 0. }T  >min-int< Undefined word
T{ min-int s>d max-int 0 d- -> 1 1s }T  >min-int< Undefined word
  ok
T{ max-2int max-2int d- -> 0. }T    \ large integers  >max-2int< Undefined word
T{ min-2int min-2int d- -> 0. }T >min-2int< Undefined word
T{ max-2int  hi-2int d- -> lo-2int dnegate }T  >max-2int< Undefined word
T{  hi-2int  lo-2int d- -> max-2int }T >hi-2int< Undefined word
T{  lo-2int  hi-2int d- -> min-2int 1. d+ }T >lo-2int< Undefined word
T{ min-2int min-2int d- -> 0. }T >min-2int< Undefined word
T{ min-2int  lo-2int d- -> lo-2int }T >min-2int< Undefined word
  ok
( TODO m*/ not implemented )  >(< Undefined word
  ok
\ max-2int 71 73 m*/ 2constant dbl1  >\< Undefined word
\ min-2int 73 79 m*/ 2constant dbl2 >\< Undefined word
\ : d>ascii ( d -- caddr u )  >\< Undefined word
   \ dup >r <# dabs #s r> sign #>    ( -- caddr1 u )  >\< Undefined word
   \ here swap 2dup 2>r chars dup allot move 2r>  >\< Undefined word
\ ; >\< Undefined word
  ok
\ dbl1 d>ascii 2constant "dbl1"  >\< Undefined word
\ dbl2 d>ascii 2constant "dbl2" >\< Undefined word
  ok
\ : doubleoutput  >\< Undefined word
   \ cr ." you should see lines duplicated:" cr  >\< Undefined word
   \ 5 spaces "dbl1" type cr  >\< Undefined word
   \ 5 spaces dbl1 d. cr  >\< Undefined word
   \ 8 spaces "dbl1" dup >r type cr  >\< Undefined word
   \ 5 spaces dbl1 r> 3 + d.r cr  >\< Undefined word
   \ 5 spaces "dbl2" type cr  >\< Undefined word
   \ 5 spaces dbl2 d. cr  >\< Undefined word
   \ 10 spaces "dbl2" dup >r type cr  >\< Undefined word
   \ 5 spaces dbl2 r> 5 + d.r cr  >\< Undefined word
\ ; >\< Undefined word
  ok
\ T{ doubleoutput -> }T >\< Undefined word
  ok
( TODO D0< not implemented yet ) >(< Undefined word
( TODO D0= not implemented yet ) >(< Undefined word
( TODO D2* not implemented yet ) >(< Undefined word
( TODO D2/ not implemented yet ) >(< Undefined word
( TODO D< not implemented yet ) >(< Undefined word
( TODO D= not implemented yet ) >(< Undefined word
  ok
T{    1234  0 d>s ->  1234   }T  >>s< Undefined word
T{   -1234 -1 d>s -> -1234   }T  >>s< Undefined word
T{ max-int  0 d>s -> max-int }T  >max-int< Undefined word
T{ min-int -1 d>s -> min-int }T >min-int< Undefined word
  ok
T{       1. dabs -> 1.       }T  >s< Undefined word
T{      -1. dabs -> 1.       }T  >s< Undefined word
T{ max-2int dabs -> max-2int }T  >max-2int< Undefined word
T{ min-2int 1. d+ dabs -> max-2int }T >min-2int< Undefined word
  ok
( TODO DMAX not implemented yet ) >(< Undefined word
( TODO DMIN not implemented yet ) >(< Undefined word
  ok
T{ 0. dnegate -> 0. }T >negate< Undefined word
T{ 1. dnegate -> -1. }T >negate< Undefined word
T{ -1. dnegate -> 1. }T >negate< Undefined word
T{ max-2int dnegate -> min-2int swap 1+ swap }T >max-2int< Undefined word
T{ min-2int swap 1+ swap dnegate -> max-2int }T >min-2int< Undefined word
  ok
( TODO M*/ not implemented yet ) >(< Undefined word
( TODO M+ not implemented yet ) >(< Undefined word
( TODO 2ROT not implemented yet ) >(< Undefined word
( TODO 2VALUE not implemented yet ) >(< Undefined word
( TODO DU< not implemented yet ) >(< Undefined word
  ok
\ Free memory used for these tests >\< Undefined word
double_tests >ouble_tests< Undefined word
  ok
 ( Running test 'facility' from file 'facility.fs' ) >(< Undefined word
\ ------------------------------------------------------------------------ >\< Undefined word
testing facility words: at-xy page   ok
  ok
( TODO AT-XY test missing ) >(< Undefined word
( TODO PAGE test missing ) >(< Undefined word
  ok
 ( Running test 'ed' from file 'ed.fs' ) >(< Undefined word
\ ------------------------------------------------------------------------ >\< Undefined word
testing editor words: ed  ok
  ok
\ TODO Rewrite compare strings once s\" is online (check for linefeed character) >\< Undefined word
  ok
decimal >imal< Undefined word
marker ed-tests  >marker< Undefined word
  ok
\ Use 10000 (decimal) as write area. This may have to be changed if tests crash >\< Undefined word
\ to a higher value. Currently, we are already using 7000 (check with HERE). >\< Undefined word
\ Note ed tests will usually return with ( 0 0 ) on the stack because of the  >\< Undefined word
\ target address >\< Undefined word
  ok
\ === SIMPLE TESTS === >\< Undefined word
  ok
\ --- a command --- >\< Undefined word
  ok
\ Simple adding of text; want aaaa bbbb >\< Undefined word
ed  ok
a  ok
aaaa  ok
bbbb  ok
.  ok
10000w >w< Undefined word
q >q< Undefined word
  ok
T{ 10000 10  s\" aaaa\nbbbb\n" compare -> 10000 10 0 }T >s\"< Undefined word
  ok
\ Add text to end of existing text; want aaaa bbbb cccc >\< Undefined word
ed  ok
a  ok
aaaa  ok
bbbb  ok
.  ok
a  ok
cccc  ok
.  ok
10000w >w< Undefined word
q >q< Undefined word
T{ 10000 15  s\" aaaa\nbbbb\ncccc\n" compare -> 10000 15 0 }T >s\"< Undefined word
  ok
  ok
\ Add a line between two lines of existing text >\< Undefined word
\ Want aaaa cccc bbbb >\< Undefined word
ed  ok
a  ok
aaaa  ok
bbbb  ok
.  ok
1a  ok
cccc  ok
.  ok
10000w >w< Undefined word
q >q< Undefined word
T{ 10000 15  s\" aaaa\ncccc\nbbbb\n" compare -> 10000 15 0 }T >s\"< Undefined word
  ok
\ Add two lines between two existing lines of existing text >\< Undefined word
\ Want: aaaa cccc dddd bbbb >\< Undefined word
ed  ok
a  ok
aaaa  ok
bbbb  ok
.  ok
1a  ok
cccc  ok
dddd  ok
.  ok
10000w >w< Undefined word
q >q< Undefined word
T{ 10000 20  s\" aaaa\ncccc\ndddd\nbbbb\n" compare -> 10000 20 0 }T >s\"< Undefined word
  ok
\ Add a line above existing text; want bbbb aaaa  >\< Undefined word
ed  ok
a  ok
aaaa  ok
.  ok
0a  ok
bbbb  ok
.  ok
10000w >w< Undefined word
q >q< Undefined word
T{ 10000 10  s\" bbbb\naaaa\n" compare -> 10000 10 0 }T >s\"< Undefined word
  ok
  ok
\ --- d command --- >\< Undefined word
  ok
\ Delete first of two lines; want bbbb >\< Undefined word
ed  ok
a  ok
aaaa  ok
bbbb  ok
.  ok
1d  ok
10000w >w< Undefined word
q >q< Undefined word
T{ 10000 5  s\" bbbb\n" compare -> 10000 5 0 }T >s\"< Undefined word
  ok
\ Delete second of two lines; want aaaa >\< Undefined word
ed  ok
a  ok
aaaa  ok
bbbb  ok
.  ok
2d  ok
10000w >w< Undefined word
q >q< Undefined word
T{ 10000 5  s\" aaaa\n" compare -> 10000 5 0 }T >s\"< Undefined word
  ok
\ === END OF ED TESTS === >\< Undefined word
  ok
\ Free memory used for these tests >\< Undefined word
ed-tests >-tests< Undefined word
  ok
 ( Running test 'asm' from file 'asm.fs' ) >(< Undefined word
\ ------------------------------------------------------------------------ >\< Undefined word
testing assembler words  ok
  ok
marker asm-tests  >marker< Undefined word
hex >hex< Undefined word
  ok
\ Add assembler wordlist. This currently kills <true> >\< Undefined word
forth-wordlist assembler-wordlist 2 set-order >orth-wordlist< Undefined word
  ok
\ Test code length and correct operand insertion >\< Undefined word
: opcode-test ( opc len addr u -- f ) >:< Undefined word
   here        ( opc len addr u here0 ) >here< Undefined word
   dup >r      ( opc len addr u here0 ) ( R: here0 ) >up< Undefined word
   -rot        ( opc len here0 addr u ) ( R: here0 ) >rot< Undefined word
   evaluate    ( opc len here0 ) ( R: here0 ) >valuate< Undefined word
  ok
   \ See if length is correct >\< Undefined word
   here swap -    ( opc len n ) ( R: here0 ) >here< Undefined word
   =              ( opc f ) ( R: here0 ) >=< Undefined word
   swap           ( f opc ) ( R: here0 ) >swap< Undefined word
  ok
   \ See if opcode is correct. We can't use AND for the last step because that >\< Undefined word
   \ is replaced by the assembler instruction of the same name >\< Undefined word
   r> c@          ( f opc c ) >r>< Undefined word
   =              ( f f )  >=< Undefined word
; >;< Undefined word
  ok
\ Test for little endian behavior with three-byte instructions >\< Undefined word
\ For instance, 'sta 1122' must become 8D 22 11. Note that Tali stores the cell >\< Undefined word
\ values little-endian as well, which makes this test confusing at first glance. >\< Undefined word
\ Insert  CR DUP 3 DUMP CR  after EVALUTE to convince yourself that this is okay >\< Undefined word
: little-endian? ( u-want addr u -- f ) >:< Undefined word
   here -rot      ( u-want here0 addr u ) >here< Undefined word
   evaluate       ( u-want here0 ) >valuate< Undefined word
   \ cr dup 3 dump cr   \ Manual check, insert if paranoia attacks >\< Undefined word
   1+             ( u-want here0+1 ) \ Skip opcode >+< Undefined word
   @              ( u-want u-have ) >@< Undefined word
   =              ( f )  >=< Undefined word
; >;< Undefined word
  ok
\ Test correct operand for two-byte instructions. Note there is little >\< Undefined word
\ difference between this code and little-endian? at the moment. However, this >\< Undefined word
\ routine here will have to modified for branch instructions at a later date. >\< Undefined word
: correct-operand? ( u-want addr u -- f ) >:< Undefined word
   here -rot      ( u-want here0 addr u ) >here< Undefined word
   evaluate       ( u-want here0 ) >valuate< Undefined word
   1+             ( u-want here0+1 ) >+< Undefined word
   c@             ( u-want u-got ) >@< Undefined word
   =              ( f ) >=< Undefined word
;  >;< Undefined word
  ok
\ -------------------------------------------------------------------------- >\< Undefined word
  ok
\ Testing pseudo-instructions >\< Undefined word
T{ here  0a lda.# push-a rts  execute -> 0a }T >here< Undefined word
  ok
\ Testing a two-byte instruction for correct operand handling >\< Undefined word
T{ 12 s" 12 lda.#" correct-operand? -> -1 }T >s"< Undefined word
  ok
\ Testing a three-byte instruction for little endian handling >\< Undefined word
T{ 1122 s" 1122 sta" little-endian? -> -1 }T >s"< Undefined word
  ok
\ Testing all assembler instructions: Opcode and length >\< Undefined word
T{ 069 2 s" 12 adc.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 07D 3 s" 1122 adc.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 079 3 s" 1122 adc.y" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 065 2 s" 12 adc.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 072 2 s" 12 adc.zi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 071 2 s" 12 adc.ziy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 075 2 s" 12 adc.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 061 2 s" 12 adc.zxi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 02D 3 s" 1122 and" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 029 2 s" 12 and.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 03D 3 s" 1122 and.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 039 3 s" 1122 and.y" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 025 2 s" 12 and.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 032 2 s" 12 and.zi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 031 2 s" 12 and.ziy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 035 2 s" 12 and.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 021 2 s" 12 and.zxi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 00E 3 s" 1122 asl" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 00A 1 s" asl.a" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 01E 3 s" 1122 asl.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 006 2 s" 12 asl.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 016 2 s" 12 asl.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 090 2 s" 12 bcc" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0B0 2 s" 12 bcs" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0F0 2 s" 12 beq" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 02C 3 s" 1122 bit" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 089 2 s" 12 bit.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 03C 3 s" 1122 bit.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 024 2 s" 12 bit.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 034 2 s" 12 bit.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 030 2 s" 12 bmi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0D0 2 s" 12 bne" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 010 2 s" 12 bpl" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 080 2 s" 12 bra" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 000 2 s" 12 brk" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 050 2 s" 12 bvc" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 070 2 s" 12 bvs" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 018 1 s" clc" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0D8 1 s" cld" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 058 1 s" cli" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0B8 1 s" clv" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0CD 3 s" 1122 cmp" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0C9 2 s" 12 cmp.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0DD 3 s" 1122 cmp.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0D9 3 s" 1122 cmp.y" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0C5 2 s" 12 cmp.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0D2 2 s" 12 cmp.zi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0D1 2 s" 12 cmp.ziy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0D5 2 s" 12 cmp.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0C1 2 s" 12 cmp.zxi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0EC 3 s" 1122 cpx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0E0 2 s" 12 cpx.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0E4 2 s" 12 cpx.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0CC 3 s" 1122 cpy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0C0 2 s" 12 cpy.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0C4 2 s" 12 cpy.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0CE 3 s" 1122 dec" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 03A 1 s" dec.a" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0DE 3 s" 1122 dec.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0C6 2 s" 12 dec.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0D6 2 s" 12 dec.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0CA 1 s" dex" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 088 1 s" dey" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 04D 3 s" 1122 eor" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 049 2 s" 12 eor.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 05D 3 s" 1122 eor.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 059 3 s" 1122 eor.y" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 045 2 s" 12 eor.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 052 2 s" 12 eor.zi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 051 2 s" 12 eor.ziy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 055 2 s" 12 eor.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 041 2 s" 12 eor.zxi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0EE 3 s" 1122 inc" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 01A 1 s" inc.a" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0FE 3 s" 1122 inc.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0E6 2 s" 12 inc.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0F6 2 s" 12 inc.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0E8 1 s" inx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0C8 1 s" iny" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 04C 3 s" 1122 jmp" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 06C 3 s" 1122 jmp.i" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 07C 3 s" 1122 jmp.xi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 020 3 s" 1122 jsr" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0AD 3 s" 1122 lda" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0A9 2 s" 12 lda.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0BD 3 s" 1122 lda.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0B9 3 s" 1122 lda.y" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0A5 2 s" 12 lda.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0B2 2 s" 12 lda.zi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0B1 2 s" 12 lda.ziy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0B5 2 s" 12 lda.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0A1 2 s" 12 lda.zxi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0AE 3 s" 1122 ldx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0A2 2 s" 12 ldx.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0BE 3 s" 1122 ldx.y" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0A6 2 s" 12 ldx.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0B6 2 s" 12 ldx.zy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0AC 3 s" 1122 ldy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0A0 2 s" 12 ldy.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0BC 3 s" 1122 ldy.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0A4 2 s" 12 ldy.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0B4 2 s" 12 ldy.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 04E 3 s" 1122 lsr" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 04A 1 s" lsr.a" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 05E 3 s" 1122 lsr.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 046 2 s" 12 lsr.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 056 2 s" 12 lsr.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0EA 1 s" nop" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 00D 3 s" 1122 ora" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 009 2 s" 12 ora.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 01D 3 s" 1122 ora.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 019 3 s" 1122 ora.y" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 005 2 s" 12 ora.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 012 2 s" 12 ora.zi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 011 2 s" 12 ora.ziy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 015 2 s" 12 ora.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 001 2 s" 12 ora.zxi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 048 1 s" pha" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 008 1 s" php" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0DA 1 s" phx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 05A 1 s" phy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 068 1 s" pla" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 028 1 s" plp" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0FA 1 s" plx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 07A 1 s" ply" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 02E 3 s" 1122 rol" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 02A 1 s" rol.a" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 03E 3 s" 1122 rol.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 026 2 s" 12 rol.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 036 2 s" 12 rol.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 06E 3 s" 1122 ror" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 06A 1 s" ror.a" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 07E 3 s" 1122 ror.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 066 2 s" 12 ror.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 076 2 s" 12 ror.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 040 1 s" rti" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 060 1 s" rts" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0ED 3 s" 1122 sbc" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0E9 2 s" 12 sbc.#" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0FD 3 s" 1122 sbc.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0F9 3 s" 1122 sbc.y" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0E5 2 s" 12 sbc.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0F2 2 s" 12 sbc.zi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0F1 2 s" 12 sbc.ziy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0F5 2 s" 12 sbc.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0E1 2 s" 12 sbc.zxi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 038 1 s" sec" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0F8 1 s" sed" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 078 1 s" sei" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 08D 3 s" 1122 sta" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 09D 3 s" 1122 sta.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 099 3 s" 1122 sta.y" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 085 2 s" 12 sta.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 092 2 s" 12 sta.zi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 091 2 s" 12 sta.ziy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 095 2 s" 12 sta.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 081 2 s" 12 sta.zxi" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 08E 3 s" 1122 stx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 086 2 s" 12 stx.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 096 2 s" 12 stx.zy" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 08C 3 s" 1122 sty" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 084 2 s" 12 sty.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 094 2 s" 12 sty.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 09C 3 s" 1122 stz" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 09E 3 s" 1122 stz.x" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 064 2 s" 12 stz.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 074 2 s" 12 stz.zx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0AA 1 s" tax" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0A8 1 s" tay" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 01C 3 s" 1122 trb" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 014 2 s" 12 trb.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 00C 3 s" 1122 tsb" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 004 2 s" 12 tsb.z" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 0BA 1 s" tsx" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 08A 1 s" txa" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 09A 1 s" txs" opcode-test -> -1 -1 }T >s"< Undefined word
T{ 098 1 s" tya" opcode-test -> -1 -1 }T >s"< Undefined word
  ok
\ Testing directives >\< Undefined word
\ TODO currently no directives available >\< Undefined word
  ok
\ Return to original state >\< Undefined word
decimal ( only forth ) asm-tests >imal< Undefined word
  ok
 ( Running test 'stringlong' from file 'stringlong.fs' ) >(< Undefined word
\ ------------------------------------------------------------------------ >\< Undefined word
testing long strings  ok
decimal >imal< Undefined word
  ok
marker long_string_tests >marker< Undefined word
  ok
\ We keep this separate for now because it takes a long, long time -- don't be >\< Undefined word
\ suprised if the delay (-d) for talitest.py has to be set to 0.04 secs.  Once >\< Undefined word
\ the interface to py65 has been cleaned up, this might be intergrated again. >\< Undefined word
\ These are Tali-specific tests, the ANSI test suite has nothing like this. >\< Undefined word
  ok
\ Test strings longer than 255 chars (important for 8-bit systems) >\< Undefined word
\ 516 character string >\< Undefined word
: s14 s" test                                                                                                                                                                                                                                                  >:< Undefined word
                                                                                                                                                                                                                                                                ok
               " ; >"< Undefined word
T{ s14 swap drop -> 516 }T >s14< Undefined word
T{ s14 -trailing -> s14 drop 4 }T >s14< Undefined word
  ok
: s15 ." abcdefghijklmnopqrstuvwxyz1abcdefghijklmnopqrstuvwxyz2abcdefghijklmnopqrstuvwxyz3abcdefghijklmnopqrstuvwxyz4abcdefghijklmnopqrstuvwxyz5abcdefghijklmnopqrstuvwxyz6abcdefghijklmnopqrstuvwxyz7abcdefghijklmnopqrstuvwxyz8abcdefghijklmnopqrstuvwxyz9abc>:< Undefined word
defghijklmnopqrstuvwxyz10abcdefghijklmnopqrstuvwxyz11abcdefghijklmnopqrstuvwxyz12abcdefghijklmnopqrstuvwxyz13abcdefghijklmnopqrstuvwxyz14abcdefghijklmnopqrstuvwxyz15abcdefghijklmnopqrstuvwxyz16abcdefghijklmnopqrstuvwxyz17abcdefghijklmnopqrstuvwxyz18abcdef>ghijklmnopqrstuvwxyz10abcdefghijklmnopqrstuvwxyz11abcdefghijklmnopqrstuvwxyz12abcdefghijklmnopqrstuvwxyz13abcdefghijklmnopqrstuvwxyz14abcdefghijklmnopqrstuvwxyz15abcdefghijklmnopqrstuvwxyz16abcdefghijklmnopqrstuvwxyz17abcdefghijklmnopqrstuvwxyz18abcdef< Undefined word
ghijklmnopqrstuvwxyz19abcdefghijklmnopqrstuvwxyz20" ; >ghijklmnopqrstuvwxyz19abcdefghijklmnopqrstuvwxyz20"< Undefined word
\ This should output the alphabet 20 times. >\< Undefined word
T{ s15 -> }T >s15< Undefined word
  ok
\ Free memory used for these tests >\< Undefined word
long_string_tests >long_string_tests< Undefined word
  ok
 ( Running test 'tali' from file 'tali.fs' ) >(< Undefined word
\ ------------------------------------------------------------------------ >\< Undefined word
hex >hex< Undefined word
  ok
marker tali_tests >marker< Undefined word
  ok
  ok
\ Repeat definitions for standalone testing >\< Undefined word
0 constant 0s >onstant< Undefined word
0 invert constant 1s >invert< Undefined word
0s constant <false> >s< Undefined word
1s constant <true> >s< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing gforth words: bounds find-name latestxt name>int name>string  ok
\ Test for COLD not implemented >\< Undefined word
  ok
( TODO NAME>INT test missing) >(< Undefined word
( TODO NAME>STRING test missing) >(< Undefined word
  ok
\ Test for FIND-NAME assumes that PARSE-NAME has been tested in core.fs >\< Undefined word
T{ parse-name drop     find-name  0<> -> <true> }T \ need to find any nt >parse-name< Undefined word
T{ parse-name Chatika  find-name  0=  -> <true> }T \ shouldn't find Tali's drone >parse-name< Undefined word
  ok
T{ hex -> }T >hex< Undefined word
T{ 1000 10 bounds -> 1010 1000 }T >ounds< Undefined word
T{ ffff 2 bounds -> 0001 ffff }T  \ BOUNDS wraps on Tali with 16 bit address space >ounds< Undefined word
T{ decimal -> }T >imal< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
\ testing tali-only words: cleave hexstore >\< Undefined word
  ok
\ Cleave: Normal cases. KNOWN issue: CLEAVE fails if we have multiple >\< Undefined word
\ delimiters, for example "aaa  bbb" with two strings. This is also true if we >\< Undefined word
\ start the string with a delimiter >\< Undefined word
  ok
T{ : s1 s" " ; -> }T \ case 1: empty string >:< Undefined word
T{ s1 bl cleave  s" " compare  -rot  s" " compare -> 0 0 }T >s1< Undefined word
  ok
T{ : s1 s" aaa" ; -> }T  \ case 2: one word >:< Undefined word
T{ s1 bl cleave  s" aaa" compare  -rot  s" " compare -> 0 0 }T >s1< Undefined word
  ok
T{ : s1 s" aaa bbb ccc" ; -> }T  \ case 3: lots of words, single space delimiter >:< Undefined word
T{ s1 bl cleave  s" aaa" compare  -rot  s" bbb ccc" compare -> 0 0 }T >s1< Undefined word
  ok
\ TODO fix this >\< Undefined word
\ T{ : s1 s" aaa  bbb  ccc" ; -> }T  \ case 3a: lots of words, multiple space delimiter >\< Undefined word
\ T{ s1 bl cleave  s" aaa" compare  -rot  s" bbb  ccc" compare -> 0 0 }T >\< Undefined word
  ok
T{ : s1 s\" aaa\tbbb\tccc" ; -> }T  \ case 3b: lots of words, tab delimter >:< Undefined word
T{ s1 bl cleave  s" aaa" compare  -rot  s\" bbb\tccc" compare -> 0 0 }T >s1< Undefined word
  ok
T{ : s1 s\" aaa\nbbb\nccc" ; -> }T  \ case 3c: lots of words, EOL delimiter >:< Undefined word
T{ s1 bl cleave  s" aaa" compare  -rot  s\" bbb\nccc" compare -> 0 0 }T >s1< Undefined word
  ok
\ TODO fix this >\< Undefined word
\ T{ : s1 s"  aaa bbb ccc" ; -> }T  \ case 3d: lots of words, start with space delimiter >\< Undefined word
\ T{ s1 bl cleave  s" aaa" compare  -rot  s" bbb ccc" compare -> 0 0 }T >\< Undefined word
  ok
  ok
\ Cleave: Pathological cases >\< Undefined word
  ok
T{ : s1 s"  aaa bbb ccc" ; -> }T \ case 4: Leading space is cleaved >:< Undefined word
T{ s1 bl cleave  s" " compare  -rot  s" aaa bbb ccc" compare -> 0 0 }T >s1< Undefined word
  ok
T{ : s1 s" aaa bbb ccc " ; -> }T \ case 5: Trailing space is left >:< Undefined word
T{ s1 bl cleave  s" aaa" compare  -rot  s" bbb ccc " compare -> 0 0 }T >s1< Undefined word
  ok
T{ : s1 s" aaa " ; -> }T  \ case 6: Trailing space on single word is empty >:< Undefined word
T{ s1 bl cleave  s" aaa" compare  -rot  s" " compare -> 0 0 }T >s1< Undefined word
  ok
T{ : s1 s"  " ; -> }T  \ case 7: Single space as word is two empty words >:< Undefined word
T{ s1 bl cleave  s" " compare  -rot  s" " compare -> 0 0 }T >s1< Undefined word
  ok
  ok
\ Hexstore: Normal cases >\< Undefined word
  ok
create hs-test 5 allot >reate< Undefined word
  ok
decimal >imal< Undefined word
create hs-want-dec  1 c, 2 c, 3 c, 4 c, 5 c,  >reate< Undefined word
T{ s" 1 2 3 4 5" hs-test hexstore  hs-test swap  hs-want-dec 5  compare -> 0 }T >s"< Undefined word
T{ s" 1" hs-test hexstore  hs-test swap  hs-want-dec 1  compare -> 0 }T >s"< Undefined word
  ok
hex >hex< Undefined word
create hs-want-hex  0A c, 0B c, 0C c, 0D c, 0E c,  >reate< Undefined word
T{ s" 0A 0B 0C 0D 0E" hs-test hexstore  hs-test swap  hs-want-hex 5  compare -> 0 }T >s"< Undefined word
T{ s" 0A" hs-test hexstore  hs-test swap  hs-want-hex 1  compare -> 0 }T >s"< Undefined word
  ok
\ Hexstore: Pathological cases >\< Undefined word
  ok
decimal >imal< Undefined word
T{ s" " hs-test hexstore  hs-test swap  s" " compare -> 0 }T >s"< Undefined word
T{ s" emergency" hs-test hexstore  hs-test swap  s" " compare -> 0 }T >s"< Undefined word
T{ s" emergency induction port" hs-test hexstore  hs-test swap  s" " compare -> 0 }T >s"< Undefined word
  ok
create hs-want-dec-path  01 c, 02 c, >reate< Undefined word
T{ s" 01 HONK! 02" hs-test hexstore  hs-test swap  hs-want-dec-path 2 compare -> 0 }T >s"< Undefined word
T{ s" HONK! 01 02" hs-test hexstore  hs-test swap  hs-want-dec-path 2 compare -> 0 }T >s"< Undefined word
T{ s" 01 02 HONK!" hs-test hexstore  hs-test swap  hs-want-dec-path 2 compare -> 0 }T >s"< Undefined word
  ok
\ ------------------------------------------------------------------------ >\< Undefined word
testing tali-only words: always-native bell compile-only digit? int>name  ok
testing tali-only words: latestnt latestxt number 0 1 2  ok
testing tali-only words: allow-native never-native wordsize nc-limit  ok
decimal >imal< Undefined word
  ok
\ Test for 0BRANCH not implemented >\< Undefined word
\ Test for BRANCH not implemented >\< Undefined word
\ Test for DISASM not implemented >\< Undefined word
\ Test for INPUT not implemented >\< Undefined word
\ Test for OUTPUT not implemented >\< Undefined word
\ Test for UF-STRIP not implemented >\< Undefined word
  ok
( TODO BELL test missing) >(< Undefined word
( TODO COMPILE-ONLY test missing) >(< Undefined word
  ok
\ Test int>name, latestnt, latestxt, and wordsize >\< Undefined word
: one 1 ; >:< Undefined word
T{ ' one int>name wordsize    -> 8 }T >'< Undefined word
T{ latestxt int>name wordsize -> 8 }T >latestxt< Undefined word
T{ latestnt wordsize          -> 8 }T >latestnt< Undefined word
  ok
\ One should have been created with NN flag, so it should be compiled >\< Undefined word
\ as a JSR when used (3-bytes). >\< Undefined word
: one-a one ; >:< Undefined word
T{ ' one-a int>name wordsize -> 3 }T >'< Undefined word
  ok
\ Test allow-native >\< Undefined word
: two 1 1 ; allow-native >:< Undefined word
\ This should just barely prevent two from being natively compiled. >\< Undefined word
15 nc-limit ! >nc-limit< Undefined word
: two-a two ; >:< Undefined word
\ This should just barely allow two to be natively compiled. >\< Undefined word
16 nc-limit ! >nc-limit< Undefined word
: two-b two ; >:< Undefined word
  ok
T{ ' two   int>name wordsize -> 16 }T >'< Undefined word
T{ ' two-a int>name wordsize ->  3 }T >'< Undefined word
T{ ' two-b int>name wordsize -> 16 }T >'< Undefined word
  ok
\ Test always-native. >\< Undefined word
: three 2 1 ; always-native >:< Undefined word
\ Three should always natively compile regardless of nc-limit. >\< Undefined word
15 nc-limit ! >nc-limit< Undefined word
: three-a three ; >:< Undefined word
16 nc-limit ! >nc-limit< Undefined word
: three-b three ; >:< Undefined word
  ok
T{ ' three   int>name wordsize -> 16 }T >'< Undefined word
T{ ' three-a int>name wordsize -> 16 }T >'< Undefined word
T{ ' three-b int>name wordsize -> 16 }T >'< Undefined word
\ Sneak in extra tests for latestnt and latestxt. >\< Undefined word
T{ latestnt wordsize           -> 16 }T >latestnt< Undefined word
T{ latestxt int>name wordsize  -> 16 }T >latestxt< Undefined word
  ok
  ok
\ Test never-native. >\< Undefined word
\ Because NN is the default, we have to switch to one of the other modes first. >\< Undefined word
: four 2 2 ; always-native never-native >:< Undefined word
\ Four should never natively compile regardless of nc-limit. >\< Undefined word
\ It will always be a JSR when used in another word. >\< Undefined word
15 nc-limit ! >nc-limit< Undefined word
: four-a four ; >:< Undefined word
16 nc-limit ! >nc-limit< Undefined word
: four-b four ; >:< Undefined word
  ok
T{ ' four   int>name wordsize -> 16 }T >'< Undefined word
T{ ' four-a int>name wordsize ->  3 }T >'< Undefined word
T{ ' four-b int>name wordsize ->  3 }T >'< Undefined word
\ Sneak in extra tests for latestnt and latestxt. >\< Undefined word
T{ latestnt wordsize          ->  3 }T >latestnt< Undefined word
T{ latestxt int>name wordsize ->  3 }T >latestxt< Undefined word
  ok
\ Nothing is too trivial for testing! >\< Undefined word
T{ 0 -> 0 }T  ok
T{ 1 -> 1 }T  ok
T{ 2 -> 2 }T 