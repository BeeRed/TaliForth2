 : ( [char] ) parse 2drop ; immediate : .( [char] ) parse type ; immediate : if postpone 0branch here 0 , ; immediate compile-only : then here swap ! ; immediate compile-only : else postpone branch here 0 , here rot ! ; immediate compile-only : repeat postpone again here swap ! ; immediate compile-only : until postpone 0branch , ; immediate compile-only : while postpone 0branch here 0 , swap ; immediate compile-only : case 0 ; immediate compile-only : of postpone over postpone = postpone if postpone drop ; immediate compile-only : endof postpone else ; immediate compile-only : endcase postpone drop begin ?dup while postpone then repeat ; immediate compile-only : defer! >body ! ; : defer@ >body @ ; : is state @ if postpone ['] postpone defer! else ' defer! then ; immediate : action-of state @ if postpone ['] postpone defer@ else ' defer@ then ; immediate : u.r >r 0 <# #s #> r> over - spaces type ; : .r >r dup abs 0 <# #s rot sign #> r> over - spaces type ; : ud. <# #s #> type space ; : ud.r >r <# #s #> r> over - spaces type ; : d. tuck dabs <# #s rot sign #> type space ; : d.r >r tuck dabs <# #s rot sign #> r> over - spaces type ; : 2constant create swap , , does> dup @ swap cell+ @ ; : 2literal swap postpone literal postpone literal ; immediate : hexstore dup 2>r begin dup 0<> while bl cleave 2>r 0. 2r> >number dup 0= if 2drop d>s r@ c! r> 1+ >r else 2drop 2drop then repeat 2drop 2r> swap - ; decimal : buffer: create allot ; 1024 buffer: blkbuffer variable buffblocknum 0 buffblocknum ! variable buffstatus 0 buffstatus ! defer block-read defer block-write : block-words-deferred cr ." Please assign deferred words BLOCK-READ and BLOCK-WRITE " ." to your routines, eg. " cr ." ' myreadroutine IS BLOCK-READ" cr abort ; ' block-words-deferred is block-read ' block-words-deferred is block-write : save-buffers buffstatus @ 3 = if blkbuffer buffblocknum @ block-write 1 buffstatus ! then ; : block dup buffblocknum @ = if buffstatus @ 1 and if drop blkbuffer exit then then buffstatus @ 3 = if blkbuffer buffblocknum @ block-write then dup buffblocknum ! blkbuffer swap block-read 1 buffstatus ! blkbuffer ; : update buffstatus @ 2 or buffstatus ! ; : buffer buffstatus @ 3 = if blkbuffer buffblocknum @ block-write then buffblocknum ! 1 buffstatus ! blkbuffer ; : empty-buffers 0 buffstatus ! ; : flush save-buffers empty-buffers ; : load blk @ >r dup blk ! block 1024 evaluate r> dup blk ! ?dup if block drop then ; : thru 1+ swap ?do i load loop ; : evaluate blk @ >r 0 blk ! evaluate r> blk ! ; : L scr @ block cr ." Screen #" scr @ 4 u.r 16 0 do cr i 2 u.r space dup i 64 * + 64 type loop cr drop ; : list scr ! L ; : block-ramdrive-init s" decimal 1024 * dup buffer: ramdrive : block-read-ramdrive ramdrive swap 1024 * + swap 1024 move ; : block-write-ramdrive ramdrive swap 1024 * + 1024 move ; ' block-read-ramdrive is block-read ' block-write-ramdrive is block-write ramdrive swap blank" evaluate ; : ONLY forth-wordlist 1 set-order ; : (wordlist) CREATE , DOES> @ >R GET-ORDER NIP R> SWAP SET-ORDER ; FORTH-WORDLIST (wordlist) FORTH : ALSO GET-ORDER OVER SWAP 1+ SET-ORDER ; : PREVIOUS GET-ORDER NIP 1- SET-ORDER ; : ORDER cr get-order 0 ?do dup 0= if ." FORTH-WORDLIST " drop else dup 1 = if ." EDITOR-WORDLIST " drop else dup 2 = if ." ASSEMBLER-WORDLIST " drop else . then then then loop ; cr .( Tali Forth 2 for the 65c02) cr .( Version BETA 15. Nov 2018 ) cr .( Copyright 2014-2018 Scot W. Stevenson) cr .( Tali Forth 2 comes with absolutely NO WARRANTY) cr .( Type 'bye' to exit) cr 